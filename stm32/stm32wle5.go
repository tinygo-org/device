// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from stm32wle5.svd, see https://github.com/tinygo-org/stm32-svd

//go:build stm32 && stm32wle5
// +build stm32,stm32wle5

// STM32WLE5_CM4
//

package stm32

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "STM32WLE5"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// System window watchdog
	IRQ_WWDG = 0

	// External interrupt/event controller
	IRQ_PVD_PVM_3 = 1

	// Real-time clock
	IRQ_TAMP_RTCSTAMP_LSECSS_RTCSSRU = 2

	// Real-time clock
	IRQ_RTC_WKUP = 3

	// Flash
	IRQ_FLASH = 4

	// Reset and clock control
	IRQ_RCC = 5

	// External interrupt/event controller
	IRQ_EXTI0 = 6

	// External interrupt/event controller
	IRQ_EXTI1 = 7

	// External interrupt/event controller
	IRQ_EXTI2 = 8

	// External interrupt/event controller
	IRQ_EXTI3 = 9

	// External interrupt/event controller
	IRQ_EXTI4 = 10

	// Direct memory access controller
	IRQ_DMA1_CH1 = 11

	// Direct memory access controller
	IRQ_DMA1_CH2 = 12

	// Direct memory access controller
	IRQ_DMA1_CH3 = 13

	// Direct memory access controller
	IRQ_DMA1_CH4 = 14

	// Direct memory access controller
	IRQ_DMA1_CH5 = 15

	// Direct memory access controller
	IRQ_DMA1_CH6 = 16

	// Direct memory access controller
	IRQ_DMA1_CH7 = 17

	// Analog to digital convertor
	IRQ_ADC = 18

	// Digital-to-analog converter
	IRQ_DAC = 19

	// Comparator
	IRQ_COMP = 21

	// External interrupt/event controller
	IRQ_EXTI9_5 = 22

	// Advanced-control timers
	IRQ_TIM1_BRK = 23

	// Advanced-control timers
	IRQ_TIM1_UP = 24

	// Advanced-control timers
	IRQ_TIM1_TRG_COM = 25

	// Advanced-control timers
	IRQ_TIM1_CC = 26

	// General-purpose-timers
	IRQ_TIM2 = 27

	// General-purpose timers
	IRQ_TIM16 = 28

	// General-purpose timers
	IRQ_TIM17 = 29

	// Inter-integrated circuit
	IRQ_I2C1_EV = 30

	// Inter-integrated circuit
	IRQ_I2C1_ER = 31

	IRQ_I2C2_EV = 32

	IRQ_I2C2_ER = 33

	// Serial peripheral interface/Inter-IC sound
	IRQ_SPI1 = 34

	IRQ_SPI2S2 = 35

	// Universal synchronous asynchronous receiver transmitter
	IRQ_USART1 = 36

	IRQ_USART2 = 37

	// Universal synchronous asynchronous receiver transmitter
	IRQ_LPUART1 = 38

	// Low-power timer
	IRQ_LPTIM1 = 39

	// Low-power timer
	IRQ_LPTIM2 = 40

	// External interrupt/event controller
	IRQ_EXTI15_10 = 41

	// Real-time clock
	IRQ_RTC_ALARM = 42

	// Low-power timer
	IRQ_LPTIM3 = 43

	// Hardware semaphore
	IRQ_HSEM = 47

	IRQ_I2C3_EV = 48

	IRQ_I2C3_ER = 49

	// External interrupt/event controller
	IRQ_Radio_IRQ_Busy = 50

	// Advanced encryption standard hardware accelerator 1
	IRQ_AES = 51

	// True random number generator
	IRQ_True_RNG = 52

	// Public key accelerator
	IRQ_PKA = 53

	IRQ_DMA2_CH1 = 54

	IRQ_DMA2_CH2 = 55

	IRQ_DMA2_CH3 = 56

	IRQ_DMA2_CH4 = 57

	IRQ_DMA2_CH5 = 58

	IRQ_DMA2_CH6 = 59

	IRQ_DMA2_CH7 = 60

	// DMA request multiplexer
	IRQ_DMAMUX1_OVR = 61

	// Highest interrupt number on this device.
	IRQ_max = 61
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export WWDG_IRQHandler
func interruptWWDG() {
	callHandlers(IRQ_WWDG)
}

//export PVD_PVM_3_IRQHandler
func interruptPVD_PVM_3() {
	callHandlers(IRQ_PVD_PVM_3)
}

//export TAMP_RTCSTAMP_LSECSS_RTCSSRU_IRQHandler
func interruptTAMP_RTCSTAMP_LSECSS_RTCSSRU() {
	callHandlers(IRQ_TAMP_RTCSTAMP_LSECSS_RTCSSRU)
}

//export RTC_WKUP_IRQHandler
func interruptRTC_WKUP() {
	callHandlers(IRQ_RTC_WKUP)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export RCC_IRQHandler
func interruptRCC() {
	callHandlers(IRQ_RCC)
}

//export EXTI0_IRQHandler
func interruptEXTI0() {
	callHandlers(IRQ_EXTI0)
}

//export EXTI1_IRQHandler
func interruptEXTI1() {
	callHandlers(IRQ_EXTI1)
}

//export EXTI2_IRQHandler
func interruptEXTI2() {
	callHandlers(IRQ_EXTI2)
}

//export EXTI3_IRQHandler
func interruptEXTI3() {
	callHandlers(IRQ_EXTI3)
}

//export EXTI4_IRQHandler
func interruptEXTI4() {
	callHandlers(IRQ_EXTI4)
}

//export DMA1_CH1_IRQHandler
func interruptDMA1_CH1() {
	callHandlers(IRQ_DMA1_CH1)
}

//export DMA1_CH2_IRQHandler
func interruptDMA1_CH2() {
	callHandlers(IRQ_DMA1_CH2)
}

//export DMA1_CH3_IRQHandler
func interruptDMA1_CH3() {
	callHandlers(IRQ_DMA1_CH3)
}

//export DMA1_CH4_IRQHandler
func interruptDMA1_CH4() {
	callHandlers(IRQ_DMA1_CH4)
}

//export DMA1_CH5_IRQHandler
func interruptDMA1_CH5() {
	callHandlers(IRQ_DMA1_CH5)
}

//export DMA1_CH6_IRQHandler
func interruptDMA1_CH6() {
	callHandlers(IRQ_DMA1_CH6)
}

//export DMA1_CH7_IRQHandler
func interruptDMA1_CH7() {
	callHandlers(IRQ_DMA1_CH7)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export DAC_IRQHandler
func interruptDAC() {
	callHandlers(IRQ_DAC)
}

//export COMP_IRQHandler
func interruptCOMP() {
	callHandlers(IRQ_COMP)
}

//export EXTI9_5_IRQHandler
func interruptEXTI9_5() {
	callHandlers(IRQ_EXTI9_5)
}

//export TIM1_BRK_IRQHandler
func interruptTIM1_BRK() {
	callHandlers(IRQ_TIM1_BRK)
}

//export TIM1_UP_IRQHandler
func interruptTIM1_UP() {
	callHandlers(IRQ_TIM1_UP)
}

//export TIM1_TRG_COM_IRQHandler
func interruptTIM1_TRG_COM() {
	callHandlers(IRQ_TIM1_TRG_COM)
}

//export TIM1_CC_IRQHandler
func interruptTIM1_CC() {
	callHandlers(IRQ_TIM1_CC)
}

//export TIM2_IRQHandler
func interruptTIM2() {
	callHandlers(IRQ_TIM2)
}

//export TIM16_IRQHandler
func interruptTIM16() {
	callHandlers(IRQ_TIM16)
}

//export TIM17_IRQHandler
func interruptTIM17() {
	callHandlers(IRQ_TIM17)
}

//export I2C1_EV_IRQHandler
func interruptI2C1_EV() {
	callHandlers(IRQ_I2C1_EV)
}

//export I2C1_ER_IRQHandler
func interruptI2C1_ER() {
	callHandlers(IRQ_I2C1_ER)
}

//export I2C2_EV_IRQHandler
func interruptI2C2_EV() {
	callHandlers(IRQ_I2C2_EV)
}

//export I2C2_ER_IRQHandler
func interruptI2C2_ER() {
	callHandlers(IRQ_I2C2_ER)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export SPI2S2_IRQHandler
func interruptSPI2S2() {
	callHandlers(IRQ_SPI2S2)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export LPUART1_IRQHandler
func interruptLPUART1() {
	callHandlers(IRQ_LPUART1)
}

//export LPTIM1_IRQHandler
func interruptLPTIM1() {
	callHandlers(IRQ_LPTIM1)
}

//export LPTIM2_IRQHandler
func interruptLPTIM2() {
	callHandlers(IRQ_LPTIM2)
}

//export EXTI15_10_IRQHandler
func interruptEXTI15_10() {
	callHandlers(IRQ_EXTI15_10)
}

//export RTC_ALARM_IRQHandler
func interruptRTC_ALARM() {
	callHandlers(IRQ_RTC_ALARM)
}

//export LPTIM3_IRQHandler
func interruptLPTIM3() {
	callHandlers(IRQ_LPTIM3)
}

//export HSEM_IRQHandler
func interruptHSEM() {
	callHandlers(IRQ_HSEM)
}

//export I2C3_EV_IRQHandler
func interruptI2C3_EV() {
	callHandlers(IRQ_I2C3_EV)
}

//export I2C3_ER_IRQHandler
func interruptI2C3_ER() {
	callHandlers(IRQ_I2C3_ER)
}

//export Radio_IRQ_Busy_IRQHandler
func interruptRadio_IRQ_Busy() {
	callHandlers(IRQ_Radio_IRQ_Busy)
}

//export AES_IRQHandler
func interruptAES() {
	callHandlers(IRQ_AES)
}

//export True_RNG_IRQHandler
func interruptTrue_RNG() {
	callHandlers(IRQ_True_RNG)
}

//export PKA_IRQHandler
func interruptPKA() {
	callHandlers(IRQ_PKA)
}

//export DMA2_CH1_IRQHandler
func interruptDMA2_CH1() {
	callHandlers(IRQ_DMA2_CH1)
}

//export DMA2_CH2_IRQHandler
func interruptDMA2_CH2() {
	callHandlers(IRQ_DMA2_CH2)
}

//export DMA2_CH3_IRQHandler
func interruptDMA2_CH3() {
	callHandlers(IRQ_DMA2_CH3)
}

//export DMA2_CH4_IRQHandler
func interruptDMA2_CH4() {
	callHandlers(IRQ_DMA2_CH4)
}

//export DMA2_CH5_IRQHandler
func interruptDMA2_CH5() {
	callHandlers(IRQ_DMA2_CH5)
}

//export DMA2_CH6_IRQHandler
func interruptDMA2_CH6() {
	callHandlers(IRQ_DMA2_CH6)
}

//export DMA2_CH7_IRQHandler
func interruptDMA2_CH7() {
	callHandlers(IRQ_DMA2_CH7)
}

//export DMAMUX1_OVR_IRQHandler
func interruptDMAMUX1_OVR() {
	callHandlers(IRQ_DMAMUX1_OVR)
}

// Peripherals.
var (
	// Analog to digital convertor
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x40012400)))

	// Advanced encryption standard hardware accelerator 1
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x58001800)))

	// Comparator
	COMP = (*COMP_Type)(unsafe.Pointer(uintptr(0x40010200)))

	// Cyclic redundancy check calculation unit
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// Digital-to-analog converter
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x40007400)))

	// Microcontroller Debug Unit
	DBGMCU = (*DBGMCU_Type)(unsafe.Pointer(uintptr(0xe0042000)))

	// Direct memory access controller
	DMA1 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// DMA request multiplexer
	DMAMUX = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x40020800)))

	// External interrupt/event controller
	EXTI = (*EXTI_Type)(unsafe.Pointer(uintptr(0x58000800)))

	// Flash
	FLASH = (*Flash_Type)(unsafe.Pointer(uintptr(0x58004000)))

	// General-purpose I/Os
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000000)))

	// General-purpose I/Os
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000400)))

	// General-purpose I/Os
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000800)))

	// General-purpose I/Os
	GPIOH = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48001c00)))

	// Hardware semaphore
	HSEM = (*HSEM_Type)(unsafe.Pointer(uintptr(0x58001400)))

	// Inter-integrated circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Independent watchdog
	IWDG = (*IWDG_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Low-power timer
	LPTIM1 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40007c00)))

	// Low-power timer
	LPTIM2 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40009400)))

	// Low-power timer
	LPTIM3 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40009800)))

	// Universal synchronous asynchronous receiver transmitter
	LPUART = (*USART_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// Memory protection unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Nested vectored interrupt controller
	NVIC_STIR = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000ef00)))

	// Public key accelerator
	PKA = (*PKA_Type)(unsafe.Pointer(uintptr(0x58002000)))

	// Power control
	PWR = (*PWR_Type)(unsafe.Pointer(uintptr(0x58000400)))

	// Reset and clock control
	RCC = (*RCC_Type)(unsafe.Pointer(uintptr(0x58000000)))

	// True random number generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x58001000)))

	// Real-time clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40002800)))

	// System control block
	SCB = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000ed00)))

	// System control block ACTLR
	SCB_ACTRL = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000e008)))

	// Serial peripheral interface/Inter-IC sound
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// SysTick timer
	STK = (*STK_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// System configuration controller
	SYSCFG = (*SYSCFG_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Tamper and backup registers
	TAMP = (*TAMP_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// Advanced-control timers
	TIM1 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40012c00)))

	// General-purpose-timers
	TIM2 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// General-purpose timers
	TIM16 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014400)))

	// General-purpose timers
	TIM17 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014800)))

	// Universal synchronous asynchronous receiver transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40013800)))

	// Voltage reference buffer
	VREFBUF = (*VREFBUF_Type)(unsafe.Pointer(uintptr(0x40010030)))

	// System window watchdog
	WWDG = (*WWDG_Type)(unsafe.Pointer(uintptr(0x40002c00)))

	// Direct memory access controller
	DMA2 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020400)))

	// Inter-integrated circuit
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005800)))

	// Inter-integrated circuit
	I2C3 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005c00)))

	// Serial peripheral interface/Inter-IC sound
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Serial peripheral interface/Inter-IC sound
	SPI3 = (*SPI_Type)(unsafe.Pointer(uintptr(0x58010000)))

	// Universal synchronous asynchronous receiver transmitter
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004400)))
)

// Analog to digital convertor
type ADC_Type struct {
	ISR     volatile.Register32 // 0x0
	IER     volatile.Register32 // 0x4
	CR      volatile.Register32 // 0x8
	CFGR1   volatile.Register32 // 0xC
	CFGR2   volatile.Register32 // 0x10
	SMPR    volatile.Register32 // 0x14
	_       [8]byte
	AWD1TR  volatile.Register32 // 0x20
	AWD2TR  volatile.Register32 // 0x24
	CHSELR0 volatile.Register32 // 0x28
	AWD3TR  volatile.Register32 // 0x2C
	_       [16]byte
	DR      volatile.Register32 // 0x40
	_       [92]byte
	AWD2CR  volatile.Register32 // 0xA0
	AWD3CR  volatile.Register32 // 0xA4
	_       [12]byte
	CALFACT volatile.Register32 // 0xB4
	_       [592]byte
	CCR     volatile.Register32 // 0x308
}

// ADC.ISR: ADC interrupt and status register
func (o *ADC_Type) SetISR_ADRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetISR_ADRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *ADC_Type) SetISR_EOSMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetISR_EOSMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetISR_EOC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetISR_EOC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetISR_EOS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetISR_EOS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetISR_AWD1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetISR_AWD1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetISR_AWD2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetISR_AWD2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetISR_AWD3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetISR_AWD3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetISR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetISR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetISR_CCRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetISR_CCRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}

// ADC.IER: ADC interrupt enable register
func (o *ADC_Type) SetIER_ADRDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIER_ADRDYIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *ADC_Type) SetIER_EOSMPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIER_EOSMPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIER_EOCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIER_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIER_EOSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIER_EOSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIER_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIER_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIER_AWD1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIER_AWD1IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIER_AWD2IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIER_AWD2IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIER_AWD3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIER_AWD3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIER_EOCALIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIER_EOCALIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIER_CCRDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetIER_CCRDYIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}

// ADC.CR: ADC control register
func (o *ADC_Type) SetCR_ADEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR_ADEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ADC_Type) SetCR_ADDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR_ADDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR_ADSTART(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCR_ADSTART() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCR_ADSTP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCR_ADSTP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCR_ADVREGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_Type) GetCR_ADVREGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *ADC_Type) SetCR_ADCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetCR_ADCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// ADC.CFGR1: ADC configuration register 1
func (o *ADC_Type) SetCFGR1_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR1_DMAEN() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}
func (o *ADC_Type) SetCFGR1_DMACFG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCFGR1_DMACFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCFGR1_SCANDIR(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCFGR1_SCANDIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCFGR1_RES(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x18)|value<<3)
}
func (o *ADC_Type) GetCFGR1_RES() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x18) >> 3
}
func (o *ADC_Type) SetCFGR1_ALIGN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCFGR1_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCFGR1_EXTSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC_Type) GetCFGR1_EXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x1c0) >> 6
}
func (o *ADC_Type) SetCFGR1_EXTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc00)|value<<10)
}
func (o *ADC_Type) GetCFGR1_EXTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc00) >> 10
}
func (o *ADC_Type) SetCFGR1_OVRMOD(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCFGR1_OVRMOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCFGR1_CONT(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFGR1_CONT() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFGR1_WAIT(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetCFGR1_WAIT() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetCFGR1_AUTOFF(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetCFGR1_AUTOFF() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetCFGR1_DISCEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCFGR1_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCFGR1_CHSELRMOD(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCFGR1_CHSELRMOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCFGR1_AWD1SGL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCFGR1_AWD1SGL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCFGR1_AWD1EN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCFGR1_AWD1EN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCFGR1_AWD1CH(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetCFGR1_AWD1CH() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x7c000000) >> 26
}

// ADC.CFGR2: ADC configuration register 2
func (o *ADC_Type) SetCFGR2_OVSE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR2_OVSE() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}
func (o *ADC_Type) SetCFGR2_TOVS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCFGR2_TOVS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCFGR2_LFTRIG(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetCFGR2_LFTRIG() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetCFGR2_CKMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *ADC_Type) GetCFGR2_CKMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xc0000000) >> 30
}
func (o *ADC_Type) SetCFGR2_OVSS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1e0)|value<<5)
}
func (o *ADC_Type) GetCFGR2_OVSS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1e0) >> 5
}
func (o *ADC_Type) SetCFGR2_OVSR(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1c)|value<<2)
}
func (o *ADC_Type) GetCFGR2_OVSR() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1c) >> 2
}

// ADC.SMPR: ADC sampling time register
func (o *ADC_Type) SetSMPR_SMP1(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetSMPR_SMP1() uint32 {
	return volatile.LoadUint32(&o.SMPR.Reg) & 0x7
}
func (o *ADC_Type) SetSMPR_SMP2(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x70)|value<<4)
}
func (o *ADC_Type) GetSMPR_SMP2() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x70) >> 4
}
func (o *ADC_Type) SetSMPR_SMPSEL0(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetSMPR_SMPSEL0() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetSMPR_SMPSEL1(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetSMPR_SMPSEL1() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetSMPR_SMPSEL2(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetSMPR_SMPSEL2() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetSMPR_SMPSEL3(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetSMPR_SMPSEL3() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetSMPR_SMPSEL4(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetSMPR_SMPSEL4() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetSMPR_SMPSEL5(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetSMPR_SMPSEL5() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetSMPR_SMPSEL6(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetSMPR_SMPSEL6() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetSMPR_SMPSEL7(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetSMPR_SMPSEL7() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetSMPR_SMPSEL8(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetSMPR_SMPSEL8() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetSMPR_SMPSEL9(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_Type) GetSMPR_SMPSEL9() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x20000) >> 17
}
func (o *ADC_Type) SetSMPR_SMPSEL10(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetSMPR_SMPSEL10() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetSMPR_SMPSEL11(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetSMPR_SMPSEL11() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x80000) >> 19
}
func (o *ADC_Type) SetSMPR_SMPSEL12(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetSMPR_SMPSEL12() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetSMPR_SMPSEL13(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetSMPR_SMPSEL13() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetSMPR_SMPSEL14(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetSMPR_SMPSEL14() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetSMPR_SMPSEL15(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetSMPR_SMPSEL15() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetSMPR_SMPSEL16(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetSMPR_SMPSEL16() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetSMPR_SMPSEL17(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetSMPR_SMPSEL17() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x2000000) >> 25
}

// ADC.AWD1TR: ADC watchdog threshold register
func (o *ADC_Type) SetAWD1TR_LT1(value uint32) {
	volatile.StoreUint32(&o.AWD1TR.Reg, volatile.LoadUint32(&o.AWD1TR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetAWD1TR_LT1() uint32 {
	return volatile.LoadUint32(&o.AWD1TR.Reg) & 0xfff
}
func (o *ADC_Type) SetAWD1TR_HT1(value uint32) {
	volatile.StoreUint32(&o.AWD1TR.Reg, volatile.LoadUint32(&o.AWD1TR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetAWD1TR_HT1() uint32 {
	return (volatile.LoadUint32(&o.AWD1TR.Reg) & 0xfff0000) >> 16
}

// ADC.AWD2TR: ADC watchdog threshold register
func (o *ADC_Type) SetAWD2TR_LT2(value uint32) {
	volatile.StoreUint32(&o.AWD2TR.Reg, volatile.LoadUint32(&o.AWD2TR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetAWD2TR_LT2() uint32 {
	return volatile.LoadUint32(&o.AWD2TR.Reg) & 0xfff
}
func (o *ADC_Type) SetAWD2TR_HT2(value uint32) {
	volatile.StoreUint32(&o.AWD2TR.Reg, volatile.LoadUint32(&o.AWD2TR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetAWD2TR_HT2() uint32 {
	return (volatile.LoadUint32(&o.AWD2TR.Reg) & 0xfff0000) >> 16
}

// ADC.CHSELR0: channel selection register
func (o *ADC_Type) SetCHSELR0_CHSEL(value uint32) {
	volatile.StoreUint32(&o.CHSELR0.Reg, volatile.LoadUint32(&o.CHSELR0.Reg)&^(0x3ffff)|value)
}
func (o *ADC_Type) GetCHSELR0_CHSEL() uint32 {
	return volatile.LoadUint32(&o.CHSELR0.Reg) & 0x3ffff
}

// ADC.AWD3TR: ADC watchdog threshold register
func (o *ADC_Type) SetAWD3TR_LT3(value uint32) {
	volatile.StoreUint32(&o.AWD3TR.Reg, volatile.LoadUint32(&o.AWD3TR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetAWD3TR_LT3() uint32 {
	return volatile.LoadUint32(&o.AWD3TR.Reg) & 0xfff
}
func (o *ADC_Type) SetAWD3TR_HT3(value uint32) {
	volatile.StoreUint32(&o.AWD3TR.Reg, volatile.LoadUint32(&o.AWD3TR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetAWD3TR_HT3() uint32 {
	return (volatile.LoadUint32(&o.AWD3TR.Reg) & 0xfff0000) >> 16
}

// ADC.DR: ADC data register
func (o *ADC_Type) SetDR_DATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetDR_DATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// ADC.AWD2CR: ADC Analog Watchdog 2 Configuration register
func (o *ADC_Type) SetAWD2CR_AWD2CH(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x3ffff)|value)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH() uint32 {
	return volatile.LoadUint32(&o.AWD2CR.Reg) & 0x3ffff
}

// ADC.AWD3CR: ADC Analog Watchdog 3 Configuration register
func (o *ADC_Type) SetAWD3CR_AWD3CH(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x3ffff)|value)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH() uint32 {
	return volatile.LoadUint32(&o.AWD3CR.Reg) & 0x3ffff
}

// ADC.CALFACT: ADC Calibration factor
func (o *ADC_Type) SetCALFACT(value uint32) {
	volatile.StoreUint32(&o.CALFACT.Reg, volatile.LoadUint32(&o.CALFACT.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCALFACT() uint32 {
	return volatile.LoadUint32(&o.CALFACT.Reg) & 0x7f
}

// ADC.CCR: ADC common configuration register
func (o *ADC_Type) SetCCR_VREFEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCCR_VREFEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCCR_TSEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCCR_TSEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCCR_VBATEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCCR_VBATEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetCCR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3c0000)|value<<18)
}
func (o *ADC_Type) GetCCR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x3c0000) >> 18
}

// Advanced encryption standard hardware accelerator 1
type AES_Type struct {
	CR     volatile.Register32 // 0x0
	SR     volatile.Register32 // 0x4
	DINR   volatile.Register32 // 0x8
	DOUTR  volatile.Register32 // 0xC
	KEYR0  volatile.Register32 // 0x10
	KEYR1  volatile.Register32 // 0x14
	KEYR2  volatile.Register32 // 0x18
	KEYR3  volatile.Register32 // 0x1C
	IVR0   volatile.Register32 // 0x20
	IVR1   volatile.Register32 // 0x24
	IVR2   volatile.Register32 // 0x28
	IVR3   volatile.Register32 // 0x2C
	KEYR4  volatile.Register32 // 0x30
	KEYR5  volatile.Register32 // 0x34
	KEYR6  volatile.Register32 // 0x38
	KEYR7  volatile.Register32 // 0x3C
	SUSP0R volatile.Register32 // 0x40
	SUSP1R volatile.Register32 // 0x44
	SUSP2R volatile.Register32 // 0x48
	SUSP3R volatile.Register32 // 0x4C
	SUSP4R volatile.Register32 // 0x50
	SUSP5R volatile.Register32 // 0x54
	SUSP6R volatile.Register32 // 0x58
	SUSP7R volatile.Register32 // 0x5C
}

// AES.CR: control register
func (o *AES_Type) SetCR_NPBLB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00000)|value<<20)
}
func (o *AES_Type) GetCR_NPBLB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00000) >> 20
}
func (o *AES_Type) SetCR_KEYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *AES_Type) GetCR_KEYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *AES_Type) SetCR_CHMOD2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *AES_Type) GetCR_CHMOD2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *AES_Type) SetCR_GCMPH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x6000)|value<<13)
}
func (o *AES_Type) GetCR_GCMPH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x6000) >> 13
}
func (o *AES_Type) SetCR_DMAOUTEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *AES_Type) GetCR_DMAOUTEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *AES_Type) SetCR_DMAINEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *AES_Type) GetCR_DMAINEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *AES_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *AES_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *AES_Type) SetCR_CCFIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *AES_Type) GetCR_CCFIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *AES_Type) SetCR_ERRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetCR_ERRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetCR_CCFC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *AES_Type) GetCR_CCFC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *AES_Type) SetCR_CHMOD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *AES_Type) GetCR_CHMOD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *AES_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *AES_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *AES_Type) SetCR_DATATYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x6)|value<<1)
}
func (o *AES_Type) GetCR_DATATYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x6) >> 1
}
func (o *AES_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// AES.SR: status register
func (o *AES_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *AES_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *AES_Type) SetSR_WRERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *AES_Type) GetSR_WRERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *AES_Type) SetSR_RDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetSR_RDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *AES_Type) SetSR_CCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetSR_CCF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// AES.DINR: data input register
func (o *AES_Type) SetDINR(value uint32) {
	volatile.StoreUint32(&o.DINR.Reg, value)
}
func (o *AES_Type) GetDINR() uint32 {
	return volatile.LoadUint32(&o.DINR.Reg)
}

// AES.DOUTR: data output register
func (o *AES_Type) SetDOUTR(value uint32) {
	volatile.StoreUint32(&o.DOUTR.Reg, value)
}
func (o *AES_Type) GetDOUTR() uint32 {
	return volatile.LoadUint32(&o.DOUTR.Reg)
}

// AES.KEYR0: key register 0
func (o *AES_Type) SetKEYR0(value uint32) {
	volatile.StoreUint32(&o.KEYR0.Reg, value)
}
func (o *AES_Type) GetKEYR0() uint32 {
	return volatile.LoadUint32(&o.KEYR0.Reg)
}

// AES.KEYR1: key register 1
func (o *AES_Type) SetKEYR1(value uint32) {
	volatile.StoreUint32(&o.KEYR1.Reg, value)
}
func (o *AES_Type) GetKEYR1() uint32 {
	return volatile.LoadUint32(&o.KEYR1.Reg)
}

// AES.KEYR2: key register 2
func (o *AES_Type) SetKEYR2(value uint32) {
	volatile.StoreUint32(&o.KEYR2.Reg, value)
}
func (o *AES_Type) GetKEYR2() uint32 {
	return volatile.LoadUint32(&o.KEYR2.Reg)
}

// AES.KEYR3: key register 3
func (o *AES_Type) SetKEYR3(value uint32) {
	volatile.StoreUint32(&o.KEYR3.Reg, value)
}
func (o *AES_Type) GetKEYR3() uint32 {
	return volatile.LoadUint32(&o.KEYR3.Reg)
}

// AES.IVR0: initialization vector register 0
func (o *AES_Type) SetIVR0(value uint32) {
	volatile.StoreUint32(&o.IVR0.Reg, value)
}
func (o *AES_Type) GetIVR0() uint32 {
	return volatile.LoadUint32(&o.IVR0.Reg)
}

// AES.IVR1: initialization vector register 1
func (o *AES_Type) SetIVR1(value uint32) {
	volatile.StoreUint32(&o.IVR1.Reg, value)
}
func (o *AES_Type) GetIVR1() uint32 {
	return volatile.LoadUint32(&o.IVR1.Reg)
}

// AES.IVR2: initialization vector register 2
func (o *AES_Type) SetIVR2(value uint32) {
	volatile.StoreUint32(&o.IVR2.Reg, value)
}
func (o *AES_Type) GetIVR2() uint32 {
	return volatile.LoadUint32(&o.IVR2.Reg)
}

// AES.IVR3: initialization vector register 3
func (o *AES_Type) SetIVR3(value uint32) {
	volatile.StoreUint32(&o.IVR3.Reg, value)
}
func (o *AES_Type) GetIVR3() uint32 {
	return volatile.LoadUint32(&o.IVR3.Reg)
}

// AES.KEYR4: key register 4
func (o *AES_Type) SetKEYR4(value uint32) {
	volatile.StoreUint32(&o.KEYR4.Reg, value)
}
func (o *AES_Type) GetKEYR4() uint32 {
	return volatile.LoadUint32(&o.KEYR4.Reg)
}

// AES.KEYR5: key register 5
func (o *AES_Type) SetKEYR5(value uint32) {
	volatile.StoreUint32(&o.KEYR5.Reg, value)
}
func (o *AES_Type) GetKEYR5() uint32 {
	return volatile.LoadUint32(&o.KEYR5.Reg)
}

// AES.KEYR6: key register 6
func (o *AES_Type) SetKEYR6(value uint32) {
	volatile.StoreUint32(&o.KEYR6.Reg, value)
}
func (o *AES_Type) GetKEYR6() uint32 {
	return volatile.LoadUint32(&o.KEYR6.Reg)
}

// AES.KEYR7: key register 7
func (o *AES_Type) SetKEYR7(value uint32) {
	volatile.StoreUint32(&o.KEYR7.Reg, value)
}
func (o *AES_Type) GetKEYR7() uint32 {
	return volatile.LoadUint32(&o.KEYR7.Reg)
}

// AES.SUSP0R: AES suspend register 0
func (o *AES_Type) SetSUSP0R(value uint32) {
	volatile.StoreUint32(&o.SUSP0R.Reg, value)
}
func (o *AES_Type) GetSUSP0R() uint32 {
	return volatile.LoadUint32(&o.SUSP0R.Reg)
}

// AES.SUSP1R: AES suspend register 1
func (o *AES_Type) SetSUSP1R(value uint32) {
	volatile.StoreUint32(&o.SUSP1R.Reg, value)
}
func (o *AES_Type) GetSUSP1R() uint32 {
	return volatile.LoadUint32(&o.SUSP1R.Reg)
}

// AES.SUSP2R: AES suspend register 2
func (o *AES_Type) SetSUSP2R(value uint32) {
	volatile.StoreUint32(&o.SUSP2R.Reg, value)
}
func (o *AES_Type) GetSUSP2R() uint32 {
	return volatile.LoadUint32(&o.SUSP2R.Reg)
}

// AES.SUSP3R: AES suspend register 3
func (o *AES_Type) SetSUSP3R(value uint32) {
	volatile.StoreUint32(&o.SUSP3R.Reg, value)
}
func (o *AES_Type) GetSUSP3R() uint32 {
	return volatile.LoadUint32(&o.SUSP3R.Reg)
}

// AES.SUSP4R: AES suspend register 4
func (o *AES_Type) SetSUSP4R(value uint32) {
	volatile.StoreUint32(&o.SUSP4R.Reg, value)
}
func (o *AES_Type) GetSUSP4R() uint32 {
	return volatile.LoadUint32(&o.SUSP4R.Reg)
}

// AES.SUSP5R: AES suspend register 5
func (o *AES_Type) SetSUSP5R(value uint32) {
	volatile.StoreUint32(&o.SUSP5R.Reg, value)
}
func (o *AES_Type) GetSUSP5R() uint32 {
	return volatile.LoadUint32(&o.SUSP5R.Reg)
}

// AES.SUSP6R: AES suspend register 6
func (o *AES_Type) SetSUSP6R(value uint32) {
	volatile.StoreUint32(&o.SUSP6R.Reg, value)
}
func (o *AES_Type) GetSUSP6R() uint32 {
	return volatile.LoadUint32(&o.SUSP6R.Reg)
}

// AES.SUSP7R: AES suspend register 7
func (o *AES_Type) SetSUSP7R(value uint32) {
	volatile.StoreUint32(&o.SUSP7R.Reg, value)
}
func (o *AES_Type) GetSUSP7R() uint32 {
	return volatile.LoadUint32(&o.SUSP7R.Reg)
}

// Comparator
type COMP_Type struct {
	COMP1_CSR volatile.Register32 // 0x0
	COMP2_CSR volatile.Register32 // 0x4
}

// COMP.COMP1_CSR: COMP1_CSR
func (o *COMP_Type) SetCOMP1_CSR_LOCK(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetCOMP1_CSR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x80000000) >> 31
}
func (o *COMP_Type) SetCOMP1_CSR_VALUE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *COMP_Type) GetCOMP1_CSR_VALUE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x40000000) >> 30
}
func (o *COMP_Type) SetCOMP1_CSR_INMESEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x6000000)|value<<25)
}
func (o *COMP_Type) GetCOMP1_CSR_INMESEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x6000000) >> 25
}
func (o *COMP_Type) SetCOMP1_CSR_SCALEN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x800000)|value<<23)
}
func (o *COMP_Type) GetCOMP1_CSR_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x800000) >> 23
}
func (o *COMP_Type) SetCOMP1_CSR_BRGEN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x400000)|value<<22)
}
func (o *COMP_Type) GetCOMP1_CSR_BRGEN() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x400000) >> 22
}
func (o *COMP_Type) SetCOMP1_CSR_BLANKING(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x1c0000)|value<<18)
}
func (o *COMP_Type) GetCOMP1_CSR_BLANKING() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x1c0000) >> 18
}
func (o *COMP_Type) SetCOMP1_CSR_HYST(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x30000)|value<<16)
}
func (o *COMP_Type) GetCOMP1_CSR_HYST() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x30000) >> 16
}
func (o *COMP_Type) SetCOMP1_CSR_POLARITY(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *COMP_Type) GetCOMP1_CSR_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x8000) >> 15
}
func (o *COMP_Type) SetCOMP1_CSR_INPSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x180)|value<<7)
}
func (o *COMP_Type) GetCOMP1_CSR_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x180) >> 7
}
func (o *COMP_Type) SetCOMP1_CSR_INMSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x70)|value<<4)
}
func (o *COMP_Type) GetCOMP1_CSR_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x70) >> 4
}
func (o *COMP_Type) SetCOMP1_CSR_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0xc)|value<<2)
}
func (o *COMP_Type) GetCOMP1_CSR_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0xc) >> 2
}
func (o *COMP_Type) SetCOMP1_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetCOMP1_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x1
}

// COMP.COMP2_CSR: COMP2_CSR
func (o *COMP_Type) SetCOMP2_CSR_LOCK(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetCOMP2_CSR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x80000000) >> 31
}
func (o *COMP_Type) SetCOMP2_CSR_VALUE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *COMP_Type) GetCOMP2_CSR_VALUE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x40000000) >> 30
}
func (o *COMP_Type) SetCOMP2_CSR_INMESEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x6000000)|value<<25)
}
func (o *COMP_Type) GetCOMP2_CSR_INMESEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x6000000) >> 25
}
func (o *COMP_Type) SetCOMP2_CSR_SCALEN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x800000)|value<<23)
}
func (o *COMP_Type) GetCOMP2_CSR_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x800000) >> 23
}
func (o *COMP_Type) SetCOMP2_CSR_BRGEN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x400000)|value<<22)
}
func (o *COMP_Type) GetCOMP2_CSR_BRGEN() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x400000) >> 22
}
func (o *COMP_Type) SetCOMP2_CSR_BLANKING(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x1c0000)|value<<18)
}
func (o *COMP_Type) GetCOMP2_CSR_BLANKING() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x1c0000) >> 18
}
func (o *COMP_Type) SetCOMP2_CSR_HYST(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x30000)|value<<16)
}
func (o *COMP_Type) GetCOMP2_CSR_HYST() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x30000) >> 16
}
func (o *COMP_Type) SetCOMP2_CSR_POLARITY(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *COMP_Type) GetCOMP2_CSR_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x8000) >> 15
}
func (o *COMP_Type) SetCOMP2_CSR_WINMODE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x200)|value<<9)
}
func (o *COMP_Type) GetCOMP2_CSR_WINMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x200) >> 9
}
func (o *COMP_Type) SetCOMP2_CSR_INPSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x180)|value<<7)
}
func (o *COMP_Type) GetCOMP2_CSR_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x180) >> 7
}
func (o *COMP_Type) SetCOMP2_CSR_INMSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x70)|value<<4)
}
func (o *COMP_Type) GetCOMP2_CSR_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x70) >> 4
}
func (o *COMP_Type) SetCOMP2_CSR_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0xc)|value<<2)
}
func (o *COMP_Type) GetCOMP2_CSR_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0xc) >> 2
}
func (o *COMP_Type) SetCOMP2_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetCOMP2_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x1
}

// Cyclic redundancy check calculation unit
type CRC_Type struct {
	DR   volatile.Register32 // 0x0
	IDR  volatile.Register32 // 0x4
	CR   volatile.Register32 // 0x8
	_    [4]byte
	INIT volatile.Register32 // 0x10
	POL  volatile.Register32 // 0x14
}

// CRC.DR: Data register
func (o *CRC_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *CRC_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// CRC.IDR: Independent data register
func (o *CRC_Type) SetIDR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, value)
}
func (o *CRC_Type) GetIDR() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg)
}

// CRC.CR: Control register
func (o *CRC_Type) SetCR_REV_OUT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCR_REV_OUT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCR_REV_IN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *CRC_Type) GetCR_REV_IN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *CRC_Type) SetCR_POLYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *CRC_Type) GetCR_POLYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *CRC_Type) SetCR_RESET(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRC_Type) GetCR_RESET() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// CRC.INIT: Initial CRC value
func (o *CRC_Type) SetINIT(value uint32) {
	volatile.StoreUint32(&o.INIT.Reg, value)
}
func (o *CRC_Type) GetINIT() uint32 {
	return volatile.LoadUint32(&o.INIT.Reg)
}

// CRC.POL: polynomial
func (o *CRC_Type) SetPOL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, value)
}
func (o *CRC_Type) GetPOL() uint32 {
	return volatile.LoadUint32(&o.POL.Reg)
}

// Digital-to-analog converter
type DAC_Type struct {
	CR      volatile.Register32 // 0x0
	SWTRGR  volatile.Register32 // 0x4
	DHR12R1 volatile.Register32 // 0x8
	DHR12L1 volatile.Register32 // 0xC
	DHR8R1  volatile.Register32 // 0x10
	_       [12]byte
	DHR12RD volatile.Register32 // 0x20
	DHR12LD volatile.Register32 // 0x24
	DHR8RD  volatile.Register32 // 0x28
	DOR1    volatile.Register32 // 0x2C
	_       [4]byte
	SR      volatile.Register32 // 0x34
	CCR     volatile.Register32 // 0x38
	MCR     volatile.Register32 // 0x3C
	SHSR1   volatile.Register32 // 0x40
	_       [4]byte
	SHHR    volatile.Register32 // 0x48
	SHRR    volatile.Register32 // 0x4C
}

// DAC.CR: control register
func (o *DAC_Type) SetCR_CEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetCR_CEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetCR_DMAUDRIE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetCR_DMAUDRIE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetCR_DMAEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DAC_Type) GetCR_DMAEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DAC_Type) SetCR_MAMP1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetCR_MAMP1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetCR_WAVE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DAC_Type) GetCR_WAVE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DAC_Type) SetCR_TEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCR_TEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCR_EN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCR_EN1() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DAC_Type) SetCR_TSEL1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3c)|value<<2)
}
func (o *DAC_Type) GetCR_TSEL1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3c) >> 2
}

// DAC.SWTRGR: software trigger register
func (o *DAC_Type) SetSWTRGR_SWTRIG1(value uint32) {
	volatile.StoreUint32(&o.SWTRGR.Reg, volatile.LoadUint32(&o.SWTRGR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSWTRGR_SWTRIG1() uint32 {
	return volatile.LoadUint32(&o.SWTRGR.Reg) & 0x1
}

// DAC.DHR12R1: channel1 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R1.Reg, volatile.LoadUint32(&o.DHR12R1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R1.Reg) & 0xfff
}

// DAC.DHR12L1: channel1 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L1.Reg, volatile.LoadUint32(&o.DHR12L1.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L1_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L1.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R1: channel1 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R1.Reg, volatile.LoadUint32(&o.DHR8R1.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R1.Reg) & 0xff
}

// DAC.DHR12RD: Dual DAC 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff
}

// DAC.DHR12LD: Dual DAC 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12LD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12LD_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff0) >> 4
}

// DAC.DHR8RD: Dual DAC 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff
}

// DAC.DOR1: DAC channel1 data output register
func (o *DAC_Type) SetDOR1_DACC1DOR(value uint32) {
	volatile.StoreUint32(&o.DOR1.Reg, volatile.LoadUint32(&o.DOR1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR1_DACC1DOR() uint32 {
	return volatile.LoadUint32(&o.DOR1.Reg) & 0xfff
}

// DAC.SR: status register
func (o *DAC_Type) SetSR_BWST1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *DAC_Type) GetSR_BWST1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *DAC_Type) SetSR_CAL_FLAG1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetSR_CAL_FLAG1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetSR_DMAUDR1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetSR_DMAUDR1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}

// DAC.CCR: calibration control register
func (o *DAC_Type) SetCCR_OTRIM1(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f)|value)
}
func (o *DAC_Type) GetCCR_OTRIM1() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1f
}

// DAC.MCR: mode control register
func (o *DAC_Type) SetMCR_MODE1(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x7)|value)
}
func (o *DAC_Type) GetMCR_MODE1() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x7
}

// DAC.SHSR1: Sample and Hold sample time register 1
func (o *DAC_Type) SetSHSR1_TSAMPLE1(value uint32) {
	volatile.StoreUint32(&o.SHSR1.Reg, volatile.LoadUint32(&o.SHSR1.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR1_TSAMPLE1() uint32 {
	return volatile.LoadUint32(&o.SHSR1.Reg) & 0x3ff
}

// DAC.SHHR: Sample and Hold hold time register
func (o *DAC_Type) SetSHHR_THOLD1(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHHR_THOLD1() uint32 {
	return volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff
}

// DAC.SHRR: Sample and Hold refresh time register
func (o *DAC_Type) SetSHRR_TREFRESH1(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetSHRR_TREFRESH1() uint32 {
	return volatile.LoadUint32(&o.SHRR.Reg) & 0xff
}

// Microcontroller Debug Unit
type DBGMCU_Type struct {
	IDCODER  volatile.Register32 // 0x0
	CR       volatile.Register32 // 0x4
	_        [52]byte
	APB1FZR1 volatile.Register32 // 0x3C
	_        [4]byte
	APB1FZR2 volatile.Register32 // 0x44
	_        [4]byte
	APB2FZR  volatile.Register32 // 0x4C
}

// DBGMCU.IDCODER: DBGMCU Identity Code Register
func (o *DBGMCU_Type) SetIDCODER_DEV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODER.Reg, volatile.LoadUint32(&o.IDCODER.Reg)&^(0xfff)|value)
}
func (o *DBGMCU_Type) GetIDCODER_DEV_ID() uint32 {
	return volatile.LoadUint32(&o.IDCODER.Reg) & 0xfff
}
func (o *DBGMCU_Type) SetIDCODER_REV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODER.Reg, volatile.LoadUint32(&o.IDCODER.Reg)&^(0xffff0000)|value<<16)
}
func (o *DBGMCU_Type) GetIDCODER_REV_ID() uint32 {
	return (volatile.LoadUint32(&o.IDCODER.Reg) & 0xffff0000) >> 16
}

// DBGMCU.CR: DBGMCU Configuration Register
func (o *DBGMCU_Type) SetCR_DBG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetCR_DBG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DBGMCU_Type) SetCR_DBG_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetCR_DBG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetCR_DBG_STANDBY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetCR_DBG_STANDBY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}

// DBGMCU.APB1FZR1: DBGMCU CPU1 APB1 Peripheral Freeze Register 1
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_TIM2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_TIM2_STOP() uint32 {
	return volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_RTC_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x400)|value<<10)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_RTC_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x400) >> 10
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_WWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_WWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x1000)|value<<12)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x1000) >> 12
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_I2C1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x200000)|value<<21)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_I2C1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x200000) >> 21
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_I2C2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x400000)|value<<22)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_I2C2_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x400000) >> 22
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_I2C3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x800000)|value<<23)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_I2C3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x800000) >> 23
}
func (o *DBGMCU_Type) SetAPB1FZR1_DBG_LPTIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR1.Reg, volatile.LoadUint32(&o.APB1FZR1.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGMCU_Type) GetAPB1FZR1_DBG_LPTIM1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR1.Reg) & 0x80000000) >> 31
}

// DBGMCU.APB1FZR2: DBGMCU CPU1 APB1 Peripheral Freeze Register 2
func (o *DBGMCU_Type) SetAPB1FZR2_DBG_LPTIM2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR2.Reg, volatile.LoadUint32(&o.APB1FZR2.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetAPB1FZR2_DBG_LPTIM2_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR2.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetAPB1FZR2_DBG_LPTIM3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1FZR2.Reg, volatile.LoadUint32(&o.APB1FZR2.Reg)&^(0x40)|value<<6)
}
func (o *DBGMCU_Type) GetAPB1FZR2_DBG_LPTIM3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1FZR2.Reg) & 0x40) >> 6
}

// DBGMCU.APB2FZR: DBGMCU CPU1 APB2 Peripheral Freeze Register
func (o *DBGMCU_Type) SetAPB2FZR_DBG_TIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2FZR.Reg, volatile.LoadUint32(&o.APB2FZR.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB2FZR_DBG_TIM1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2FZR.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB2FZR_DBG_TIM16_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2FZR.Reg, volatile.LoadUint32(&o.APB2FZR.Reg)&^(0x20000)|value<<17)
}
func (o *DBGMCU_Type) GetAPB2FZR_DBG_TIM16_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2FZR.Reg) & 0x20000) >> 17
}
func (o *DBGMCU_Type) SetAPB2FZR_DBG_TIM17_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2FZR.Reg, volatile.LoadUint32(&o.APB2FZR.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB2FZR_DBG_TIM17_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2FZR.Reg) & 0x40000) >> 18
}

// Direct memory access controller
type DMA_Type struct {
	ISR    volatile.Register32 // 0x0
	IFCR   volatile.Register32 // 0x4
	CCR1   volatile.Register32 // 0x8
	CNDTR1 volatile.Register32 // 0xC
	CPAR1  volatile.Register32 // 0x10
	CMAR1  volatile.Register32 // 0x14
	_      [4]byte
	CCR2   volatile.Register32 // 0x1C
	CNDTR2 volatile.Register32 // 0x20
	CPAR2  volatile.Register32 // 0x24
	CMAR2  volatile.Register32 // 0x28
	_      [4]byte
	CCR3   volatile.Register32 // 0x30
	CNDTR3 volatile.Register32 // 0x34
	CPAR3  volatile.Register32 // 0x38
	CMAR3  volatile.Register32 // 0x3C
	_      [4]byte
	CCR4   volatile.Register32 // 0x44
	CNDTR4 volatile.Register32 // 0x48
	CPAR4  volatile.Register32 // 0x4C
	CMAR4  volatile.Register32 // 0x50
	_      [4]byte
	CCR5   volatile.Register32 // 0x58
	CNDTR5 volatile.Register32 // 0x5C
	CPAR5  volatile.Register32 // 0x60
	CMAR5  volatile.Register32 // 0x64
	_      [4]byte
	CCR6   volatile.Register32 // 0x6C
	CNDTR6 volatile.Register32 // 0x70
	CPAR6  volatile.Register32 // 0x74
	CMAR6  volatile.Register32 // 0x78
	_      [4]byte
	CCR7   volatile.Register32 // 0x80
	CNDTR7 volatile.Register32 // 0x84
	CPAR7  volatile.Register32 // 0x88
	CMAR7  volatile.Register32 // 0x8C
}

// DMA.ISR: interrupt status register
func (o *DMA_Type) SetISR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetISR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetISR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetISR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetISR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetISR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetISR_GIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetISR_GIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetISR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetISR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetISR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetISR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetISR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetISR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetISR_GIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetISR_GIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetISR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetISR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetISR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetISR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetISR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetISR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetISR_GIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetISR_GIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetISR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetISR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetISR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetISR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetISR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetISR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetISR_GIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetISR_GIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetISR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetISR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetISR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetISR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetISR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetISR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetISR_GIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetISR_GIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetISR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetISR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetISR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetISR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetISR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetISR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetISR_GIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetISR_GIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetISR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetISR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetISR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetISR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetISR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetISR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetISR_GIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetISR_GIF1() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// DMA.IFCR: interrupt flag clear register
func (o *DMA_Type) SetIFCR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetIFCR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetIFCR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetIFCR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetIFCR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetIFCR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetIFCR_GIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetIFCR_GIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetIFCR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetIFCR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetIFCR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetIFCR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetIFCR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetIFCR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetIFCR_GIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetIFCR_GIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetIFCR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetIFCR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetIFCR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetIFCR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetIFCR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetIFCR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetIFCR_GIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetIFCR_GIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetIFCR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetIFCR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetIFCR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetIFCR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetIFCR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetIFCR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetIFCR_GIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIFCR_GIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetIFCR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetIFCR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetIFCR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetIFCR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetIFCR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetIFCR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetIFCR_GIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetIFCR_GIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetIFCR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetIFCR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetIFCR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIFCR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetIFCR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIFCR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIFCR_GIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIFCR_GIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIFCR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIFCR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIFCR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIFCR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIFCR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIFCR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIFCR_GIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIFCR_GIF1() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}

// DMA.CCR1: channel x configuration register
func (o *DMA_Type) SetCCR1_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR1_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR1_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR1_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR1_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR1_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR1_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR1_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR1_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR1_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR1_PL(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR1_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR1_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR1_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR1_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR1_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR1_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR1_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR1_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR1_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR1_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR1_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR1_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR1_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR1_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR1_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR1_EN(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR1_EN() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0x1
}

// DMA.CNDTR1: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR1_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR1.Reg, volatile.LoadUint32(&o.CNDTR1.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR1_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR1.Reg) & 0x3ffff
}

// DMA.CPAR1: channel x peripheral address register
func (o *DMA_Type) SetCPAR1(value uint32) {
	volatile.StoreUint32(&o.CPAR1.Reg, value)
}
func (o *DMA_Type) GetCPAR1() uint32 {
	return volatile.LoadUint32(&o.CPAR1.Reg)
}

// DMA.CMAR1: channel x memory address register
func (o *DMA_Type) SetCMAR1(value uint32) {
	volatile.StoreUint32(&o.CMAR1.Reg, value)
}
func (o *DMA_Type) GetCMAR1() uint32 {
	return volatile.LoadUint32(&o.CMAR1.Reg)
}

// DMA.CCR2: channel x configuration register
func (o *DMA_Type) SetCCR2_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR2_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR2_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR2_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR2_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR2_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR2_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR2_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR2_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR2_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR2_PL(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR2_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR2_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR2_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR2_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR2_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR2_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR2_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR2_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR2_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR2_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR2_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR2_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR2_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR2_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR2_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR2_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR2_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR2_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR2_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR2_EN(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR2_EN() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0x1
}

// DMA.CNDTR2: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR2_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR2.Reg, volatile.LoadUint32(&o.CNDTR2.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR2_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR2.Reg) & 0x3ffff
}

// DMA.CPAR2: channel x peripheral address register
func (o *DMA_Type) SetCPAR2(value uint32) {
	volatile.StoreUint32(&o.CPAR2.Reg, value)
}
func (o *DMA_Type) GetCPAR2() uint32 {
	return volatile.LoadUint32(&o.CPAR2.Reg)
}

// DMA.CMAR2: channel x memory address register
func (o *DMA_Type) SetCMAR2(value uint32) {
	volatile.StoreUint32(&o.CMAR2.Reg, value)
}
func (o *DMA_Type) GetCMAR2() uint32 {
	return volatile.LoadUint32(&o.CMAR2.Reg)
}

// DMA.CCR3: channel x configuration register
func (o *DMA_Type) SetCCR3_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR3_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR3_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR3_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR3_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR3_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR3_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR3_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR3_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR3_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR3_PL(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR3_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR3_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR3_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR3_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR3_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR3_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR3_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR3_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR3_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR3_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR3_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR3_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR3_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR3_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR3_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR3_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR3_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR3_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR3_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR3_EN(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR3_EN() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg) & 0x1
}

// DMA.CNDTR3: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR3_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR3.Reg, volatile.LoadUint32(&o.CNDTR3.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR3_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR3.Reg) & 0x3ffff
}

// DMA.CPAR3: channel x peripheral address register
func (o *DMA_Type) SetCPAR3(value uint32) {
	volatile.StoreUint32(&o.CPAR3.Reg, value)
}
func (o *DMA_Type) GetCPAR3() uint32 {
	return volatile.LoadUint32(&o.CPAR3.Reg)
}

// DMA.CMAR3: channel x memory address register
func (o *DMA_Type) SetCMAR3(value uint32) {
	volatile.StoreUint32(&o.CMAR3.Reg, value)
}
func (o *DMA_Type) GetCMAR3() uint32 {
	return volatile.LoadUint32(&o.CMAR3.Reg)
}

// DMA.CCR4: channel x configuration register
func (o *DMA_Type) SetCCR4_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR4_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR4_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR4_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR4_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR4_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR4_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR4_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR4_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR4_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR4_PL(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR4_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR4_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR4_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR4_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR4_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR4_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR4_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR4_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR4_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR4_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR4_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR4_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR4_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR4_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR4_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR4_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR4_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR4_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR4_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR4_EN(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR4_EN() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg) & 0x1
}

// DMA.CNDTR4: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR4_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR4.Reg, volatile.LoadUint32(&o.CNDTR4.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR4_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR4.Reg) & 0x3ffff
}

// DMA.CPAR4: channel x peripheral address register
func (o *DMA_Type) SetCPAR4(value uint32) {
	volatile.StoreUint32(&o.CPAR4.Reg, value)
}
func (o *DMA_Type) GetCPAR4() uint32 {
	return volatile.LoadUint32(&o.CPAR4.Reg)
}

// DMA.CMAR4: channel x memory address register
func (o *DMA_Type) SetCMAR4(value uint32) {
	volatile.StoreUint32(&o.CMAR4.Reg, value)
}
func (o *DMA_Type) GetCMAR4() uint32 {
	return volatile.LoadUint32(&o.CMAR4.Reg)
}

// DMA.CCR5: channel x configuration register
func (o *DMA_Type) SetCCR5_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR5_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR5_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR5_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR5_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR5_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR5_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR5_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR5_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR5_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR5_PL(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR5_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR5_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR5_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR5_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR5_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR5_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR5_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR5_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR5_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR5_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR5_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR5_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR5_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR5_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR5_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR5_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR5_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR5_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR5_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR5_EN(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR5_EN() uint32 {
	return volatile.LoadUint32(&o.CCR5.Reg) & 0x1
}

// DMA.CNDTR5: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR5_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR5.Reg, volatile.LoadUint32(&o.CNDTR5.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR5_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR5.Reg) & 0x3ffff
}

// DMA.CPAR5: channel x peripheral address register
func (o *DMA_Type) SetCPAR5(value uint32) {
	volatile.StoreUint32(&o.CPAR5.Reg, value)
}
func (o *DMA_Type) GetCPAR5() uint32 {
	return volatile.LoadUint32(&o.CPAR5.Reg)
}

// DMA.CMAR5: channel x memory address register
func (o *DMA_Type) SetCMAR5(value uint32) {
	volatile.StoreUint32(&o.CMAR5.Reg, value)
}
func (o *DMA_Type) GetCMAR5() uint32 {
	return volatile.LoadUint32(&o.CMAR5.Reg)
}

// DMA.CCR6: channel x configuration register
func (o *DMA_Type) SetCCR6_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR6_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR6_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR6_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR6_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR6_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR6_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR6_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR6_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR6_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR6_PL(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR6_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR6_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR6_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR6_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR6_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR6_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR6_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR6_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR6_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR6_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR6_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR6_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR6_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR6_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR6_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR6_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR6_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR6_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR6_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR6_EN(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR6_EN() uint32 {
	return volatile.LoadUint32(&o.CCR6.Reg) & 0x1
}

// DMA.CNDTR6: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR6_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR6.Reg, volatile.LoadUint32(&o.CNDTR6.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR6_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR6.Reg) & 0x3ffff
}

// DMA.CPAR6: channel x peripheral address register
func (o *DMA_Type) SetCPAR6(value uint32) {
	volatile.StoreUint32(&o.CPAR6.Reg, value)
}
func (o *DMA_Type) GetCPAR6() uint32 {
	return volatile.LoadUint32(&o.CPAR6.Reg)
}

// DMA.CMAR6: channel x memory address register
func (o *DMA_Type) SetCMAR6(value uint32) {
	volatile.StoreUint32(&o.CMAR6.Reg, value)
}
func (o *DMA_Type) GetCMAR6() uint32 {
	return volatile.LoadUint32(&o.CMAR6.Reg)
}

// DMA.CCR7: channel x configuration register
func (o *DMA_Type) SetCCR7_PRIV(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetCCR7_PRIV() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetCCR7_DSEC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetCCR7_DSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetCCR7_SSEC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetCCR7_SSEC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetCCR7_SECM(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCCR7_SECM() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCCR7_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR7_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR7_PL(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR7_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR7_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR7_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR7_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR7_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR7_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR7_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR7_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR7_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR7_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR7_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR7_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR7_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR7_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR7_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR7_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR7_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR7_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR7_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR7_EN(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR7_EN() uint32 {
	return volatile.LoadUint32(&o.CCR7.Reg) & 0x1
}

// DMA.CNDTR7: channel x number of data to transfer register
func (o *DMA_Type) SetCNDTR7_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR7.Reg, volatile.LoadUint32(&o.CNDTR7.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetCNDTR7_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR7.Reg) & 0x3ffff
}

// DMA.CPAR7: channel x peripheral address register
func (o *DMA_Type) SetCPAR7(value uint32) {
	volatile.StoreUint32(&o.CPAR7.Reg, value)
}
func (o *DMA_Type) GetCPAR7() uint32 {
	return volatile.LoadUint32(&o.CPAR7.Reg)
}

// DMA.CMAR7: channel x memory address register
func (o *DMA_Type) SetCMAR7(value uint32) {
	volatile.StoreUint32(&o.CMAR7.Reg, value)
}
func (o *DMA_Type) GetCMAR7() uint32 {
	return volatile.LoadUint32(&o.CMAR7.Reg)
}

// DMA request multiplexer
type DMAMUX_Type struct {
	C0CR  volatile.Register32 // 0x0
	C1CR  volatile.Register32 // 0x4
	C2CR  volatile.Register32 // 0x8
	C3CR  volatile.Register32 // 0xC
	C4CR  volatile.Register32 // 0x10
	C5CR  volatile.Register32 // 0x14
	C6CR  volatile.Register32 // 0x18
	C7CR  volatile.Register32 // 0x1C
	C8CR  volatile.Register32 // 0x20
	C9CR  volatile.Register32 // 0x24
	C10CR volatile.Register32 // 0x28
	C11CR volatile.Register32 // 0x2C
	C12CR volatile.Register32 // 0x30
	C13CR volatile.Register32 // 0x34
	_     [72]byte
	CSR   volatile.Register32 // 0x80
	CCFR  volatile.Register32 // 0x84
	_     [120]byte
	RG0CR volatile.Register32 // 0x100
	RG1CR volatile.Register32 // 0x104
	RG2CR volatile.Register32 // 0x108
	RG3CR volatile.Register32 // 0x10C
	_     [48]byte
	RGSR  volatile.Register32 // 0x140
	RGCFR volatile.Register32 // 0x144
}

// DMAMUX.C0CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC0CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC0CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC0CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC0CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC0CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC0CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC0CR_SE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC0CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC0CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC0CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC0CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC0CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC0CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC0CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C0CR.Reg) & 0xff
}

// DMAMUX.C1CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC1CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC1CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC1CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC1CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC1CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC1CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC1CR_SE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC1CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC1CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC1CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC1CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC1CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC1CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC1CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C1CR.Reg) & 0xff
}

// DMAMUX.C2CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC2CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC2CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC2CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC2CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC2CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC2CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC2CR_SE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC2CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC2CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC2CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC2CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC2CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC2CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC2CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C2CR.Reg) & 0xff
}

// DMAMUX.C3CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC3CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC3CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC3CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC3CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC3CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC3CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC3CR_SE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC3CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC3CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC3CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC3CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC3CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC3CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC3CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C3CR.Reg) & 0xff
}

// DMAMUX.C4CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC4CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC4CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC4CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC4CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC4CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC4CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC4CR_SE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC4CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC4CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC4CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC4CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC4CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC4CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC4CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C4CR.Reg) & 0xff
}

// DMAMUX.C5CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC5CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC5CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC5CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC5CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC5CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC5CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC5CR_SE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC5CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC5CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC5CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC5CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC5CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC5CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC5CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C5CR.Reg) & 0xff
}

// DMAMUX.C6CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC6CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC6CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC6CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC6CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC6CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC6CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC6CR_SE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC6CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC6CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC6CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC6CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC6CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC6CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC6CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C6CR.Reg) & 0xff
}

// DMAMUX.C7CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC7CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC7CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC7CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC7CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC7CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC7CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC7CR_SE(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC7CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC7CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC7CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC7CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC7CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC7CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC7CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C7CR.Reg) & 0xff
}

// DMAMUX.C8CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC8CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC8CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC8CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC8CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC8CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC8CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC8CR_SE(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC8CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC8CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC8CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC8CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC8CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC8CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC8CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C8CR.Reg) & 0xff
}

// DMAMUX.C9CR: request line multiplexer channel x configuration register
func (o *DMAMUX_Type) SetC9CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC9CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC9CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC9CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC9CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC9CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC9CR_SE(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC9CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC9CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC9CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC9CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC9CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC9CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC9CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C9CR.Reg) & 0xff
}

// DMAMUX.C10CR: C10CR
func (o *DMAMUX_Type) SetC10CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC10CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC10CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC10CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC10CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC10CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC10CR_SE(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC10CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC10CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC10CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC10CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC10CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC10CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC10CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C10CR.Reg) & 0xff
}

// DMAMUX.C11CR: C11CR
func (o *DMAMUX_Type) SetC11CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC11CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC11CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC11CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC11CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC11CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC11CR_SE(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC11CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC11CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC11CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC11CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC11CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC11CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC11CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C11CR.Reg) & 0xff
}

// DMAMUX.C12CR: C12CR
func (o *DMAMUX_Type) SetC12CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC12CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC12CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC12CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC12CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC12CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC12CR_SE(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC12CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC12CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC12CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC12CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC12CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC12CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC12CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C12CR.Reg) & 0xff
}

// DMAMUX.C13CR: C13CR
func (o *DMAMUX_Type) SetC13CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC13CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC13CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC13CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC13CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC13CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC13CR_SE(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC13CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC13CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC13CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC13CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC13CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC13CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC13CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C13CR.Reg) & 0xff
}

// DMAMUX.CSR: request line multiplexer interrupt channel status register
func (o *DMAMUX_Type) SetCSR_SOF13(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAMUX_Type) GetCSR_SOF13() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000) >> 13
}
func (o *DMAMUX_Type) SetCSR_SOF12(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAMUX_Type) GetCSR_SOF12() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000) >> 12
}
func (o *DMAMUX_Type) SetCSR_SOF11(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800)|value<<11)
}
func (o *DMAMUX_Type) GetCSR_SOF11() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800) >> 11
}
func (o *DMAMUX_Type) SetCSR_SOF10(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x400)|value<<10)
}
func (o *DMAMUX_Type) GetCSR_SOF10() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x400) >> 10
}
func (o *DMAMUX_Type) SetCSR_SOF9(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCSR_SOF9() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCSR_SOF8(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCSR_SOF8() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCSR_SOF7(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCSR_SOF7() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}
func (o *DMAMUX_Type) SetCSR_SOF6(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCSR_SOF6() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCSR_SOF5(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetCSR_SOF5() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetCSR_SOF4(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetCSR_SOF4() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetCSR_SOF3(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetCSR_SOF3() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetCSR_SOF2(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetCSR_SOF2() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetCSR_SOF1(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetCSR_SOF1() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetCSR_SOF0(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetCSR_SOF0() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}

// DMAMUX.CCFR: request line multiplexer interrupt channel clear flag register
func (o *DMAMUX_Type) SetCCFR_CSOF13(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAMUX_Type) GetCCFR_CSOF13() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x2000) >> 13
}
func (o *DMAMUX_Type) SetCCFR_CSOF12(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAMUX_Type) GetCCFR_CSOF12() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x1000) >> 12
}
func (o *DMAMUX_Type) SetCCFR_CSOF11(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x800)|value<<11)
}
func (o *DMAMUX_Type) GetCCFR_CSOF11() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x800) >> 11
}
func (o *DMAMUX_Type) SetCCFR_CSOF10(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x400)|value<<10)
}
func (o *DMAMUX_Type) GetCCFR_CSOF10() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x400) >> 10
}
func (o *DMAMUX_Type) SetCCFR_CSOF9(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCFR_CSOF9() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCFR_CSOF8(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCFR_CSOF8() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCFR_CSOF7(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCCFR_CSOF7() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x80) >> 7
}
func (o *DMAMUX_Type) SetCCFR_CSOF6(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCCFR_CSOF6() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCCFR_CSOF5(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetCCFR_CSOF5() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetCCFR_CSOF4(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetCCFR_CSOF4() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetCCFR_CSOF3(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetCCFR_CSOF3() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetCCFR_CSOF2(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetCCFR_CSOF2() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetCCFR_CSOF1(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetCCFR_CSOF1() uint32 {
	return (volatile.LoadUint32(&o.CCFR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetCCFR_CSOF0(value uint32) {
	volatile.StoreUint32(&o.CCFR.Reg, volatile.LoadUint32(&o.CCFR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetCCFR_CSOF0() uint32 {
	return volatile.LoadUint32(&o.CCFR.Reg) & 0x1
}

// DMAMUX.RG0CR: request generator channel x configuration register
func (o *DMAMUX_Type) SetRG0CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG0CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG0CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG0CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG0CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG0CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG0CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG0CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG0CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG0CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG0CR.Reg) & 0x1f
}

// DMAMUX.RG1CR: request generator channel x configuration register
func (o *DMAMUX_Type) SetRG1CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG1CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG1CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG1CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG1CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG1CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG1CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG1CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG1CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG1CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG1CR.Reg) & 0x1f
}

// DMAMUX.RG2CR: request generator channel x configuration register
func (o *DMAMUX_Type) SetRG2CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG2CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG2CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG2CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG2CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG2CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG2CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG2CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG2CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG2CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG2CR.Reg) & 0x1f
}

// DMAMUX.RG3CR: request generator channel x configuration register
func (o *DMAMUX_Type) SetRG3CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG3CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG3CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG3CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG3CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG3CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG3CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG3CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG3CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG3CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG3CR.Reg) & 0x1f
}

// DMAMUX.RGSR: request generator interrupt status register
func (o *DMAMUX_Type) SetRGSR_OF3(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetRGSR_OF3() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetRGSR_OF2(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetRGSR_OF2() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetRGSR_OF1(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetRGSR_OF1() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetRGSR_OF0(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetRGSR_OF0() uint32 {
	return volatile.LoadUint32(&o.RGSR.Reg) & 0x1
}

// DMAMUX.RGCFR: request generator interrupt clear flag register
func (o *DMAMUX_Type) SetRGCFR_COF3(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetRGCFR_COF3() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetRGCFR_COF2(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetRGCFR_COF2() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetRGCFR_COF1(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetRGCFR_COF1() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetRGCFR_COF0(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetRGCFR_COF0() uint32 {
	return volatile.LoadUint32(&o.RGCFR.Reg) & 0x1
}

// External interrupt/event controller
type EXTI_Type struct {
	RTSR1  volatile.Register32 // 0x0
	FTSR1  volatile.Register32 // 0x4
	SWIER1 volatile.Register32 // 0x8
	PR1    volatile.Register32 // 0xC
	_      [16]byte
	RTSR2  volatile.Register32 // 0x20
	FTSR2  volatile.Register32 // 0x24
	SWIER2 volatile.Register32 // 0x28
	PR2    volatile.Register32 // 0x2C
	_      [80]byte
	C1IMR1 volatile.Register32 // 0x80
	EMR1   volatile.Register32 // 0x84
	_      [8]byte
	C1IMR2 volatile.Register32 // 0x90
}

// EXTI.RTSR1: rising trigger selection register
func (o *EXTI_Type) SetRTSR1_RT21(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetRTSR1_RT21() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetRTSR1_RT22(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetRTSR1_RT22() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetRTSR1_RT0(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRTSR1_RT0() uint32 {
	return volatile.LoadUint32(&o.RTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetRTSR1_RT1(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRTSR1_RT1() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRTSR1_RT2(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTSR1_RT2() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTSR1_RT3(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTSR1_RT3() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTSR1_RT4(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTSR1_RT4() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTSR1_RT5(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTSR1_RT5() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTSR1_RT6(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTSR1_RT6() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRTSR1_RT7(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRTSR1_RT7() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRTSR1_RT8(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRTSR1_RT8() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRTSR1_RT9(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRTSR1_RT9() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetRTSR1_RT10(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetRTSR1_RT10() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetRTSR1_RT11(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetRTSR1_RT11() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetRTSR1_RT12(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetRTSR1_RT12() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetRTSR1_RT13(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRTSR1_RT13() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetRTSR1_RT14(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetRTSR1_RT14() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetRTSR1_RT15(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetRTSR1_RT15() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetRTSR1_RT16(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetRTSR1_RT16() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10000) >> 16
}

// EXTI.FTSR1: falling trigger selection register
func (o *EXTI_Type) SetFTSR1_FT21(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetFTSR1_FT21() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetFTSR1_FT22(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetFTSR1_FT22() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetFTSR1_FT0(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFTSR1_FT0() uint32 {
	return volatile.LoadUint32(&o.FTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetFTSR1_FT1(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFTSR1_FT1() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFTSR1_FT2(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTSR1_FT2() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTSR1_FT3(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTSR1_FT3() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTSR1_FT4(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTSR1_FT4() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTSR1_FT5(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTSR1_FT5() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTSR1_FT6(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTSR1_FT6() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFTSR1_FT7(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFTSR1_FT7() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFTSR1_FT8(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFTSR1_FT8() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFTSR1_FT9(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFTSR1_FT9() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetFTSR1_FT10(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetFTSR1_FT10() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetFTSR1_FT11(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetFTSR1_FT11() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetFTSR1_FT12(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetFTSR1_FT12() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetFTSR1_FT13(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFTSR1_FT13() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetFTSR1_FT14(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetFTSR1_FT14() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetFTSR1_FT15(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetFTSR1_FT15() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetFTSR1_FT16(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetFTSR1_FT16() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10000) >> 16
}

// EXTI.SWIER1: software interrupt event register
func (o *EXTI_Type) SetSWIER1_SWI21(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetSWIER1_SWI21() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetSWIER1_SWI22(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetSWIER1_SWI22() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetSWIER1_SWI0(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetSWIER1_SWI0() uint32 {
	return volatile.LoadUint32(&o.SWIER1.Reg) & 0x1
}
func (o *EXTI_Type) SetSWIER1_SWI1(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetSWIER1_SWI1() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetSWIER1_SWI2(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIER1_SWI2() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIER1_SWI3(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIER1_SWI3() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIER1_SWI4(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIER1_SWI4() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIER1_SWI5(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIER1_SWI5() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIER1_SWI6(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIER1_SWI6() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetSWIER1_SWI7(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetSWIER1_SWI7() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetSWIER1_SWI8(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetSWIER1_SWI8() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetSWIER1_SWI9(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetSWIER1_SWI9() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetSWIER1_SWI10(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetSWIER1_SWI10() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetSWIER1_SWI11(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetSWIER1_SWI11() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetSWIER1_SWI12(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetSWIER1_SWI12() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetSWIER1_SWI13(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetSWIER1_SWI13() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetSWIER1_SWI14(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetSWIER1_SWI14() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetSWIER1_SWI15(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetSWIER1_SWI15() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetSWIER1_SWI16(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetSWIER1_SWI16() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10000) >> 16
}

// EXTI.PR1: EXTI pending register
func (o *EXTI_Type) SetPR1_PIF21(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetPR1_PIF21() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetPR1_PIF22(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetPR1_PIF22() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetPR1_PIF0(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetPR1_PIF0() uint32 {
	return volatile.LoadUint32(&o.PR1.Reg) & 0x1
}
func (o *EXTI_Type) SetPR1_PIF1(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetPR1_PIF1() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetPR1_PIF2(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetPR1_PIF2() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetPR1_PIF3(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetPR1_PIF3() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetPR1_PIF4(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetPR1_PIF4() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetPR1_PIF5(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetPR1_PIF5() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetPR1_PIF6(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetPR1_PIF6() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetPR1_PIF7(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetPR1_PIF7() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetPR1_PIF8(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetPR1_PIF8() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetPR1_PIF9(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetPR1_PIF9() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetPR1_PIF10(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetPR1_PIF10() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetPR1_PIF11(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetPR1_PIF11() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetPR1_PIF12(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetPR1_PIF12() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetPR1_PIF13(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetPR1_PIF13() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetPR1_PIF14(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetPR1_PIF14() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetPR1_PIF15(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetPR1_PIF15() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetPR1_PIF16(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetPR1_PIF16() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x10000) >> 16
}

// EXTI.RTSR2: rising trigger selection register
func (o *EXTI_Type) SetRTSR2_RT34(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTSR2_RT34() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTSR2_RT45(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRTSR2_RT45() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x2000) >> 13
}

// EXTI.FTSR2: falling trigger selection register
func (o *EXTI_Type) SetFTSR2_FT34(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTSR2_FT34() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTSR2_FT45(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFTSR2_FT45() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x2000) >> 13
}

// EXTI.SWIER2: software interrupt event register
func (o *EXTI_Type) SetSWIER2_SWI34(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIER2_SWI34() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIER2_SWI45(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetSWIER2_SWI45() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x2000) >> 13
}

// EXTI.PR2: pending register
func (o *EXTI_Type) SetPR2_PIF34(value uint32) {
	volatile.StoreUint32(&o.PR2.Reg, volatile.LoadUint32(&o.PR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetPR2_PIF34() uint32 {
	return (volatile.LoadUint32(&o.PR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetPR2_PIF45(value uint32) {
	volatile.StoreUint32(&o.PR2.Reg, volatile.LoadUint32(&o.PR2.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetPR2_PIF45() uint32 {
	return (volatile.LoadUint32(&o.PR2.Reg) & 0x2000) >> 13
}

// EXTI.C1IMR1: interrupt mask register
func (o *EXTI_Type) SetC1IMR1_IM0(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetC1IMR1_IM0() uint32 {
	return volatile.LoadUint32(&o.C1IMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetC1IMR1_IM1(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetC1IMR1_IM1() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetC1IMR1_IM2(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetC1IMR1_IM2() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetC1IMR1_IM3(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetC1IMR1_IM3() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetC1IMR1_IM4(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetC1IMR1_IM4() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetC1IMR1_IM5(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetC1IMR1_IM5() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetC1IMR1_IM6(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetC1IMR1_IM6() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetC1IMR1_IM7(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetC1IMR1_IM7() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetC1IMR1_IM8(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetC1IMR1_IM8() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetC1IMR1_IM9(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetC1IMR1_IM9() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetC1IMR1_IM10(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetC1IMR1_IM10() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetC1IMR1_IM11(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetC1IMR1_IM11() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetC1IMR1_IM12(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetC1IMR1_IM12() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetC1IMR1_IM13(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetC1IMR1_IM13() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetC1IMR1_IM14(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetC1IMR1_IM14() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetC1IMR1_IM15(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetC1IMR1_IM15() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetC1IMR1_IM16(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetC1IMR1_IM16() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetC1IMR1_IM17(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetC1IMR1_IM17() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetC1IMR1_IM18(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetC1IMR1_IM18() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetC1IMR1_IM19(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetC1IMR1_IM19() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetC1IMR1_IM20(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetC1IMR1_IM20() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetC1IMR1_IM21(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetC1IMR1_IM21() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetC1IMR1_IM22(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetC1IMR1_IM22() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetC1IMR1_IM23(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetC1IMR1_IM23() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetC1IMR1_IM24(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetC1IMR1_IM24() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetC1IMR1_IM25(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetC1IMR1_IM25() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetC1IMR1_IM26(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetC1IMR1_IM26() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetC1IMR1_IM27(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetC1IMR1_IM27() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetC1IMR1_IM28(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetC1IMR1_IM28() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetC1IMR1_IM29(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetC1IMR1_IM29() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetC1IMR1_IM30(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetC1IMR1_IM30() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetC1IMR1_IM31(value uint32) {
	volatile.StoreUint32(&o.C1IMR1.Reg, volatile.LoadUint32(&o.C1IMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetC1IMR1_IM31() uint32 {
	return (volatile.LoadUint32(&o.C1IMR1.Reg) & 0x80000000) >> 31
}

// EXTI.EMR1: event mask register
func (o *EXTI_Type) SetEMR1_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEMR1_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetEMR1_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEMR1_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetEMR1_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetEMR1_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetEMR1_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetEMR1_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetEMR1_EM4(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetEMR1_EM4() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetEMR1_EM5(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetEMR1_EM5() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetEMR1_EM6(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetEMR1_EM6() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetEMR1_EM7(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetEMR1_EM7() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetEMR1_EM8(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetEMR1_EM8() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetEMR1_EM9(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetEMR1_EM9() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetEMR1_EM10(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetEMR1_EM10() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetEMR1_EM11(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetEMR1_EM11() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetEMR1_EM12(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetEMR1_EM12() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetEMR1_EM13(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetEMR1_EM13() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetEMR1_EM14(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetEMR1_EM14() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetEMR1_EM15(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetEMR1_EM15() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetEMR1_EM17(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetEMR1_EM17() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetEMR1_EM18(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetEMR1_EM18() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetEMR1_EM19(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetEMR1_EM19() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetEMR1_EM20(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetEMR1_EM20() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetEMR1_EM21(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetEMR1_EM21() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetEMR1_EM22(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetEMR1_EM22() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x400000) >> 22
}

// EXTI.C1IMR2: interrupt mask register
func (o *EXTI_Type) SetC1IMR2_IM34(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetC1IMR2_IM34() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetC1IMR2_IM38(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetC1IMR2_IM38() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetC1IMR2_IM42(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetC1IMR2_IM42() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetC1IMR2_IM43(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetC1IMR2_IM43() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetC1IMR2_IM44(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetC1IMR2_IM44() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetC1IMR2_IM45(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetC1IMR2_IM45() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetC1IMR2_IM46(value uint32) {
	volatile.StoreUint32(&o.C1IMR2.Reg, volatile.LoadUint32(&o.C1IMR2.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetC1IMR2_IM46() uint32 {
	return (volatile.LoadUint32(&o.C1IMR2.Reg) & 0x4000) >> 14
}

// Flash
type Flash_Type struct {
	ACR       volatile.Register32 // 0x0
	_         [4]byte
	KEYR      volatile.Register32 // 0x8
	OPTKEYR   volatile.Register32 // 0xC
	SR        volatile.Register32 // 0x10
	CR        volatile.Register32 // 0x14
	ECCR      volatile.Register32 // 0x18
	_         [4]byte
	OPTR      volatile.Register32 // 0x20
	PCROP1ASR volatile.Register32 // 0x24
	PCROP1AER volatile.Register32 // 0x28
	WRP1AR    volatile.Register32 // 0x2C
	WRP1BR    volatile.Register32 // 0x30
	PCROP1BSR volatile.Register32 // 0x34
	PCROP1BER volatile.Register32 // 0x38
}

// Flash.ACR: Access control register
func (o *Flash_Type) SetACR_LATENCY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x7)|value)
}
func (o *Flash_Type) GetACR_LATENCY() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x7
}
func (o *Flash_Type) SetACR_PRFTEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetACR_PRFTEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetACR_ICEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *Flash_Type) GetACR_ICEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *Flash_Type) SetACR_DCEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x400)|value<<10)
}
func (o *Flash_Type) GetACR_DCEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x400) >> 10
}
func (o *Flash_Type) SetACR_ICRST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x800)|value<<11)
}
func (o *Flash_Type) GetACR_ICRST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x800) >> 11
}
func (o *Flash_Type) SetACR_DCRST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1000)|value<<12)
}
func (o *Flash_Type) GetACR_DCRST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x1000) >> 12
}
func (o *Flash_Type) SetACR_PES(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x8000)|value<<15)
}
func (o *Flash_Type) GetACR_PES() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x8000) >> 15
}
func (o *Flash_Type) SetACR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetACR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x10000) >> 16
}

// Flash.KEYR: Flash key register
func (o *Flash_Type) SetKEYR(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, value)
}
func (o *Flash_Type) GetKEYR() uint32 {
	return volatile.LoadUint32(&o.KEYR.Reg)
}

// Flash.OPTKEYR: Option byte key register
func (o *Flash_Type) SetOPTKEYR(value uint32) {
	volatile.StoreUint32(&o.OPTKEYR.Reg, value)
}
func (o *Flash_Type) GetOPTKEYR() uint32 {
	return volatile.LoadUint32(&o.OPTKEYR.Reg)
}

// Flash.SR: Status register
func (o *Flash_Type) SetSR_EOP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *Flash_Type) GetSR_EOP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *Flash_Type) SetSR_OPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *Flash_Type) GetSR_OPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *Flash_Type) SetSR_PROGERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *Flash_Type) GetSR_PROGERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *Flash_Type) SetSR_WRPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *Flash_Type) GetSR_WRPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *Flash_Type) SetSR_PGAERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *Flash_Type) GetSR_PGAERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *Flash_Type) SetSR_SIZERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *Flash_Type) GetSR_SIZERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *Flash_Type) SetSR_PGSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *Flash_Type) GetSR_PGSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *Flash_Type) SetSR_MISSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetSR_MISSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetSR_FASTERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *Flash_Type) GetSR_FASTERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *Flash_Type) SetSR_OPTNV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *Flash_Type) GetSR_OPTNV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *Flash_Type) SetSR_RDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *Flash_Type) GetSR_RDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *Flash_Type) SetSR_OPTVERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *Flash_Type) GetSR_OPTVERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *Flash_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetSR_CFGBSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetSR_CFGBSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetSR_PESD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *Flash_Type) GetSR_PESD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}

// Flash.CR: Flash control register
func (o *Flash_Type) SetCR_PG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *Flash_Type) GetCR_PG() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *Flash_Type) SetCR_PER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *Flash_Type) GetCR_PER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *Flash_Type) SetCR_MER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *Flash_Type) GetCR_MER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *Flash_Type) SetCR_PNB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f8)|value<<3)
}
func (o *Flash_Type) GetCR_PNB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3f8) >> 3
}
func (o *Flash_Type) SetCR_STRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetCR_STRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetCR_OPTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *Flash_Type) GetCR_OPTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *Flash_Type) SetCR_FSTPG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetCR_FSTPG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetCR_EOPIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetCR_EOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *Flash_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *Flash_Type) SetCR_RDERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *Flash_Type) GetCR_RDERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *Flash_Type) SetCR_OBL_LAUNCH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *Flash_Type) GetCR_OBL_LAUNCH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *Flash_Type) SetCR_OPTLOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetCR_OPTLOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *Flash_Type) SetCR_LOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetCR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// Flash.ECCR: Flash ECC register
func (o *Flash_Type) SetECCR_ADDR_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x1ffff)|value)
}
func (o *Flash_Type) GetECCR_ADDR_ECC() uint32 {
	return volatile.LoadUint32(&o.ECCR.Reg) & 0x1ffff
}
func (o *Flash_Type) SetECCR_SYSF_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x100000)|value<<20)
}
func (o *Flash_Type) GetECCR_SYSF_ECC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x100000) >> 20
}
func (o *Flash_Type) SetECCR_ECCCIE(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetECCR_ECCCIE() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetECCR_ECCC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetECCR_ECCC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x40000000) >> 30
}
func (o *Flash_Type) SetECCR_ECCD(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetECCR_ECCD() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x80000000) >> 31
}

// Flash.OPTR: Flash option register
func (o *Flash_Type) SetOPTR_RDP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetOPTR_RDP() uint32 {
	return volatile.LoadUint32(&o.OPTR.Reg) & 0xff
}
func (o *Flash_Type) SetOPTR_ESE(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetOPTR_ESE() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetOPTR_BOR_LEV(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0xe00)|value<<9)
}
func (o *Flash_Type) GetOPTR_BOR_LEV() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0xe00) >> 9
}
func (o *Flash_Type) SetOPTR_NRST_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x1000)|value<<12)
}
func (o *Flash_Type) GetOPTR_NRST_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x1000) >> 12
}
func (o *Flash_Type) SetOPTR_NRST_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x2000)|value<<13)
}
func (o *Flash_Type) GetOPTR_NRST_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x2000) >> 13
}
func (o *Flash_Type) SetOPTR_NRST_SHDW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x4000)|value<<14)
}
func (o *Flash_Type) GetOPTR_NRST_SHDW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x4000) >> 14
}
func (o *Flash_Type) SetOPTR_IWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetOPTR_IWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetOPTR_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x20000)|value<<17)
}
func (o *Flash_Type) GetOPTR_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x20000) >> 17
}
func (o *Flash_Type) SetOPTR_IWDG_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetOPTR_IWDG_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetOPTR_WWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x80000)|value<<19)
}
func (o *Flash_Type) GetOPTR_WWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x80000) >> 19
}
func (o *Flash_Type) SetOPTR_NBOOT1(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x800000)|value<<23)
}
func (o *Flash_Type) GetOPTR_NBOOT1() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x800000) >> 23
}
func (o *Flash_Type) SetOPTR_SRAM2_PE(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetOPTR_SRAM2_PE() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetOPTR_SRAM_RST(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x2000000)|value<<25)
}
func (o *Flash_Type) GetOPTR_SRAM_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x2000000) >> 25
}
func (o *Flash_Type) SetOPTR_NSWBOOT0(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x4000000)|value<<26)
}
func (o *Flash_Type) GetOPTR_NSWBOOT0() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x4000000) >> 26
}
func (o *Flash_Type) SetOPTR_NBOOT0(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x8000000)|value<<27)
}
func (o *Flash_Type) GetOPTR_NBOOT0() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x8000000) >> 27
}
func (o *Flash_Type) SetOPTR_BOOT_LOCK(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetOPTR_BOOT_LOCK() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x40000000) >> 30
}

// Flash.PCROP1ASR: Flash PCROP zone A Start address register
func (o *Flash_Type) SetPCROP1ASR_PCROP1A_STRT(value uint32) {
	volatile.StoreUint32(&o.PCROP1ASR.Reg, volatile.LoadUint32(&o.PCROP1ASR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1ASR_PCROP1A_STRT() uint32 {
	return volatile.LoadUint32(&o.PCROP1ASR.Reg) & 0xff
}

// Flash.PCROP1AER: Flash PCROP zone A End address register
func (o *Flash_Type) SetPCROP1AER_PCROP1A_END(value uint32) {
	volatile.StoreUint32(&o.PCROP1AER.Reg, volatile.LoadUint32(&o.PCROP1AER.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1AER_PCROP1A_END() uint32 {
	return volatile.LoadUint32(&o.PCROP1AER.Reg) & 0xff
}
func (o *Flash_Type) SetPCROP1AER_PCROP_RDP(value uint32) {
	volatile.StoreUint32(&o.PCROP1AER.Reg, volatile.LoadUint32(&o.PCROP1AER.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetPCROP1AER_PCROP_RDP() uint32 {
	return (volatile.LoadUint32(&o.PCROP1AER.Reg) & 0x80000000) >> 31
}

// Flash.WRP1AR: Flash WRP area A address register
func (o *Flash_Type) SetWRP1AR_WRP1A_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP1AR.Reg, volatile.LoadUint32(&o.WRP1AR.Reg)&^(0x7f)|value)
}
func (o *Flash_Type) GetWRP1AR_WRP1A_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP1AR.Reg) & 0x7f
}
func (o *Flash_Type) SetWRP1AR_WRP1A_END(value uint32) {
	volatile.StoreUint32(&o.WRP1AR.Reg, volatile.LoadUint32(&o.WRP1AR.Reg)&^(0x7f0000)|value<<16)
}
func (o *Flash_Type) GetWRP1AR_WRP1A_END() uint32 {
	return (volatile.LoadUint32(&o.WRP1AR.Reg) & 0x7f0000) >> 16
}

// Flash.WRP1BR: Flash WRP area B address register
func (o *Flash_Type) SetWRP1BR_WRP1B_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP1BR.Reg, volatile.LoadUint32(&o.WRP1BR.Reg)&^(0x7f)|value)
}
func (o *Flash_Type) GetWRP1BR_WRP1B_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP1BR.Reg) & 0x7f
}
func (o *Flash_Type) SetWRP1BR_WRP1B_END(value uint32) {
	volatile.StoreUint32(&o.WRP1BR.Reg, volatile.LoadUint32(&o.WRP1BR.Reg)&^(0x7f0000)|value<<16)
}
func (o *Flash_Type) GetWRP1BR_WRP1B_END() uint32 {
	return (volatile.LoadUint32(&o.WRP1BR.Reg) & 0x7f0000) >> 16
}

// Flash.PCROP1BSR: Flash PCROP zone B Start address register
func (o *Flash_Type) SetPCROP1BSR_PCROP1B_STRT(value uint32) {
	volatile.StoreUint32(&o.PCROP1BSR.Reg, volatile.LoadUint32(&o.PCROP1BSR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1BSR_PCROP1B_STRT() uint32 {
	return volatile.LoadUint32(&o.PCROP1BSR.Reg) & 0xff
}

// Flash.PCROP1BER: Flash PCROP zone B End address register
func (o *Flash_Type) SetPCROP1BER_PCROP1B_END(value uint32) {
	volatile.StoreUint32(&o.PCROP1BER.Reg, volatile.LoadUint32(&o.PCROP1BER.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1BER_PCROP1B_END() uint32 {
	return volatile.LoadUint32(&o.PCROP1BER.Reg) & 0xff
}

// General-purpose I/Os
type GPIO_Type struct {
	MODER   volatile.Register32 // 0x0
	OTYPER  volatile.Register32 // 0x4
	OSPEEDR volatile.Register32 // 0x8
	PUPDR   volatile.Register32 // 0xC
	IDR     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	BSRR    volatile.Register32 // 0x18
	LCKR    volatile.Register32 // 0x1C
	AFRL    volatile.Register32 // 0x20
	AFRH    volatile.Register32 // 0x24
	BRR     volatile.Register32 // 0x28
}

// GPIO.MODER: GPIO port mode register
func (o *GPIO_Type) SetMODER_MODER15(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetMODER_MODER15() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetMODER_MODER14(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetMODER_MODER14() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetMODER_MODER13(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetMODER_MODER13() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetMODER_MODER12(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetMODER_MODER12() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetMODER_MODER11(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetMODER_MODER11() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetMODER_MODER10(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetMODER_MODER10() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetMODER_MODER9(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetMODER_MODER9() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetMODER_MODER8(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetMODER_MODER8() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetMODER_MODER7(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetMODER_MODER7() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetMODER_MODER6(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetMODER_MODER6() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetMODER_MODER5(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetMODER_MODER5() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetMODER_MODER4(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetMODER_MODER4() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetMODER_MODER3(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetMODER_MODER3() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetMODER_MODER2(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetMODER_MODER2() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetMODER_MODER1(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetMODER_MODER1() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetMODER_MODER0(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetMODER_MODER0() uint32 {
	return volatile.LoadUint32(&o.MODER.Reg) & 0x3
}

// GPIO.OTYPER: GPIO port output type register
func (o *GPIO_Type) SetOTYPER_OT15(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOTYPER_OT15() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOTYPER_OT14(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOTYPER_OT14() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOTYPER_OT13(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOTYPER_OT13() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOTYPER_OT12(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOTYPER_OT12() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOTYPER_OT11(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOTYPER_OT11() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOTYPER_OT10(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOTYPER_OT10() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOTYPER_OT9(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOTYPER_OT9() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOTYPER_OT8(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOTYPER_OT8() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOTYPER_OT7(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOTYPER_OT7() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOTYPER_OT6(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOTYPER_OT6() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOTYPER_OT5(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOTYPER_OT5() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOTYPER_OT4(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOTYPER_OT4() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOTYPER_OT3(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOTYPER_OT3() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOTYPER_OT2(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOTYPER_OT2() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOTYPER_OT1(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOTYPER_OT1() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOTYPER_OT0(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOTYPER_OT0() uint32 {
	return volatile.LoadUint32(&o.OTYPER.Reg) & 0x1
}

// GPIO.OSPEEDR: GPIO port output speed register
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR15(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR15() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR14(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR14() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR13(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR13() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR12(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR12() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR11(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR11() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR10(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR10() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR9(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR9() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR8(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR8() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR7(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR7() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR6(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR6() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR5(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR5() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR4(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR4() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR3(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR3() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR2(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR2() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR1(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR1() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR0(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR0() uint32 {
	return volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3
}

// GPIO.PUPDR: GPIO port pull-up/pull-down register
func (o *GPIO_Type) SetPUPDR_PUPDR15(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetPUPDR_PUPDR15() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetPUPDR_PUPDR14(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetPUPDR_PUPDR14() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetPUPDR_PUPDR13(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetPUPDR_PUPDR13() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetPUPDR_PUPDR12(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetPUPDR_PUPDR12() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetPUPDR_PUPDR11(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetPUPDR_PUPDR11() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetPUPDR_PUPDR10(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetPUPDR_PUPDR10() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetPUPDR_PUPDR9(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetPUPDR_PUPDR9() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetPUPDR_PUPDR8(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPUPDR_PUPDR8() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetPUPDR_PUPDR7(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetPUPDR_PUPDR7() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetPUPDR_PUPDR6(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetPUPDR_PUPDR6() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetPUPDR_PUPDR5(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetPUPDR_PUPDR5() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetPUPDR_PUPDR4(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetPUPDR_PUPDR4() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetPUPDR_PUPDR3(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetPUPDR_PUPDR3() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetPUPDR_PUPDR2(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetPUPDR_PUPDR2() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetPUPDR_PUPDR1(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPUPDR_PUPDR1() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPUPDR_PUPDR0(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPUPDR_PUPDR0() uint32 {
	return volatile.LoadUint32(&o.PUPDR.Reg) & 0x3
}

// GPIO.IDR: GPIO port input data register
func (o *GPIO_Type) SetIDR_IDR15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIDR_IDR15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIDR_IDR14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIDR_IDR14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIDR_IDR13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIDR_IDR13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIDR_IDR12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIDR_IDR12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIDR_IDR11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIDR_IDR11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIDR_IDR10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIDR_IDR10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIDR_IDR9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIDR_IDR9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIDR_IDR8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIDR_IDR8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIDR_IDR7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIDR_IDR7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIDR_IDR6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIDR_IDR6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIDR_IDR5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIDR_IDR5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIDR_IDR4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIDR_IDR4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIDR_IDR3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIDR_IDR3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIDR_IDR2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIDR_IDR2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIDR_IDR1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIDR_IDR1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIDR_IDR0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIDR_IDR0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// GPIO.ODR: GPIO port output data register
func (o *GPIO_Type) SetODR_ODR15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetODR_ODR15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetODR_ODR14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetODR_ODR14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetODR_ODR13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetODR_ODR13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetODR_ODR12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetODR_ODR12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetODR_ODR11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetODR_ODR11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetODR_ODR10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetODR_ODR10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetODR_ODR9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetODR_ODR9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetODR_ODR8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetODR_ODR8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetODR_ODR7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetODR_ODR7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetODR_ODR6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetODR_ODR6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetODR_ODR5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetODR_ODR5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetODR_ODR4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetODR_ODR4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetODR_ODR3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetODR_ODR3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetODR_ODR2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetODR_ODR2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetODR_ODR1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetODR_ODR1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetODR_ODR0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetODR_ODR0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}

// GPIO.BSRR: GPIO port bit set/reset register
func (o *GPIO_Type) SetBSRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetBSRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000000) >> 31
}
func (o *GPIO_Type) SetBSRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetBSRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetBSRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetBSRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetBSRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetBSRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetBSRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetBSRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetBSRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetBSRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetBSRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetBSRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetBSRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetBSRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetBSRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetBSRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetBSRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetBSRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetBSRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetBSRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetBSRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetBSRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetBSRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetBSRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetBSRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetBSRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetBSRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetBSRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetBSRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetBSRR_BR0() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetBSRR_BS15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBSRR_BS15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetBSRR_BS14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBSRR_BS14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBSRR_BS13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBSRR_BS13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBSRR_BS12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBSRR_BS12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBSRR_BS11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBSRR_BS11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBSRR_BS10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBSRR_BS10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBSRR_BS9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBSRR_BS9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBSRR_BS8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBSRR_BS8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBSRR_BS7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBSRR_BS7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBSRR_BS6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBSRR_BS6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBSRR_BS5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBSRR_BS5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBSRR_BS4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBSRR_BS4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBSRR_BS3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBSRR_BS3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBSRR_BS2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBSRR_BS2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBSRR_BS1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBSRR_BS1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBSRR_BS0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBSRR_BS0() uint32 {
	return volatile.LoadUint32(&o.BSRR.Reg) & 0x1
}

// GPIO.LCKR: GPIO port configuration lock register
func (o *GPIO_Type) SetLCKR_LCKK(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLCKR_LCKK() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLCKR_LCK15(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLCKR_LCK15() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLCKR_LCK14(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLCKR_LCK14() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLCKR_LCK13(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLCKR_LCK13() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLCKR_LCK12(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLCKR_LCK12() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLCKR_LCK11(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLCKR_LCK11() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLCKR_LCK10(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLCKR_LCK10() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLCKR_LCK9(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLCKR_LCK9() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLCKR_LCK8(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLCKR_LCK8() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLCKR_LCK7(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLCKR_LCK7() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLCKR_LCK6(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLCKR_LCK6() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLCKR_LCK5(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLCKR_LCK5() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLCKR_LCK4(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLCKR_LCK4() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLCKR_LCK3(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLCKR_LCK3() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLCKR_LCK2(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLCKR_LCK2() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLCKR_LCK1(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLCKR_LCK1() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLCKR_LCK0(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLCKR_LCK0() uint32 {
	return volatile.LoadUint32(&o.LCKR.Reg) & 0x1
}

// GPIO.AFRL: GPIO alternate function low register
func (o *GPIO_Type) SetAFRL_AFRL7(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRL_AFRL7() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRL_AFRL6(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRL_AFRL6() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRL_AFRL5(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRL_AFRL5() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRL_AFRL4(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRL_AFRL4() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRL_AFRL3(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRL_AFRL3() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRL_AFRL2(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRL_AFRL2() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRL_AFRL1(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRL_AFRL1() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRL_AFRL0(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRL_AFRL0() uint32 {
	return volatile.LoadUint32(&o.AFRL.Reg) & 0xf
}

// GPIO.AFRH: GPIO alternate function high register
func (o *GPIO_Type) SetAFRH_AFRH15(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRH_AFRH15() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRH_AFRH14(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRH_AFRH14() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRH_AFRH13(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRH_AFRH13() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRH_AFRH12(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRH_AFRH12() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRH_AFRH11(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRH_AFRH11() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRH_AFRH10(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRH_AFRH10() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRH_AFRH9(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRH_AFRH9() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRH_AFRH8(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRH_AFRH8() uint32 {
	return volatile.LoadUint32(&o.AFRH.Reg) & 0xf
}

// GPIO.BRR: GPIO port bit reset register
func (o *GPIO_Type) SetBRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBRR_BR0() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0x1
}
func (o *GPIO_Type) SetBRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8000) >> 15
}

// Hardware semaphore
type HSEM_Type struct {
	R0     volatile.Register32 // 0x0
	R1     volatile.Register32 // 0x4
	R2     volatile.Register32 // 0x8
	R3     volatile.Register32 // 0xC
	R4     volatile.Register32 // 0x10
	R5     volatile.Register32 // 0x14
	R6     volatile.Register32 // 0x18
	R7     volatile.Register32 // 0x1C
	R8     volatile.Register32 // 0x20
	R9     volatile.Register32 // 0x24
	R10    volatile.Register32 // 0x28
	R11    volatile.Register32 // 0x2C
	R12    volatile.Register32 // 0x30
	R13    volatile.Register32 // 0x34
	R14    volatile.Register32 // 0x38
	R15    volatile.Register32 // 0x3C
	_      [64]byte
	RLR0   volatile.Register32 // 0x80
	RLR1   volatile.Register32 // 0x84
	RLR2   volatile.Register32 // 0x88
	RLR3   volatile.Register32 // 0x8C
	RLR4   volatile.Register32 // 0x90
	RLR5   volatile.Register32 // 0x94
	RLR6   volatile.Register32 // 0x98
	RLR7   volatile.Register32 // 0x9C
	RLR8   volatile.Register32 // 0xA0
	RLR9   volatile.Register32 // 0xA4
	RLR10  volatile.Register32 // 0xA8
	RLR11  volatile.Register32 // 0xAC
	RLR12  volatile.Register32 // 0xB0
	RLR13  volatile.Register32 // 0xB4
	RLR14  volatile.Register32 // 0xB8
	RLR15  volatile.Register32 // 0xBC
	_      [64]byte
	C1IER  volatile.Register32 // 0x100
	C1ICR  volatile.Register32 // 0x104
	C1ISR  volatile.Register32 // 0x108
	C1MISR volatile.Register32 // 0x10C
	_      [48]byte
	CR     volatile.Register32 // 0x140
	KEYR   volatile.Register32 // 0x144
}

// HSEM.R0: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR0_PROCID(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR0_PROCID() uint32 {
	return volatile.LoadUint32(&o.R0.Reg) & 0xff
}
func (o *HSEM_Type) SetR0_COREID(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR0_COREID() uint32 {
	return (volatile.LoadUint32(&o.R0.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR0_LOCK(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR0_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R0.Reg) & 0x80000000) >> 31
}

// HSEM.R1: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR1_PROCID(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR1_PROCID() uint32 {
	return volatile.LoadUint32(&o.R1.Reg) & 0xff
}
func (o *HSEM_Type) SetR1_COREID(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR1_COREID() uint32 {
	return (volatile.LoadUint32(&o.R1.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR1_LOCK(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R1.Reg) & 0x80000000) >> 31
}

// HSEM.R2: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR2_PROCID(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR2_PROCID() uint32 {
	return volatile.LoadUint32(&o.R2.Reg) & 0xff
}
func (o *HSEM_Type) SetR2_COREID(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR2_COREID() uint32 {
	return (volatile.LoadUint32(&o.R2.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR2_LOCK(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R2.Reg) & 0x80000000) >> 31
}

// HSEM.R3: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR3_PROCID(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR3_PROCID() uint32 {
	return volatile.LoadUint32(&o.R3.Reg) & 0xff
}
func (o *HSEM_Type) SetR3_COREID(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR3_COREID() uint32 {
	return (volatile.LoadUint32(&o.R3.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR3_LOCK(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR3_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R3.Reg) & 0x80000000) >> 31
}

// HSEM.R4: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR4_PROCID(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR4_PROCID() uint32 {
	return volatile.LoadUint32(&o.R4.Reg) & 0xff
}
func (o *HSEM_Type) SetR4_COREID(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR4_COREID() uint32 {
	return (volatile.LoadUint32(&o.R4.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR4_LOCK(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR4_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R4.Reg) & 0x80000000) >> 31
}

// HSEM.R5: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR5_PROCID(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR5_PROCID() uint32 {
	return volatile.LoadUint32(&o.R5.Reg) & 0xff
}
func (o *HSEM_Type) SetR5_COREID(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR5_COREID() uint32 {
	return (volatile.LoadUint32(&o.R5.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR5_LOCK(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR5_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R5.Reg) & 0x80000000) >> 31
}

// HSEM.R6: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR6_PROCID(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR6_PROCID() uint32 {
	return volatile.LoadUint32(&o.R6.Reg) & 0xff
}
func (o *HSEM_Type) SetR6_COREID(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR6_COREID() uint32 {
	return (volatile.LoadUint32(&o.R6.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR6_LOCK(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR6_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R6.Reg) & 0x80000000) >> 31
}

// HSEM.R7: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR7_PROCID(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR7_PROCID() uint32 {
	return volatile.LoadUint32(&o.R7.Reg) & 0xff
}
func (o *HSEM_Type) SetR7_COREID(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR7_COREID() uint32 {
	return (volatile.LoadUint32(&o.R7.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR7_LOCK(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR7_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R7.Reg) & 0x80000000) >> 31
}

// HSEM.R8: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR8_PROCID(value uint32) {
	volatile.StoreUint32(&o.R8.Reg, volatile.LoadUint32(&o.R8.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR8_PROCID() uint32 {
	return volatile.LoadUint32(&o.R8.Reg) & 0xff
}
func (o *HSEM_Type) SetR8_COREID(value uint32) {
	volatile.StoreUint32(&o.R8.Reg, volatile.LoadUint32(&o.R8.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR8_COREID() uint32 {
	return (volatile.LoadUint32(&o.R8.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR8_LOCK(value uint32) {
	volatile.StoreUint32(&o.R8.Reg, volatile.LoadUint32(&o.R8.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR8_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R8.Reg) & 0x80000000) >> 31
}

// HSEM.R9: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR9_PROCID(value uint32) {
	volatile.StoreUint32(&o.R9.Reg, volatile.LoadUint32(&o.R9.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR9_PROCID() uint32 {
	return volatile.LoadUint32(&o.R9.Reg) & 0xff
}
func (o *HSEM_Type) SetR9_COREID(value uint32) {
	volatile.StoreUint32(&o.R9.Reg, volatile.LoadUint32(&o.R9.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR9_COREID() uint32 {
	return (volatile.LoadUint32(&o.R9.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR9_LOCK(value uint32) {
	volatile.StoreUint32(&o.R9.Reg, volatile.LoadUint32(&o.R9.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR9_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R9.Reg) & 0x80000000) >> 31
}

// HSEM.R10: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR10_PROCID(value uint32) {
	volatile.StoreUint32(&o.R10.Reg, volatile.LoadUint32(&o.R10.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR10_PROCID() uint32 {
	return volatile.LoadUint32(&o.R10.Reg) & 0xff
}
func (o *HSEM_Type) SetR10_COREID(value uint32) {
	volatile.StoreUint32(&o.R10.Reg, volatile.LoadUint32(&o.R10.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR10_COREID() uint32 {
	return (volatile.LoadUint32(&o.R10.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR10_LOCK(value uint32) {
	volatile.StoreUint32(&o.R10.Reg, volatile.LoadUint32(&o.R10.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR10_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R10.Reg) & 0x80000000) >> 31
}

// HSEM.R11: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR11_PROCID(value uint32) {
	volatile.StoreUint32(&o.R11.Reg, volatile.LoadUint32(&o.R11.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR11_PROCID() uint32 {
	return volatile.LoadUint32(&o.R11.Reg) & 0xff
}
func (o *HSEM_Type) SetR11_COREID(value uint32) {
	volatile.StoreUint32(&o.R11.Reg, volatile.LoadUint32(&o.R11.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR11_COREID() uint32 {
	return (volatile.LoadUint32(&o.R11.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR11_LOCK(value uint32) {
	volatile.StoreUint32(&o.R11.Reg, volatile.LoadUint32(&o.R11.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR11_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R11.Reg) & 0x80000000) >> 31
}

// HSEM.R12: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR12_PROCID(value uint32) {
	volatile.StoreUint32(&o.R12.Reg, volatile.LoadUint32(&o.R12.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR12_PROCID() uint32 {
	return volatile.LoadUint32(&o.R12.Reg) & 0xff
}
func (o *HSEM_Type) SetR12_COREID(value uint32) {
	volatile.StoreUint32(&o.R12.Reg, volatile.LoadUint32(&o.R12.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR12_COREID() uint32 {
	return (volatile.LoadUint32(&o.R12.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR12_LOCK(value uint32) {
	volatile.StoreUint32(&o.R12.Reg, volatile.LoadUint32(&o.R12.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR12_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R12.Reg) & 0x80000000) >> 31
}

// HSEM.R13: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR13_PROCID(value uint32) {
	volatile.StoreUint32(&o.R13.Reg, volatile.LoadUint32(&o.R13.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR13_PROCID() uint32 {
	return volatile.LoadUint32(&o.R13.Reg) & 0xff
}
func (o *HSEM_Type) SetR13_COREID(value uint32) {
	volatile.StoreUint32(&o.R13.Reg, volatile.LoadUint32(&o.R13.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR13_COREID() uint32 {
	return (volatile.LoadUint32(&o.R13.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR13_LOCK(value uint32) {
	volatile.StoreUint32(&o.R13.Reg, volatile.LoadUint32(&o.R13.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR13_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R13.Reg) & 0x80000000) >> 31
}

// HSEM.R14: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR14_PROCID(value uint32) {
	volatile.StoreUint32(&o.R14.Reg, volatile.LoadUint32(&o.R14.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR14_PROCID() uint32 {
	return volatile.LoadUint32(&o.R14.Reg) & 0xff
}
func (o *HSEM_Type) SetR14_COREID(value uint32) {
	volatile.StoreUint32(&o.R14.Reg, volatile.LoadUint32(&o.R14.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR14_COREID() uint32 {
	return (volatile.LoadUint32(&o.R14.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR14_LOCK(value uint32) {
	volatile.StoreUint32(&o.R14.Reg, volatile.LoadUint32(&o.R14.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR14_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R14.Reg) & 0x80000000) >> 31
}

// HSEM.R15: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR15_PROCID(value uint32) {
	volatile.StoreUint32(&o.R15.Reg, volatile.LoadUint32(&o.R15.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR15_PROCID() uint32 {
	return volatile.LoadUint32(&o.R15.Reg) & 0xff
}
func (o *HSEM_Type) SetR15_COREID(value uint32) {
	volatile.StoreUint32(&o.R15.Reg, volatile.LoadUint32(&o.R15.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetR15_COREID() uint32 {
	return (volatile.LoadUint32(&o.R15.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetR15_LOCK(value uint32) {
	volatile.StoreUint32(&o.R15.Reg, volatile.LoadUint32(&o.R15.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR15_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R15.Reg) & 0x80000000) >> 31
}

// HSEM.RLR0: HSEM Read lock register
func (o *HSEM_Type) SetRLR0_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR0.Reg, volatile.LoadUint32(&o.RLR0.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR0_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR0.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR0_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR0.Reg, volatile.LoadUint32(&o.RLR0.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR0_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR0.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR0_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR0.Reg, volatile.LoadUint32(&o.RLR0.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR0_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR0.Reg) & 0x80000000) >> 31
}

// HSEM.RLR1: HSEM Read lock register
func (o *HSEM_Type) SetRLR1_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR1.Reg, volatile.LoadUint32(&o.RLR1.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR1_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR1.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR1_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR1.Reg, volatile.LoadUint32(&o.RLR1.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR1_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR1.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR1_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR1.Reg, volatile.LoadUint32(&o.RLR1.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR1.Reg) & 0x80000000) >> 31
}

// HSEM.RLR2: HSEM Read lock register
func (o *HSEM_Type) SetRLR2_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR2.Reg, volatile.LoadUint32(&o.RLR2.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR2_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR2.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR2_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR2.Reg, volatile.LoadUint32(&o.RLR2.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR2_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR2.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR2_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR2.Reg, volatile.LoadUint32(&o.RLR2.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR2.Reg) & 0x80000000) >> 31
}

// HSEM.RLR3: HSEM Read lock register
func (o *HSEM_Type) SetRLR3_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR3.Reg, volatile.LoadUint32(&o.RLR3.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR3_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR3.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR3_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR3.Reg, volatile.LoadUint32(&o.RLR3.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR3_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR3.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR3_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR3.Reg, volatile.LoadUint32(&o.RLR3.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR3_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR3.Reg) & 0x80000000) >> 31
}

// HSEM.RLR4: HSEM Read lock register
func (o *HSEM_Type) SetRLR4_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR4.Reg, volatile.LoadUint32(&o.RLR4.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR4_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR4.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR4_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR4.Reg, volatile.LoadUint32(&o.RLR4.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR4_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR4.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR4_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR4.Reg, volatile.LoadUint32(&o.RLR4.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR4_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR4.Reg) & 0x80000000) >> 31
}

// HSEM.RLR5: HSEM Read lock register
func (o *HSEM_Type) SetRLR5_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR5.Reg, volatile.LoadUint32(&o.RLR5.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR5_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR5.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR5_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR5.Reg, volatile.LoadUint32(&o.RLR5.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR5_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR5.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR5_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR5.Reg, volatile.LoadUint32(&o.RLR5.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR5_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR5.Reg) & 0x80000000) >> 31
}

// HSEM.RLR6: HSEM Read lock register
func (o *HSEM_Type) SetRLR6_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR6.Reg, volatile.LoadUint32(&o.RLR6.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR6_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR6.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR6_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR6.Reg, volatile.LoadUint32(&o.RLR6.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR6_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR6.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR6_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR6.Reg, volatile.LoadUint32(&o.RLR6.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR6_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR6.Reg) & 0x80000000) >> 31
}

// HSEM.RLR7: HSEM Read lock register
func (o *HSEM_Type) SetRLR7_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR7.Reg, volatile.LoadUint32(&o.RLR7.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR7_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR7.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR7_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR7.Reg, volatile.LoadUint32(&o.RLR7.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR7_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR7.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR7_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR7.Reg, volatile.LoadUint32(&o.RLR7.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR7_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR7.Reg) & 0x80000000) >> 31
}

// HSEM.RLR8: HSEM Read lock register
func (o *HSEM_Type) SetRLR8_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR8.Reg, volatile.LoadUint32(&o.RLR8.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR8_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR8.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR8_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR8.Reg, volatile.LoadUint32(&o.RLR8.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR8_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR8.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR8_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR8.Reg, volatile.LoadUint32(&o.RLR8.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR8_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR8.Reg) & 0x80000000) >> 31
}

// HSEM.RLR9: HSEM Read lock register
func (o *HSEM_Type) SetRLR9_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR9.Reg, volatile.LoadUint32(&o.RLR9.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR9_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR9.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR9_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR9.Reg, volatile.LoadUint32(&o.RLR9.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR9_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR9.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR9_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR9.Reg, volatile.LoadUint32(&o.RLR9.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR9_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR9.Reg) & 0x80000000) >> 31
}

// HSEM.RLR10: HSEM Read lock register
func (o *HSEM_Type) SetRLR10_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR10.Reg, volatile.LoadUint32(&o.RLR10.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR10_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR10.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR10_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR10.Reg, volatile.LoadUint32(&o.RLR10.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR10_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR10.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR10_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR10.Reg, volatile.LoadUint32(&o.RLR10.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR10_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR10.Reg) & 0x80000000) >> 31
}

// HSEM.RLR11: HSEM Read lock register
func (o *HSEM_Type) SetRLR11_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR11.Reg, volatile.LoadUint32(&o.RLR11.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR11_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR11.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR11_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR11.Reg, volatile.LoadUint32(&o.RLR11.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR11_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR11.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR11_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR11.Reg, volatile.LoadUint32(&o.RLR11.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR11_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR11.Reg) & 0x80000000) >> 31
}

// HSEM.RLR12: HSEM Read lock register
func (o *HSEM_Type) SetRLR12_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR12.Reg, volatile.LoadUint32(&o.RLR12.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR12_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR12.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR12_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR12.Reg, volatile.LoadUint32(&o.RLR12.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR12_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR12.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR12_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR12.Reg, volatile.LoadUint32(&o.RLR12.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR12_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR12.Reg) & 0x80000000) >> 31
}

// HSEM.RLR13: HSEM Read lock register
func (o *HSEM_Type) SetRLR13_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR13.Reg, volatile.LoadUint32(&o.RLR13.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR13_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR13.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR13_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR13.Reg, volatile.LoadUint32(&o.RLR13.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR13_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR13.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR13_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR13.Reg, volatile.LoadUint32(&o.RLR13.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR13_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR13.Reg) & 0x80000000) >> 31
}

// HSEM.RLR14: HSEM Read lock register
func (o *HSEM_Type) SetRLR14_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR14.Reg, volatile.LoadUint32(&o.RLR14.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR14_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR14.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR14_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR14.Reg, volatile.LoadUint32(&o.RLR14.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR14_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR14.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR14_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR14.Reg, volatile.LoadUint32(&o.RLR14.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR14_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR14.Reg) & 0x80000000) >> 31
}

// HSEM.RLR15: HSEM Read lock register
func (o *HSEM_Type) SetRLR15_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR15.Reg, volatile.LoadUint32(&o.RLR15.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR15_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR15.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR15_COREID(value uint32) {
	volatile.StoreUint32(&o.RLR15.Reg, volatile.LoadUint32(&o.RLR15.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetRLR15_COREID() uint32 {
	return (volatile.LoadUint32(&o.RLR15.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetRLR15_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR15.Reg, volatile.LoadUint32(&o.RLR15.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR15_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR15.Reg) & 0x80000000) >> 31
}

// HSEM.C1IER: HSEM Interrupt enable register
func (o *HSEM_Type) SetC1IER_ISE0(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1IER_ISE0() uint32 {
	return volatile.LoadUint32(&o.C1IER.Reg) & 0x1
}
func (o *HSEM_Type) SetC1IER_ISE1(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1IER_ISE1() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1IER_ISE2(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1IER_ISE2() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1IER_ISE3(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1IER_ISE3() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1IER_ISE4(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1IER_ISE4() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1IER_ISE5(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1IER_ISE5() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1IER_ISE6(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1IER_ISE6() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1IER_ISE7(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1IER_ISE7() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1IER_ISE8(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1IER_ISE8() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1IER_ISE9(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1IER_ISE9() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1IER_ISE10(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1IER_ISE10() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1IER_ISE11(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1IER_ISE11() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1IER_ISE12(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1IER_ISE12() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1IER_ISE13(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1IER_ISE13() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1IER_ISE14(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1IER_ISE14() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1IER_ISE15(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1IER_ISE15() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x8000) >> 15
}

// HSEM.C1ICR: HSEM Interrupt clear register
func (o *HSEM_Type) SetC1ICR_ISC0(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1ICR_ISC0() uint32 {
	return volatile.LoadUint32(&o.C1ICR.Reg) & 0x1
}
func (o *HSEM_Type) SetC1ICR_ISC1(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1ICR_ISC1() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1ICR_ISC2(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1ICR_ISC2() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1ICR_ISC3(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1ICR_ISC3() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1ICR_ISC4(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1ICR_ISC4() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1ICR_ISC5(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1ICR_ISC5() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1ICR_ISC6(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1ICR_ISC6() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1ICR_ISC7(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1ICR_ISC7() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1ICR_ISC8(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1ICR_ISC8() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1ICR_ISC9(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1ICR_ISC9() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1ICR_ISC10(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1ICR_ISC10() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1ICR_ISC11(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1ICR_ISC11() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1ICR_ISC12(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1ICR_ISC12() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1ICR_ISC13(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1ICR_ISC13() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1ICR_ISC14(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1ICR_ISC14() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1ICR_ISC15(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1ICR_ISC15() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x8000) >> 15
}

// HSEM.C1ISR: HSEM Interrupt status register
func (o *HSEM_Type) SetC1ISR_ISF0(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1ISR_ISF0() uint32 {
	return volatile.LoadUint32(&o.C1ISR.Reg) & 0x1
}
func (o *HSEM_Type) SetC1ISR_ISF1(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1ISR_ISF1() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1ISR_ISF2(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1ISR_ISF2() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1ISR_ISF3(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1ISR_ISF3() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1ISR_ISF4(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1ISR_ISF4() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1ISR_ISF5(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1ISR_ISF5() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1ISR_ISF6(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1ISR_ISF6() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1ISR_ISF7(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1ISR_ISF7() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1ISR_ISF8(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1ISR_ISF8() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1ISR_ISF9(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1ISR_ISF9() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1ISR_ISF10(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1ISR_ISF10() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1ISR_ISF11(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1ISR_ISF11() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1ISR_ISF12(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1ISR_ISF12() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1ISR_ISF13(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1ISR_ISF13() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1ISR_ISF14(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1ISR_ISF14() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1ISR_ISF15(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1ISR_ISF15() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x8000) >> 15
}

// HSEM.C1MISR: HSEM Masked interrupt status register
func (o *HSEM_Type) SetC1MISR_MISF0(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1MISR_MISF0() uint32 {
	return volatile.LoadUint32(&o.C1MISR.Reg) & 0x1
}
func (o *HSEM_Type) SetC1MISR_MISF1(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1MISR_MISF1() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1MISR_MISF2(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1MISR_MISF2() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1MISR_MISF3(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1MISR_MISF3() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1MISR_MISF4(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1MISR_MISF4() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1MISR_MISF5(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1MISR_MISF5() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1MISR_MISF6(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1MISR_MISF6() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1MISR_MISF7(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1MISR_MISF7() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1MISR_MISF8(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1MISR_MISF8() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1MISR_MISF9(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1MISR_MISF9() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1MISR_MISF10(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1MISR_MISF10() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1MISR_MISF11(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1MISR_MISF11() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1MISR_MISF12(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1MISR_MISF12() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1MISR_MISF13(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1MISR_MISF13() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1MISR_MISF14(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1MISR_MISF14() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1MISR_MISF15(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1MISR_MISF15() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x8000) >> 15
}

// HSEM.CR: HSEM Clear register
func (o *HSEM_Type) SetCR_COREID(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetCR_COREID() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSEM_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffff0000) >> 16
}

// HSEM.KEYR: HSEM Interrupt clear register
func (o *HSEM_Type) SetKEYR_KEY(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, volatile.LoadUint32(&o.KEYR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSEM_Type) GetKEYR_KEY() uint32 {
	return (volatile.LoadUint32(&o.KEYR.Reg) & 0xffff0000) >> 16
}

// Inter-integrated circuit
type I2C_Type struct {
	CR1      volatile.Register32 // 0x0
	CR2      volatile.Register32 // 0x4
	OAR1     volatile.Register32 // 0x8
	OAR2     volatile.Register32 // 0xC
	TIMINGR  volatile.Register32 // 0x10
	TIMEOUTR volatile.Register32 // 0x14
	ISR      volatile.Register32 // 0x18
	ICR      volatile.Register32 // 0x1C
	PECR     volatile.Register32 // 0x20
	RXDR     volatile.Register32 // 0x24
	TXDR     volatile.Register32 // 0x28
}

// I2C.CR1: Control register 1
func (o *I2C_Type) SetCR1_PE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCR1_PE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *I2C_Type) SetCR1_TXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCR1_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCR1_RXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCR1_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCR1_ADDRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCR1_ADDRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCR1_NACKIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCR1_NACKIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCR1_STOPIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCR1_STOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCR1_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCR1_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCR1_DNF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00)|value<<8)
}
func (o *I2C_Type) GetCR1_DNF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00) >> 8
}
func (o *I2C_Type) SetCR1_ANFOFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR1_ANFOFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR1_SBC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetCR1_SBC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetCR1_NOSTRETCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetCR1_NOSTRETCH() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetCR1_WUPEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetCR1_WUPEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *I2C_Type) SetCR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetCR1_GCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetCR1_SMBHEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetCR1_SMBHEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetCR1_SMBDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetCR1_SMBDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *I2C_Type) SetCR1_ALERTEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400000)|value<<22)
}
func (o *I2C_Type) GetCR1_ALERTEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400000) >> 22
}
func (o *I2C_Type) SetCR1_PECEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *I2C_Type) GetCR1_PECEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}

// I2C.CR2: Control register 2
func (o *I2C_Type) SetCR2_PECBYTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C_Type) GetCR2_PECBYTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000000) >> 26
}
func (o *I2C_Type) SetCR2_AUTOEND(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetCR2_AUTOEND() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}
func (o *I2C_Type) SetCR2_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetCR2_RELOAD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetCR2_NBYTES(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C_Type) GetCR2_NBYTES() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff0000) >> 16
}
func (o *I2C_Type) SetCR2_NACK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR2_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR2_START(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetCR2_START() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetCR2_HEAD10R(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR2_HEAD10R() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR2_ADD10(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCR2_ADD10() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCR2_RD_WRN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCR2_RD_WRN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCR2_SADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetCR2_SADD() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x3ff
}

// I2C.OAR1: Own address register 1
func (o *I2C_Type) SetOAR1_OA1(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetOAR1_OA1() uint32 {
	return volatile.LoadUint32(&o.OAR1.Reg) & 0x3ff
}
func (o *I2C_Type) SetOAR1_OA1MODE(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetOAR1_OA1MODE() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetOAR1_OA1EN(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR1_OA1EN() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x8000) >> 15
}

// I2C.OAR2: Own address register 2
func (o *I2C_Type) SetOAR2_OA2(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOAR2_OA2() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOAR2_OA2MSK(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x700)|value<<8)
}
func (o *I2C_Type) GetOAR2_OA2MSK() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x700) >> 8
}
func (o *I2C_Type) SetOAR2_OA2EN(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR2_OA2EN() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x8000) >> 15
}

// I2C.TIMINGR: Timing register
func (o *I2C_Type) SetTIMINGR_SCLL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTIMINGR_SCLL() uint32 {
	return volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff
}
func (o *I2C_Type) SetTIMINGR_SCLH(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff00)|value<<8)
}
func (o *I2C_Type) GetTIMINGR_SCLH() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff00) >> 8
}
func (o *I2C_Type) SetTIMINGR_SDADEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000)|value<<16)
}
func (o *I2C_Type) GetTIMINGR_SDADEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000) >> 16
}
func (o *I2C_Type) SetTIMINGR_SCLDEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf00000)|value<<20)
}
func (o *I2C_Type) GetTIMINGR_SCLDEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf00000) >> 20
}
func (o *I2C_Type) SetTIMINGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000000)|value<<28)
}
func (o *I2C_Type) GetTIMINGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000000) >> 28
}

// I2C.TIMEOUTR: Status register 1
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTA(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff)|value)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTA() uint32 {
	return volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff
}
func (o *I2C_Type) SetTIMEOUTR_TIDLE(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetTIMEOUTR_TIDLE() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetTIMEOUTR_TIMOUTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetTIMEOUTR_TIMOUTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTB(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff0000)|value<<16)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTB() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff0000) >> 16
}
func (o *I2C_Type) SetTIMEOUTR_TEXTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetTIMEOUTR_TEXTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x80000000) >> 31
}

// I2C.ISR: Interrupt and Status register
func (o *I2C_Type) SetISR_ADDCODE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xfe0000)|value<<17)
}
func (o *I2C_Type) GetISR_ADDCODE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xfe0000) >> 17
}
func (o *I2C_Type) SetISR_DIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetISR_ALERT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetISR_ALERT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetISR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetISR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetISR_PECERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetISR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetISR_ARLO(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetISR_ARLO() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetISR_BERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetISR_BERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetISR_TCR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetISR_TCR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetISR_STOPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetISR_STOPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetISR_NACKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetISR_NACKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetISR_ADDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetISR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetISR_TXIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetISR_TXIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetISR_TXE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// I2C.ICR: Interrupt clear register
func (o *I2C_Type) SetICR_ALERTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetICR_ALERTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetICR_TIMOUTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetICR_TIMOUTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetICR_PECCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetICR_PECCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetICR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetICR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetICR_ARLOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetICR_ARLOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetICR_BERRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetICR_BERRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetICR_STOPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetICR_STOPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetICR_NACKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetICR_NACKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetICR_ADDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetICR_ADDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}

// I2C.PECR: PEC register
func (o *I2C_Type) SetPECR_PEC(value uint32) {
	volatile.StoreUint32(&o.PECR.Reg, volatile.LoadUint32(&o.PECR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetPECR_PEC() uint32 {
	return volatile.LoadUint32(&o.PECR.Reg) & 0xff
}

// I2C.RXDR: Receive data register
func (o *I2C_Type) SetRXDR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetRXDR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// I2C.TXDR: Transmit data register
func (o *I2C_Type) SetTXDR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTXDR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// Independent watchdog
type IWDG_Type struct {
	KR  volatile.Register32 // 0x0
	PR  volatile.Register32 // 0x4
	RLR volatile.Register32 // 0x8
	SR  volatile.Register32 // 0xC
}

// IWDG.KR: Key register
func (o *IWDG_Type) SetKR_KEY(value uint32) {
	volatile.StoreUint32(&o.KR.Reg, volatile.LoadUint32(&o.KR.Reg)&^(0xffff)|value)
}
func (o *IWDG_Type) GetKR_KEY() uint32 {
	return volatile.LoadUint32(&o.KR.Reg) & 0xffff
}

// IWDG.PR: Prescaler register
func (o *IWDG_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x7)|value)
}
func (o *IWDG_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0x7
}

// IWDG.RLR: Reload register
func (o *IWDG_Type) SetRLR_RL(value uint32) {
	volatile.StoreUint32(&o.RLR.Reg, volatile.LoadUint32(&o.RLR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetRLR_RL() uint32 {
	return volatile.LoadUint32(&o.RLR.Reg) & 0xfff
}

// IWDG.SR: Status register
func (o *IWDG_Type) SetSR_WVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *IWDG_Type) GetSR_WVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *IWDG_Type) SetSR_RVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *IWDG_Type) GetSR_RVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *IWDG_Type) SetSR_PVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *IWDG_Type) GetSR_PVU() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Low-power timer
type LPTIM_Type struct {
	ISR  volatile.Register32 // 0x0
	ICR  volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	CFGR volatile.Register32 // 0xC
	CR   volatile.Register32 // 0x10
	CMP  volatile.Register32 // 0x14
	ARR  volatile.Register32 // 0x18
	CNT  volatile.Register32 // 0x1C
	OR   volatile.Register32 // 0x20
	_    [4]byte
	RCR  volatile.Register32 // 0x28
}

// LPTIM.ISR: interrupt and status register
func (o *LPTIM_Type) SetISR_REPOK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *LPTIM_Type) GetISR_REPOK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *LPTIM_Type) SetISR_UE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *LPTIM_Type) GetISR_UE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *LPTIM_Type) SetISR_DOWN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetISR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetISR_UP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetISR_UP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetISR_ARROK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetISR_ARROK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetISR_CMPOK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetISR_CMPOK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetISR_EXTTRIG(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetISR_EXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetISR_ARRM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetISR_ARRM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetISR_CMPM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetISR_CMPM() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LPTIM.ICR: interrupt clear register
func (o *LPTIM_Type) SetICR_REPOKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *LPTIM_Type) GetICR_REPOKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *LPTIM_Type) SetICR_UECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *LPTIM_Type) GetICR_UECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *LPTIM_Type) SetICR_DOWNCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetICR_DOWNCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetICR_UPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetICR_UPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetICR_ARROKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetICR_ARROKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetICR_CMPOKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetICR_CMPOKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetICR_EXTTRIGCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetICR_EXTTRIGCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetICR_ARRMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetICR_ARRMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetICR_CMPMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetICR_CMPMCF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LPTIM.IER: interrupt enable register
func (o *LPTIM_Type) SetIER_REPOKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *LPTIM_Type) GetIER_REPOKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *LPTIM_Type) SetIER_UEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *LPTIM_Type) GetIER_UEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *LPTIM_Type) SetIER_DOWNIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetIER_DOWNIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetIER_UPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetIER_UPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetIER_ARROKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetIER_ARROKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetIER_CMPOKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetIER_CMPOKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetIER_EXTTRIGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetIER_EXTTRIGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetIER_ARRMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetIER_ARRMIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetIER_CMPMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetIER_CMPMIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LPTIM.CFGR: configuration register
func (o *LPTIM_Type) SetCFGR_ENC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPTIM_Type) GetCFGR_ENC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *LPTIM_Type) SetCFGR_COUNTMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *LPTIM_Type) GetCFGR_COUNTMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *LPTIM_Type) SetCFGR_PRELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *LPTIM_Type) GetCFGR_PRELOAD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *LPTIM_Type) SetCFGR_WAVPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *LPTIM_Type) GetCFGR_WAVPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *LPTIM_Type) SetCFGR_WAVE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *LPTIM_Type) GetCFGR_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *LPTIM_Type) SetCFGR_TIMOUT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000)|value<<19)
}
func (o *LPTIM_Type) GetCFGR_TIMOUT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000) >> 19
}
func (o *LPTIM_Type) SetCFGR_TRIGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x60000)|value<<17)
}
func (o *LPTIM_Type) GetCFGR_TRIGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x60000) >> 17
}
func (o *LPTIM_Type) SetCFGR_TRIGSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe000)|value<<13)
}
func (o *LPTIM_Type) GetCFGR_TRIGSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe000) >> 13
}
func (o *LPTIM_Type) SetCFGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe00)|value<<9)
}
func (o *LPTIM_Type) GetCFGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe00) >> 9
}
func (o *LPTIM_Type) SetCFGR_TRGFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc0)|value<<6)
}
func (o *LPTIM_Type) GetCFGR_TRGFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc0) >> 6
}
func (o *LPTIM_Type) SetCFGR_CKFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x18)|value<<3)
}
func (o *LPTIM_Type) GetCFGR_CKFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x18) >> 3
}
func (o *LPTIM_Type) SetCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x6)|value<<1)
}
func (o *LPTIM_Type) GetCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x6) >> 1
}
func (o *LPTIM_Type) SetCFGR_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCFGR_CKSEL() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x1
}

// LPTIM.CR: control register
func (o *LPTIM_Type) SetCR_RSTARE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetCR_RSTARE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetCR_COUNTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetCR_COUNTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetCR_CNTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetCR_CNTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetCR_SNGSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetCR_SNGSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// LPTIM.CMP: compare register
func (o *LPTIM_Type) SetCMP(value uint32) {
	volatile.StoreUint32(&o.CMP.Reg, volatile.LoadUint32(&o.CMP.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCMP() uint32 {
	return volatile.LoadUint32(&o.CMP.Reg) & 0xffff
}

// LPTIM.ARR: autoreload register
func (o *LPTIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// LPTIM.CNT: counter register
func (o *LPTIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// LPTIM.OR: option register
func (o *LPTIM_Type) SetOR_OR_1(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetOR_OR_1() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetOR_OR_0(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetOR_OR_0() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x1
}

// LPTIM.RCR: repetition register
func (o *LPTIM_Type) SetRCR_REP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xff)|value)
}
func (o *LPTIM_Type) GetRCR_REP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xff
}

// Universal synchronous asynchronous receiver transmitter
type USART_Type struct {
	CR1   volatile.Register32 // 0x0
	CR2   volatile.Register32 // 0x4
	CR3   volatile.Register32 // 0x8
	BRR   volatile.Register32 // 0xC
	_     [8]byte
	RQR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	ICR   volatile.Register32 // 0x20
	RDR   volatile.Register32 // 0x24
	TDR   volatile.Register32 // 0x28
	PRESC volatile.Register32 // 0x2C
}

// USART.CR1: Control register 1
func (o *USART_Type) SetCR1_RXFFIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetCR1_RXFFIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000000) >> 31
}
func (o *USART_Type) SetCR1_TXFEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetCR1_TXFEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetCR1_FIFOEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetCR1_FIFOEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetCR1_M1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR1_M1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR1_DEAT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3e00000)|value<<21)
}
func (o *USART_Type) GetCR1_DEAT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3e00000) >> 21
}
func (o *USART_Type) SetCR1_DEDT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *USART_Type) GetCR1_DEDT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1f0000) >> 16
}
func (o *USART_Type) SetCR1_CMIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR1_CMIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR1_MME(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR1_MME() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR1_M0(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR1_M0() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR1_TE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR1_RE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR1_UESM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR1_UESM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR1_UE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR1_UE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// USART.CR2: Control register 2
func (o *USART_Type) SetCR2_ADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetCR2_ADD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff000000) >> 24
}
func (o *USART_Type) SetCR2_MSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR2_MSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCR2_DATAINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR2_DATAINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR2_TXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetCR2_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetCR2_RXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetCR2_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetCR2_SWAP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR2_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetCR2_ADDM7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR2_ADDM7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}

// USART.CR3: Control register 3
func (o *USART_Type) SetCR3_TXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000000)|value<<29)
}
func (o *USART_Type) GetCR3_TXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000000) >> 29
}
func (o *USART_Type) SetCR3_RXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR3_RXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR3_RXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe000000)|value<<25)
}
func (o *USART_Type) GetCR3_RXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe000000) >> 25
}
func (o *USART_Type) SetCR3_TXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR3_TXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR3_WUFIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetCR3_WUFIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetCR3_WUS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x300000)|value<<20)
}
func (o *USART_Type) GetCR3_WUS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x300000) >> 20
}
func (o *USART_Type) SetCR3_DEP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR3_DEP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR3_DEM(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR3_DEM() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR3_DDRE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR3_DDRE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR3_OVRDIS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR3_OVRDIS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// USART.BRR: Baud rate register
func (o *USART_Type) SetBRR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xfffff)|value)
}
func (o *USART_Type) GetBRR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xfffff
}

// USART.RQR: Request register
func (o *USART_Type) SetRQR_TXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetRQR_TXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetRQR_RXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetRQR_RXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetRQR_MMRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetRQR_MMRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetRQR_SBKRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetRQR_SBKRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x2) >> 1
}

// USART.ISR: Interrupt and status register
func (o *USART_Type) SetISR_TXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetISR_TXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetISR_RXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetISR_RXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetISR_RXFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetISR_RXFF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *USART_Type) SetISR_TXFE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetISR_TXFE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetISR_REACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetISR_REACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetISR_TEACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetISR_TEACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetISR_WUF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetISR_WUF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetISR_RWU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetISR_RWU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetISR_SBKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetISR_SBKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetISR_CMF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetISR_CMF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetISR_CTS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetISR_CTS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetISR_CTSIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetISR_CTSIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetISR_TXFNF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetISR_TXFNF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetISR_RXFNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetISR_RXFNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetISR_IDLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetISR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetISR_ORE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetISR_ORE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetISR_NE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetISR_NE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetISR_FE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetISR_FE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetISR_PE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetISR_PE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// USART.ICR: Interrupt flag clear register
func (o *USART_Type) SetICR_WUCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetICR_WUCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetICR_CMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetICR_CMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetICR_CTSCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetICR_CTSCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetICR_TCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetICR_TCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetICR_IDLECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetICR_IDLECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetICR_ORECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetICR_ORECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetICR_NCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetICR_NCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetICR_FECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetICR_FECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetICR_PECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetICR_PECF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// USART.RDR: Receive data register
func (o *USART_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0x1ff
}

// USART.TDR: Transmit data register
func (o *USART_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0x1ff
}

// USART.PRESC: Prescaler register
func (o *USART_Type) SetPRESC_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESC.Reg, volatile.LoadUint32(&o.PRESC.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetPRESC_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESC.Reg) & 0xf
}

// Memory protection unit
type MPU_Type struct {
	TYPER volatile.Register32 // 0x0
	CTRL  volatile.Register32 // 0x4
	RNR   volatile.Register32 // 0x8
	RBAR  volatile.Register32 // 0xC
	RASR  volatile.Register32 // 0x10
}

// MPU.TYPER: MPU type register
func (o *MPU_Type) SetTYPER_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPER_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPER.Reg) & 0x1
}
func (o *MPU_Type) SetTYPER_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPER_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPER_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPER_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU control register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU region number register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU region base address register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU region attribute and size register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x3e)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x3e) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER0 volatile.Register32 // 0x0
	ISER1 volatile.Register32 // 0x4
	_     [120]byte
	ICER0 volatile.Register32 // 0x80
	ICER1 volatile.Register32 // 0x84
	_     [120]byte
	ISPR0 volatile.Register32 // 0x100
	ISPR1 volatile.Register32 // 0x104
	_     [120]byte
	ICPR0 volatile.Register32 // 0x180
	ICPR1 volatile.Register32 // 0x184
	_     [120]byte
	IABR0 volatile.Register32 // 0x200
	IABR1 volatile.Register32 // 0x204
	_     [248]byte
	IPR0  volatile.Register32 // 0x300
	IPR1  volatile.Register32 // 0x304
	IPR2  volatile.Register32 // 0x308
	IPR3  volatile.Register32 // 0x30C
	IPR4  volatile.Register32 // 0x310
	IPR5  volatile.Register32 // 0x314
	IPR6  volatile.Register32 // 0x318
	IPR7  volatile.Register32 // 0x31C
	IPR8  volatile.Register32 // 0x320
	IPR9  volatile.Register32 // 0x324
	IPR10 volatile.Register32 // 0x328
	IPR11 volatile.Register32 // 0x32C
	IPR12 volatile.Register32 // 0x330
	IPR13 volatile.Register32 // 0x334
	IPR14 volatile.Register32 // 0x338
	IPR15 volatile.Register32 // 0x33C
	IPR16 volatile.Register32 // 0x340
	IPR17 volatile.Register32 // 0x344
}

// NVIC.ISER0: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER0(value uint32) {
	volatile.StoreUint32(&o.ISER0.Reg, value)
}
func (o *NVIC_Type) GetISER0() uint32 {
	return volatile.LoadUint32(&o.ISER0.Reg)
}

// NVIC.ISER1: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER1(value uint32) {
	volatile.StoreUint32(&o.ISER1.Reg, value)
}
func (o *NVIC_Type) GetISER1() uint32 {
	return volatile.LoadUint32(&o.ISER1.Reg)
}

// NVIC.ICER0: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER0(value uint32) {
	volatile.StoreUint32(&o.ICER0.Reg, value)
}
func (o *NVIC_Type) GetICER0() uint32 {
	return volatile.LoadUint32(&o.ICER0.Reg)
}

// NVIC.ICER1: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER1(value uint32) {
	volatile.StoreUint32(&o.ICER1.Reg, value)
}
func (o *NVIC_Type) GetICER1() uint32 {
	return volatile.LoadUint32(&o.ICER1.Reg)
}

// NVIC.ISPR0: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR0(value uint32) {
	volatile.StoreUint32(&o.ISPR0.Reg, value)
}
func (o *NVIC_Type) GetISPR0() uint32 {
	return volatile.LoadUint32(&o.ISPR0.Reg)
}

// NVIC.ISPR1: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR1(value uint32) {
	volatile.StoreUint32(&o.ISPR1.Reg, value)
}
func (o *NVIC_Type) GetISPR1() uint32 {
	return volatile.LoadUint32(&o.ISPR1.Reg)
}

// NVIC.ICPR0: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR0(value uint32) {
	volatile.StoreUint32(&o.ICPR0.Reg, value)
}
func (o *NVIC_Type) GetICPR0() uint32 {
	return volatile.LoadUint32(&o.ICPR0.Reg)
}

// NVIC.ICPR1: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR1(value uint32) {
	volatile.StoreUint32(&o.ICPR1.Reg, value)
}
func (o *NVIC_Type) GetICPR1() uint32 {
	return volatile.LoadUint32(&o.ICPR1.Reg)
}

// NVIC.IABR0: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR0(value uint32) {
	volatile.StoreUint32(&o.IABR0.Reg, value)
}
func (o *NVIC_Type) GetIABR0() uint32 {
	return volatile.LoadUint32(&o.IABR0.Reg)
}

// NVIC.IABR1: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR1(value uint32) {
	volatile.StoreUint32(&o.IABR1.Reg, value)
}
func (o *NVIC_Type) GetIABR1() uint32 {
	return volatile.LoadUint32(&o.IABR1.Reg)
}

// NVIC.IPR0: Interrupt Priority Register
func (o *NVIC_Type) SetIPR0_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR0_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR0_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR0_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR0_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR0_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR0_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR0_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff000000) >> 24
}

// NVIC.IPR1: Interrupt Priority Register
func (o *NVIC_Type) SetIPR1_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR1_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR1_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR1_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR1_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR1_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR1_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR1_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff000000) >> 24
}

// NVIC.IPR2: Interrupt Priority Register
func (o *NVIC_Type) SetIPR2_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR2_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR2_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR2_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR2_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR2_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR2_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR2_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff000000) >> 24
}

// NVIC.IPR3: Interrupt Priority Register
func (o *NVIC_Type) SetIPR3_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR3_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR3_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR3_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR3_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR3_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR3_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR3_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff000000) >> 24
}

// NVIC.IPR4: Interrupt Priority Register
func (o *NVIC_Type) SetIPR4_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR4_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR4.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR4_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR4_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR4_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR4_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR4_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR4_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff000000) >> 24
}

// NVIC.IPR5: Interrupt Priority Register
func (o *NVIC_Type) SetIPR5_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR5_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR5.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR5_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR5_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR5_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR5_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR5_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR5_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff000000) >> 24
}

// NVIC.IPR6: Interrupt Priority Register
func (o *NVIC_Type) SetIPR6_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR6_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR6.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR6_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR6_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR6_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR6_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR6_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR6_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff000000) >> 24
}

// NVIC.IPR7: Interrupt Priority Register
func (o *NVIC_Type) SetIPR7_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR7_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR7.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR7_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR7_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR7_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR7_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR7_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR7_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff000000) >> 24
}

// NVIC.IPR8: Interrupt Priority Register
func (o *NVIC_Type) SetIPR8_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR8_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR8.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR8_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR8_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR8_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR8_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR8_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR8_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff000000) >> 24
}

// NVIC.IPR9: Interrupt Priority Register
func (o *NVIC_Type) SetIPR9_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR9_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR9.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR9_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR9_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR9_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR9_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR9_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR9_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff000000) >> 24
}

// NVIC.IPR10: Interrupt Priority Register
func (o *NVIC_Type) SetIPR10_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR10_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR10.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR10_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR10_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR10_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR10_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR10_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR10_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff000000) >> 24
}

// NVIC.IPR11: Interrupt Priority Register
func (o *NVIC_Type) SetIPR11_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR11_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR11.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR11_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR11_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR11_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR11_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR11_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR11_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff000000) >> 24
}

// NVIC.IPR12: Interrupt Priority Register
func (o *NVIC_Type) SetIPR12_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR12_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR12.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR12_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR12_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR12_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR12_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR12_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR12_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff000000) >> 24
}

// NVIC.IPR13: Interrupt Priority Register
func (o *NVIC_Type) SetIPR13_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR13_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR13.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR13_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR13_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR13_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR13_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR13_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR13_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff000000) >> 24
}

// NVIC.IPR14: Interrupt Priority Register
func (o *NVIC_Type) SetIPR14_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR14_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR14.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR14_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR14_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR14_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR14_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR14_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR14_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff000000) >> 24
}

// NVIC.IPR15: Interrupt Priority Register
func (o *NVIC_Type) SetIPR15_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR15_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR15.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR15_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR15_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR15_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR15_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR15_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR15_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff000000) >> 24
}

// NVIC.IPR16: Interrupt Priority Register
func (o *NVIC_Type) SetIPR16_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR16_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR16.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR16_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR16_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR16_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR16_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR16_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR16_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff000000) >> 24
}

// NVIC.IPR17: Interrupt Priority Register
func (o *NVIC_Type) SetIPR17_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR17_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR17.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR17_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR17_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR17_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR17_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR17_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR17_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff000000) >> 24
}

// Public key accelerator
type PKA_Type struct {
	CR    volatile.Register32 // 0x0
	SR    volatile.Register32 // 0x4
	CLRFR volatile.Register32 // 0x8
}

// PKA.CR: control register
func (o *PKA_Type) SetCR_ADDRERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *PKA_Type) GetCR_ADDRERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *PKA_Type) SetCR_RAMERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *PKA_Type) GetCR_RAMERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *PKA_Type) SetCR_PROCENDIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *PKA_Type) GetCR_PROCENDIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *PKA_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f00)|value<<8)
}
func (o *PKA_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3f00) >> 8
}
func (o *PKA_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *PKA_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *PKA_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *PKA_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// PKA.SR: status register
func (o *PKA_Type) SetSR_ADDRERRF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *PKA_Type) GetSR_ADDRERRF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *PKA_Type) SetSR_RAMERRF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *PKA_Type) GetSR_RAMERRF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *PKA_Type) SetSR_PROCENDF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *PKA_Type) GetSR_PROCENDF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *PKA_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *PKA_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}

// PKA.CLRFR: clear flag register
func (o *PKA_Type) SetCLRFR_ADDRERRFC(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x100000)|value<<20)
}
func (o *PKA_Type) GetCLRFR_ADDRERRFC() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x100000) >> 20
}
func (o *PKA_Type) SetCLRFR_RAMERRFC(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x80000)|value<<19)
}
func (o *PKA_Type) GetCLRFR_RAMERRFC() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x80000) >> 19
}
func (o *PKA_Type) SetCLRFR_PROCENDFC(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x20000)|value<<17)
}
func (o *PKA_Type) GetCLRFR_PROCENDFC() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x20000) >> 17
}

// Power control
type PWR_Type struct {
	CR1         volatile.Register32 // 0x0
	CR2         volatile.Register32 // 0x4
	CR3         volatile.Register32 // 0x8
	CR4         volatile.Register32 // 0xC
	SR1         volatile.Register32 // 0x10
	SR2         volatile.Register32 // 0x14
	SCR         volatile.Register32 // 0x18
	CR5         volatile.Register32 // 0x1C
	PUCRA       volatile.Register32 // 0x20
	PDCRA       volatile.Register32 // 0x24
	PUCRB       volatile.Register32 // 0x28
	PDCRB       volatile.Register32 // 0x2C
	PUCRC       volatile.Register32 // 0x30
	PDCRC       volatile.Register32 // 0x34
	_           [32]byte
	PUCRH       volatile.Register32 // 0x58
	PDCRH       volatile.Register32 // 0x5C
	_           [40]byte
	EXTSCR      volatile.Register32 // 0x88
	_           [4]byte
	SUBGHZSPICR volatile.Register32 // 0x90
}

// PWR.CR1: Power control register 1
func (o *PWR_Type) SetCR1_LPR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetCR1_LPR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetCR1_VOS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x600)|value<<9)
}
func (o *PWR_Type) GetCR1_VOS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x600) >> 9
}
func (o *PWR_Type) SetCR1_DBP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR1_DBP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR1_FPDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCR1_FPDS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCR1_FPDR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR1_FPDR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR1_SUBGHZSPINSSSEL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR1_SUBGHZSPINSSSEL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR1_LPMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x7)|value)
}
func (o *PWR_Type) GetCR1_LPMS() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x7
}

// PWR.CR2: Power control register 2
func (o *PWR_Type) SetCR2_PVME3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetCR2_PVME3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetCR2_PLS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xe)|value<<1)
}
func (o *PWR_Type) GetCR2_PLS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xe) >> 1
}
func (o *PWR_Type) SetCR2_PVDE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR2_PVDE() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// PWR.CR3: Power control register 3
func (o *PWR_Type) SetCR3_EIWUL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetCR3_EIWUL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetCR3_EWRFIRQ(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetCR3_EWRFIRQ() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetCR3_EWRFBUSY(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetCR3_EWRFBUSY() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetCR3_APC(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCR3_APC() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCR3_RRS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR3_RRS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR3_EWPVD(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR3_EWPVD() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR3_EULPEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetCR3_EULPEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetCR3_EWUP3(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCR3_EWUP3() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCR3_EWUP2(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR3_EWUP2() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR3_EWUP1(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR3_EWUP1() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// PWR.CR4: Power control register 4
func (o *PWR_Type) SetCR4_WRFBUSYP(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetCR4_WRFBUSYP() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetCR4_VBRS(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR4_VBRS() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR4_VBE(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR4_VBE() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR4_WP3(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCR4_WP3() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCR4_WP2(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR4_WP2() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR4_WP1(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR4_WP1() uint32 {
	return volatile.LoadUint32(&o.CR4.Reg) & 0x1
}

// PWR.SR1: Power status register 1
func (o *PWR_Type) SetSR1_WUFI(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetSR1_WUFI() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetSR1_WRFBUSYF(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetSR1_WRFBUSYF() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetSR1_WPVDF(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSR1_WPVDF() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSR1_WUF3(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetSR1_WUF3() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetSR1_WUF2(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSR1_WUF2() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetSR1_WUF1(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetSR1_WUF1() uint32 {
	return volatile.LoadUint32(&o.SR1.Reg) & 0x1
}

// PWR.SR2: Power status register 2
func (o *PWR_Type) SetSR2_PVMO3(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetSR2_PVMO3() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetSR2_PVDO(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetSR2_PVDO() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetSR2_VOSF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetSR2_VOSF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetSR2_REGLPF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetSR2_REGLPF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetSR2_REGLPS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSR2_REGLPS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSR2_FLASHRDY(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetSR2_FLASHRDY() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetSR2_REGMRS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetSR2_REGMRS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetSR2_RFEOLF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetSR2_RFEOLF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetSR2_LDORDY(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetSR2_LDORDY() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetSR2_SMPSRDY(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetSR2_SMPSRDY() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetSR2_RFBUSYMS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetSR2_RFBUSYMS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetSR2_RFBUSYS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSR2_RFBUSYS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x2) >> 1
}

// PWR.SCR: Power status clear register
func (o *PWR_Type) SetSCR_CWRFBUSYF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetSCR_CWRFBUSYF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetSCR_CWPVDF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSCR_CWPVDF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSCR_CWUF3(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetSCR_CWUF3() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetSCR_CWUF2(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSCR_CWUF2() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetSCR_CWUF1(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetSCR_CWUF1() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}

// PWR.CR5: Power control register 5
func (o *PWR_Type) SetCR5_SMPSEN(value uint32) {
	volatile.StoreUint32(&o.CR5.Reg, volatile.LoadUint32(&o.CR5.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetCR5_SMPSEN() uint32 {
	return (volatile.LoadUint32(&o.CR5.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetCR5_RFEOLEN(value uint32) {
	volatile.StoreUint32(&o.CR5.Reg, volatile.LoadUint32(&o.CR5.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetCR5_RFEOLEN() uint32 {
	return (volatile.LoadUint32(&o.CR5.Reg) & 0x4000) >> 14
}

// PWR.PUCRA: Power Port A pull-up control register
func (o *PWR_Type) SetPUCRA_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRA_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRA_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRA_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRA_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRA_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRA_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRA_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRA_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRA_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRA_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRA_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRA_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRA_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRA_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRA_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRA_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRA_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRA_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRA_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRA_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRA_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRA_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRA_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRA_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRA_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRA_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRA_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRA_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRA_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRA_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRA_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRA.Reg) & 0x1
}

// PWR.PDCRA: Power Port A pull-down control register
func (o *PWR_Type) SetPDCRA_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRA_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRA_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRA_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRA_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRA_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRA_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRA_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRA_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRA_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRA_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRA_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRA_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRA_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRA_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRA_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRA_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRA_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRA_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRA_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRA_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRA_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRA_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRA_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRA_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRA_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRA_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRA_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRA_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRA_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRA_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRA_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRA.Reg) & 0x1
}

// PWR.PUCRB: Power Port B pull-up control register
func (o *PWR_Type) SetPUCRB_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRB_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRB_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRB_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRB_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRB_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRB_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRB_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRB_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRB_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRB_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRB_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRB_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRB_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRB_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRB_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRB_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRB_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRB_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRB_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRB_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRB_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRB_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRB_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRB_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRB_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRB_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRB_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRB_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRB_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRB_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRB_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRB.Reg) & 0x1
}

// PWR.PDCRB: Power Port B pull-down control register
func (o *PWR_Type) SetPDCRB_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRB_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRB_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRB_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRB_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRB_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRB_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRB_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRB_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRB_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRB_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRB_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRB_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRB_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRB_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRB_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRB_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRB_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRB_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRB_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRB_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRB_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRB_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRB_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRB_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRB_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRB_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRB_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRB_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRB_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRB_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRB_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRB.Reg) & 0x1
}

// PWR.PUCRC: Power Port C pull-up control register
func (o *PWR_Type) SetPUCRC_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRC_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRC_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRC_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRC_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRC_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRC_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRC_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRC_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRC_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRC_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRC_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRC.Reg) & 0x1
}
func (o *PWR_Type) SetPUCRC_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRC_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRC_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRC_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRC_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRC_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRC_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRC_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x40) >> 6
}

// PWR.PDCRC: Power Port C pull-down control register
func (o *PWR_Type) SetPDCRC_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRC_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRC_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRC_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRC_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRC_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRC_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRC_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRC_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRC_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRC_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRC_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRC.Reg) & 0x1
}
func (o *PWR_Type) SetPDCRC_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRC_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRC_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRC_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRC_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRC_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRC_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRC_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x40) >> 6
}

// PWR.PUCRH: Power Port H pull-up control register
func (o *PWR_Type) SetPUCRH_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRH.Reg, volatile.LoadUint32(&o.PUCRH.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRH_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRH.Reg) & 0x8) >> 3
}

// PWR.PDCRH: Power Port H pull-down control register
func (o *PWR_Type) SetPDCRH_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRH.Reg, volatile.LoadUint32(&o.PDCRH.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRH_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRH.Reg) & 0x8) >> 3
}

// PWR.EXTSCR: Power extended status and status clear register
func (o *PWR_Type) SetEXTSCR_C1DS(value uint32) {
	volatile.StoreUint32(&o.EXTSCR.Reg, volatile.LoadUint32(&o.EXTSCR.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetEXTSCR_C1DS() uint32 {
	return (volatile.LoadUint32(&o.EXTSCR.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetEXTSCR_C1STOPF(value uint32) {
	volatile.StoreUint32(&o.EXTSCR.Reg, volatile.LoadUint32(&o.EXTSCR.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetEXTSCR_C1STOPF() uint32 {
	return (volatile.LoadUint32(&o.EXTSCR.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetEXTSCR_C1STOP2F(value uint32) {
	volatile.StoreUint32(&o.EXTSCR.Reg, volatile.LoadUint32(&o.EXTSCR.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetEXTSCR_C1STOP2F() uint32 {
	return (volatile.LoadUint32(&o.EXTSCR.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetEXTSCR_C1SBF(value uint32) {
	volatile.StoreUint32(&o.EXTSCR.Reg, volatile.LoadUint32(&o.EXTSCR.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetEXTSCR_C1SBF() uint32 {
	return (volatile.LoadUint32(&o.EXTSCR.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetEXTSCR_C1CSSF(value uint32) {
	volatile.StoreUint32(&o.EXTSCR.Reg, volatile.LoadUint32(&o.EXTSCR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetEXTSCR_C1CSSF() uint32 {
	return volatile.LoadUint32(&o.EXTSCR.Reg) & 0x1
}

// PWR.SUBGHZSPICR: Power SPI3 control register
func (o *PWR_Type) SetSUBGHZSPICR_NSS(value uint32) {
	volatile.StoreUint32(&o.SUBGHZSPICR.Reg, volatile.LoadUint32(&o.SUBGHZSPICR.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetSUBGHZSPICR_NSS() uint32 {
	return (volatile.LoadUint32(&o.SUBGHZSPICR.Reg) & 0x8000) >> 15
}

// Reset and clock control
type RCC_Type struct {
	CR         volatile.Register32 // 0x0
	ICSCR      volatile.Register32 // 0x4
	CFGR       volatile.Register32 // 0x8
	PLLCFGR    volatile.Register32 // 0xC
	_          [8]byte
	CIER       volatile.Register32 // 0x18
	CIFR       volatile.Register32 // 0x1C
	CICR       volatile.Register32 // 0x20
	_          [4]byte
	AHB1RSTR   volatile.Register32 // 0x28
	AHB2RSTR   volatile.Register32 // 0x2C
	AHB3RSTR   volatile.Register32 // 0x30
	_          [4]byte
	APB1RSTR1  volatile.Register32 // 0x38
	APB1RSTR2  volatile.Register32 // 0x3C
	APB2RSTR   volatile.Register32 // 0x40
	APB3RSTR   volatile.Register32 // 0x44
	AHB1ENR    volatile.Register32 // 0x48
	AHB2ENR    volatile.Register32 // 0x4C
	AHB3ENR    volatile.Register32 // 0x50
	_          [4]byte
	APB1ENR1   volatile.Register32 // 0x58
	APB1ENR2   volatile.Register32 // 0x5C
	APB2ENR    volatile.Register32 // 0x60
	APB3ENR    volatile.Register32 // 0x64
	AHB1SMENR  volatile.Register32 // 0x68
	AHB2SMENR  volatile.Register32 // 0x6C
	AHB3SMENR  volatile.Register32 // 0x70
	_          [4]byte
	APB1SMENR1 volatile.Register32 // 0x78
	APB1SMENR2 volatile.Register32 // 0x7C
	APB2SMENR  volatile.Register32 // 0x80
	APB3SMENR  volatile.Register32 // 0x84
	CCIPR      volatile.Register32 // 0x88
	_          [4]byte
	BDCR       volatile.Register32 // 0x90
	CSR        volatile.Register32 // 0x94
	_          [112]byte
	EXTCFGR    volatile.Register32 // 0x108
}

// RCC.CR: Clock control register
func (o *RCC_Type) SetCR_PLLRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCR_PLLRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCR_PLLON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCR_PLLON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCR_HSEBYPPWR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetCR_HSEBYPPWR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetCR_HSEPRE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetCR_HSEPRE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetCR_CSSON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCR_CSSON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCR_HSERDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCR_HSERDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCR_HSEON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCR_HSEON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCR_HSIKERDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetCR_HSIKERDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetCR_HSIASFS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetCR_HSIASFS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetCR_HSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCR_HSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetCR_HSIKERON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCR_HSIKERON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCR_HSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCR_HSION() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCR_MSIRANGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetCR_MSIRANGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetCR_MSIRGSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCR_MSIRGSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCR_MSIPLLEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCR_MSIPLLEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCR_MSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCR_MSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCR_MSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCR_MSION() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// RCC.ICSCR: Internal clock sources calibration register
func (o *RCC_Type) SetICSCR_HSITRIM(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0x7f000000)|value<<24)
}
func (o *RCC_Type) GetICSCR_HSITRIM() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0x7f000000) >> 24
}
func (o *RCC_Type) SetICSCR_HSICAL(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff0000)|value<<16)
}
func (o *RCC_Type) GetICSCR_HSICAL() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0xff0000) >> 16
}
func (o *RCC_Type) SetICSCR_MSITRIM(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff00)|value<<8)
}
func (o *RCC_Type) GetICSCR_MSITRIM() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0xff00) >> 8
}
func (o *RCC_Type) SetICSCR_MSICAL(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff)|value)
}
func (o *RCC_Type) GetICSCR_MSICAL() uint32 {
	return volatile.LoadUint32(&o.ICSCR.Reg) & 0xff
}

// RCC.CFGR: Clock configuration register
func (o *RCC_Type) SetCFGR_MCOPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetCFGR_MCOPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x70000000) >> 28
}
func (o *RCC_Type) SetCFGR_MCOSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xf000000)|value<<24)
}
func (o *RCC_Type) GetCFGR_MCOSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xf000000) >> 24
}
func (o *RCC_Type) SetCFGR_PPRE2F(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCFGR_PPRE2F() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCFGR_PPRE1F(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCFGR_PPRE1F() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCFGR_HPREF(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCFGR_HPREF() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCFGR_STOPWUCK(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetCFGR_STOPWUCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetCFGR_PPRE2(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3800)|value<<11)
}
func (o *RCC_Type) GetCFGR_PPRE2() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x3800) >> 11
}
func (o *RCC_Type) SetCFGR_PPRE1(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x700)|value<<8)
}
func (o *RCC_Type) GetCFGR_PPRE1() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x700) >> 8
}
func (o *RCC_Type) SetCFGR_HPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetCFGR_HPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetCFGR_SWS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCFGR_SWS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetCFGR_SW(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCFGR_SW() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x3
}

// RCC.PLLCFGR: PLL configuration register
func (o *RCC_Type) SetPLLCFGR_PLLR(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xe0000000)|value<<29)
}
func (o *RCC_Type) GetPLLCFGR_PLLR() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xe0000000) >> 29
}
func (o *RCC_Type) SetPLLCFGR_PLLREN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetPLLCFGR_PLLREN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetPLLCFGR_PLLQ(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xe000000)|value<<25)
}
func (o *RCC_Type) GetPLLCFGR_PLLQ() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xe000000) >> 25
}
func (o *RCC_Type) SetPLLCFGR_PLLQEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetPLLCFGR_PLLQEN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetPLLCFGR_PLLP(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x3e0000)|value<<17)
}
func (o *RCC_Type) GetPLLCFGR_PLLP() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x3e0000) >> 17
}
func (o *RCC_Type) SetPLLCFGR_PLLPEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetPLLCFGR_PLLPEN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetPLLCFGR_PLLN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x7f00)|value<<8)
}
func (o *RCC_Type) GetPLLCFGR_PLLN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x7f00) >> 8
}
func (o *RCC_Type) SetPLLCFGR_PLLM(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x70)|value<<4)
}
func (o *RCC_Type) GetPLLCFGR_PLLM() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x70) >> 4
}
func (o *RCC_Type) SetPLLCFGR_PLLSRC(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetPLLCFGR_PLLSRC() uint32 {
	return volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x3
}

// RCC.CIER: Clock interrupt enable register
func (o *RCC_Type) SetCIER_LSECSSIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIER_LSECSSIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCIER_PLLRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIER_PLLRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIER_HSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIER_HSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIER_HSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIER_HSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIER_MSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIER_MSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIER_LSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIER_LSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIER_LSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIER_LSIRDYIE() uint32 {
	return volatile.LoadUint32(&o.CIER.Reg) & 0x1
}

// RCC.CIFR: Clock interrupt flag register
func (o *RCC_Type) SetCIFR_LSECSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIFR_LSECSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCIFR_CSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCIFR_CSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCIFR_PLLRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIFR_PLLRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIFR_HSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIFR_HSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIFR_HSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIFR_HSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIFR_MSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIFR_MSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIFR_LSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIFR_LSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIFR_LSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIFR_LSIRDYF() uint32 {
	return volatile.LoadUint32(&o.CIFR.Reg) & 0x1
}

// RCC.CICR: Clock interrupt clear register
func (o *RCC_Type) SetCICR_LSECSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCICR_LSECSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCICR_CSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCICR_CSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCICR_PLLRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCICR_PLLRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCICR_HSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCICR_HSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCICR_HSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCICR_HSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCICR_MSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCICR_MSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCICR_LSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCICR_LSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCICR_LSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCICR_LSIRDYC() uint32 {
	return volatile.LoadUint32(&o.CICR.Reg) & 0x1
}

// RCC.AHB1RSTR: AHB1 peripheral reset register
func (o *RCC_Type) SetAHB1RSTR_CRCRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1RSTR_CRCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1RSTR_DMAMUX1RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1RSTR_DMAMUX1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1RSTR_DMA2RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1RSTR_DMA2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1RSTR_DMA1RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1RSTR_DMA1RST() uint32 {
	return volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1
}

// RCC.AHB2RSTR: AHB2 peripheral reset register
func (o *RCC_Type) SetAHB2RSTR_GPIOHRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2RSTR_GPIOCRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB2RSTR_GPIOBRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOBRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB2RSTR_GPIOARST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOARST() uint32 {
	return volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x1
}

// RCC.AHB3RSTR: AHB3 peripheral reset register
func (o *RCC_Type) SetAHB3RSTR_FLASHRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB3RSTR_FLASHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB3RSTR_HSEMRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB3RSTR_HSEMRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB3RSTR_RNGRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB3RSTR_RNGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB3RSTR_AESRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB3RSTR_AESRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB3RSTR_PKARST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB3RSTR_PKARST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x10000) >> 16
}

// RCC.APB1RSTR1: APB1 peripheral reset register 1
func (o *RCC_Type) SetAPB1RSTR1_LPTIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1RSTR1_LPTIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1RSTR1_DACRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1RSTR1_DACRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1RSTR1_I2C3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1RSTR1_I2C3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1RSTR1_I2C2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1RSTR1_I2C2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1RSTR1_I2C1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1RSTR1_I2C1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1RSTR1_USART2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1RSTR1_USART2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1RSTR1_SPI2S2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1RSTR1_SPI2S2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1RSTR1_TIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM2RST() uint32 {
	return volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x1
}

// RCC.APB1RSTR2: APB1 peripheral reset register 2
func (o *RCC_Type) SetAPB1RSTR2_LPTIM3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR2.Reg, volatile.LoadUint32(&o.APB1RSTR2.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1RSTR2_LPTIM3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR2.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1RSTR2_LPTIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR2.Reg, volatile.LoadUint32(&o.APB1RSTR2.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1RSTR2_LPTIM2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR2.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1RSTR2_LPUART1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR2.Reg, volatile.LoadUint32(&o.APB1RSTR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1RSTR2_LPUART1RST() uint32 {
	return volatile.LoadUint32(&o.APB1RSTR2.Reg) & 0x1
}

// RCC.APB2RSTR: APB2 peripheral reset register
func (o *RCC_Type) SetAPB2RSTR_TIM17RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2RSTR_TIM17RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2RSTR_TIM16RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2RSTR_TIM16RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2RSTR_USART1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2RSTR_USART1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2RSTR_SPI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2RSTR_SPI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2RSTR_TIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2RSTR_TIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2RSTR_ADCRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2RSTR_ADCRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x200) >> 9
}

// RCC.APB3RSTR: APB3 peripheral reset register
func (o *RCC_Type) SetAPB3RSTR_SUBGHZSPIRST(value uint32) {
	volatile.StoreUint32(&o.APB3RSTR.Reg, volatile.LoadUint32(&o.APB3RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB3RSTR_SUBGHZSPIRST() uint32 {
	return volatile.LoadUint32(&o.APB3RSTR.Reg) & 0x1
}

// RCC.AHB1ENR: AHB1 peripheral clock enable register
func (o *RCC_Type) SetAHB1ENR_CRCEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1ENR_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1ENR_DMAMUX1EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1ENR_DMAMUX1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1ENR_DMA2EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1ENR_DMA2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1ENR_DMA1EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1ENR_DMA1EN() uint32 {
	return volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1
}

// RCC.AHB2ENR: AHB2 peripheral clock enable register
func (o *RCC_Type) SetAHB2ENR_GPIOHEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2ENR_GPIOHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2ENR_GPIOCEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB2ENR_GPIOCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB2ENR_GPIOBEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2ENR_GPIOBEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB2ENR_GPIOAEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2ENR_GPIOAEN() uint32 {
	return volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x1
}

// RCC.AHB3ENR: AHB3 peripheral clock enable register
func (o *RCC_Type) SetAHB3ENR_FLASHEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB3ENR_FLASHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB3ENR_HSEMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB3ENR_HSEMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB3ENR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB3ENR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB3ENR_AESEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB3ENR_AESEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB3ENR_PKAEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB3ENR_PKAEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x10000) >> 16
}

// RCC.APB1ENR1: APB1 peripheral clock enable register 1
func (o *RCC_Type) SetAPB1ENR1_LPTIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1ENR1_LPTIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1ENR1_DAC1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1ENR1_DAC1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1ENR1_I2C3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1ENR1_I2C3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1ENR1_I2C2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1ENR1_I2C2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1ENR1_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1ENR1_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1ENR1_USART2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1ENR1_USART2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1ENR1_SPI2S2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1ENR1_SPI2S2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1ENR1_WWDGEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1ENR1_WWDGEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1ENR1_RTCAPBEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB1ENR1_RTCAPBEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB1ENR1_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1ENR1_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x1
}

// RCC.APB1ENR2: APB1 peripheral clock enable register 2
func (o *RCC_Type) SetAPB1ENR2_LPTIM3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR2.Reg, volatile.LoadUint32(&o.APB1ENR2.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1ENR2_LPTIM3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR2.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1ENR2_LPTIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR2.Reg, volatile.LoadUint32(&o.APB1ENR2.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1ENR2_LPTIM2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR2.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1ENR2_LPUART1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR2.Reg, volatile.LoadUint32(&o.APB1ENR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1ENR2_LPUART1EN() uint32 {
	return volatile.LoadUint32(&o.APB1ENR2.Reg) & 0x1
}

// RCC.APB2ENR: APB2 peripheral clock enable register
func (o *RCC_Type) SetAPB2ENR_TIM17EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2ENR_TIM17EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2ENR_TIM16EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2ENR_TIM16EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2ENR_USART1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2ENR_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2ENR_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2ENR_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2ENR_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2ENR_TIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2ENR_ADCEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2ENR_ADCEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x200) >> 9
}

// RCC.APB3ENR: APB3 peripheral clock enable register
func (o *RCC_Type) SetAPB3ENR_SUBGHZSPIEN(value uint32) {
	volatile.StoreUint32(&o.APB3ENR.Reg, volatile.LoadUint32(&o.APB3ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB3ENR_SUBGHZSPIEN() uint32 {
	return volatile.LoadUint32(&o.APB3ENR.Reg) & 0x1
}

// RCC.AHB1SMENR: AHB1 peripheral clocks enable in Sleep modes register
func (o *RCC_Type) SetAHB1SMENR_CRCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1SMENR_CRCSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1SMENR_DMAMUX1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1SMENR_DMAMUX1SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1SMENR_DMA2SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1SMENR_DMA2SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1SMENR_DMA1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1SMENR_DMA1SMEN() uint32 {
	return volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x1
}

// RCC.AHB2SMENR: AHB2 peripheral clocks enable in Sleep modes register
func (o *RCC_Type) SetAHB2SMENR_GPIOHSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOHSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2SMENR_GPIOCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOCSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB2SMENR_GPIOBSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOBSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB2SMENR_GPIOASMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOASMEN() uint32 {
	return volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x1
}

// RCC.AHB3SMENR: AHB3 peripheral clocks enable in Sleep and Stop modes register
func (o *RCC_Type) SetAHB3SMENR_FLASHSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB3SMENR_FLASHSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB3SMENR_SRAM2SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAHB3SMENR_SRAM2SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAHB3SMENR_SRAM1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB3SMENR_SRAM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAHB3SMENR_RNGSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB3SMENR_RNGSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB3SMENR_AESSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB3SMENR_AESSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB3SMENR_PKASMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB3SMENR_PKASMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x10000) >> 16
}

// RCC.APB1SMENR1: APB1 peripheral clocks enable in Sleep mode register 1
func (o *RCC_Type) SetAPB1SMENR1_LPTIM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1SMENR1_LPTIM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1SMENR1_DACSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1SMENR1_DACSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1SMENR1_I2C3SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1SMENR1_I2C3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1SMENR1_I2C2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1SMENR1_I2C2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1SMENR1_I2C1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1SMENR1_I2C1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1SMENR1_USART2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1SMENR1_USART2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1SMENR1_SPI2S2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1SMENR1_SPI2S2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1SMENR1_WWDGSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1SMENR1_WWDGSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1SMENR1_RTCAPBSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB1SMENR1_RTCAPBSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB1SMENR1_TIM2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM2SMEN() uint32 {
	return volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x1
}

// RCC.APB1SMENR2: APB1 peripheral clocks enable in Sleep mode register 2
func (o *RCC_Type) SetAPB1SMENR2_LPTIM3SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR2.Reg, volatile.LoadUint32(&o.APB1SMENR2.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1SMENR2_LPTIM3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR2.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1SMENR2_LPTIM2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR2.Reg, volatile.LoadUint32(&o.APB1SMENR2.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1SMENR2_LPTIM2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR2.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1SMENR2_LPUART1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR2.Reg, volatile.LoadUint32(&o.APB1SMENR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1SMENR2_LPUART1SMEN() uint32 {
	return volatile.LoadUint32(&o.APB1SMENR2.Reg) & 0x1
}

// RCC.APB2SMENR: APB2 peripheral clocks enable in Sleep mode register
func (o *RCC_Type) SetAPB2SMENR_TIM17SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2SMENR_TIM17SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2SMENR_TIM16SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2SMENR_TIM16SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2SMENR_USART1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2SMENR_USART1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2SMENR_SPI1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2SMENR_SPI1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2SMENR_TIM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2SMENR_TIM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2SMENR_ADCSMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2SMENR_ADCSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x200) >> 9
}

// RCC.APB3SMENR: APB3 peripheral clock enable in Sleep mode register
func (o *RCC_Type) SetAPB3SMENR_SUBGHZSPISMEN(value uint32) {
	volatile.StoreUint32(&o.APB3SMENR.Reg, volatile.LoadUint32(&o.APB3SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB3SMENR_SUBGHZSPISMEN() uint32 {
	return volatile.LoadUint32(&o.APB3SMENR.Reg) & 0x1
}

// RCC.CCIPR: Peripherals independent clock configuration register
func (o *RCC_Type) SetCCIPR_RNGSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc0000000)|value<<30)
}
func (o *RCC_Type) GetCCIPR_RNGSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc0000000) >> 30
}
func (o *RCC_Type) SetCCIPR_ADCSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x30000000)|value<<28)
}
func (o *RCC_Type) GetCCIPR_ADCSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x30000000) >> 28
}
func (o *RCC_Type) SetCCIPR_LPTIM3SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc00000)|value<<22)
}
func (o *RCC_Type) GetCCIPR_LPTIM3SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc00000) >> 22
}
func (o *RCC_Type) SetCCIPR_LPTIM2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetCCIPR_LPTIM2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetCCIPR_LPTIM1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc0000)|value<<18)
}
func (o *RCC_Type) GetCCIPR_LPTIM1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc0000) >> 18
}
func (o *RCC_Type) SetCCIPR_I2C3SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetCCIPR_I2C3SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetCCIPR_I2C2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc000)|value<<14)
}
func (o *RCC_Type) GetCCIPR_I2C2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc000) >> 14
}
func (o *RCC_Type) SetCCIPR_I2C1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3000)|value<<12)
}
func (o *RCC_Type) GetCCIPR_I2C1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x3000) >> 12
}
func (o *RCC_Type) SetCCIPR_LPUART1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc00)|value<<10)
}
func (o *RCC_Type) GetCCIPR_LPUART1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc00) >> 10
}
func (o *RCC_Type) SetCCIPR_SPI2S2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetCCIPR_SPI2S2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetCCIPR_USART2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCCIPR_USART2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetCCIPR_USART1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCCIPR_USART1SEL() uint32 {
	return volatile.LoadUint32(&o.CCIPR.Reg) & 0x3
}

// RCC.BDCR: Backup domain control register
func (o *RCC_Type) SetBDCR_LSCOSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetBDCR_LSCOSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetBDCR_LSCOEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetBDCR_LSCOEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetBDCR_BDRST(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetBDCR_BDRST() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetBDCR_RTCEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetBDCR_RTCEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetBDCR_LSESYSRDY(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetBDCR_LSESYSRDY() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetBDCR_RTCSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetBDCR_RTCSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetBDCR_LSESYSEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetBDCR_LSESYSEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetBDCR_LSECSSD(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetBDCR_LSECSSD() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetBDCR_LSECSSON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetBDCR_LSECSSON() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetBDCR_LSEDRV(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetBDCR_LSEDRV() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetBDCR_LSEBYP(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetBDCR_LSEBYP() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetBDCR_LSERDY(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetBDCR_LSERDY() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetBDCR_LSEON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetBDCR_LSEON() uint32 {
	return volatile.LoadUint32(&o.BDCR.Reg) & 0x1
}

// RCC.CSR: Control/status register
func (o *RCC_Type) SetCSR_LPWRRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetCSR_LPWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetCSR_WWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetCSR_WWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetCSR_IWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCSR_IWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetCSR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCSR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetCSR_BORRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCSR_BORRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCSR_PINRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCSR_PINRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCSR_OBLRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCSR_OBLRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCSR_RFILARSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCSR_RFILARSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCSR_RMVF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetCSR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetCSR_RFRST(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetCSR_RFRST() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetCSR_RFRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetCSR_RFRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetCSR_MSISRANGE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0xf00)|value<<8)
}
func (o *RCC_Type) GetCSR_MSISRANGE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0xf00) >> 8
}
func (o *RCC_Type) SetCSR_LSIPRE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCSR_LSIPRE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCSR_LSIRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCSR_LSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCSR_LSION(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCSR_LSION() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}

// RCC.EXTCFGR: Extended clock recovery register
func (o *RCC_Type) SetEXTCFGR_SHDHPREF(value uint32) {
	volatile.StoreUint32(&o.EXTCFGR.Reg, volatile.LoadUint32(&o.EXTCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetEXTCFGR_SHDHPREF() uint32 {
	return (volatile.LoadUint32(&o.EXTCFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetEXTCFGR_SHDHPRE(value uint32) {
	volatile.StoreUint32(&o.EXTCFGR.Reg, volatile.LoadUint32(&o.EXTCFGR.Reg)&^(0xf)|value)
}
func (o *RCC_Type) GetEXTCFGR_SHDHPRE() uint32 {
	return volatile.LoadUint32(&o.EXTCFGR.Reg) & 0xf
}

// True random number generator
type RNG_Type struct {
	CR   volatile.Register32 // 0x0
	SR   volatile.Register32 // 0x4
	DR   volatile.Register32 // 0x8
	_    [4]byte
	HTCR volatile.Register32 // 0x10
}

// RNG.CR: control register
func (o *RNG_Type) SetCR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetCR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetCR_IE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetCR_IE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetCR_CED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RNG_Type) GetCR_CED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RNG_Type) SetCR_RNG_CONFIG3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *RNG_Type) GetCR_RNG_CONFIG3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *RNG_Type) SetCR_NISTC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RNG_Type) GetCR_NISTC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RNG_Type) SetCR_RNG_CONFIG2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xe000)|value<<13)
}
func (o *RNG_Type) GetCR_RNG_CONFIG2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xe000) >> 13
}
func (o *RNG_Type) SetCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0000)|value<<16)
}
func (o *RNG_Type) GetCR_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0000) >> 16
}
func (o *RNG_Type) SetCR_RNG_CONFIG1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f00000)|value<<20)
}
func (o *RNG_Type) GetCR_RNG_CONFIG1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3f00000) >> 20
}
func (o *RNG_Type) SetCR_CONDRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *RNG_Type) GetCR_CONDRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *RNG_Type) SetCR_CONFIGLOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *RNG_Type) GetCR_CONFIGLOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// RNG.SR: status register
func (o *RNG_Type) SetSR_SEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *RNG_Type) GetSR_SEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *RNG_Type) SetSR_CEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RNG_Type) GetSR_CEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *RNG_Type) SetSR_SECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetSR_SECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetSR_CECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetSR_CECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetSR_DRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSR_DRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// RNG.DR: data register
func (o *RNG_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *RNG_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// RNG.HTCR: health test control register
func (o *RNG_Type) SetHTCR(value uint32) {
	volatile.StoreUint32(&o.HTCR.Reg, value)
}
func (o *RNG_Type) GetHTCR() uint32 {
	return volatile.LoadUint32(&o.HTCR.Reg)
}

// Real-time clock
type RTC_Type struct {
	TR       volatile.Register32 // 0x0
	DR       volatile.Register32 // 0x4
	SSR      volatile.Register32 // 0x8
	ICSR     volatile.Register32 // 0xC
	PRER     volatile.Register32 // 0x10
	WUTR     volatile.Register32 // 0x14
	CR       volatile.Register32 // 0x18
	_        [8]byte
	WPR      volatile.Register32 // 0x24
	CALR     volatile.Register32 // 0x28
	SHIFTR   volatile.Register32 // 0x2C
	TSTR     volatile.Register32 // 0x30
	TSDR     volatile.Register32 // 0x34
	TSSSR    volatile.Register32 // 0x38
	_        [4]byte
	ALRMAR   volatile.Register32 // 0x40
	ALRMASSR volatile.Register32 // 0x44
	ALRMBR   volatile.Register32 // 0x48
	ALRMBSSR volatile.Register32 // 0x4C
	SR       volatile.Register32 // 0x50
	MISR     volatile.Register32 // 0x54
	_        [4]byte
	SCR      volatile.Register32 // 0x5C
	_        [16]byte
	ALRABINR volatile.Register32 // 0x70
	ALRBBINR volatile.Register32 // 0x74
}

// RTC.TR: Time register
func (o *RTC_Type) SetTR_PM(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTR_HT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTR_HU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTR_ST(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTR_SU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTR_SU() uint32 {
	return volatile.LoadUint32(&o.TR.Reg) & 0xf
}

// RTC.DR: Date register
func (o *RTC_Type) SetDR_YT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00000)|value<<20)
}
func (o *RTC_Type) GetDR_YT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00000) >> 20
}
func (o *RTC_Type) SetDR_YU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetDR_YU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetDR_WDU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetDR_MT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetDR_MT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetDR_MU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetDR_MU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetDR_DT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetDR_DT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetDR_DU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetDR_DU() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xf
}

// RTC.SSR: Sub second register
func (o *RTC_Type) SetSSR(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, value)
}
func (o *RTC_Type) GetSSR() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg)
}

// RTC.ICSR: Initialization control and status register
func (o *RTC_Type) SetICSR_RECALPF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetICSR_RECALPF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetICSR_BCDU(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1c00)|value<<10)
}
func (o *RTC_Type) GetICSR_BCDU() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x1c00) >> 10
}
func (o *RTC_Type) SetICSR_BIN(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x300)|value<<8)
}
func (o *RTC_Type) GetICSR_BIN() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x300) >> 8
}
func (o *RTC_Type) SetICSR_INIT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetICSR_INIT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetICSR_INITF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetICSR_INITF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetICSR_RSF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetICSR_RSF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetICSR_INITS(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetICSR_INITS() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetICSR_SHPF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetICSR_SHPF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetICSR_WUTWF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetICSR_WUTWF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4) >> 2
}

// RTC.PRER: Pre-scaler register
func (o *RTC_Type) SetPRER_PREDIV_A(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7f0000)|value<<16)
}
func (o *RTC_Type) GetPRER_PREDIV_A() uint32 {
	return (volatile.LoadUint32(&o.PRER.Reg) & 0x7f0000) >> 16
}
func (o *RTC_Type) SetPRER_PREDIV_S(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetPRER_PREDIV_S() uint32 {
	return volatile.LoadUint32(&o.PRER.Reg) & 0x7fff
}

// RTC.WUTR: Wakeup timer register
func (o *RTC_Type) SetWUTR_WUTOCLR(value uint32) {
	volatile.StoreUint32(&o.WUTR.Reg, volatile.LoadUint32(&o.WUTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *RTC_Type) GetWUTR_WUTOCLR() uint32 {
	return (volatile.LoadUint32(&o.WUTR.Reg) & 0xffff0000) >> 16
}
func (o *RTC_Type) SetWUTR_WUT(value uint32) {
	volatile.StoreUint32(&o.WUTR.Reg, volatile.LoadUint32(&o.WUTR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetWUTR_WUT() uint32 {
	return volatile.LoadUint32(&o.WUTR.Reg) & 0xffff
}

// RTC.CR: Control register
func (o *RTC_Type) SetCR_OUT2EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetCR_OUT2EN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetCR_TAMPALRM_TYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetCR_TAMPALRM_TYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetCR_TAMPALRM_PU(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_Type) GetCR_TAMPALRM_PU() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *RTC_Type) SetCR_TAMPOE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_Type) GetCR_TAMPOE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *RTC_Type) SetCR_TAMPTS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_Type) GetCR_TAMPTS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *RTC_Type) SetCR_ITSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetCR_ITSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RTC_Type) SetCR_COE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCR_COE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCR_OSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_Type) GetCR_OSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *RTC_Type) SetCR_POL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetCR_POL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetCR_COSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetCR_COSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetCR_BKP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetCR_BKP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetCR_SUB1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCR_SUB1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetCR_ADD1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetCR_ADD1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetCR_TSIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCR_TSIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCR_WUTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCR_WUTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCR_ALRBIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_ALRBIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCR_ALRAIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_ALRAIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_TSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_TSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_WUTE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_WUTE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_ALRBE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_ALRBE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_ALRAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_ALRAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_SSRUIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetCR_SSRUIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetCR_FMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCR_FMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCR_BYPSHAD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCR_BYPSHAD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCR_REFCKON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_REFCKON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_TSEDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_TSEDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_WUCKSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetCR_WUCKSEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7
}

// RTC.WPR: Write protection register
func (o *RTC_Type) SetWPR_KEY(value uint32) {
	volatile.StoreUint32(&o.WPR.Reg, volatile.LoadUint32(&o.WPR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetWPR_KEY() uint32 {
	return volatile.LoadUint32(&o.WPR.Reg) & 0xff
}

// RTC.CALR: Calibration register
func (o *RTC_Type) SetCALR_CALP(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCALR_CALP() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCALR_CALW8(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCALR_CALW8() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCALR_CALW16(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCALR_CALW16() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCALR_LPCAL(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCALR_LPCAL() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCALR_CALM(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetCALR_CALM() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x1ff
}

// RTC.SHIFTR: Shift control register
func (o *RTC_Type) SetSHIFTR_ADD1S(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSHIFTR_ADD1S() uint32 {
	return (volatile.LoadUint32(&o.SHIFTR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetSHIFTR_SUBFS(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetSHIFTR_SUBFS() uint32 {
	return volatile.LoadUint32(&o.SHIFTR.Reg) & 0x7fff
}

// RTC.TSTR: Timestamp time register
func (o *RTC_Type) SetTSTR_PM(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTSTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTSTR_HT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTSTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTSTR_HU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTSTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTSTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTSTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTSTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSTR_ST(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTSTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTSTR_SU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSTR_SU() uint32 {
	return volatile.LoadUint32(&o.TSTR.Reg) & 0xf
}

// RTC.TSDR: Timestamp date register
func (o *RTC_Type) SetTSDR_WDU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetTSDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetTSDR_MT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetTSDR_MT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetTSDR_MU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSDR_MU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSDR_DT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetTSDR_DT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetTSDR_DU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSDR_DU() uint32 {
	return volatile.LoadUint32(&o.TSDR.Reg) & 0xf
}

// RTC.TSSSR: Timestamp sub second register
func (o *RTC_Type) SetTSSSR(value uint32) {
	volatile.StoreUint32(&o.TSSSR.Reg, value)
}
func (o *RTC_Type) GetTSSSR() uint32 {
	return volatile.LoadUint32(&o.TSSSR.Reg)
}

// RTC.ALRMAR: Alarm A register
func (o *RTC_Type) SetALRMAR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMAR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMAR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMAR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMAR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMAR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMAR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMAR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMAR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMAR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMAR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMAR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMAR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMAR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMAR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMAR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMAR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMAR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMAR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMAR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMAR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMAR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMAR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMAR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMAR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMAR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMAR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMAR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf
}

// RTC.ALRMASSR: Alarm A sub second register
func (o *RTC_Type) SetALRMASSR_SSCLR(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMASSR_SSCLR() uint32 {
	return (volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMASSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetALRMASSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x3f000000) >> 24
}
func (o *RTC_Type) SetALRMASSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMASSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x7fff
}

// RTC.ALRMBR: Alarm B register
func (o *RTC_Type) SetALRMBR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMBR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMBR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMBR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMBR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMBR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMBR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMBR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMBR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMBR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMBR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMBR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMBR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMBR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMBR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMBR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMBR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMBR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMBR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMBR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMBR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMBR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMBR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMBR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMBR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMBR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf
}

// RTC.ALRMBSSR: Alarm B sub second register
func (o *RTC_Type) SetALRMBSSR_SSCLR(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMBSSR_SSCLR() uint32 {
	return (volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMBSSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetALRMBSSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x3f000000) >> 24
}
func (o *RTC_Type) SetALRMBSSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMBSSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x7fff
}

// RTC.SR: Status register (interrupts)
func (o *RTC_Type) SetSR_SSRUF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetSR_SSRUF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetSR_ITSF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetSR_ITSF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetSR_TSOVF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSR_TSOVF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetSR_TSF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSR_TSF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSR_WUTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSR_WUTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSR_ALRBF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSR_ALRBF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSR_ALRAF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSR_ALRAF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// RTC.MISR: Masked interrupt status register
func (o *RTC_Type) SetMISR_SSRUMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetMISR_SSRUMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetMISR_ITSMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetMISR_ITSMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetMISR_TSOVMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetMISR_TSOVMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetMISR_TSMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetMISR_TSMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetMISR_WUTMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetMISR_WUTMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetMISR_ALRBMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetMISR_ALRBMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetMISR_ALRAMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetMISR_ALRAMF() uint32 {
	return volatile.LoadUint32(&o.MISR.Reg) & 0x1
}

// RTC.SCR: Status clear register (interrupts)
func (o *RTC_Type) SetSCR_CSSRUF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetSCR_CSSRUF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetSCR_CITSF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetSCR_CITSF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetSCR_CTSOVF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSCR_CTSOVF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetSCR_CTSF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSCR_CTSF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSCR_CWUTF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSCR_CWUTF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSCR_CALRBF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSCR_CALRBF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSCR_CALRAF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSCR_CALRAF() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}

// RTC.ALRABINR: RTC alarm A binary mode register
func (o *RTC_Type) SetALRABINR(value uint32) {
	volatile.StoreUint32(&o.ALRABINR.Reg, value)
}
func (o *RTC_Type) GetALRABINR() uint32 {
	return volatile.LoadUint32(&o.ALRABINR.Reg)
}

// RTC.ALRBBINR: RTC alarm B binary mode register
func (o *RTC_Type) SetALRBBINR(value uint32) {
	volatile.StoreUint32(&o.ALRBBINR.Reg, value)
}
func (o *RTC_Type) GetALRBBINR() uint32 {
	return volatile.LoadUint32(&o.ALRBBINR.Reg)
}

// System control block
type SCB_Type struct {
	CPUID                volatile.Register32 // 0x0
	ICSR                 volatile.Register32 // 0x4
	VTOR                 volatile.Register32 // 0x8
	AIRCR                volatile.Register32 // 0xC
	SCR                  volatile.Register32 // 0x10
	CCR                  volatile.Register32 // 0x14
	SHPR1                volatile.Register32 // 0x18
	SHPR2                volatile.Register32 // 0x1C
	SHPR3                volatile.Register32 // 0x20
	SHCSR                volatile.Register32 // 0x24
	CFSR_UFSR_BFSR_MMFSR volatile.Register32 // 0x28
	HFSR                 volatile.Register32 // 0x2C
	_                    [4]byte
	MMFAR                volatile.Register32 // 0x34
	BFAR                 volatile.Register32 // 0x38
	AFSR                 volatile.Register32 // 0x3C
}

// SCB.CPUID: CPUID base register
func (o *SCB_Type) SetCPUID_Revision(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCPUID_Revision() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SCB_Type) SetCPUID_PartNo(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SCB_Type) GetCPUID_PartNo() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SCB_Type) SetCPUID_Constant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCPUID_Constant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCPUID_Variant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCPUID_Variant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCPUID_Implementer(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetCPUID_Implementer() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SCB.ICSR: Interrupt control and state register
func (o *SCB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SCB_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x7f000)|value<<12)
}
func (o *SCB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x7f000) >> 12
}
func (o *SCB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SCB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SCB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SCB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SCB.VTOR: Vector table offset register
func (o *SCB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0x3ffffe00)|value<<9)
}
func (o *SCB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0x3ffffe00) >> 9
}

// SCB.AIRCR: Application interrupt and reset control register
func (o *SCB_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SCB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SCB_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SCB_Type) SetAIRCR_ENDIANESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetAIRCR_ENDIANESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetAIRCR_VECTKEYSTAT(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCB_Type) GetAIRCR_VECTKEYSTAT() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SCB.SCR: System control register
func (o *SCB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetSCR_SEVEONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetSCR_SEVEONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SCB.CCR: Configuration and control register
func (o *SCB_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SCB_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCCR_UNALIGN__TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCCR_UNALIGN__TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}

// SCB.SHPR1: System handler priority registers
func (o *SCB_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SCB_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SCB_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SCB_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SCB_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SCB.SHPR2: System handler priority registers
func (o *SCB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SCB.SHPR3: System handler priority registers
func (o *SCB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SCB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SCB.SHCSR: System handler control and state register
func (o *SCB_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SCB_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SCB_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SCB.CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x20)|value<<5)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x20) >> 5
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x40000) >> 18
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x80000) >> 19
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1000000) >> 24
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2000000) >> 25
}

// SCB.HFSR: Hard fault status register
func (o *SCB_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetHFSR_DEBUG_VT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetHFSR_DEBUG_VT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SCB.MMFAR: Memory management fault address register
func (o *SCB_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SCB_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SCB.BFAR: Bus fault address register
func (o *SCB_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SCB_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SCB.AFSR: Auxiliary fault status register
func (o *SCB_Type) SetAFSR(value uint32) {
	volatile.StoreUint32(&o.AFSR.Reg, value)
}
func (o *SCB_Type) GetAFSR() uint32 {
	return volatile.LoadUint32(&o.AFSR.Reg)
}

// Serial peripheral interface/Inter-IC sound
type SPI_Type struct {
	CR1     volatile.Register32 // 0x0
	CR2     volatile.Register32 // 0x4
	SR      volatile.Register32 // 0x8
	DR      volatile.Register32 // 0xC
	CRCPR   volatile.Register32 // 0x10
	RXCRCR  volatile.Register32 // 0x14
	TXCRCR  volatile.Register32 // 0x18
	I2SCFGR volatile.Register32 // 0x1C
	I2SPR   volatile.Register32 // 0x20
}

// SPI.CR1: control register 1
func (o *SPI_Type) SetCR1_BIDIMODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCR1_BIDIMODE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCR1_BIDIOE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR1_BIDIOE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCR1_CRCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR1_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR1_CRCNEXT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR1_CRCNEXT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR1_CRCL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCR1_CRCL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetCR1_RXONLY(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCR1_RXONLY() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCR1_SSM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCR1_SSM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCR1_SSI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCR1_SSI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR1_SPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR1_SPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR1_BR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetCR1_BR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetCR1_MSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR1_MSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR1_CPHA() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// SPI.CR2: control register 2
func (o *SPI_Type) SetCR2_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR2_RXDMAEN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *SPI_Type) SetCR2_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR2_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR2_SSOE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR2_SSOE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR2_NSSP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCR2_NSSP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCR2_FRF(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetCR2_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetCR2_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCR2_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCR2_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR2_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR2_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR2_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR2_DS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCR2_DS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCR2_FRXTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR2_FRXTH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR2_LDMA_RX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR2_LDMA_RX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR2_LDMA_TX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR2_LDMA_TX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}

// SPI.SR: status register
func (o *SPI_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RXNE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TXE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TXE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_CHSIDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_CHSIDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_UDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_UDR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_CRCERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSR_FRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_FRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_FRLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x600)|value<<9)
}
func (o *SPI_Type) GetSR_FRLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x600) >> 9
}
func (o *SPI_Type) SetSR_FTLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1800)|value<<11)
}
func (o *SPI_Type) GetSR_FTLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1800) >> 11
}

// SPI.DR: data register
func (o *SPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// SPI.CRCPR: CRC polynomial register
func (o *SPI_Type) SetCRCPR_CRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPR.Reg, volatile.LoadUint32(&o.CRCPR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetCRCPR_CRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPR.Reg) & 0xffff
}

// SPI.RXCRCR: RX CRC register
func (o *SPI_Type) SetRXCRCR_RxCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRCR.Reg, volatile.LoadUint32(&o.RXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRXCRCR_RxCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRCR.Reg) & 0xffff
}

// SPI.TXCRCR: TX CRC register
func (o *SPI_Type) SetTXCRCR_TxCRC(value uint32) {
	volatile.StoreUint32(&o.TXCRCR.Reg, volatile.LoadUint32(&o.TXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXCRCR_TxCRC() uint32 {
	return volatile.LoadUint32(&o.TXCRCR.Reg) & 0xffff
}

// SPI.I2SCFGR: configuration register
func (o *SPI_Type) SetI2SCFGR_CHLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetI2SCFGR_CHLEN() uint32 {
	return volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1
}
func (o *SPI_Type) SetI2SCFGR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x6)|value<<1)
}
func (o *SPI_Type) GetI2SCFGR_DATLEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x6) >> 1
}
func (o *SPI_Type) SetI2SCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetI2SCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetI2SCFGR_I2SSTD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetI2SCFGR_I2SSTD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetI2SCFGR_PCMSYNC(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetI2SCFGR_PCMSYNC() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetI2SCFGR_I2SCFG(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetI2SCFGR_I2SCFG() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetI2SCFGR_I2SE(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetI2SCFGR_I2SE() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetI2SCFGR_I2SMOD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetI2SCFGR_I2SMOD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetI2SCFGR_ASTRTEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetI2SCFGR_ASTRTEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1000) >> 12
}

// SPI.I2SPR: prescaler register
func (o *SPI_Type) SetI2SPR_I2SDIV(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetI2SPR_I2SDIV() uint32 {
	return volatile.LoadUint32(&o.I2SPR.Reg) & 0xff
}
func (o *SPI_Type) SetI2SPR_ODD(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetI2SPR_ODD() uint32 {
	return (volatile.LoadUint32(&o.I2SPR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetI2SPR_MCKOE(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetI2SPR_MCKOE() uint32 {
	return (volatile.LoadUint32(&o.I2SPR.Reg) & 0x200) >> 9
}

// SysTick timer
type STK_Type struct {
	CTRL  volatile.Register32 // 0x0
	LOAD  volatile.Register32 // 0x4
	VAL   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// STK.CTRL: SysTick control and status register
func (o *STK_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *STK_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *STK_Type) SetCTRL_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *STK_Type) GetCTRL_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *STK_Type) SetCTRL_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *STK_Type) GetCTRL_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *STK_Type) SetCTRL_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *STK_Type) GetCTRL_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}

// STK.LOAD: SysTick reload value register
func (o *STK_Type) SetLOAD_RELOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, volatile.LoadUint32(&o.LOAD.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetLOAD_RELOAD() uint32 {
	return volatile.LoadUint32(&o.LOAD.Reg) & 0xffffff
}

// STK.VAL: SysTick current value register
func (o *STK_Type) SetVAL_CURRENT(value uint32) {
	volatile.StoreUint32(&o.VAL.Reg, volatile.LoadUint32(&o.VAL.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetVAL_CURRENT() uint32 {
	return volatile.LoadUint32(&o.VAL.Reg) & 0xffffff
}

// STK.CALIB: SysTick calibration value register
func (o *STK_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *STK_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *STK_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *STK_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *STK_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// System configuration controller
type SYSCFG_Type struct {
	MEMRMP  volatile.Register32 // 0x0
	CFGR1   volatile.Register32 // 0x4
	EXTICR1 volatile.Register32 // 0x8
	EXTICR2 volatile.Register32 // 0xC
	EXTICR3 volatile.Register32 // 0x10
	EXTICR4 volatile.Register32 // 0x14
	SCSR    volatile.Register32 // 0x18
	CFGR2   volatile.Register32 // 0x1C
	SWPR    volatile.Register32 // 0x20
	SKR     volatile.Register32 // 0x24
	_       [480]byte
	RFDCR   volatile.Register32 // 0x208
}

// SYSCFG.MEMRMP: memory remap register
func (o *SYSCFG_Type) SetMEMRMP_MEM_MODE(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetMEMRMP_MEM_MODE() uint32 {
	return volatile.LoadUint32(&o.MEMRMP.Reg) & 0x7
}

// SYSCFG.CFGR1: configuration register 1
func (o *SYSCFG_Type) SetCFGR1_I2C3_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCFG_Type) GetCFGR1_I2C3_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x400000) >> 22
}
func (o *SYSCFG_Type) SetCFGR1_I2C2_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCFG_Type) GetCFGR1_I2C2_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x200000) >> 21
}
func (o *SYSCFG_Type) SetCFGR1_I2C1_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCFG_Type) GetCFGR1_I2C1_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100000) >> 20
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB9_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB9_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x80000) >> 19
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB8_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB8_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x40000) >> 18
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB7_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB7_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20000) >> 17
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB6_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB6_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10000) >> 16
}
func (o *SYSCFG_Type) SetCFGR1_BOOSTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCFGR1_BOOSTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100) >> 8
}

// SYSCFG.EXTICR1: external interrupt configuration register 1
func (o *SYSCFG_Type) SetEXTICR1_EXTI3(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI3() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI2(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI2() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI1(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI1() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI0(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI0() uint32 {
	return volatile.LoadUint32(&o.EXTICR1.Reg) & 0x7
}

// SYSCFG.EXTICR2: external interrupt configuration register 2
func (o *SYSCFG_Type) SetEXTICR2_EXTI7(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI7() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI6(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI6() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI5(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI5() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI4(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI4() uint32 {
	return volatile.LoadUint32(&o.EXTICR2.Reg) & 0x7
}

// SYSCFG.EXTICR3: external interrupt configuration register 3
func (o *SYSCFG_Type) SetEXTICR3_EXTI11(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI11() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI10(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI10() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI9(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI9() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI8(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI8() uint32 {
	return volatile.LoadUint32(&o.EXTICR3.Reg) & 0x7
}

// SYSCFG.EXTICR4: external interrupt configuration register 4
func (o *SYSCFG_Type) SetEXTICR4_EXTI15(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI14(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI14() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI13(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI13() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI12(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI12() uint32 {
	return volatile.LoadUint32(&o.EXTICR4.Reg) & 0x7
}

// SYSCFG.SCSR: SCSR
func (o *SYSCFG_Type) SetSCSR_PKASRAMBSY(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetSCSR_PKASRAMBSY() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetSCSR_SRAMBSY(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetSCSR_SRAMBSY() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetSCSR_SRAM2ER(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetSCSR_SRAM2ER() uint32 {
	return volatile.LoadUint32(&o.SCSR.Reg) & 0x1
}

// SYSCFG.CFGR2: CFGR2
func (o *SYSCFG_Type) SetCFGR2_SPF(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCFGR2_SPF() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetCFGR2_ECCL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetCFGR2_ECCL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetCFGR2_PVDL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetCFGR2_PVDL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetCFGR2_SPL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetCFGR2_SPL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetCFGR2_CLL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetCFGR2_CLL() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}

// SYSCFG.SWPR: SWPR
func (o *SYSCFG_Type) SetSWPR_P31WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCFG_Type) GetSWPR_P31WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x80000000) >> 31
}
func (o *SYSCFG_Type) SetSWPR_P30WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCFG_Type) GetSWPR_P30WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x40000000) >> 30
}
func (o *SYSCFG_Type) SetSWPR_P29WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCFG_Type) GetSWPR_P29WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x20000000) >> 29
}
func (o *SYSCFG_Type) SetSWPR_P28WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCFG_Type) GetSWPR_P28WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x10000000) >> 28
}
func (o *SYSCFG_Type) SetSWPR_P27WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCFG_Type) GetSWPR_P27WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x8000000) >> 27
}
func (o *SYSCFG_Type) SetSWPR_P26WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCFG_Type) GetSWPR_P26WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x4000000) >> 26
}
func (o *SYSCFG_Type) SetSWPR_P25WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCFG_Type) GetSWPR_P25WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x2000000) >> 25
}
func (o *SYSCFG_Type) SetSWPR_P24WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCFG_Type) GetSWPR_P24WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x1000000) >> 24
}
func (o *SYSCFG_Type) SetSWPR_P23WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCFG_Type) GetSWPR_P23WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x800000) >> 23
}
func (o *SYSCFG_Type) SetSWPR_P22WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCFG_Type) GetSWPR_P22WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x400000) >> 22
}
func (o *SYSCFG_Type) SetSWPR_P21WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCFG_Type) GetSWPR_P21WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x200000) >> 21
}
func (o *SYSCFG_Type) SetSWPR_P20WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCFG_Type) GetSWPR_P20WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x100000) >> 20
}
func (o *SYSCFG_Type) SetSWPR_P19WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCFG_Type) GetSWPR_P19WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x80000) >> 19
}
func (o *SYSCFG_Type) SetSWPR_P18WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCFG_Type) GetSWPR_P18WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x40000) >> 18
}
func (o *SYSCFG_Type) SetSWPR_P17WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCFG_Type) GetSWPR_P17WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x20000) >> 17
}
func (o *SYSCFG_Type) SetSWPR_P16WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetSWPR_P16WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x10000) >> 16
}
func (o *SYSCFG_Type) SetSWPR_P15WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCFG_Type) GetSWPR_P15WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x8000) >> 15
}
func (o *SYSCFG_Type) SetSWPR_P14WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCFG_Type) GetSWPR_P14WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x4000) >> 14
}
func (o *SYSCFG_Type) SetSWPR_P13WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCFG_Type) GetSWPR_P13WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x2000) >> 13
}
func (o *SYSCFG_Type) SetSWPR_P12WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCFG_Type) GetSWPR_P12WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x1000) >> 12
}
func (o *SYSCFG_Type) SetSWPR_P11WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x800)|value<<11)
}
func (o *SYSCFG_Type) GetSWPR_P11WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x800) >> 11
}
func (o *SYSCFG_Type) SetSWPR_P10WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x400)|value<<10)
}
func (o *SYSCFG_Type) GetSWPR_P10WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x400) >> 10
}
func (o *SYSCFG_Type) SetSWPR_P9WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x200)|value<<9)
}
func (o *SYSCFG_Type) GetSWPR_P9WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x200) >> 9
}
func (o *SYSCFG_Type) SetSWPR_P8WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetSWPR_P8WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetSWPR_P7WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetSWPR_P7WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetSWPR_P6WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetSWPR_P6WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetSWPR_P5WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetSWPR_P5WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetSWPR_P4WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetSWPR_P4WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetSWPR_P3WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetSWPR_P3WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetSWPR_P2WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetSWPR_P2WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetSWPR_P1WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetSWPR_P1WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetSWPR_P0WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetSWPR_P0WP() uint32 {
	return volatile.LoadUint32(&o.SWPR.Reg) & 0x1
}

// SYSCFG.SKR: SKR
func (o *SYSCFG_Type) SetSKR_KEY(value uint32) {
	volatile.StoreUint32(&o.SKR.Reg, volatile.LoadUint32(&o.SKR.Reg)&^(0xff)|value)
}
func (o *SYSCFG_Type) GetSKR_KEY() uint32 {
	return volatile.LoadUint32(&o.SKR.Reg) & 0xff
}

// SYSCFG.RFDCR: radio debug control register
func (o *SYSCFG_Type) SetRFDCR_RFTBSEL(value uint32) {
	volatile.StoreUint32(&o.RFDCR.Reg, volatile.LoadUint32(&o.RFDCR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetRFDCR_RFTBSEL() uint32 {
	return volatile.LoadUint32(&o.RFDCR.Reg) & 0x1
}

// Tamper and backup registers
type TAMP_Type struct {
	CR1    volatile.Register32 // 0x0
	CR2    volatile.Register32 // 0x4
	CR3    volatile.Register32 // 0x8
	FLTCR  volatile.Register32 // 0xC
	_      [28]byte
	IER    volatile.Register32 // 0x2C
	SR     volatile.Register32 // 0x30
	MISR   volatile.Register32 // 0x34
	_      [4]byte
	SCR    volatile.Register32 // 0x3C
	COUNTR volatile.Register32 // 0x40
	_      [188]byte
	BKP0R  volatile.Register32 // 0x100
	BKP1R  volatile.Register32 // 0x104
	BKP2R  volatile.Register32 // 0x108
	BKP3R  volatile.Register32 // 0x10C
	BKP4R  volatile.Register32 // 0x110
	BKP5R  volatile.Register32 // 0x114
	BKP6R  volatile.Register32 // 0x118
	BKP7R  volatile.Register32 // 0x11C
	BKP8R  volatile.Register32 // 0x120
	BKP9R  volatile.Register32 // 0x124
	_      [24]byte
	BKP10R volatile.Register32 // 0x140
	BKP11R volatile.Register32 // 0x144
	BKP12R volatile.Register32 // 0x148
	BKP13R volatile.Register32 // 0x14C
	BKP14R volatile.Register32 // 0x150
	BKP15R volatile.Register32 // 0x154
	BKP16R volatile.Register32 // 0x158
	BKP17R volatile.Register32 // 0x15C
	BKP18R volatile.Register32 // 0x160
	BKP19R volatile.Register32 // 0x164
}

// TAMP.CR1: control register 1
func (o *TAMP_Type) SetCR1_TAMP1E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetCR1_TAMP1E() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *TAMP_Type) SetCR1_TAMP2E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetCR1_TAMP2E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetCR1_TAMP3E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetCR1_TAMP3E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetCR1_ITAMP3E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetCR1_ITAMP3E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetCR1_ITAMP5E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetCR1_ITAMP5E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetCR1_ITAMP6E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetCR1_ITAMP6E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetCR1_ITAMP8E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *TAMP_Type) GetCR1_ITAMP8E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}

// TAMP.CR2: control register 2
func (o *TAMP_Type) SetCR2_TAMP1NOER(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetCR2_TAMP1NOER() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *TAMP_Type) SetCR2_TAMP2NOER(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetCR2_TAMP2NOER() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetCR2_TAMP3NOER(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetCR2_TAMP3NOER() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetCR2_TAMP1MSK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetCR2_TAMP1MSK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetCR2_TAMP2MSK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *TAMP_Type) GetCR2_TAMP2MSK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *TAMP_Type) SetCR2_TAMP3MSK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetCR2_TAMP3MSK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetCR2_BKERASE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800000)|value<<23)
}
func (o *TAMP_Type) GetCR2_BKERASE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800000) >> 23
}
func (o *TAMP_Type) SetCR2_TAMP1TRG(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *TAMP_Type) GetCR2_TAMP1TRG() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *TAMP_Type) SetCR2_TAMP2TRG(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *TAMP_Type) GetCR2_TAMP2TRG() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}
func (o *TAMP_Type) SetCR2_TAMP3TRG(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000000)|value<<26)
}
func (o *TAMP_Type) GetCR2_TAMP3TRG() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000000) >> 26
}

// TAMP.CR3: TAMP control register 3
func (o *TAMP_Type) SetCR3_ITAMP3NOER(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetCR3_ITAMP3NOER() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetCR3_ITAMP5NOER(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *TAMP_Type) GetCR3_ITAMP5NOER() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *TAMP_Type) SetCR3_ITAMP6NOER(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x20)|value<<5)
}
func (o *TAMP_Type) GetCR3_ITAMP6NOER() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x20) >> 5
}
func (o *TAMP_Type) SetCR3_ITAMP8NOER(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *TAMP_Type) GetCR3_ITAMP8NOER() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}

// TAMP.FLTCR: TAMP filter control register
func (o *TAMP_Type) SetFLTCR_TAMPFREQ(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x7)|value)
}
func (o *TAMP_Type) GetFLTCR_TAMPFREQ() uint32 {
	return volatile.LoadUint32(&o.FLTCR.Reg) & 0x7
}
func (o *TAMP_Type) SetFLTCR_TAMPFLT(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x18)|value<<3)
}
func (o *TAMP_Type) GetFLTCR_TAMPFLT() uint32 {
	return (volatile.LoadUint32(&o.FLTCR.Reg) & 0x18) >> 3
}
func (o *TAMP_Type) SetFLTCR_TAMPPRCH(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x60)|value<<5)
}
func (o *TAMP_Type) GetFLTCR_TAMPPRCH() uint32 {
	return (volatile.LoadUint32(&o.FLTCR.Reg) & 0x60) >> 5
}
func (o *TAMP_Type) SetFLTCR_TAMPPUDIS(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x80)|value<<7)
}
func (o *TAMP_Type) GetFLTCR_TAMPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.FLTCR.Reg) & 0x80) >> 7
}

// TAMP.IER: TAMP interrupt enable register
func (o *TAMP_Type) SetIER_TAMP1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetIER_TAMP1IE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TAMP_Type) SetIER_TAMP2IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetIER_TAMP2IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetIER_TAMP3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetIER_TAMP3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetIER_ITAMP3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetIER_ITAMP3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetIER_ITAMP5IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetIER_ITAMP5IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetIER_ITAMP6IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetIER_ITAMP6IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetIER_ITAMP8IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *TAMP_Type) GetIER_ITAMP8IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}

// TAMP.SR: TAMP status register
func (o *TAMP_Type) SetSR_TAMP1F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetSR_TAMP1F() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TAMP_Type) SetSR_TAMP2F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetSR_TAMP2F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetSR_TAMP3F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetSR_TAMP3F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetSR_ITAMP3F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetSR_ITAMP3F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetSR_ITAMP5F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetSR_ITAMP5F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetSR_ITAMP6F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetSR_ITAMP6F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetSR_ITAMP8F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *TAMP_Type) GetSR_ITAMP8F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}

// TAMP.MISR: TAMP masked interrupt status register
func (o *TAMP_Type) SetMISR_TAMP1MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetMISR_TAMP1MF() uint32 {
	return volatile.LoadUint32(&o.MISR.Reg) & 0x1
}
func (o *TAMP_Type) SetMISR_TAMP2MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetMISR_TAMP2MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetMISR_TAMP3MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetMISR_TAMP3MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetMISR_ITAMP3MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetMISR_ITAMP3MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetMISR_ITAMP5MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetMISR_ITAMP5MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetMISR_ITAMP6MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetMISR_ITAMP6MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetMISR_ITAMP8MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x800000)|value<<23)
}
func (o *TAMP_Type) GetMISR_ITAMP8MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x800000) >> 23
}

// TAMP.SCR: TAMP status clear register
func (o *TAMP_Type) SetSCR_CTAMP1F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetSCR_CTAMP1F() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}
func (o *TAMP_Type) SetSCR_CTAMP2F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetSCR_CTAMP2F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetSCR_CTAMP3F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *TAMP_Type) GetSCR_CTAMP3F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *TAMP_Type) SetSCR_CITAMP3F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetSCR_CITAMP3F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetSCR_CITAMP5F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetSCR_CITAMP5F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetSCR_CITAMP6F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetSCR_CITAMP6F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetSCR_CITAMP8F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x800000)|value<<23)
}
func (o *TAMP_Type) GetSCR_CITAMP8F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x800000) >> 23
}

// TAMP.COUNTR: monotonic counter register
func (o *TAMP_Type) SetCOUNTR(value uint32) {
	volatile.StoreUint32(&o.COUNTR.Reg, value)
}
func (o *TAMP_Type) GetCOUNTR() uint32 {
	return volatile.LoadUint32(&o.COUNTR.Reg)
}

// TAMP.BKP0R: TAMP backup register
func (o *TAMP_Type) SetBKP0R(value uint32) {
	volatile.StoreUint32(&o.BKP0R.Reg, value)
}
func (o *TAMP_Type) GetBKP0R() uint32 {
	return volatile.LoadUint32(&o.BKP0R.Reg)
}

// TAMP.BKP1R: TAMP backup register
func (o *TAMP_Type) SetBKP1R(value uint32) {
	volatile.StoreUint32(&o.BKP1R.Reg, value)
}
func (o *TAMP_Type) GetBKP1R() uint32 {
	return volatile.LoadUint32(&o.BKP1R.Reg)
}

// TAMP.BKP2R: TAMP backup register
func (o *TAMP_Type) SetBKP2R(value uint32) {
	volatile.StoreUint32(&o.BKP2R.Reg, value)
}
func (o *TAMP_Type) GetBKP2R() uint32 {
	return volatile.LoadUint32(&o.BKP2R.Reg)
}

// TAMP.BKP3R: TAMP backup register
func (o *TAMP_Type) SetBKP3R(value uint32) {
	volatile.StoreUint32(&o.BKP3R.Reg, value)
}
func (o *TAMP_Type) GetBKP3R() uint32 {
	return volatile.LoadUint32(&o.BKP3R.Reg)
}

// TAMP.BKP4R: TAMP backup register
func (o *TAMP_Type) SetBKP4R(value uint32) {
	volatile.StoreUint32(&o.BKP4R.Reg, value)
}
func (o *TAMP_Type) GetBKP4R() uint32 {
	return volatile.LoadUint32(&o.BKP4R.Reg)
}

// TAMP.BKP5R: TAMP backup register
func (o *TAMP_Type) SetBKP5R(value uint32) {
	volatile.StoreUint32(&o.BKP5R.Reg, value)
}
func (o *TAMP_Type) GetBKP5R() uint32 {
	return volatile.LoadUint32(&o.BKP5R.Reg)
}

// TAMP.BKP6R: TAMP backup register
func (o *TAMP_Type) SetBKP6R(value uint32) {
	volatile.StoreUint32(&o.BKP6R.Reg, value)
}
func (o *TAMP_Type) GetBKP6R() uint32 {
	return volatile.LoadUint32(&o.BKP6R.Reg)
}

// TAMP.BKP7R: TAMP backup register
func (o *TAMP_Type) SetBKP7R(value uint32) {
	volatile.StoreUint32(&o.BKP7R.Reg, value)
}
func (o *TAMP_Type) GetBKP7R() uint32 {
	return volatile.LoadUint32(&o.BKP7R.Reg)
}

// TAMP.BKP8R: TAMP backup register
func (o *TAMP_Type) SetBKP8R(value uint32) {
	volatile.StoreUint32(&o.BKP8R.Reg, value)
}
func (o *TAMP_Type) GetBKP8R() uint32 {
	return volatile.LoadUint32(&o.BKP8R.Reg)
}

// TAMP.BKP9R: TAMP backup register
func (o *TAMP_Type) SetBKP9R(value uint32) {
	volatile.StoreUint32(&o.BKP9R.Reg, value)
}
func (o *TAMP_Type) GetBKP9R() uint32 {
	return volatile.LoadUint32(&o.BKP9R.Reg)
}

// TAMP.BKP10R: TAMP backup register
func (o *TAMP_Type) SetBKP10R(value uint32) {
	volatile.StoreUint32(&o.BKP10R.Reg, value)
}
func (o *TAMP_Type) GetBKP10R() uint32 {
	return volatile.LoadUint32(&o.BKP10R.Reg)
}

// TAMP.BKP11R: TAMP backup register
func (o *TAMP_Type) SetBKP11R(value uint32) {
	volatile.StoreUint32(&o.BKP11R.Reg, value)
}
func (o *TAMP_Type) GetBKP11R() uint32 {
	return volatile.LoadUint32(&o.BKP11R.Reg)
}

// TAMP.BKP12R: TAMP backup register
func (o *TAMP_Type) SetBKP12R(value uint32) {
	volatile.StoreUint32(&o.BKP12R.Reg, value)
}
func (o *TAMP_Type) GetBKP12R() uint32 {
	return volatile.LoadUint32(&o.BKP12R.Reg)
}

// TAMP.BKP13R: TAMP backup register
func (o *TAMP_Type) SetBKP13R(value uint32) {
	volatile.StoreUint32(&o.BKP13R.Reg, value)
}
func (o *TAMP_Type) GetBKP13R() uint32 {
	return volatile.LoadUint32(&o.BKP13R.Reg)
}

// TAMP.BKP14R: TAMP backup register
func (o *TAMP_Type) SetBKP14R(value uint32) {
	volatile.StoreUint32(&o.BKP14R.Reg, value)
}
func (o *TAMP_Type) GetBKP14R() uint32 {
	return volatile.LoadUint32(&o.BKP14R.Reg)
}

// TAMP.BKP15R: TAMP backup register
func (o *TAMP_Type) SetBKP15R(value uint32) {
	volatile.StoreUint32(&o.BKP15R.Reg, value)
}
func (o *TAMP_Type) GetBKP15R() uint32 {
	return volatile.LoadUint32(&o.BKP15R.Reg)
}

// TAMP.BKP16R: TAMP backup register
func (o *TAMP_Type) SetBKP16R(value uint32) {
	volatile.StoreUint32(&o.BKP16R.Reg, value)
}
func (o *TAMP_Type) GetBKP16R() uint32 {
	return volatile.LoadUint32(&o.BKP16R.Reg)
}

// TAMP.BKP17R: TAMP backup register
func (o *TAMP_Type) SetBKP17R(value uint32) {
	volatile.StoreUint32(&o.BKP17R.Reg, value)
}
func (o *TAMP_Type) GetBKP17R() uint32 {
	return volatile.LoadUint32(&o.BKP17R.Reg)
}

// TAMP.BKP18R: TAMP backup register
func (o *TAMP_Type) SetBKP18R(value uint32) {
	volatile.StoreUint32(&o.BKP18R.Reg, value)
}
func (o *TAMP_Type) GetBKP18R() uint32 {
	return volatile.LoadUint32(&o.BKP18R.Reg)
}

// TAMP.BKP19R: TAMP backup register
func (o *TAMP_Type) SetBKP19R(value uint32) {
	volatile.StoreUint32(&o.BKP19R.Reg, value)
}
func (o *TAMP_Type) GetBKP19R() uint32 {
	return volatile.LoadUint32(&o.BKP19R.Reg)
}

// Advanced-control timers
type TIM_Type struct {
	CR1          volatile.Register32 // 0x0
	CR2          volatile.Register32 // 0x4
	SMCR         volatile.Register32 // 0x8
	DIER         volatile.Register32 // 0xC
	SR           volatile.Register32 // 0x10
	EGR          volatile.Register32 // 0x14
	CCMR1_Output volatile.Register32 // 0x18
	CCMR2_Output volatile.Register32 // 0x1C
	CCER         volatile.Register32 // 0x20
	CNT          volatile.Register32 // 0x24
	PSC          volatile.Register32 // 0x28
	ARR          volatile.Register32 // 0x2C
	RCR          volatile.Register32 // 0x30
	CCR1         volatile.Register32 // 0x34
	CCR2         volatile.Register32 // 0x38
	CCR3         volatile.Register32 // 0x3C
	CCR4         volatile.Register32 // 0x40
	BDTR         volatile.Register32 // 0x44
	DCR          volatile.Register32 // 0x48
	DMAR         volatile.Register32 // 0x4C
	OR1          volatile.Register32 // 0x50
	CCMR3_Output volatile.Register32 // 0x54
	CCR5         volatile.Register32 // 0x58
	CCR6         volatile.Register32 // 0x5C
	AF1          volatile.Register32 // 0x60
	AF2          volatile.Register32 // 0x64
	TISEL        volatile.Register32 // 0x68
}

// TIM.CR1: control register 1
func (o *TIM_Type) SetCR1_UIFREMAP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR1_UIFREMAP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR1_CMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x60)|value<<5)
}
func (o *TIM_Type) GetCR1_CMS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x60) >> 5
}
func (o *TIM_Type) SetCR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR1_URS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// TIM.CR2: control register 2
func (o *TIM_Type) SetCR2_MMS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00000)|value<<20)
}
func (o *TIM_Type) GetCR2_MMS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00000) >> 20
}
func (o *TIM_Type) SetCR2_OIS6(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *TIM_Type) GetCR2_OIS6() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *TIM_Type) SetCR2_OIS5(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCR2_OIS5() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCR2_OIS4(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetCR2_OIS4() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetCR2_OIS3N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCR2_OIS3N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCR2_OIS3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCR2_OIS3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCR2_OIS2N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR2_OIS2N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCR2_OIS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCR2_OIS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCR2_OIS1N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCR2_OIS1N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCR2_OIS1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCR2_OIS1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCR2_TI1S(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR2_TI1S() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR2_MMS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCR2_MMS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR2_CCUS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR2_CCUS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR2_CCPC(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR2_CCPC() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// TIM.SMCR: slave mode control register
func (o *TIM_Type) SetSMCR_TS3_4(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x300000)|value<<20)
}
func (o *TIM_Type) GetSMCR_TS3_4() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x300000) >> 20
}
func (o *TIM_Type) SetSMCR_SMS_3(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetSMCR_SMS_3() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetSMCR_ETP(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetSMCR_ETP() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetSMCR_ECE(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetSMCR_ECE() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetSMCR_ETPS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x3000)|value<<12)
}
func (o *TIM_Type) GetSMCR_ETPS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x3000) >> 12
}
func (o *TIM_Type) SetSMCR_ETF(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetSMCR_ETF() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetSMCR_MSM(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSMCR_MSM() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSMCR_TS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetSMCR_TS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetSMCR_OCCS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetSMCR_OCCS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetSMCR_SMS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x7)|value)
}
func (o *TIM_Type) GetSMCR_SMS() uint32 {
	return volatile.LoadUint32(&o.SMCR.Reg) & 0x7
}

// TIM.DIER: DMA/interrupt enable register
func (o *TIM_Type) SetDIER_TDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetDIER_TDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetDIER_COMDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetDIER_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetDIER_CC4DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetDIER_CC4DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetDIER_CC3DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetDIER_CC3DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetDIER_CC2DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetDIER_CC2DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetDIER_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetDIER_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetDIER_UDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetDIER_UDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetDIER_BIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetDIER_BIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetDIER_TIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetDIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetDIER_COMIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetDIER_COMIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetDIER_CC4IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetDIER_CC4IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetDIER_CC3IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetDIER_CC3IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetDIER_CC2IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetDIER_CC2IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetDIER_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetDIER_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetDIER_UIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetDIER_UIE() uint32 {
	return volatile.LoadUint32(&o.DIER.Reg) & 0x1
}

// TIM.SR: status register
func (o *TIM_Type) SetSR_CC6IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *TIM_Type) GetSR_CC6IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *TIM_Type) SetSR_CC5IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetSR_CC5IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetSR_SBIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetSR_SBIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetSR_CC4OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetSR_CC4OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetSR_CC3OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetSR_CC3OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetSR_CC2OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetSR_CC2OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetSR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetSR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetSR_B2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetSR_B2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetSR_BIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSR_BIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetSR_TIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetSR_COMIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetSR_COMIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetSR_CC4IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetSR_CC4IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetSR_CC3IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetSR_CC3IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetSR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetSR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetSR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetSR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetSR_UIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetSR_UIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// TIM.EGR: event generation register
func (o *TIM_Type) SetEGR_B2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetEGR_B2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetEGR_BG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetEGR_BG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetEGR_TG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetEGR_TG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetEGR_COMG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetEGR_COMG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetEGR_CC4G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetEGR_CC4G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetEGR_CC3G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetEGR_CC3G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetEGR_CC2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetEGR_CC2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetEGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetEGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetEGR_UG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetEGR_UG() uint32 {
	return volatile.LoadUint32(&o.EGR.Reg) & 0x1
}

// TIM.CCMR1_Output: capture/compare mode register 1 (output mode)
func (o *TIM_Type) SetCCMR1_Output_OC2M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetCCMR1_Output_OC1M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR1_Output_OC2CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR1_Output_OC2CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR1_Output_OC2M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR1_Output_OC2PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR1_Output_OC2PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR1_Output_OC2FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR1_Output_OC2FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR1_Output_CC2S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR1_Output_CC2S() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR1_Output_OC1CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR1_Output_OC1CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x3
}

// TIM.CCMR2_Output: capture/compare mode register 2 (output mode)
func (o *TIM_Type) SetCCMR2_Output_OC4M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetCCMR2_Output_OC3M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR2_Output_OC4CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR2_Output_OC4CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR2_Output_OC4M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR2_Output_OC4PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR2_Output_OC4PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR2_Output_OC4FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR2_Output_OC4FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR2_Output_CC4S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR2_Output_CC4S() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR2_Output_OC3CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR2_Output_OC3CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR2_Output_OC3M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR2_Output_OC3PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR2_Output_OC3PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR2_Output_OC3FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR2_Output_OC3FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR2_Output_CC3S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR2_Output_CC3S() uint32 {
	return volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x3
}

// TIM.CCER: capture/compare enable register
func (o *TIM_Type) SetCCER_CC6P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200000)|value<<21)
}
func (o *TIM_Type) GetCCER_CC6P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200000) >> 21
}
func (o *TIM_Type) SetCCER_CC6E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100000)|value<<20)
}
func (o *TIM_Type) GetCCER_CC6E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100000) >> 20
}
func (o *TIM_Type) SetCCER_CC5P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20000)|value<<17)
}
func (o *TIM_Type) GetCCER_CC5P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20000) >> 17
}
func (o *TIM_Type) SetCCER_CC5E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCER_CC5E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCER_CC4P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCCER_CC4P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCCER_CC4E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCCER_CC4E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCCER_CC3NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCER_CC3NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCER_CC3NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCER_CC3NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCER_CC3P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCCER_CC3P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCCER_CC3E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCCER_CC3E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCCER_CC2NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCER_CC2NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCER_CC2NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetCCER_CC2NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetCCER_CC2P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetCCER_CC2P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetCCER_CC2E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCCER_CC2E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCER_CC1NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCER_CC1NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}

// TIM.CNT: counter
func (o *TIM_Type) SetCNT_UIFCPY(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCNT_UIFCPY() uint32 {
	return (volatile.LoadUint32(&o.CNT.Reg) & 0x80000000) >> 31
}
func (o *TIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// TIM.PSC: prescaler
func (o *TIM_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIM.ARR: auto-reload register
func (o *TIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// TIM.RCR: repetition counter register
func (o *TIM_Type) SetRCR_REP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetRCR_REP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// TIM.CCR1: capture/compare register 1
func (o *TIM_Type) SetCCR1(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR1() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0xffff
}

// TIM.CCR2: capture/compare register 2
func (o *TIM_Type) SetCCR2(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR2() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0xffff
}

// TIM.CCR3: capture/compare register 3
func (o *TIM_Type) SetCCR3(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR3() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg) & 0xffff
}

// TIM.CCR4: capture/compare register 4
func (o *TIM_Type) SetCCR4(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR4() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg) & 0xffff
}

// TIM.BDTR: break and dead-time register
func (o *TIM_Type) SetBDTR_BK2BID(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x20000000)|value<<29)
}
func (o *TIM_Type) GetBDTR_BK2BID() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x20000000) >> 29
}
func (o *TIM_Type) SetBDTR_BKBID(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x10000000)|value<<28)
}
func (o *TIM_Type) GetBDTR_BKBID() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x10000000) >> 28
}
func (o *TIM_Type) SetBDTR_BK2DSRM(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000000)|value<<27)
}
func (o *TIM_Type) GetBDTR_BK2DSRM() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000000) >> 27
}
func (o *TIM_Type) SetBDTR_BKDSRM(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000000)|value<<26)
}
func (o *TIM_Type) GetBDTR_BKDSRM() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000000) >> 26
}
func (o *TIM_Type) SetBDTR_BK2P(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000000)|value<<25)
}
func (o *TIM_Type) GetBDTR_BK2P() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000000) >> 25
}
func (o *TIM_Type) SetBDTR_BK2E(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetBDTR_BK2E() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetBDTR_BK2F(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf00000)|value<<20)
}
func (o *TIM_Type) GetBDTR_BK2F() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf00000) >> 20
}
func (o *TIM_Type) SetBDTR_BKF(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf0000)|value<<16)
}
func (o *TIM_Type) GetBDTR_BKF() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf0000) >> 16
}
func (o *TIM_Type) SetBDTR_MOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetBDTR_MOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetBDTR_AOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetBDTR_AOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetBDTR_BKP(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetBDTR_BKP() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetBDTR_BKE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetBDTR_BKE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetBDTR_OSSR(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetBDTR_OSSR() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetBDTR_OSSI(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetBDTR_OSSI() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetBDTR_LOCK(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetBDTR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetBDTR_DTG(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetBDTR_DTG() uint32 {
	return volatile.LoadUint32(&o.BDTR.Reg) & 0xff
}

// TIM.DCR: DMA control register
func (o *TIM_Type) SetDCR_DBL(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIM_Type) GetDCR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f00) >> 8
}
func (o *TIM_Type) SetDCR_DBA(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f)|value)
}
func (o *TIM_Type) GetDCR_DBA() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1f
}

// TIM.DMAR: DMA address for full transfer
func (o *TIM_Type) SetDMAR_DMAB(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, volatile.LoadUint32(&o.DMAR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetDMAR_DMAB() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg) & 0xffff
}

// TIM.OR1: option register 1
func (o *TIM_Type) SetOR1_TI1_RMP(value uint32) {
	volatile.StoreUint32(&o.OR1.Reg, volatile.LoadUint32(&o.OR1.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetOR1_TI1_RMP() uint32 {
	return (volatile.LoadUint32(&o.OR1.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetOR1_TIM1_ETR_ADC1_RMP(value uint32) {
	volatile.StoreUint32(&o.OR1.Reg, volatile.LoadUint32(&o.OR1.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetOR1_TIM1_ETR_ADC1_RMP() uint32 {
	return volatile.LoadUint32(&o.OR1.Reg) & 0x3
}

// TIM.CCMR3_Output: capture/compare mode register 3
func (o *TIM_Type) SetCCMR3_Output_OC6M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR3_Output_OC6M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetCCMR3_Output_OC5M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR3_Output_OC5M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR3_Output_OC6CE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR3_Output_OC6CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR3_Output_OC6M(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR3_Output_OC6M() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR3_Output_OC6PE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR3_Output_OC6PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR3_Output_OC6FE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR3_Output_OC6FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR3_Output_OC5CE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR3_Output_OC5CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR3_Output_OC5M(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR3_Output_OC5M() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR3_Output_OC5PE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR3_Output_OC5PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR3_Output_OC5FE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR3_Output_OC5FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x4) >> 2
}

// TIM.CCR5: capture/compare register 5
func (o *TIM_Type) SetCCR5_GC5C3(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCCR5_GC5C3() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x80000000) >> 31
}
func (o *TIM_Type) SetCCR5_GC5C2(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x40000000)|value<<30)
}
func (o *TIM_Type) GetCCR5_GC5C2() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x40000000) >> 30
}
func (o *TIM_Type) SetCCR5_GC5C1(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x20000000)|value<<29)
}
func (o *TIM_Type) GetCCR5_GC5C1() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x20000000) >> 29
}
func (o *TIM_Type) SetCCR5(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR5() uint32 {
	return volatile.LoadUint32(&o.CCR5.Reg) & 0xffff
}

// TIM.CCR6: capture/compare register 6
func (o *TIM_Type) SetCCR6(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR6() uint32 {
	return volatile.LoadUint32(&o.CCR6.Reg) & 0xffff
}

// TIM.AF1: alternate function option register 1
func (o *TIM_Type) SetAF1_ETRSEL(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x3c000)|value<<14)
}
func (o *TIM_Type) GetAF1_ETRSEL() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x3c000) >> 14
}
func (o *TIM_Type) SetAF1_BKCMP2P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetAF1_BKCMP2P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetAF1_BKCMP1P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetAF1_BKCMP1P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetAF1_BKINP(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF1_BKINP() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetAF1_BKCMP2E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetAF1_BKCMP2E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetAF1_BKCMP1E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetAF1_BKCMP1E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetAF1_BKINE(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF1_BKINE() uint32 {
	return volatile.LoadUint32(&o.AF1.Reg) & 0x1
}

// TIM.AF2: Alternate function register 2
func (o *TIM_Type) SetAF2_BK2CMP2P(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetAF2_BK2CMP2P() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetAF2_BK2CMP1P(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetAF2_BK2CMP1P() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetAF2_BK2INP(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF2_BK2INP() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetAF2_BK2CMP2E(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetAF2_BK2CMP2E() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetAF2_BK2CMP1E(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetAF2_BK2CMP1E() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetAF2_BK2INE(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF2_BK2INE() uint32 {
	return volatile.LoadUint32(&o.AF2.Reg) & 0x1
}

// TIM.TISEL: timer input selection register
func (o *TIM_Type) SetTISEL_TI4SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf000000)|value<<24)
}
func (o *TIM_Type) GetTISEL_TI4SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf000000) >> 24
}
func (o *TIM_Type) SetTISEL_TI3SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf0000)|value<<16)
}
func (o *TIM_Type) GetTISEL_TI3SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf0000) >> 16
}
func (o *TIM_Type) SetTISEL_TI2SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetTISEL_TI2SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetTISEL_TI1SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf)|value)
}
func (o *TIM_Type) GetTISEL_TI1SEL() uint32 {
	return volatile.LoadUint32(&o.TISEL.Reg) & 0xf
}

// Voltage reference buffer
type VREFBUF_Type struct {
	CSR volatile.Register32 // 0x0
	CCR volatile.Register32 // 0x4
}

// VREFBUF.CSR: control and status register
func (o *VREFBUF_Type) SetCSR_VRR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *VREFBUF_Type) GetCSR_VRR() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *VREFBUF_Type) SetCSR_VRS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *VREFBUF_Type) GetCSR_VRS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *VREFBUF_Type) SetCSR_HIZ(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *VREFBUF_Type) GetCSR_HIZ() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *VREFBUF_Type) SetCSR_ENVR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *VREFBUF_Type) GetCSR_ENVR() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}

// VREFBUF.CCR: calibration control register
func (o *VREFBUF_Type) SetCCR_TRIM(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3f)|value)
}
func (o *VREFBUF_Type) GetCCR_TRIM() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x3f
}

// System window watchdog
type WWDG_Type struct {
	CR  volatile.Register32 // 0x0
	CFR volatile.Register32 // 0x4
	SR  volatile.Register32 // 0x8
}

// WWDG.CR: Control register
func (o *WWDG_Type) SetCR_WDGA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *WWDG_Type) GetCR_WDGA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *WWDG_Type) SetCR_T(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCR_T() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7f
}

// WWDG.CFR: Configuration register
func (o *WWDG_Type) SetCFR_EWI(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *WWDG_Type) GetCFR_EWI() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *WWDG_Type) SetCFR_W(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCFR_W() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCFR_WDGTB(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x3800)|value<<11)
}
func (o *WWDG_Type) GetCFR_WDGTB() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x3800) >> 11
}

// WWDG.SR: Status register
func (o *WWDG_Type) SetSR_EWIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *WWDG_Type) GetSR_EWIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Constants for ADC: Analog to digital convertor
const (
	// ISR: ADC interrupt and status register
	// Position of ADRDY field.
	ADC_ISR_ADRDY_Pos = 0x0
	// Bit mask of ADRDY field.
	ADC_ISR_ADRDY_Msk = 0x1
	// Bit ADRDY.
	ADC_ISR_ADRDY = 0x1
	// ADC not yet ready to start conversion
	ADC_ISR_ADRDY_NotReady = 0x0
	// ADC ready to start conversion
	ADC_ISR_ADRDY_Ready = 0x1
	// Clear the ADC ready flag
	ADC_ISR_ADRDY_Clear = 0x1
	// Position of EOSMP field.
	ADC_ISR_EOSMP_Pos = 0x1
	// Bit mask of EOSMP field.
	ADC_ISR_EOSMP_Msk = 0x2
	// Bit EOSMP.
	ADC_ISR_EOSMP = 0x2
	// Not at the end of the samplings phase
	ADC_ISR_EOSMP_NotAtEnd = 0x0
	// End of sampling phase reached
	ADC_ISR_EOSMP_AtEnd = 0x1
	// Clear the sampling phase flag
	ADC_ISR_EOSMP_Clear = 0x1
	// Position of EOC field.
	ADC_ISR_EOC_Pos = 0x2
	// Bit mask of EOC field.
	ADC_ISR_EOC_Msk = 0x4
	// Bit EOC.
	ADC_ISR_EOC = 0x4
	// Channel conversion is not complete
	ADC_ISR_EOC_NotComplete = 0x0
	// Channel conversion complete
	ADC_ISR_EOC_Complete = 0x1
	// Clear the channel conversion flag
	ADC_ISR_EOC_Clear = 0x1
	// Position of EOS field.
	ADC_ISR_EOS_Pos = 0x3
	// Bit mask of EOS field.
	ADC_ISR_EOS_Msk = 0x8
	// Bit EOS.
	ADC_ISR_EOS = 0x8
	// Conversion sequence is not complete
	ADC_ISR_EOS_NotComplete = 0x0
	// Conversion sequence complete
	ADC_ISR_EOS_Complete = 0x1
	// Clear the conversion sequence flag
	ADC_ISR_EOS_Clear = 0x1
	// Position of OVR field.
	ADC_ISR_OVR_Pos = 0x4
	// Bit mask of OVR field.
	ADC_ISR_OVR_Msk = 0x10
	// Bit OVR.
	ADC_ISR_OVR = 0x10
	// No overrun occurred
	ADC_ISR_OVR_NoOverrun = 0x0
	// Overrun occurred
	ADC_ISR_OVR_Overrun = 0x1
	// Clear the overrun flag
	ADC_ISR_OVR_Clear = 0x1
	// Position of AWD1 field.
	ADC_ISR_AWD1_Pos = 0x7
	// Bit mask of AWD1 field.
	ADC_ISR_AWD1_Msk = 0x80
	// Bit AWD1.
	ADC_ISR_AWD1 = 0x80
	// No analog watchdog event occurred
	ADC_ISR_AWD1_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_ISR_AWD1_Event = 0x1
	// Clear the analog watchdog event flag
	ADC_ISR_AWD1_Clear = 0x1
	// Position of AWD2 field.
	ADC_ISR_AWD2_Pos = 0x8
	// Bit mask of AWD2 field.
	ADC_ISR_AWD2_Msk = 0x100
	// Bit AWD2.
	ADC_ISR_AWD2 = 0x100
	// No analog watchdog event occurred
	ADC_ISR_AWD2_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_ISR_AWD2_Event = 0x1
	// Clear the analog watchdog event flag
	ADC_ISR_AWD2_Clear = 0x1
	// Position of AWD3 field.
	ADC_ISR_AWD3_Pos = 0x9
	// Bit mask of AWD3 field.
	ADC_ISR_AWD3_Msk = 0x200
	// Bit AWD3.
	ADC_ISR_AWD3 = 0x200
	// No analog watchdog event occurred
	ADC_ISR_AWD3_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_ISR_AWD3_Event = 0x1
	// Clear the analog watchdog event flag
	ADC_ISR_AWD3_Clear = 0x1
	// Position of EOCAL field.
	ADC_ISR_EOCAL_Pos = 0xb
	// Bit mask of EOCAL field.
	ADC_ISR_EOCAL_Msk = 0x800
	// Bit EOCAL.
	ADC_ISR_EOCAL = 0x800
	// Calibration is not complete
	ADC_ISR_EOCAL_NotComplete = 0x0
	// Calibration complete
	ADC_ISR_EOCAL_Complete = 0x1
	// Clear the calibration flag
	ADC_ISR_EOCAL_Clear = 0x1
	// Position of CCRDY field.
	ADC_ISR_CCRDY_Pos = 0xd
	// Bit mask of CCRDY field.
	ADC_ISR_CCRDY_Msk = 0x2000
	// Bit CCRDY.
	ADC_ISR_CCRDY = 0x2000
	// Channel configuration update not applied
	ADC_ISR_CCRDY_NotComplete = 0x0
	// Channel configuration update is applied
	ADC_ISR_CCRDY_Complete = 0x1
	// Clear the channel configuration flag
	ADC_ISR_CCRDY_Clear = 0x1

	// IER: ADC interrupt enable register
	// Position of ADRDYIE field.
	ADC_IER_ADRDYIE_Pos = 0x0
	// Bit mask of ADRDYIE field.
	ADC_IER_ADRDYIE_Msk = 0x1
	// Bit ADRDYIE.
	ADC_IER_ADRDYIE = 0x1
	// ADRDY interrupt disabled
	ADC_IER_ADRDYIE_Disabled = 0x0
	// ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.
	ADC_IER_ADRDYIE_Enabled = 0x1
	// Position of EOSMPIE field.
	ADC_IER_EOSMPIE_Pos = 0x1
	// Bit mask of EOSMPIE field.
	ADC_IER_EOSMPIE_Msk = 0x2
	// Bit EOSMPIE.
	ADC_IER_EOSMPIE = 0x2
	// EOSMP interrupt disabled
	ADC_IER_EOSMPIE_Disabled = 0x0
	// EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.
	ADC_IER_EOSMPIE_Enabled = 0x1
	// Position of EOCIE field.
	ADC_IER_EOCIE_Pos = 0x2
	// Bit mask of EOCIE field.
	ADC_IER_EOCIE_Msk = 0x4
	// Bit EOCIE.
	ADC_IER_EOCIE = 0x4
	// EOC interrupt disabled
	ADC_IER_EOCIE_Disabled = 0x0
	// EOC interrupt enabled. An interrupt is generated when the EOC bit is set.
	ADC_IER_EOCIE_Enabled = 0x1
	// Position of EOSIE field.
	ADC_IER_EOSIE_Pos = 0x3
	// Bit mask of EOSIE field.
	ADC_IER_EOSIE_Msk = 0x8
	// Bit EOSIE.
	ADC_IER_EOSIE = 0x8
	// EOS interrupt disabled
	ADC_IER_EOSIE_Disabled = 0x0
	// EOS interrupt enabled. An interrupt is generated when the EOS bit is set.
	ADC_IER_EOSIE_Enabled = 0x1
	// Position of OVRIE field.
	ADC_IER_OVRIE_Pos = 0x4
	// Bit mask of OVRIE field.
	ADC_IER_OVRIE_Msk = 0x10
	// Bit OVRIE.
	ADC_IER_OVRIE = 0x10
	// Overrun interrupt disabled
	ADC_IER_OVRIE_Disabled = 0x0
	// Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.
	ADC_IER_OVRIE_Enabled = 0x1
	// Position of AWD1IE field.
	ADC_IER_AWD1IE_Pos = 0x7
	// Bit mask of AWD1IE field.
	ADC_IER_AWD1IE_Msk = 0x80
	// Bit AWD1IE.
	ADC_IER_AWD1IE = 0x80
	// Analog watchdog interrupt disabled
	ADC_IER_AWD1IE_Disabled = 0x0
	// Analog watchdog interrupt enabled
	ADC_IER_AWD1IE_Enabled = 0x1
	// Position of AWD2IE field.
	ADC_IER_AWD2IE_Pos = 0x8
	// Bit mask of AWD2IE field.
	ADC_IER_AWD2IE_Msk = 0x100
	// Bit AWD2IE.
	ADC_IER_AWD2IE = 0x100
	// Analog watchdog interrupt disabled
	ADC_IER_AWD2IE_Disabled = 0x0
	// Analog watchdog interrupt enabled
	ADC_IER_AWD2IE_Enabled = 0x1
	// Position of AWD3IE field.
	ADC_IER_AWD3IE_Pos = 0x9
	// Bit mask of AWD3IE field.
	ADC_IER_AWD3IE_Msk = 0x200
	// Bit AWD3IE.
	ADC_IER_AWD3IE = 0x200
	// Analog watchdog interrupt disabled
	ADC_IER_AWD3IE_Disabled = 0x0
	// Analog watchdog interrupt enabled
	ADC_IER_AWD3IE_Enabled = 0x1
	// Position of EOCALIE field.
	ADC_IER_EOCALIE_Pos = 0xb
	// Bit mask of EOCALIE field.
	ADC_IER_EOCALIE_Msk = 0x800
	// Bit EOCALIE.
	ADC_IER_EOCALIE = 0x800
	// End of calibration interrupt disabled
	ADC_IER_EOCALIE_Disabled = 0x0
	// End of calibration interrupt enabled
	ADC_IER_EOCALIE_Enabled = 0x1
	// Position of CCRDYIE field.
	ADC_IER_CCRDYIE_Pos = 0xd
	// Bit mask of CCRDYIE field.
	ADC_IER_CCRDYIE_Msk = 0x2000
	// Bit CCRDYIE.
	ADC_IER_CCRDYIE = 0x2000
	// Channel configuration ready interrupt disabled
	ADC_IER_CCRDYIE_Disabled = 0x0
	// Channel configuration ready interrupt enabled
	ADC_IER_CCRDYIE_Enabled = 0x1

	// CR: ADC control register
	// Position of ADEN field.
	ADC_CR_ADEN_Pos = 0x0
	// Bit mask of ADEN field.
	ADC_CR_ADEN_Msk = 0x1
	// Bit ADEN.
	ADC_CR_ADEN = 0x1
	// ADC disabled
	ADC_CR_ADEN_Disabled = 0x0
	// ADC enabled
	ADC_CR_ADEN_Enabled = 0x1
	// Position of ADDIS field.
	ADC_CR_ADDIS_Pos = 0x1
	// Bit mask of ADDIS field.
	ADC_CR_ADDIS_Msk = 0x2
	// Bit ADDIS.
	ADC_CR_ADDIS = 0x2
	// No disable command active
	ADC_CR_ADDIS_NotDisabling = 0x0
	// ADC disabling
	ADC_CR_ADDIS_Disabling = 0x1
	// Disable the ADC
	ADC_CR_ADDIS_Disable = 0x1
	// Position of ADSTART field.
	ADC_CR_ADSTART_Pos = 0x2
	// Bit mask of ADSTART field.
	ADC_CR_ADSTART_Msk = 0x4
	// Bit ADSTART.
	ADC_CR_ADSTART = 0x4
	// No conversion ongoing
	ADC_CR_ADSTART_NotActive = 0x0
	// ADC operating and may be converting
	ADC_CR_ADSTART_Active = 0x1
	// Start the ADC conversion (may be delayed for hardware triggers)
	ADC_CR_ADSTART_StartConversion = 0x1
	// Position of ADSTP field.
	ADC_CR_ADSTP_Pos = 0x4
	// Bit mask of ADSTP field.
	ADC_CR_ADSTP_Msk = 0x10
	// Bit ADSTP.
	ADC_CR_ADSTP = 0x10
	// No stop command active
	ADC_CR_ADSTP_NotStopping = 0x0
	// ADC stopping conversion
	ADC_CR_ADSTP_Stopping = 0x1
	// Stop the active conversion
	ADC_CR_ADSTP_StopConversion = 0x1
	// Position of ADVREGEN field.
	ADC_CR_ADVREGEN_Pos = 0x1c
	// Bit mask of ADVREGEN field.
	ADC_CR_ADVREGEN_Msk = 0x10000000
	// Bit ADVREGEN.
	ADC_CR_ADVREGEN = 0x10000000
	// ADC voltage regulator disabled
	ADC_CR_ADVREGEN_Disabled = 0x0
	// ADC voltage regulator enabled
	ADC_CR_ADVREGEN_Enabled = 0x1
	// Position of ADCAL field.
	ADC_CR_ADCAL_Pos = 0x1f
	// Bit mask of ADCAL field.
	ADC_CR_ADCAL_Msk = 0x80000000
	// Bit ADCAL.
	ADC_CR_ADCAL = 0x80000000
	// ADC calibration either not yet performed or completed
	ADC_CR_ADCAL_NotCalibrating = 0x0
	// ADC calibration in progress
	ADC_CR_ADCAL_Calibrating = 0x1
	// Start the ADC calibration sequence
	ADC_CR_ADCAL_StartCalibration = 0x1

	// CFGR1: ADC configuration register 1
	// Position of DMAEN field.
	ADC_CFGR1_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	ADC_CFGR1_DMAEN_Msk = 0x1
	// Bit DMAEN.
	ADC_CFGR1_DMAEN = 0x1
	// DMA disabled
	ADC_CFGR1_DMAEN_Disabled = 0x0
	// DMA enabled
	ADC_CFGR1_DMAEN_Enabled = 0x1
	// Position of DMACFG field.
	ADC_CFGR1_DMACFG_Pos = 0x1
	// Bit mask of DMACFG field.
	ADC_CFGR1_DMACFG_Msk = 0x2
	// Bit DMACFG.
	ADC_CFGR1_DMACFG = 0x2
	// DMA one shot mode selected
	ADC_CFGR1_DMACFG_OneShot = 0x0
	// DMA circular mode selected
	ADC_CFGR1_DMACFG_Circular = 0x1
	// Position of SCANDIR field.
	ADC_CFGR1_SCANDIR_Pos = 0x2
	// Bit mask of SCANDIR field.
	ADC_CFGR1_SCANDIR_Msk = 0x4
	// Bit SCANDIR.
	ADC_CFGR1_SCANDIR = 0x4
	// Upward scan (from CHSEL0 to CHSEL17)
	ADC_CFGR1_SCANDIR_Upward = 0x0
	// Backward scan (from CHSEL17 to CHSEL0)
	ADC_CFGR1_SCANDIR_Backward = 0x1
	// Position of RES field.
	ADC_CFGR1_RES_Pos = 0x3
	// Bit mask of RES field.
	ADC_CFGR1_RES_Msk = 0x18
	// 12 bits
	ADC_CFGR1_RES_Bits12 = 0x0
	// 10 bits
	ADC_CFGR1_RES_Bits10 = 0x1
	// 8 bits
	ADC_CFGR1_RES_Bits8 = 0x2
	// 6 bits
	ADC_CFGR1_RES_Bits6 = 0x3
	// Position of ALIGN field.
	ADC_CFGR1_ALIGN_Pos = 0x5
	// Bit mask of ALIGN field.
	ADC_CFGR1_ALIGN_Msk = 0x20
	// Bit ALIGN.
	ADC_CFGR1_ALIGN = 0x20
	// Right alignment
	ADC_CFGR1_ALIGN_Right = 0x0
	// Left alignment
	ADC_CFGR1_ALIGN_Left = 0x1
	// Position of EXTSEL field.
	ADC_CFGR1_EXTSEL_Pos = 0x6
	// Bit mask of EXTSEL field.
	ADC_CFGR1_EXTSEL_Msk = 0x1c0
	// Timer 1 TRGO event
	ADC_CFGR1_EXTSEL_TIM1_TRGO = 0x0
	// Timer 1 CC4 event
	ADC_CFGR1_EXTSEL_TIM1_CC4 = 0x1
	// Timer 2 TRGO event
	ADC_CFGR1_EXTSEL_TIM2_TRGO = 0x2
	// Timer 2 CH4 event
	ADC_CFGR1_EXTSEL_TIM2_CH4 = 0x3
	// Timer 2 CH3 event
	ADC_CFGR1_EXTSEL_TIM2_CH3 = 0x5
	// EXTI line 11 event
	ADC_CFGR1_EXTSEL_EXTI_LINE11 = 0x7
	// Position of EXTEN field.
	ADC_CFGR1_EXTEN_Pos = 0xa
	// Bit mask of EXTEN field.
	ADC_CFGR1_EXTEN_Msk = 0xc00
	// Hardware trigger detection disabled
	ADC_CFGR1_EXTEN_Disabled = 0x0
	// Hardware trigger detection on the rising edge
	ADC_CFGR1_EXTEN_RisingEdge = 0x1
	// Hardware trigger detection on the falling edge
	ADC_CFGR1_EXTEN_FallingEdge = 0x2
	// Hardware trigger detection on both the rising and falling edges
	ADC_CFGR1_EXTEN_BothEdges = 0x3
	// Position of OVRMOD field.
	ADC_CFGR1_OVRMOD_Pos = 0xc
	// Bit mask of OVRMOD field.
	ADC_CFGR1_OVRMOD_Msk = 0x1000
	// Bit OVRMOD.
	ADC_CFGR1_OVRMOD = 0x1000
	// ADC_DR register is preserved with the old data when an overrun is detected
	ADC_CFGR1_OVRMOD_Preserve = 0x0
	// ADC_DR register is overwritten with the last conversion result when an overrun is detected
	ADC_CFGR1_OVRMOD_Overwrite = 0x1
	// Position of CONT field.
	ADC_CFGR1_CONT_Pos = 0xd
	// Bit mask of CONT field.
	ADC_CFGR1_CONT_Msk = 0x2000
	// Bit CONT.
	ADC_CFGR1_CONT = 0x2000
	// Single conversion mode
	ADC_CFGR1_CONT_Single = 0x0
	// Continuous conversion mode
	ADC_CFGR1_CONT_Continuous = 0x1
	// Position of WAIT field.
	ADC_CFGR1_WAIT_Pos = 0xe
	// Bit mask of WAIT field.
	ADC_CFGR1_WAIT_Msk = 0x4000
	// Bit WAIT.
	ADC_CFGR1_WAIT = 0x4000
	// Wait conversion mode off
	ADC_CFGR1_WAIT_Disabled = 0x0
	// Wait conversion mode on
	ADC_CFGR1_WAIT_Enabled = 0x1
	// Position of AUTOFF field.
	ADC_CFGR1_AUTOFF_Pos = 0xf
	// Bit mask of AUTOFF field.
	ADC_CFGR1_AUTOFF_Msk = 0x8000
	// Bit AUTOFF.
	ADC_CFGR1_AUTOFF = 0x8000
	// Auto-off mode disabled
	ADC_CFGR1_AUTOFF_Disabled = 0x0
	// Auto-off mode enabled
	ADC_CFGR1_AUTOFF_Enabled = 0x1
	// Position of DISCEN field.
	ADC_CFGR1_DISCEN_Pos = 0x10
	// Bit mask of DISCEN field.
	ADC_CFGR1_DISCEN_Msk = 0x10000
	// Bit DISCEN.
	ADC_CFGR1_DISCEN = 0x10000
	// Discontinuous mode disabled
	ADC_CFGR1_DISCEN_Disabled = 0x0
	// Discontinuous mode enabled
	ADC_CFGR1_DISCEN_Enabled = 0x1
	// Position of CHSELRMOD field.
	ADC_CFGR1_CHSELRMOD_Pos = 0x15
	// Bit mask of CHSELRMOD field.
	ADC_CFGR1_CHSELRMOD_Msk = 0x200000
	// Bit CHSELRMOD.
	ADC_CFGR1_CHSELRMOD = 0x200000
	// Each bit of the ADC_CHSELR register enables an input
	ADC_CFGR1_CHSELRMOD_BitPerInput = 0x0
	// ADC_CHSELR register is able to sequence up to 8 channels
	ADC_CFGR1_CHSELRMOD_Sequence = 0x1
	// Position of AWD1SGL field.
	ADC_CFGR1_AWD1SGL_Pos = 0x16
	// Bit mask of AWD1SGL field.
	ADC_CFGR1_AWD1SGL_Msk = 0x400000
	// Bit AWD1SGL.
	ADC_CFGR1_AWD1SGL = 0x400000
	// Analog watchdog 1 enabled on all channels
	ADC_CFGR1_AWD1SGL_AllChannels = 0x0
	// Analog watchdog 1 enabled on a single channel
	ADC_CFGR1_AWD1SGL_SingleChannel = 0x1
	// Position of AWD1EN field.
	ADC_CFGR1_AWD1EN_Pos = 0x17
	// Bit mask of AWD1EN field.
	ADC_CFGR1_AWD1EN_Msk = 0x800000
	// Bit AWD1EN.
	ADC_CFGR1_AWD1EN = 0x800000
	// Analog watchdog 1 disabled
	ADC_CFGR1_AWD1EN_Disabled = 0x0
	// Analog watchdog 1 enabled
	ADC_CFGR1_AWD1EN_Enabled = 0x1
	// Position of AWD1CH field.
	ADC_CFGR1_AWD1CH_Pos = 0x1a
	// Bit mask of AWD1CH field.
	ADC_CFGR1_AWD1CH_Msk = 0x7c000000

	// CFGR2: ADC configuration register 2
	// Position of OVSE field.
	ADC_CFGR2_OVSE_Pos = 0x0
	// Bit mask of OVSE field.
	ADC_CFGR2_OVSE_Msk = 0x1
	// Bit OVSE.
	ADC_CFGR2_OVSE = 0x1
	// Oversampler disabled
	ADC_CFGR2_OVSE_Disabled = 0x0
	// Oversampler enabled
	ADC_CFGR2_OVSE_Enabled = 0x1
	// Position of TOVS field.
	ADC_CFGR2_TOVS_Pos = 0x9
	// Bit mask of TOVS field.
	ADC_CFGR2_TOVS_Msk = 0x200
	// Bit TOVS.
	ADC_CFGR2_TOVS = 0x200
	// All oversampled conversions for a channel are done consecutively after a trigger
	ADC_CFGR2_TOVS_TriggerAll = 0x0
	// Each oversampled conversion for a channel needs a trigger
	ADC_CFGR2_TOVS_TriggerEach = 0x1
	// Position of LFTRIG field.
	ADC_CFGR2_LFTRIG_Pos = 0x1d
	// Bit mask of LFTRIG field.
	ADC_CFGR2_LFTRIG_Msk = 0x20000000
	// Bit LFTRIG.
	ADC_CFGR2_LFTRIG = 0x20000000
	// Low Frequency Trigger Mode disabled
	ADC_CFGR2_LFTRIG_Disabled = 0x0
	// Low Frequency Trigger Mode enabled
	ADC_CFGR2_LFTRIG_Enabled = 0x1
	// Position of CKMODE field.
	ADC_CFGR2_CKMODE_Pos = 0x1e
	// Bit mask of CKMODE field.
	ADC_CFGR2_CKMODE_Msk = 0xc0000000
	// ADCCLK (Asynchronous clock mode)
	ADC_CFGR2_CKMODE_ADCLK = 0x0
	// PCLK/2 (Synchronous clock mode)
	ADC_CFGR2_CKMODE_PCLK_Div2 = 0x1
	// PCLK/4 (Synchronous clock mode)
	ADC_CFGR2_CKMODE_PCLK_Div4 = 0x2
	// PCLK (Synchronous clock mode)
	ADC_CFGR2_CKMODE_PCLK = 0x3
	// Position of OVSS field.
	ADC_CFGR2_OVSS_Pos = 0x5
	// Bit mask of OVSS field.
	ADC_CFGR2_OVSS_Msk = 0x1e0
	// No shift
	ADC_CFGR2_OVSS_NoShift = 0x0
	// Shift 1-bit
	ADC_CFGR2_OVSS_Shift1 = 0x1
	// Shift 2-bits
	ADC_CFGR2_OVSS_Shift2 = 0x2
	// Shift 3-bits
	ADC_CFGR2_OVSS_Shift3 = 0x3
	// Shift 4-bits
	ADC_CFGR2_OVSS_Shift4 = 0x4
	// Shift 5-bits
	ADC_CFGR2_OVSS_Shift5 = 0x5
	// Shift 6-bits
	ADC_CFGR2_OVSS_Shift6 = 0x6
	// Shift 7-bits
	ADC_CFGR2_OVSS_Shift7 = 0x7
	// Shift 8-bits
	ADC_CFGR2_OVSS_Shift8 = 0x8
	// Position of OVSR field.
	ADC_CFGR2_OVSR_Pos = 0x2
	// Bit mask of OVSR field.
	ADC_CFGR2_OVSR_Msk = 0x1c
	// 2x
	ADC_CFGR2_OVSR_Mul2 = 0x0
	// 4x
	ADC_CFGR2_OVSR_Mul4 = 0x1
	// 8x
	ADC_CFGR2_OVSR_Mul8 = 0x2
	// 16x
	ADC_CFGR2_OVSR_Mul16 = 0x3
	// 32x
	ADC_CFGR2_OVSR_Mul32 = 0x4
	// 64x
	ADC_CFGR2_OVSR_Mul64 = 0x5
	// 128x
	ADC_CFGR2_OVSR_Mul128 = 0x6
	// 256x
	ADC_CFGR2_OVSR_Mul256 = 0x7

	// SMPR: ADC sampling time register
	// Position of SMP1 field.
	ADC_SMPR_SMP1_Pos = 0x0
	// Bit mask of SMP1 field.
	ADC_SMPR_SMP1_Msk = 0x7
	// 1.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles1_5 = 0x0
	// 3.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles3_5 = 0x1
	// 7.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles7_5 = 0x2
	// 12.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles12_5 = 0x3
	// 19.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles19_5 = 0x4
	// 39.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles39_5 = 0x5
	// 79.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles79_5 = 0x6
	// 160.5 ADC clock cycles
	ADC_SMPR_SMP1_Cycles160_5 = 0x7
	// Position of SMP2 field.
	ADC_SMPR_SMP2_Pos = 0x4
	// Bit mask of SMP2 field.
	ADC_SMPR_SMP2_Msk = 0x70
	// 1.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles1_5 = 0x0
	// 3.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles3_5 = 0x1
	// 7.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles7_5 = 0x2
	// 12.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles12_5 = 0x3
	// 19.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles19_5 = 0x4
	// 39.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles39_5 = 0x5
	// 79.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles79_5 = 0x6
	// 160.5 ADC clock cycles
	ADC_SMPR_SMP2_Cycles160_5 = 0x7
	// Position of SMPSEL0 field.
	ADC_SMPR_SMPSEL0_Pos = 0x8
	// Bit mask of SMPSEL0 field.
	ADC_SMPR_SMPSEL0_Msk = 0x100
	// Bit SMPSEL0.
	ADC_SMPR_SMPSEL0 = 0x100
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL0_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL0_Smp2 = 0x1
	// Position of SMPSEL1 field.
	ADC_SMPR_SMPSEL1_Pos = 0x9
	// Bit mask of SMPSEL1 field.
	ADC_SMPR_SMPSEL1_Msk = 0x200
	// Bit SMPSEL1.
	ADC_SMPR_SMPSEL1 = 0x200
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL1_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL1_Smp2 = 0x1
	// Position of SMPSEL2 field.
	ADC_SMPR_SMPSEL2_Pos = 0xa
	// Bit mask of SMPSEL2 field.
	ADC_SMPR_SMPSEL2_Msk = 0x400
	// Bit SMPSEL2.
	ADC_SMPR_SMPSEL2 = 0x400
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL2_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL2_Smp2 = 0x1
	// Position of SMPSEL3 field.
	ADC_SMPR_SMPSEL3_Pos = 0xb
	// Bit mask of SMPSEL3 field.
	ADC_SMPR_SMPSEL3_Msk = 0x800
	// Bit SMPSEL3.
	ADC_SMPR_SMPSEL3 = 0x800
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL3_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL3_Smp2 = 0x1
	// Position of SMPSEL4 field.
	ADC_SMPR_SMPSEL4_Pos = 0xc
	// Bit mask of SMPSEL4 field.
	ADC_SMPR_SMPSEL4_Msk = 0x1000
	// Bit SMPSEL4.
	ADC_SMPR_SMPSEL4 = 0x1000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL4_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL4_Smp2 = 0x1
	// Position of SMPSEL5 field.
	ADC_SMPR_SMPSEL5_Pos = 0xd
	// Bit mask of SMPSEL5 field.
	ADC_SMPR_SMPSEL5_Msk = 0x2000
	// Bit SMPSEL5.
	ADC_SMPR_SMPSEL5 = 0x2000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL5_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL5_Smp2 = 0x1
	// Position of SMPSEL6 field.
	ADC_SMPR_SMPSEL6_Pos = 0xe
	// Bit mask of SMPSEL6 field.
	ADC_SMPR_SMPSEL6_Msk = 0x4000
	// Bit SMPSEL6.
	ADC_SMPR_SMPSEL6 = 0x4000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL6_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL6_Smp2 = 0x1
	// Position of SMPSEL7 field.
	ADC_SMPR_SMPSEL7_Pos = 0xf
	// Bit mask of SMPSEL7 field.
	ADC_SMPR_SMPSEL7_Msk = 0x8000
	// Bit SMPSEL7.
	ADC_SMPR_SMPSEL7 = 0x8000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL7_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL7_Smp2 = 0x1
	// Position of SMPSEL8 field.
	ADC_SMPR_SMPSEL8_Pos = 0x10
	// Bit mask of SMPSEL8 field.
	ADC_SMPR_SMPSEL8_Msk = 0x10000
	// Bit SMPSEL8.
	ADC_SMPR_SMPSEL8 = 0x10000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL8_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL8_Smp2 = 0x1
	// Position of SMPSEL9 field.
	ADC_SMPR_SMPSEL9_Pos = 0x11
	// Bit mask of SMPSEL9 field.
	ADC_SMPR_SMPSEL9_Msk = 0x20000
	// Bit SMPSEL9.
	ADC_SMPR_SMPSEL9 = 0x20000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL9_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL9_Smp2 = 0x1
	// Position of SMPSEL10 field.
	ADC_SMPR_SMPSEL10_Pos = 0x12
	// Bit mask of SMPSEL10 field.
	ADC_SMPR_SMPSEL10_Msk = 0x40000
	// Bit SMPSEL10.
	ADC_SMPR_SMPSEL10 = 0x40000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL10_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL10_Smp2 = 0x1
	// Position of SMPSEL11 field.
	ADC_SMPR_SMPSEL11_Pos = 0x13
	// Bit mask of SMPSEL11 field.
	ADC_SMPR_SMPSEL11_Msk = 0x80000
	// Bit SMPSEL11.
	ADC_SMPR_SMPSEL11 = 0x80000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL11_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL11_Smp2 = 0x1
	// Position of SMPSEL12 field.
	ADC_SMPR_SMPSEL12_Pos = 0x14
	// Bit mask of SMPSEL12 field.
	ADC_SMPR_SMPSEL12_Msk = 0x100000
	// Bit SMPSEL12.
	ADC_SMPR_SMPSEL12 = 0x100000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL12_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL12_Smp2 = 0x1
	// Position of SMPSEL13 field.
	ADC_SMPR_SMPSEL13_Pos = 0x15
	// Bit mask of SMPSEL13 field.
	ADC_SMPR_SMPSEL13_Msk = 0x200000
	// Bit SMPSEL13.
	ADC_SMPR_SMPSEL13 = 0x200000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL13_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL13_Smp2 = 0x1
	// Position of SMPSEL14 field.
	ADC_SMPR_SMPSEL14_Pos = 0x16
	// Bit mask of SMPSEL14 field.
	ADC_SMPR_SMPSEL14_Msk = 0x400000
	// Bit SMPSEL14.
	ADC_SMPR_SMPSEL14 = 0x400000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL14_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL14_Smp2 = 0x1
	// Position of SMPSEL15 field.
	ADC_SMPR_SMPSEL15_Pos = 0x17
	// Bit mask of SMPSEL15 field.
	ADC_SMPR_SMPSEL15_Msk = 0x800000
	// Bit SMPSEL15.
	ADC_SMPR_SMPSEL15 = 0x800000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL15_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL15_Smp2 = 0x1
	// Position of SMPSEL16 field.
	ADC_SMPR_SMPSEL16_Pos = 0x18
	// Bit mask of SMPSEL16 field.
	ADC_SMPR_SMPSEL16_Msk = 0x1000000
	// Bit SMPSEL16.
	ADC_SMPR_SMPSEL16 = 0x1000000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL16_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL16_Smp2 = 0x1
	// Position of SMPSEL17 field.
	ADC_SMPR_SMPSEL17_Pos = 0x19
	// Bit mask of SMPSEL17 field.
	ADC_SMPR_SMPSEL17_Msk = 0x2000000
	// Bit SMPSEL17.
	ADC_SMPR_SMPSEL17 = 0x2000000
	// Sampling time of CHANNELx use the setting of SMP1 register
	ADC_SMPR_SMPSEL17_Smp1 = 0x0
	// Sampling time of CHANNELx use the setting of SMP2 register
	ADC_SMPR_SMPSEL17_Smp2 = 0x1

	// AWD1TR: ADC watchdog threshold register
	// Position of LT1 field.
	ADC_AWD1TR_LT1_Pos = 0x0
	// Bit mask of LT1 field.
	ADC_AWD1TR_LT1_Msk = 0xfff
	// Position of HT1 field.
	ADC_AWD1TR_HT1_Pos = 0x10
	// Bit mask of HT1 field.
	ADC_AWD1TR_HT1_Msk = 0xfff0000

	// AWD2TR: ADC watchdog threshold register
	// Position of LT2 field.
	ADC_AWD2TR_LT2_Pos = 0x0
	// Bit mask of LT2 field.
	ADC_AWD2TR_LT2_Msk = 0xfff
	// Position of HT2 field.
	ADC_AWD2TR_HT2_Pos = 0x10
	// Bit mask of HT2 field.
	ADC_AWD2TR_HT2_Msk = 0xfff0000

	// CHSELR0: channel selection register
	// Position of CHSEL field.
	ADC_CHSELR0_CHSEL_Pos = 0x0
	// Bit mask of CHSEL field.
	ADC_CHSELR0_CHSEL_Msk = 0x3ffff
	// Input Channel is not selected for conversion
	ADC_CHSELR0_CHSEL_NotSelected = 0x0
	// Input Channel is selected for conversion
	ADC_CHSELR0_CHSEL_Selected = 0x1

	// CHSELR1: channel selection register
	// Position of SQ1 field.
	ADC_CHSELR1_SQ1_Pos = 0x0
	// Bit mask of SQ1 field.
	ADC_CHSELR1_SQ1_Msk = 0xf
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ1_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ1_EOS = 0xf
	// Position of SQ2 field.
	ADC_CHSELR1_SQ2_Pos = 0x4
	// Bit mask of SQ2 field.
	ADC_CHSELR1_SQ2_Msk = 0xf0
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ2_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ2_EOS = 0xf
	// Position of SQ3 field.
	ADC_CHSELR1_SQ3_Pos = 0x8
	// Bit mask of SQ3 field.
	ADC_CHSELR1_SQ3_Msk = 0xf00
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ3_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ3_EOS = 0xf
	// Position of SQ4 field.
	ADC_CHSELR1_SQ4_Pos = 0xc
	// Bit mask of SQ4 field.
	ADC_CHSELR1_SQ4_Msk = 0xf000
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ4_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ4_EOS = 0xf
	// Position of SQ5 field.
	ADC_CHSELR1_SQ5_Pos = 0x10
	// Bit mask of SQ5 field.
	ADC_CHSELR1_SQ5_Msk = 0xf0000
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ5_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ5_EOS = 0xf
	// Position of SQ6 field.
	ADC_CHSELR1_SQ6_Pos = 0x14
	// Bit mask of SQ6 field.
	ADC_CHSELR1_SQ6_Msk = 0xf00000
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ6_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ6_EOS = 0xf
	// Position of SQ7 field.
	ADC_CHSELR1_SQ7_Pos = 0x18
	// Bit mask of SQ7 field.
	ADC_CHSELR1_SQ7_Msk = 0xf000000
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ7_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ7_EOS = 0xf
	// Position of SQ8 field.
	ADC_CHSELR1_SQ8_Pos = 0x1c
	// Bit mask of SQ8 field.
	ADC_CHSELR1_SQ8_Msk = 0xf0000000
	// Channel 0 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch0 = 0x0
	// Channel 1 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch1 = 0x1
	// Channel 2 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch2 = 0x2
	// Channel 3 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch3 = 0x3
	// Channel 4 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch4 = 0x4
	// Channel 5 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch5 = 0x5
	// Channel 6 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch6 = 0x6
	// Channel 7 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch7 = 0x7
	// Channel 8 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch8 = 0x8
	// Channel 9 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch9 = 0x9
	// Channel 10 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch10 = 0xa
	// Channel 11 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch11 = 0xb
	// Channel 12 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch12 = 0xc
	// Channel 13 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch13 = 0xd
	// Channel 14 selected for the Nth conversion
	ADC_CHSELR1_SQ8_Ch14 = 0xe
	// End of sequence
	ADC_CHSELR1_SQ8_EOS = 0xf

	// AWD3TR: ADC watchdog threshold register
	// Position of LT3 field.
	ADC_AWD3TR_LT3_Pos = 0x0
	// Bit mask of LT3 field.
	ADC_AWD3TR_LT3_Msk = 0xfff
	// Position of HT3 field.
	ADC_AWD3TR_HT3_Pos = 0x10
	// Bit mask of HT3 field.
	ADC_AWD3TR_HT3_Msk = 0xfff0000

	// DR: ADC data register
	// Position of DATA field.
	ADC_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC_DR_DATA_Msk = 0xffff

	// AWD2CR: ADC Analog Watchdog 2 Configuration register
	// Position of AWD2CH field.
	ADC_AWD2CR_AWD2CH_Pos = 0x0
	// Bit mask of AWD2CH field.
	ADC_AWD2CR_AWD2CH_Msk = 0x3ffff

	// AWD3CR: ADC Analog Watchdog 3 Configuration register
	// Position of AWD3CH field.
	ADC_AWD3CR_AWD3CH_Pos = 0x0
	// Bit mask of AWD3CH field.
	ADC_AWD3CR_AWD3CH_Msk = 0x3ffff

	// CALFACT: ADC Calibration factor
	// Position of CALFACT field.
	ADC_CALFACT_CALFACT_Pos = 0x0
	// Bit mask of CALFACT field.
	ADC_CALFACT_CALFACT_Msk = 0x7f

	// CCR: ADC common configuration register
	// Position of VREFEN field.
	ADC_CCR_VREFEN_Pos = 0x16
	// Bit mask of VREFEN field.
	ADC_CCR_VREFEN_Msk = 0x400000
	// Bit VREFEN.
	ADC_CCR_VREFEN = 0x400000
	// VREFINT disabled
	ADC_CCR_VREFEN_Disabled = 0x0
	// VREFINT enabled
	ADC_CCR_VREFEN_Enabled = 0x1
	// Position of TSEN field.
	ADC_CCR_TSEN_Pos = 0x17
	// Bit mask of TSEN field.
	ADC_CCR_TSEN_Msk = 0x800000
	// Bit TSEN.
	ADC_CCR_TSEN = 0x800000
	// Temperature sensor disabled
	ADC_CCR_TSEN_Disabled = 0x0
	// Temperature sensor enabled
	ADC_CCR_TSEN_Enabled = 0x1
	// Position of VBATEN field.
	ADC_CCR_VBATEN_Pos = 0x18
	// Bit mask of VBATEN field.
	ADC_CCR_VBATEN_Msk = 0x1000000
	// Bit VBATEN.
	ADC_CCR_VBATEN = 0x1000000
	// VBAT channel disabled
	ADC_CCR_VBATEN_Disabled = 0x0
	// VBAT channel enabled
	ADC_CCR_VBATEN_Enabled = 0x1
	// Position of PRESC field.
	ADC_CCR_PRESC_Pos = 0x12
	// Bit mask of PRESC field.
	ADC_CCR_PRESC_Msk = 0x3c0000
	// Input ADC clock not divided
	ADC_CCR_PRESC_Div1 = 0x0
	// Input ADC clock divided by 2
	ADC_CCR_PRESC_Div2 = 0x1
	// Input ADC clock divided by 4
	ADC_CCR_PRESC_Div4 = 0x2
	// Input ADC clock divided by 6
	ADC_CCR_PRESC_Div6 = 0x3
	// Input ADC clock divided by 8
	ADC_CCR_PRESC_Div8 = 0x4
	// Input ADC clock divided by 10
	ADC_CCR_PRESC_Div10 = 0x5
	// Input ADC clock divided by 12
	ADC_CCR_PRESC_Div12 = 0x6
	// Input ADC clock divided by 16
	ADC_CCR_PRESC_Div16 = 0x7
	// Input ADC clock divided by 32
	ADC_CCR_PRESC_Div32 = 0x8
	// Input ADC clock divided by 64
	ADC_CCR_PRESC_Div64 = 0x9
	// Input ADC clock divided by 128
	ADC_CCR_PRESC_Div128 = 0xa
	// Input ADC clock divided by 256
	ADC_CCR_PRESC_Div256 = 0xb
)

// Constants for AES: Advanced encryption standard hardware accelerator 1
const (
	// CR: control register
	// Position of NPBLB field.
	AES_CR_NPBLB_Pos = 0x14
	// Bit mask of NPBLB field.
	AES_CR_NPBLB_Msk = 0xf00000
	// Position of KEYSIZE field.
	AES_CR_KEYSIZE_Pos = 0x12
	// Bit mask of KEYSIZE field.
	AES_CR_KEYSIZE_Msk = 0x40000
	// Bit KEYSIZE.
	AES_CR_KEYSIZE = 0x40000
	// 128 bits
	AES_CR_KEYSIZE_Bits128 = 0x0
	// 256 bits
	AES_CR_KEYSIZE_Bits256 = 0x1
	// Position of CHMOD2 field.
	AES_CR_CHMOD2_Pos = 0x10
	// Bit mask of CHMOD2 field.
	AES_CR_CHMOD2_Msk = 0x10000
	// Bit CHMOD2.
	AES_CR_CHMOD2 = 0x10000
	// Mode as per CHMOD (ECB, CBC, CTR, GCM)
	AES_CR_CHMOD2_CHMOD = 0x0
	// Counter with CBC-MAC (CCM) - CHMOD must be 0 (ECB)
	AES_CR_CHMOD2_CCM = 0x1
	// Position of GCMPH field.
	AES_CR_GCMPH_Pos = 0xd
	// Bit mask of GCMPH field.
	AES_CR_GCMPH_Msk = 0x6000
	// Init phase
	AES_CR_GCMPH_Init = 0x0
	// Header phase
	AES_CR_GCMPH_Header = 0x1
	// Payload phase
	AES_CR_GCMPH_Payload = 0x2
	// Final phase
	AES_CR_GCMPH_Final = 0x3
	// Position of DMAOUTEN field.
	AES_CR_DMAOUTEN_Pos = 0xc
	// Bit mask of DMAOUTEN field.
	AES_CR_DMAOUTEN_Msk = 0x1000
	// Bit DMAOUTEN.
	AES_CR_DMAOUTEN = 0x1000
	// Disable DMA Output
	AES_CR_DMAOUTEN_Disabled = 0x0
	// Enabled DMA Output
	AES_CR_DMAOUTEN_Enabled = 0x1
	// Position of DMAINEN field.
	AES_CR_DMAINEN_Pos = 0xb
	// Bit mask of DMAINEN field.
	AES_CR_DMAINEN_Msk = 0x800
	// Bit DMAINEN.
	AES_CR_DMAINEN = 0x800
	// Disable DMA Input
	AES_CR_DMAINEN_Disabled = 0x0
	// Enable DMA Input
	AES_CR_DMAINEN_Enabled = 0x1
	// Position of ERRIE field.
	AES_CR_ERRIE_Pos = 0xa
	// Bit mask of ERRIE field.
	AES_CR_ERRIE_Msk = 0x400
	// Bit ERRIE.
	AES_CR_ERRIE = 0x400
	// Disable (mask) error interrupt
	AES_CR_ERRIE_Disabled = 0x0
	// Enable error interrupt
	AES_CR_ERRIE_Enabled = 0x1
	// Position of CCFIE field.
	AES_CR_CCFIE_Pos = 0x9
	// Bit mask of CCFIE field.
	AES_CR_CCFIE_Msk = 0x200
	// Bit CCFIE.
	AES_CR_CCFIE = 0x200
	// Disable (mask) CCF interrupt
	AES_CR_CCFIE_Disabled = 0x0
	// Enable CCF interrupt
	AES_CR_CCFIE_Enabled = 0x1
	// Position of ERRC field.
	AES_CR_ERRC_Pos = 0x8
	// Bit mask of ERRC field.
	AES_CR_ERRC_Msk = 0x100
	// Bit ERRC.
	AES_CR_ERRC = 0x100
	// Clear RDERR and WRERR flags
	AES_CR_ERRC_Clear = 0x1
	// Position of CCFC field.
	AES_CR_CCFC_Pos = 0x7
	// Bit mask of CCFC field.
	AES_CR_CCFC_Msk = 0x80
	// Bit CCFC.
	AES_CR_CCFC = 0x80
	// Clear computation complete flag
	AES_CR_CCFC_Clear = 0x1
	// Position of CHMOD field.
	AES_CR_CHMOD_Pos = 0x5
	// Bit mask of CHMOD field.
	AES_CR_CHMOD_Msk = 0x60
	// Electronic codebook (ECB) / Counter with CBC-MAC (CCM) if CHMOD2 is 1
	AES_CR_CHMOD_ECB = 0x0
	// Cipher-block chaining (CBC)
	AES_CR_CHMOD_CBC = 0x1
	// Counter mode (CTR)
	AES_CR_CHMOD_CTR = 0x2
	// Galois counter mode (GCM) and Galois message authentication code (GMAC)
	AES_CR_CHMOD_GCM = 0x3
	// Position of MODE field.
	AES_CR_MODE_Pos = 0x3
	// Bit mask of MODE field.
	AES_CR_MODE_Msk = 0x18
	// Mode 1: encryption
	AES_CR_MODE_Mode1 = 0x0
	// Mode 2: key derivation (or key preparation for ECB/CBC decryption)
	AES_CR_MODE_Mode2 = 0x1
	// Mode 3: decryption
	AES_CR_MODE_Mode3 = 0x2
	// Mode 4: key derivation & decrypt (UNDOCUMENTED in ref. manual, exists in CubeMX code)
	AES_CR_MODE_Mode4 = 0x3
	// Position of DATATYPE field.
	AES_CR_DATATYPE_Pos = 0x1
	// Bit mask of DATATYPE field.
	AES_CR_DATATYPE_Msk = 0x6
	// Word
	AES_CR_DATATYPE_None = 0x0
	// Half-word (16-bit)
	AES_CR_DATATYPE_HalfWord = 0x1
	// Byte (8-bit)
	AES_CR_DATATYPE_Byte = 0x2
	// Bit
	AES_CR_DATATYPE_Bit = 0x3
	// Position of EN field.
	AES_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	AES_CR_EN_Msk = 0x1
	// Bit EN.
	AES_CR_EN = 0x1
	// Disable AES
	AES_CR_EN_Disabled = 0x0
	// Enable AES
	AES_CR_EN_Enabled = 0x1

	// SR: status register
	// Position of BUSY field.
	AES_SR_BUSY_Pos = 0x3
	// Bit mask of BUSY field.
	AES_SR_BUSY_Msk = 0x8
	// Bit BUSY.
	AES_SR_BUSY = 0x8
	// Idle
	AES_SR_BUSY_Idle = 0x0
	// Busy
	AES_SR_BUSY_Busy = 0x1
	// Position of WRERR field.
	AES_SR_WRERR_Pos = 0x2
	// Bit mask of WRERR field.
	AES_SR_WRERR_Msk = 0x4
	// Bit WRERR.
	AES_SR_WRERR = 0x4
	// Write error not detected
	AES_SR_WRERR_NoError = 0x0
	// Write error detected
	AES_SR_WRERR_Error = 0x1
	// Position of RDERR field.
	AES_SR_RDERR_Pos = 0x1
	// Bit mask of RDERR field.
	AES_SR_RDERR_Msk = 0x2
	// Bit RDERR.
	AES_SR_RDERR = 0x2
	// Read error not detected
	AES_SR_RDERR_NoError = 0x0
	// Read error detected
	AES_SR_RDERR_Error = 0x1
	// Position of CCF field.
	AES_SR_CCF_Pos = 0x0
	// Bit mask of CCF field.
	AES_SR_CCF_Msk = 0x1
	// Bit CCF.
	AES_SR_CCF = 0x1
	// Computation complete
	AES_SR_CCF_Complete = 0x0
	// Computation not complete
	AES_SR_CCF_NotComplete = 0x1

	// DINR: data input register
	// Position of DIN field.
	AES_DINR_DIN_Pos = 0x0
	// Bit mask of DIN field.
	AES_DINR_DIN_Msk = 0xffffffff

	// DOUTR: data output register
	// Position of DOUT field.
	AES_DOUTR_DOUT_Pos = 0x0
	// Bit mask of DOUT field.
	AES_DOUTR_DOUT_Msk = 0xffffffff

	// KEYR0: key register 0
	// Position of KEY field.
	AES_KEYR0_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR0_KEY_Msk = 0xffffffff

	// KEYR1: key register 1
	// Position of KEY field.
	AES_KEYR1_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR1_KEY_Msk = 0xffffffff

	// KEYR2: key register 2
	// Position of KEY field.
	AES_KEYR2_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR2_KEY_Msk = 0xffffffff

	// KEYR3: key register 3
	// Position of KEY field.
	AES_KEYR3_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR3_KEY_Msk = 0xffffffff

	// IVR0: initialization vector register 0
	// Position of IVI field.
	AES_IVR0_IVI_Pos = 0x0
	// Bit mask of IVI field.
	AES_IVR0_IVI_Msk = 0xffffffff

	// IVR1: initialization vector register 1
	// Position of IVI field.
	AES_IVR1_IVI_Pos = 0x0
	// Bit mask of IVI field.
	AES_IVR1_IVI_Msk = 0xffffffff

	// IVR2: initialization vector register 2
	// Position of IVI field.
	AES_IVR2_IVI_Pos = 0x0
	// Bit mask of IVI field.
	AES_IVR2_IVI_Msk = 0xffffffff

	// IVR3: initialization vector register 3
	// Position of IVI field.
	AES_IVR3_IVI_Pos = 0x0
	// Bit mask of IVI field.
	AES_IVR3_IVI_Msk = 0xffffffff

	// KEYR4: key register 4
	// Position of KEY field.
	AES_KEYR4_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR4_KEY_Msk = 0xffffffff

	// KEYR5: key register 5
	// Position of KEY field.
	AES_KEYR5_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR5_KEY_Msk = 0xffffffff

	// KEYR6: key register 6
	// Position of KEY field.
	AES_KEYR6_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR6_KEY_Msk = 0xffffffff

	// KEYR7: key register 7
	// Position of KEY field.
	AES_KEYR7_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEYR7_KEY_Msk = 0xffffffff

	// SUSP0R: AES suspend register 0
	// Position of SUSP field.
	AES_SUSP0R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP0R_SUSP_Msk = 0xffffffff

	// SUSP1R: AES suspend register 1
	// Position of SUSP field.
	AES_SUSP1R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP1R_SUSP_Msk = 0xffffffff

	// SUSP2R: AES suspend register 2
	// Position of SUSP field.
	AES_SUSP2R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP2R_SUSP_Msk = 0xffffffff

	// SUSP3R: AES suspend register 3
	// Position of SUSP field.
	AES_SUSP3R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP3R_SUSP_Msk = 0xffffffff

	// SUSP4R: AES suspend register 4
	// Position of SUSP field.
	AES_SUSP4R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP4R_SUSP_Msk = 0xffffffff

	// SUSP5R: AES suspend register 5
	// Position of SUSP field.
	AES_SUSP5R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP5R_SUSP_Msk = 0xffffffff

	// SUSP6R: AES suspend register 6
	// Position of SUSP field.
	AES_SUSP6R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP6R_SUSP_Msk = 0xffffffff

	// SUSP7R: AES suspend register 7
	// Position of SUSP field.
	AES_SUSP7R_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	AES_SUSP7R_SUSP_Msk = 0xffffffff
)

// Constants for COMP: Comparator
const (
	// COMP1_CSR: COMP1_CSR
	// Position of LOCK field.
	COMP_COMP1_CSR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	COMP_COMP1_CSR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	COMP_COMP1_CSR_LOCK = 0x80000000
	// Comparator CSR bits are read-write
	COMP_COMP1_CSR_LOCK_Unlocked = 0x0
	// Comparator CSR bits are read-only
	COMP_COMP1_CSR_LOCK_Locked = 0x1
	// Position of VALUE field.
	COMP_COMP1_CSR_VALUE_Pos = 0x1e
	// Bit mask of VALUE field.
	COMP_COMP1_CSR_VALUE_Msk = 0x40000000
	// Bit VALUE.
	COMP_COMP1_CSR_VALUE = 0x40000000
	// Comparator output is low
	COMP_COMP1_CSR_VALUE_Low = 0x0
	// Comparator output is high
	COMP_COMP1_CSR_VALUE_High = 0x1
	// Position of INMESEL field.
	COMP_COMP1_CSR_INMESEL_Pos = 0x19
	// Bit mask of INMESEL field.
	COMP_COMP1_CSR_INMESEL_Msk = 0x6000000
	// PA10 connected to input minus
	COMP_COMP1_CSR_INMESEL_PA10 = 0x0
	// PA11 connected to input minus
	COMP_COMP1_CSR_INMESEL_PA11 = 0x1
	// PA15 connected to input minus
	COMP_COMP1_CSR_INMESEL_PA15 = 0x2
	// Position of SCALEN field.
	COMP_COMP1_CSR_SCALEN_Pos = 0x17
	// Bit mask of SCALEN field.
	COMP_COMP1_CSR_SCALEN_Msk = 0x800000
	// Bit SCALEN.
	COMP_COMP1_CSR_SCALEN = 0x800000
	// Voltage scaler disabled
	COMP_COMP1_CSR_SCALEN_Disabled = 0x0
	// Voltage scaler enabled
	COMP_COMP1_CSR_SCALEN_Enabled = 0x1
	// Position of BRGEN field.
	COMP_COMP1_CSR_BRGEN_Pos = 0x16
	// Bit mask of BRGEN field.
	COMP_COMP1_CSR_BRGEN_Msk = 0x400000
	// Bit BRGEN.
	COMP_COMP1_CSR_BRGEN = 0x400000
	// Scaler resistor bridge disabled
	COMP_COMP1_CSR_BRGEN_Disabled = 0x0
	// Scaler resistor bridge enabled
	COMP_COMP1_CSR_BRGEN_Enabled = 0x1
	// Position of BLANKING field.
	COMP_COMP1_CSR_BLANKING_Pos = 0x12
	// Bit mask of BLANKING field.
	COMP_COMP1_CSR_BLANKING_Msk = 0x1c0000
	// No blanking
	COMP_COMP1_CSR_BLANKING_NoBlanking = 0x0
	// TIM1 OC5 selected as blanking source
	COMP_COMP1_CSR_BLANKING_TIM1OC5 = 0x1
	// TIM2 OC3 selected as blanking source
	COMP_COMP1_CSR_BLANKING_TIM2OC3 = 0x2
	// Position of HYST field.
	COMP_COMP1_CSR_HYST_Pos = 0x10
	// Bit mask of HYST field.
	COMP_COMP1_CSR_HYST_Msk = 0x30000
	// No hysteresis
	COMP_COMP1_CSR_HYST_NoHysteresis = 0x0
	// Low hysteresis
	COMP_COMP1_CSR_HYST_LowHysteresis = 0x1
	// Medium hysteresis
	COMP_COMP1_CSR_HYST_MediumHysteresis = 0x2
	// High hysteresis
	COMP_COMP1_CSR_HYST_HighHysteresis = 0x3
	// Position of POLARITY field.
	COMP_COMP1_CSR_POLARITY_Pos = 0xf
	// Bit mask of POLARITY field.
	COMP_COMP1_CSR_POLARITY_Msk = 0x8000
	// Bit POLARITY.
	COMP_COMP1_CSR_POLARITY = 0x8000
	// Output is not inverted
	COMP_COMP1_CSR_POLARITY_NotInverted = 0x0
	// Output is inverted
	COMP_COMP1_CSR_POLARITY_Inverted = 0x1
	// Position of INPSEL field.
	COMP_COMP1_CSR_INPSEL_Pos = 0x7
	// Bit mask of INPSEL field.
	COMP_COMP1_CSR_INPSEL_Msk = 0x180
	// PB4 connected to input plus
	COMP_COMP1_CSR_INPSEL_PB4 = 0x0
	// PB2 connected to input plus
	COMP_COMP1_CSR_INPSEL_PB2 = 0x1
	// Position of INMSEL field.
	COMP_COMP1_CSR_INMSEL_Pos = 0x4
	// Bit mask of INMSEL field.
	COMP_COMP1_CSR_INMSEL_Msk = 0x70
	// 1/4 of VRefint
	COMP_COMP1_CSR_INMSEL_OneQuarterVRef = 0x0
	// 1/2 of VRefint
	COMP_COMP1_CSR_INMSEL_OneHalfVRef = 0x1
	// 3/4 of VRefint
	COMP_COMP1_CSR_INMSEL_ThreeQuarterVRef = 0x2
	// VRefint
	COMP_COMP1_CSR_INMSEL_VRef = 0x3
	// DAC Channel 1
	COMP_COMP1_CSR_INMSEL_DAC_CH1 = 0x4
	// PB3
	COMP_COMP1_CSR_INMSEL_PB3 = 0x6
	// GPIO pin selected by INMESEL
	COMP_COMP1_CSR_INMSEL_GPIO = 0x7
	// Position of PWRMODE field.
	COMP_COMP1_CSR_PWRMODE_Pos = 0x2
	// Bit mask of PWRMODE field.
	COMP_COMP1_CSR_PWRMODE_Msk = 0xc
	// High speed / full power
	COMP_COMP1_CSR_PWRMODE_HighSpeed = 0x0
	// Medium speed / medium power
	COMP_COMP1_CSR_PWRMODE_MediumSpeed = 0x1
	// Low speed / low power
	COMP_COMP1_CSR_PWRMODE_LowSpeed = 0x2
	// Very-low speed / ultra-low power
	COMP_COMP1_CSR_PWRMODE_VeryLowSpeed = 0x3
	// Position of EN field.
	COMP_COMP1_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	COMP_COMP1_CSR_EN_Msk = 0x1
	// Bit EN.
	COMP_COMP1_CSR_EN = 0x1
	// Comparator 1 disabled
	COMP_COMP1_CSR_EN_Disabled = 0x0
	// Comparator 1 enabled
	COMP_COMP1_CSR_EN_Enabled = 0x1

	// COMP2_CSR: COMP2_CSR
	// Position of LOCK field.
	COMP_COMP2_CSR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	COMP_COMP2_CSR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	COMP_COMP2_CSR_LOCK = 0x80000000
	// Comparator CSR bits are read-write
	COMP_COMP2_CSR_LOCK_Unlocked = 0x0
	// Comparator CSR bits are read-only
	COMP_COMP2_CSR_LOCK_Locked = 0x1
	// Position of VALUE field.
	COMP_COMP2_CSR_VALUE_Pos = 0x1e
	// Bit mask of VALUE field.
	COMP_COMP2_CSR_VALUE_Msk = 0x40000000
	// Bit VALUE.
	COMP_COMP2_CSR_VALUE = 0x40000000
	// Comparator output is low
	COMP_COMP2_CSR_VALUE_Low = 0x0
	// Comparator output is high
	COMP_COMP2_CSR_VALUE_High = 0x1
	// Position of INMESEL field.
	COMP_COMP2_CSR_INMESEL_Pos = 0x19
	// Bit mask of INMESEL field.
	COMP_COMP2_CSR_INMESEL_Msk = 0x6000000
	// PB2 connected to input minus
	COMP_COMP2_CSR_INMESEL_PB2 = 0x0
	// PA10 connected to input minus
	COMP_COMP2_CSR_INMESEL_PA10 = 0x1
	// PA11 connected to input minus
	COMP_COMP2_CSR_INMESEL_PA11 = 0x2
	// Position of SCALEN field.
	COMP_COMP2_CSR_SCALEN_Pos = 0x17
	// Bit mask of SCALEN field.
	COMP_COMP2_CSR_SCALEN_Msk = 0x800000
	// Bit SCALEN.
	COMP_COMP2_CSR_SCALEN = 0x800000
	// Voltage scaler disabled
	COMP_COMP2_CSR_SCALEN_Disabled = 0x0
	// Voltage scaler enabled
	COMP_COMP2_CSR_SCALEN_Enabled = 0x1
	// Position of BRGEN field.
	COMP_COMP2_CSR_BRGEN_Pos = 0x16
	// Bit mask of BRGEN field.
	COMP_COMP2_CSR_BRGEN_Msk = 0x400000
	// Bit BRGEN.
	COMP_COMP2_CSR_BRGEN = 0x400000
	// Scaler resistor bridge disabled
	COMP_COMP2_CSR_BRGEN_Disabled = 0x0
	// Scaler resistor bridge enabled
	COMP_COMP2_CSR_BRGEN_Enabled = 0x1
	// Position of BLANKING field.
	COMP_COMP2_CSR_BLANKING_Pos = 0x12
	// Bit mask of BLANKING field.
	COMP_COMP2_CSR_BLANKING_Msk = 0x1c0000
	// No blanking
	COMP_COMP2_CSR_BLANKING_NoBlanking = 0x0
	// TIM1 OC5 selected as blanking source
	COMP_COMP2_CSR_BLANKING_TIM1OC5 = 0x1
	// TIM2 OC3 selected as blanking source
	COMP_COMP2_CSR_BLANKING_TIM2OC3 = 0x2
	// Position of HYST field.
	COMP_COMP2_CSR_HYST_Pos = 0x10
	// Bit mask of HYST field.
	COMP_COMP2_CSR_HYST_Msk = 0x30000
	// No hysteresis
	COMP_COMP2_CSR_HYST_NoHysteresis = 0x0
	// Low hysteresis
	COMP_COMP2_CSR_HYST_LowHysteresis = 0x1
	// Medium hysteresis
	COMP_COMP2_CSR_HYST_MediumHysteresis = 0x2
	// High hysteresis
	COMP_COMP2_CSR_HYST_HighHysteresis = 0x3
	// Position of POLARITY field.
	COMP_COMP2_CSR_POLARITY_Pos = 0xf
	// Bit mask of POLARITY field.
	COMP_COMP2_CSR_POLARITY_Msk = 0x8000
	// Bit POLARITY.
	COMP_COMP2_CSR_POLARITY = 0x8000
	// Output is not inverted
	COMP_COMP2_CSR_POLARITY_NotInverted = 0x0
	// Output is inverted
	COMP_COMP2_CSR_POLARITY_Inverted = 0x1
	// Position of WINMODE field.
	COMP_COMP2_CSR_WINMODE_Pos = 0x9
	// Bit mask of WINMODE field.
	COMP_COMP2_CSR_WINMODE_Msk = 0x200
	// Bit WINMODE.
	COMP_COMP2_CSR_WINMODE = 0x200
	// COMP2 input plus is not connected to COMP1
	COMP_COMP2_CSR_WINMODE_Disabled = 0x0
	// COMP2 input plus is connected to COMP1
	COMP_COMP2_CSR_WINMODE_Enabled = 0x1
	// Position of INPSEL field.
	COMP_COMP2_CSR_INPSEL_Pos = 0x7
	// Bit mask of INPSEL field.
	COMP_COMP2_CSR_INPSEL_Msk = 0x180
	// PB4 connected to input plus
	COMP_COMP2_CSR_INPSEL_PB4 = 0x0
	// PB1 connected to input plus
	COMP_COMP2_CSR_INPSEL_PB1 = 0x1
	// PA15 connected to input plus
	COMP_COMP2_CSR_INPSEL_PA15 = 0x2
	// Position of INMSEL field.
	COMP_COMP2_CSR_INMSEL_Pos = 0x4
	// Bit mask of INMSEL field.
	COMP_COMP2_CSR_INMSEL_Msk = 0x70
	// 1/4 of VRefint
	COMP_COMP2_CSR_INMSEL_OneQuarterVRef = 0x0
	// 1/2 of VRefint
	COMP_COMP2_CSR_INMSEL_OneHalfVRef = 0x1
	// 3/4 of VRefint
	COMP_COMP2_CSR_INMSEL_ThreeQuarterVRef = 0x2
	// VRefint
	COMP_COMP2_CSR_INMSEL_VRef = 0x3
	// DAC Channel 1
	COMP_COMP2_CSR_INMSEL_DAC_CH1 = 0x4
	// PB3
	COMP_COMP2_CSR_INMSEL_PB3 = 0x6
	// GPIO pin selected by INMESEL
	COMP_COMP2_CSR_INMSEL_GPIO = 0x7
	// Position of PWRMODE field.
	COMP_COMP2_CSR_PWRMODE_Pos = 0x2
	// Bit mask of PWRMODE field.
	COMP_COMP2_CSR_PWRMODE_Msk = 0xc
	// High speed / full power
	COMP_COMP2_CSR_PWRMODE_HighSpeed = 0x0
	// Medium speed / medium power
	COMP_COMP2_CSR_PWRMODE_MediumSpeed = 0x1
	// Low speed / low power
	COMP_COMP2_CSR_PWRMODE_LowSpeed = 0x2
	// Very-low speed / ultra-low power
	COMP_COMP2_CSR_PWRMODE_VeryLowSpeed = 0x3
	// Position of EN field.
	COMP_COMP2_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	COMP_COMP2_CSR_EN_Msk = 0x1
	// Bit EN.
	COMP_COMP2_CSR_EN = 0x1
	// Comparator 1 disabled
	COMP_COMP2_CSR_EN_Disabled = 0x0
	// Comparator 1 enabled
	COMP_COMP2_CSR_EN_Enabled = 0x1
)

// Constants for CRC: Cyclic redundancy check calculation unit
const (
	// DR: Data register
	// Position of DR field.
	CRC_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	CRC_DR_DR_Msk = 0xffffffff

	// DR8: Data register - byte sized
	// Position of DR8 field.
	CRC_DR8_DR8_Pos = 0x0
	// Bit mask of DR8 field.
	CRC_DR8_DR8_Msk = 0xff

	// DR16: Data register - half-word sized
	// Position of DR16 field.
	CRC_DR16_DR16_Pos = 0x0
	// Bit mask of DR16 field.
	CRC_DR16_DR16_Msk = 0xffff

	// IDR: Independent data register
	// Position of IDR field.
	CRC_IDR_IDR_Pos = 0x0
	// Bit mask of IDR field.
	CRC_IDR_IDR_Msk = 0xffffffff

	// CR: Control register
	// Position of REV_OUT field.
	CRC_CR_REV_OUT_Pos = 0x7
	// Bit mask of REV_OUT field.
	CRC_CR_REV_OUT_Msk = 0x80
	// Bit REV_OUT.
	CRC_CR_REV_OUT = 0x80
	// Bit order not affected
	CRC_CR_REV_OUT_Normal = 0x0
	// Bit reversed output
	CRC_CR_REV_OUT_Reversed = 0x1
	// Position of REV_IN field.
	CRC_CR_REV_IN_Pos = 0x5
	// Bit mask of REV_IN field.
	CRC_CR_REV_IN_Msk = 0x60
	// Bit order not affected
	CRC_CR_REV_IN_Normal = 0x0
	// Bit reversal done by byte
	CRC_CR_REV_IN_Byte = 0x1
	// Bit reversal done by half-word
	CRC_CR_REV_IN_HalfWord = 0x2
	// Bit reversal done by word
	CRC_CR_REV_IN_Word = 0x3
	// Position of POLYSIZE field.
	CRC_CR_POLYSIZE_Pos = 0x3
	// Bit mask of POLYSIZE field.
	CRC_CR_POLYSIZE_Msk = 0x18
	// 32-bit polynomial
	CRC_CR_POLYSIZE_Polysize32 = 0x0
	// 16-bit polynomial
	CRC_CR_POLYSIZE_Polysize16 = 0x1
	// 8-bit polynomial
	CRC_CR_POLYSIZE_Polysize8 = 0x2
	// 7-bit polynomial
	CRC_CR_POLYSIZE_Polysize7 = 0x3
	// Position of RESET field.
	CRC_CR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	CRC_CR_RESET_Msk = 0x1
	// Bit RESET.
	CRC_CR_RESET = 0x1
	// Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
	CRC_CR_RESET_Reset = 0x1

	// INIT: Initial CRC value
	// Position of INIT field.
	CRC_INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	CRC_INIT_INIT_Msk = 0xffffffff

	// POL: polynomial
	// Position of POL field.
	CRC_POL_POL_Pos = 0x0
	// Bit mask of POL field.
	CRC_POL_POL_Msk = 0xffffffff
)

// Constants for DAC: Digital-to-analog converter
const (
	// CR: control register
	// Position of CEN1 field.
	DAC_CR_CEN1_Pos = 0xe
	// Bit mask of CEN1 field.
	DAC_CR_CEN1_Msk = 0x4000
	// Bit CEN1.
	DAC_CR_CEN1 = 0x4000
	// DAC Channel X Normal operating mode
	DAC_CR_CEN1_Normal = 0x0
	// DAC Channel X calibration mode
	DAC_CR_CEN1_Calibration = 0x1
	// Position of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Pos = 0xd
	// Bit mask of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Msk = 0x2000
	// Bit DMAUDRIE1.
	DAC_CR_DMAUDRIE1 = 0x2000
	// DAC Channel X DMA Underrun Interrupt disabled
	DAC_CR_DMAUDRIE1_Disabled = 0x0
	// DAC Channel X DMA Underrun Interrupt enabled
	DAC_CR_DMAUDRIE1_Enabled = 0x1
	// Position of DMAEN1 field.
	DAC_CR_DMAEN1_Pos = 0xc
	// Bit mask of DMAEN1 field.
	DAC_CR_DMAEN1_Msk = 0x1000
	// Bit DMAEN1.
	DAC_CR_DMAEN1 = 0x1000
	// DAC Channel X DMA mode disabled
	DAC_CR_DMAEN1_Disabled = 0x0
	// DAC Channel X DMA mode enabled
	DAC_CR_DMAEN1_Enabled = 0x1
	// Position of MAMP1 field.
	DAC_CR_MAMP1_Pos = 0x8
	// Bit mask of MAMP1 field.
	DAC_CR_MAMP1_Msk = 0xf00
	// Unmask bit0 of LFSR/ triangle amplitude equal to 1
	DAC_CR_MAMP1_Amp1 = 0x0
	// Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3
	DAC_CR_MAMP1_Amp3 = 0x1
	// Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7
	DAC_CR_MAMP1_Amp7 = 0x2
	// Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15
	DAC_CR_MAMP1_Amp15 = 0x3
	// Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31
	DAC_CR_MAMP1_Amp31 = 0x4
	// Unmask bits[5:0] of LFSR/ triangle amplitude equal 63
	DAC_CR_MAMP1_Amp63 = 0x5
	// Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127
	DAC_CR_MAMP1_Amp127 = 0x6
	// Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255
	DAC_CR_MAMP1_Amp255 = 0x7
	// Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511
	DAC_CR_MAMP1_Amp511 = 0x8
	// Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023
	DAC_CR_MAMP1_Amp1023 = 0x9
	// Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047
	DAC_CR_MAMP1_Amp2047 = 0xa
	// Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC_CR_MAMP1_Amp4095 = 0xb
	// Position of WAVE1 field.
	DAC_CR_WAVE1_Pos = 0x6
	// Bit mask of WAVE1 field.
	DAC_CR_WAVE1_Msk = 0xc0
	// Wave generation disabled
	DAC_CR_WAVE1_Disabled = 0x0
	// Noise wave generation enabled
	DAC_CR_WAVE1_Noise = 0x1
	// Triangle wave generation enabled
	DAC_CR_WAVE1_Triangle = 0x2
	// Position of TEN1 field.
	DAC_CR_TEN1_Pos = 0x1
	// Bit mask of TEN1 field.
	DAC_CR_TEN1_Msk = 0x2
	// Bit TEN1.
	DAC_CR_TEN1 = 0x2
	// DAC Channel X trigger disabled
	DAC_CR_TEN1_Disabled = 0x0
	// DAC Channel X trigger enabled
	DAC_CR_TEN1_Enabled = 0x1
	// Position of EN1 field.
	DAC_CR_EN1_Pos = 0x0
	// Bit mask of EN1 field.
	DAC_CR_EN1_Msk = 0x1
	// Bit EN1.
	DAC_CR_EN1 = 0x1
	// DAC Channel X disabled
	DAC_CR_EN1_Disabled = 0x0
	// DAC Channel X enabled
	DAC_CR_EN1_Enabled = 0x1
	// Position of TSEL1 field.
	DAC_CR_TSEL1_Pos = 0x2
	// Bit mask of TSEL1 field.
	DAC_CR_TSEL1_Msk = 0x3c
	// SWTRIG1
	DAC_CR_TSEL1_SWTRIG = 0x0
	// dac_chx_trg1
	DAC_CR_TSEL1_TIM1_TRGO = 0x1
	// dac_chx_trg2
	DAC_CR_TSEL1_TIM2_TRGO = 0x2
	// dac_chx_trg3
	DAC_CR_TSEL1_TRG3 = 0x3
	// dac_chx_trg4
	DAC_CR_TSEL1_TRG4 = 0x4
	// dac_chx_trg5
	DAC_CR_TSEL1_TRG5 = 0x5
	// dac_chx_trg6
	DAC_CR_TSEL1_TRG6 = 0x6
	// dac_chx_trg7
	DAC_CR_TSEL1_TRG7 = 0x7
	// dac_chx_trg8
	DAC_CR_TSEL1_TRG8 = 0x8
	// dac_chx_trg9
	DAC_CR_TSEL1_TRG9 = 0x9
	// dac_chx_trg10
	DAC_CR_TSEL1_TRG10 = 0xa
	// dac_chx_trg11
	DAC_CR_TSEL1_LPTIM1_OUT = 0xb
	// dac_chx_trg12
	DAC_CR_TSEL1_LPTIM2_OUT = 0xc
	// dac_chx_trg13
	DAC_CR_TSEL1_LPTIM3_OUT = 0xd
	// dac_chx_trg14
	DAC_CR_TSEL1_EXTI9 = 0xe
	// dac_chx_trg15
	DAC_CR_TSEL1_TRG15 = 0xf

	// SWTRGR: software trigger register
	// Position of SWTRIG1 field.
	DAC_SWTRGR_SWTRIG1_Pos = 0x0
	// Bit mask of SWTRIG1 field.
	DAC_SWTRGR_SWTRIG1_Msk = 0x1
	// Bit SWTRIG1.
	DAC_SWTRGR_SWTRIG1 = 0x1
	// No trigger
	DAC_SWTRGR_SWTRIG1_NoTrigger = 0x0
	// Trigger
	DAC_SWTRGR_SWTRIG1_Trigger = 0x1

	// DHR12R1: channel1 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Msk = 0xfff

	// DHR12L1: channel1 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Msk = 0xfff0

	// DHR8R1: channel1 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Msk = 0xff

	// DHR12RD: Dual DAC 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Msk = 0xfff

	// DHR12LD: Dual DAC 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Msk = 0xfff0

	// DHR8RD: Dual DAC 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Msk = 0xff

	// DOR1: DAC channel1 data output register
	// Position of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Pos = 0x0
	// Bit mask of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Msk = 0xfff

	// SR: status register
	// Position of BWST1 field.
	DAC_SR_BWST1_Pos = 0xf
	// Bit mask of BWST1 field.
	DAC_SR_BWST1_Msk = 0x8000
	// Bit BWST1.
	DAC_SR_BWST1 = 0x8000
	// There is no write operation of DAC_SHSR1 ongoing: DAC_SHSR1 can be written
	DAC_SR_BWST1_Idle = 0x0
	// There is a write operation of DAC_SHSR1 ongoing: DAC_SHSR1 cannot be written
	DAC_SR_BWST1_Busy = 0x1
	// Position of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Pos = 0xe
	// Bit mask of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Msk = 0x4000
	// Bit CAL_FLAG1.
	DAC_SR_CAL_FLAG1 = 0x4000
	// Calibration trimming value is lower than the offset correction value
	DAC_SR_CAL_FLAG1_Lower = 0x0
	// Calibration trimming value is equal or greater than the offset correction value
	DAC_SR_CAL_FLAG1_Equal_Higher = 0x1
	// Position of DMAUDR1 field.
	DAC_SR_DMAUDR1_Pos = 0xd
	// Bit mask of DMAUDR1 field.
	DAC_SR_DMAUDR1_Msk = 0x2000
	// Bit DMAUDR1.
	DAC_SR_DMAUDR1 = 0x2000
	// No DMA underrun error condition occurred for DAC channel x
	DAC_SR_DMAUDR1_NoError = 0x0
	// DMA underrun error condition occurred for DAC channel x (the currently selected trigger is driving DAC channel1 conversion at a frequency higher than the DMA service capability rate)
	DAC_SR_DMAUDR1_Error = 0x1

	// CCR: calibration control register
	// Position of OTRIM1 field.
	DAC_CCR_OTRIM1_Pos = 0x0
	// Bit mask of OTRIM1 field.
	DAC_CCR_OTRIM1_Msk = 0x1f

	// MCR: mode control register
	// Position of MODE1 field.
	DAC_MCR_MODE1_Pos = 0x0
	// Bit mask of MODE1 field.
	DAC_MCR_MODE1_Msk = 0x7
	// Normal mode - DAC channelx is connected to external pin with Buffer enabled
	DAC_MCR_MODE1_NormalPinBuffer = 0x0
	// Normal mode - DAC channelx is connected to external pin and to on chip peripherals with Buffer enabled
	DAC_MCR_MODE1_NormalPinChipBuffer = 0x1
	// Normal mode - DAC channelx is connected to external pin with Buffer disabled
	DAC_MCR_MODE1_NormalPinNoBuffer = 0x2
	// Normal mode - DAC channelx is connected to on chip peripherals with Buffer disabled
	DAC_MCR_MODE1_NormalChipNoBuffer = 0x3
	// S&H mode - DAC channelx is connected to external pin with Buffer enabled
	DAC_MCR_MODE1_SHPinBuffer = 0x4
	// S&H mode - DAC channelx is connected to external pin and to on chip peripherals with Buffer enabled
	DAC_MCR_MODE1_SHPinChipBuffer = 0x5
	// S&H mode - DAC channelx is connected to external pin and to on chip peripherals with Buffer disabled
	DAC_MCR_MODE1_SHPinNoBuffer = 0x6
	// S&H mode - DAC channelx is connected to on chip peripherals with Buffer disabled
	DAC_MCR_MODE1_SHChipNoBuffer = 0x7

	// SHSR1: Sample and Hold sample time register 1
	// Position of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Pos = 0x0
	// Bit mask of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Msk = 0x3ff

	// SHHR: Sample and Hold hold time register
	// Position of THOLD1 field.
	DAC_SHHR_THOLD1_Pos = 0x0
	// Bit mask of THOLD1 field.
	DAC_SHHR_THOLD1_Msk = 0x3ff

	// SHRR: Sample and Hold refresh time register
	// Position of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Pos = 0x0
	// Bit mask of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Msk = 0xff
)

// Constants for DBGMCU: Microcontroller Debug Unit
const (
	// IDCODER: DBGMCU Identity Code Register
	// Position of DEV_ID field.
	DBGMCU_IDCODER_DEV_ID_Pos = 0x0
	// Bit mask of DEV_ID field.
	DBGMCU_IDCODER_DEV_ID_Msk = 0xfff
	// Position of REV_ID field.
	DBGMCU_IDCODER_REV_ID_Pos = 0x10
	// Bit mask of REV_ID field.
	DBGMCU_IDCODER_REV_ID_Msk = 0xffff0000

	// CR: DBGMCU Configuration Register
	// Position of DBG_SLEEP field.
	DBGMCU_CR_DBG_SLEEP_Pos = 0x0
	// Bit mask of DBG_SLEEP field.
	DBGMCU_CR_DBG_SLEEP_Msk = 0x1
	// Bit DBG_SLEEP.
	DBGMCU_CR_DBG_SLEEP = 0x1
	// Debug Sleep Mode Disabled
	DBGMCU_CR_DBG_SLEEP_Disabled = 0x0
	// Debug Sleep Mode Enabled
	DBGMCU_CR_DBG_SLEEP_Enabled = 0x1
	// Position of DBG_STOP field.
	DBGMCU_CR_DBG_STOP_Pos = 0x1
	// Bit mask of DBG_STOP field.
	DBGMCU_CR_DBG_STOP_Msk = 0x2
	// Bit DBG_STOP.
	DBGMCU_CR_DBG_STOP = 0x2
	// Debug Stop Mode Disabled
	DBGMCU_CR_DBG_STOP_Disabled = 0x0
	// Debug Stop Mode Enabled
	DBGMCU_CR_DBG_STOP_Enabled = 0x1
	// Position of DBG_STANDBY field.
	DBGMCU_CR_DBG_STANDBY_Pos = 0x2
	// Bit mask of DBG_STANDBY field.
	DBGMCU_CR_DBG_STANDBY_Msk = 0x4
	// Bit DBG_STANDBY.
	DBGMCU_CR_DBG_STANDBY = 0x4
	// Debug Standby Mode Disabled
	DBGMCU_CR_DBG_STANDBY_Disabled = 0x0
	// Debug Standby Mode Enabled
	DBGMCU_CR_DBG_STANDBY_Enabled = 0x1

	// APB1FZR1: DBGMCU CPU1 APB1 Peripheral Freeze Register 1
	// Position of DBG_TIM2_STOP field.
	DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos = 0x0
	// Bit mask of DBG_TIM2_STOP field.
	DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk = 0x1
	// Bit DBG_TIM2_STOP.
	DBGMCU_APB1FZR1_DBG_TIM2_STOP = 0x1
	// The counter clock of TIMx is fed even if the core is halted
	DBGMCU_APB1FZR1_DBG_TIM2_STOP_Continue = 0x0
	// The counter clock of TIMx is stopped when the core is halted
	DBGMCU_APB1FZR1_DBG_TIM2_STOP_Stop = 0x1
	// Position of DBG_RTC_STOP field.
	DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos = 0xa
	// Bit mask of DBG_RTC_STOP field.
	DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk = 0x400
	// Bit DBG_RTC_STOP.
	DBGMCU_APB1FZR1_DBG_RTC_STOP = 0x400
	// The clock of the RTC counter is fed even if the core is halted
	DBGMCU_APB1FZR1_DBG_RTC_STOP_Continue = 0x0
	// The clock of the RTC counter is stopped when the core is halted
	DBGMCU_APB1FZR1_DBG_RTC_STOP_Stop = 0x1
	// Position of DBG_WWDG_STOP field.
	DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos = 0xb
	// Bit mask of DBG_WWDG_STOP field.
	DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk = 0x800
	// Bit DBG_WWDG_STOP.
	DBGMCU_APB1FZR1_DBG_WWDG_STOP = 0x800
	// The window watchdog counter clock continues even if the core is halted
	DBGMCU_APB1FZR1_DBG_WWDG_STOP_Continue = 0x0
	// The window watchdog counter clock is stopped when the core is halted
	DBGMCU_APB1FZR1_DBG_WWDG_STOP_Stop = 0x1
	// Position of DBG_IWDG_STOP field.
	DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos = 0xc
	// Bit mask of DBG_IWDG_STOP field.
	DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk = 0x1000
	// Bit DBG_IWDG_STOP.
	DBGMCU_APB1FZR1_DBG_IWDG_STOP = 0x1000
	// The independent watchdog counter clock continues even if the core is halted
	DBGMCU_APB1FZR1_DBG_IWDG_STOP_Continue = 0x0
	// The independent watchdog counter clock is stopped when the core is halted
	DBGMCU_APB1FZR1_DBG_IWDG_STOP_Stop = 0x1
	// Position of DBG_I2C1_STOP field.
	DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos = 0x15
	// Bit mask of DBG_I2C1_STOP field.
	DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk = 0x200000
	// Bit DBG_I2C1_STOP.
	DBGMCU_APB1FZR1_DBG_I2C1_STOP = 0x200000
	// Same behavior as in normal mode
	DBGMCU_APB1FZR1_DBG_I2C1_STOP_NormalMode = 0x0
	// I2C3 SMBUS timeout is frozen
	DBGMCU_APB1FZR1_DBG_I2C1_STOP_SMBusTimeoutFrozen = 0x1
	// Position of DBG_I2C2_STOP field.
	DBGMCU_APB1FZR1_DBG_I2C2_STOP_Pos = 0x16
	// Bit mask of DBG_I2C2_STOP field.
	DBGMCU_APB1FZR1_DBG_I2C2_STOP_Msk = 0x400000
	// Bit DBG_I2C2_STOP.
	DBGMCU_APB1FZR1_DBG_I2C2_STOP = 0x400000
	// Same behavior as in normal mode
	DBGMCU_APB1FZR1_DBG_I2C2_STOP_NormalMode = 0x0
	// I2C3 SMBUS timeout is frozen
	DBGMCU_APB1FZR1_DBG_I2C2_STOP_SMBusTimeoutFrozen = 0x1
	// Position of DBG_I2C3_STOP field.
	DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos = 0x17
	// Bit mask of DBG_I2C3_STOP field.
	DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk = 0x800000
	// Bit DBG_I2C3_STOP.
	DBGMCU_APB1FZR1_DBG_I2C3_STOP = 0x800000
	// Same behavior as in normal mode
	DBGMCU_APB1FZR1_DBG_I2C3_STOP_NormalMode = 0x0
	// I2C3 SMBUS timeout is frozen
	DBGMCU_APB1FZR1_DBG_I2C3_STOP_SMBusTimeoutFrozen = 0x1
	// Position of DBG_LPTIM1_STOP field.
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos = 0x1f
	// Bit mask of DBG_LPTIM1_STOP field.
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk = 0x80000000
	// Bit DBG_LPTIM1_STOP.
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP = 0x80000000
	// LPTIM1 counter clock is fed even if the core is halted
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Continue = 0x0
	// LPTIM1 counter clock is stopped when the core is halted
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Stop = 0x1

	// APB1FZR2: DBGMCU CPU1 APB1 Peripheral Freeze Register 2
	// Position of DBG_LPTIM2_STOP field.
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Pos = 0x5
	// Bit mask of DBG_LPTIM2_STOP field.
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Msk = 0x20
	// Bit DBG_LPTIM2_STOP.
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP = 0x20
	// LPTIM1 counter clock is fed even if the core is halted
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Continue = 0x0
	// LPTIM1 counter clock is stopped when the core is halted
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Stop = 0x1
	// Position of DBG_LPTIM3_STOP field.
	DBGMCU_APB1FZR2_DBG_LPTIM3_STOP_Pos = 0x6
	// Bit mask of DBG_LPTIM3_STOP field.
	DBGMCU_APB1FZR2_DBG_LPTIM3_STOP_Msk = 0x40
	// Bit DBG_LPTIM3_STOP.
	DBGMCU_APB1FZR2_DBG_LPTIM3_STOP = 0x40
	// LPTIM1 counter clock is fed even if the core is halted
	DBGMCU_APB1FZR2_DBG_LPTIM3_STOP_Continue = 0x0
	// LPTIM1 counter clock is stopped when the core is halted
	DBGMCU_APB1FZR2_DBG_LPTIM3_STOP_Stop = 0x1

	// APB2FZR: DBGMCU CPU1 APB2 Peripheral Freeze Register
	// Position of DBG_TIM1_STOP field.
	DBGMCU_APB2FZR_DBG_TIM1_STOP_Pos = 0xb
	// Bit mask of DBG_TIM1_STOP field.
	DBGMCU_APB2FZR_DBG_TIM1_STOP_Msk = 0x800
	// Bit DBG_TIM1_STOP.
	DBGMCU_APB2FZR_DBG_TIM1_STOP = 0x800
	// The counter clock of TIMx is fed even if the core is halted
	DBGMCU_APB2FZR_DBG_TIM1_STOP_Continue = 0x0
	// The counter clock of TIMx is stopped when the core is halted
	DBGMCU_APB2FZR_DBG_TIM1_STOP_Stop = 0x1
	// Position of DBG_TIM16_STOP field.
	DBGMCU_APB2FZR_DBG_TIM16_STOP_Pos = 0x11
	// Bit mask of DBG_TIM16_STOP field.
	DBGMCU_APB2FZR_DBG_TIM16_STOP_Msk = 0x20000
	// Bit DBG_TIM16_STOP.
	DBGMCU_APB2FZR_DBG_TIM16_STOP = 0x20000
	// The counter clock of TIMx is fed even if the core is halted
	DBGMCU_APB2FZR_DBG_TIM16_STOP_Continue = 0x0
	// The counter clock of TIMx is stopped when the core is halted
	DBGMCU_APB2FZR_DBG_TIM16_STOP_Stop = 0x1
	// Position of DBG_TIM17_STOP field.
	DBGMCU_APB2FZR_DBG_TIM17_STOP_Pos = 0x12
	// Bit mask of DBG_TIM17_STOP field.
	DBGMCU_APB2FZR_DBG_TIM17_STOP_Msk = 0x40000
	// Bit DBG_TIM17_STOP.
	DBGMCU_APB2FZR_DBG_TIM17_STOP = 0x40000
	// The counter clock of TIMx is fed even if the core is halted
	DBGMCU_APB2FZR_DBG_TIM17_STOP_Continue = 0x0
	// The counter clock of TIMx is stopped when the core is halted
	DBGMCU_APB2FZR_DBG_TIM17_STOP_Stop = 0x1
)

// Constants for DMA1: Direct memory access controller
const (
	// ISR: interrupt status register
	// Position of TEIF7 field.
	DMA_ISR_TEIF7_Pos = 0x1b
	// Bit mask of TEIF7 field.
	DMA_ISR_TEIF7_Msk = 0x8000000
	// Bit TEIF7.
	DMA_ISR_TEIF7 = 0x8000000
	// No transfer error on channel x
	DMA_ISR_TEIF7_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF7_Error = 0x1
	// Position of HTIF7 field.
	DMA_ISR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA_ISR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA_ISR_HTIF7 = 0x4000000
	// No half transfer event on channel x
	DMA_ISR_HTIF7_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF7_Half = 0x1
	// Position of TCIF7 field.
	DMA_ISR_TCIF7_Pos = 0x19
	// Bit mask of TCIF7 field.
	DMA_ISR_TCIF7_Msk = 0x2000000
	// Bit TCIF7.
	DMA_ISR_TCIF7 = 0x2000000
	// No transfer complete event on channel x
	DMA_ISR_TCIF7_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF7_Complete = 0x1
	// Position of GIF7 field.
	DMA_ISR_GIF7_Pos = 0x18
	// Bit mask of GIF7 field.
	DMA_ISR_GIF7_Msk = 0x1000000
	// Bit GIF7.
	DMA_ISR_GIF7 = 0x1000000
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF7_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF7_Event = 0x1
	// Position of TEIF6 field.
	DMA_ISR_TEIF6_Pos = 0x17
	// Bit mask of TEIF6 field.
	DMA_ISR_TEIF6_Msk = 0x800000
	// Bit TEIF6.
	DMA_ISR_TEIF6 = 0x800000
	// No transfer error on channel x
	DMA_ISR_TEIF6_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF6_Error = 0x1
	// Position of HTIF6 field.
	DMA_ISR_HTIF6_Pos = 0x16
	// Bit mask of HTIF6 field.
	DMA_ISR_HTIF6_Msk = 0x400000
	// Bit HTIF6.
	DMA_ISR_HTIF6 = 0x400000
	// No half transfer event on channel x
	DMA_ISR_HTIF6_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF6_Half = 0x1
	// Position of TCIF6 field.
	DMA_ISR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA_ISR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA_ISR_TCIF6 = 0x200000
	// No transfer complete event on channel x
	DMA_ISR_TCIF6_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF6_Complete = 0x1
	// Position of GIF6 field.
	DMA_ISR_GIF6_Pos = 0x14
	// Bit mask of GIF6 field.
	DMA_ISR_GIF6_Msk = 0x100000
	// Bit GIF6.
	DMA_ISR_GIF6 = 0x100000
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF6_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF6_Event = 0x1
	// Position of TEIF5 field.
	DMA_ISR_TEIF5_Pos = 0x13
	// Bit mask of TEIF5 field.
	DMA_ISR_TEIF5_Msk = 0x80000
	// Bit TEIF5.
	DMA_ISR_TEIF5 = 0x80000
	// No transfer error on channel x
	DMA_ISR_TEIF5_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF5_Error = 0x1
	// Position of HTIF5 field.
	DMA_ISR_HTIF5_Pos = 0x12
	// Bit mask of HTIF5 field.
	DMA_ISR_HTIF5_Msk = 0x40000
	// Bit HTIF5.
	DMA_ISR_HTIF5 = 0x40000
	// No half transfer event on channel x
	DMA_ISR_HTIF5_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF5_Half = 0x1
	// Position of TCIF5 field.
	DMA_ISR_TCIF5_Pos = 0x11
	// Bit mask of TCIF5 field.
	DMA_ISR_TCIF5_Msk = 0x20000
	// Bit TCIF5.
	DMA_ISR_TCIF5 = 0x20000
	// No transfer complete event on channel x
	DMA_ISR_TCIF5_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF5_Complete = 0x1
	// Position of GIF5 field.
	DMA_ISR_GIF5_Pos = 0x10
	// Bit mask of GIF5 field.
	DMA_ISR_GIF5_Msk = 0x10000
	// Bit GIF5.
	DMA_ISR_GIF5 = 0x10000
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF5_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF5_Event = 0x1
	// Position of TEIF4 field.
	DMA_ISR_TEIF4_Pos = 0xf
	// Bit mask of TEIF4 field.
	DMA_ISR_TEIF4_Msk = 0x8000
	// Bit TEIF4.
	DMA_ISR_TEIF4 = 0x8000
	// No transfer error on channel x
	DMA_ISR_TEIF4_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF4_Error = 0x1
	// Position of HTIF4 field.
	DMA_ISR_HTIF4_Pos = 0xe
	// Bit mask of HTIF4 field.
	DMA_ISR_HTIF4_Msk = 0x4000
	// Bit HTIF4.
	DMA_ISR_HTIF4 = 0x4000
	// No half transfer event on channel x
	DMA_ISR_HTIF4_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF4_Half = 0x1
	// Position of TCIF4 field.
	DMA_ISR_TCIF4_Pos = 0xd
	// Bit mask of TCIF4 field.
	DMA_ISR_TCIF4_Msk = 0x2000
	// Bit TCIF4.
	DMA_ISR_TCIF4 = 0x2000
	// No transfer complete event on channel x
	DMA_ISR_TCIF4_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF4_Complete = 0x1
	// Position of GIF4 field.
	DMA_ISR_GIF4_Pos = 0xc
	// Bit mask of GIF4 field.
	DMA_ISR_GIF4_Msk = 0x1000
	// Bit GIF4.
	DMA_ISR_GIF4 = 0x1000
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF4_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF4_Event = 0x1
	// Position of TEIF3 field.
	DMA_ISR_TEIF3_Pos = 0xb
	// Bit mask of TEIF3 field.
	DMA_ISR_TEIF3_Msk = 0x800
	// Bit TEIF3.
	DMA_ISR_TEIF3 = 0x800
	// No transfer error on channel x
	DMA_ISR_TEIF3_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF3_Error = 0x1
	// Position of HTIF3 field.
	DMA_ISR_HTIF3_Pos = 0xa
	// Bit mask of HTIF3 field.
	DMA_ISR_HTIF3_Msk = 0x400
	// Bit HTIF3.
	DMA_ISR_HTIF3 = 0x400
	// No half transfer event on channel x
	DMA_ISR_HTIF3_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF3_Half = 0x1
	// Position of TCIF3 field.
	DMA_ISR_TCIF3_Pos = 0x9
	// Bit mask of TCIF3 field.
	DMA_ISR_TCIF3_Msk = 0x200
	// Bit TCIF3.
	DMA_ISR_TCIF3 = 0x200
	// No transfer complete event on channel x
	DMA_ISR_TCIF3_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF3_Complete = 0x1
	// Position of GIF3 field.
	DMA_ISR_GIF3_Pos = 0x8
	// Bit mask of GIF3 field.
	DMA_ISR_GIF3_Msk = 0x100
	// Bit GIF3.
	DMA_ISR_GIF3 = 0x100
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF3_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF3_Event = 0x1
	// Position of TEIF2 field.
	DMA_ISR_TEIF2_Pos = 0x7
	// Bit mask of TEIF2 field.
	DMA_ISR_TEIF2_Msk = 0x80
	// Bit TEIF2.
	DMA_ISR_TEIF2 = 0x80
	// No transfer error on channel x
	DMA_ISR_TEIF2_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF2_Error = 0x1
	// Position of HTIF2 field.
	DMA_ISR_HTIF2_Pos = 0x6
	// Bit mask of HTIF2 field.
	DMA_ISR_HTIF2_Msk = 0x40
	// Bit HTIF2.
	DMA_ISR_HTIF2 = 0x40
	// No half transfer event on channel x
	DMA_ISR_HTIF2_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF2_Half = 0x1
	// Position of TCIF2 field.
	DMA_ISR_TCIF2_Pos = 0x5
	// Bit mask of TCIF2 field.
	DMA_ISR_TCIF2_Msk = 0x20
	// Bit TCIF2.
	DMA_ISR_TCIF2 = 0x20
	// No transfer complete event on channel x
	DMA_ISR_TCIF2_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF2_Complete = 0x1
	// Position of GIF2 field.
	DMA_ISR_GIF2_Pos = 0x4
	// Bit mask of GIF2 field.
	DMA_ISR_GIF2_Msk = 0x10
	// Bit GIF2.
	DMA_ISR_GIF2 = 0x10
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF2_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF2_Event = 0x1
	// Position of TEIF1 field.
	DMA_ISR_TEIF1_Pos = 0x3
	// Bit mask of TEIF1 field.
	DMA_ISR_TEIF1_Msk = 0x8
	// Bit TEIF1.
	DMA_ISR_TEIF1 = 0x8
	// No transfer error on channel x
	DMA_ISR_TEIF1_NoError = 0x0
	// A transfer error occurred on channel x
	DMA_ISR_TEIF1_Error = 0x1
	// Position of HTIF1 field.
	DMA_ISR_HTIF1_Pos = 0x2
	// Bit mask of HTIF1 field.
	DMA_ISR_HTIF1_Msk = 0x4
	// Bit HTIF1.
	DMA_ISR_HTIF1 = 0x4
	// No half transfer event on channel x
	DMA_ISR_HTIF1_NotHalf = 0x0
	// A half transfer event occurred on channel x
	DMA_ISR_HTIF1_Half = 0x1
	// Position of TCIF1 field.
	DMA_ISR_TCIF1_Pos = 0x1
	// Bit mask of TCIF1 field.
	DMA_ISR_TCIF1_Msk = 0x2
	// Bit TCIF1.
	DMA_ISR_TCIF1 = 0x2
	// No transfer complete event on channel x
	DMA_ISR_TCIF1_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	DMA_ISR_TCIF1_Complete = 0x1
	// Position of GIF1 field.
	DMA_ISR_GIF1_Pos = 0x0
	// Bit mask of GIF1 field.
	DMA_ISR_GIF1_Msk = 0x1
	// Bit GIF1.
	DMA_ISR_GIF1 = 0x1
	// No TE, HT or TC event on channel x
	DMA_ISR_GIF1_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	DMA_ISR_GIF1_Event = 0x1

	// IFCR: interrupt flag clear register
	// Position of TEIF7 field.
	DMA_IFCR_TEIF7_Pos = 0x1b
	// Bit mask of TEIF7 field.
	DMA_IFCR_TEIF7_Msk = 0x8000000
	// Bit TEIF7.
	DMA_IFCR_TEIF7 = 0x8000000
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF7_Clear = 0x1
	// Position of HTIF7 field.
	DMA_IFCR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA_IFCR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA_IFCR_HTIF7 = 0x4000000
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF7_Clear = 0x1
	// Position of TCIF7 field.
	DMA_IFCR_TCIF7_Pos = 0x19
	// Bit mask of TCIF7 field.
	DMA_IFCR_TCIF7_Msk = 0x2000000
	// Bit TCIF7.
	DMA_IFCR_TCIF7 = 0x2000000
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF7_Clear = 0x1
	// Position of GIF7 field.
	DMA_IFCR_GIF7_Pos = 0x18
	// Bit mask of GIF7 field.
	DMA_IFCR_GIF7_Msk = 0x1000000
	// Bit GIF7.
	DMA_IFCR_GIF7 = 0x1000000
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF7_Clear = 0x1
	// Position of TEIF6 field.
	DMA_IFCR_TEIF6_Pos = 0x17
	// Bit mask of TEIF6 field.
	DMA_IFCR_TEIF6_Msk = 0x800000
	// Bit TEIF6.
	DMA_IFCR_TEIF6 = 0x800000
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF6_Clear = 0x1
	// Position of HTIF6 field.
	DMA_IFCR_HTIF6_Pos = 0x16
	// Bit mask of HTIF6 field.
	DMA_IFCR_HTIF6_Msk = 0x400000
	// Bit HTIF6.
	DMA_IFCR_HTIF6 = 0x400000
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF6_Clear = 0x1
	// Position of TCIF6 field.
	DMA_IFCR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA_IFCR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA_IFCR_TCIF6 = 0x200000
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF6_Clear = 0x1
	// Position of GIF6 field.
	DMA_IFCR_GIF6_Pos = 0x14
	// Bit mask of GIF6 field.
	DMA_IFCR_GIF6_Msk = 0x100000
	// Bit GIF6.
	DMA_IFCR_GIF6 = 0x100000
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF6_Clear = 0x1
	// Position of TEIF5 field.
	DMA_IFCR_TEIF5_Pos = 0x13
	// Bit mask of TEIF5 field.
	DMA_IFCR_TEIF5_Msk = 0x80000
	// Bit TEIF5.
	DMA_IFCR_TEIF5 = 0x80000
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF5_Clear = 0x1
	// Position of HTIF5 field.
	DMA_IFCR_HTIF5_Pos = 0x12
	// Bit mask of HTIF5 field.
	DMA_IFCR_HTIF5_Msk = 0x40000
	// Bit HTIF5.
	DMA_IFCR_HTIF5 = 0x40000
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF5_Clear = 0x1
	// Position of TCIF5 field.
	DMA_IFCR_TCIF5_Pos = 0x11
	// Bit mask of TCIF5 field.
	DMA_IFCR_TCIF5_Msk = 0x20000
	// Bit TCIF5.
	DMA_IFCR_TCIF5 = 0x20000
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF5_Clear = 0x1
	// Position of GIF5 field.
	DMA_IFCR_GIF5_Pos = 0x10
	// Bit mask of GIF5 field.
	DMA_IFCR_GIF5_Msk = 0x10000
	// Bit GIF5.
	DMA_IFCR_GIF5 = 0x10000
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF5_Clear = 0x1
	// Position of TEIF4 field.
	DMA_IFCR_TEIF4_Pos = 0xf
	// Bit mask of TEIF4 field.
	DMA_IFCR_TEIF4_Msk = 0x8000
	// Bit TEIF4.
	DMA_IFCR_TEIF4 = 0x8000
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF4_Clear = 0x1
	// Position of HTIF4 field.
	DMA_IFCR_HTIF4_Pos = 0xe
	// Bit mask of HTIF4 field.
	DMA_IFCR_HTIF4_Msk = 0x4000
	// Bit HTIF4.
	DMA_IFCR_HTIF4 = 0x4000
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF4_Clear = 0x1
	// Position of TCIF4 field.
	DMA_IFCR_TCIF4_Pos = 0xd
	// Bit mask of TCIF4 field.
	DMA_IFCR_TCIF4_Msk = 0x2000
	// Bit TCIF4.
	DMA_IFCR_TCIF4 = 0x2000
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF4_Clear = 0x1
	// Position of GIF4 field.
	DMA_IFCR_GIF4_Pos = 0xc
	// Bit mask of GIF4 field.
	DMA_IFCR_GIF4_Msk = 0x1000
	// Bit GIF4.
	DMA_IFCR_GIF4 = 0x1000
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF4_Clear = 0x1
	// Position of TEIF3 field.
	DMA_IFCR_TEIF3_Pos = 0xb
	// Bit mask of TEIF3 field.
	DMA_IFCR_TEIF3_Msk = 0x800
	// Bit TEIF3.
	DMA_IFCR_TEIF3 = 0x800
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF3_Clear = 0x1
	// Position of HTIF3 field.
	DMA_IFCR_HTIF3_Pos = 0xa
	// Bit mask of HTIF3 field.
	DMA_IFCR_HTIF3_Msk = 0x400
	// Bit HTIF3.
	DMA_IFCR_HTIF3 = 0x400
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF3_Clear = 0x1
	// Position of TCIF3 field.
	DMA_IFCR_TCIF3_Pos = 0x9
	// Bit mask of TCIF3 field.
	DMA_IFCR_TCIF3_Msk = 0x200
	// Bit TCIF3.
	DMA_IFCR_TCIF3 = 0x200
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF3_Clear = 0x1
	// Position of GIF3 field.
	DMA_IFCR_GIF3_Pos = 0x8
	// Bit mask of GIF3 field.
	DMA_IFCR_GIF3_Msk = 0x100
	// Bit GIF3.
	DMA_IFCR_GIF3 = 0x100
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF3_Clear = 0x1
	// Position of TEIF2 field.
	DMA_IFCR_TEIF2_Pos = 0x7
	// Bit mask of TEIF2 field.
	DMA_IFCR_TEIF2_Msk = 0x80
	// Bit TEIF2.
	DMA_IFCR_TEIF2 = 0x80
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF2_Clear = 0x1
	// Position of HTIF2 field.
	DMA_IFCR_HTIF2_Pos = 0x6
	// Bit mask of HTIF2 field.
	DMA_IFCR_HTIF2_Msk = 0x40
	// Bit HTIF2.
	DMA_IFCR_HTIF2 = 0x40
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF2_Clear = 0x1
	// Position of TCIF2 field.
	DMA_IFCR_TCIF2_Pos = 0x5
	// Bit mask of TCIF2 field.
	DMA_IFCR_TCIF2_Msk = 0x20
	// Bit TCIF2.
	DMA_IFCR_TCIF2 = 0x20
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF2_Clear = 0x1
	// Position of GIF2 field.
	DMA_IFCR_GIF2_Pos = 0x4
	// Bit mask of GIF2 field.
	DMA_IFCR_GIF2_Msk = 0x10
	// Bit GIF2.
	DMA_IFCR_GIF2 = 0x10
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF2_Clear = 0x1
	// Position of TEIF1 field.
	DMA_IFCR_TEIF1_Pos = 0x3
	// Bit mask of TEIF1 field.
	DMA_IFCR_TEIF1_Msk = 0x8
	// Bit TEIF1.
	DMA_IFCR_TEIF1 = 0x8
	// Clear the corresponding TEIFx flag
	DMA_IFCR_TEIF1_Clear = 0x1
	// Position of HTIF1 field.
	DMA_IFCR_HTIF1_Pos = 0x2
	// Bit mask of HTIF1 field.
	DMA_IFCR_HTIF1_Msk = 0x4
	// Bit HTIF1.
	DMA_IFCR_HTIF1 = 0x4
	// Clear the corresponding HTIFx flag
	DMA_IFCR_HTIF1_Clear = 0x1
	// Position of TCIF1 field.
	DMA_IFCR_TCIF1_Pos = 0x1
	// Bit mask of TCIF1 field.
	DMA_IFCR_TCIF1_Msk = 0x2
	// Bit TCIF1.
	DMA_IFCR_TCIF1 = 0x2
	// Clear the corresponding TCIFx flag
	DMA_IFCR_TCIF1_Clear = 0x1
	// Position of GIF1 field.
	DMA_IFCR_GIF1_Pos = 0x0
	// Bit mask of GIF1 field.
	DMA_IFCR_GIF1_Msk = 0x1
	// Bit GIF1.
	DMA_IFCR_GIF1 = 0x1
	// Clear the corresponding CGIFx flag
	DMA_IFCR_GIF1_Clear = 0x1

	// CCR1: channel x configuration register
	// Position of PRIV field.
	DMA_CCR1_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR1_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR1_PRIV = 0x100000
	// Disabled
	DMA_CCR1_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR1_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR1_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR1_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR1_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR1_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR1_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR1_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR1_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR1_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR1_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR1_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR1_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR1_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR1_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR1_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR1_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR1_PL_Msk = 0x3000
	// Low
	DMA_CCR1_PL_Low = 0x0
	// Medium
	DMA_CCR1_PL_Medium = 0x1
	// High
	DMA_CCR1_PL_High = 0x2
	// Very high
	DMA_CCR1_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR1_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR1_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR1_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR1_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR1_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR1_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR1_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR1_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR1_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR1_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR1_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR1_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR1_MINC = 0x80
	// Disabled
	DMA_CCR1_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR1_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR1_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR1_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR1_PINC = 0x40
	// Disabled
	DMA_CCR1_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR1_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR1_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR1_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR1_CIRC = 0x20
	// Disabled
	DMA_CCR1_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR1_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR1_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR1_DIR = 0x10
	// Read from peripheral
	DMA_CCR1_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR1_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR1_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR1_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR1_TEIE = 0x8
	// Disabled
	DMA_CCR1_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR1_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR1_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR1_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR1_HTIE = 0x4
	// Disabled
	DMA_CCR1_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR1_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR1_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR1_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR1_TCIE = 0x2
	// Disabled
	DMA_CCR1_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR1_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR1_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR1_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR1_EN = 0x1
	// Disabled
	DMA_CCR1_EN_Disabled = 0x0
	// Enabled
	DMA_CCR1_EN_Enabled = 0x1

	// CNDTR1: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR1_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR1_NDT_Msk = 0x3ffff

	// CPAR1: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR1_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR1_PA_Msk = 0xffffffff

	// CMAR1: channel x memory address register
	// Position of MA field.
	DMA_CMAR1_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR1_MA_Msk = 0xffffffff

	// CCR2: channel x configuration register
	// Position of PRIV field.
	DMA_CCR2_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR2_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR2_PRIV = 0x100000
	// Disabled
	DMA_CCR2_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR2_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR2_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR2_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR2_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR2_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR2_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR2_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR2_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR2_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR2_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR2_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR2_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR2_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR2_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR2_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR2_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR2_PL_Msk = 0x3000
	// Low
	DMA_CCR2_PL_Low = 0x0
	// Medium
	DMA_CCR2_PL_Medium = 0x1
	// High
	DMA_CCR2_PL_High = 0x2
	// Very high
	DMA_CCR2_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR2_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR2_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR2_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR2_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR2_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR2_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR2_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR2_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR2_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR2_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR2_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR2_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR2_MINC = 0x80
	// Disabled
	DMA_CCR2_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR2_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR2_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR2_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR2_PINC = 0x40
	// Disabled
	DMA_CCR2_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR2_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR2_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR2_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR2_CIRC = 0x20
	// Disabled
	DMA_CCR2_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR2_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR2_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR2_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR2_DIR = 0x10
	// Read from peripheral
	DMA_CCR2_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR2_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR2_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR2_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR2_TEIE = 0x8
	// Disabled
	DMA_CCR2_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR2_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR2_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR2_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR2_HTIE = 0x4
	// Disabled
	DMA_CCR2_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR2_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR2_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR2_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR2_TCIE = 0x2
	// Disabled
	DMA_CCR2_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR2_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR2_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR2_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR2_EN = 0x1
	// Disabled
	DMA_CCR2_EN_Disabled = 0x0
	// Enabled
	DMA_CCR2_EN_Enabled = 0x1

	// CNDTR2: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR2_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR2_NDT_Msk = 0x3ffff

	// CPAR2: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR2_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR2_PA_Msk = 0xffffffff

	// CMAR2: channel x memory address register
	// Position of MA field.
	DMA_CMAR2_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR2_MA_Msk = 0xffffffff

	// CCR3: channel x configuration register
	// Position of PRIV field.
	DMA_CCR3_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR3_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR3_PRIV = 0x100000
	// Disabled
	DMA_CCR3_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR3_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR3_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR3_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR3_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR3_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR3_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR3_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR3_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR3_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR3_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR3_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR3_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR3_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR3_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR3_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR3_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR3_PL_Msk = 0x3000
	// Low
	DMA_CCR3_PL_Low = 0x0
	// Medium
	DMA_CCR3_PL_Medium = 0x1
	// High
	DMA_CCR3_PL_High = 0x2
	// Very high
	DMA_CCR3_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR3_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR3_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR3_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR3_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR3_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR3_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR3_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR3_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR3_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR3_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR3_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR3_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR3_MINC = 0x80
	// Disabled
	DMA_CCR3_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR3_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR3_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR3_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR3_PINC = 0x40
	// Disabled
	DMA_CCR3_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR3_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR3_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR3_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR3_CIRC = 0x20
	// Disabled
	DMA_CCR3_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR3_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR3_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR3_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR3_DIR = 0x10
	// Read from peripheral
	DMA_CCR3_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR3_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR3_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR3_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR3_TEIE = 0x8
	// Disabled
	DMA_CCR3_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR3_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR3_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR3_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR3_HTIE = 0x4
	// Disabled
	DMA_CCR3_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR3_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR3_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR3_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR3_TCIE = 0x2
	// Disabled
	DMA_CCR3_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR3_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR3_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR3_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR3_EN = 0x1
	// Disabled
	DMA_CCR3_EN_Disabled = 0x0
	// Enabled
	DMA_CCR3_EN_Enabled = 0x1

	// CNDTR3: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR3_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR3_NDT_Msk = 0x3ffff

	// CPAR3: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR3_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR3_PA_Msk = 0xffffffff

	// CMAR3: channel x memory address register
	// Position of MA field.
	DMA_CMAR3_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR3_MA_Msk = 0xffffffff

	// CCR4: channel x configuration register
	// Position of PRIV field.
	DMA_CCR4_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR4_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR4_PRIV = 0x100000
	// Disabled
	DMA_CCR4_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR4_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR4_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR4_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR4_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR4_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR4_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR4_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR4_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR4_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR4_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR4_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR4_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR4_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR4_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR4_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR4_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR4_PL_Msk = 0x3000
	// Low
	DMA_CCR4_PL_Low = 0x0
	// Medium
	DMA_CCR4_PL_Medium = 0x1
	// High
	DMA_CCR4_PL_High = 0x2
	// Very high
	DMA_CCR4_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR4_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR4_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR4_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR4_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR4_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR4_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR4_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR4_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR4_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR4_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR4_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR4_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR4_MINC = 0x80
	// Disabled
	DMA_CCR4_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR4_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR4_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR4_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR4_PINC = 0x40
	// Disabled
	DMA_CCR4_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR4_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR4_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR4_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR4_CIRC = 0x20
	// Disabled
	DMA_CCR4_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR4_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR4_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR4_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR4_DIR = 0x10
	// Read from peripheral
	DMA_CCR4_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR4_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR4_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR4_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR4_TEIE = 0x8
	// Disabled
	DMA_CCR4_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR4_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR4_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR4_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR4_HTIE = 0x4
	// Disabled
	DMA_CCR4_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR4_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR4_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR4_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR4_TCIE = 0x2
	// Disabled
	DMA_CCR4_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR4_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR4_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR4_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR4_EN = 0x1
	// Disabled
	DMA_CCR4_EN_Disabled = 0x0
	// Enabled
	DMA_CCR4_EN_Enabled = 0x1

	// CNDTR4: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR4_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR4_NDT_Msk = 0x3ffff

	// CPAR4: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR4_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR4_PA_Msk = 0xffffffff

	// CMAR4: channel x memory address register
	// Position of MA field.
	DMA_CMAR4_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR4_MA_Msk = 0xffffffff

	// CCR5: channel x configuration register
	// Position of PRIV field.
	DMA_CCR5_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR5_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR5_PRIV = 0x100000
	// Disabled
	DMA_CCR5_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR5_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR5_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR5_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR5_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR5_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR5_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR5_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR5_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR5_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR5_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR5_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR5_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR5_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR5_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR5_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR5_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR5_PL_Msk = 0x3000
	// Low
	DMA_CCR5_PL_Low = 0x0
	// Medium
	DMA_CCR5_PL_Medium = 0x1
	// High
	DMA_CCR5_PL_High = 0x2
	// Very high
	DMA_CCR5_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR5_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR5_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR5_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR5_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR5_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR5_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR5_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR5_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR5_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR5_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR5_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR5_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR5_MINC = 0x80
	// Disabled
	DMA_CCR5_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR5_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR5_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR5_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR5_PINC = 0x40
	// Disabled
	DMA_CCR5_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR5_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR5_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR5_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR5_CIRC = 0x20
	// Disabled
	DMA_CCR5_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR5_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR5_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR5_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR5_DIR = 0x10
	// Read from peripheral
	DMA_CCR5_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR5_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR5_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR5_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR5_TEIE = 0x8
	// Disabled
	DMA_CCR5_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR5_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR5_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR5_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR5_HTIE = 0x4
	// Disabled
	DMA_CCR5_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR5_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR5_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR5_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR5_TCIE = 0x2
	// Disabled
	DMA_CCR5_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR5_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR5_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR5_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR5_EN = 0x1
	// Disabled
	DMA_CCR5_EN_Disabled = 0x0
	// Enabled
	DMA_CCR5_EN_Enabled = 0x1

	// CNDTR5: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR5_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR5_NDT_Msk = 0x3ffff

	// CPAR5: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR5_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR5_PA_Msk = 0xffffffff

	// CMAR5: channel x memory address register
	// Position of MA field.
	DMA_CMAR5_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR5_MA_Msk = 0xffffffff

	// CCR6: channel x configuration register
	// Position of PRIV field.
	DMA_CCR6_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR6_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR6_PRIV = 0x100000
	// Disabled
	DMA_CCR6_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR6_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR6_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR6_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR6_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR6_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR6_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR6_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR6_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR6_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR6_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR6_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR6_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR6_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR6_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR6_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR6_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR6_PL_Msk = 0x3000
	// Low
	DMA_CCR6_PL_Low = 0x0
	// Medium
	DMA_CCR6_PL_Medium = 0x1
	// High
	DMA_CCR6_PL_High = 0x2
	// Very high
	DMA_CCR6_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR6_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR6_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR6_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR6_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR6_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR6_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR6_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR6_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR6_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR6_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR6_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR6_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR6_MINC = 0x80
	// Disabled
	DMA_CCR6_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR6_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR6_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR6_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR6_PINC = 0x40
	// Disabled
	DMA_CCR6_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR6_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR6_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR6_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR6_CIRC = 0x20
	// Disabled
	DMA_CCR6_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR6_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR6_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR6_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR6_DIR = 0x10
	// Read from peripheral
	DMA_CCR6_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR6_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR6_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR6_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR6_TEIE = 0x8
	// Disabled
	DMA_CCR6_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR6_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR6_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR6_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR6_HTIE = 0x4
	// Disabled
	DMA_CCR6_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR6_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR6_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR6_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR6_TCIE = 0x2
	// Disabled
	DMA_CCR6_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR6_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR6_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR6_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR6_EN = 0x1
	// Disabled
	DMA_CCR6_EN_Disabled = 0x0
	// Enabled
	DMA_CCR6_EN_Enabled = 0x1

	// CNDTR6: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR6_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR6_NDT_Msk = 0x3ffff

	// CPAR6: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR6_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR6_PA_Msk = 0xffffffff

	// CMAR6: channel x memory address register
	// Position of MA field.
	DMA_CMAR6_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR6_MA_Msk = 0xffffffff

	// CCR7: channel x configuration register
	// Position of PRIV field.
	DMA_CCR7_PRIV_Pos = 0x14
	// Bit mask of PRIV field.
	DMA_CCR7_PRIV_Msk = 0x100000
	// Bit PRIV.
	DMA_CCR7_PRIV = 0x100000
	// Disabled
	DMA_CCR7_PRIV_Disabled = 0x0
	// Enabled
	DMA_CCR7_PRIV_Enabled = 0x1
	// Position of DSEC field.
	DMA_CCR7_DSEC_Pos = 0x13
	// Bit mask of DSEC field.
	DMA_CCR7_DSEC_Msk = 0x80000
	// Bit DSEC.
	DMA_CCR7_DSEC = 0x80000
	// Position of SSEC field.
	DMA_CCR7_SSEC_Pos = 0x12
	// Bit mask of SSEC field.
	DMA_CCR7_SSEC_Msk = 0x40000
	// Bit SSEC.
	DMA_CCR7_SSEC = 0x40000
	// Position of SECM field.
	DMA_CCR7_SECM_Pos = 0x11
	// Bit mask of SECM field.
	DMA_CCR7_SECM_Msk = 0x20000
	// Bit SECM.
	DMA_CCR7_SECM = 0x20000
	// Position of MEM2MEM field.
	DMA_CCR7_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR7_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR7_MEM2MEM = 0x4000
	// Disabled
	DMA_CCR7_MEM2MEM_Disabled = 0x0
	// Enabled
	DMA_CCR7_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR7_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR7_PL_Msk = 0x3000
	// Low
	DMA_CCR7_PL_Low = 0x0
	// Medium
	DMA_CCR7_PL_Medium = 0x1
	// High
	DMA_CCR7_PL_High = 0x2
	// Very high
	DMA_CCR7_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR7_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR7_MSIZE_Msk = 0xc00
	// 8 bits
	DMA_CCR7_MSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR7_MSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR7_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR7_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR7_PSIZE_Msk = 0x300
	// 8 bits
	DMA_CCR7_PSIZE_Bits8 = 0x0
	// 16 bits
	DMA_CCR7_PSIZE_Bits16 = 0x1
	// 32 bits
	DMA_CCR7_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR7_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR7_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR7_MINC = 0x80
	// Disabled
	DMA_CCR7_MINC_Disabled = 0x0
	// Enabled
	DMA_CCR7_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR7_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR7_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR7_PINC = 0x40
	// Disabled
	DMA_CCR7_PINC_Disabled = 0x0
	// Enabled
	DMA_CCR7_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR7_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR7_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR7_CIRC = 0x20
	// Disabled
	DMA_CCR7_CIRC_Disabled = 0x0
	// Enabled
	DMA_CCR7_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR7_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR7_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR7_DIR = 0x10
	// Read from peripheral
	DMA_CCR7_DIR_Peripheral = 0x0
	// Read from memory
	DMA_CCR7_DIR_Memory = 0x1
	// Position of TEIE field.
	DMA_CCR7_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR7_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR7_TEIE = 0x8
	// Disabled
	DMA_CCR7_TEIE_Disabled = 0x0
	// Enabled
	DMA_CCR7_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR7_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR7_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR7_HTIE = 0x4
	// Disabled
	DMA_CCR7_HTIE_Disabled = 0x0
	// Enabled
	DMA_CCR7_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR7_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR7_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR7_TCIE = 0x2
	// Disabled
	DMA_CCR7_TCIE_Disabled = 0x0
	// Enabled
	DMA_CCR7_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR7_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR7_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR7_EN = 0x1
	// Disabled
	DMA_CCR7_EN_Disabled = 0x0
	// Enabled
	DMA_CCR7_EN_Enabled = 0x1

	// CNDTR7: channel x number of data to transfer register
	// Position of NDT field.
	DMA_CNDTR7_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR7_NDT_Msk = 0x3ffff

	// CPAR7: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR7_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR7_PA_Msk = 0xffffffff

	// CMAR7: channel x memory address register
	// Position of MA field.
	DMA_CMAR7_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR7_MA_Msk = 0xffffffff
)

// Constants for DMAMUX: DMA request multiplexer
const (
	// C0CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C0CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C0CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C0CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C0CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C0CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C0CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C0CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C0CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C0CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C0CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C0CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C0CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C0CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C0CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C0CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C0CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C0CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C0CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C0CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C0CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C0CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C0CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C0CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C0CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C0CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C0CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C0CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C0CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C0CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C0CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C1CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C1CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C1CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C1CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C1CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C1CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C1CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C1CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C1CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C1CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C1CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C1CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C1CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C1CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C1CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C1CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C1CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C1CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C1CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C1CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C1CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C1CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C1CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C1CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C1CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C1CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C1CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C1CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C1CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C1CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C1CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C2CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C2CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C2CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C2CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C2CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C2CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C2CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C2CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C2CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C2CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C2CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C2CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C2CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C2CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C2CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C2CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C2CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C2CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C2CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C2CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C2CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C2CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C2CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C2CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C2CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C2CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C2CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C2CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C2CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C2CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C2CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C3CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C3CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C3CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C3CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C3CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C3CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C3CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C3CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C3CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C3CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C3CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C3CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C3CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C3CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C3CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C3CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C3CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C3CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C3CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C3CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C3CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C3CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C3CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C3CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C3CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C3CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C3CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C3CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C3CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C3CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C3CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C4CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C4CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C4CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C4CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C4CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C4CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C4CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C4CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C4CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C4CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C4CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C4CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C4CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C4CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C4CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C4CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C4CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C4CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C4CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C4CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C4CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C4CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C4CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C4CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C4CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C4CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C4CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C4CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C4CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C4CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C4CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C5CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C5CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C5CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C5CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C5CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C5CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C5CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C5CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C5CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C5CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C5CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C5CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C5CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C5CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C5CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C5CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C5CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C5CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C5CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C5CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C5CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C5CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C5CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C5CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C5CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C5CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C5CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C5CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C5CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C5CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C5CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C6CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C6CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C6CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C6CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C6CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C6CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C6CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C6CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C6CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C6CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C6CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C6CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C6CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C6CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C6CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C6CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C6CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C6CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C6CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C6CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C6CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C6CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C6CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C6CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C6CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C6CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C6CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C6CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C6CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C6CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C6CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C7CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C7CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C7CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C7CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C7CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C7CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C7CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C7CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C7CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C7CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C7CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C7CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C7CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C7CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C7CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C7CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C7CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C7CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C7CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C7CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C7CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C7CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C7CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C7CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C7CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C7CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C7CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C7CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C7CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C7CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C7CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C8CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C8CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C8CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C8CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C8CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C8CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C8CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C8CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C8CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C8CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C8CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C8CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C8CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C8CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C8CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C8CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C8CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C8CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C8CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C8CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C8CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C8CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C8CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C8CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C8CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C8CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C8CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C8CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C8CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C8CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C8CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C9CR: request line multiplexer channel x configuration register
	// Position of SYNC_ID field.
	DMAMUX_C9CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C9CR_SYNC_ID_Msk = 0x1f000000
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_C9CR_SYNC_ID_LPTIM3_OUT = 0x14
	// Position of NBREQ field.
	DMAMUX_C9CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C9CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C9CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C9CR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_C9CR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_C9CR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_C9CR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_C9CR_SPOL_BothEdges = 0x3
	// Position of SE field.
	DMAMUX_C9CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C9CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C9CR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_C9CR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_C9CR_SE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_C9CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C9CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C9CR_EGE = 0x200
	// Event generation disabled
	DMAMUX_C9CR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_C9CR_EGE_Enabled = 0x1
	// Position of SOIE field.
	DMAMUX_C9CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C9CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C9CR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_C9CR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_C9CR_SOIE_Enabled = 0x1
	// Position of DMAREQ_ID field.
	DMAMUX_C9CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C9CR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_C9CR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `adc1_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_ADC = 0x5
	// Signal `dac_out1_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_DAT_OUT1 = 0x6
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_SPI1_RX_DMA = 0x7
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_SPI1_TX_DMA = 0x8
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_SPI2_RX_DMA = 0x9
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_SPI2_TX_DMA = 0xa
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_I2C1_RX_DMA = 0xb
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_I2C1_TX_DMA = 0xc
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_I2C2_RX_DMA = 0xd
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_I2C2_TX_DMA = 0xe
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_I2C3_RX_DMA = 0xf
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_I2C3_TX_DMA = 0x10
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_USART1_RX_DMA = 0x11
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_USART1_TX_DMA = 0x12
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_USART2_RX_DMA = 0x13
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_USART2_TX_DMA = 0x14
	// Signal `lpuart1_rx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_LPUART1_RX_DMA = 0x15
	// Signal `lpuart1_tx_dma` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_LPUART1_TX_DMA = 0x16
	// Signal `tim1_ch1` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_CH1 = 0x17
	// Signal `tim1_ch2` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_CH2 = 0x18
	// Signal `tim1_ch3` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_CH3 = 0x19
	// Signal `tim1_ch4` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_CH4 = 0x1a
	// Signal `tim1_up` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_UP = 0x1b
	// Signal `tim1_trig` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_TRIG = 0x1c
	// Signal `tim1_com` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM1_COM = 0x1d
	// Signal `tim2_ch1` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM2_CH1 = 0x1e
	// Signal `tim2_ch2` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM2_CH2 = 0x1f
	// Signal `tim2_ch3` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM2_CH3 = 0x20
	// Signal `tim2_ch4` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM2_CH4 = 0x21
	// Signal `tim2_up` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM2_UP = 0x22
	// Signal `tim16_ch1` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM16_CH1 = 0x23
	// Signal `tim16_up` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM16_UP = 0x24
	// Signal `tim17_ch1` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM17_CH1 = 0x25
	// Signal `tim17_up` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_TIM17_UP = 0x26
	// Signal `aes_in` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_AES_IN = 0x27
	// Signal `aes_out` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_AES_OUT = 0x28
	// Signal `subghzspi_rx` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_SUBGHZSPI_RX = 0x29
	// Signal `subghzspi_tx` selected as request input
	DMAMUX_C9CR_DMAREQ_ID_SUBGHZSPI_TX = 0x2a

	// C10CR: C10CR
	// Position of SYNC_ID field.
	DMAMUX_C10CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C10CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C10CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C10CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C10CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C10CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C10CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C10CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C10CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C10CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C10CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C10CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C10CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C10CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C10CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C10CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C10CR_DMAREQ_ID_Msk = 0xff

	// C11CR: C11CR
	// Position of SYNC_ID field.
	DMAMUX_C11CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C11CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C11CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C11CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C11CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C11CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C11CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C11CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C11CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C11CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C11CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C11CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C11CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C11CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C11CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C11CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C11CR_DMAREQ_ID_Msk = 0xff

	// C12CR: C12CR
	// Position of SYNC_ID field.
	DMAMUX_C12CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C12CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C12CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C12CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C12CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C12CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C12CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C12CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C12CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C12CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C12CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C12CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C12CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C12CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C12CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C12CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C12CR_DMAREQ_ID_Msk = 0xff

	// C13CR: C13CR
	// Position of SYNC_ID field.
	DMAMUX_C13CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C13CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C13CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C13CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C13CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C13CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C13CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C13CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C13CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C13CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C13CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C13CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C13CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C13CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C13CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C13CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C13CR_DMAREQ_ID_Msk = 0xff

	// CSR: request line multiplexer interrupt channel status register
	// Position of SOF13 field.
	DMAMUX_CSR_SOF13_Pos = 0xd
	// Bit mask of SOF13 field.
	DMAMUX_CSR_SOF13_Msk = 0x2000
	// Bit SOF13.
	DMAMUX_CSR_SOF13 = 0x2000
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF13_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF13_SyncEvent = 0x1
	// Position of SOF12 field.
	DMAMUX_CSR_SOF12_Pos = 0xc
	// Bit mask of SOF12 field.
	DMAMUX_CSR_SOF12_Msk = 0x1000
	// Bit SOF12.
	DMAMUX_CSR_SOF12 = 0x1000
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF12_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF12_SyncEvent = 0x1
	// Position of SOF11 field.
	DMAMUX_CSR_SOF11_Pos = 0xb
	// Bit mask of SOF11 field.
	DMAMUX_CSR_SOF11_Msk = 0x800
	// Bit SOF11.
	DMAMUX_CSR_SOF11 = 0x800
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF11_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF11_SyncEvent = 0x1
	// Position of SOF10 field.
	DMAMUX_CSR_SOF10_Pos = 0xa
	// Bit mask of SOF10 field.
	DMAMUX_CSR_SOF10_Msk = 0x400
	// Bit SOF10.
	DMAMUX_CSR_SOF10 = 0x400
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF10_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF10_SyncEvent = 0x1
	// Position of SOF9 field.
	DMAMUX_CSR_SOF9_Pos = 0x9
	// Bit mask of SOF9 field.
	DMAMUX_CSR_SOF9_Msk = 0x200
	// Bit SOF9.
	DMAMUX_CSR_SOF9 = 0x200
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF9_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF9_SyncEvent = 0x1
	// Position of SOF8 field.
	DMAMUX_CSR_SOF8_Pos = 0x8
	// Bit mask of SOF8 field.
	DMAMUX_CSR_SOF8_Msk = 0x100
	// Bit SOF8.
	DMAMUX_CSR_SOF8 = 0x100
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF8_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF8_SyncEvent = 0x1
	// Position of SOF7 field.
	DMAMUX_CSR_SOF7_Pos = 0x7
	// Bit mask of SOF7 field.
	DMAMUX_CSR_SOF7_Msk = 0x80
	// Bit SOF7.
	DMAMUX_CSR_SOF7 = 0x80
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF7_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF7_SyncEvent = 0x1
	// Position of SOF6 field.
	DMAMUX_CSR_SOF6_Pos = 0x6
	// Bit mask of SOF6 field.
	DMAMUX_CSR_SOF6_Msk = 0x40
	// Bit SOF6.
	DMAMUX_CSR_SOF6 = 0x40
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF6_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF6_SyncEvent = 0x1
	// Position of SOF5 field.
	DMAMUX_CSR_SOF5_Pos = 0x5
	// Bit mask of SOF5 field.
	DMAMUX_CSR_SOF5_Msk = 0x20
	// Bit SOF5.
	DMAMUX_CSR_SOF5 = 0x20
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF5_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF5_SyncEvent = 0x1
	// Position of SOF4 field.
	DMAMUX_CSR_SOF4_Pos = 0x4
	// Bit mask of SOF4 field.
	DMAMUX_CSR_SOF4_Msk = 0x10
	// Bit SOF4.
	DMAMUX_CSR_SOF4 = 0x10
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF4_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF4_SyncEvent = 0x1
	// Position of SOF3 field.
	DMAMUX_CSR_SOF3_Pos = 0x3
	// Bit mask of SOF3 field.
	DMAMUX_CSR_SOF3_Msk = 0x8
	// Bit SOF3.
	DMAMUX_CSR_SOF3 = 0x8
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF3_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF3_SyncEvent = 0x1
	// Position of SOF2 field.
	DMAMUX_CSR_SOF2_Pos = 0x2
	// Bit mask of SOF2 field.
	DMAMUX_CSR_SOF2_Msk = 0x4
	// Bit SOF2.
	DMAMUX_CSR_SOF2 = 0x4
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF2_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF2_SyncEvent = 0x1
	// Position of SOF1 field.
	DMAMUX_CSR_SOF1_Pos = 0x1
	// Bit mask of SOF1 field.
	DMAMUX_CSR_SOF1_Msk = 0x2
	// Bit SOF1.
	DMAMUX_CSR_SOF1 = 0x2
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF1_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF1_SyncEvent = 0x1
	// Position of SOF0 field.
	DMAMUX_CSR_SOF0_Pos = 0x0
	// Bit mask of SOF0 field.
	DMAMUX_CSR_SOF0_Msk = 0x1
	// Bit SOF0.
	DMAMUX_CSR_SOF0 = 0x1
	// No synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF0_NoSyncEvent = 0x0
	// Synchronization event occured on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ
	DMAMUX_CSR_SOF0_SyncEvent = 0x1

	// CCFR: request line multiplexer interrupt channel clear flag register
	// Position of CSOF13 field.
	DMAMUX_CCFR_CSOF13_Pos = 0xd
	// Bit mask of CSOF13 field.
	DMAMUX_CCFR_CSOF13_Msk = 0x2000
	// Bit CSOF13.
	DMAMUX_CCFR_CSOF13 = 0x2000
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF13_Clear = 0x1
	// Position of CSOF12 field.
	DMAMUX_CCFR_CSOF12_Pos = 0xc
	// Bit mask of CSOF12 field.
	DMAMUX_CCFR_CSOF12_Msk = 0x1000
	// Bit CSOF12.
	DMAMUX_CCFR_CSOF12 = 0x1000
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF12_Clear = 0x1
	// Position of CSOF11 field.
	DMAMUX_CCFR_CSOF11_Pos = 0xb
	// Bit mask of CSOF11 field.
	DMAMUX_CCFR_CSOF11_Msk = 0x800
	// Bit CSOF11.
	DMAMUX_CCFR_CSOF11 = 0x800
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF11_Clear = 0x1
	// Position of CSOF10 field.
	DMAMUX_CCFR_CSOF10_Pos = 0xa
	// Bit mask of CSOF10 field.
	DMAMUX_CCFR_CSOF10_Msk = 0x400
	// Bit CSOF10.
	DMAMUX_CCFR_CSOF10 = 0x400
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF10_Clear = 0x1
	// Position of CSOF9 field.
	DMAMUX_CCFR_CSOF9_Pos = 0x9
	// Bit mask of CSOF9 field.
	DMAMUX_CCFR_CSOF9_Msk = 0x200
	// Bit CSOF9.
	DMAMUX_CCFR_CSOF9 = 0x200
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF9_Clear = 0x1
	// Position of CSOF8 field.
	DMAMUX_CCFR_CSOF8_Pos = 0x8
	// Bit mask of CSOF8 field.
	DMAMUX_CCFR_CSOF8_Msk = 0x100
	// Bit CSOF8.
	DMAMUX_CCFR_CSOF8 = 0x100
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF8_Clear = 0x1
	// Position of CSOF7 field.
	DMAMUX_CCFR_CSOF7_Pos = 0x7
	// Bit mask of CSOF7 field.
	DMAMUX_CCFR_CSOF7_Msk = 0x80
	// Bit CSOF7.
	DMAMUX_CCFR_CSOF7 = 0x80
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF7_Clear = 0x1
	// Position of CSOF6 field.
	DMAMUX_CCFR_CSOF6_Pos = 0x6
	// Bit mask of CSOF6 field.
	DMAMUX_CCFR_CSOF6_Msk = 0x40
	// Bit CSOF6.
	DMAMUX_CCFR_CSOF6 = 0x40
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF6_Clear = 0x1
	// Position of CSOF5 field.
	DMAMUX_CCFR_CSOF5_Pos = 0x5
	// Bit mask of CSOF5 field.
	DMAMUX_CCFR_CSOF5_Msk = 0x20
	// Bit CSOF5.
	DMAMUX_CCFR_CSOF5 = 0x20
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF5_Clear = 0x1
	// Position of CSOF4 field.
	DMAMUX_CCFR_CSOF4_Pos = 0x4
	// Bit mask of CSOF4 field.
	DMAMUX_CCFR_CSOF4_Msk = 0x10
	// Bit CSOF4.
	DMAMUX_CCFR_CSOF4 = 0x10
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF4_Clear = 0x1
	// Position of CSOF3 field.
	DMAMUX_CCFR_CSOF3_Pos = 0x3
	// Bit mask of CSOF3 field.
	DMAMUX_CCFR_CSOF3_Msk = 0x8
	// Bit CSOF3.
	DMAMUX_CCFR_CSOF3 = 0x8
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF3_Clear = 0x1
	// Position of CSOF2 field.
	DMAMUX_CCFR_CSOF2_Pos = 0x2
	// Bit mask of CSOF2 field.
	DMAMUX_CCFR_CSOF2_Msk = 0x4
	// Bit CSOF2.
	DMAMUX_CCFR_CSOF2 = 0x4
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF2_Clear = 0x1
	// Position of CSOF1 field.
	DMAMUX_CCFR_CSOF1_Pos = 0x1
	// Bit mask of CSOF1 field.
	DMAMUX_CCFR_CSOF1_Msk = 0x2
	// Bit CSOF1.
	DMAMUX_CCFR_CSOF1 = 0x2
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF1_Clear = 0x1
	// Position of CSOF0 field.
	DMAMUX_CCFR_CSOF0_Pos = 0x0
	// Bit mask of CSOF0 field.
	DMAMUX_CCFR_CSOF0_Msk = 0x1
	// Bit CSOF0.
	DMAMUX_CCFR_CSOF0 = 0x1
	// Clear synchronization flag
	DMAMUX_CCFR_CSOF0_Clear = 0x1

	// RG0CR: request generator channel x configuration register
	// Position of GNBREQ field.
	DMAMUX_RG0CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG0CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG0CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG0CR_GPOL_Msk = 0x60000
	// No event, i.e. no detection nor generation
	DMAMUX_RG0CR_GPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_RG0CR_GPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_RG0CR_GPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_RG0CR_GPOL_BothEdges = 0x3
	// Position of GE field.
	DMAMUX_RG0CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG0CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG0CR_GE = 0x10000
	// DMA request generation disabled
	DMAMUX_RG0CR_GE_Disabled = 0x0
	// DMA request enabled
	DMAMUX_RG0CR_GE_Enabled = 0x1
	// Position of OIE field.
	DMAMUX_RG0CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG0CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG0CR_OIE = 0x100
	// Trigger overrun interrupt disabled
	DMAMUX_RG0CR_OIE_Disabled = 0x0
	// Trigger overrun interrupt enabled
	DMAMUX_RG0CR_OIE_Enabled = 0x1
	// Position of SIG_ID field.
	DMAMUX_RG0CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG0CR_SIG_ID_Msk = 0x1f
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_RG0CR_SIG_ID_LPTIM3_OUT = 0x14

	// RG1CR: request generator channel x configuration register
	// Position of GNBREQ field.
	DMAMUX_RG1CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG1CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG1CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG1CR_GPOL_Msk = 0x60000
	// No event, i.e. no detection nor generation
	DMAMUX_RG1CR_GPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_RG1CR_GPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_RG1CR_GPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_RG1CR_GPOL_BothEdges = 0x3
	// Position of GE field.
	DMAMUX_RG1CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG1CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG1CR_GE = 0x10000
	// DMA request generation disabled
	DMAMUX_RG1CR_GE_Disabled = 0x0
	// DMA request enabled
	DMAMUX_RG1CR_GE_Enabled = 0x1
	// Position of OIE field.
	DMAMUX_RG1CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG1CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG1CR_OIE = 0x100
	// Trigger overrun interrupt disabled
	DMAMUX_RG1CR_OIE_Disabled = 0x0
	// Trigger overrun interrupt enabled
	DMAMUX_RG1CR_OIE_Enabled = 0x1
	// Position of SIG_ID field.
	DMAMUX_RG1CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG1CR_SIG_ID_Msk = 0x1f
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_RG1CR_SIG_ID_LPTIM3_OUT = 0x14

	// RG2CR: request generator channel x configuration register
	// Position of GNBREQ field.
	DMAMUX_RG2CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG2CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG2CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG2CR_GPOL_Msk = 0x60000
	// No event, i.e. no detection nor generation
	DMAMUX_RG2CR_GPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_RG2CR_GPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_RG2CR_GPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_RG2CR_GPOL_BothEdges = 0x3
	// Position of GE field.
	DMAMUX_RG2CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG2CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG2CR_GE = 0x10000
	// DMA request generation disabled
	DMAMUX_RG2CR_GE_Disabled = 0x0
	// DMA request enabled
	DMAMUX_RG2CR_GE_Enabled = 0x1
	// Position of OIE field.
	DMAMUX_RG2CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG2CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG2CR_OIE = 0x100
	// Trigger overrun interrupt disabled
	DMAMUX_RG2CR_OIE_Disabled = 0x0
	// Trigger overrun interrupt enabled
	DMAMUX_RG2CR_OIE_Enabled = 0x1
	// Position of SIG_ID field.
	DMAMUX_RG2CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG2CR_SIG_ID_Msk = 0x1f
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_RG2CR_SIG_ID_LPTIM3_OUT = 0x14

	// RG3CR: request generator channel x configuration register
	// Position of GNBREQ field.
	DMAMUX_RG3CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG3CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG3CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG3CR_GPOL_Msk = 0x60000
	// No event, i.e. no detection nor generation
	DMAMUX_RG3CR_GPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_RG3CR_GPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_RG3CR_GPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_RG3CR_GPOL_BothEdges = 0x3
	// Position of GE field.
	DMAMUX_RG3CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG3CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG3CR_GE = 0x10000
	// DMA request generation disabled
	DMAMUX_RG3CR_GE_Disabled = 0x0
	// DMA request enabled
	DMAMUX_RG3CR_GE_Enabled = 0x1
	// Position of OIE field.
	DMAMUX_RG3CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG3CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG3CR_OIE = 0x100
	// Trigger overrun interrupt disabled
	DMAMUX_RG3CR_OIE_Disabled = 0x0
	// Trigger overrun interrupt enabled
	DMAMUX_RG3CR_OIE_Enabled = 0x1
	// Position of SIG_ID field.
	DMAMUX_RG3CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG3CR_SIG_ID_Msk = 0x1f
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI0 = 0x0
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI1 = 0x1
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI2 = 0x2
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI3 = 0x3
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI4 = 0x4
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI5 = 0x5
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI6 = 0x6
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI7 = 0x7
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI8 = 0x8
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI9 = 0x9
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI10 = 0xa
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI11 = 0xb
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI12 = 0xc
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI13 = 0xd
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI14 = 0xe
	// Signal `EXTIx` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_EXTI15 = 0xf
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_DMAMUX1_EVT0 = 0x10
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_DMAMUX1_EVT1 = 0x11
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_LPTIM1_OUT = 0x12
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_LPTIM2_OUT = 0x13
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_RG3CR_SIG_ID_LPTIM3_OUT = 0x14

	// RGSR: request generator interrupt status register
	// Position of OF3 field.
	DMAMUX_RGSR_OF3_Pos = 0x3
	// Bit mask of OF3 field.
	DMAMUX_RGSR_OF3_Msk = 0x8
	// Bit OF3.
	DMAMUX_RGSR_OF3 = 0x8
	// No new trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF3_NoTrigger = 0x0
	// New trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF3_Trigger = 0x1
	// Position of OF2 field.
	DMAMUX_RGSR_OF2_Pos = 0x2
	// Bit mask of OF2 field.
	DMAMUX_RGSR_OF2_Msk = 0x4
	// Bit OF2.
	DMAMUX_RGSR_OF2 = 0x4
	// No new trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF2_NoTrigger = 0x0
	// New trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF2_Trigger = 0x1
	// Position of OF1 field.
	DMAMUX_RGSR_OF1_Pos = 0x1
	// Bit mask of OF1 field.
	DMAMUX_RGSR_OF1_Msk = 0x2
	// Bit OF1.
	DMAMUX_RGSR_OF1 = 0x2
	// No new trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF1_NoTrigger = 0x0
	// New trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF1_Trigger = 0x1
	// Position of OF0 field.
	DMAMUX_RGSR_OF0_Pos = 0x0
	// Bit mask of OF0 field.
	DMAMUX_RGSR_OF0_Msk = 0x1
	// Bit OF0.
	DMAMUX_RGSR_OF0 = 0x1
	// No new trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF0_NoTrigger = 0x0
	// New trigger event occured on DMA request generator channel x, before the request counter underrun
	DMAMUX_RGSR_OF0_Trigger = 0x1

	// RGCFR: request generator interrupt clear flag register
	// Position of COF3 field.
	DMAMUX_RGCFR_COF3_Pos = 0x3
	// Bit mask of COF3 field.
	DMAMUX_RGCFR_COF3_Msk = 0x8
	// Bit COF3.
	DMAMUX_RGCFR_COF3 = 0x8
	// Clear overrun flag
	DMAMUX_RGCFR_COF3_Clear = 0x1
	// Position of COF2 field.
	DMAMUX_RGCFR_COF2_Pos = 0x2
	// Bit mask of COF2 field.
	DMAMUX_RGCFR_COF2_Msk = 0x4
	// Bit COF2.
	DMAMUX_RGCFR_COF2 = 0x4
	// Clear overrun flag
	DMAMUX_RGCFR_COF2_Clear = 0x1
	// Position of COF1 field.
	DMAMUX_RGCFR_COF1_Pos = 0x1
	// Bit mask of COF1 field.
	DMAMUX_RGCFR_COF1_Msk = 0x2
	// Bit COF1.
	DMAMUX_RGCFR_COF1 = 0x2
	// Clear overrun flag
	DMAMUX_RGCFR_COF1_Clear = 0x1
	// Position of COF0 field.
	DMAMUX_RGCFR_COF0_Pos = 0x0
	// Bit mask of COF0 field.
	DMAMUX_RGCFR_COF0_Msk = 0x1
	// Bit COF0.
	DMAMUX_RGCFR_COF0 = 0x1
	// Clear overrun flag
	DMAMUX_RGCFR_COF0_Clear = 0x1
)

// Constants for EXTI: External interrupt/event controller
const (
	// RTSR1: rising trigger selection register
	// Position of RT21 field.
	EXTI_RTSR1_RT21_Pos = 0x15
	// Bit mask of RT21 field.
	EXTI_RTSR1_RT21_Msk = 0x200000
	// Bit RT21.
	EXTI_RTSR1_RT21 = 0x200000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT21_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT21_Enabled = 0x1
	// Position of RT22 field.
	EXTI_RTSR1_RT22_Pos = 0x16
	// Bit mask of RT22 field.
	EXTI_RTSR1_RT22_Msk = 0x400000
	// Bit RT22.
	EXTI_RTSR1_RT22 = 0x400000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT22_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT22_Enabled = 0x1
	// Position of RT0 field.
	EXTI_RTSR1_RT0_Pos = 0x0
	// Bit mask of RT0 field.
	EXTI_RTSR1_RT0_Msk = 0x1
	// Bit RT0.
	EXTI_RTSR1_RT0 = 0x1
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT0_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT0_Enabled = 0x1
	// Position of RT1 field.
	EXTI_RTSR1_RT1_Pos = 0x1
	// Bit mask of RT1 field.
	EXTI_RTSR1_RT1_Msk = 0x2
	// Bit RT1.
	EXTI_RTSR1_RT1 = 0x2
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT1_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT1_Enabled = 0x1
	// Position of RT2 field.
	EXTI_RTSR1_RT2_Pos = 0x2
	// Bit mask of RT2 field.
	EXTI_RTSR1_RT2_Msk = 0x4
	// Bit RT2.
	EXTI_RTSR1_RT2 = 0x4
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT2_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT2_Enabled = 0x1
	// Position of RT3 field.
	EXTI_RTSR1_RT3_Pos = 0x3
	// Bit mask of RT3 field.
	EXTI_RTSR1_RT3_Msk = 0x8
	// Bit RT3.
	EXTI_RTSR1_RT3 = 0x8
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT3_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT3_Enabled = 0x1
	// Position of RT4 field.
	EXTI_RTSR1_RT4_Pos = 0x4
	// Bit mask of RT4 field.
	EXTI_RTSR1_RT4_Msk = 0x10
	// Bit RT4.
	EXTI_RTSR1_RT4 = 0x10
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT4_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT4_Enabled = 0x1
	// Position of RT5 field.
	EXTI_RTSR1_RT5_Pos = 0x5
	// Bit mask of RT5 field.
	EXTI_RTSR1_RT5_Msk = 0x20
	// Bit RT5.
	EXTI_RTSR1_RT5 = 0x20
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT5_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT5_Enabled = 0x1
	// Position of RT6 field.
	EXTI_RTSR1_RT6_Pos = 0x6
	// Bit mask of RT6 field.
	EXTI_RTSR1_RT6_Msk = 0x40
	// Bit RT6.
	EXTI_RTSR1_RT6 = 0x40
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT6_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT6_Enabled = 0x1
	// Position of RT7 field.
	EXTI_RTSR1_RT7_Pos = 0x7
	// Bit mask of RT7 field.
	EXTI_RTSR1_RT7_Msk = 0x80
	// Bit RT7.
	EXTI_RTSR1_RT7 = 0x80
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT7_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT7_Enabled = 0x1
	// Position of RT8 field.
	EXTI_RTSR1_RT8_Pos = 0x8
	// Bit mask of RT8 field.
	EXTI_RTSR1_RT8_Msk = 0x100
	// Bit RT8.
	EXTI_RTSR1_RT8 = 0x100
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT8_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT8_Enabled = 0x1
	// Position of RT9 field.
	EXTI_RTSR1_RT9_Pos = 0x9
	// Bit mask of RT9 field.
	EXTI_RTSR1_RT9_Msk = 0x200
	// Bit RT9.
	EXTI_RTSR1_RT9 = 0x200
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT9_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT9_Enabled = 0x1
	// Position of RT10 field.
	EXTI_RTSR1_RT10_Pos = 0xa
	// Bit mask of RT10 field.
	EXTI_RTSR1_RT10_Msk = 0x400
	// Bit RT10.
	EXTI_RTSR1_RT10 = 0x400
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT10_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT10_Enabled = 0x1
	// Position of RT11 field.
	EXTI_RTSR1_RT11_Pos = 0xb
	// Bit mask of RT11 field.
	EXTI_RTSR1_RT11_Msk = 0x800
	// Bit RT11.
	EXTI_RTSR1_RT11 = 0x800
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT11_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT11_Enabled = 0x1
	// Position of RT12 field.
	EXTI_RTSR1_RT12_Pos = 0xc
	// Bit mask of RT12 field.
	EXTI_RTSR1_RT12_Msk = 0x1000
	// Bit RT12.
	EXTI_RTSR1_RT12 = 0x1000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT12_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT12_Enabled = 0x1
	// Position of RT13 field.
	EXTI_RTSR1_RT13_Pos = 0xd
	// Bit mask of RT13 field.
	EXTI_RTSR1_RT13_Msk = 0x2000
	// Bit RT13.
	EXTI_RTSR1_RT13 = 0x2000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT13_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT13_Enabled = 0x1
	// Position of RT14 field.
	EXTI_RTSR1_RT14_Pos = 0xe
	// Bit mask of RT14 field.
	EXTI_RTSR1_RT14_Msk = 0x4000
	// Bit RT14.
	EXTI_RTSR1_RT14 = 0x4000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT14_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT14_Enabled = 0x1
	// Position of RT15 field.
	EXTI_RTSR1_RT15_Pos = 0xf
	// Bit mask of RT15 field.
	EXTI_RTSR1_RT15_Msk = 0x8000
	// Bit RT15.
	EXTI_RTSR1_RT15 = 0x8000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT15_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT15_Enabled = 0x1
	// Position of RT16 field.
	EXTI_RTSR1_RT16_Pos = 0x10
	// Bit mask of RT16 field.
	EXTI_RTSR1_RT16_Msk = 0x10000
	// Bit RT16.
	EXTI_RTSR1_RT16 = 0x10000
	// Rising edge trigger is disabled
	EXTI_RTSR1_RT16_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_RT16_Enabled = 0x1

	// FTSR1: falling trigger selection register
	// Position of FT21 field.
	EXTI_FTSR1_FT21_Pos = 0x15
	// Bit mask of FT21 field.
	EXTI_FTSR1_FT21_Msk = 0x200000
	// Bit FT21.
	EXTI_FTSR1_FT21 = 0x200000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT21_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT21_Enabled = 0x1
	// Position of FT22 field.
	EXTI_FTSR1_FT22_Pos = 0x16
	// Bit mask of FT22 field.
	EXTI_FTSR1_FT22_Msk = 0x400000
	// Bit FT22.
	EXTI_FTSR1_FT22 = 0x400000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT22_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT22_Enabled = 0x1
	// Position of FT0 field.
	EXTI_FTSR1_FT0_Pos = 0x0
	// Bit mask of FT0 field.
	EXTI_FTSR1_FT0_Msk = 0x1
	// Bit FT0.
	EXTI_FTSR1_FT0 = 0x1
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT0_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT0_Enabled = 0x1
	// Position of FT1 field.
	EXTI_FTSR1_FT1_Pos = 0x1
	// Bit mask of FT1 field.
	EXTI_FTSR1_FT1_Msk = 0x2
	// Bit FT1.
	EXTI_FTSR1_FT1 = 0x2
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT1_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT1_Enabled = 0x1
	// Position of FT2 field.
	EXTI_FTSR1_FT2_Pos = 0x2
	// Bit mask of FT2 field.
	EXTI_FTSR1_FT2_Msk = 0x4
	// Bit FT2.
	EXTI_FTSR1_FT2 = 0x4
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT2_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT2_Enabled = 0x1
	// Position of FT3 field.
	EXTI_FTSR1_FT3_Pos = 0x3
	// Bit mask of FT3 field.
	EXTI_FTSR1_FT3_Msk = 0x8
	// Bit FT3.
	EXTI_FTSR1_FT3 = 0x8
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT3_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT3_Enabled = 0x1
	// Position of FT4 field.
	EXTI_FTSR1_FT4_Pos = 0x4
	// Bit mask of FT4 field.
	EXTI_FTSR1_FT4_Msk = 0x10
	// Bit FT4.
	EXTI_FTSR1_FT4 = 0x10
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT4_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT4_Enabled = 0x1
	// Position of FT5 field.
	EXTI_FTSR1_FT5_Pos = 0x5
	// Bit mask of FT5 field.
	EXTI_FTSR1_FT5_Msk = 0x20
	// Bit FT5.
	EXTI_FTSR1_FT5 = 0x20
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT5_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT5_Enabled = 0x1
	// Position of FT6 field.
	EXTI_FTSR1_FT6_Pos = 0x6
	// Bit mask of FT6 field.
	EXTI_FTSR1_FT6_Msk = 0x40
	// Bit FT6.
	EXTI_FTSR1_FT6 = 0x40
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT6_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT6_Enabled = 0x1
	// Position of FT7 field.
	EXTI_FTSR1_FT7_Pos = 0x7
	// Bit mask of FT7 field.
	EXTI_FTSR1_FT7_Msk = 0x80
	// Bit FT7.
	EXTI_FTSR1_FT7 = 0x80
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT7_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT7_Enabled = 0x1
	// Position of FT8 field.
	EXTI_FTSR1_FT8_Pos = 0x8
	// Bit mask of FT8 field.
	EXTI_FTSR1_FT8_Msk = 0x100
	// Bit FT8.
	EXTI_FTSR1_FT8 = 0x100
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT8_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT8_Enabled = 0x1
	// Position of FT9 field.
	EXTI_FTSR1_FT9_Pos = 0x9
	// Bit mask of FT9 field.
	EXTI_FTSR1_FT9_Msk = 0x200
	// Bit FT9.
	EXTI_FTSR1_FT9 = 0x200
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT9_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT9_Enabled = 0x1
	// Position of FT10 field.
	EXTI_FTSR1_FT10_Pos = 0xa
	// Bit mask of FT10 field.
	EXTI_FTSR1_FT10_Msk = 0x400
	// Bit FT10.
	EXTI_FTSR1_FT10 = 0x400
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT10_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT10_Enabled = 0x1
	// Position of FT11 field.
	EXTI_FTSR1_FT11_Pos = 0xb
	// Bit mask of FT11 field.
	EXTI_FTSR1_FT11_Msk = 0x800
	// Bit FT11.
	EXTI_FTSR1_FT11 = 0x800
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT11_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT11_Enabled = 0x1
	// Position of FT12 field.
	EXTI_FTSR1_FT12_Pos = 0xc
	// Bit mask of FT12 field.
	EXTI_FTSR1_FT12_Msk = 0x1000
	// Bit FT12.
	EXTI_FTSR1_FT12 = 0x1000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT12_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT12_Enabled = 0x1
	// Position of FT13 field.
	EXTI_FTSR1_FT13_Pos = 0xd
	// Bit mask of FT13 field.
	EXTI_FTSR1_FT13_Msk = 0x2000
	// Bit FT13.
	EXTI_FTSR1_FT13 = 0x2000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT13_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT13_Enabled = 0x1
	// Position of FT14 field.
	EXTI_FTSR1_FT14_Pos = 0xe
	// Bit mask of FT14 field.
	EXTI_FTSR1_FT14_Msk = 0x4000
	// Bit FT14.
	EXTI_FTSR1_FT14 = 0x4000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT14_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT14_Enabled = 0x1
	// Position of FT15 field.
	EXTI_FTSR1_FT15_Pos = 0xf
	// Bit mask of FT15 field.
	EXTI_FTSR1_FT15_Msk = 0x8000
	// Bit FT15.
	EXTI_FTSR1_FT15 = 0x8000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT15_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT15_Enabled = 0x1
	// Position of FT16 field.
	EXTI_FTSR1_FT16_Pos = 0x10
	// Bit mask of FT16 field.
	EXTI_FTSR1_FT16_Msk = 0x10000
	// Bit FT16.
	EXTI_FTSR1_FT16 = 0x10000
	// Falling edge trigger is disabled
	EXTI_FTSR1_FT16_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_FT16_Enabled = 0x1

	// SWIER1: software interrupt event register
	// Position of SWI21 field.
	EXTI_SWIER1_SWI21_Pos = 0x15
	// Bit mask of SWI21 field.
	EXTI_SWIER1_SWI21_Msk = 0x200000
	// Bit SWI21.
	EXTI_SWIER1_SWI21 = 0x200000
	// Generates an interrupt request
	EXTI_SWIER1_SWI21_Pend = 0x1
	// Position of SWI22 field.
	EXTI_SWIER1_SWI22_Pos = 0x16
	// Bit mask of SWI22 field.
	EXTI_SWIER1_SWI22_Msk = 0x400000
	// Bit SWI22.
	EXTI_SWIER1_SWI22 = 0x400000
	// Generates an interrupt request
	EXTI_SWIER1_SWI22_Pend = 0x1
	// Position of SWI0 field.
	EXTI_SWIER1_SWI0_Pos = 0x0
	// Bit mask of SWI0 field.
	EXTI_SWIER1_SWI0_Msk = 0x1
	// Bit SWI0.
	EXTI_SWIER1_SWI0 = 0x1
	// Generates an interrupt request
	EXTI_SWIER1_SWI0_Pend = 0x1
	// Position of SWI1 field.
	EXTI_SWIER1_SWI1_Pos = 0x1
	// Bit mask of SWI1 field.
	EXTI_SWIER1_SWI1_Msk = 0x2
	// Bit SWI1.
	EXTI_SWIER1_SWI1 = 0x2
	// Generates an interrupt request
	EXTI_SWIER1_SWI1_Pend = 0x1
	// Position of SWI2 field.
	EXTI_SWIER1_SWI2_Pos = 0x2
	// Bit mask of SWI2 field.
	EXTI_SWIER1_SWI2_Msk = 0x4
	// Bit SWI2.
	EXTI_SWIER1_SWI2 = 0x4
	// Generates an interrupt request
	EXTI_SWIER1_SWI2_Pend = 0x1
	// Position of SWI3 field.
	EXTI_SWIER1_SWI3_Pos = 0x3
	// Bit mask of SWI3 field.
	EXTI_SWIER1_SWI3_Msk = 0x8
	// Bit SWI3.
	EXTI_SWIER1_SWI3 = 0x8
	// Generates an interrupt request
	EXTI_SWIER1_SWI3_Pend = 0x1
	// Position of SWI4 field.
	EXTI_SWIER1_SWI4_Pos = 0x4
	// Bit mask of SWI4 field.
	EXTI_SWIER1_SWI4_Msk = 0x10
	// Bit SWI4.
	EXTI_SWIER1_SWI4 = 0x10
	// Generates an interrupt request
	EXTI_SWIER1_SWI4_Pend = 0x1
	// Position of SWI5 field.
	EXTI_SWIER1_SWI5_Pos = 0x5
	// Bit mask of SWI5 field.
	EXTI_SWIER1_SWI5_Msk = 0x20
	// Bit SWI5.
	EXTI_SWIER1_SWI5 = 0x20
	// Generates an interrupt request
	EXTI_SWIER1_SWI5_Pend = 0x1
	// Position of SWI6 field.
	EXTI_SWIER1_SWI6_Pos = 0x6
	// Bit mask of SWI6 field.
	EXTI_SWIER1_SWI6_Msk = 0x40
	// Bit SWI6.
	EXTI_SWIER1_SWI6 = 0x40
	// Generates an interrupt request
	EXTI_SWIER1_SWI6_Pend = 0x1
	// Position of SWI7 field.
	EXTI_SWIER1_SWI7_Pos = 0x7
	// Bit mask of SWI7 field.
	EXTI_SWIER1_SWI7_Msk = 0x80
	// Bit SWI7.
	EXTI_SWIER1_SWI7 = 0x80
	// Generates an interrupt request
	EXTI_SWIER1_SWI7_Pend = 0x1
	// Position of SWI8 field.
	EXTI_SWIER1_SWI8_Pos = 0x8
	// Bit mask of SWI8 field.
	EXTI_SWIER1_SWI8_Msk = 0x100
	// Bit SWI8.
	EXTI_SWIER1_SWI8 = 0x100
	// Generates an interrupt request
	EXTI_SWIER1_SWI8_Pend = 0x1
	// Position of SWI9 field.
	EXTI_SWIER1_SWI9_Pos = 0x9
	// Bit mask of SWI9 field.
	EXTI_SWIER1_SWI9_Msk = 0x200
	// Bit SWI9.
	EXTI_SWIER1_SWI9 = 0x200
	// Generates an interrupt request
	EXTI_SWIER1_SWI9_Pend = 0x1
	// Position of SWI10 field.
	EXTI_SWIER1_SWI10_Pos = 0xa
	// Bit mask of SWI10 field.
	EXTI_SWIER1_SWI10_Msk = 0x400
	// Bit SWI10.
	EXTI_SWIER1_SWI10 = 0x400
	// Generates an interrupt request
	EXTI_SWIER1_SWI10_Pend = 0x1
	// Position of SWI11 field.
	EXTI_SWIER1_SWI11_Pos = 0xb
	// Bit mask of SWI11 field.
	EXTI_SWIER1_SWI11_Msk = 0x800
	// Bit SWI11.
	EXTI_SWIER1_SWI11 = 0x800
	// Generates an interrupt request
	EXTI_SWIER1_SWI11_Pend = 0x1
	// Position of SWI12 field.
	EXTI_SWIER1_SWI12_Pos = 0xc
	// Bit mask of SWI12 field.
	EXTI_SWIER1_SWI12_Msk = 0x1000
	// Bit SWI12.
	EXTI_SWIER1_SWI12 = 0x1000
	// Generates an interrupt request
	EXTI_SWIER1_SWI12_Pend = 0x1
	// Position of SWI13 field.
	EXTI_SWIER1_SWI13_Pos = 0xd
	// Bit mask of SWI13 field.
	EXTI_SWIER1_SWI13_Msk = 0x2000
	// Bit SWI13.
	EXTI_SWIER1_SWI13 = 0x2000
	// Generates an interrupt request
	EXTI_SWIER1_SWI13_Pend = 0x1
	// Position of SWI14 field.
	EXTI_SWIER1_SWI14_Pos = 0xe
	// Bit mask of SWI14 field.
	EXTI_SWIER1_SWI14_Msk = 0x4000
	// Bit SWI14.
	EXTI_SWIER1_SWI14 = 0x4000
	// Generates an interrupt request
	EXTI_SWIER1_SWI14_Pend = 0x1
	// Position of SWI15 field.
	EXTI_SWIER1_SWI15_Pos = 0xf
	// Bit mask of SWI15 field.
	EXTI_SWIER1_SWI15_Msk = 0x8000
	// Bit SWI15.
	EXTI_SWIER1_SWI15 = 0x8000
	// Generates an interrupt request
	EXTI_SWIER1_SWI15_Pend = 0x1
	// Position of SWI16 field.
	EXTI_SWIER1_SWI16_Pos = 0x10
	// Bit mask of SWI16 field.
	EXTI_SWIER1_SWI16_Msk = 0x10000
	// Bit SWI16.
	EXTI_SWIER1_SWI16 = 0x10000
	// Generates an interrupt request
	EXTI_SWIER1_SWI16_Pend = 0x1

	// PR1: EXTI pending register
	// Position of PIF21 field.
	EXTI_PR1_PIF21_Pos = 0x15
	// Bit mask of PIF21 field.
	EXTI_PR1_PIF21_Msk = 0x200000
	// Bit PIF21.
	EXTI_PR1_PIF21 = 0x200000
	// No trigger request occurred
	EXTI_PR1_PIF21_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF21_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF21_Clear = 0x1
	// Position of PIF22 field.
	EXTI_PR1_PIF22_Pos = 0x16
	// Bit mask of PIF22 field.
	EXTI_PR1_PIF22_Msk = 0x400000
	// Bit PIF22.
	EXTI_PR1_PIF22 = 0x400000
	// No trigger request occurred
	EXTI_PR1_PIF22_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF22_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF22_Clear = 0x1
	// Position of PIF0 field.
	EXTI_PR1_PIF0_Pos = 0x0
	// Bit mask of PIF0 field.
	EXTI_PR1_PIF0_Msk = 0x1
	// Bit PIF0.
	EXTI_PR1_PIF0 = 0x1
	// No trigger request occurred
	EXTI_PR1_PIF0_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF0_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF0_Clear = 0x1
	// Position of PIF1 field.
	EXTI_PR1_PIF1_Pos = 0x1
	// Bit mask of PIF1 field.
	EXTI_PR1_PIF1_Msk = 0x2
	// Bit PIF1.
	EXTI_PR1_PIF1 = 0x2
	// No trigger request occurred
	EXTI_PR1_PIF1_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF1_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF1_Clear = 0x1
	// Position of PIF2 field.
	EXTI_PR1_PIF2_Pos = 0x2
	// Bit mask of PIF2 field.
	EXTI_PR1_PIF2_Msk = 0x4
	// Bit PIF2.
	EXTI_PR1_PIF2 = 0x4
	// No trigger request occurred
	EXTI_PR1_PIF2_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF2_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF2_Clear = 0x1
	// Position of PIF3 field.
	EXTI_PR1_PIF3_Pos = 0x3
	// Bit mask of PIF3 field.
	EXTI_PR1_PIF3_Msk = 0x8
	// Bit PIF3.
	EXTI_PR1_PIF3 = 0x8
	// No trigger request occurred
	EXTI_PR1_PIF3_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF3_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF3_Clear = 0x1
	// Position of PIF4 field.
	EXTI_PR1_PIF4_Pos = 0x4
	// Bit mask of PIF4 field.
	EXTI_PR1_PIF4_Msk = 0x10
	// Bit PIF4.
	EXTI_PR1_PIF4 = 0x10
	// No trigger request occurred
	EXTI_PR1_PIF4_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF4_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF4_Clear = 0x1
	// Position of PIF5 field.
	EXTI_PR1_PIF5_Pos = 0x5
	// Bit mask of PIF5 field.
	EXTI_PR1_PIF5_Msk = 0x20
	// Bit PIF5.
	EXTI_PR1_PIF5 = 0x20
	// No trigger request occurred
	EXTI_PR1_PIF5_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF5_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF5_Clear = 0x1
	// Position of PIF6 field.
	EXTI_PR1_PIF6_Pos = 0x6
	// Bit mask of PIF6 field.
	EXTI_PR1_PIF6_Msk = 0x40
	// Bit PIF6.
	EXTI_PR1_PIF6 = 0x40
	// No trigger request occurred
	EXTI_PR1_PIF6_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF6_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF6_Clear = 0x1
	// Position of PIF7 field.
	EXTI_PR1_PIF7_Pos = 0x7
	// Bit mask of PIF7 field.
	EXTI_PR1_PIF7_Msk = 0x80
	// Bit PIF7.
	EXTI_PR1_PIF7 = 0x80
	// No trigger request occurred
	EXTI_PR1_PIF7_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF7_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF7_Clear = 0x1
	// Position of PIF8 field.
	EXTI_PR1_PIF8_Pos = 0x8
	// Bit mask of PIF8 field.
	EXTI_PR1_PIF8_Msk = 0x100
	// Bit PIF8.
	EXTI_PR1_PIF8 = 0x100
	// No trigger request occurred
	EXTI_PR1_PIF8_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF8_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF8_Clear = 0x1
	// Position of PIF9 field.
	EXTI_PR1_PIF9_Pos = 0x9
	// Bit mask of PIF9 field.
	EXTI_PR1_PIF9_Msk = 0x200
	// Bit PIF9.
	EXTI_PR1_PIF9 = 0x200
	// No trigger request occurred
	EXTI_PR1_PIF9_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF9_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF9_Clear = 0x1
	// Position of PIF10 field.
	EXTI_PR1_PIF10_Pos = 0xa
	// Bit mask of PIF10 field.
	EXTI_PR1_PIF10_Msk = 0x400
	// Bit PIF10.
	EXTI_PR1_PIF10 = 0x400
	// No trigger request occurred
	EXTI_PR1_PIF10_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF10_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF10_Clear = 0x1
	// Position of PIF11 field.
	EXTI_PR1_PIF11_Pos = 0xb
	// Bit mask of PIF11 field.
	EXTI_PR1_PIF11_Msk = 0x800
	// Bit PIF11.
	EXTI_PR1_PIF11 = 0x800
	// No trigger request occurred
	EXTI_PR1_PIF11_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF11_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF11_Clear = 0x1
	// Position of PIF12 field.
	EXTI_PR1_PIF12_Pos = 0xc
	// Bit mask of PIF12 field.
	EXTI_PR1_PIF12_Msk = 0x1000
	// Bit PIF12.
	EXTI_PR1_PIF12 = 0x1000
	// No trigger request occurred
	EXTI_PR1_PIF12_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF12_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF12_Clear = 0x1
	// Position of PIF13 field.
	EXTI_PR1_PIF13_Pos = 0xd
	// Bit mask of PIF13 field.
	EXTI_PR1_PIF13_Msk = 0x2000
	// Bit PIF13.
	EXTI_PR1_PIF13 = 0x2000
	// No trigger request occurred
	EXTI_PR1_PIF13_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF13_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF13_Clear = 0x1
	// Position of PIF14 field.
	EXTI_PR1_PIF14_Pos = 0xe
	// Bit mask of PIF14 field.
	EXTI_PR1_PIF14_Msk = 0x4000
	// Bit PIF14.
	EXTI_PR1_PIF14 = 0x4000
	// No trigger request occurred
	EXTI_PR1_PIF14_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF14_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF14_Clear = 0x1
	// Position of PIF15 field.
	EXTI_PR1_PIF15_Pos = 0xf
	// Bit mask of PIF15 field.
	EXTI_PR1_PIF15_Msk = 0x8000
	// Bit PIF15.
	EXTI_PR1_PIF15 = 0x8000
	// No trigger request occurred
	EXTI_PR1_PIF15_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF15_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF15_Clear = 0x1
	// Position of PIF16 field.
	EXTI_PR1_PIF16_Pos = 0x10
	// Bit mask of PIF16 field.
	EXTI_PR1_PIF16_Msk = 0x10000
	// Bit PIF16.
	EXTI_PR1_PIF16 = 0x10000
	// No trigger request occurred
	EXTI_PR1_PIF16_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PIF16_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PIF16_Clear = 0x1

	// RTSR2: rising trigger selection register
	// Position of RT34 field.
	EXTI_RTSR2_RT34_Pos = 0x2
	// Bit mask of RT34 field.
	EXTI_RTSR2_RT34_Msk = 0x4
	// Bit RT34.
	EXTI_RTSR2_RT34 = 0x4
	// Rising edge trigger is disabled
	EXTI_RTSR2_RT34_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_RT34_Enabled = 0x1
	// Position of RT45 field.
	EXTI_RTSR2_RT45_Pos = 0xd
	// Bit mask of RT45 field.
	EXTI_RTSR2_RT45_Msk = 0x2000
	// Bit RT45.
	EXTI_RTSR2_RT45 = 0x2000
	// Rising edge trigger is disabled
	EXTI_RTSR2_RT45_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_RT45_Enabled = 0x1

	// FTSR2: falling trigger selection register
	// Position of FT34 field.
	EXTI_FTSR2_FT34_Pos = 0x2
	// Bit mask of FT34 field.
	EXTI_FTSR2_FT34_Msk = 0x4
	// Bit FT34.
	EXTI_FTSR2_FT34 = 0x4
	// Falling edge trigger is disabled
	EXTI_FTSR2_FT34_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_FT34_Enabled = 0x1
	// Position of FT45 field.
	EXTI_FTSR2_FT45_Pos = 0xd
	// Bit mask of FT45 field.
	EXTI_FTSR2_FT45_Msk = 0x2000
	// Bit FT45.
	EXTI_FTSR2_FT45 = 0x2000
	// Falling edge trigger is disabled
	EXTI_FTSR2_FT45_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_FT45_Enabled = 0x1

	// SWIER2: software interrupt event register
	// Position of SWI34 field.
	EXTI_SWIER2_SWI34_Pos = 0x2
	// Bit mask of SWI34 field.
	EXTI_SWIER2_SWI34_Msk = 0x4
	// Bit SWI34.
	EXTI_SWIER2_SWI34 = 0x4
	// Generates an interrupt request
	EXTI_SWIER2_SWI34_Pend = 0x1
	// Position of SWI45 field.
	EXTI_SWIER2_SWI45_Pos = 0xd
	// Bit mask of SWI45 field.
	EXTI_SWIER2_SWI45_Msk = 0x2000
	// Bit SWI45.
	EXTI_SWIER2_SWI45 = 0x2000
	// Generates an interrupt request
	EXTI_SWIER2_SWI45_Pend = 0x1

	// PR2: pending register
	// Position of PIF34 field.
	EXTI_PR2_PIF34_Pos = 0x2
	// Bit mask of PIF34 field.
	EXTI_PR2_PIF34_Msk = 0x4
	// Bit PIF34.
	EXTI_PR2_PIF34 = 0x4
	// No trigger request occurred
	EXTI_PR2_PIF34_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR2_PIF34_Pending = 0x1
	// Clears pending bit
	EXTI_PR2_PIF34_Clear = 0x1
	// Position of PIF45 field.
	EXTI_PR2_PIF45_Pos = 0xd
	// Bit mask of PIF45 field.
	EXTI_PR2_PIF45_Msk = 0x2000
	// Bit PIF45.
	EXTI_PR2_PIF45 = 0x2000
	// No trigger request occurred
	EXTI_PR2_PIF45_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR2_PIF45_Pending = 0x1
	// Clears pending bit
	EXTI_PR2_PIF45_Clear = 0x1

	// C1IMR1: interrupt mask register
	// Position of IM0 field.
	EXTI_C1IMR1_IM0_Pos = 0x0
	// Bit mask of IM0 field.
	EXTI_C1IMR1_IM0_Msk = 0x1
	// Bit IM0.
	EXTI_C1IMR1_IM0 = 0x1
	// Interrupt request line is masked
	EXTI_C1IMR1_IM0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM0_Unmasked = 0x1
	// Position of IM1 field.
	EXTI_C1IMR1_IM1_Pos = 0x1
	// Bit mask of IM1 field.
	EXTI_C1IMR1_IM1_Msk = 0x2
	// Bit IM1.
	EXTI_C1IMR1_IM1 = 0x2
	// Interrupt request line is masked
	EXTI_C1IMR1_IM1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM1_Unmasked = 0x1
	// Position of IM2 field.
	EXTI_C1IMR1_IM2_Pos = 0x2
	// Bit mask of IM2 field.
	EXTI_C1IMR1_IM2_Msk = 0x4
	// Bit IM2.
	EXTI_C1IMR1_IM2 = 0x4
	// Interrupt request line is masked
	EXTI_C1IMR1_IM2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM2_Unmasked = 0x1
	// Position of IM3 field.
	EXTI_C1IMR1_IM3_Pos = 0x3
	// Bit mask of IM3 field.
	EXTI_C1IMR1_IM3_Msk = 0x8
	// Bit IM3.
	EXTI_C1IMR1_IM3 = 0x8
	// Interrupt request line is masked
	EXTI_C1IMR1_IM3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM3_Unmasked = 0x1
	// Position of IM4 field.
	EXTI_C1IMR1_IM4_Pos = 0x4
	// Bit mask of IM4 field.
	EXTI_C1IMR1_IM4_Msk = 0x10
	// Bit IM4.
	EXTI_C1IMR1_IM4 = 0x10
	// Interrupt request line is masked
	EXTI_C1IMR1_IM4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM4_Unmasked = 0x1
	// Position of IM5 field.
	EXTI_C1IMR1_IM5_Pos = 0x5
	// Bit mask of IM5 field.
	EXTI_C1IMR1_IM5_Msk = 0x20
	// Bit IM5.
	EXTI_C1IMR1_IM5 = 0x20
	// Interrupt request line is masked
	EXTI_C1IMR1_IM5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM5_Unmasked = 0x1
	// Position of IM6 field.
	EXTI_C1IMR1_IM6_Pos = 0x6
	// Bit mask of IM6 field.
	EXTI_C1IMR1_IM6_Msk = 0x40
	// Bit IM6.
	EXTI_C1IMR1_IM6 = 0x40
	// Interrupt request line is masked
	EXTI_C1IMR1_IM6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM6_Unmasked = 0x1
	// Position of IM7 field.
	EXTI_C1IMR1_IM7_Pos = 0x7
	// Bit mask of IM7 field.
	EXTI_C1IMR1_IM7_Msk = 0x80
	// Bit IM7.
	EXTI_C1IMR1_IM7 = 0x80
	// Interrupt request line is masked
	EXTI_C1IMR1_IM7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM7_Unmasked = 0x1
	// Position of IM8 field.
	EXTI_C1IMR1_IM8_Pos = 0x8
	// Bit mask of IM8 field.
	EXTI_C1IMR1_IM8_Msk = 0x100
	// Bit IM8.
	EXTI_C1IMR1_IM8 = 0x100
	// Interrupt request line is masked
	EXTI_C1IMR1_IM8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM8_Unmasked = 0x1
	// Position of IM9 field.
	EXTI_C1IMR1_IM9_Pos = 0x9
	// Bit mask of IM9 field.
	EXTI_C1IMR1_IM9_Msk = 0x200
	// Bit IM9.
	EXTI_C1IMR1_IM9 = 0x200
	// Interrupt request line is masked
	EXTI_C1IMR1_IM9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM9_Unmasked = 0x1
	// Position of IM10 field.
	EXTI_C1IMR1_IM10_Pos = 0xa
	// Bit mask of IM10 field.
	EXTI_C1IMR1_IM10_Msk = 0x400
	// Bit IM10.
	EXTI_C1IMR1_IM10 = 0x400
	// Interrupt request line is masked
	EXTI_C1IMR1_IM10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM10_Unmasked = 0x1
	// Position of IM11 field.
	EXTI_C1IMR1_IM11_Pos = 0xb
	// Bit mask of IM11 field.
	EXTI_C1IMR1_IM11_Msk = 0x800
	// Bit IM11.
	EXTI_C1IMR1_IM11 = 0x800
	// Interrupt request line is masked
	EXTI_C1IMR1_IM11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM11_Unmasked = 0x1
	// Position of IM12 field.
	EXTI_C1IMR1_IM12_Pos = 0xc
	// Bit mask of IM12 field.
	EXTI_C1IMR1_IM12_Msk = 0x1000
	// Bit IM12.
	EXTI_C1IMR1_IM12 = 0x1000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM12_Unmasked = 0x1
	// Position of IM13 field.
	EXTI_C1IMR1_IM13_Pos = 0xd
	// Bit mask of IM13 field.
	EXTI_C1IMR1_IM13_Msk = 0x2000
	// Bit IM13.
	EXTI_C1IMR1_IM13 = 0x2000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM13_Unmasked = 0x1
	// Position of IM14 field.
	EXTI_C1IMR1_IM14_Pos = 0xe
	// Bit mask of IM14 field.
	EXTI_C1IMR1_IM14_Msk = 0x4000
	// Bit IM14.
	EXTI_C1IMR1_IM14 = 0x4000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM14_Unmasked = 0x1
	// Position of IM15 field.
	EXTI_C1IMR1_IM15_Pos = 0xf
	// Bit mask of IM15 field.
	EXTI_C1IMR1_IM15_Msk = 0x8000
	// Bit IM15.
	EXTI_C1IMR1_IM15 = 0x8000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM15_Unmasked = 0x1
	// Position of IM16 field.
	EXTI_C1IMR1_IM16_Pos = 0x10
	// Bit mask of IM16 field.
	EXTI_C1IMR1_IM16_Msk = 0x10000
	// Bit IM16.
	EXTI_C1IMR1_IM16 = 0x10000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM16_Unmasked = 0x1
	// Position of IM17 field.
	EXTI_C1IMR1_IM17_Pos = 0x11
	// Bit mask of IM17 field.
	EXTI_C1IMR1_IM17_Msk = 0x20000
	// Bit IM17.
	EXTI_C1IMR1_IM17 = 0x20000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM17_Unmasked = 0x1
	// Position of IM18 field.
	EXTI_C1IMR1_IM18_Pos = 0x12
	// Bit mask of IM18 field.
	EXTI_C1IMR1_IM18_Msk = 0x40000
	// Bit IM18.
	EXTI_C1IMR1_IM18 = 0x40000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM18_Unmasked = 0x1
	// Position of IM19 field.
	EXTI_C1IMR1_IM19_Pos = 0x13
	// Bit mask of IM19 field.
	EXTI_C1IMR1_IM19_Msk = 0x80000
	// Bit IM19.
	EXTI_C1IMR1_IM19 = 0x80000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM19_Unmasked = 0x1
	// Position of IM20 field.
	EXTI_C1IMR1_IM20_Pos = 0x14
	// Bit mask of IM20 field.
	EXTI_C1IMR1_IM20_Msk = 0x100000
	// Bit IM20.
	EXTI_C1IMR1_IM20 = 0x100000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM20_Unmasked = 0x1
	// Position of IM21 field.
	EXTI_C1IMR1_IM21_Pos = 0x15
	// Bit mask of IM21 field.
	EXTI_C1IMR1_IM21_Msk = 0x200000
	// Bit IM21.
	EXTI_C1IMR1_IM21 = 0x200000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM21_Unmasked = 0x1
	// Position of IM22 field.
	EXTI_C1IMR1_IM22_Pos = 0x16
	// Bit mask of IM22 field.
	EXTI_C1IMR1_IM22_Msk = 0x400000
	// Bit IM22.
	EXTI_C1IMR1_IM22 = 0x400000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM22_Unmasked = 0x1
	// Position of IM23 field.
	EXTI_C1IMR1_IM23_Pos = 0x17
	// Bit mask of IM23 field.
	EXTI_C1IMR1_IM23_Msk = 0x800000
	// Bit IM23.
	EXTI_C1IMR1_IM23 = 0x800000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM23_Unmasked = 0x1
	// Position of IM24 field.
	EXTI_C1IMR1_IM24_Pos = 0x18
	// Bit mask of IM24 field.
	EXTI_C1IMR1_IM24_Msk = 0x1000000
	// Bit IM24.
	EXTI_C1IMR1_IM24 = 0x1000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM24_Unmasked = 0x1
	// Position of IM25 field.
	EXTI_C1IMR1_IM25_Pos = 0x19
	// Bit mask of IM25 field.
	EXTI_C1IMR1_IM25_Msk = 0x2000000
	// Bit IM25.
	EXTI_C1IMR1_IM25 = 0x2000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM25_Unmasked = 0x1
	// Position of IM26 field.
	EXTI_C1IMR1_IM26_Pos = 0x1a
	// Bit mask of IM26 field.
	EXTI_C1IMR1_IM26_Msk = 0x4000000
	// Bit IM26.
	EXTI_C1IMR1_IM26 = 0x4000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM26_Unmasked = 0x1
	// Position of IM27 field.
	EXTI_C1IMR1_IM27_Pos = 0x1b
	// Bit mask of IM27 field.
	EXTI_C1IMR1_IM27_Msk = 0x8000000
	// Bit IM27.
	EXTI_C1IMR1_IM27 = 0x8000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM27_Unmasked = 0x1
	// Position of IM28 field.
	EXTI_C1IMR1_IM28_Pos = 0x1c
	// Bit mask of IM28 field.
	EXTI_C1IMR1_IM28_Msk = 0x10000000
	// Bit IM28.
	EXTI_C1IMR1_IM28 = 0x10000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM28_Unmasked = 0x1
	// Position of IM29 field.
	EXTI_C1IMR1_IM29_Pos = 0x1d
	// Bit mask of IM29 field.
	EXTI_C1IMR1_IM29_Msk = 0x20000000
	// Bit IM29.
	EXTI_C1IMR1_IM29 = 0x20000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM29_Unmasked = 0x1
	// Position of IM30 field.
	EXTI_C1IMR1_IM30_Pos = 0x1e
	// Bit mask of IM30 field.
	EXTI_C1IMR1_IM30_Msk = 0x40000000
	// Bit IM30.
	EXTI_C1IMR1_IM30 = 0x40000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM30_Unmasked = 0x1
	// Position of IM31 field.
	EXTI_C1IMR1_IM31_Pos = 0x1f
	// Bit mask of IM31 field.
	EXTI_C1IMR1_IM31_Msk = 0x80000000
	// Bit IM31.
	EXTI_C1IMR1_IM31 = 0x80000000
	// Interrupt request line is masked
	EXTI_C1IMR1_IM31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR1_IM31_Unmasked = 0x1

	// EMR1: event mask register
	// Position of EM0 field.
	EXTI_EMR1_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	EXTI_EMR1_EM0_Msk = 0x1
	// Bit EM0.
	EXTI_EMR1_EM0 = 0x1
	// Interrupt request line is masked
	EXTI_EMR1_EM0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM0_Unmasked = 0x1
	// Position of EM1 field.
	EXTI_EMR1_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	EXTI_EMR1_EM1_Msk = 0x2
	// Bit EM1.
	EXTI_EMR1_EM1 = 0x2
	// Interrupt request line is masked
	EXTI_EMR1_EM1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM1_Unmasked = 0x1
	// Position of EM2 field.
	EXTI_EMR1_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	EXTI_EMR1_EM2_Msk = 0x4
	// Bit EM2.
	EXTI_EMR1_EM2 = 0x4
	// Interrupt request line is masked
	EXTI_EMR1_EM2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM2_Unmasked = 0x1
	// Position of EM3 field.
	EXTI_EMR1_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	EXTI_EMR1_EM3_Msk = 0x8
	// Bit EM3.
	EXTI_EMR1_EM3 = 0x8
	// Interrupt request line is masked
	EXTI_EMR1_EM3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM3_Unmasked = 0x1
	// Position of EM4 field.
	EXTI_EMR1_EM4_Pos = 0x4
	// Bit mask of EM4 field.
	EXTI_EMR1_EM4_Msk = 0x10
	// Bit EM4.
	EXTI_EMR1_EM4 = 0x10
	// Interrupt request line is masked
	EXTI_EMR1_EM4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM4_Unmasked = 0x1
	// Position of EM5 field.
	EXTI_EMR1_EM5_Pos = 0x5
	// Bit mask of EM5 field.
	EXTI_EMR1_EM5_Msk = 0x20
	// Bit EM5.
	EXTI_EMR1_EM5 = 0x20
	// Interrupt request line is masked
	EXTI_EMR1_EM5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM5_Unmasked = 0x1
	// Position of EM6 field.
	EXTI_EMR1_EM6_Pos = 0x6
	// Bit mask of EM6 field.
	EXTI_EMR1_EM6_Msk = 0x40
	// Bit EM6.
	EXTI_EMR1_EM6 = 0x40
	// Interrupt request line is masked
	EXTI_EMR1_EM6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM6_Unmasked = 0x1
	// Position of EM7 field.
	EXTI_EMR1_EM7_Pos = 0x7
	// Bit mask of EM7 field.
	EXTI_EMR1_EM7_Msk = 0x80
	// Bit EM7.
	EXTI_EMR1_EM7 = 0x80
	// Interrupt request line is masked
	EXTI_EMR1_EM7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM7_Unmasked = 0x1
	// Position of EM8 field.
	EXTI_EMR1_EM8_Pos = 0x8
	// Bit mask of EM8 field.
	EXTI_EMR1_EM8_Msk = 0x100
	// Bit EM8.
	EXTI_EMR1_EM8 = 0x100
	// Interrupt request line is masked
	EXTI_EMR1_EM8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM8_Unmasked = 0x1
	// Position of EM9 field.
	EXTI_EMR1_EM9_Pos = 0x9
	// Bit mask of EM9 field.
	EXTI_EMR1_EM9_Msk = 0x200
	// Bit EM9.
	EXTI_EMR1_EM9 = 0x200
	// Interrupt request line is masked
	EXTI_EMR1_EM9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM9_Unmasked = 0x1
	// Position of EM10 field.
	EXTI_EMR1_EM10_Pos = 0xa
	// Bit mask of EM10 field.
	EXTI_EMR1_EM10_Msk = 0x400
	// Bit EM10.
	EXTI_EMR1_EM10 = 0x400
	// Interrupt request line is masked
	EXTI_EMR1_EM10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM10_Unmasked = 0x1
	// Position of EM11 field.
	EXTI_EMR1_EM11_Pos = 0xb
	// Bit mask of EM11 field.
	EXTI_EMR1_EM11_Msk = 0x800
	// Bit EM11.
	EXTI_EMR1_EM11 = 0x800
	// Interrupt request line is masked
	EXTI_EMR1_EM11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM11_Unmasked = 0x1
	// Position of EM12 field.
	EXTI_EMR1_EM12_Pos = 0xc
	// Bit mask of EM12 field.
	EXTI_EMR1_EM12_Msk = 0x1000
	// Bit EM12.
	EXTI_EMR1_EM12 = 0x1000
	// Interrupt request line is masked
	EXTI_EMR1_EM12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM12_Unmasked = 0x1
	// Position of EM13 field.
	EXTI_EMR1_EM13_Pos = 0xd
	// Bit mask of EM13 field.
	EXTI_EMR1_EM13_Msk = 0x2000
	// Bit EM13.
	EXTI_EMR1_EM13 = 0x2000
	// Interrupt request line is masked
	EXTI_EMR1_EM13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM13_Unmasked = 0x1
	// Position of EM14 field.
	EXTI_EMR1_EM14_Pos = 0xe
	// Bit mask of EM14 field.
	EXTI_EMR1_EM14_Msk = 0x4000
	// Bit EM14.
	EXTI_EMR1_EM14 = 0x4000
	// Interrupt request line is masked
	EXTI_EMR1_EM14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM14_Unmasked = 0x1
	// Position of EM15 field.
	EXTI_EMR1_EM15_Pos = 0xf
	// Bit mask of EM15 field.
	EXTI_EMR1_EM15_Msk = 0x8000
	// Bit EM15.
	EXTI_EMR1_EM15 = 0x8000
	// Interrupt request line is masked
	EXTI_EMR1_EM15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM15_Unmasked = 0x1
	// Position of EM17 field.
	EXTI_EMR1_EM17_Pos = 0x11
	// Bit mask of EM17 field.
	EXTI_EMR1_EM17_Msk = 0x20000
	// Bit EM17.
	EXTI_EMR1_EM17 = 0x20000
	// Interrupt request line is masked
	EXTI_EMR1_EM17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM17_Unmasked = 0x1
	// Position of EM18 field.
	EXTI_EMR1_EM18_Pos = 0x12
	// Bit mask of EM18 field.
	EXTI_EMR1_EM18_Msk = 0x40000
	// Bit EM18.
	EXTI_EMR1_EM18 = 0x40000
	// Interrupt request line is masked
	EXTI_EMR1_EM18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM18_Unmasked = 0x1
	// Position of EM19 field.
	EXTI_EMR1_EM19_Pos = 0x13
	// Bit mask of EM19 field.
	EXTI_EMR1_EM19_Msk = 0x80000
	// Bit EM19.
	EXTI_EMR1_EM19 = 0x80000
	// Interrupt request line is masked
	EXTI_EMR1_EM19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM19_Unmasked = 0x1
	// Position of EM20 field.
	EXTI_EMR1_EM20_Pos = 0x14
	// Bit mask of EM20 field.
	EXTI_EMR1_EM20_Msk = 0x100000
	// Bit EM20.
	EXTI_EMR1_EM20 = 0x100000
	// Interrupt request line is masked
	EXTI_EMR1_EM20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM20_Unmasked = 0x1
	// Position of EM21 field.
	EXTI_EMR1_EM21_Pos = 0x15
	// Bit mask of EM21 field.
	EXTI_EMR1_EM21_Msk = 0x200000
	// Bit EM21.
	EXTI_EMR1_EM21 = 0x200000
	// Interrupt request line is masked
	EXTI_EMR1_EM21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM21_Unmasked = 0x1
	// Position of EM22 field.
	EXTI_EMR1_EM22_Pos = 0x16
	// Bit mask of EM22 field.
	EXTI_EMR1_EM22_Msk = 0x400000
	// Bit EM22.
	EXTI_EMR1_EM22 = 0x400000
	// Interrupt request line is masked
	EXTI_EMR1_EM22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM22_Unmasked = 0x1

	// C1IMR2: interrupt mask register
	// Position of IM34 field.
	EXTI_C1IMR2_IM34_Pos = 0x2
	// Bit mask of IM34 field.
	EXTI_C1IMR2_IM34_Msk = 0x4
	// Bit IM34.
	EXTI_C1IMR2_IM34 = 0x4
	// Interrupt request line is masked
	EXTI_C1IMR2_IM34_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM34_Unmasked = 0x1
	// Position of IM38 field.
	EXTI_C1IMR2_IM38_Pos = 0x6
	// Bit mask of IM38 field.
	EXTI_C1IMR2_IM38_Msk = 0x40
	// Bit IM38.
	EXTI_C1IMR2_IM38 = 0x40
	// Interrupt request line is masked
	EXTI_C1IMR2_IM38_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM38_Unmasked = 0x1
	// Position of IM42 field.
	EXTI_C1IMR2_IM42_Pos = 0xa
	// Bit mask of IM42 field.
	EXTI_C1IMR2_IM42_Msk = 0x400
	// Bit IM42.
	EXTI_C1IMR2_IM42 = 0x400
	// Interrupt request line is masked
	EXTI_C1IMR2_IM42_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM42_Unmasked = 0x1
	// Position of IM43 field.
	EXTI_C1IMR2_IM43_Pos = 0xb
	// Bit mask of IM43 field.
	EXTI_C1IMR2_IM43_Msk = 0x800
	// Bit IM43.
	EXTI_C1IMR2_IM43 = 0x800
	// Interrupt request line is masked
	EXTI_C1IMR2_IM43_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM43_Unmasked = 0x1
	// Position of IM44 field.
	EXTI_C1IMR2_IM44_Pos = 0xc
	// Bit mask of IM44 field.
	EXTI_C1IMR2_IM44_Msk = 0x1000
	// Bit IM44.
	EXTI_C1IMR2_IM44 = 0x1000
	// Interrupt request line is masked
	EXTI_C1IMR2_IM44_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM44_Unmasked = 0x1
	// Position of IM45 field.
	EXTI_C1IMR2_IM45_Pos = 0xd
	// Bit mask of IM45 field.
	EXTI_C1IMR2_IM45_Msk = 0x2000
	// Bit IM45.
	EXTI_C1IMR2_IM45 = 0x2000
	// Interrupt request line is masked
	EXTI_C1IMR2_IM45_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM45_Unmasked = 0x1
	// Position of IM46 field.
	EXTI_C1IMR2_IM46_Pos = 0xe
	// Bit mask of IM46 field.
	EXTI_C1IMR2_IM46_Msk = 0x4000
	// Bit IM46.
	EXTI_C1IMR2_IM46 = 0x4000
	// Interrupt request line is masked
	EXTI_C1IMR2_IM46_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_C1IMR2_IM46_Unmasked = 0x1
)

// Constants for FLASH: Flash
const (
	// ACR: Access control register
	// Position of LATENCY field.
	Flash_ACR_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	Flash_ACR_LATENCY_Msk = 0x7
	// 0 wait states
	Flash_ACR_LATENCY_WS0 = 0x0
	// 1 wait states
	Flash_ACR_LATENCY_WS1 = 0x1
	// 2 wait states
	Flash_ACR_LATENCY_WS2 = 0x2
	// Position of PRFTEN field.
	Flash_ACR_PRFTEN_Pos = 0x8
	// Bit mask of PRFTEN field.
	Flash_ACR_PRFTEN_Msk = 0x100
	// Bit PRFTEN.
	Flash_ACR_PRFTEN = 0x100
	// Prefetch is disabled
	Flash_ACR_PRFTEN_Disabled = 0x0
	// Prefetch is enabled
	Flash_ACR_PRFTEN_Enabled = 0x1
	// Position of ICEN field.
	Flash_ACR_ICEN_Pos = 0x9
	// Bit mask of ICEN field.
	Flash_ACR_ICEN_Msk = 0x200
	// Bit ICEN.
	Flash_ACR_ICEN = 0x200
	// Instruction cache is disabled
	Flash_ACR_ICEN_Disabled = 0x0
	// Instruction cache is enabled
	Flash_ACR_ICEN_Enabled = 0x1
	// Position of DCEN field.
	Flash_ACR_DCEN_Pos = 0xa
	// Bit mask of DCEN field.
	Flash_ACR_DCEN_Msk = 0x400
	// Bit DCEN.
	Flash_ACR_DCEN = 0x400
	// Data cache is disabled
	Flash_ACR_DCEN_Disabled = 0x0
	// Data cache is enabled
	Flash_ACR_DCEN_Enabled = 0x1
	// Position of ICRST field.
	Flash_ACR_ICRST_Pos = 0xb
	// Bit mask of ICRST field.
	Flash_ACR_ICRST_Msk = 0x800
	// Bit ICRST.
	Flash_ACR_ICRST = 0x800
	// Instruction cache is not reset
	Flash_ACR_ICRST_NotReset = 0x0
	// Instruction cache is reset
	Flash_ACR_ICRST_Reset = 0x1
	// Position of DCRST field.
	Flash_ACR_DCRST_Pos = 0xc
	// Bit mask of DCRST field.
	Flash_ACR_DCRST_Msk = 0x1000
	// Bit DCRST.
	Flash_ACR_DCRST = 0x1000
	// Data cache is not reset
	Flash_ACR_DCRST_NotReset = 0x0
	// Data cache is reset
	Flash_ACR_DCRST_Reset = 0x1
	// Position of PES field.
	Flash_ACR_PES_Pos = 0xf
	// Bit mask of PES field.
	Flash_ACR_PES_Msk = 0x8000
	// Bit PES.
	Flash_ACR_PES = 0x8000
	// Flash program and erase operations granted
	Flash_ACR_PES_Granted = 0x0
	// Any new Flash program and erase operation is suspended until this bit is cleared. The PESD bit in FLASH_SR is set when PES bit in FLASH_ACR is set
	Flash_ACR_PES_Suspended = 0x1
	// Position of EMPTY field.
	Flash_ACR_EMPTY_Pos = 0x10
	// Bit mask of EMPTY field.
	Flash_ACR_EMPTY_Msk = 0x10000
	// Bit EMPTY.
	Flash_ACR_EMPTY = 0x10000
	// User Flash programmend
	Flash_ACR_EMPTY_Programmed = 0x0
	// User Flash empty
	Flash_ACR_EMPTY_Empty = 0x1

	// KEYR: Flash key register
	// Position of KEY field.
	Flash_KEYR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	Flash_KEYR_KEY_Msk = 0xffffffff

	// OPTKEYR: Option byte key register
	// Position of OPTKEY field.
	Flash_OPTKEYR_OPTKEY_Pos = 0x0
	// Bit mask of OPTKEY field.
	Flash_OPTKEYR_OPTKEY_Msk = 0xffffffff

	// SR: Status register
	// Position of EOP field.
	Flash_SR_EOP_Pos = 0x0
	// Bit mask of EOP field.
	Flash_SR_EOP_Msk = 0x1
	// Bit EOP.
	Flash_SR_EOP = 0x1
	// No EOP operation occurred
	Flash_SR_EOP_NoEvent = 0x0
	// An EOP event occurred
	Flash_SR_EOP_Event = 0x1
	// Clear the flag
	Flash_SR_EOP_Clear = 0x1
	// Position of OPERR field.
	Flash_SR_OPERR_Pos = 0x1
	// Bit mask of OPERR field.
	Flash_SR_OPERR_Msk = 0x2
	// Bit OPERR.
	Flash_SR_OPERR = 0x2
	// No memory opreation error happened
	Flash_SR_OPERR_NoError = 0x0
	// Memory operation error happened
	Flash_SR_OPERR_Error = 0x1
	// Clear the flag
	Flash_SR_OPERR_Clear = 0x1
	// Position of PROGERR field.
	Flash_SR_PROGERR_Pos = 0x3
	// Bit mask of PROGERR field.
	Flash_SR_PROGERR_Msk = 0x8
	// Bit PROGERR.
	Flash_SR_PROGERR = 0x8
	// No size programming error happened
	Flash_SR_PROGERR_NoError = 0x0
	// Programming error happened
	Flash_SR_PROGERR_Error = 0x1
	// Clear the flag
	Flash_SR_PROGERR_Clear = 0x1
	// Position of WRPERR field.
	Flash_SR_WRPERR_Pos = 0x4
	// Bit mask of WRPERR field.
	Flash_SR_WRPERR_Msk = 0x10
	// Bit WRPERR.
	Flash_SR_WRPERR = 0x10
	// No write protection error happened
	Flash_SR_WRPERR_NoError = 0x0
	// Write protection error happened
	Flash_SR_WRPERR_Error = 0x1
	// Clear the flag
	Flash_SR_WRPERR_Clear = 0x1
	// Position of PGAERR field.
	Flash_SR_PGAERR_Pos = 0x5
	// Bit mask of PGAERR field.
	Flash_SR_PGAERR_Msk = 0x20
	// Bit PGAERR.
	Flash_SR_PGAERR = 0x20
	// No programming alignment error happened
	Flash_SR_PGAERR_NoError = 0x0
	// Programming alignment error happened
	Flash_SR_PGAERR_Error = 0x1
	// Clear the flag
	Flash_SR_PGAERR_Clear = 0x1
	// Position of SIZERR field.
	Flash_SR_SIZERR_Pos = 0x6
	// Bit mask of SIZERR field.
	Flash_SR_SIZERR_Msk = 0x40
	// Bit SIZERR.
	Flash_SR_SIZERR = 0x40
	// No size error happened
	Flash_SR_SIZERR_NoError = 0x0
	// Size error happened
	Flash_SR_SIZERR_Error = 0x1
	// Clear the flag
	Flash_SR_SIZERR_Clear = 0x1
	// Position of PGSERR field.
	Flash_SR_PGSERR_Pos = 0x7
	// Bit mask of PGSERR field.
	Flash_SR_PGSERR_Msk = 0x80
	// Bit PGSERR.
	Flash_SR_PGSERR = 0x80
	// No fast programming sequence error happened
	Flash_SR_PGSERR_NoError = 0x0
	// Fast programming sequence error happened
	Flash_SR_PGSERR_Error = 0x1
	// Clear the flag
	Flash_SR_PGSERR_Clear = 0x1
	// Position of MISSERR field.
	Flash_SR_MISSERR_Pos = 0x8
	// Bit mask of MISSERR field.
	Flash_SR_MISSERR_Msk = 0x100
	// Bit MISSERR.
	Flash_SR_MISSERR = 0x100
	// No fast programming data miss error happened
	Flash_SR_MISSERR_NoError = 0x0
	// Fast programming data miss error happened
	Flash_SR_MISSERR_Error = 0x1
	// Clear the flag
	Flash_SR_MISSERR_Clear = 0x1
	// Position of FASTERR field.
	Flash_SR_FASTERR_Pos = 0x9
	// Bit mask of FASTERR field.
	Flash_SR_FASTERR_Msk = 0x200
	// Bit FASTERR.
	Flash_SR_FASTERR = 0x200
	// No fast programming error happened
	Flash_SR_FASTERR_NoError = 0x0
	// Fast programming error happened
	Flash_SR_FASTERR_Error = 0x1
	// Clear the flag
	Flash_SR_FASTERR_Clear = 0x1
	// Position of OPTNV field.
	Flash_SR_OPTNV_Pos = 0xd
	// Bit mask of OPTNV field.
	Flash_SR_OPTNV_Msk = 0x2000
	// Bit OPTNV.
	Flash_SR_OPTNV = 0x2000
	// The OBL user option OPTVAL indicates "valid"
	Flash_SR_OPTNV_Valid = 0x0
	// The OBL user option OPTVAL indicates "invalid"
	Flash_SR_OPTNV_Invalid = 0x1
	// Position of RDERR field.
	Flash_SR_RDERR_Pos = 0xe
	// Bit mask of RDERR field.
	Flash_SR_RDERR_Msk = 0x4000
	// Bit RDERR.
	Flash_SR_RDERR = 0x4000
	// No read-only error happened
	Flash_SR_RDERR_NoError = 0x0
	// Read-only error happened
	Flash_SR_RDERR_Error = 0x1
	// Clear the flag
	Flash_SR_RDERR_Clear = 0x1
	// Position of OPTVERR field.
	Flash_SR_OPTVERR_Pos = 0xf
	// Bit mask of OPTVERR field.
	Flash_SR_OPTVERR_Msk = 0x8000
	// Bit OPTVERR.
	Flash_SR_OPTVERR = 0x8000
	// No error in option and engineering bits
	Flash_SR_OPTVERR_NoError = 0x0
	// Error in option and engineering bits
	Flash_SR_OPTVERR_Error = 0x1
	// Clear the flag
	Flash_SR_OPTVERR_Clear = 0x1
	// Position of BSY field.
	Flash_SR_BSY_Pos = 0x10
	// Bit mask of BSY field.
	Flash_SR_BSY_Msk = 0x10000
	// Bit BSY.
	Flash_SR_BSY = 0x10000
	// No write/erase operation is in progress
	Flash_SR_BSY_Inactive = 0x0
	// No write/erase operation is in progress
	Flash_SR_BSY_Active = 0x1
	// Position of CFGBSY field.
	Flash_SR_CFGBSY_Pos = 0x12
	// Bit mask of CFGBSY field.
	Flash_SR_CFGBSY_Msk = 0x40000
	// Bit CFGBSY.
	Flash_SR_CFGBSY = 0x40000
	// PG, PNB, PER, MER bits available for writing
	Flash_SR_CFGBSY_Free = 0x0
	// PG, PNB, PER, MER bits not available for writing (operation ongoing)
	Flash_SR_CFGBSY_Busy = 0x1
	// Position of PESD field.
	Flash_SR_PESD_Pos = 0x13
	// Bit mask of PESD field.
	Flash_SR_PESD_Msk = 0x80000
	// Bit PESD.
	Flash_SR_PESD = 0x80000
	// Flash program and erase operations granted
	Flash_SR_PESD_Granted = 0x0
	// Any new Flash program and erase operation is suspended until this bit is cleared. This bit is set when the PES bit in FLASH_ACR is set
	Flash_SR_PESD_Suspended = 0x1

	// CR: Flash control register
	// Position of PG field.
	Flash_CR_PG_Pos = 0x0
	// Bit mask of PG field.
	Flash_CR_PG_Msk = 0x1
	// Bit PG.
	Flash_CR_PG = 0x1
	// Flash programming disabled
	Flash_CR_PG_Disabled = 0x0
	// Flash programming enabled
	Flash_CR_PG_Enabled = 0x1
	// Position of PER field.
	Flash_CR_PER_Pos = 0x1
	// Bit mask of PER field.
	Flash_CR_PER_Msk = 0x2
	// Bit PER.
	Flash_CR_PER = 0x2
	// Page erase disabled
	Flash_CR_PER_Disabled = 0x0
	// Page erase enabled
	Flash_CR_PER_Enabled = 0x1
	// Position of MER field.
	Flash_CR_MER_Pos = 0x2
	// Bit mask of MER field.
	Flash_CR_MER_Msk = 0x4
	// Bit MER.
	Flash_CR_MER = 0x4
	// No mass erase
	Flash_CR_MER_NoErase = 0x0
	// Trigger mass erase
	Flash_CR_MER_MassErase = 0x1
	// Position of PNB field.
	Flash_CR_PNB_Pos = 0x3
	// Bit mask of PNB field.
	Flash_CR_PNB_Msk = 0x3f8
	// Position of STRT field.
	Flash_CR_STRT_Pos = 0x10
	// Bit mask of STRT field.
	Flash_CR_STRT_Msk = 0x10000
	// Bit STRT.
	Flash_CR_STRT = 0x10000
	// Options modification completed or idle
	Flash_CR_STRT_Done = 0x0
	// Trigger options programming operation
	Flash_CR_STRT_Start = 0x1
	// Position of OPTSTRT field.
	Flash_CR_OPTSTRT_Pos = 0x11
	// Bit mask of OPTSTRT field.
	Flash_CR_OPTSTRT_Msk = 0x20000
	// Bit OPTSTRT.
	Flash_CR_OPTSTRT = 0x20000
	// Options modification completed or idle
	Flash_CR_OPTSTRT_Done = 0x0
	// Trigger options programming operation
	Flash_CR_OPTSTRT_Start = 0x1
	// Position of FSTPG field.
	Flash_CR_FSTPG_Pos = 0x12
	// Bit mask of FSTPG field.
	Flash_CR_FSTPG_Msk = 0x40000
	// Bit FSTPG.
	Flash_CR_FSTPG = 0x40000
	// Fast programming disabled
	Flash_CR_FSTPG_Disabled = 0x0
	// Fast programming enabled
	Flash_CR_FSTPG_Enabled = 0x1
	// Position of EOPIE field.
	Flash_CR_EOPIE_Pos = 0x18
	// Bit mask of EOPIE field.
	Flash_CR_EOPIE_Msk = 0x1000000
	// Bit EOPIE.
	Flash_CR_EOPIE = 0x1000000
	// End of program interrupt disable
	Flash_CR_EOPIE_Disabled = 0x0
	// End of program interrupt enable
	Flash_CR_EOPIE_Enabled = 0x1
	// Position of ERRIE field.
	Flash_CR_ERRIE_Pos = 0x19
	// Bit mask of ERRIE field.
	Flash_CR_ERRIE_Msk = 0x2000000
	// Bit ERRIE.
	Flash_CR_ERRIE = 0x2000000
	// OPERR Error interrupt disable
	Flash_CR_ERRIE_Disabled = 0x0
	// OPERR Error interrupt enable
	Flash_CR_ERRIE_Enabled = 0x1
	// Position of RDERRIE field.
	Flash_CR_RDERRIE_Pos = 0x1a
	// Bit mask of RDERRIE field.
	Flash_CR_RDERRIE_Msk = 0x4000000
	// Bit RDERRIE.
	Flash_CR_RDERRIE = 0x4000000
	// PCROP read error interrupt disable
	Flash_CR_RDERRIE_Disabled = 0x0
	// PCROP read error interrupt enable
	Flash_CR_RDERRIE_Enabled = 0x1
	// Position of OBL_LAUNCH field.
	Flash_CR_OBL_LAUNCH_Pos = 0x1b
	// Bit mask of OBL_LAUNCH field.
	Flash_CR_OBL_LAUNCH_Msk = 0x8000000
	// Bit OBL_LAUNCH.
	Flash_CR_OBL_LAUNCH = 0x8000000
	// Option byte loaded
	Flash_CR_OBL_LAUNCH_Complete = 0x0
	// Option byte loading to be done
	Flash_CR_OBL_LAUNCH_NotComplete = 0x1
	// Reload option byte
	Flash_CR_OBL_LAUNCH_Reload = 0x1
	// Position of OPTLOCK field.
	Flash_CR_OPTLOCK_Pos = 0x1e
	// Bit mask of OPTLOCK field.
	Flash_CR_OPTLOCK_Msk = 0x40000000
	// Bit OPTLOCK.
	Flash_CR_OPTLOCK = 0x40000000
	// FLASH_CR options are unlocked
	Flash_CR_OPTLOCK_Unlocked = 0x0
	// FLASH_CR options are locked
	Flash_CR_OPTLOCK_Locked = 0x1
	// Position of LOCK field.
	Flash_CR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	Flash_CR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	Flash_CR_LOCK = 0x80000000
	// FLASH_CR is unlocked
	Flash_CR_LOCK_Unlocked = 0x0
	// FLASH_CR is locked
	Flash_CR_LOCK_Locked = 0x1

	// ECCR: Flash ECC register
	// Position of ADDR_ECC field.
	Flash_ECCR_ADDR_ECC_Pos = 0x0
	// Bit mask of ADDR_ECC field.
	Flash_ECCR_ADDR_ECC_Msk = 0x1ffff
	// Position of SYSF_ECC field.
	Flash_ECCR_SYSF_ECC_Pos = 0x14
	// Bit mask of SYSF_ECC field.
	Flash_ECCR_SYSF_ECC_Msk = 0x100000
	// Bit SYSF_ECC.
	Flash_ECCR_SYSF_ECC = 0x100000
	// No System Flash memory ECC fail
	Flash_ECCR_SYSF_ECC_NotInFlash = 0x0
	// System Flash memory ECC fail
	Flash_ECCR_SYSF_ECC_InFlash = 0x1
	// Position of ECCCIE field.
	Flash_ECCR_ECCCIE_Pos = 0x18
	// Bit mask of ECCCIE field.
	Flash_ECCR_ECCCIE_Msk = 0x1000000
	// Bit ECCCIE.
	Flash_ECCR_ECCCIE = 0x1000000
	// ECCC interrupt disabled
	Flash_ECCR_ECCCIE_Disabled = 0x0
	// ECCC interrupt enabled
	Flash_ECCR_ECCCIE_Enabled = 0x1
	// Position of ECCC field.
	Flash_ECCR_ECCC_Pos = 0x1e
	// Bit mask of ECCC field.
	Flash_ECCR_ECCC_Msk = 0x40000000
	// Bit ECCC.
	Flash_ECCR_ECCC = 0x40000000
	// ECC error corrected
	Flash_ECCR_ECCC_NoEvent = 0x0
	// No ECC error corrected
	Flash_ECCR_ECCC_Event = 0x1
	// Clear the flag
	Flash_ECCR_ECCC_Clear = 0x1
	// Position of ECCD field.
	Flash_ECCR_ECCD_Pos = 0x1f
	// Bit mask of ECCD field.
	Flash_ECCR_ECCD_Msk = 0x80000000
	// Bit ECCD.
	Flash_ECCR_ECCD = 0x80000000
	// Two ECC errors detected
	Flash_ECCR_ECCD_NoEvent = 0x0
	// No two ECC errors detected
	Flash_ECCR_ECCD_Event = 0x1
	// Clear the flag
	Flash_ECCR_ECCD_Clear = 0x1

	// OPTR: Flash option register
	// Position of RDP field.
	Flash_OPTR_RDP_Pos = 0x0
	// Bit mask of RDP field.
	Flash_OPTR_RDP_Msk = 0xff
	// Level 0, readout protection not active
	Flash_OPTR_RDP_Level0 = 0xaa
	// Level 2, chip readout protection active
	Flash_OPTR_RDP_Level2 = 0xcc
	// Level 1, memories readout protection active (writes 0x88)
	Flash_OPTR_RDP_Level1 = 0x88
	// Position of ESE field.
	Flash_OPTR_ESE_Pos = 0x8
	// Bit mask of ESE field.
	Flash_OPTR_ESE_Msk = 0x100
	// Bit ESE.
	Flash_OPTR_ESE = 0x100
	// Security disabled
	Flash_OPTR_ESE_Disabled = 0x0
	// Security enabled
	Flash_OPTR_ESE_Enabled = 0x1
	// Position of BOR_LEV field.
	Flash_OPTR_BOR_LEV_Pos = 0x9
	// Bit mask of BOR_LEV field.
	Flash_OPTR_BOR_LEV_Msk = 0xe00
	// BOR level 0. Reset level threshold is around 1.7 V
	Flash_OPTR_BOR_LEV_Level0 = 0x0
	// BOR level 1. Reset level threshold is around 2.0 V
	Flash_OPTR_BOR_LEV_Level1 = 0x1
	// BOR level 2. Reset level threshold is around 2.2 V
	Flash_OPTR_BOR_LEV_Level2 = 0x2
	// BOR level 3. Reset level threshold is around 2.5 V
	Flash_OPTR_BOR_LEV_Level3 = 0x3
	// BOR level 4. Reset level threshold is around 2.8 V
	Flash_OPTR_BOR_LEV_Level4 = 0x4
	// Position of NRST_STOP field.
	Flash_OPTR_NRST_STOP_Pos = 0xc
	// Bit mask of NRST_STOP field.
	Flash_OPTR_NRST_STOP_Msk = 0x1000
	// Bit NRST_STOP.
	Flash_OPTR_NRST_STOP = 0x1000
	// Reset generated when entering the Standby mode
	Flash_OPTR_NRST_STOP_Enabled = 0x0
	// No reset generated when entering the Standby mode
	Flash_OPTR_NRST_STOP_Disabled = 0x1
	// Position of NRST_STDBY field.
	Flash_OPTR_NRST_STDBY_Pos = 0xd
	// Bit mask of NRST_STDBY field.
	Flash_OPTR_NRST_STDBY_Msk = 0x2000
	// Bit NRST_STDBY.
	Flash_OPTR_NRST_STDBY = 0x2000
	// Reset generated when entering the Standby mode
	Flash_OPTR_NRST_STDBY_Enabled = 0x0
	// No reset generated when entering the Standby mode
	Flash_OPTR_NRST_STDBY_Disabled = 0x1
	// Position of NRST_SHDW field.
	Flash_OPTR_NRST_SHDW_Pos = 0xe
	// Bit mask of NRST_SHDW field.
	Flash_OPTR_NRST_SHDW_Msk = 0x4000
	// Bit NRST_SHDW.
	Flash_OPTR_NRST_SHDW = 0x4000
	// Reset generated when entering the Shutdown mode
	Flash_OPTR_NRST_SHDW_Enabled = 0x0
	// No reset generated when entering the Shutdown mode
	Flash_OPTR_NRST_SHDW_Disabled = 0x1
	// Position of IWDG_SW field.
	Flash_OPTR_IWDG_SW_Pos = 0x10
	// Bit mask of IWDG_SW field.
	Flash_OPTR_IWDG_SW_Msk = 0x10000
	// Bit IWDG_SW.
	Flash_OPTR_IWDG_SW = 0x10000
	// Hardware independent watchdog
	Flash_OPTR_IWDG_SW_Hardware = 0x0
	// Software independent watchdog
	Flash_OPTR_IWDG_SW_Software = 0x1
	// Position of IWDG_STOP field.
	Flash_OPTR_IWDG_STOP_Pos = 0x11
	// Bit mask of IWDG_STOP field.
	Flash_OPTR_IWDG_STOP_Msk = 0x20000
	// Bit IWDG_STOP.
	Flash_OPTR_IWDG_STOP = 0x20000
	// Independent watchdog counter frozen in Stop mode
	Flash_OPTR_IWDG_STOP_Frozen = 0x0
	// Independent watchdog counter running in Stop mode
	Flash_OPTR_IWDG_STOP_Running = 0x1
	// Position of IWDG_STDBY field.
	Flash_OPTR_IWDG_STDBY_Pos = 0x12
	// Bit mask of IWDG_STDBY field.
	Flash_OPTR_IWDG_STDBY_Msk = 0x40000
	// Bit IWDG_STDBY.
	Flash_OPTR_IWDG_STDBY = 0x40000
	// Independent watchdog counter frozen in Standby mode
	Flash_OPTR_IWDG_STDBY_Frozen = 0x0
	// Independent watchdog counter running in Standby mode
	Flash_OPTR_IWDG_STDBY_Running = 0x1
	// Position of WWDG_SW field.
	Flash_OPTR_WWDG_SW_Pos = 0x13
	// Bit mask of WWDG_SW field.
	Flash_OPTR_WWDG_SW_Msk = 0x80000
	// Bit WWDG_SW.
	Flash_OPTR_WWDG_SW = 0x80000
	// Hardware window watchdog
	Flash_OPTR_WWDG_SW_Hardware = 0x0
	// Software window watchdog
	Flash_OPTR_WWDG_SW_Software = 0x1
	// Position of NBOOT1 field.
	Flash_OPTR_NBOOT1_Pos = 0x17
	// Bit mask of NBOOT1 field.
	Flash_OPTR_NBOOT1_Msk = 0x800000
	// Bit NBOOT1.
	Flash_OPTR_NBOOT1 = 0x800000
	// When nSWBOOT0 is cleared, select boot mode together with nBOOT0
	Flash_OPTR_NBOOT1_Clear = 0x0
	// When nSWBOOT0 is cleared, select boot mode together with nBOOT0
	Flash_OPTR_NBOOT1_Set = 0x1
	// Position of SRAM2_PE field.
	Flash_OPTR_SRAM2_PE_Pos = 0x18
	// Bit mask of SRAM2_PE field.
	Flash_OPTR_SRAM2_PE_Msk = 0x1000000
	// Bit SRAM2_PE.
	Flash_OPTR_SRAM2_PE = 0x1000000
	// SRAM2 Parity check enabled
	Flash_OPTR_SRAM2_PE_Enabled = 0x0
	// SRAM2 Parity check disabled
	Flash_OPTR_SRAM2_PE_Disabled = 0x1
	// Position of SRAM_RST field.
	Flash_OPTR_SRAM_RST_Pos = 0x19
	// Bit mask of SRAM_RST field.
	Flash_OPTR_SRAM_RST_Msk = 0x2000000
	// Bit SRAM_RST.
	Flash_OPTR_SRAM_RST = 0x2000000
	// SRAM1 and SRAM2 erased when a system reset occurs
	Flash_OPTR_SRAM_RST_Reset = 0x0
	// SRAM1 and SRAM2 not erased when a system reset occurs
	Flash_OPTR_SRAM_RST_NotReset = 0x1
	// Position of NSWBOOT0 field.
	Flash_OPTR_NSWBOOT0_Pos = 0x1a
	// Bit mask of NSWBOOT0 field.
	Flash_OPTR_NSWBOOT0_Msk = 0x4000000
	// Bit NSWBOOT0.
	Flash_OPTR_NSWBOOT0 = 0x4000000
	// BOOT0 taken from nBOOT0 in this register
	Flash_OPTR_NSWBOOT0_Bit = 0x0
	// BOOT0 taken from GPIO PH3/BOOT0
	Flash_OPTR_NSWBOOT0_Pin = 0x1
	// Position of NBOOT0 field.
	Flash_OPTR_NBOOT0_Pos = 0x1b
	// Bit mask of NBOOT0 field.
	Flash_OPTR_NBOOT0_Msk = 0x8000000
	// Bit NBOOT0.
	Flash_OPTR_NBOOT0 = 0x8000000
	// When nSWBOOT0 is cleared, select boot mode together with nBOOT1
	Flash_OPTR_NBOOT0_Clear = 0x0
	// When nSWBOOT0 is cleared, select boot mode together with nBOOT1
	Flash_OPTR_NBOOT0_Set = 0x1
	// Position of BOOT_LOCK field.
	Flash_OPTR_BOOT_LOCK_Pos = 0x1e
	// Bit mask of BOOT_LOCK field.
	Flash_OPTR_BOOT_LOCK_Msk = 0x40000000
	// Bit BOOT_LOCK.
	Flash_OPTR_BOOT_LOCK = 0x40000000
	// Boot lock is disabled
	Flash_OPTR_BOOT_LOCK_Disabled = 0x0
	// Boot lock is enabled
	Flash_OPTR_BOOT_LOCK_Enabled = 0x1

	// PCROP1ASR: Flash PCROP zone A Start address register
	// Position of PCROP1A_STRT field.
	Flash_PCROP1ASR_PCROP1A_STRT_Pos = 0x0
	// Bit mask of PCROP1A_STRT field.
	Flash_PCROP1ASR_PCROP1A_STRT_Msk = 0xff

	// PCROP1AER: Flash PCROP zone A End address register
	// Position of PCROP1A_END field.
	Flash_PCROP1AER_PCROP1A_END_Pos = 0x0
	// Bit mask of PCROP1A_END field.
	Flash_PCROP1AER_PCROP1A_END_Msk = 0xff
	// Position of PCROP_RDP field.
	Flash_PCROP1AER_PCROP_RDP_Pos = 0x1f
	// Bit mask of PCROP_RDP field.
	Flash_PCROP1AER_PCROP_RDP_Msk = 0x80000000
	// Bit PCROP_RDP.
	Flash_PCROP1AER_PCROP_RDP = 0x80000000

	// WRP1AR: Flash WRP area A address register
	// Position of WRP1A_STRT field.
	Flash_WRP1AR_WRP1A_STRT_Pos = 0x0
	// Bit mask of WRP1A_STRT field.
	Flash_WRP1AR_WRP1A_STRT_Msk = 0x7f
	// Position of WRP1A_END field.
	Flash_WRP1AR_WRP1A_END_Pos = 0x10
	// Bit mask of WRP1A_END field.
	Flash_WRP1AR_WRP1A_END_Msk = 0x7f0000

	// WRP1BR: Flash WRP area B address register
	// Position of WRP1B_STRT field.
	Flash_WRP1BR_WRP1B_STRT_Pos = 0x0
	// Bit mask of WRP1B_STRT field.
	Flash_WRP1BR_WRP1B_STRT_Msk = 0x7f
	// Position of WRP1B_END field.
	Flash_WRP1BR_WRP1B_END_Pos = 0x10
	// Bit mask of WRP1B_END field.
	Flash_WRP1BR_WRP1B_END_Msk = 0x7f0000

	// PCROP1BSR: Flash PCROP zone B Start address register
	// Position of PCROP1B_STRT field.
	Flash_PCROP1BSR_PCROP1B_STRT_Pos = 0x0
	// Bit mask of PCROP1B_STRT field.
	Flash_PCROP1BSR_PCROP1B_STRT_Msk = 0xff

	// PCROP1BER: Flash PCROP zone B End address register
	// Position of PCROP1B_END field.
	Flash_PCROP1BER_PCROP1B_END_Pos = 0x0
	// Bit mask of PCROP1B_END field.
	Flash_PCROP1BER_PCROP1B_END_Msk = 0xff
)

// Constants for GPIOA: General-purpose I/Os
const (
	// MODER: GPIO port mode register
	// Position of MODER15 field.
	GPIO_MODER_MODER15_Pos = 0x1e
	// Bit mask of MODER15 field.
	GPIO_MODER_MODER15_Msk = 0xc0000000
	// Input mode (reset state)
	GPIO_MODER_MODER15_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER15_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER15_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER15_Analog = 0x3
	// Position of MODER14 field.
	GPIO_MODER_MODER14_Pos = 0x1c
	// Bit mask of MODER14 field.
	GPIO_MODER_MODER14_Msk = 0x30000000
	// Input mode (reset state)
	GPIO_MODER_MODER14_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER14_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER14_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER14_Analog = 0x3
	// Position of MODER13 field.
	GPIO_MODER_MODER13_Pos = 0x1a
	// Bit mask of MODER13 field.
	GPIO_MODER_MODER13_Msk = 0xc000000
	// Input mode (reset state)
	GPIO_MODER_MODER13_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER13_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER13_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER13_Analog = 0x3
	// Position of MODER12 field.
	GPIO_MODER_MODER12_Pos = 0x18
	// Bit mask of MODER12 field.
	GPIO_MODER_MODER12_Msk = 0x3000000
	// Input mode (reset state)
	GPIO_MODER_MODER12_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER12_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER12_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER12_Analog = 0x3
	// Position of MODER11 field.
	GPIO_MODER_MODER11_Pos = 0x16
	// Bit mask of MODER11 field.
	GPIO_MODER_MODER11_Msk = 0xc00000
	// Input mode (reset state)
	GPIO_MODER_MODER11_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER11_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER11_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER11_Analog = 0x3
	// Position of MODER10 field.
	GPIO_MODER_MODER10_Pos = 0x14
	// Bit mask of MODER10 field.
	GPIO_MODER_MODER10_Msk = 0x300000
	// Input mode (reset state)
	GPIO_MODER_MODER10_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER10_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER10_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER10_Analog = 0x3
	// Position of MODER9 field.
	GPIO_MODER_MODER9_Pos = 0x12
	// Bit mask of MODER9 field.
	GPIO_MODER_MODER9_Msk = 0xc0000
	// Input mode (reset state)
	GPIO_MODER_MODER9_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER9_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER9_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER9_Analog = 0x3
	// Position of MODER8 field.
	GPIO_MODER_MODER8_Pos = 0x10
	// Bit mask of MODER8 field.
	GPIO_MODER_MODER8_Msk = 0x30000
	// Input mode (reset state)
	GPIO_MODER_MODER8_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER8_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER8_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER8_Analog = 0x3
	// Position of MODER7 field.
	GPIO_MODER_MODER7_Pos = 0xe
	// Bit mask of MODER7 field.
	GPIO_MODER_MODER7_Msk = 0xc000
	// Input mode (reset state)
	GPIO_MODER_MODER7_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER7_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER7_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER7_Analog = 0x3
	// Position of MODER6 field.
	GPIO_MODER_MODER6_Pos = 0xc
	// Bit mask of MODER6 field.
	GPIO_MODER_MODER6_Msk = 0x3000
	// Input mode (reset state)
	GPIO_MODER_MODER6_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER6_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER6_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER6_Analog = 0x3
	// Position of MODER5 field.
	GPIO_MODER_MODER5_Pos = 0xa
	// Bit mask of MODER5 field.
	GPIO_MODER_MODER5_Msk = 0xc00
	// Input mode (reset state)
	GPIO_MODER_MODER5_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER5_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER5_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER5_Analog = 0x3
	// Position of MODER4 field.
	GPIO_MODER_MODER4_Pos = 0x8
	// Bit mask of MODER4 field.
	GPIO_MODER_MODER4_Msk = 0x300
	// Input mode (reset state)
	GPIO_MODER_MODER4_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER4_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER4_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER4_Analog = 0x3
	// Position of MODER3 field.
	GPIO_MODER_MODER3_Pos = 0x6
	// Bit mask of MODER3 field.
	GPIO_MODER_MODER3_Msk = 0xc0
	// Input mode (reset state)
	GPIO_MODER_MODER3_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER3_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER3_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER3_Analog = 0x3
	// Position of MODER2 field.
	GPIO_MODER_MODER2_Pos = 0x4
	// Bit mask of MODER2 field.
	GPIO_MODER_MODER2_Msk = 0x30
	// Input mode (reset state)
	GPIO_MODER_MODER2_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER2_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER2_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER2_Analog = 0x3
	// Position of MODER1 field.
	GPIO_MODER_MODER1_Pos = 0x2
	// Bit mask of MODER1 field.
	GPIO_MODER_MODER1_Msk = 0xc
	// Input mode (reset state)
	GPIO_MODER_MODER1_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER1_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER1_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER1_Analog = 0x3
	// Position of MODER0 field.
	GPIO_MODER_MODER0_Pos = 0x0
	// Bit mask of MODER0 field.
	GPIO_MODER_MODER0_Msk = 0x3
	// Input mode (reset state)
	GPIO_MODER_MODER0_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER0_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER0_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER0_Analog = 0x3

	// OTYPER: GPIO port output type register
	// Position of OT15 field.
	GPIO_OTYPER_OT15_Pos = 0xf
	// Bit mask of OT15 field.
	GPIO_OTYPER_OT15_Msk = 0x8000
	// Bit OT15.
	GPIO_OTYPER_OT15 = 0x8000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT15_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT15_OpenDrain = 0x1
	// Position of OT14 field.
	GPIO_OTYPER_OT14_Pos = 0xe
	// Bit mask of OT14 field.
	GPIO_OTYPER_OT14_Msk = 0x4000
	// Bit OT14.
	GPIO_OTYPER_OT14 = 0x4000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT14_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT14_OpenDrain = 0x1
	// Position of OT13 field.
	GPIO_OTYPER_OT13_Pos = 0xd
	// Bit mask of OT13 field.
	GPIO_OTYPER_OT13_Msk = 0x2000
	// Bit OT13.
	GPIO_OTYPER_OT13 = 0x2000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT13_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT13_OpenDrain = 0x1
	// Position of OT12 field.
	GPIO_OTYPER_OT12_Pos = 0xc
	// Bit mask of OT12 field.
	GPIO_OTYPER_OT12_Msk = 0x1000
	// Bit OT12.
	GPIO_OTYPER_OT12 = 0x1000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT12_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT12_OpenDrain = 0x1
	// Position of OT11 field.
	GPIO_OTYPER_OT11_Pos = 0xb
	// Bit mask of OT11 field.
	GPIO_OTYPER_OT11_Msk = 0x800
	// Bit OT11.
	GPIO_OTYPER_OT11 = 0x800
	// Output push-pull (reset state)
	GPIO_OTYPER_OT11_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT11_OpenDrain = 0x1
	// Position of OT10 field.
	GPIO_OTYPER_OT10_Pos = 0xa
	// Bit mask of OT10 field.
	GPIO_OTYPER_OT10_Msk = 0x400
	// Bit OT10.
	GPIO_OTYPER_OT10 = 0x400
	// Output push-pull (reset state)
	GPIO_OTYPER_OT10_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT10_OpenDrain = 0x1
	// Position of OT9 field.
	GPIO_OTYPER_OT9_Pos = 0x9
	// Bit mask of OT9 field.
	GPIO_OTYPER_OT9_Msk = 0x200
	// Bit OT9.
	GPIO_OTYPER_OT9 = 0x200
	// Output push-pull (reset state)
	GPIO_OTYPER_OT9_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT9_OpenDrain = 0x1
	// Position of OT8 field.
	GPIO_OTYPER_OT8_Pos = 0x8
	// Bit mask of OT8 field.
	GPIO_OTYPER_OT8_Msk = 0x100
	// Bit OT8.
	GPIO_OTYPER_OT8 = 0x100
	// Output push-pull (reset state)
	GPIO_OTYPER_OT8_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT8_OpenDrain = 0x1
	// Position of OT7 field.
	GPIO_OTYPER_OT7_Pos = 0x7
	// Bit mask of OT7 field.
	GPIO_OTYPER_OT7_Msk = 0x80
	// Bit OT7.
	GPIO_OTYPER_OT7 = 0x80
	// Output push-pull (reset state)
	GPIO_OTYPER_OT7_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT7_OpenDrain = 0x1
	// Position of OT6 field.
	GPIO_OTYPER_OT6_Pos = 0x6
	// Bit mask of OT6 field.
	GPIO_OTYPER_OT6_Msk = 0x40
	// Bit OT6.
	GPIO_OTYPER_OT6 = 0x40
	// Output push-pull (reset state)
	GPIO_OTYPER_OT6_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT6_OpenDrain = 0x1
	// Position of OT5 field.
	GPIO_OTYPER_OT5_Pos = 0x5
	// Bit mask of OT5 field.
	GPIO_OTYPER_OT5_Msk = 0x20
	// Bit OT5.
	GPIO_OTYPER_OT5 = 0x20
	// Output push-pull (reset state)
	GPIO_OTYPER_OT5_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT5_OpenDrain = 0x1
	// Position of OT4 field.
	GPIO_OTYPER_OT4_Pos = 0x4
	// Bit mask of OT4 field.
	GPIO_OTYPER_OT4_Msk = 0x10
	// Bit OT4.
	GPIO_OTYPER_OT4 = 0x10
	// Output push-pull (reset state)
	GPIO_OTYPER_OT4_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT4_OpenDrain = 0x1
	// Position of OT3 field.
	GPIO_OTYPER_OT3_Pos = 0x3
	// Bit mask of OT3 field.
	GPIO_OTYPER_OT3_Msk = 0x8
	// Bit OT3.
	GPIO_OTYPER_OT3 = 0x8
	// Output push-pull (reset state)
	GPIO_OTYPER_OT3_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT3_OpenDrain = 0x1
	// Position of OT2 field.
	GPIO_OTYPER_OT2_Pos = 0x2
	// Bit mask of OT2 field.
	GPIO_OTYPER_OT2_Msk = 0x4
	// Bit OT2.
	GPIO_OTYPER_OT2 = 0x4
	// Output push-pull (reset state)
	GPIO_OTYPER_OT2_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT2_OpenDrain = 0x1
	// Position of OT1 field.
	GPIO_OTYPER_OT1_Pos = 0x1
	// Bit mask of OT1 field.
	GPIO_OTYPER_OT1_Msk = 0x2
	// Bit OT1.
	GPIO_OTYPER_OT1 = 0x2
	// Output push-pull (reset state)
	GPIO_OTYPER_OT1_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT1_OpenDrain = 0x1
	// Position of OT0 field.
	GPIO_OTYPER_OT0_Pos = 0x0
	// Bit mask of OT0 field.
	GPIO_OTYPER_OT0_Msk = 0x1
	// Bit OT0.
	GPIO_OTYPER_OT0 = 0x1
	// Output push-pull (reset state)
	GPIO_OTYPER_OT0_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT0_OpenDrain = 0x1

	// OSPEEDR: GPIO port output speed register
	// Position of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Pos = 0x1e
	// Bit mask of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Msk = 0xc0000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR15_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR15_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR15_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR15_VeryHighSpeed = 0x3
	// Position of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Pos = 0x1c
	// Bit mask of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Msk = 0x30000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR14_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR14_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR14_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR14_VeryHighSpeed = 0x3
	// Position of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Pos = 0x1a
	// Bit mask of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Msk = 0xc000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR13_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR13_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR13_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR13_VeryHighSpeed = 0x3
	// Position of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Pos = 0x18
	// Bit mask of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Msk = 0x3000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR12_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR12_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR12_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR12_VeryHighSpeed = 0x3
	// Position of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Pos = 0x16
	// Bit mask of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Msk = 0xc00000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR11_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR11_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR11_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR11_VeryHighSpeed = 0x3
	// Position of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Pos = 0x14
	// Bit mask of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Msk = 0x300000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR10_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR10_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR10_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR10_VeryHighSpeed = 0x3
	// Position of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Pos = 0x12
	// Bit mask of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Msk = 0xc0000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR9_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR9_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR9_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR9_VeryHighSpeed = 0x3
	// Position of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Pos = 0x10
	// Bit mask of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Msk = 0x30000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR8_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR8_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR8_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR8_VeryHighSpeed = 0x3
	// Position of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Pos = 0xe
	// Bit mask of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Msk = 0xc000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR7_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR7_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR7_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR7_VeryHighSpeed = 0x3
	// Position of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Pos = 0xc
	// Bit mask of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Msk = 0x3000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR6_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR6_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR6_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR6_VeryHighSpeed = 0x3
	// Position of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Pos = 0xa
	// Bit mask of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Msk = 0xc00
	// Low speed
	GPIO_OSPEEDR_OSPEEDR5_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR5_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR5_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR5_VeryHighSpeed = 0x3
	// Position of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Pos = 0x8
	// Bit mask of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Msk = 0x300
	// Low speed
	GPIO_OSPEEDR_OSPEEDR4_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR4_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR4_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR4_VeryHighSpeed = 0x3
	// Position of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Pos = 0x6
	// Bit mask of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Msk = 0xc0
	// Low speed
	GPIO_OSPEEDR_OSPEEDR3_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR3_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR3_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR3_VeryHighSpeed = 0x3
	// Position of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Pos = 0x4
	// Bit mask of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Msk = 0x30
	// Low speed
	GPIO_OSPEEDR_OSPEEDR2_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR2_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR2_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR2_VeryHighSpeed = 0x3
	// Position of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Pos = 0x2
	// Bit mask of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Msk = 0xc
	// Low speed
	GPIO_OSPEEDR_OSPEEDR1_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR1_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR1_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR1_VeryHighSpeed = 0x3
	// Position of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Pos = 0x0
	// Bit mask of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Msk = 0x3
	// Low speed
	GPIO_OSPEEDR_OSPEEDR0_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR0_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR0_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR0_VeryHighSpeed = 0x3

	// PUPDR: GPIO port pull-up/pull-down register
	// Position of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Pos = 0x1e
	// Bit mask of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Msk = 0xc0000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR15_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR15_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR15_PullDown = 0x2
	// Position of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Pos = 0x1c
	// Bit mask of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Msk = 0x30000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR14_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR14_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR14_PullDown = 0x2
	// Position of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Pos = 0x1a
	// Bit mask of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Msk = 0xc000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR13_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR13_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR13_PullDown = 0x2
	// Position of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Pos = 0x18
	// Bit mask of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Msk = 0x3000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR12_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR12_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR12_PullDown = 0x2
	// Position of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Pos = 0x16
	// Bit mask of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Msk = 0xc00000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR11_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR11_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR11_PullDown = 0x2
	// Position of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Pos = 0x14
	// Bit mask of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Msk = 0x300000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR10_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR10_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR10_PullDown = 0x2
	// Position of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Pos = 0x12
	// Bit mask of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Msk = 0xc0000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR9_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR9_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR9_PullDown = 0x2
	// Position of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Pos = 0x10
	// Bit mask of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Msk = 0x30000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR8_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR8_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR8_PullDown = 0x2
	// Position of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Pos = 0xe
	// Bit mask of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Msk = 0xc000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR7_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR7_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR7_PullDown = 0x2
	// Position of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Pos = 0xc
	// Bit mask of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Msk = 0x3000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR6_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR6_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR6_PullDown = 0x2
	// Position of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Pos = 0xa
	// Bit mask of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Msk = 0xc00
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR5_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR5_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR5_PullDown = 0x2
	// Position of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Pos = 0x8
	// Bit mask of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Msk = 0x300
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR4_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR4_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR4_PullDown = 0x2
	// Position of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Pos = 0x6
	// Bit mask of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Msk = 0xc0
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR3_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR3_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR3_PullDown = 0x2
	// Position of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Pos = 0x4
	// Bit mask of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Msk = 0x30
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR2_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR2_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR2_PullDown = 0x2
	// Position of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Pos = 0x2
	// Bit mask of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Msk = 0xc
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR1_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR1_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR1_PullDown = 0x2
	// Position of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Pos = 0x0
	// Bit mask of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Msk = 0x3
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR0_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR0_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR0_PullDown = 0x2

	// IDR: GPIO port input data register
	// Position of IDR15 field.
	GPIO_IDR_IDR15_Pos = 0xf
	// Bit mask of IDR15 field.
	GPIO_IDR_IDR15_Msk = 0x8000
	// Bit IDR15.
	GPIO_IDR_IDR15 = 0x8000
	// Input is logic high
	GPIO_IDR_IDR15_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR15_Low = 0x0
	// Position of IDR14 field.
	GPIO_IDR_IDR14_Pos = 0xe
	// Bit mask of IDR14 field.
	GPIO_IDR_IDR14_Msk = 0x4000
	// Bit IDR14.
	GPIO_IDR_IDR14 = 0x4000
	// Input is logic high
	GPIO_IDR_IDR14_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR14_Low = 0x0
	// Position of IDR13 field.
	GPIO_IDR_IDR13_Pos = 0xd
	// Bit mask of IDR13 field.
	GPIO_IDR_IDR13_Msk = 0x2000
	// Bit IDR13.
	GPIO_IDR_IDR13 = 0x2000
	// Input is logic high
	GPIO_IDR_IDR13_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR13_Low = 0x0
	// Position of IDR12 field.
	GPIO_IDR_IDR12_Pos = 0xc
	// Bit mask of IDR12 field.
	GPIO_IDR_IDR12_Msk = 0x1000
	// Bit IDR12.
	GPIO_IDR_IDR12 = 0x1000
	// Input is logic high
	GPIO_IDR_IDR12_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR12_Low = 0x0
	// Position of IDR11 field.
	GPIO_IDR_IDR11_Pos = 0xb
	// Bit mask of IDR11 field.
	GPIO_IDR_IDR11_Msk = 0x800
	// Bit IDR11.
	GPIO_IDR_IDR11 = 0x800
	// Input is logic high
	GPIO_IDR_IDR11_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR11_Low = 0x0
	// Position of IDR10 field.
	GPIO_IDR_IDR10_Pos = 0xa
	// Bit mask of IDR10 field.
	GPIO_IDR_IDR10_Msk = 0x400
	// Bit IDR10.
	GPIO_IDR_IDR10 = 0x400
	// Input is logic high
	GPIO_IDR_IDR10_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR10_Low = 0x0
	// Position of IDR9 field.
	GPIO_IDR_IDR9_Pos = 0x9
	// Bit mask of IDR9 field.
	GPIO_IDR_IDR9_Msk = 0x200
	// Bit IDR9.
	GPIO_IDR_IDR9 = 0x200
	// Input is logic high
	GPIO_IDR_IDR9_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR9_Low = 0x0
	// Position of IDR8 field.
	GPIO_IDR_IDR8_Pos = 0x8
	// Bit mask of IDR8 field.
	GPIO_IDR_IDR8_Msk = 0x100
	// Bit IDR8.
	GPIO_IDR_IDR8 = 0x100
	// Input is logic high
	GPIO_IDR_IDR8_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR8_Low = 0x0
	// Position of IDR7 field.
	GPIO_IDR_IDR7_Pos = 0x7
	// Bit mask of IDR7 field.
	GPIO_IDR_IDR7_Msk = 0x80
	// Bit IDR7.
	GPIO_IDR_IDR7 = 0x80
	// Input is logic high
	GPIO_IDR_IDR7_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR7_Low = 0x0
	// Position of IDR6 field.
	GPIO_IDR_IDR6_Pos = 0x6
	// Bit mask of IDR6 field.
	GPIO_IDR_IDR6_Msk = 0x40
	// Bit IDR6.
	GPIO_IDR_IDR6 = 0x40
	// Input is logic high
	GPIO_IDR_IDR6_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR6_Low = 0x0
	// Position of IDR5 field.
	GPIO_IDR_IDR5_Pos = 0x5
	// Bit mask of IDR5 field.
	GPIO_IDR_IDR5_Msk = 0x20
	// Bit IDR5.
	GPIO_IDR_IDR5 = 0x20
	// Input is logic high
	GPIO_IDR_IDR5_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR5_Low = 0x0
	// Position of IDR4 field.
	GPIO_IDR_IDR4_Pos = 0x4
	// Bit mask of IDR4 field.
	GPIO_IDR_IDR4_Msk = 0x10
	// Bit IDR4.
	GPIO_IDR_IDR4 = 0x10
	// Input is logic high
	GPIO_IDR_IDR4_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR4_Low = 0x0
	// Position of IDR3 field.
	GPIO_IDR_IDR3_Pos = 0x3
	// Bit mask of IDR3 field.
	GPIO_IDR_IDR3_Msk = 0x8
	// Bit IDR3.
	GPIO_IDR_IDR3 = 0x8
	// Input is logic high
	GPIO_IDR_IDR3_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR3_Low = 0x0
	// Position of IDR2 field.
	GPIO_IDR_IDR2_Pos = 0x2
	// Bit mask of IDR2 field.
	GPIO_IDR_IDR2_Msk = 0x4
	// Bit IDR2.
	GPIO_IDR_IDR2 = 0x4
	// Input is logic high
	GPIO_IDR_IDR2_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR2_Low = 0x0
	// Position of IDR1 field.
	GPIO_IDR_IDR1_Pos = 0x1
	// Bit mask of IDR1 field.
	GPIO_IDR_IDR1_Msk = 0x2
	// Bit IDR1.
	GPIO_IDR_IDR1 = 0x2
	// Input is logic high
	GPIO_IDR_IDR1_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR1_Low = 0x0
	// Position of IDR0 field.
	GPIO_IDR_IDR0_Pos = 0x0
	// Bit mask of IDR0 field.
	GPIO_IDR_IDR0_Msk = 0x1
	// Bit IDR0.
	GPIO_IDR_IDR0 = 0x1
	// Input is logic high
	GPIO_IDR_IDR0_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR0_Low = 0x0

	// ODR: GPIO port output data register
	// Position of ODR15 field.
	GPIO_ODR_ODR15_Pos = 0xf
	// Bit mask of ODR15 field.
	GPIO_ODR_ODR15_Msk = 0x8000
	// Bit ODR15.
	GPIO_ODR_ODR15 = 0x8000
	// Set output to logic high
	GPIO_ODR_ODR15_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR15_Low = 0x0
	// Position of ODR14 field.
	GPIO_ODR_ODR14_Pos = 0xe
	// Bit mask of ODR14 field.
	GPIO_ODR_ODR14_Msk = 0x4000
	// Bit ODR14.
	GPIO_ODR_ODR14 = 0x4000
	// Set output to logic high
	GPIO_ODR_ODR14_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR14_Low = 0x0
	// Position of ODR13 field.
	GPIO_ODR_ODR13_Pos = 0xd
	// Bit mask of ODR13 field.
	GPIO_ODR_ODR13_Msk = 0x2000
	// Bit ODR13.
	GPIO_ODR_ODR13 = 0x2000
	// Set output to logic high
	GPIO_ODR_ODR13_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR13_Low = 0x0
	// Position of ODR12 field.
	GPIO_ODR_ODR12_Pos = 0xc
	// Bit mask of ODR12 field.
	GPIO_ODR_ODR12_Msk = 0x1000
	// Bit ODR12.
	GPIO_ODR_ODR12 = 0x1000
	// Set output to logic high
	GPIO_ODR_ODR12_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR12_Low = 0x0
	// Position of ODR11 field.
	GPIO_ODR_ODR11_Pos = 0xb
	// Bit mask of ODR11 field.
	GPIO_ODR_ODR11_Msk = 0x800
	// Bit ODR11.
	GPIO_ODR_ODR11 = 0x800
	// Set output to logic high
	GPIO_ODR_ODR11_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR11_Low = 0x0
	// Position of ODR10 field.
	GPIO_ODR_ODR10_Pos = 0xa
	// Bit mask of ODR10 field.
	GPIO_ODR_ODR10_Msk = 0x400
	// Bit ODR10.
	GPIO_ODR_ODR10 = 0x400
	// Set output to logic high
	GPIO_ODR_ODR10_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR10_Low = 0x0
	// Position of ODR9 field.
	GPIO_ODR_ODR9_Pos = 0x9
	// Bit mask of ODR9 field.
	GPIO_ODR_ODR9_Msk = 0x200
	// Bit ODR9.
	GPIO_ODR_ODR9 = 0x200
	// Set output to logic high
	GPIO_ODR_ODR9_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR9_Low = 0x0
	// Position of ODR8 field.
	GPIO_ODR_ODR8_Pos = 0x8
	// Bit mask of ODR8 field.
	GPIO_ODR_ODR8_Msk = 0x100
	// Bit ODR8.
	GPIO_ODR_ODR8 = 0x100
	// Set output to logic high
	GPIO_ODR_ODR8_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR8_Low = 0x0
	// Position of ODR7 field.
	GPIO_ODR_ODR7_Pos = 0x7
	// Bit mask of ODR7 field.
	GPIO_ODR_ODR7_Msk = 0x80
	// Bit ODR7.
	GPIO_ODR_ODR7 = 0x80
	// Set output to logic high
	GPIO_ODR_ODR7_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR7_Low = 0x0
	// Position of ODR6 field.
	GPIO_ODR_ODR6_Pos = 0x6
	// Bit mask of ODR6 field.
	GPIO_ODR_ODR6_Msk = 0x40
	// Bit ODR6.
	GPIO_ODR_ODR6 = 0x40
	// Set output to logic high
	GPIO_ODR_ODR6_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR6_Low = 0x0
	// Position of ODR5 field.
	GPIO_ODR_ODR5_Pos = 0x5
	// Bit mask of ODR5 field.
	GPIO_ODR_ODR5_Msk = 0x20
	// Bit ODR5.
	GPIO_ODR_ODR5 = 0x20
	// Set output to logic high
	GPIO_ODR_ODR5_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR5_Low = 0x0
	// Position of ODR4 field.
	GPIO_ODR_ODR4_Pos = 0x4
	// Bit mask of ODR4 field.
	GPIO_ODR_ODR4_Msk = 0x10
	// Bit ODR4.
	GPIO_ODR_ODR4 = 0x10
	// Set output to logic high
	GPIO_ODR_ODR4_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR4_Low = 0x0
	// Position of ODR3 field.
	GPIO_ODR_ODR3_Pos = 0x3
	// Bit mask of ODR3 field.
	GPIO_ODR_ODR3_Msk = 0x8
	// Bit ODR3.
	GPIO_ODR_ODR3 = 0x8
	// Set output to logic high
	GPIO_ODR_ODR3_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR3_Low = 0x0
	// Position of ODR2 field.
	GPIO_ODR_ODR2_Pos = 0x2
	// Bit mask of ODR2 field.
	GPIO_ODR_ODR2_Msk = 0x4
	// Bit ODR2.
	GPIO_ODR_ODR2 = 0x4
	// Set output to logic high
	GPIO_ODR_ODR2_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR2_Low = 0x0
	// Position of ODR1 field.
	GPIO_ODR_ODR1_Pos = 0x1
	// Bit mask of ODR1 field.
	GPIO_ODR_ODR1_Msk = 0x2
	// Bit ODR1.
	GPIO_ODR_ODR1 = 0x2
	// Set output to logic high
	GPIO_ODR_ODR1_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR1_Low = 0x0
	// Position of ODR0 field.
	GPIO_ODR_ODR0_Pos = 0x0
	// Bit mask of ODR0 field.
	GPIO_ODR_ODR0_Msk = 0x1
	// Bit ODR0.
	GPIO_ODR_ODR0 = 0x1
	// Set output to logic high
	GPIO_ODR_ODR0_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR0_Low = 0x0

	// BSRR: GPIO port bit set/reset register
	// Position of BR15 field.
	GPIO_BSRR_BR15_Pos = 0x1f
	// Bit mask of BR15 field.
	GPIO_BSRR_BR15_Msk = 0x80000000
	// Bit BR15.
	GPIO_BSRR_BR15 = 0x80000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR15_Reset = 0x1
	// Position of BR14 field.
	GPIO_BSRR_BR14_Pos = 0x1e
	// Bit mask of BR14 field.
	GPIO_BSRR_BR14_Msk = 0x40000000
	// Bit BR14.
	GPIO_BSRR_BR14 = 0x40000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR14_Reset = 0x1
	// Position of BR13 field.
	GPIO_BSRR_BR13_Pos = 0x1d
	// Bit mask of BR13 field.
	GPIO_BSRR_BR13_Msk = 0x20000000
	// Bit BR13.
	GPIO_BSRR_BR13 = 0x20000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR13_Reset = 0x1
	// Position of BR12 field.
	GPIO_BSRR_BR12_Pos = 0x1c
	// Bit mask of BR12 field.
	GPIO_BSRR_BR12_Msk = 0x10000000
	// Bit BR12.
	GPIO_BSRR_BR12 = 0x10000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR12_Reset = 0x1
	// Position of BR11 field.
	GPIO_BSRR_BR11_Pos = 0x1b
	// Bit mask of BR11 field.
	GPIO_BSRR_BR11_Msk = 0x8000000
	// Bit BR11.
	GPIO_BSRR_BR11 = 0x8000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR11_Reset = 0x1
	// Position of BR10 field.
	GPIO_BSRR_BR10_Pos = 0x1a
	// Bit mask of BR10 field.
	GPIO_BSRR_BR10_Msk = 0x4000000
	// Bit BR10.
	GPIO_BSRR_BR10 = 0x4000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR10_Reset = 0x1
	// Position of BR9 field.
	GPIO_BSRR_BR9_Pos = 0x19
	// Bit mask of BR9 field.
	GPIO_BSRR_BR9_Msk = 0x2000000
	// Bit BR9.
	GPIO_BSRR_BR9 = 0x2000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR9_Reset = 0x1
	// Position of BR8 field.
	GPIO_BSRR_BR8_Pos = 0x18
	// Bit mask of BR8 field.
	GPIO_BSRR_BR8_Msk = 0x1000000
	// Bit BR8.
	GPIO_BSRR_BR8 = 0x1000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR8_Reset = 0x1
	// Position of BR7 field.
	GPIO_BSRR_BR7_Pos = 0x17
	// Bit mask of BR7 field.
	GPIO_BSRR_BR7_Msk = 0x800000
	// Bit BR7.
	GPIO_BSRR_BR7 = 0x800000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR7_Reset = 0x1
	// Position of BR6 field.
	GPIO_BSRR_BR6_Pos = 0x16
	// Bit mask of BR6 field.
	GPIO_BSRR_BR6_Msk = 0x400000
	// Bit BR6.
	GPIO_BSRR_BR6 = 0x400000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR6_Reset = 0x1
	// Position of BR5 field.
	GPIO_BSRR_BR5_Pos = 0x15
	// Bit mask of BR5 field.
	GPIO_BSRR_BR5_Msk = 0x200000
	// Bit BR5.
	GPIO_BSRR_BR5 = 0x200000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR5_Reset = 0x1
	// Position of BR4 field.
	GPIO_BSRR_BR4_Pos = 0x14
	// Bit mask of BR4 field.
	GPIO_BSRR_BR4_Msk = 0x100000
	// Bit BR4.
	GPIO_BSRR_BR4 = 0x100000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR4_Reset = 0x1
	// Position of BR3 field.
	GPIO_BSRR_BR3_Pos = 0x13
	// Bit mask of BR3 field.
	GPIO_BSRR_BR3_Msk = 0x80000
	// Bit BR3.
	GPIO_BSRR_BR3 = 0x80000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR3_Reset = 0x1
	// Position of BR2 field.
	GPIO_BSRR_BR2_Pos = 0x12
	// Bit mask of BR2 field.
	GPIO_BSRR_BR2_Msk = 0x40000
	// Bit BR2.
	GPIO_BSRR_BR2 = 0x40000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR2_Reset = 0x1
	// Position of BR1 field.
	GPIO_BSRR_BR1_Pos = 0x11
	// Bit mask of BR1 field.
	GPIO_BSRR_BR1_Msk = 0x20000
	// Bit BR1.
	GPIO_BSRR_BR1 = 0x20000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR1_Reset = 0x1
	// Position of BR0 field.
	GPIO_BSRR_BR0_Pos = 0x10
	// Bit mask of BR0 field.
	GPIO_BSRR_BR0_Msk = 0x10000
	// Bit BR0.
	GPIO_BSRR_BR0 = 0x10000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR0_Reset = 0x1
	// Position of BS15 field.
	GPIO_BSRR_BS15_Pos = 0xf
	// Bit mask of BS15 field.
	GPIO_BSRR_BS15_Msk = 0x8000
	// Bit BS15.
	GPIO_BSRR_BS15 = 0x8000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS15_Set = 0x1
	// Position of BS14 field.
	GPIO_BSRR_BS14_Pos = 0xe
	// Bit mask of BS14 field.
	GPIO_BSRR_BS14_Msk = 0x4000
	// Bit BS14.
	GPIO_BSRR_BS14 = 0x4000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS14_Set = 0x1
	// Position of BS13 field.
	GPIO_BSRR_BS13_Pos = 0xd
	// Bit mask of BS13 field.
	GPIO_BSRR_BS13_Msk = 0x2000
	// Bit BS13.
	GPIO_BSRR_BS13 = 0x2000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS13_Set = 0x1
	// Position of BS12 field.
	GPIO_BSRR_BS12_Pos = 0xc
	// Bit mask of BS12 field.
	GPIO_BSRR_BS12_Msk = 0x1000
	// Bit BS12.
	GPIO_BSRR_BS12 = 0x1000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS12_Set = 0x1
	// Position of BS11 field.
	GPIO_BSRR_BS11_Pos = 0xb
	// Bit mask of BS11 field.
	GPIO_BSRR_BS11_Msk = 0x800
	// Bit BS11.
	GPIO_BSRR_BS11 = 0x800
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS11_Set = 0x1
	// Position of BS10 field.
	GPIO_BSRR_BS10_Pos = 0xa
	// Bit mask of BS10 field.
	GPIO_BSRR_BS10_Msk = 0x400
	// Bit BS10.
	GPIO_BSRR_BS10 = 0x400
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS10_Set = 0x1
	// Position of BS9 field.
	GPIO_BSRR_BS9_Pos = 0x9
	// Bit mask of BS9 field.
	GPIO_BSRR_BS9_Msk = 0x200
	// Bit BS9.
	GPIO_BSRR_BS9 = 0x200
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS9_Set = 0x1
	// Position of BS8 field.
	GPIO_BSRR_BS8_Pos = 0x8
	// Bit mask of BS8 field.
	GPIO_BSRR_BS8_Msk = 0x100
	// Bit BS8.
	GPIO_BSRR_BS8 = 0x100
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS8_Set = 0x1
	// Position of BS7 field.
	GPIO_BSRR_BS7_Pos = 0x7
	// Bit mask of BS7 field.
	GPIO_BSRR_BS7_Msk = 0x80
	// Bit BS7.
	GPIO_BSRR_BS7 = 0x80
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS7_Set = 0x1
	// Position of BS6 field.
	GPIO_BSRR_BS6_Pos = 0x6
	// Bit mask of BS6 field.
	GPIO_BSRR_BS6_Msk = 0x40
	// Bit BS6.
	GPIO_BSRR_BS6 = 0x40
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS6_Set = 0x1
	// Position of BS5 field.
	GPIO_BSRR_BS5_Pos = 0x5
	// Bit mask of BS5 field.
	GPIO_BSRR_BS5_Msk = 0x20
	// Bit BS5.
	GPIO_BSRR_BS5 = 0x20
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS5_Set = 0x1
	// Position of BS4 field.
	GPIO_BSRR_BS4_Pos = 0x4
	// Bit mask of BS4 field.
	GPIO_BSRR_BS4_Msk = 0x10
	// Bit BS4.
	GPIO_BSRR_BS4 = 0x10
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS4_Set = 0x1
	// Position of BS3 field.
	GPIO_BSRR_BS3_Pos = 0x3
	// Bit mask of BS3 field.
	GPIO_BSRR_BS3_Msk = 0x8
	// Bit BS3.
	GPIO_BSRR_BS3 = 0x8
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS3_Set = 0x1
	// Position of BS2 field.
	GPIO_BSRR_BS2_Pos = 0x2
	// Bit mask of BS2 field.
	GPIO_BSRR_BS2_Msk = 0x4
	// Bit BS2.
	GPIO_BSRR_BS2 = 0x4
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS2_Set = 0x1
	// Position of BS1 field.
	GPIO_BSRR_BS1_Pos = 0x1
	// Bit mask of BS1 field.
	GPIO_BSRR_BS1_Msk = 0x2
	// Bit BS1.
	GPIO_BSRR_BS1 = 0x2
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS1_Set = 0x1
	// Position of BS0 field.
	GPIO_BSRR_BS0_Pos = 0x0
	// Bit mask of BS0 field.
	GPIO_BSRR_BS0_Msk = 0x1
	// Bit BS0.
	GPIO_BSRR_BS0 = 0x1
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS0_Set = 0x1

	// LCKR: GPIO port configuration lock register
	// Position of LCKK field.
	GPIO_LCKR_LCKK_Pos = 0x10
	// Bit mask of LCKK field.
	GPIO_LCKR_LCKK_Msk = 0x10000
	// Bit LCKK.
	GPIO_LCKR_LCKK = 0x10000
	// Position of LCK15 field.
	GPIO_LCKR_LCK15_Pos = 0xf
	// Bit mask of LCK15 field.
	GPIO_LCKR_LCK15_Msk = 0x8000
	// Bit LCK15.
	GPIO_LCKR_LCK15 = 0x8000
	// Position of LCK14 field.
	GPIO_LCKR_LCK14_Pos = 0xe
	// Bit mask of LCK14 field.
	GPIO_LCKR_LCK14_Msk = 0x4000
	// Bit LCK14.
	GPIO_LCKR_LCK14 = 0x4000
	// Position of LCK13 field.
	GPIO_LCKR_LCK13_Pos = 0xd
	// Bit mask of LCK13 field.
	GPIO_LCKR_LCK13_Msk = 0x2000
	// Bit LCK13.
	GPIO_LCKR_LCK13 = 0x2000
	// Position of LCK12 field.
	GPIO_LCKR_LCK12_Pos = 0xc
	// Bit mask of LCK12 field.
	GPIO_LCKR_LCK12_Msk = 0x1000
	// Bit LCK12.
	GPIO_LCKR_LCK12 = 0x1000
	// Position of LCK11 field.
	GPIO_LCKR_LCK11_Pos = 0xb
	// Bit mask of LCK11 field.
	GPIO_LCKR_LCK11_Msk = 0x800
	// Bit LCK11.
	GPIO_LCKR_LCK11 = 0x800
	// Position of LCK10 field.
	GPIO_LCKR_LCK10_Pos = 0xa
	// Bit mask of LCK10 field.
	GPIO_LCKR_LCK10_Msk = 0x400
	// Bit LCK10.
	GPIO_LCKR_LCK10 = 0x400
	// Position of LCK9 field.
	GPIO_LCKR_LCK9_Pos = 0x9
	// Bit mask of LCK9 field.
	GPIO_LCKR_LCK9_Msk = 0x200
	// Bit LCK9.
	GPIO_LCKR_LCK9 = 0x200
	// Position of LCK8 field.
	GPIO_LCKR_LCK8_Pos = 0x8
	// Bit mask of LCK8 field.
	GPIO_LCKR_LCK8_Msk = 0x100
	// Bit LCK8.
	GPIO_LCKR_LCK8 = 0x100
	// Position of LCK7 field.
	GPIO_LCKR_LCK7_Pos = 0x7
	// Bit mask of LCK7 field.
	GPIO_LCKR_LCK7_Msk = 0x80
	// Bit LCK7.
	GPIO_LCKR_LCK7 = 0x80
	// Position of LCK6 field.
	GPIO_LCKR_LCK6_Pos = 0x6
	// Bit mask of LCK6 field.
	GPIO_LCKR_LCK6_Msk = 0x40
	// Bit LCK6.
	GPIO_LCKR_LCK6 = 0x40
	// Position of LCK5 field.
	GPIO_LCKR_LCK5_Pos = 0x5
	// Bit mask of LCK5 field.
	GPIO_LCKR_LCK5_Msk = 0x20
	// Bit LCK5.
	GPIO_LCKR_LCK5 = 0x20
	// Position of LCK4 field.
	GPIO_LCKR_LCK4_Pos = 0x4
	// Bit mask of LCK4 field.
	GPIO_LCKR_LCK4_Msk = 0x10
	// Bit LCK4.
	GPIO_LCKR_LCK4 = 0x10
	// Position of LCK3 field.
	GPIO_LCKR_LCK3_Pos = 0x3
	// Bit mask of LCK3 field.
	GPIO_LCKR_LCK3_Msk = 0x8
	// Bit LCK3.
	GPIO_LCKR_LCK3 = 0x8
	// Position of LCK2 field.
	GPIO_LCKR_LCK2_Pos = 0x2
	// Bit mask of LCK2 field.
	GPIO_LCKR_LCK2_Msk = 0x4
	// Bit LCK2.
	GPIO_LCKR_LCK2 = 0x4
	// Position of LCK1 field.
	GPIO_LCKR_LCK1_Pos = 0x1
	// Bit mask of LCK1 field.
	GPIO_LCKR_LCK1_Msk = 0x2
	// Bit LCK1.
	GPIO_LCKR_LCK1 = 0x2
	// Position of LCK0 field.
	GPIO_LCKR_LCK0_Pos = 0x0
	// Bit mask of LCK0 field.
	GPIO_LCKR_LCK0_Msk = 0x1
	// Bit LCK0.
	GPIO_LCKR_LCK0 = 0x1

	// AFRL: GPIO alternate function low register
	// Position of AFRL7 field.
	GPIO_AFRL_AFRL7_Pos = 0x1c
	// Bit mask of AFRL7 field.
	GPIO_AFRL_AFRL7_Msk = 0xf0000000
	// AF0
	GPIO_AFRL_AFRL7_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL7_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL7_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL7_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL7_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL7_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL7_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL7_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL7_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL7_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL7_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL7_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL7_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL7_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL7_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL7_AF15 = 0xf
	// Position of AFRL6 field.
	GPIO_AFRL_AFRL6_Pos = 0x18
	// Bit mask of AFRL6 field.
	GPIO_AFRL_AFRL6_Msk = 0xf000000
	// AF0
	GPIO_AFRL_AFRL6_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL6_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL6_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL6_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL6_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL6_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL6_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL6_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL6_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL6_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL6_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL6_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL6_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL6_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL6_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL6_AF15 = 0xf
	// Position of AFRL5 field.
	GPIO_AFRL_AFRL5_Pos = 0x14
	// Bit mask of AFRL5 field.
	GPIO_AFRL_AFRL5_Msk = 0xf00000
	// AF0
	GPIO_AFRL_AFRL5_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL5_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL5_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL5_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL5_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL5_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL5_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL5_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL5_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL5_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL5_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL5_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL5_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL5_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL5_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL5_AF15 = 0xf
	// Position of AFRL4 field.
	GPIO_AFRL_AFRL4_Pos = 0x10
	// Bit mask of AFRL4 field.
	GPIO_AFRL_AFRL4_Msk = 0xf0000
	// AF0
	GPIO_AFRL_AFRL4_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL4_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL4_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL4_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL4_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL4_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL4_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL4_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL4_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL4_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL4_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL4_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL4_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL4_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL4_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL4_AF15 = 0xf
	// Position of AFRL3 field.
	GPIO_AFRL_AFRL3_Pos = 0xc
	// Bit mask of AFRL3 field.
	GPIO_AFRL_AFRL3_Msk = 0xf000
	// AF0
	GPIO_AFRL_AFRL3_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL3_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL3_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL3_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL3_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL3_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL3_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL3_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL3_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL3_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL3_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL3_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL3_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL3_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL3_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL3_AF15 = 0xf
	// Position of AFRL2 field.
	GPIO_AFRL_AFRL2_Pos = 0x8
	// Bit mask of AFRL2 field.
	GPIO_AFRL_AFRL2_Msk = 0xf00
	// AF0
	GPIO_AFRL_AFRL2_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL2_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL2_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL2_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL2_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL2_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL2_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL2_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL2_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL2_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL2_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL2_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL2_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL2_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL2_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL2_AF15 = 0xf
	// Position of AFRL1 field.
	GPIO_AFRL_AFRL1_Pos = 0x4
	// Bit mask of AFRL1 field.
	GPIO_AFRL_AFRL1_Msk = 0xf0
	// AF0
	GPIO_AFRL_AFRL1_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL1_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL1_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL1_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL1_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL1_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL1_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL1_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL1_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL1_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL1_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL1_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL1_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL1_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL1_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL1_AF15 = 0xf
	// Position of AFRL0 field.
	GPIO_AFRL_AFRL0_Pos = 0x0
	// Bit mask of AFRL0 field.
	GPIO_AFRL_AFRL0_Msk = 0xf
	// AF0
	GPIO_AFRL_AFRL0_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL0_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL0_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL0_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL0_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL0_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL0_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL0_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL0_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL0_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL0_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL0_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL0_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL0_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL0_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL0_AF15 = 0xf

	// AFRH: GPIO alternate function high register
	// Position of AFRH15 field.
	GPIO_AFRH_AFRH15_Pos = 0x1c
	// Bit mask of AFRH15 field.
	GPIO_AFRH_AFRH15_Msk = 0xf0000000
	// AF0
	GPIO_AFRH_AFRH15_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH15_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH15_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH15_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH15_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH15_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH15_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH15_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH15_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH15_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH15_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH15_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH15_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH15_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH15_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH15_AF15 = 0xf
	// Position of AFRH14 field.
	GPIO_AFRH_AFRH14_Pos = 0x18
	// Bit mask of AFRH14 field.
	GPIO_AFRH_AFRH14_Msk = 0xf000000
	// AF0
	GPIO_AFRH_AFRH14_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH14_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH14_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH14_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH14_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH14_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH14_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH14_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH14_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH14_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH14_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH14_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH14_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH14_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH14_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH14_AF15 = 0xf
	// Position of AFRH13 field.
	GPIO_AFRH_AFRH13_Pos = 0x14
	// Bit mask of AFRH13 field.
	GPIO_AFRH_AFRH13_Msk = 0xf00000
	// AF0
	GPIO_AFRH_AFRH13_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH13_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH13_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH13_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH13_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH13_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH13_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH13_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH13_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH13_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH13_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH13_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH13_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH13_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH13_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH13_AF15 = 0xf
	// Position of AFRH12 field.
	GPIO_AFRH_AFRH12_Pos = 0x10
	// Bit mask of AFRH12 field.
	GPIO_AFRH_AFRH12_Msk = 0xf0000
	// AF0
	GPIO_AFRH_AFRH12_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH12_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH12_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH12_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH12_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH12_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH12_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH12_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH12_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH12_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH12_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH12_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH12_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH12_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH12_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH12_AF15 = 0xf
	// Position of AFRH11 field.
	GPIO_AFRH_AFRH11_Pos = 0xc
	// Bit mask of AFRH11 field.
	GPIO_AFRH_AFRH11_Msk = 0xf000
	// AF0
	GPIO_AFRH_AFRH11_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH11_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH11_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH11_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH11_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH11_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH11_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH11_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH11_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH11_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH11_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH11_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH11_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH11_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH11_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH11_AF15 = 0xf
	// Position of AFRH10 field.
	GPIO_AFRH_AFRH10_Pos = 0x8
	// Bit mask of AFRH10 field.
	GPIO_AFRH_AFRH10_Msk = 0xf00
	// AF0
	GPIO_AFRH_AFRH10_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH10_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH10_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH10_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH10_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH10_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH10_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH10_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH10_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH10_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH10_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH10_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH10_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH10_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH10_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH10_AF15 = 0xf
	// Position of AFRH9 field.
	GPIO_AFRH_AFRH9_Pos = 0x4
	// Bit mask of AFRH9 field.
	GPIO_AFRH_AFRH9_Msk = 0xf0
	// AF0
	GPIO_AFRH_AFRH9_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH9_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH9_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH9_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH9_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH9_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH9_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH9_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH9_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH9_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH9_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH9_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH9_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH9_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH9_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH9_AF15 = 0xf
	// Position of AFRH8 field.
	GPIO_AFRH_AFRH8_Pos = 0x0
	// Bit mask of AFRH8 field.
	GPIO_AFRH_AFRH8_Msk = 0xf
	// AF0
	GPIO_AFRH_AFRH8_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH8_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH8_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH8_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH8_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH8_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH8_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH8_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH8_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH8_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH8_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH8_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH8_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH8_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH8_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH8_AF15 = 0xf

	// BRR: GPIO port bit reset register
	// Position of BR0 field.
	GPIO_BRR_BR0_Pos = 0x0
	// Bit mask of BR0 field.
	GPIO_BRR_BR0_Msk = 0x1
	// Bit BR0.
	GPIO_BRR_BR0 = 0x1
	// No action on the corresponding ODx bit
	GPIO_BRR_BR0_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR0_Reset = 0x1
	// Position of BR1 field.
	GPIO_BRR_BR1_Pos = 0x1
	// Bit mask of BR1 field.
	GPIO_BRR_BR1_Msk = 0x2
	// Bit BR1.
	GPIO_BRR_BR1 = 0x2
	// No action on the corresponding ODx bit
	GPIO_BRR_BR1_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR1_Reset = 0x1
	// Position of BR2 field.
	GPIO_BRR_BR2_Pos = 0x2
	// Bit mask of BR2 field.
	GPIO_BRR_BR2_Msk = 0x4
	// Bit BR2.
	GPIO_BRR_BR2 = 0x4
	// No action on the corresponding ODx bit
	GPIO_BRR_BR2_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR2_Reset = 0x1
	// Position of BR3 field.
	GPIO_BRR_BR3_Pos = 0x3
	// Bit mask of BR3 field.
	GPIO_BRR_BR3_Msk = 0x8
	// Bit BR3.
	GPIO_BRR_BR3 = 0x8
	// No action on the corresponding ODx bit
	GPIO_BRR_BR3_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR3_Reset = 0x1
	// Position of BR4 field.
	GPIO_BRR_BR4_Pos = 0x4
	// Bit mask of BR4 field.
	GPIO_BRR_BR4_Msk = 0x10
	// Bit BR4.
	GPIO_BRR_BR4 = 0x10
	// No action on the corresponding ODx bit
	GPIO_BRR_BR4_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR4_Reset = 0x1
	// Position of BR5 field.
	GPIO_BRR_BR5_Pos = 0x5
	// Bit mask of BR5 field.
	GPIO_BRR_BR5_Msk = 0x20
	// Bit BR5.
	GPIO_BRR_BR5 = 0x20
	// No action on the corresponding ODx bit
	GPIO_BRR_BR5_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR5_Reset = 0x1
	// Position of BR6 field.
	GPIO_BRR_BR6_Pos = 0x6
	// Bit mask of BR6 field.
	GPIO_BRR_BR6_Msk = 0x40
	// Bit BR6.
	GPIO_BRR_BR6 = 0x40
	// No action on the corresponding ODx bit
	GPIO_BRR_BR6_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR6_Reset = 0x1
	// Position of BR7 field.
	GPIO_BRR_BR7_Pos = 0x7
	// Bit mask of BR7 field.
	GPIO_BRR_BR7_Msk = 0x80
	// Bit BR7.
	GPIO_BRR_BR7 = 0x80
	// No action on the corresponding ODx bit
	GPIO_BRR_BR7_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR7_Reset = 0x1
	// Position of BR8 field.
	GPIO_BRR_BR8_Pos = 0x8
	// Bit mask of BR8 field.
	GPIO_BRR_BR8_Msk = 0x100
	// Bit BR8.
	GPIO_BRR_BR8 = 0x100
	// No action on the corresponding ODx bit
	GPIO_BRR_BR8_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR8_Reset = 0x1
	// Position of BR9 field.
	GPIO_BRR_BR9_Pos = 0x9
	// Bit mask of BR9 field.
	GPIO_BRR_BR9_Msk = 0x200
	// Bit BR9.
	GPIO_BRR_BR9 = 0x200
	// No action on the corresponding ODx bit
	GPIO_BRR_BR9_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR9_Reset = 0x1
	// Position of BR10 field.
	GPIO_BRR_BR10_Pos = 0xa
	// Bit mask of BR10 field.
	GPIO_BRR_BR10_Msk = 0x400
	// Bit BR10.
	GPIO_BRR_BR10 = 0x400
	// No action on the corresponding ODx bit
	GPIO_BRR_BR10_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR10_Reset = 0x1
	// Position of BR11 field.
	GPIO_BRR_BR11_Pos = 0xb
	// Bit mask of BR11 field.
	GPIO_BRR_BR11_Msk = 0x800
	// Bit BR11.
	GPIO_BRR_BR11 = 0x800
	// No action on the corresponding ODx bit
	GPIO_BRR_BR11_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR11_Reset = 0x1
	// Position of BR12 field.
	GPIO_BRR_BR12_Pos = 0xc
	// Bit mask of BR12 field.
	GPIO_BRR_BR12_Msk = 0x1000
	// Bit BR12.
	GPIO_BRR_BR12 = 0x1000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR12_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR12_Reset = 0x1
	// Position of BR13 field.
	GPIO_BRR_BR13_Pos = 0xd
	// Bit mask of BR13 field.
	GPIO_BRR_BR13_Msk = 0x2000
	// Bit BR13.
	GPIO_BRR_BR13 = 0x2000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR13_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR13_Reset = 0x1
	// Position of BR14 field.
	GPIO_BRR_BR14_Pos = 0xe
	// Bit mask of BR14 field.
	GPIO_BRR_BR14_Msk = 0x4000
	// Bit BR14.
	GPIO_BRR_BR14 = 0x4000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR14_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR14_Reset = 0x1
	// Position of BR15 field.
	GPIO_BRR_BR15_Pos = 0xf
	// Bit mask of BR15 field.
	GPIO_BRR_BR15_Msk = 0x8000
	// Bit BR15.
	GPIO_BRR_BR15 = 0x8000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR15_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR15_Reset = 0x1
)

// Constants for HSEM: Hardware semaphore
const (
	// R0: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R0_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R0_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R0_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R0_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R0_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R0_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R0_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R0_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R0_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R0_LOCK_TryLock = 0x1

	// R1: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R1_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R1_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R1_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R1_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R1_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R1_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R1_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R1_LOCK_TryLock = 0x1

	// R2: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R2_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R2_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R2_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R2_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R2_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R2_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R2_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R2_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R2_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R2_LOCK_TryLock = 0x1

	// R3: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R3_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R3_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R3_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R3_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R3_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R3_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R3_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R3_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R3_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R3_LOCK_TryLock = 0x1

	// R4: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R4_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R4_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R4_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R4_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R4_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R4_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R4_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R4_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R4_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R4_LOCK_TryLock = 0x1

	// R5: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R5_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R5_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R5_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R5_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R5_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R5_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R5_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R5_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R5_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R5_LOCK_TryLock = 0x1

	// R6: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R6_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R6_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R6_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R6_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R6_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R6_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R6_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R6_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R6_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R6_LOCK_TryLock = 0x1

	// R7: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R7_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R7_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R7_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R7_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R7_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R7_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R7_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R7_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R7_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R7_LOCK_TryLock = 0x1

	// R8: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R8_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R8_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R8_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R8_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R8_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R8_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R8_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R8_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R8_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R8_LOCK_TryLock = 0x1

	// R9: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R9_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R9_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R9_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R9_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R9_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R9_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R9_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R9_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R9_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R9_LOCK_TryLock = 0x1

	// R10: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R10_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R10_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R10_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R10_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R10_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R10_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R10_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R10_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R10_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R10_LOCK_TryLock = 0x1

	// R11: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R11_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R11_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R11_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R11_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R11_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R11_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R11_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R11_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R11_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R11_LOCK_TryLock = 0x1

	// R12: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R12_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R12_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R12_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R12_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R12_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R12_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R12_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R12_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R12_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R12_LOCK_TryLock = 0x1

	// R13: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R13_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R13_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R13_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R13_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R13_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R13_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R13_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R13_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R13_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R13_LOCK_TryLock = 0x1

	// R14: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R14_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R14_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R14_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R14_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R14_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R14_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R14_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R14_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R14_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R14_LOCK_TryLock = 0x1

	// R15: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R15_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R15_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_R15_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_R15_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_R15_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R15_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R15_LOCK = 0x80000000
	// Semaphore is free
	HSEM_R15_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_R15_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_R15_LOCK_TryLock = 0x1

	// RLR0: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR0_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR0_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR0_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR0_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR0_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR0_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR0_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR0_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR0_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR0_LOCK_TryLock = 0x1

	// RLR1: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR1_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR1_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR1_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR1_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR1_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR1_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR1_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR1_LOCK_TryLock = 0x1

	// RLR2: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR2_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR2_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR2_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR2_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR2_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR2_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR2_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR2_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR2_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR2_LOCK_TryLock = 0x1

	// RLR3: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR3_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR3_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR3_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR3_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR3_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR3_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR3_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR3_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR3_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR3_LOCK_TryLock = 0x1

	// RLR4: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR4_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR4_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR4_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR4_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR4_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR4_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR4_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR4_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR4_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR4_LOCK_TryLock = 0x1

	// RLR5: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR5_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR5_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR5_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR5_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR5_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR5_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR5_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR5_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR5_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR5_LOCK_TryLock = 0x1

	// RLR6: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR6_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR6_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR6_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR6_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR6_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR6_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR6_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR6_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR6_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR6_LOCK_TryLock = 0x1

	// RLR7: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR7_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR7_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR7_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR7_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR7_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR7_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR7_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR7_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR7_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR7_LOCK_TryLock = 0x1

	// RLR8: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR8_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR8_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR8_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR8_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR8_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR8_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR8_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR8_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR8_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR8_LOCK_TryLock = 0x1

	// RLR9: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR9_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR9_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR9_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR9_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR9_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR9_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR9_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR9_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR9_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR9_LOCK_TryLock = 0x1

	// RLR10: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR10_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR10_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR10_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR10_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR10_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR10_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR10_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR10_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR10_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR10_LOCK_TryLock = 0x1

	// RLR11: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR11_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR11_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR11_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR11_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR11_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR11_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR11_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR11_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR11_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR11_LOCK_TryLock = 0x1

	// RLR12: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR12_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR12_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR12_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR12_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR12_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR12_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR12_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR12_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR12_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR12_LOCK_TryLock = 0x1

	// RLR13: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR13_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR13_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR13_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR13_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR13_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR13_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR13_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR13_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR13_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR13_LOCK_TryLock = 0x1

	// RLR14: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR14_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR14_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR14_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR14_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR14_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR14_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR14_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR14_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR14_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR14_LOCK_TryLock = 0x1

	// RLR15: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR15_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR15_PROCID_Msk = 0xff
	// Position of COREID field.
	HSEM_RLR15_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_RLR15_COREID_Msk = 0xf00
	// Position of LOCK field.
	HSEM_RLR15_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR15_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR15_LOCK = 0x80000000
	// Semaphore is free
	HSEM_RLR15_LOCK_Free = 0x0
	// Semaphore is locked
	HSEM_RLR15_LOCK_Locked = 0x1
	// Try to lock semaphore
	HSEM_RLR15_LOCK_TryLock = 0x1

	// C1IER: HSEM Interrupt enable register
	// Position of ISE0 field.
	HSEM_C1IER_ISE0_Pos = 0x0
	// Bit mask of ISE0 field.
	HSEM_C1IER_ISE0_Msk = 0x1
	// Bit ISE0.
	HSEM_C1IER_ISE0 = 0x1
	// Interrupt generation disabled
	HSEM_C1IER_ISE0_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE0_Enabled = 0x1
	// Position of ISE1 field.
	HSEM_C1IER_ISE1_Pos = 0x1
	// Bit mask of ISE1 field.
	HSEM_C1IER_ISE1_Msk = 0x2
	// Bit ISE1.
	HSEM_C1IER_ISE1 = 0x2
	// Interrupt generation disabled
	HSEM_C1IER_ISE1_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE1_Enabled = 0x1
	// Position of ISE2 field.
	HSEM_C1IER_ISE2_Pos = 0x2
	// Bit mask of ISE2 field.
	HSEM_C1IER_ISE2_Msk = 0x4
	// Bit ISE2.
	HSEM_C1IER_ISE2 = 0x4
	// Interrupt generation disabled
	HSEM_C1IER_ISE2_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE2_Enabled = 0x1
	// Position of ISE3 field.
	HSEM_C1IER_ISE3_Pos = 0x3
	// Bit mask of ISE3 field.
	HSEM_C1IER_ISE3_Msk = 0x8
	// Bit ISE3.
	HSEM_C1IER_ISE3 = 0x8
	// Interrupt generation disabled
	HSEM_C1IER_ISE3_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE3_Enabled = 0x1
	// Position of ISE4 field.
	HSEM_C1IER_ISE4_Pos = 0x4
	// Bit mask of ISE4 field.
	HSEM_C1IER_ISE4_Msk = 0x10
	// Bit ISE4.
	HSEM_C1IER_ISE4 = 0x10
	// Interrupt generation disabled
	HSEM_C1IER_ISE4_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE4_Enabled = 0x1
	// Position of ISE5 field.
	HSEM_C1IER_ISE5_Pos = 0x5
	// Bit mask of ISE5 field.
	HSEM_C1IER_ISE5_Msk = 0x20
	// Bit ISE5.
	HSEM_C1IER_ISE5 = 0x20
	// Interrupt generation disabled
	HSEM_C1IER_ISE5_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE5_Enabled = 0x1
	// Position of ISE6 field.
	HSEM_C1IER_ISE6_Pos = 0x6
	// Bit mask of ISE6 field.
	HSEM_C1IER_ISE6_Msk = 0x40
	// Bit ISE6.
	HSEM_C1IER_ISE6 = 0x40
	// Interrupt generation disabled
	HSEM_C1IER_ISE6_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE6_Enabled = 0x1
	// Position of ISE7 field.
	HSEM_C1IER_ISE7_Pos = 0x7
	// Bit mask of ISE7 field.
	HSEM_C1IER_ISE7_Msk = 0x80
	// Bit ISE7.
	HSEM_C1IER_ISE7 = 0x80
	// Interrupt generation disabled
	HSEM_C1IER_ISE7_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE7_Enabled = 0x1
	// Position of ISE8 field.
	HSEM_C1IER_ISE8_Pos = 0x8
	// Bit mask of ISE8 field.
	HSEM_C1IER_ISE8_Msk = 0x100
	// Bit ISE8.
	HSEM_C1IER_ISE8 = 0x100
	// Interrupt generation disabled
	HSEM_C1IER_ISE8_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE8_Enabled = 0x1
	// Position of ISE9 field.
	HSEM_C1IER_ISE9_Pos = 0x9
	// Bit mask of ISE9 field.
	HSEM_C1IER_ISE9_Msk = 0x200
	// Bit ISE9.
	HSEM_C1IER_ISE9 = 0x200
	// Interrupt generation disabled
	HSEM_C1IER_ISE9_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE9_Enabled = 0x1
	// Position of ISE10 field.
	HSEM_C1IER_ISE10_Pos = 0xa
	// Bit mask of ISE10 field.
	HSEM_C1IER_ISE10_Msk = 0x400
	// Bit ISE10.
	HSEM_C1IER_ISE10 = 0x400
	// Interrupt generation disabled
	HSEM_C1IER_ISE10_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE10_Enabled = 0x1
	// Position of ISE11 field.
	HSEM_C1IER_ISE11_Pos = 0xb
	// Bit mask of ISE11 field.
	HSEM_C1IER_ISE11_Msk = 0x800
	// Bit ISE11.
	HSEM_C1IER_ISE11 = 0x800
	// Interrupt generation disabled
	HSEM_C1IER_ISE11_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE11_Enabled = 0x1
	// Position of ISE12 field.
	HSEM_C1IER_ISE12_Pos = 0xc
	// Bit mask of ISE12 field.
	HSEM_C1IER_ISE12_Msk = 0x1000
	// Bit ISE12.
	HSEM_C1IER_ISE12 = 0x1000
	// Interrupt generation disabled
	HSEM_C1IER_ISE12_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE12_Enabled = 0x1
	// Position of ISE13 field.
	HSEM_C1IER_ISE13_Pos = 0xd
	// Bit mask of ISE13 field.
	HSEM_C1IER_ISE13_Msk = 0x2000
	// Bit ISE13.
	HSEM_C1IER_ISE13 = 0x2000
	// Interrupt generation disabled
	HSEM_C1IER_ISE13_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE13_Enabled = 0x1
	// Position of ISE14 field.
	HSEM_C1IER_ISE14_Pos = 0xe
	// Bit mask of ISE14 field.
	HSEM_C1IER_ISE14_Msk = 0x4000
	// Bit ISE14.
	HSEM_C1IER_ISE14 = 0x4000
	// Interrupt generation disabled
	HSEM_C1IER_ISE14_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE14_Enabled = 0x1
	// Position of ISE15 field.
	HSEM_C1IER_ISE15_Pos = 0xf
	// Bit mask of ISE15 field.
	HSEM_C1IER_ISE15_Msk = 0x8000
	// Bit ISE15.
	HSEM_C1IER_ISE15 = 0x8000
	// Interrupt generation disabled
	HSEM_C1IER_ISE15_Disabled = 0x0
	// Interrupt generation enabled
	HSEM_C1IER_ISE15_Enabled = 0x1

	// C1ICR: HSEM Interrupt clear register
	// Position of ISC0 field.
	HSEM_C1ICR_ISC0_Pos = 0x0
	// Bit mask of ISC0 field.
	HSEM_C1ICR_ISC0_Msk = 0x1
	// Bit ISC0.
	HSEM_C1ICR_ISC0 = 0x1
	// Always reads 0
	HSEM_C1ICR_ISC0_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC0_Clear = 0x1
	// Position of ISC1 field.
	HSEM_C1ICR_ISC1_Pos = 0x1
	// Bit mask of ISC1 field.
	HSEM_C1ICR_ISC1_Msk = 0x2
	// Bit ISC1.
	HSEM_C1ICR_ISC1 = 0x2
	// Always reads 0
	HSEM_C1ICR_ISC1_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC1_Clear = 0x1
	// Position of ISC2 field.
	HSEM_C1ICR_ISC2_Pos = 0x2
	// Bit mask of ISC2 field.
	HSEM_C1ICR_ISC2_Msk = 0x4
	// Bit ISC2.
	HSEM_C1ICR_ISC2 = 0x4
	// Always reads 0
	HSEM_C1ICR_ISC2_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC2_Clear = 0x1
	// Position of ISC3 field.
	HSEM_C1ICR_ISC3_Pos = 0x3
	// Bit mask of ISC3 field.
	HSEM_C1ICR_ISC3_Msk = 0x8
	// Bit ISC3.
	HSEM_C1ICR_ISC3 = 0x8
	// Always reads 0
	HSEM_C1ICR_ISC3_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC3_Clear = 0x1
	// Position of ISC4 field.
	HSEM_C1ICR_ISC4_Pos = 0x4
	// Bit mask of ISC4 field.
	HSEM_C1ICR_ISC4_Msk = 0x10
	// Bit ISC4.
	HSEM_C1ICR_ISC4 = 0x10
	// Always reads 0
	HSEM_C1ICR_ISC4_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC4_Clear = 0x1
	// Position of ISC5 field.
	HSEM_C1ICR_ISC5_Pos = 0x5
	// Bit mask of ISC5 field.
	HSEM_C1ICR_ISC5_Msk = 0x20
	// Bit ISC5.
	HSEM_C1ICR_ISC5 = 0x20
	// Always reads 0
	HSEM_C1ICR_ISC5_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC5_Clear = 0x1
	// Position of ISC6 field.
	HSEM_C1ICR_ISC6_Pos = 0x6
	// Bit mask of ISC6 field.
	HSEM_C1ICR_ISC6_Msk = 0x40
	// Bit ISC6.
	HSEM_C1ICR_ISC6 = 0x40
	// Always reads 0
	HSEM_C1ICR_ISC6_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC6_Clear = 0x1
	// Position of ISC7 field.
	HSEM_C1ICR_ISC7_Pos = 0x7
	// Bit mask of ISC7 field.
	HSEM_C1ICR_ISC7_Msk = 0x80
	// Bit ISC7.
	HSEM_C1ICR_ISC7 = 0x80
	// Always reads 0
	HSEM_C1ICR_ISC7_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC7_Clear = 0x1
	// Position of ISC8 field.
	HSEM_C1ICR_ISC8_Pos = 0x8
	// Bit mask of ISC8 field.
	HSEM_C1ICR_ISC8_Msk = 0x100
	// Bit ISC8.
	HSEM_C1ICR_ISC8 = 0x100
	// Always reads 0
	HSEM_C1ICR_ISC8_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC8_Clear = 0x1
	// Position of ISC9 field.
	HSEM_C1ICR_ISC9_Pos = 0x9
	// Bit mask of ISC9 field.
	HSEM_C1ICR_ISC9_Msk = 0x200
	// Bit ISC9.
	HSEM_C1ICR_ISC9 = 0x200
	// Always reads 0
	HSEM_C1ICR_ISC9_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC9_Clear = 0x1
	// Position of ISC10 field.
	HSEM_C1ICR_ISC10_Pos = 0xa
	// Bit mask of ISC10 field.
	HSEM_C1ICR_ISC10_Msk = 0x400
	// Bit ISC10.
	HSEM_C1ICR_ISC10 = 0x400
	// Always reads 0
	HSEM_C1ICR_ISC10_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC10_Clear = 0x1
	// Position of ISC11 field.
	HSEM_C1ICR_ISC11_Pos = 0xb
	// Bit mask of ISC11 field.
	HSEM_C1ICR_ISC11_Msk = 0x800
	// Bit ISC11.
	HSEM_C1ICR_ISC11 = 0x800
	// Always reads 0
	HSEM_C1ICR_ISC11_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC11_Clear = 0x1
	// Position of ISC12 field.
	HSEM_C1ICR_ISC12_Pos = 0xc
	// Bit mask of ISC12 field.
	HSEM_C1ICR_ISC12_Msk = 0x1000
	// Bit ISC12.
	HSEM_C1ICR_ISC12 = 0x1000
	// Always reads 0
	HSEM_C1ICR_ISC12_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC12_Clear = 0x1
	// Position of ISC13 field.
	HSEM_C1ICR_ISC13_Pos = 0xd
	// Bit mask of ISC13 field.
	HSEM_C1ICR_ISC13_Msk = 0x2000
	// Bit ISC13.
	HSEM_C1ICR_ISC13 = 0x2000
	// Always reads 0
	HSEM_C1ICR_ISC13_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC13_Clear = 0x1
	// Position of ISC14 field.
	HSEM_C1ICR_ISC14_Pos = 0xe
	// Bit mask of ISC14 field.
	HSEM_C1ICR_ISC14_Msk = 0x4000
	// Bit ISC14.
	HSEM_C1ICR_ISC14 = 0x4000
	// Always reads 0
	HSEM_C1ICR_ISC14_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC14_Clear = 0x1
	// Position of ISC15 field.
	HSEM_C1ICR_ISC15_Pos = 0xf
	// Bit mask of ISC15 field.
	HSEM_C1ICR_ISC15_Msk = 0x8000
	// Bit ISC15.
	HSEM_C1ICR_ISC15 = 0x8000
	// Always reads 0
	HSEM_C1ICR_ISC15_NoEffect = 0x0
	// Interrupt semaphore x status ISFx and masked status MISFx cleared
	HSEM_C1ICR_ISC15_Clear = 0x1

	// C1ISR: HSEM Interrupt status register
	// Position of ISF0 field.
	HSEM_C1ISR_ISF0_Pos = 0x0
	// Bit mask of ISF0 field.
	HSEM_C1ISR_ISF0_Msk = 0x1
	// Bit ISF0.
	HSEM_C1ISR_ISF0 = 0x1
	// No interrupt pending
	HSEM_C1ISR_ISF0_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF0_Pending = 0x1
	// Position of ISF1 field.
	HSEM_C1ISR_ISF1_Pos = 0x1
	// Bit mask of ISF1 field.
	HSEM_C1ISR_ISF1_Msk = 0x2
	// Bit ISF1.
	HSEM_C1ISR_ISF1 = 0x2
	// No interrupt pending
	HSEM_C1ISR_ISF1_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF1_Pending = 0x1
	// Position of ISF2 field.
	HSEM_C1ISR_ISF2_Pos = 0x2
	// Bit mask of ISF2 field.
	HSEM_C1ISR_ISF2_Msk = 0x4
	// Bit ISF2.
	HSEM_C1ISR_ISF2 = 0x4
	// No interrupt pending
	HSEM_C1ISR_ISF2_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF2_Pending = 0x1
	// Position of ISF3 field.
	HSEM_C1ISR_ISF3_Pos = 0x3
	// Bit mask of ISF3 field.
	HSEM_C1ISR_ISF3_Msk = 0x8
	// Bit ISF3.
	HSEM_C1ISR_ISF3 = 0x8
	// No interrupt pending
	HSEM_C1ISR_ISF3_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF3_Pending = 0x1
	// Position of ISF4 field.
	HSEM_C1ISR_ISF4_Pos = 0x4
	// Bit mask of ISF4 field.
	HSEM_C1ISR_ISF4_Msk = 0x10
	// Bit ISF4.
	HSEM_C1ISR_ISF4 = 0x10
	// No interrupt pending
	HSEM_C1ISR_ISF4_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF4_Pending = 0x1
	// Position of ISF5 field.
	HSEM_C1ISR_ISF5_Pos = 0x5
	// Bit mask of ISF5 field.
	HSEM_C1ISR_ISF5_Msk = 0x20
	// Bit ISF5.
	HSEM_C1ISR_ISF5 = 0x20
	// No interrupt pending
	HSEM_C1ISR_ISF5_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF5_Pending = 0x1
	// Position of ISF6 field.
	HSEM_C1ISR_ISF6_Pos = 0x6
	// Bit mask of ISF6 field.
	HSEM_C1ISR_ISF6_Msk = 0x40
	// Bit ISF6.
	HSEM_C1ISR_ISF6 = 0x40
	// No interrupt pending
	HSEM_C1ISR_ISF6_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF6_Pending = 0x1
	// Position of ISF7 field.
	HSEM_C1ISR_ISF7_Pos = 0x7
	// Bit mask of ISF7 field.
	HSEM_C1ISR_ISF7_Msk = 0x80
	// Bit ISF7.
	HSEM_C1ISR_ISF7 = 0x80
	// No interrupt pending
	HSEM_C1ISR_ISF7_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF7_Pending = 0x1
	// Position of ISF8 field.
	HSEM_C1ISR_ISF8_Pos = 0x8
	// Bit mask of ISF8 field.
	HSEM_C1ISR_ISF8_Msk = 0x100
	// Bit ISF8.
	HSEM_C1ISR_ISF8 = 0x100
	// No interrupt pending
	HSEM_C1ISR_ISF8_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF8_Pending = 0x1
	// Position of ISF9 field.
	HSEM_C1ISR_ISF9_Pos = 0x9
	// Bit mask of ISF9 field.
	HSEM_C1ISR_ISF9_Msk = 0x200
	// Bit ISF9.
	HSEM_C1ISR_ISF9 = 0x200
	// No interrupt pending
	HSEM_C1ISR_ISF9_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF9_Pending = 0x1
	// Position of ISF10 field.
	HSEM_C1ISR_ISF10_Pos = 0xa
	// Bit mask of ISF10 field.
	HSEM_C1ISR_ISF10_Msk = 0x400
	// Bit ISF10.
	HSEM_C1ISR_ISF10 = 0x400
	// No interrupt pending
	HSEM_C1ISR_ISF10_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF10_Pending = 0x1
	// Position of ISF11 field.
	HSEM_C1ISR_ISF11_Pos = 0xb
	// Bit mask of ISF11 field.
	HSEM_C1ISR_ISF11_Msk = 0x800
	// Bit ISF11.
	HSEM_C1ISR_ISF11 = 0x800
	// No interrupt pending
	HSEM_C1ISR_ISF11_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF11_Pending = 0x1
	// Position of ISF12 field.
	HSEM_C1ISR_ISF12_Pos = 0xc
	// Bit mask of ISF12 field.
	HSEM_C1ISR_ISF12_Msk = 0x1000
	// Bit ISF12.
	HSEM_C1ISR_ISF12 = 0x1000
	// No interrupt pending
	HSEM_C1ISR_ISF12_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF12_Pending = 0x1
	// Position of ISF13 field.
	HSEM_C1ISR_ISF13_Pos = 0xd
	// Bit mask of ISF13 field.
	HSEM_C1ISR_ISF13_Msk = 0x2000
	// Bit ISF13.
	HSEM_C1ISR_ISF13 = 0x2000
	// No interrupt pending
	HSEM_C1ISR_ISF13_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF13_Pending = 0x1
	// Position of ISF14 field.
	HSEM_C1ISR_ISF14_Pos = 0xe
	// Bit mask of ISF14 field.
	HSEM_C1ISR_ISF14_Msk = 0x4000
	// Bit ISF14.
	HSEM_C1ISR_ISF14 = 0x4000
	// No interrupt pending
	HSEM_C1ISR_ISF14_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF14_Pending = 0x1
	// Position of ISF15 field.
	HSEM_C1ISR_ISF15_Pos = 0xf
	// Bit mask of ISF15 field.
	HSEM_C1ISR_ISF15_Msk = 0x8000
	// Bit ISF15.
	HSEM_C1ISR_ISF15 = 0x8000
	// No interrupt pending
	HSEM_C1ISR_ISF15_NotPending = 0x0
	// Interrupt pending
	HSEM_C1ISR_ISF15_Pending = 0x1

	// C1MISR: HSEM Masked interrupt status register
	// Position of MISF0 field.
	HSEM_C1MISR_MISF0_Pos = 0x0
	// Bit mask of MISF0 field.
	HSEM_C1MISR_MISF0_Msk = 0x1
	// Bit MISF0.
	HSEM_C1MISR_MISF0 = 0x1
	// No interrupt pending after masking
	HSEM_C1MISR_MISF0_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF0_Pending = 0x1
	// Position of MISF1 field.
	HSEM_C1MISR_MISF1_Pos = 0x1
	// Bit mask of MISF1 field.
	HSEM_C1MISR_MISF1_Msk = 0x2
	// Bit MISF1.
	HSEM_C1MISR_MISF1 = 0x2
	// No interrupt pending after masking
	HSEM_C1MISR_MISF1_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF1_Pending = 0x1
	// Position of MISF2 field.
	HSEM_C1MISR_MISF2_Pos = 0x2
	// Bit mask of MISF2 field.
	HSEM_C1MISR_MISF2_Msk = 0x4
	// Bit MISF2.
	HSEM_C1MISR_MISF2 = 0x4
	// No interrupt pending after masking
	HSEM_C1MISR_MISF2_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF2_Pending = 0x1
	// Position of MISF3 field.
	HSEM_C1MISR_MISF3_Pos = 0x3
	// Bit mask of MISF3 field.
	HSEM_C1MISR_MISF3_Msk = 0x8
	// Bit MISF3.
	HSEM_C1MISR_MISF3 = 0x8
	// No interrupt pending after masking
	HSEM_C1MISR_MISF3_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF3_Pending = 0x1
	// Position of MISF4 field.
	HSEM_C1MISR_MISF4_Pos = 0x4
	// Bit mask of MISF4 field.
	HSEM_C1MISR_MISF4_Msk = 0x10
	// Bit MISF4.
	HSEM_C1MISR_MISF4 = 0x10
	// No interrupt pending after masking
	HSEM_C1MISR_MISF4_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF4_Pending = 0x1
	// Position of MISF5 field.
	HSEM_C1MISR_MISF5_Pos = 0x5
	// Bit mask of MISF5 field.
	HSEM_C1MISR_MISF5_Msk = 0x20
	// Bit MISF5.
	HSEM_C1MISR_MISF5 = 0x20
	// No interrupt pending after masking
	HSEM_C1MISR_MISF5_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF5_Pending = 0x1
	// Position of MISF6 field.
	HSEM_C1MISR_MISF6_Pos = 0x6
	// Bit mask of MISF6 field.
	HSEM_C1MISR_MISF6_Msk = 0x40
	// Bit MISF6.
	HSEM_C1MISR_MISF6 = 0x40
	// No interrupt pending after masking
	HSEM_C1MISR_MISF6_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF6_Pending = 0x1
	// Position of MISF7 field.
	HSEM_C1MISR_MISF7_Pos = 0x7
	// Bit mask of MISF7 field.
	HSEM_C1MISR_MISF7_Msk = 0x80
	// Bit MISF7.
	HSEM_C1MISR_MISF7 = 0x80
	// No interrupt pending after masking
	HSEM_C1MISR_MISF7_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF7_Pending = 0x1
	// Position of MISF8 field.
	HSEM_C1MISR_MISF8_Pos = 0x8
	// Bit mask of MISF8 field.
	HSEM_C1MISR_MISF8_Msk = 0x100
	// Bit MISF8.
	HSEM_C1MISR_MISF8 = 0x100
	// No interrupt pending after masking
	HSEM_C1MISR_MISF8_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF8_Pending = 0x1
	// Position of MISF9 field.
	HSEM_C1MISR_MISF9_Pos = 0x9
	// Bit mask of MISF9 field.
	HSEM_C1MISR_MISF9_Msk = 0x200
	// Bit MISF9.
	HSEM_C1MISR_MISF9 = 0x200
	// No interrupt pending after masking
	HSEM_C1MISR_MISF9_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF9_Pending = 0x1
	// Position of MISF10 field.
	HSEM_C1MISR_MISF10_Pos = 0xa
	// Bit mask of MISF10 field.
	HSEM_C1MISR_MISF10_Msk = 0x400
	// Bit MISF10.
	HSEM_C1MISR_MISF10 = 0x400
	// No interrupt pending after masking
	HSEM_C1MISR_MISF10_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF10_Pending = 0x1
	// Position of MISF11 field.
	HSEM_C1MISR_MISF11_Pos = 0xb
	// Bit mask of MISF11 field.
	HSEM_C1MISR_MISF11_Msk = 0x800
	// Bit MISF11.
	HSEM_C1MISR_MISF11 = 0x800
	// No interrupt pending after masking
	HSEM_C1MISR_MISF11_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF11_Pending = 0x1
	// Position of MISF12 field.
	HSEM_C1MISR_MISF12_Pos = 0xc
	// Bit mask of MISF12 field.
	HSEM_C1MISR_MISF12_Msk = 0x1000
	// Bit MISF12.
	HSEM_C1MISR_MISF12 = 0x1000
	// No interrupt pending after masking
	HSEM_C1MISR_MISF12_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF12_Pending = 0x1
	// Position of MISF13 field.
	HSEM_C1MISR_MISF13_Pos = 0xd
	// Bit mask of MISF13 field.
	HSEM_C1MISR_MISF13_Msk = 0x2000
	// Bit MISF13.
	HSEM_C1MISR_MISF13 = 0x2000
	// No interrupt pending after masking
	HSEM_C1MISR_MISF13_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF13_Pending = 0x1
	// Position of MISF14 field.
	HSEM_C1MISR_MISF14_Pos = 0xe
	// Bit mask of MISF14 field.
	HSEM_C1MISR_MISF14_Msk = 0x4000
	// Bit MISF14.
	HSEM_C1MISR_MISF14 = 0x4000
	// No interrupt pending after masking
	HSEM_C1MISR_MISF14_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF14_Pending = 0x1
	// Position of MISF15 field.
	HSEM_C1MISR_MISF15_Pos = 0xf
	// Bit mask of MISF15 field.
	HSEM_C1MISR_MISF15_Msk = 0x8000
	// Bit MISF15.
	HSEM_C1MISR_MISF15 = 0x8000
	// No interrupt pending after masking
	HSEM_C1MISR_MISF15_NotPending = 0x0
	// Interrupt pending after masking
	HSEM_C1MISR_MISF15_Pending = 0x1

	// CR: HSEM Clear register
	// Position of COREID field.
	HSEM_CR_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_CR_COREID_Msk = 0xf00
	// Position of KEY field.
	HSEM_CR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	HSEM_CR_KEY_Msk = 0xffff0000

	// KEYR: HSEM Interrupt clear register
	// Position of KEY field.
	HSEM_KEYR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	HSEM_KEYR_KEY_Msk = 0xffff0000
)

// Constants for I2C1: Inter-integrated circuit
const (
	// CR1: Control register 1
	// Position of PE field.
	I2C_CR1_PE_Pos = 0x0
	// Bit mask of PE field.
	I2C_CR1_PE_Msk = 0x1
	// Bit PE.
	I2C_CR1_PE = 0x1
	// Peripheral disabled
	I2C_CR1_PE_Disabled = 0x0
	// Peripheral enabled
	I2C_CR1_PE_Enabled = 0x1
	// Position of TXIE field.
	I2C_CR1_TXIE_Pos = 0x1
	// Bit mask of TXIE field.
	I2C_CR1_TXIE_Msk = 0x2
	// Bit TXIE.
	I2C_CR1_TXIE = 0x2
	// Transmit (TXIS) interrupt disabled
	I2C_CR1_TXIE_Disabled = 0x0
	// Transmit (TXIS) interrupt enabled
	I2C_CR1_TXIE_Enabled = 0x1
	// Position of RXIE field.
	I2C_CR1_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	I2C_CR1_RXIE_Msk = 0x4
	// Bit RXIE.
	I2C_CR1_RXIE = 0x4
	// Receive (RXNE) interrupt disabled
	I2C_CR1_RXIE_Disabled = 0x0
	// Receive (RXNE) interrupt enabled
	I2C_CR1_RXIE_Enabled = 0x1
	// Position of ADDRIE field.
	I2C_CR1_ADDRIE_Pos = 0x3
	// Bit mask of ADDRIE field.
	I2C_CR1_ADDRIE_Msk = 0x8
	// Bit ADDRIE.
	I2C_CR1_ADDRIE = 0x8
	// Address match (ADDR) interrupts disabled
	I2C_CR1_ADDRIE_Disabled = 0x0
	// Address match (ADDR) interrupts enabled
	I2C_CR1_ADDRIE_Enabled = 0x1
	// Position of NACKIE field.
	I2C_CR1_NACKIE_Pos = 0x4
	// Bit mask of NACKIE field.
	I2C_CR1_NACKIE_Msk = 0x10
	// Bit NACKIE.
	I2C_CR1_NACKIE = 0x10
	// Not acknowledge (NACKF) received interrupts disabled
	I2C_CR1_NACKIE_Disabled = 0x0
	// Not acknowledge (NACKF) received interrupts enabled
	I2C_CR1_NACKIE_Enabled = 0x1
	// Position of STOPIE field.
	I2C_CR1_STOPIE_Pos = 0x5
	// Bit mask of STOPIE field.
	I2C_CR1_STOPIE_Msk = 0x20
	// Bit STOPIE.
	I2C_CR1_STOPIE = 0x20
	// Stop detection (STOPF) interrupt disabled
	I2C_CR1_STOPIE_Disabled = 0x0
	// Stop detection (STOPF) interrupt enabled
	I2C_CR1_STOPIE_Enabled = 0x1
	// Position of TCIE field.
	I2C_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	I2C_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	I2C_CR1_TCIE = 0x40
	// Transfer Complete interrupt disabled
	I2C_CR1_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	I2C_CR1_TCIE_Enabled = 0x1
	// Position of ERRIE field.
	I2C_CR1_ERRIE_Pos = 0x7
	// Bit mask of ERRIE field.
	I2C_CR1_ERRIE_Msk = 0x80
	// Bit ERRIE.
	I2C_CR1_ERRIE = 0x80
	// Error detection interrupts disabled
	I2C_CR1_ERRIE_Disabled = 0x0
	// Error detection interrupts enabled
	I2C_CR1_ERRIE_Enabled = 0x1
	// Position of DNF field.
	I2C_CR1_DNF_Pos = 0x8
	// Bit mask of DNF field.
	I2C_CR1_DNF_Msk = 0xf00
	// Digital filter disabled
	I2C_CR1_DNF_NoFilter = 0x0
	// Digital filter enabled and filtering capability up to 1 tI2CCLK
	I2C_CR1_DNF_Filter1 = 0x1
	// Digital filter enabled and filtering capability up to 2 tI2CCLK
	I2C_CR1_DNF_Filter2 = 0x2
	// Digital filter enabled and filtering capability up to 3 tI2CCLK
	I2C_CR1_DNF_Filter3 = 0x3
	// Digital filter enabled and filtering capability up to 4 tI2CCLK
	I2C_CR1_DNF_Filter4 = 0x4
	// Digital filter enabled and filtering capability up to 5 tI2CCLK
	I2C_CR1_DNF_Filter5 = 0x5
	// Digital filter enabled and filtering capability up to 6 tI2CCLK
	I2C_CR1_DNF_Filter6 = 0x6
	// Digital filter enabled and filtering capability up to 7 tI2CCLK
	I2C_CR1_DNF_Filter7 = 0x7
	// Digital filter enabled and filtering capability up to 8 tI2CCLK
	I2C_CR1_DNF_Filter8 = 0x8
	// Digital filter enabled and filtering capability up to 9 tI2CCLK
	I2C_CR1_DNF_Filter9 = 0x9
	// Digital filter enabled and filtering capability up to 10 tI2CCLK
	I2C_CR1_DNF_Filter10 = 0xa
	// Digital filter enabled and filtering capability up to 11 tI2CCLK
	I2C_CR1_DNF_Filter11 = 0xb
	// Digital filter enabled and filtering capability up to 12 tI2CCLK
	I2C_CR1_DNF_Filter12 = 0xc
	// Digital filter enabled and filtering capability up to 13 tI2CCLK
	I2C_CR1_DNF_Filter13 = 0xd
	// Digital filter enabled and filtering capability up to 14 tI2CCLK
	I2C_CR1_DNF_Filter14 = 0xe
	// Digital filter enabled and filtering capability up to 15 tI2CCLK
	I2C_CR1_DNF_Filter15 = 0xf
	// Position of ANFOFF field.
	I2C_CR1_ANFOFF_Pos = 0xc
	// Bit mask of ANFOFF field.
	I2C_CR1_ANFOFF_Msk = 0x1000
	// Bit ANFOFF.
	I2C_CR1_ANFOFF = 0x1000
	// Analog noise filter enabled
	I2C_CR1_ANFOFF_Enabled = 0x0
	// Analog noise filter disabled
	I2C_CR1_ANFOFF_Disabled = 0x1
	// Position of TXDMAEN field.
	I2C_CR1_TXDMAEN_Pos = 0xe
	// Bit mask of TXDMAEN field.
	I2C_CR1_TXDMAEN_Msk = 0x4000
	// Bit TXDMAEN.
	I2C_CR1_TXDMAEN = 0x4000
	// DMA mode disabled for transmission
	I2C_CR1_TXDMAEN_Disabled = 0x0
	// DMA mode enabled for transmission
	I2C_CR1_TXDMAEN_Enabled = 0x1
	// Position of RXDMAEN field.
	I2C_CR1_RXDMAEN_Pos = 0xf
	// Bit mask of RXDMAEN field.
	I2C_CR1_RXDMAEN_Msk = 0x8000
	// Bit RXDMAEN.
	I2C_CR1_RXDMAEN = 0x8000
	// DMA mode disabled for reception
	I2C_CR1_RXDMAEN_Disabled = 0x0
	// DMA mode enabled for reception
	I2C_CR1_RXDMAEN_Enabled = 0x1
	// Position of SBC field.
	I2C_CR1_SBC_Pos = 0x10
	// Bit mask of SBC field.
	I2C_CR1_SBC_Msk = 0x10000
	// Bit SBC.
	I2C_CR1_SBC = 0x10000
	// Slave byte control disabled
	I2C_CR1_SBC_Disabled = 0x0
	// Slave byte control enabled
	I2C_CR1_SBC_Enabled = 0x1
	// Position of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Pos = 0x11
	// Bit mask of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Msk = 0x20000
	// Bit NOSTRETCH.
	I2C_CR1_NOSTRETCH = 0x20000
	// Clock stretching enabled
	I2C_CR1_NOSTRETCH_Enabled = 0x0
	// Clock stretching disabled
	I2C_CR1_NOSTRETCH_Disabled = 0x1
	// Position of WUPEN field.
	I2C_CR1_WUPEN_Pos = 0x12
	// Bit mask of WUPEN field.
	I2C_CR1_WUPEN_Msk = 0x40000
	// Bit WUPEN.
	I2C_CR1_WUPEN = 0x40000
	// Wakeup from Stop mode disabled
	I2C_CR1_WUPEN_Disabled = 0x0
	// Wakeup from Stop mode enabled
	I2C_CR1_WUPEN_Enabled = 0x1
	// Position of GCEN field.
	I2C_CR1_GCEN_Pos = 0x13
	// Bit mask of GCEN field.
	I2C_CR1_GCEN_Msk = 0x80000
	// Bit GCEN.
	I2C_CR1_GCEN = 0x80000
	// General call disabled. Address 0b00000000 is NACKed
	I2C_CR1_GCEN_Disabled = 0x0
	// General call enabled. Address 0b00000000 is ACKed
	I2C_CR1_GCEN_Enabled = 0x1
	// Position of SMBHEN field.
	I2C_CR1_SMBHEN_Pos = 0x14
	// Bit mask of SMBHEN field.
	I2C_CR1_SMBHEN_Msk = 0x100000
	// Bit SMBHEN.
	I2C_CR1_SMBHEN = 0x100000
	// Host address disabled. Address 0b0001000x is NACKed
	I2C_CR1_SMBHEN_Disabled = 0x0
	// Host address enabled. Address 0b0001000x is ACKed
	I2C_CR1_SMBHEN_Enabled = 0x1
	// Position of SMBDEN field.
	I2C_CR1_SMBDEN_Pos = 0x15
	// Bit mask of SMBDEN field.
	I2C_CR1_SMBDEN_Msk = 0x200000
	// Bit SMBDEN.
	I2C_CR1_SMBDEN = 0x200000
	// Device default address disabled. Address 0b1100001x is NACKed
	I2C_CR1_SMBDEN_Disabled = 0x0
	// Device default address enabled. Address 0b1100001x is ACKed
	I2C_CR1_SMBDEN_Enabled = 0x1
	// Position of ALERTEN field.
	I2C_CR1_ALERTEN_Pos = 0x16
	// Bit mask of ALERTEN field.
	I2C_CR1_ALERTEN_Msk = 0x400000
	// Bit ALERTEN.
	I2C_CR1_ALERTEN = 0x400000
	// In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported
	I2C_CR1_ALERTEN_Disabled = 0x0
	// In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported
	I2C_CR1_ALERTEN_Enabled = 0x1
	// Position of PECEN field.
	I2C_CR1_PECEN_Pos = 0x17
	// Bit mask of PECEN field.
	I2C_CR1_PECEN_Msk = 0x800000
	// Bit PECEN.
	I2C_CR1_PECEN = 0x800000
	// PEC calculation disabled
	I2C_CR1_PECEN_Disabled = 0x0
	// PEC calculation enabled
	I2C_CR1_PECEN_Enabled = 0x1

	// CR2: Control register 2
	// Position of PECBYTE field.
	I2C_CR2_PECBYTE_Pos = 0x1a
	// Bit mask of PECBYTE field.
	I2C_CR2_PECBYTE_Msk = 0x4000000
	// Bit PECBYTE.
	I2C_CR2_PECBYTE = 0x4000000
	// No PEC transfer
	I2C_CR2_PECBYTE_NoPec = 0x0
	// PEC transmission/reception is requested
	I2C_CR2_PECBYTE_Pec = 0x1
	// Position of AUTOEND field.
	I2C_CR2_AUTOEND_Pos = 0x19
	// Bit mask of AUTOEND field.
	I2C_CR2_AUTOEND_Msk = 0x2000000
	// Bit AUTOEND.
	I2C_CR2_AUTOEND = 0x2000000
	// Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low
	I2C_CR2_AUTOEND_Software = 0x0
	// Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred
	I2C_CR2_AUTOEND_Automatic = 0x1
	// Position of RELOAD field.
	I2C_CR2_RELOAD_Pos = 0x18
	// Bit mask of RELOAD field.
	I2C_CR2_RELOAD_Msk = 0x1000000
	// Bit RELOAD.
	I2C_CR2_RELOAD = 0x1000000
	// The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)
	I2C_CR2_RELOAD_Completed = 0x0
	// The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)
	I2C_CR2_RELOAD_NotCompleted = 0x1
	// Position of NBYTES field.
	I2C_CR2_NBYTES_Pos = 0x10
	// Bit mask of NBYTES field.
	I2C_CR2_NBYTES_Msk = 0xff0000
	// Position of NACK field.
	I2C_CR2_NACK_Pos = 0xf
	// Bit mask of NACK field.
	I2C_CR2_NACK_Msk = 0x8000
	// Bit NACK.
	I2C_CR2_NACK = 0x8000
	// an ACK is sent after current received byte
	I2C_CR2_NACK_Ack = 0x0
	// a NACK is sent after current received byte
	I2C_CR2_NACK_Nack = 0x1
	// Position of STOP field.
	I2C_CR2_STOP_Pos = 0xe
	// Bit mask of STOP field.
	I2C_CR2_STOP_Msk = 0x4000
	// Bit STOP.
	I2C_CR2_STOP = 0x4000
	// No Stop generation
	I2C_CR2_STOP_NoStop = 0x0
	// Stop generation after current byte transfer
	I2C_CR2_STOP_Stop = 0x1
	// Position of START field.
	I2C_CR2_START_Pos = 0xd
	// Bit mask of START field.
	I2C_CR2_START_Msk = 0x2000
	// Bit START.
	I2C_CR2_START = 0x2000
	// No Start generation
	I2C_CR2_START_NoStart = 0x0
	// Restart/Start generation
	I2C_CR2_START_Start = 0x1
	// Position of HEAD10R field.
	I2C_CR2_HEAD10R_Pos = 0xc
	// Bit mask of HEAD10R field.
	I2C_CR2_HEAD10R_Msk = 0x1000
	// Bit HEAD10R.
	I2C_CR2_HEAD10R = 0x1000
	// The master sends the complete 10 bit slave address read sequence
	I2C_CR2_HEAD10R_Complete = 0x0
	// The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction
	I2C_CR2_HEAD10R_Partial = 0x1
	// Position of ADD10 field.
	I2C_CR2_ADD10_Pos = 0xb
	// Bit mask of ADD10 field.
	I2C_CR2_ADD10_Msk = 0x800
	// Bit ADD10.
	I2C_CR2_ADD10 = 0x800
	// The master operates in 7-bit addressing mode
	I2C_CR2_ADD10_Bit7 = 0x0
	// The master operates in 10-bit addressing mode
	I2C_CR2_ADD10_Bit10 = 0x1
	// Position of RD_WRN field.
	I2C_CR2_RD_WRN_Pos = 0xa
	// Bit mask of RD_WRN field.
	I2C_CR2_RD_WRN_Msk = 0x400
	// Bit RD_WRN.
	I2C_CR2_RD_WRN = 0x400
	// Master requests a write transfer
	I2C_CR2_RD_WRN_Write = 0x0
	// Master requests a read transfer
	I2C_CR2_RD_WRN_Read = 0x1
	// Position of SADD field.
	I2C_CR2_SADD_Pos = 0x0
	// Bit mask of SADD field.
	I2C_CR2_SADD_Msk = 0x3ff

	// OAR1: Own address register 1
	// Position of OA1 field.
	I2C_OAR1_OA1_Pos = 0x0
	// Bit mask of OA1 field.
	I2C_OAR1_OA1_Msk = 0x3ff
	// Position of OA1MODE field.
	I2C_OAR1_OA1MODE_Pos = 0xa
	// Bit mask of OA1MODE field.
	I2C_OAR1_OA1MODE_Msk = 0x400
	// Bit OA1MODE.
	I2C_OAR1_OA1MODE = 0x400
	// Own address 1 is a 7-bit address
	I2C_OAR1_OA1MODE_Bit7 = 0x0
	// Own address 1 is a 10-bit address
	I2C_OAR1_OA1MODE_Bit10 = 0x1
	// Position of OA1EN field.
	I2C_OAR1_OA1EN_Pos = 0xf
	// Bit mask of OA1EN field.
	I2C_OAR1_OA1EN_Msk = 0x8000
	// Bit OA1EN.
	I2C_OAR1_OA1EN = 0x8000
	// Own address 1 disabled. The received slave address OA1 is NACKed
	I2C_OAR1_OA1EN_Disabled = 0x0
	// Own address 1 enabled. The received slave address OA1 is ACKed
	I2C_OAR1_OA1EN_Enabled = 0x1

	// OAR2: Own address register 2
	// Position of OA2 field.
	I2C_OAR2_OA2_Pos = 0x1
	// Bit mask of OA2 field.
	I2C_OAR2_OA2_Msk = 0xfe
	// Position of OA2MSK field.
	I2C_OAR2_OA2MSK_Pos = 0x8
	// Bit mask of OA2MSK field.
	I2C_OAR2_OA2MSK_Msk = 0x700
	// No mask
	I2C_OAR2_OA2MSK_NoMask = 0x0
	// OA2[1] is masked and dont care. Only OA2[7:2] are compared
	I2C_OAR2_OA2MSK_Mask1 = 0x1
	// OA2[2:1] are masked and dont care. Only OA2[7:3] are compared
	I2C_OAR2_OA2MSK_Mask2 = 0x2
	// OA2[3:1] are masked and dont care. Only OA2[7:4] are compared
	I2C_OAR2_OA2MSK_Mask3 = 0x3
	// OA2[4:1] are masked and dont care. Only OA2[7:5] are compared
	I2C_OAR2_OA2MSK_Mask4 = 0x4
	// OA2[5:1] are masked and dont care. Only OA2[7:6] are compared
	I2C_OAR2_OA2MSK_Mask5 = 0x5
	// OA2[6:1] are masked and dont care. Only OA2[7] is compared.
	I2C_OAR2_OA2MSK_Mask6 = 0x6
	// OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged
	I2C_OAR2_OA2MSK_Mask7 = 0x7
	// Position of OA2EN field.
	I2C_OAR2_OA2EN_Pos = 0xf
	// Bit mask of OA2EN field.
	I2C_OAR2_OA2EN_Msk = 0x8000
	// Bit OA2EN.
	I2C_OAR2_OA2EN = 0x8000
	// Own address 2 disabled. The received slave address OA2 is NACKed
	I2C_OAR2_OA2EN_Disabled = 0x0
	// Own address 2 enabled. The received slave address OA2 is ACKed
	I2C_OAR2_OA2EN_Enabled = 0x1

	// TIMINGR: Timing register
	// Position of SCLL field.
	I2C_TIMINGR_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_TIMINGR_SCLL_Msk = 0xff
	// Position of SCLH field.
	I2C_TIMINGR_SCLH_Pos = 0x8
	// Bit mask of SCLH field.
	I2C_TIMINGR_SCLH_Msk = 0xff00
	// Position of SDADEL field.
	I2C_TIMINGR_SDADEL_Pos = 0x10
	// Bit mask of SDADEL field.
	I2C_TIMINGR_SDADEL_Msk = 0xf0000
	// Position of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Pos = 0x14
	// Bit mask of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Msk = 0xf00000
	// Position of PRESC field.
	I2C_TIMINGR_PRESC_Pos = 0x1c
	// Bit mask of PRESC field.
	I2C_TIMINGR_PRESC_Msk = 0xf0000000

	// TIMEOUTR: Status register 1
	// Position of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Pos = 0x0
	// Bit mask of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Msk = 0xfff
	// Position of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Pos = 0xc
	// Bit mask of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Msk = 0x1000
	// Bit TIDLE.
	I2C_TIMEOUTR_TIDLE = 0x1000
	// TIMEOUTA is used to detect SCL low timeout
	I2C_TIMEOUTR_TIDLE_Disabled = 0x0
	// TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
	I2C_TIMEOUTR_TIDLE_Enabled = 0x1
	// Position of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Pos = 0xf
	// Bit mask of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Msk = 0x8000
	// Bit TIMOUTEN.
	I2C_TIMEOUTR_TIMOUTEN = 0x8000
	// SCL timeout detection is disabled
	I2C_TIMEOUTR_TIMOUTEN_Disabled = 0x0
	// SCL timeout detection is enabled
	I2C_TIMEOUTR_TIMOUTEN_Enabled = 0x1
	// Position of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Pos = 0x10
	// Bit mask of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Msk = 0xfff0000
	// Position of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Pos = 0x1f
	// Bit mask of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Msk = 0x80000000
	// Bit TEXTEN.
	I2C_TIMEOUTR_TEXTEN = 0x80000000
	// Extended clock timeout detection is disabled
	I2C_TIMEOUTR_TEXTEN_Disabled = 0x0
	// Extended clock timeout detection is enabled
	I2C_TIMEOUTR_TEXTEN_Enabled = 0x1

	// ISR: Interrupt and Status register
	// Position of ADDCODE field.
	I2C_ISR_ADDCODE_Pos = 0x11
	// Bit mask of ADDCODE field.
	I2C_ISR_ADDCODE_Msk = 0xfe0000
	// Position of DIR field.
	I2C_ISR_DIR_Pos = 0x10
	// Bit mask of DIR field.
	I2C_ISR_DIR_Msk = 0x10000
	// Bit DIR.
	I2C_ISR_DIR = 0x10000
	// Write transfer, slave enters receiver mode
	I2C_ISR_DIR_Write = 0x0
	// Read transfer, slave enters transmitter mode
	I2C_ISR_DIR_Read = 0x1
	// Position of BUSY field.
	I2C_ISR_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	I2C_ISR_BUSY_Msk = 0x8000
	// Bit BUSY.
	I2C_ISR_BUSY = 0x8000
	// No communication is in progress on the bus
	I2C_ISR_BUSY_NotBusy = 0x0
	// A communication is in progress on the bus
	I2C_ISR_BUSY_Busy = 0x1
	// Position of ALERT field.
	I2C_ISR_ALERT_Pos = 0xd
	// Bit mask of ALERT field.
	I2C_ISR_ALERT_Msk = 0x2000
	// Bit ALERT.
	I2C_ISR_ALERT = 0x2000
	// SMBA alert is not detected
	I2C_ISR_ALERT_NoAlert = 0x0
	// SMBA alert event is detected on SMBA pin
	I2C_ISR_ALERT_Alert = 0x1
	// Position of TIMEOUT field.
	I2C_ISR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	I2C_ISR_TIMEOUT_Msk = 0x1000
	// Bit TIMEOUT.
	I2C_ISR_TIMEOUT = 0x1000
	// No timeout occured
	I2C_ISR_TIMEOUT_NoTimeout = 0x0
	// Timeout occured
	I2C_ISR_TIMEOUT_Timeout = 0x1
	// Position of PECERR field.
	I2C_ISR_PECERR_Pos = 0xb
	// Bit mask of PECERR field.
	I2C_ISR_PECERR_Msk = 0x800
	// Bit PECERR.
	I2C_ISR_PECERR = 0x800
	// Received PEC does match with PEC register
	I2C_ISR_PECERR_Match = 0x0
	// Received PEC does not match with PEC register
	I2C_ISR_PECERR_NoMatch = 0x1
	// Position of OVR field.
	I2C_ISR_OVR_Pos = 0xa
	// Bit mask of OVR field.
	I2C_ISR_OVR_Msk = 0x400
	// Bit OVR.
	I2C_ISR_OVR = 0x400
	// No overrun/underrun error occurs
	I2C_ISR_OVR_NoOverrun = 0x0
	// slave mode with NOSTRETCH=1, when an overrun/underrun error occurs
	I2C_ISR_OVR_Overrun = 0x1
	// Position of ARLO field.
	I2C_ISR_ARLO_Pos = 0x9
	// Bit mask of ARLO field.
	I2C_ISR_ARLO_Msk = 0x200
	// Bit ARLO.
	I2C_ISR_ARLO = 0x200
	// No arbitration lost
	I2C_ISR_ARLO_NotLost = 0x0
	// Arbitration lost
	I2C_ISR_ARLO_Lost = 0x1
	// Position of BERR field.
	I2C_ISR_BERR_Pos = 0x8
	// Bit mask of BERR field.
	I2C_ISR_BERR_Msk = 0x100
	// Bit BERR.
	I2C_ISR_BERR = 0x100
	// No bus error
	I2C_ISR_BERR_NoError = 0x0
	// Misplaced Start and Stop condition is detected
	I2C_ISR_BERR_Error = 0x1
	// Position of TCR field.
	I2C_ISR_TCR_Pos = 0x7
	// Bit mask of TCR field.
	I2C_ISR_TCR_Msk = 0x80
	// Bit TCR.
	I2C_ISR_TCR = 0x80
	// Transfer is not complete
	I2C_ISR_TCR_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TCR_Complete = 0x1
	// Position of TC field.
	I2C_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	I2C_ISR_TC_Msk = 0x40
	// Bit TC.
	I2C_ISR_TC = 0x40
	// Transfer is not complete
	I2C_ISR_TC_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TC_Complete = 0x1
	// Position of STOPF field.
	I2C_ISR_STOPF_Pos = 0x5
	// Bit mask of STOPF field.
	I2C_ISR_STOPF_Msk = 0x20
	// Bit STOPF.
	I2C_ISR_STOPF = 0x20
	// No Stop condition detected
	I2C_ISR_STOPF_NoStop = 0x0
	// Stop condition detected
	I2C_ISR_STOPF_Stop = 0x1
	// Position of NACKF field.
	I2C_ISR_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	I2C_ISR_NACKF_Msk = 0x10
	// Bit NACKF.
	I2C_ISR_NACKF = 0x10
	// No NACK has been received
	I2C_ISR_NACKF_NoNack = 0x0
	// NACK has been received
	I2C_ISR_NACKF_Nack = 0x1
	// Position of ADDR field.
	I2C_ISR_ADDR_Pos = 0x3
	// Bit mask of ADDR field.
	I2C_ISR_ADDR_Msk = 0x8
	// Bit ADDR.
	I2C_ISR_ADDR = 0x8
	// Adress mismatched or not received
	I2C_ISR_ADDR_NotMatch = 0x0
	// Received slave address matched with one of the enabled slave addresses
	I2C_ISR_ADDR_Match = 0x1
	// Position of RXNE field.
	I2C_ISR_RXNE_Pos = 0x2
	// Bit mask of RXNE field.
	I2C_ISR_RXNE_Msk = 0x4
	// Bit RXNE.
	I2C_ISR_RXNE = 0x4
	// The RXDR register is empty
	I2C_ISR_RXNE_Empty = 0x0
	// Received data is copied into the RXDR register, and is ready to be read
	I2C_ISR_RXNE_NotEmpty = 0x1
	// Position of TXIS field.
	I2C_ISR_TXIS_Pos = 0x1
	// Bit mask of TXIS field.
	I2C_ISR_TXIS_Msk = 0x2
	// Bit TXIS.
	I2C_ISR_TXIS = 0x2
	// The TXDR register is not empty
	I2C_ISR_TXIS_NotEmpty = 0x0
	// The TXDR register is empty and the data to be transmitted must be written in the TXDR register
	I2C_ISR_TXIS_Empty = 0x1
	// Position of TXE field.
	I2C_ISR_TXE_Pos = 0x0
	// Bit mask of TXE field.
	I2C_ISR_TXE_Msk = 0x1
	// Bit TXE.
	I2C_ISR_TXE = 0x1
	// TXDR register not empty
	I2C_ISR_TXE_NotEmpty = 0x0
	// TXDR register empty
	I2C_ISR_TXE_Empty = 0x1

	// ICR: Interrupt clear register
	// Position of ALERTCF field.
	I2C_ICR_ALERTCF_Pos = 0xd
	// Bit mask of ALERTCF field.
	I2C_ICR_ALERTCF_Msk = 0x2000
	// Bit ALERTCF.
	I2C_ICR_ALERTCF = 0x2000
	// Clears the ALERT flag in ISR register
	I2C_ICR_ALERTCF_Clear = 0x1
	// Position of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Pos = 0xc
	// Bit mask of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Msk = 0x1000
	// Bit TIMOUTCF.
	I2C_ICR_TIMOUTCF = 0x1000
	// Clears the TIMOUT flag in ISR register
	I2C_ICR_TIMOUTCF_Clear = 0x1
	// Position of PECCF field.
	I2C_ICR_PECCF_Pos = 0xb
	// Bit mask of PECCF field.
	I2C_ICR_PECCF_Msk = 0x800
	// Bit PECCF.
	I2C_ICR_PECCF = 0x800
	// Clears the PEC flag in ISR register
	I2C_ICR_PECCF_Clear = 0x1
	// Position of OVRCF field.
	I2C_ICR_OVRCF_Pos = 0xa
	// Bit mask of OVRCF field.
	I2C_ICR_OVRCF_Msk = 0x400
	// Bit OVRCF.
	I2C_ICR_OVRCF = 0x400
	// Clears the OVR flag in ISR register
	I2C_ICR_OVRCF_Clear = 0x1
	// Position of ARLOCF field.
	I2C_ICR_ARLOCF_Pos = 0x9
	// Bit mask of ARLOCF field.
	I2C_ICR_ARLOCF_Msk = 0x200
	// Bit ARLOCF.
	I2C_ICR_ARLOCF = 0x200
	// Clears the ARLO flag in ISR register
	I2C_ICR_ARLOCF_Clear = 0x1
	// Position of BERRCF field.
	I2C_ICR_BERRCF_Pos = 0x8
	// Bit mask of BERRCF field.
	I2C_ICR_BERRCF_Msk = 0x100
	// Bit BERRCF.
	I2C_ICR_BERRCF = 0x100
	// Clears the BERR flag in ISR register
	I2C_ICR_BERRCF_Clear = 0x1
	// Position of STOPCF field.
	I2C_ICR_STOPCF_Pos = 0x5
	// Bit mask of STOPCF field.
	I2C_ICR_STOPCF_Msk = 0x20
	// Bit STOPCF.
	I2C_ICR_STOPCF = 0x20
	// Clears the STOP flag in ISR register
	I2C_ICR_STOPCF_Clear = 0x1
	// Position of NACKCF field.
	I2C_ICR_NACKCF_Pos = 0x4
	// Bit mask of NACKCF field.
	I2C_ICR_NACKCF_Msk = 0x10
	// Bit NACKCF.
	I2C_ICR_NACKCF = 0x10
	// Clears the NACK flag in ISR register
	I2C_ICR_NACKCF_Clear = 0x1
	// Position of ADDRCF field.
	I2C_ICR_ADDRCF_Pos = 0x3
	// Bit mask of ADDRCF field.
	I2C_ICR_ADDRCF_Msk = 0x8
	// Bit ADDRCF.
	I2C_ICR_ADDRCF = 0x8
	// Clears the ADDR flag in ISR register
	I2C_ICR_ADDRCF_Clear = 0x1

	// PECR: PEC register
	// Position of PEC field.
	I2C_PECR_PEC_Pos = 0x0
	// Bit mask of PEC field.
	I2C_PECR_PEC_Msk = 0xff

	// RXDR: Receive data register
	// Position of RXDATA field.
	I2C_RXDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	I2C_RXDR_RXDATA_Msk = 0xff

	// TXDR: Transmit data register
	// Position of TXDATA field.
	I2C_TXDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	I2C_TXDR_TXDATA_Msk = 0xff
)

// Constants for IWDG: Independent watchdog
const (
	// KR: Key register
	// Position of KEY field.
	IWDG_KR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	IWDG_KR_KEY_Msk = 0xffff
	// Enable access to PR, RLR and WINR registers (0x5555)
	IWDG_KR_KEY_Enable = 0x5555
	// Reset the watchdog value (0xAAAA)
	IWDG_KR_KEY_Reset = 0xaaaa
	// Start the watchdog (0xCCCC)
	IWDG_KR_KEY_Start = 0xcccc

	// PR: Prescaler register
	// Position of PR field.
	IWDG_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	IWDG_PR_PR_Msk = 0x7
	// Divider /4
	IWDG_PR_PR_DivideBy4 = 0x0
	// Divider /8
	IWDG_PR_PR_DivideBy8 = 0x1
	// Divider /16
	IWDG_PR_PR_DivideBy16 = 0x2
	// Divider /32
	IWDG_PR_PR_DivideBy32 = 0x3
	// Divider /64
	IWDG_PR_PR_DivideBy64 = 0x4
	// Divider /128
	IWDG_PR_PR_DivideBy128 = 0x5
	// Divider /256
	IWDG_PR_PR_DivideBy256 = 0x6
	// Divider /256
	IWDG_PR_PR_DivideBy256bis = 0x7

	// RLR: Reload register
	// Position of RL field.
	IWDG_RLR_RL_Pos = 0x0
	// Bit mask of RL field.
	IWDG_RLR_RL_Msk = 0xfff

	// SR: Status register
	// Position of WVU field.
	IWDG_SR_WVU_Pos = 0x2
	// Bit mask of WVU field.
	IWDG_SR_WVU_Msk = 0x4
	// Bit WVU.
	IWDG_SR_WVU = 0x4
	// No update on-going
	IWDG_SR_WVU_Idle = 0x0
	// Update on-going
	IWDG_SR_WVU_Busy = 0x1
	// Position of RVU field.
	IWDG_SR_RVU_Pos = 0x1
	// Bit mask of RVU field.
	IWDG_SR_RVU_Msk = 0x2
	// Bit RVU.
	IWDG_SR_RVU = 0x2
	// No update on-going
	IWDG_SR_RVU_Idle = 0x0
	// Update on-going
	IWDG_SR_RVU_Busy = 0x1
	// Position of PVU field.
	IWDG_SR_PVU_Pos = 0x0
	// Bit mask of PVU field.
	IWDG_SR_PVU_Msk = 0x1
	// Bit PVU.
	IWDG_SR_PVU = 0x1
	// No update on-going
	IWDG_SR_PVU_Idle = 0x0
	// Update on-going
	IWDG_SR_PVU_Busy = 0x1
)

// Constants for LPTIM1: Low-power timer
const (
	// ISR: interrupt and status register
	// Position of REPOK field.
	LPTIM_ISR_REPOK_Pos = 0x8
	// Bit mask of REPOK field.
	LPTIM_ISR_REPOK_Msk = 0x100
	// Bit REPOK.
	LPTIM_ISR_REPOK = 0x100
	// Repetition register update OK
	LPTIM_ISR_REPOK_Set = 0x1
	// Position of UE field.
	LPTIM_ISR_UE_Pos = 0x7
	// Bit mask of UE field.
	LPTIM_ISR_UE_Msk = 0x80
	// Bit UE.
	LPTIM_ISR_UE = 0x80
	// LPTIM update event occurred
	LPTIM_ISR_UE_Set = 0x1
	// Position of DOWN field.
	LPTIM_ISR_DOWN_Pos = 0x6
	// Bit mask of DOWN field.
	LPTIM_ISR_DOWN_Msk = 0x40
	// Bit DOWN.
	LPTIM_ISR_DOWN = 0x40
	// Counter direction change up to down
	LPTIM_ISR_DOWN_Set = 0x1
	// Position of UP field.
	LPTIM_ISR_UP_Pos = 0x5
	// Bit mask of UP field.
	LPTIM_ISR_UP_Msk = 0x20
	// Bit UP.
	LPTIM_ISR_UP = 0x20
	// Counter direction change down to up
	LPTIM_ISR_UP_Set = 0x1
	// Position of ARROK field.
	LPTIM_ISR_ARROK_Pos = 0x4
	// Bit mask of ARROK field.
	LPTIM_ISR_ARROK_Msk = 0x10
	// Bit ARROK.
	LPTIM_ISR_ARROK = 0x10
	// Autoreload register update OK
	LPTIM_ISR_ARROK_Set = 0x1
	// Position of CMPOK field.
	LPTIM_ISR_CMPOK_Pos = 0x3
	// Bit mask of CMPOK field.
	LPTIM_ISR_CMPOK_Msk = 0x8
	// Bit CMPOK.
	LPTIM_ISR_CMPOK = 0x8
	// Compare register update OK
	LPTIM_ISR_CMPOK_Set = 0x1
	// Position of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Pos = 0x2
	// Bit mask of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Msk = 0x4
	// Bit EXTTRIG.
	LPTIM_ISR_EXTTRIG = 0x4
	// External trigger edge event
	LPTIM_ISR_EXTTRIG_Set = 0x1
	// Position of ARRM field.
	LPTIM_ISR_ARRM_Pos = 0x1
	// Bit mask of ARRM field.
	LPTIM_ISR_ARRM_Msk = 0x2
	// Bit ARRM.
	LPTIM_ISR_ARRM = 0x2
	// Autoreload match
	LPTIM_ISR_ARRM_Set = 0x1
	// Position of CMPM field.
	LPTIM_ISR_CMPM_Pos = 0x0
	// Bit mask of CMPM field.
	LPTIM_ISR_CMPM_Msk = 0x1
	// Bit CMPM.
	LPTIM_ISR_CMPM = 0x1
	// Compare match
	LPTIM_ISR_CMPM_Set = 0x1

	// ICR: interrupt clear register
	// Position of REPOKCF field.
	LPTIM_ICR_REPOKCF_Pos = 0x8
	// Bit mask of REPOKCF field.
	LPTIM_ICR_REPOKCF_Msk = 0x100
	// Bit REPOKCF.
	LPTIM_ICR_REPOKCF = 0x100
	// Clear REPOK flag
	LPTIM_ICR_REPOKCF_Clear = 0x1
	// Position of UECF field.
	LPTIM_ICR_UECF_Pos = 0x7
	// Bit mask of UECF field.
	LPTIM_ICR_UECF_Msk = 0x80
	// Bit UECF.
	LPTIM_ICR_UECF = 0x80
	// Clear update event flag
	LPTIM_ICR_UECF_Clear = 0x1
	// Position of DOWNCF field.
	LPTIM_ICR_DOWNCF_Pos = 0x6
	// Bit mask of DOWNCF field.
	LPTIM_ICR_DOWNCF_Msk = 0x40
	// Bit DOWNCF.
	LPTIM_ICR_DOWNCF = 0x40
	// Direction change to down Clear Flag
	LPTIM_ICR_DOWNCF_Clear = 0x1
	// Position of UPCF field.
	LPTIM_ICR_UPCF_Pos = 0x5
	// Bit mask of UPCF field.
	LPTIM_ICR_UPCF_Msk = 0x20
	// Bit UPCF.
	LPTIM_ICR_UPCF = 0x20
	// Direction change to up Clear Flag
	LPTIM_ICR_UPCF_Clear = 0x1
	// Position of ARROKCF field.
	LPTIM_ICR_ARROKCF_Pos = 0x4
	// Bit mask of ARROKCF field.
	LPTIM_ICR_ARROKCF_Msk = 0x10
	// Bit ARROKCF.
	LPTIM_ICR_ARROKCF = 0x10
	// Autoreload register update OK Clear Flag
	LPTIM_ICR_ARROKCF_Clear = 0x1
	// Position of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Pos = 0x3
	// Bit mask of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Msk = 0x8
	// Bit CMPOKCF.
	LPTIM_ICR_CMPOKCF = 0x8
	// Compare register update OK Clear Flag
	LPTIM_ICR_CMPOKCF_Clear = 0x1
	// Position of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Pos = 0x2
	// Bit mask of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Msk = 0x4
	// Bit EXTTRIGCF.
	LPTIM_ICR_EXTTRIGCF = 0x4
	// External trigger valid edge Clear Flag
	LPTIM_ICR_EXTTRIGCF_Clear = 0x1
	// Position of ARRMCF field.
	LPTIM_ICR_ARRMCF_Pos = 0x1
	// Bit mask of ARRMCF field.
	LPTIM_ICR_ARRMCF_Msk = 0x2
	// Bit ARRMCF.
	LPTIM_ICR_ARRMCF = 0x2
	// Autoreload match Clear Flag
	LPTIM_ICR_ARRMCF_Clear = 0x1
	// Position of CMPMCF field.
	LPTIM_ICR_CMPMCF_Pos = 0x0
	// Bit mask of CMPMCF field.
	LPTIM_ICR_CMPMCF_Msk = 0x1
	// Bit CMPMCF.
	LPTIM_ICR_CMPMCF = 0x1
	// Compare match Clear Flag
	LPTIM_ICR_CMPMCF_Clear = 0x1

	// IER: interrupt enable register
	// Position of REPOKIE field.
	LPTIM_IER_REPOKIE_Pos = 0x8
	// Bit mask of REPOKIE field.
	LPTIM_IER_REPOKIE_Msk = 0x100
	// Bit REPOKIE.
	LPTIM_IER_REPOKIE = 0x100
	// Repetition register update OK interrupt disabled
	LPTIM_IER_REPOKIE_Disabled = 0x0
	// Repetition register update OK interrupt enabled
	LPTIM_IER_REPOKIE_Enabled = 0x1
	// Position of UEIE field.
	LPTIM_IER_UEIE_Pos = 0x7
	// Bit mask of UEIE field.
	LPTIM_IER_UEIE_Msk = 0x80
	// Bit UEIE.
	LPTIM_IER_UEIE = 0x80
	// Update event interrupt disabled
	LPTIM_IER_UEIE_Disabled = 0x0
	// Update event interrupt enabled
	LPTIM_IER_UEIE_Enabled = 0x1
	// Position of DOWNIE field.
	LPTIM_IER_DOWNIE_Pos = 0x6
	// Bit mask of DOWNIE field.
	LPTIM_IER_DOWNIE_Msk = 0x40
	// Bit DOWNIE.
	LPTIM_IER_DOWNIE = 0x40
	// DOWN interrupt disabled
	LPTIM_IER_DOWNIE_Disabled = 0x0
	// DOWN interrupt enabled
	LPTIM_IER_DOWNIE_Enabled = 0x1
	// Position of UPIE field.
	LPTIM_IER_UPIE_Pos = 0x5
	// Bit mask of UPIE field.
	LPTIM_IER_UPIE_Msk = 0x20
	// Bit UPIE.
	LPTIM_IER_UPIE = 0x20
	// UP interrupt disabled
	LPTIM_IER_UPIE_Disabled = 0x0
	// UP interrupt enabled
	LPTIM_IER_UPIE_Enabled = 0x1
	// Position of ARROKIE field.
	LPTIM_IER_ARROKIE_Pos = 0x4
	// Bit mask of ARROKIE field.
	LPTIM_IER_ARROKIE_Msk = 0x10
	// Bit ARROKIE.
	LPTIM_IER_ARROKIE = 0x10
	// ARROK interrupt disabled
	LPTIM_IER_ARROKIE_Disabled = 0x0
	// ARROK interrupt enabled
	LPTIM_IER_ARROKIE_Enabled = 0x1
	// Position of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Pos = 0x3
	// Bit mask of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Msk = 0x8
	// Bit CMPOKIE.
	LPTIM_IER_CMPOKIE = 0x8
	// CMPOK interrupt disabled
	LPTIM_IER_CMPOKIE_Disabled = 0x0
	// CMPOK interrupt enabled
	LPTIM_IER_CMPOKIE_Enabled = 0x1
	// Position of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Pos = 0x2
	// Bit mask of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Msk = 0x4
	// Bit EXTTRIGIE.
	LPTIM_IER_EXTTRIGIE = 0x4
	// EXTTRIG interrupt disabled
	LPTIM_IER_EXTTRIGIE_Disabled = 0x0
	// EXTTRIG interrupt enabled
	LPTIM_IER_EXTTRIGIE_Enabled = 0x1
	// Position of ARRMIE field.
	LPTIM_IER_ARRMIE_Pos = 0x1
	// Bit mask of ARRMIE field.
	LPTIM_IER_ARRMIE_Msk = 0x2
	// Bit ARRMIE.
	LPTIM_IER_ARRMIE = 0x2
	// ARRM interrupt disabled
	LPTIM_IER_ARRMIE_Disabled = 0x0
	// ARRM interrupt enabled
	LPTIM_IER_ARRMIE_Enabled = 0x1
	// Position of CMPMIE field.
	LPTIM_IER_CMPMIE_Pos = 0x0
	// Bit mask of CMPMIE field.
	LPTIM_IER_CMPMIE_Msk = 0x1
	// Bit CMPMIE.
	LPTIM_IER_CMPMIE = 0x1
	// CMPM interrupt disabled
	LPTIM_IER_CMPMIE_Disabled = 0x0
	// CMPM interrupt enabled
	LPTIM_IER_CMPMIE_Enabled = 0x1

	// CFGR: configuration register
	// Position of ENC field.
	LPTIM_CFGR_ENC_Pos = 0x18
	// Bit mask of ENC field.
	LPTIM_CFGR_ENC_Msk = 0x1000000
	// Bit ENC.
	LPTIM_CFGR_ENC = 0x1000000
	// Encoder mode disabled
	LPTIM_CFGR_ENC_Disabled = 0x0
	// Encoder mode enabled
	LPTIM_CFGR_ENC_Enabled = 0x1
	// Position of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Pos = 0x17
	// Bit mask of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Msk = 0x800000
	// Bit COUNTMODE.
	LPTIM_CFGR_COUNTMODE = 0x800000
	// The counter is incremented following each internal clock pulse
	LPTIM_CFGR_COUNTMODE_Internal = 0x0
	// The counter is incremented following each valid clock pulse on the LPTIM external Input1
	LPTIM_CFGR_COUNTMODE_External = 0x1
	// Position of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Pos = 0x16
	// Bit mask of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Msk = 0x400000
	// Bit PRELOAD.
	LPTIM_CFGR_PRELOAD = 0x400000
	// Registers are updated after each APB bus write access
	LPTIM_CFGR_PRELOAD_Immediate = 0x0
	// Registers are updated at the end of the current LPTIM period
	LPTIM_CFGR_PRELOAD_EndOfPeriod = 0x1
	// Position of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Pos = 0x15
	// Bit mask of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Msk = 0x200000
	// Bit WAVPOL.
	LPTIM_CFGR_WAVPOL = 0x200000
	// The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
	LPTIM_CFGR_WAVPOL_Positive = 0x0
	// The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
	LPTIM_CFGR_WAVPOL_Negative = 0x1
	// Position of WAVE field.
	LPTIM_CFGR_WAVE_Pos = 0x14
	// Bit mask of WAVE field.
	LPTIM_CFGR_WAVE_Msk = 0x100000
	// Bit WAVE.
	LPTIM_CFGR_WAVE = 0x100000
	// Deactivate Set-once mode, PWM / One Pulse waveform (depending on OPMODE bit)
	LPTIM_CFGR_WAVE_Inactive = 0x0
	// Activate the Set-once mode
	LPTIM_CFGR_WAVE_Active = 0x1
	// Position of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Pos = 0x13
	// Bit mask of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Msk = 0x80000
	// Bit TIMOUT.
	LPTIM_CFGR_TIMOUT = 0x80000
	// A trigger event arriving when the timer is already started will be ignored
	LPTIM_CFGR_TIMOUT_Disabled = 0x0
	// A trigger event arriving when the timer is already started will reset and restart the counter
	LPTIM_CFGR_TIMOUT_Enabled = 0x1
	// Position of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Pos = 0x11
	// Bit mask of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Msk = 0x60000
	// Software trigger (counting start is initiated by software)
	LPTIM_CFGR_TRIGEN_SW = 0x0
	// Rising edge is the active edge
	LPTIM_CFGR_TRIGEN_RisingEdge = 0x1
	// Falling edge is the active edge
	LPTIM_CFGR_TRIGEN_FallingEdge = 0x2
	// Both edges are active edges
	LPTIM_CFGR_TRIGEN_BothEdges = 0x3
	// Position of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Pos = 0xd
	// Bit mask of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Msk = 0xe000
	// lptim_ext_trig0
	LPTIM_CFGR_TRIGSEL_Trig0 = 0x0
	// lptim_ext_trig1
	LPTIM_CFGR_TRIGSEL_Trig1 = 0x1
	// lptim_ext_trig2
	LPTIM_CFGR_TRIGSEL_Trig2 = 0x2
	// lptim_ext_trig3
	LPTIM_CFGR_TRIGSEL_Trig3 = 0x3
	// lptim_ext_trig4
	LPTIM_CFGR_TRIGSEL_Trig4 = 0x4
	// lptim_ext_trig5
	LPTIM_CFGR_TRIGSEL_Trig5 = 0x5
	// lptim_ext_trig6
	LPTIM_CFGR_TRIGSEL_Trig6 = 0x6
	// lptim_ext_trig7
	LPTIM_CFGR_TRIGSEL_Trig7 = 0x7
	// Position of PRESC field.
	LPTIM_CFGR_PRESC_Pos = 0x9
	// Bit mask of PRESC field.
	LPTIM_CFGR_PRESC_Msk = 0xe00
	// /1
	LPTIM_CFGR_PRESC_Div1 = 0x0
	// /2
	LPTIM_CFGR_PRESC_Div2 = 0x1
	// /4
	LPTIM_CFGR_PRESC_Div4 = 0x2
	// /8
	LPTIM_CFGR_PRESC_Div8 = 0x3
	// /16
	LPTIM_CFGR_PRESC_Div16 = 0x4
	// /32
	LPTIM_CFGR_PRESC_Div32 = 0x5
	// /64
	LPTIM_CFGR_PRESC_Div64 = 0x6
	// /128
	LPTIM_CFGR_PRESC_Div128 = 0x7
	// Position of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Pos = 0x6
	// Bit mask of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Msk = 0xc0
	// Any trigger active level change is considered as a valid trigger
	LPTIM_CFGR_TRGFLT_Immediate = 0x0
	// Trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger
	LPTIM_CFGR_TRGFLT_Clocks2 = 0x1
	// Trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger
	LPTIM_CFGR_TRGFLT_Clocks4 = 0x2
	// Trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger
	LPTIM_CFGR_TRGFLT_Clocks8 = 0x3
	// Position of CKFLT field.
	LPTIM_CFGR_CKFLT_Pos = 0x3
	// Bit mask of CKFLT field.
	LPTIM_CFGR_CKFLT_Msk = 0x18
	// Any external clock signal level change is considered as a valid transition
	LPTIM_CFGR_CKFLT_Immediate = 0x0
	// External clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition
	LPTIM_CFGR_CKFLT_Clocks2 = 0x1
	// External clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition
	LPTIM_CFGR_CKFLT_Clocks4 = 0x2
	// External clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition
	LPTIM_CFGR_CKFLT_Clocks8 = 0x3
	// Position of CKPOL field.
	LPTIM_CFGR_CKPOL_Pos = 0x1
	// Bit mask of CKPOL field.
	LPTIM_CFGR_CKPOL_Msk = 0x6
	// The rising edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 1 is active.
	LPTIM_CFGR_CKPOL_RisingEdge = 0x0
	// The falling edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 2 is active.
	LPTIM_CFGR_CKPOL_FallingEdge = 0x1
	// Both edges are active edge. If LPTIM is in encoder mode: Encoder sub-mode 3 is active.
	LPTIM_CFGR_CKPOL_BothEdges = 0x2
	// Position of CKSEL field.
	LPTIM_CFGR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	LPTIM_CFGR_CKSEL_Msk = 0x1
	// Bit CKSEL.
	LPTIM_CFGR_CKSEL = 0x1
	// LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
	LPTIM_CFGR_CKSEL_Internal = 0x0
	// LPTIM is clocked by an external clock source through the LPTIM external Input1
	LPTIM_CFGR_CKSEL_External = 0x1

	// CR: control register
	// Position of RSTARE field.
	LPTIM_CR_RSTARE_Pos = 0x4
	// Bit mask of RSTARE field.
	LPTIM_CR_RSTARE_Msk = 0x10
	// Bit RSTARE.
	LPTIM_CR_RSTARE = 0x10
	// CNT Register reads do not trigger reset
	LPTIM_CR_RSTARE_Disabled = 0x0
	// CNT Register reads trigger reset of LPTIM
	LPTIM_CR_RSTARE_Enabled = 0x1
	// Position of COUNTRST field.
	LPTIM_CR_COUNTRST_Pos = 0x3
	// Bit mask of COUNTRST field.
	LPTIM_CR_COUNTRST_Msk = 0x8
	// Bit COUNTRST.
	LPTIM_CR_COUNTRST = 0x8
	// Triggering of reset is possible
	LPTIM_CR_COUNTRST_Idle = 0x0
	// Reset in progress, do not write 1 to this field
	LPTIM_CR_COUNTRST_Busy = 0x1
	// Trigger synchronous reset of CNT (3 LPTimer core clock cycles)
	LPTIM_CR_COUNTRST_Reset = 0x1
	// Position of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Pos = 0x2
	// Bit mask of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Msk = 0x4
	// Bit CNTSTRT.
	LPTIM_CR_CNTSTRT = 0x4
	// Timer start in Continuous mode
	LPTIM_CR_CNTSTRT_Start = 0x1
	// Position of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Pos = 0x1
	// Bit mask of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Msk = 0x2
	// Bit SNGSTRT.
	LPTIM_CR_SNGSTRT = 0x2
	// LPTIM start in Single mode
	LPTIM_CR_SNGSTRT_Start = 0x1
	// Position of ENABLE field.
	LPTIM_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPTIM_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	LPTIM_CR_ENABLE = 0x1
	// LPTIM is disabled
	LPTIM_CR_ENABLE_Disabled = 0x0
	// LPTIM is enabled
	LPTIM_CR_ENABLE_Enabled = 0x1

	// CMP: compare register
	// Position of CMP field.
	LPTIM_CMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	LPTIM_CMP_CMP_Msk = 0xffff

	// ARR: autoreload register
	// Position of ARR field.
	LPTIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	LPTIM_ARR_ARR_Msk = 0xffff

	// CNT: counter register
	// Position of CNT field.
	LPTIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	LPTIM_CNT_CNT_Msk = 0xffff

	// OR: option register
	// Position of OR_1 field.
	LPTIM_OR_OR_1_Pos = 0x1
	// Bit mask of OR_1 field.
	LPTIM_OR_OR_1_Msk = 0x2
	// Bit OR_1.
	LPTIM_OR_OR_1 = 0x2
	// LPTIM1 input 2 is connected to I/O
	LPTIM_OR_OR_1_IO = 0x0
	// LPTIM1 input 2 is connected to COMP2_OUT
	LPTIM_OR_OR_1_COMP2_OUT = 0x1
	// Position of OR_0 field.
	LPTIM_OR_OR_0_Pos = 0x0
	// Bit mask of OR_0 field.
	LPTIM_OR_OR_0_Msk = 0x1
	// Bit OR_0.
	LPTIM_OR_OR_0 = 0x1
	// LPTIM1 input 1 is connected to I/O
	LPTIM_OR_OR_0_IO = 0x0
	// LPTIM1 input 1 is connected to COMP1_OUT
	LPTIM_OR_OR_0_COMP1_OUT = 0x1

	// RCR: repetition register
	// Position of REP field.
	LPTIM_RCR_REP_Pos = 0x0
	// Bit mask of REP field.
	LPTIM_RCR_REP_Msk = 0xff
)

// Constants for LPUART: Universal synchronous asynchronous receiver transmitter
const (
	// CR1: Control register 1
	// Position of RXFFIE field.
	USART_CR1_RXFFIE_Pos = 0x1f
	// Bit mask of RXFFIE field.
	USART_CR1_RXFFIE_Msk = 0x80000000
	// Bit RXFFIE.
	USART_CR1_RXFFIE = 0x80000000
	// Interrupt inhibited
	USART_CR1_RXFFIE_Disabled = 0x0
	// USART interrupt generated when RXFF = 1 in the USART_ISR register
	USART_CR1_RXFFIE_Enabled = 0x1
	// Position of TXFEIE field.
	USART_CR1_TXFEIE_Pos = 0x1e
	// Bit mask of TXFEIE field.
	USART_CR1_TXFEIE_Msk = 0x40000000
	// Bit TXFEIE.
	USART_CR1_TXFEIE = 0x40000000
	// Interrupt inhibited
	USART_CR1_TXFEIE_Disabled = 0x0
	// USART interrupt generated when TXFE = 1 in the USART_ISR register
	USART_CR1_TXFEIE_Enabled = 0x1
	// Position of FIFOEN field.
	USART_CR1_FIFOEN_Pos = 0x1d
	// Bit mask of FIFOEN field.
	USART_CR1_FIFOEN_Msk = 0x20000000
	// Bit FIFOEN.
	USART_CR1_FIFOEN = 0x20000000
	// FIFO mode is disabled
	USART_CR1_FIFOEN_Disabled = 0x0
	// FIFO mode is enabled
	USART_CR1_FIFOEN_Enabled = 0x1
	// Position of M1 field.
	USART_CR1_M1_Pos = 0x1c
	// Bit mask of M1 field.
	USART_CR1_M1_Msk = 0x10000000
	// Bit M1.
	USART_CR1_M1 = 0x10000000
	// Use M0 to set the data bits
	USART_CR1_M1_M0 = 0x0
	// 1 start bit, 7 data bits, n stop bits
	USART_CR1_M1_Bit7 = 0x1
	// Position of DEAT field.
	USART_CR1_DEAT_Pos = 0x15
	// Bit mask of DEAT field.
	USART_CR1_DEAT_Msk = 0x3e00000
	// Position of DEDT field.
	USART_CR1_DEDT_Pos = 0x10
	// Bit mask of DEDT field.
	USART_CR1_DEDT_Msk = 0x1f0000
	// Position of CMIE field.
	USART_CR1_CMIE_Pos = 0xe
	// Bit mask of CMIE field.
	USART_CR1_CMIE_Msk = 0x4000
	// Bit CMIE.
	USART_CR1_CMIE = 0x4000
	// Interrupt is disabled
	USART_CR1_CMIE_Disabled = 0x0
	// Interrupt is generated when the CMF bit is set in the ISR register
	USART_CR1_CMIE_Enabled = 0x1
	// Position of MME field.
	USART_CR1_MME_Pos = 0xd
	// Bit mask of MME field.
	USART_CR1_MME_Msk = 0x2000
	// Bit MME.
	USART_CR1_MME = 0x2000
	// Receiver in active mode permanently
	USART_CR1_MME_Disabled = 0x0
	// Receiver can switch between mute mode and active mode
	USART_CR1_MME_Enabled = 0x1
	// Position of M0 field.
	USART_CR1_M0_Pos = 0xc
	// Bit mask of M0 field.
	USART_CR1_M0_Msk = 0x1000
	// Bit M0.
	USART_CR1_M0 = 0x1000
	// 1 start bit, 8 data bits, n stop bits
	USART_CR1_M0_Bit8 = 0x0
	// 1 start bit, 9 data bits, n stop bits
	USART_CR1_M0_Bit9 = 0x1
	// Position of WAKE field.
	USART_CR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	USART_CR1_WAKE_Msk = 0x800
	// Bit WAKE.
	USART_CR1_WAKE = 0x800
	// Idle line
	USART_CR1_WAKE_Idle = 0x0
	// Address mask
	USART_CR1_WAKE_Address = 0x1
	// Position of PCE field.
	USART_CR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	USART_CR1_PCE_Msk = 0x400
	// Bit PCE.
	USART_CR1_PCE = 0x400
	// Parity control disabled
	USART_CR1_PCE_Disabled = 0x0
	// Parity control enabled
	USART_CR1_PCE_Enabled = 0x1
	// Position of PS field.
	USART_CR1_PS_Pos = 0x9
	// Bit mask of PS field.
	USART_CR1_PS_Msk = 0x200
	// Bit PS.
	USART_CR1_PS = 0x200
	// Even parity
	USART_CR1_PS_Even = 0x0
	// Odd parity
	USART_CR1_PS_Odd = 0x1
	// Position of PEIE field.
	USART_CR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	USART_CR1_PEIE_Msk = 0x100
	// Bit PEIE.
	USART_CR1_PEIE = 0x100
	// Interrupt is disabled
	USART_CR1_PEIE_Disabled = 0x0
	// Interrupt is generated whenever PE=1 in the ISR register
	USART_CR1_PEIE_Enabled = 0x1
	// Position of TXEIE field.
	USART_CR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	USART_CR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	USART_CR1_TXEIE = 0x80
	// Interrupt is disabled
	USART_CR1_TXEIE_Disabled = 0x0
	// Interrupt is generated whenever TXE=1 in the ISR register
	USART_CR1_TXEIE_Enabled = 0x1
	// Position of TCIE field.
	USART_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	USART_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	USART_CR1_TCIE = 0x40
	// Interrupt is disabled
	USART_CR1_TCIE_Disabled = 0x0
	// Interrupt is generated whenever TC=1 in the ISR register
	USART_CR1_TCIE_Enabled = 0x1
	// Position of RXNEIE field.
	USART_CR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	USART_CR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	USART_CR1_RXNEIE = 0x20
	// Interrupt is disabled
	USART_CR1_RXNEIE_Disabled = 0x0
	// Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register
	USART_CR1_RXNEIE_Enabled = 0x1
	// Position of IDLEIE field.
	USART_CR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	USART_CR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	USART_CR1_IDLEIE = 0x10
	// Interrupt is disabled
	USART_CR1_IDLEIE_Disabled = 0x0
	// Interrupt is generated whenever IDLE=1 in the ISR register
	USART_CR1_IDLEIE_Enabled = 0x1
	// Position of TE field.
	USART_CR1_TE_Pos = 0x3
	// Bit mask of TE field.
	USART_CR1_TE_Msk = 0x8
	// Bit TE.
	USART_CR1_TE = 0x8
	// Transmitter is disabled
	USART_CR1_TE_Disabled = 0x0
	// Transmitter is enabled
	USART_CR1_TE_Enabled = 0x1
	// Position of RE field.
	USART_CR1_RE_Pos = 0x2
	// Bit mask of RE field.
	USART_CR1_RE_Msk = 0x4
	// Bit RE.
	USART_CR1_RE = 0x4
	// Receiver is disabled
	USART_CR1_RE_Disabled = 0x0
	// Receiver is enabled
	USART_CR1_RE_Enabled = 0x1
	// Position of UESM field.
	USART_CR1_UESM_Pos = 0x1
	// Bit mask of UESM field.
	USART_CR1_UESM_Msk = 0x2
	// Bit UESM.
	USART_CR1_UESM = 0x2
	// USART not able to wake up the MCU from Stop mode
	USART_CR1_UESM_Disabled = 0x0
	// USART able to wake up the MCU from Stop mode
	USART_CR1_UESM_Enabled = 0x1
	// Position of UE field.
	USART_CR1_UE_Pos = 0x0
	// Bit mask of UE field.
	USART_CR1_UE_Msk = 0x1
	// Bit UE.
	USART_CR1_UE = 0x1
	// UART is disabled
	USART_CR1_UE_Disabled = 0x0
	// UART is enabled
	USART_CR1_UE_Enabled = 0x1

	// CR2: Control register 2
	// Position of ADD field.
	USART_CR2_ADD_Pos = 0x18
	// Bit mask of ADD field.
	USART_CR2_ADD_Msk = 0xff000000
	// Position of MSBFIRST field.
	USART_CR2_MSBFIRST_Pos = 0x13
	// Bit mask of MSBFIRST field.
	USART_CR2_MSBFIRST_Msk = 0x80000
	// Bit MSBFIRST.
	USART_CR2_MSBFIRST = 0x80000
	// data is transmitted/received with data bit 0 first, following the start bit
	USART_CR2_MSBFIRST_LSB = 0x0
	// data is transmitted/received with MSB (bit 7/8/9) first, following the start bit
	USART_CR2_MSBFIRST_MSB = 0x1
	// Position of DATAINV field.
	USART_CR2_DATAINV_Pos = 0x12
	// Bit mask of DATAINV field.
	USART_CR2_DATAINV_Msk = 0x40000
	// Bit DATAINV.
	USART_CR2_DATAINV = 0x40000
	// Logical data from the data register are send/received in positive/direct logic
	USART_CR2_DATAINV_Positive = 0x0
	// Logical data from the data register are send/received in negative/inverse logic
	USART_CR2_DATAINV_Negative = 0x1
	// Position of TXINV field.
	USART_CR2_TXINV_Pos = 0x11
	// Bit mask of TXINV field.
	USART_CR2_TXINV_Msk = 0x20000
	// Bit TXINV.
	USART_CR2_TXINV = 0x20000
	// TX pin signal works using the standard logic levels
	USART_CR2_TXINV_Standard = 0x0
	// TX pin signal values are inverted
	USART_CR2_TXINV_Inverted = 0x1
	// Position of RXINV field.
	USART_CR2_RXINV_Pos = 0x10
	// Bit mask of RXINV field.
	USART_CR2_RXINV_Msk = 0x10000
	// Bit RXINV.
	USART_CR2_RXINV = 0x10000
	// RX pin signal works using the standard logic levels
	USART_CR2_RXINV_Standard = 0x0
	// RX pin signal values are inverted
	USART_CR2_RXINV_Inverted = 0x1
	// Position of SWAP field.
	USART_CR2_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	USART_CR2_SWAP_Msk = 0x8000
	// Bit SWAP.
	USART_CR2_SWAP = 0x8000
	// TX/RX pins are used as defined in standard pinout
	USART_CR2_SWAP_Standard = 0x0
	// The TX and RX pins functions are swapped
	USART_CR2_SWAP_Swapped = 0x1
	// Position of STOP field.
	USART_CR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	USART_CR2_STOP_Msk = 0x3000
	// 1 stop bit
	USART_CR2_STOP_Stop1 = 0x0
	// 2 stop bit
	USART_CR2_STOP_Stop2 = 0x2
	// Position of ADDM7 field.
	USART_CR2_ADDM7_Pos = 0x4
	// Bit mask of ADDM7 field.
	USART_CR2_ADDM7_Msk = 0x10
	// Bit ADDM7.
	USART_CR2_ADDM7 = 0x10
	// 4-bit address detection
	USART_CR2_ADDM7_Bit4 = 0x0
	// 7-bit address detection
	USART_CR2_ADDM7_Bit7 = 0x1

	// CR3: Control register 3
	// Position of TXFTCFG field.
	USART_CR3_TXFTCFG_Pos = 0x1d
	// Bit mask of TXFTCFG field.
	USART_CR3_TXFTCFG_Msk = 0xe0000000
	// TXFIFO reaches 1/8 of its depth
	USART_CR3_TXFTCFG_Depth_1_8 = 0x0
	// TXFIFO reaches 1/4 of its depth
	USART_CR3_TXFTCFG_Depth_1_4 = 0x1
	// TXFIFO reaches 1/2 of its depth
	USART_CR3_TXFTCFG_Depth_1_2 = 0x2
	// TXFIFO reaches 3/4 of its depth
	USART_CR3_TXFTCFG_Depth_3_4 = 0x3
	// TXFIFO reaches 7/8 of its depth
	USART_CR3_TXFTCFG_Depth_7_8 = 0x4
	// TXFIFO becomes empty
	USART_CR3_TXFTCFG_Empty = 0x5
	// Position of RXFTIE field.
	USART_CR3_RXFTIE_Pos = 0x1c
	// Bit mask of RXFTIE field.
	USART_CR3_RXFTIE_Msk = 0x10000000
	// Bit RXFTIE.
	USART_CR3_RXFTIE = 0x10000000
	// Interrupt inhibited
	USART_CR3_RXFTIE_Disabled = 0x0
	// USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG
	USART_CR3_RXFTIE_Enabled = 0x1
	// Position of RXFTCFG field.
	USART_CR3_RXFTCFG_Pos = 0x19
	// Bit mask of RXFTCFG field.
	USART_CR3_RXFTCFG_Msk = 0xe000000
	// RXFIFO reaches 1/8 of its depth
	USART_CR3_RXFTCFG_Depth_1_8 = 0x0
	// RXFIFO reaches 1/4 of its depth
	USART_CR3_RXFTCFG_Depth_1_4 = 0x1
	// RXFIFO reaches 1/2 of its depth
	USART_CR3_RXFTCFG_Depth_1_2 = 0x2
	// RXFIFO reaches 3/4 of its depth
	USART_CR3_RXFTCFG_Depth_3_4 = 0x3
	// RXFIFO reaches 7/8 of its depth
	USART_CR3_RXFTCFG_Depth_7_8 = 0x4
	// RXFIFO becomes full
	USART_CR3_RXFTCFG_Full = 0x5
	// Position of TXFTIE field.
	USART_CR3_TXFTIE_Pos = 0x17
	// Bit mask of TXFTIE field.
	USART_CR3_TXFTIE_Msk = 0x800000
	// Bit TXFTIE.
	USART_CR3_TXFTIE = 0x800000
	// Interrupt inhibited
	USART_CR3_TXFTIE_Disabled = 0x0
	// USART interrupt generated when Transmit FIFO reaches the threshold programmed in TXFTCFG
	USART_CR3_TXFTIE_Enabled = 0x1
	// Position of WUFIE field.
	USART_CR3_WUFIE_Pos = 0x16
	// Bit mask of WUFIE field.
	USART_CR3_WUFIE_Msk = 0x400000
	// Bit WUFIE.
	USART_CR3_WUFIE = 0x400000
	// Interrupt is inhibited
	USART_CR3_WUFIE_Disabled = 0x0
	// An USART interrupt is generated whenever WUF=1 in the ISR register
	USART_CR3_WUFIE_Enabled = 0x1
	// Position of WUS field.
	USART_CR3_WUS_Pos = 0x14
	// Bit mask of WUS field.
	USART_CR3_WUS_Msk = 0x300000
	// WUF active on address match
	USART_CR3_WUS_Address = 0x0
	// WuF active on Start bit detection
	USART_CR3_WUS_Start = 0x2
	// WUF active on RXNE
	USART_CR3_WUS_RXNE = 0x3
	// Position of DEP field.
	USART_CR3_DEP_Pos = 0xf
	// Bit mask of DEP field.
	USART_CR3_DEP_Msk = 0x8000
	// Bit DEP.
	USART_CR3_DEP = 0x8000
	// DE signal is active high
	USART_CR3_DEP_High = 0x0
	// DE signal is active low
	USART_CR3_DEP_Low = 0x1
	// Position of DEM field.
	USART_CR3_DEM_Pos = 0xe
	// Bit mask of DEM field.
	USART_CR3_DEM_Msk = 0x4000
	// Bit DEM.
	USART_CR3_DEM = 0x4000
	// DE function is disabled
	USART_CR3_DEM_Disabled = 0x0
	// The DE signal is output on the RTS pin
	USART_CR3_DEM_Enabled = 0x1
	// Position of DDRE field.
	USART_CR3_DDRE_Pos = 0xd
	// Bit mask of DDRE field.
	USART_CR3_DDRE_Msk = 0x2000
	// Bit DDRE.
	USART_CR3_DDRE = 0x2000
	// DMA is not disabled in case of reception error
	USART_CR3_DDRE_NotDisabled = 0x0
	// DMA is disabled following a reception error
	USART_CR3_DDRE_Disabled = 0x1
	// Position of OVRDIS field.
	USART_CR3_OVRDIS_Pos = 0xc
	// Bit mask of OVRDIS field.
	USART_CR3_OVRDIS_Msk = 0x1000
	// Bit OVRDIS.
	USART_CR3_OVRDIS = 0x1000
	// Overrun Error Flag, ORE, is set when received data is not read before receiving new data
	USART_CR3_OVRDIS_Enabled = 0x0
	// Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register
	USART_CR3_OVRDIS_Disabled = 0x1
	// Position of CTSIE field.
	USART_CR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	USART_CR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	USART_CR3_CTSIE = 0x400
	// Interrupt is inhibited
	USART_CR3_CTSIE_Disabled = 0x0
	// An interrupt is generated whenever CTSIF=1 in the ISR register
	USART_CR3_CTSIE_Enabled = 0x1
	// Position of CTSE field.
	USART_CR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	USART_CR3_CTSE_Msk = 0x200
	// Bit CTSE.
	USART_CR3_CTSE = 0x200
	// CTS hardware flow control disabled
	USART_CR3_CTSE_Disabled = 0x0
	// CTS mode enabled, data is only transmitted when the CTS input is asserted
	USART_CR3_CTSE_Enabled = 0x1
	// Position of RTSE field.
	USART_CR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	USART_CR3_RTSE_Msk = 0x100
	// Bit RTSE.
	USART_CR3_RTSE = 0x100
	// RTS hardware flow control disabled
	USART_CR3_RTSE_Disabled = 0x0
	// RTS output enabled, data is only requested when there is space in the receive buffer
	USART_CR3_RTSE_Enabled = 0x1
	// Position of DMAT field.
	USART_CR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	USART_CR3_DMAT_Msk = 0x80
	// Bit DMAT.
	USART_CR3_DMAT = 0x80
	// DMA mode is disabled for transmission
	USART_CR3_DMAT_Disabled = 0x0
	// DMA mode is enabled for transmission
	USART_CR3_DMAT_Enabled = 0x1
	// Position of DMAR field.
	USART_CR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	USART_CR3_DMAR_Msk = 0x40
	// Bit DMAR.
	USART_CR3_DMAR = 0x40
	// DMA mode is disabled for reception
	USART_CR3_DMAR_Disabled = 0x0
	// DMA mode is enabled for reception
	USART_CR3_DMAR_Enabled = 0x1
	// Position of HDSEL field.
	USART_CR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	USART_CR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	USART_CR3_HDSEL = 0x8
	// Half duplex mode is not selected
	USART_CR3_HDSEL_NotSelected = 0x0
	// Half duplex mode is selected
	USART_CR3_HDSEL_Selected = 0x1
	// Position of EIE field.
	USART_CR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	USART_CR3_EIE_Msk = 0x1
	// Bit EIE.
	USART_CR3_EIE = 0x1
	// Interrupt is inhibited
	USART_CR3_EIE_Disabled = 0x0
	// An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register
	USART_CR3_EIE_Enabled = 0x1

	// BRR: Baud rate register
	// Position of BRR field.
	USART_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	USART_BRR_BRR_Msk = 0xfffff

	// RQR: Request register
	// Position of TXFRQ field.
	USART_RQR_TXFRQ_Pos = 0x4
	// Bit mask of TXFRQ field.
	USART_RQR_TXFRQ_Msk = 0x10
	// Bit TXFRQ.
	USART_RQR_TXFRQ = 0x10
	// Set the TXE flags. This allows to discard the transmit data
	USART_RQR_TXFRQ_Discard = 0x1
	// Position of RXFRQ field.
	USART_RQR_RXFRQ_Pos = 0x3
	// Bit mask of RXFRQ field.
	USART_RQR_RXFRQ_Msk = 0x8
	// Bit RXFRQ.
	USART_RQR_RXFRQ = 0x8
	// clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition
	USART_RQR_RXFRQ_Discard = 0x1
	// Position of MMRQ field.
	USART_RQR_MMRQ_Pos = 0x2
	// Bit mask of MMRQ field.
	USART_RQR_MMRQ_Msk = 0x4
	// Bit MMRQ.
	USART_RQR_MMRQ = 0x4
	// Puts the USART in mute mode and sets the RWU flag
	USART_RQR_MMRQ_Mute = 0x1
	// Position of SBKRQ field.
	USART_RQR_SBKRQ_Pos = 0x1
	// Bit mask of SBKRQ field.
	USART_RQR_SBKRQ_Msk = 0x2
	// Bit SBKRQ.
	USART_RQR_SBKRQ = 0x2
	// sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available
	USART_RQR_SBKRQ_Break = 0x1

	// ISR: Interrupt and status register
	// Position of TXFT field.
	USART_ISR_TXFT_Pos = 0x1b
	// Bit mask of TXFT field.
	USART_ISR_TXFT_Msk = 0x8000000
	// Bit TXFT.
	USART_ISR_TXFT = 0x8000000
	// Position of RXFT field.
	USART_ISR_RXFT_Pos = 0x1a
	// Bit mask of RXFT field.
	USART_ISR_RXFT_Msk = 0x4000000
	// Bit RXFT.
	USART_ISR_RXFT = 0x4000000
	// Position of RXFF field.
	USART_ISR_RXFF_Pos = 0x18
	// Bit mask of RXFF field.
	USART_ISR_RXFF_Msk = 0x1000000
	// Bit RXFF.
	USART_ISR_RXFF = 0x1000000
	// Position of TXFE field.
	USART_ISR_TXFE_Pos = 0x17
	// Bit mask of TXFE field.
	USART_ISR_TXFE_Msk = 0x800000
	// Bit TXFE.
	USART_ISR_TXFE = 0x800000
	// Position of REACK field.
	USART_ISR_REACK_Pos = 0x16
	// Bit mask of REACK field.
	USART_ISR_REACK_Msk = 0x400000
	// Bit REACK.
	USART_ISR_REACK = 0x400000
	// Position of TEACK field.
	USART_ISR_TEACK_Pos = 0x15
	// Bit mask of TEACK field.
	USART_ISR_TEACK_Msk = 0x200000
	// Bit TEACK.
	USART_ISR_TEACK = 0x200000
	// Position of WUF field.
	USART_ISR_WUF_Pos = 0x14
	// Bit mask of WUF field.
	USART_ISR_WUF_Msk = 0x100000
	// Bit WUF.
	USART_ISR_WUF = 0x100000
	// Position of RWU field.
	USART_ISR_RWU_Pos = 0x13
	// Bit mask of RWU field.
	USART_ISR_RWU_Msk = 0x80000
	// Bit RWU.
	USART_ISR_RWU = 0x80000
	// Position of SBKF field.
	USART_ISR_SBKF_Pos = 0x12
	// Bit mask of SBKF field.
	USART_ISR_SBKF_Msk = 0x40000
	// Bit SBKF.
	USART_ISR_SBKF = 0x40000
	// Position of CMF field.
	USART_ISR_CMF_Pos = 0x11
	// Bit mask of CMF field.
	USART_ISR_CMF_Msk = 0x20000
	// Bit CMF.
	USART_ISR_CMF = 0x20000
	// Position of BUSY field.
	USART_ISR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	USART_ISR_BUSY_Msk = 0x10000
	// Bit BUSY.
	USART_ISR_BUSY = 0x10000
	// Position of CTS field.
	USART_ISR_CTS_Pos = 0xa
	// Bit mask of CTS field.
	USART_ISR_CTS_Msk = 0x400
	// Bit CTS.
	USART_ISR_CTS = 0x400
	// Position of CTSIF field.
	USART_ISR_CTSIF_Pos = 0x9
	// Bit mask of CTSIF field.
	USART_ISR_CTSIF_Msk = 0x200
	// Bit CTSIF.
	USART_ISR_CTSIF = 0x200
	// Position of TXFNF field.
	USART_ISR_TXFNF_Pos = 0x7
	// Bit mask of TXFNF field.
	USART_ISR_TXFNF_Msk = 0x80
	// Bit TXFNF.
	USART_ISR_TXFNF = 0x80
	// Position of TC field.
	USART_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	USART_ISR_TC_Msk = 0x40
	// Bit TC.
	USART_ISR_TC = 0x40
	// Position of RXFNE field.
	USART_ISR_RXFNE_Pos = 0x5
	// Bit mask of RXFNE field.
	USART_ISR_RXFNE_Msk = 0x20
	// Bit RXFNE.
	USART_ISR_RXFNE = 0x20
	// Position of IDLE field.
	USART_ISR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	USART_ISR_IDLE_Msk = 0x10
	// Bit IDLE.
	USART_ISR_IDLE = 0x10
	// Position of ORE field.
	USART_ISR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	USART_ISR_ORE_Msk = 0x8
	// Bit ORE.
	USART_ISR_ORE = 0x8
	// Position of NE field.
	USART_ISR_NE_Pos = 0x2
	// Bit mask of NE field.
	USART_ISR_NE_Msk = 0x4
	// Bit NE.
	USART_ISR_NE = 0x4
	// Position of FE field.
	USART_ISR_FE_Pos = 0x1
	// Bit mask of FE field.
	USART_ISR_FE_Msk = 0x2
	// Bit FE.
	USART_ISR_FE = 0x2
	// Position of PE field.
	USART_ISR_PE_Pos = 0x0
	// Bit mask of PE field.
	USART_ISR_PE_Msk = 0x1
	// Bit PE.
	USART_ISR_PE = 0x1

	// ICR: Interrupt flag clear register
	// Position of WUCF field.
	USART_ICR_WUCF_Pos = 0x14
	// Bit mask of WUCF field.
	USART_ICR_WUCF_Msk = 0x100000
	// Bit WUCF.
	USART_ICR_WUCF = 0x100000
	// Clears the WUF flag in the ISR register
	USART_ICR_WUCF_Clear = 0x1
	// Position of CMCF field.
	USART_ICR_CMCF_Pos = 0x11
	// Bit mask of CMCF field.
	USART_ICR_CMCF_Msk = 0x20000
	// Bit CMCF.
	USART_ICR_CMCF = 0x20000
	// Clears the CMF flag in the ISR register
	USART_ICR_CMCF_Clear = 0x1
	// Position of CTSCF field.
	USART_ICR_CTSCF_Pos = 0x9
	// Bit mask of CTSCF field.
	USART_ICR_CTSCF_Msk = 0x200
	// Bit CTSCF.
	USART_ICR_CTSCF = 0x200
	// Clears the CTSIF flag in the ISR register
	USART_ICR_CTSCF_Clear = 0x1
	// Position of TCCF field.
	USART_ICR_TCCF_Pos = 0x6
	// Bit mask of TCCF field.
	USART_ICR_TCCF_Msk = 0x40
	// Bit TCCF.
	USART_ICR_TCCF = 0x40
	// Clears the TC flag in the ISR register
	USART_ICR_TCCF_Clear = 0x1
	// Position of IDLECF field.
	USART_ICR_IDLECF_Pos = 0x4
	// Bit mask of IDLECF field.
	USART_ICR_IDLECF_Msk = 0x10
	// Bit IDLECF.
	USART_ICR_IDLECF = 0x10
	// Clears the IDLE flag in the ISR register
	USART_ICR_IDLECF_Clear = 0x1
	// Position of ORECF field.
	USART_ICR_ORECF_Pos = 0x3
	// Bit mask of ORECF field.
	USART_ICR_ORECF_Msk = 0x8
	// Bit ORECF.
	USART_ICR_ORECF = 0x8
	// Clears the ORE flag in the ISR register
	USART_ICR_ORECF_Clear = 0x1
	// Position of NCF field.
	USART_ICR_NCF_Pos = 0x2
	// Bit mask of NCF field.
	USART_ICR_NCF_Msk = 0x4
	// Bit NCF.
	USART_ICR_NCF = 0x4
	// Clears the NF flag in the ISR register
	USART_ICR_NCF_Clear = 0x1
	// Position of FECF field.
	USART_ICR_FECF_Pos = 0x1
	// Bit mask of FECF field.
	USART_ICR_FECF_Msk = 0x2
	// Bit FECF.
	USART_ICR_FECF = 0x2
	// Clears the FE flag in the ISR register
	USART_ICR_FECF_Clear = 0x1
	// Position of PECF field.
	USART_ICR_PECF_Pos = 0x0
	// Bit mask of PECF field.
	USART_ICR_PECF_Msk = 0x1
	// Bit PECF.
	USART_ICR_PECF = 0x1
	// Clears the PE flag in the ISR register
	USART_ICR_PECF_Clear = 0x1

	// RDR: Receive data register
	// Position of RDR field.
	USART_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	USART_RDR_RDR_Msk = 0x1ff

	// TDR: Transmit data register
	// Position of TDR field.
	USART_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	USART_TDR_TDR_Msk = 0x1ff

	// PRESC: Prescaler register
	// Position of PRESCALER field.
	USART_PRESC_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	USART_PRESC_PRESCALER_Msk = 0xf
	// /1
	USART_PRESC_PRESCALER_Div1 = 0x0
	// /2
	USART_PRESC_PRESCALER_Div2 = 0x1
	// /4
	USART_PRESC_PRESCALER_Div4 = 0x2
	// /6
	USART_PRESC_PRESCALER_Div6 = 0x3
	// /8
	USART_PRESC_PRESCALER_Div8 = 0x4
	// /10
	USART_PRESC_PRESCALER_Div10 = 0x5
	// /12
	USART_PRESC_PRESCALER_Div12 = 0x6
	// /16
	USART_PRESC_PRESCALER_Div16 = 0x7
	// /32
	USART_PRESC_PRESCALER_Div32 = 0x8
	// /64
	USART_PRESC_PRESCALER_Div64 = 0x9
	// /128
	USART_PRESC_PRESCALER_Div128 = 0xa
	// /256
	USART_PRESC_PRESCALER_Div256 = 0xb
)

// Constants for MPU: Memory protection unit
const (
	// TYPER: MPU type register
	// Position of SEPARATE field.
	MPU_TYPER_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPER_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPER_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPER_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPER_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPER_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPER_IREGION_Msk = 0xff0000

	// CTRL: MPU control register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU region number register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU region base address register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU region attribute and size register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x3e
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER0: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER0_SETENA_Msk = 0xffffffff

	// ISER1: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER1_SETENA_Msk = 0xffffffff

	// ICER0: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER0_CLRENA_Msk = 0xffffffff

	// ICER1: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER1_CLRENA_Msk = 0xffffffff

	// ISPR0: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR0_SETPEND_Msk = 0xffffffff

	// ISPR1: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR1_SETPEND_Msk = 0xffffffff

	// ICPR0: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Msk = 0xffffffff

	// ICPR1: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Msk = 0xffffffff

	// IABR0: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR0_ACTIVE_Msk = 0xffffffff

	// IABR1: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR1_ACTIVE_Msk = 0xffffffff

	// IPR0: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Msk = 0xff000000

	// IPR1: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Msk = 0xff000000

	// IPR2: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Msk = 0xff000000

	// IPR3: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Msk = 0xff000000

	// IPR4: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Msk = 0xff000000

	// IPR5: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Msk = 0xff000000

	// IPR6: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Msk = 0xff000000

	// IPR7: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Msk = 0xff000000

	// IPR8: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Msk = 0xff000000

	// IPR9: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Msk = 0xff000000

	// IPR10: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Msk = 0xff000000

	// IPR11: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Msk = 0xff000000

	// IPR12: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Msk = 0xff000000

	// IPR13: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Msk = 0xff000000

	// IPR14: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Msk = 0xff000000

	// IPR15: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Msk = 0xff000000

	// IPR16: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Msk = 0xff000000

	// IPR17: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Msk = 0xff000000
)

// Constants for PKA: Public key accelerator
const (
	// CR: control register
	// Position of ADDRERRIE field.
	PKA_CR_ADDRERRIE_Pos = 0x14
	// Bit mask of ADDRERRIE field.
	PKA_CR_ADDRERRIE_Msk = 0x100000
	// Bit ADDRERRIE.
	PKA_CR_ADDRERRIE = 0x100000
	// No interrupt is generated when ADDRERRF flag is set in PKA_SR
	PKA_CR_ADDRERRIE_Disabled = 0x0
	// An interrupt is generated when ADDRERRF flag is set in PKA_SR
	PKA_CR_ADDRERRIE_Enabled = 0x1
	// Position of RAMERRIE field.
	PKA_CR_RAMERRIE_Pos = 0x13
	// Bit mask of RAMERRIE field.
	PKA_CR_RAMERRIE_Msk = 0x80000
	// Bit RAMERRIE.
	PKA_CR_RAMERRIE = 0x80000
	// No interrupt is generated when RAMERRF flag is set in PKA_SR
	PKA_CR_RAMERRIE_Disabled = 0x0
	// An interrupt is generated when RAMERRF flag is set in PKA_SR
	PKA_CR_RAMERRIE_Enabled = 0x1
	// Position of PROCENDIE field.
	PKA_CR_PROCENDIE_Pos = 0x11
	// Bit mask of PROCENDIE field.
	PKA_CR_PROCENDIE_Msk = 0x20000
	// Bit PROCENDIE.
	PKA_CR_PROCENDIE = 0x20000
	// No interrupt is generated when PROCENDF flag is set in PKA_SR
	PKA_CR_PROCENDIE_Disabled = 0x0
	// An interrupt is generated when PROCENDF flag is set in PKA_SR
	PKA_CR_PROCENDIE_Enabled = 0x1
	// Position of MODE field.
	PKA_CR_MODE_Pos = 0x8
	// Bit mask of MODE field.
	PKA_CR_MODE_Msk = 0x3f00
	// Montgomery parameter computation then modular exponentiation
	PKA_CR_MODE_MontgomeryCompExp = 0x0
	// Montgomery parameter computation only
	PKA_CR_MODE_MontgomeryComp = 0x1
	// Modular exponentiation only (Montgomery parameter must be loaded first)
	PKA_CR_MODE_MontgomeryExp = 0x2
	// Montgomery parameter computation then ECC scalar multiplication
	PKA_CR_MODE_MontgomeryCompScalar = 0x20
	// ECC scalar multiplication only (Montgomery parameter must be loaded first)
	PKA_CR_MODE_MontgomeryScalar = 0x22
	// ECDSA sign
	PKA_CR_MODE_ECDSASign = 0x24
	// ECDSA verification
	PKA_CR_MODE_ECDSAVerif = 0x26
	// Point on elliptic curve Fp check
	PKA_CR_MODE_Elliptic = 0x28
	// RSA CRT exponentiation
	PKA_CR_MODE_RSA = 0x7
	// Modular inversion
	PKA_CR_MODE_ModularInv = 0x8
	// Arithmetic addition
	PKA_CR_MODE_ArithmeticAdd = 0x9
	// Arithmetic subtraction
	PKA_CR_MODE_ArithmeticSub = 0xa
	// Arithmetic multiplication
	PKA_CR_MODE_ArithmeticMul = 0xb
	// Arithmetic comparison
	PKA_CR_MODE_ArithmeticComp = 0xc
	// Modular reduction
	PKA_CR_MODE_ModularRed = 0xd
	// Modular addition
	PKA_CR_MODE_ModularAdd = 0xe
	// Modular subtraction
	PKA_CR_MODE_ModularSub = 0xf
	// Montgomery multiplication
	PKA_CR_MODE_ModularMul = 0x10
	// Position of START field.
	PKA_CR_START_Pos = 0x1
	// Bit mask of START field.
	PKA_CR_START_Msk = 0x2
	// Bit START.
	PKA_CR_START = 0x2
	// Writing 1 to this bit starts the operation which is selected by MODE[5:0], using the operands and data already written to the PKA RAM - This bit is always read as 0
	PKA_CR_START_Start = 0x1
	// Position of EN field.
	PKA_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	PKA_CR_EN_Msk = 0x1
	// Bit EN.
	PKA_CR_EN = 0x1
	// Disable PKA
	PKA_CR_EN_Disabled = 0x0
	// Enable PKA
	PKA_CR_EN_Enabled = 0x1

	// SR: status register
	// Position of ADDRERRF field.
	PKA_SR_ADDRERRF_Pos = 0x14
	// Bit mask of ADDRERRF field.
	PKA_SR_ADDRERRF_Msk = 0x100000
	// Bit ADDRERRF.
	PKA_SR_ADDRERRF = 0x100000
	// No error
	PKA_SR_ADDRERRF_NoError = 0x0
	// Address access is out of range (unmapped address)
	PKA_SR_ADDRERRF_Error = 0x1
	// Position of RAMERRF field.
	PKA_SR_RAMERRF_Pos = 0x13
	// Bit mask of RAMERRF field.
	PKA_SR_RAMERRF_Msk = 0x80000
	// Bit RAMERRF.
	PKA_SR_RAMERRF = 0x80000
	// No error
	PKA_SR_RAMERRF_NoError = 0x0
	// An AHB access to the PKA RAM occurred while the PKA core was computing and using its internal RAM (AHB PKA_RAM access are not allowed while PKA operation is in progress)
	PKA_SR_RAMERRF_Error = 0x1
	// Position of PROCENDF field.
	PKA_SR_PROCENDF_Pos = 0x11
	// Bit mask of PROCENDF field.
	PKA_SR_PROCENDF_Msk = 0x20000
	// Bit PROCENDF.
	PKA_SR_PROCENDF = 0x20000
	// Operation in progress
	PKA_SR_PROCENDF_InProgress = 0x0
	// PKA operation is completed - set when BUSY is deasserted
	PKA_SR_PROCENDF_Completed = 0x1
	// Position of BUSY field.
	PKA_SR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	PKA_SR_BUSY_Msk = 0x10000
	// Bit BUSY.
	PKA_SR_BUSY = 0x10000
	// No operation in pgoress
	PKA_SR_BUSY_Idle = 0x0
	// Operation in progress
	PKA_SR_BUSY_Busy = 0x1

	// CLRFR: clear flag register
	// Position of ADDRERRFC field.
	PKA_CLRFR_ADDRERRFC_Pos = 0x14
	// Bit mask of ADDRERRFC field.
	PKA_CLRFR_ADDRERRFC_Msk = 0x100000
	// Bit ADDRERRFC.
	PKA_CLRFR_ADDRERRFC = 0x100000
	// Clear ADDRERRF flag
	PKA_CLRFR_ADDRERRFC_Clear = 0x1
	// Position of RAMERRFC field.
	PKA_CLRFR_RAMERRFC_Pos = 0x13
	// Bit mask of RAMERRFC field.
	PKA_CLRFR_RAMERRFC_Msk = 0x80000
	// Bit RAMERRFC.
	PKA_CLRFR_RAMERRFC = 0x80000
	// Clear RAMERRF flag
	PKA_CLRFR_RAMERRFC_Clear = 0x1
	// Position of PROCENDFC field.
	PKA_CLRFR_PROCENDFC_Pos = 0x11
	// Bit mask of PROCENDFC field.
	PKA_CLRFR_PROCENDFC_Msk = 0x20000
	// Bit PROCENDFC.
	PKA_CLRFR_PROCENDFC = 0x20000
	// Clear PROCENDF flag
	PKA_CLRFR_PROCENDFC_Clear = 0x1
)

// Constants for PWR: Power control
const (
	// CR1: Power control register 1
	// Position of LPR field.
	PWR_CR1_LPR_Pos = 0xe
	// Bit mask of LPR field.
	PWR_CR1_LPR_Msk = 0x4000
	// Bit LPR.
	PWR_CR1_LPR = 0x4000
	// Voltage regulator in Main mode in Low-power run mode
	PWR_CR1_LPR_MainMode = 0x0
	// Voltage regulator in low-power mode in Low-power run mode
	PWR_CR1_LPR_LowPowerMode = 0x1
	// Position of VOS field.
	PWR_CR1_VOS_Pos = 0x9
	// Bit mask of VOS field.
	PWR_CR1_VOS_Msk = 0x600
	// 1.2 V (range 1)
	PWR_CR1_VOS_V1_2 = 0x1
	// 1.0 V (range 2)
	PWR_CR1_VOS_V1_0 = 0x2
	// Position of DBP field.
	PWR_CR1_DBP_Pos = 0x8
	// Bit mask of DBP field.
	PWR_CR1_DBP_Msk = 0x100
	// Bit DBP.
	PWR_CR1_DBP = 0x100
	// Access to RTC and backup registers disabled
	PWR_CR1_DBP_Disabled = 0x0
	// Access to RTC and backup registers enabled
	PWR_CR1_DBP_Enabled = 0x1
	// Position of FPDS field.
	PWR_CR1_FPDS_Pos = 0x5
	// Bit mask of FPDS field.
	PWR_CR1_FPDS_Msk = 0x20
	// Bit FPDS.
	PWR_CR1_FPDS = 0x20
	// Flash memory in Idle mode when system is in LPSleep mode
	PWR_CR1_FPDS_Idle = 0x0
	// Flash memory in Power-down mode when system is in LPSleep mode
	PWR_CR1_FPDS_PowerDown = 0x1
	// Position of FPDR field.
	PWR_CR1_FPDR_Pos = 0x4
	// Bit mask of FPDR field.
	PWR_CR1_FPDR_Msk = 0x10
	// Bit FPDR.
	PWR_CR1_FPDR = 0x10
	// Flash memory in Idle mode when system is in LPRun mode
	PWR_CR1_FPDR_Idle = 0x0
	// Flash memory in Power-down mode when system is in LPRun mode
	PWR_CR1_FPDR_PowerDown = 0x1
	// Position of SUBGHZSPINSSSEL field.
	PWR_CR1_SUBGHZSPINSSSEL_Pos = 0x3
	// Bit mask of SUBGHZSPINSSSEL field.
	PWR_CR1_SUBGHZSPINSSSEL_Msk = 0x8
	// Bit SUBGHZSPINSSSEL.
	PWR_CR1_SUBGHZSPINSSSEL = 0x8
	// sub-GHz SPI NSS signal driven from PWR_SUBGHZSPICR.NSS (RFBUSYMS functionality enabled)
	PWR_CR1_SUBGHZSPINSSSEL_SUBGHZSPICR = 0x0
	// sub-GHz SPI NSS signal driven from LPTIM3_OUT (RFBUSYMS functionality disabled)
	PWR_CR1_SUBGHZSPINSSSEL_LPTIM3 = 0x1
	// Position of LPMS field.
	PWR_CR1_LPMS_Pos = 0x0
	// Bit mask of LPMS field.
	PWR_CR1_LPMS_Msk = 0x7
	// Stop 0 mode
	PWR_CR1_LPMS_Stop0 = 0x0
	// Stop 1 mode
	PWR_CR1_LPMS_Stop1 = 0x1
	// Stop 2 mode
	PWR_CR1_LPMS_Stop2 = 0x2
	// Standby mode
	PWR_CR1_LPMS_Standby = 0x3
	// Shutdown mode
	PWR_CR1_LPMS_Shutdown = 0x4

	// CR2: Power control register 2
	// Position of PVME3 field.
	PWR_CR2_PVME3_Pos = 0x6
	// Bit mask of PVME3 field.
	PWR_CR2_PVME3_Msk = 0x40
	// Bit PVME3.
	PWR_CR2_PVME3 = 0x40
	// PVM3 (VDDA monitoring versus 1.62 V threshold) disable
	PWR_CR2_PVME3_Disabled = 0x0
	// PVM3 (VDDA monitoring versus 1.62 V threshold) enable
	PWR_CR2_PVME3_Enabled = 0x1
	// Position of PLS field.
	PWR_CR2_PLS_Pos = 0x1
	// Bit mask of PLS field.
	PWR_CR2_PLS_Msk = 0xe
	// 2.0V
	PWR_CR2_PLS_V2_0 = 0x0
	// 2.2V
	PWR_CR2_PLS_V2_2 = 0x1
	// 2.4V
	PWR_CR2_PLS_V2_4 = 0x2
	// 2.5V
	PWR_CR2_PLS_V2_5 = 0x3
	// 2.6V
	PWR_CR2_PLS_V2_6 = 0x4
	// 2.8V
	PWR_CR2_PLS_V2_8 = 0x5
	// 2.9V
	PWR_CR2_PLS_V2_9 = 0x6
	// External input analog voltage PVD_IN (compared internally to VREFINT)
	PWR_CR2_PLS_External = 0x7
	// Position of PVDE field.
	PWR_CR2_PVDE_Pos = 0x0
	// Bit mask of PVDE field.
	PWR_CR2_PVDE_Msk = 0x1
	// Bit PVDE.
	PWR_CR2_PVDE = 0x1
	// PVD Disabled
	PWR_CR2_PVDE_Disabled = 0x0
	// PVD Enabled
	PWR_CR2_PVDE_Enabled = 0x1

	// CR3: Power control register 3
	// Position of EIWUL field.
	PWR_CR3_EIWUL_Pos = 0xf
	// Bit mask of EIWUL field.
	PWR_CR3_EIWUL_Msk = 0x8000
	// Bit EIWUL.
	PWR_CR3_EIWUL = 0x8000
	// Internal wakeup line interrupt to CPU1 disabled
	PWR_CR3_EIWUL_Disabled = 0x0
	// Internal wakeup line interrupt to CPU1 enabled
	PWR_CR3_EIWUL_Enabled = 0x1
	// Position of EWRFIRQ field.
	PWR_CR3_EWRFIRQ_Pos = 0xd
	// Bit mask of EWRFIRQ field.
	PWR_CR3_EWRFIRQ_Msk = 0x2000
	// Bit EWRFIRQ.
	PWR_CR3_EWRFIRQ = 0x2000
	// Radio IRQ[2:0] is disabled and does not trigger a wakeup from Standby event to CPU1.
	PWR_CR3_EWRFIRQ_Disabled = 0x0
	// Radio IRQ[2:0] is enabled and triggers a wakeup from Standby event to CPU1.
	PWR_CR3_EWRFIRQ_Enabled = 0x1
	// Position of EWRFBUSY field.
	PWR_CR3_EWRFBUSY_Pos = 0xb
	// Bit mask of EWRFBUSY field.
	PWR_CR3_EWRFBUSY_Msk = 0x800
	// Bit EWRFBUSY.
	PWR_CR3_EWRFBUSY = 0x800
	// Radio Busy is disabled and does not trigger a wakeup from Standby event to CPU1 when a rising or a falling edge occurs
	PWR_CR3_EWRFBUSY_Disabled = 0x0
	// Radio Busy is enabled and triggers a wakeup from Standby event to CPU1 when a rising or a falling edge occurs. The active edge is configured via the WRFBUSYP bit in PWR_CR4
	PWR_CR3_EWRFBUSY_Enabled = 0x1
	// Position of APC field.
	PWR_CR3_APC_Pos = 0xa
	// Bit mask of APC field.
	PWR_CR3_APC_Msk = 0x400
	// Bit APC.
	PWR_CR3_APC = 0x400
	// I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied
	PWR_CR3_APC_Disabled = 0x0
	// PWR_PUCRx and PWR_PDCRx registers are NOT applied to the I/Os
	PWR_CR3_APC_Enabled = 0x1
	// Position of RRS field.
	PWR_CR3_RRS_Pos = 0x9
	// Bit mask of RRS field.
	PWR_CR3_RRS_Msk = 0x200
	// Bit RRS.
	PWR_CR3_RRS = 0x200
	// SRAM2 powered off in Standby mode (SRAM2 content lost)
	PWR_CR3_RRS_PowerOff = 0x0
	// SRAM2 powered by the low-power regulator in Standby mode (SRAM2 content kept)
	PWR_CR3_RRS_OnLPR = 0x1
	// Position of EWPVD field.
	PWR_CR3_EWPVD_Pos = 0x8
	// Bit mask of EWPVD field.
	PWR_CR3_EWPVD_Msk = 0x100
	// Bit EWPVD.
	PWR_CR3_EWPVD = 0x100
	// PVD not enabled by the sub-GHz radio active state
	PWR_CR3_EWPVD_Disabled = 0x0
	// PVD enabled while the sub-GHz radio is active
	PWR_CR3_EWPVD_Enabled = 0x1
	// Position of EULPEN field.
	PWR_CR3_EULPEN_Pos = 0x7
	// Bit mask of EULPEN field.
	PWR_CR3_EULPEN_Msk = 0x80
	// Bit EULPEN.
	PWR_CR3_EULPEN = 0x80
	// Disable (the supply voltage is monitored continuously)
	PWR_CR3_EULPEN_Disabled = 0x0
	// Enable, when set, the supply voltage is sampled for PDR/BOR reset condition only periodically
	PWR_CR3_EULPEN_Enabled = 0x1
	// Position of EWUP3 field.
	PWR_CR3_EWUP3_Pos = 0x2
	// Bit mask of EWUP3 field.
	PWR_CR3_EWUP3_Msk = 0x4
	// Bit EWUP3.
	PWR_CR3_EWUP3 = 0x4
	// WKUP pin 3 is used for general purpose I/Os. An event on the WKUP pin 3 does not wakeup the device from Standby mode
	PWR_CR3_EWUP3_Disabled = 0x0
	// WKUP pin 3 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 3wakes-up the system from Standby mode)
	PWR_CR3_EWUP3_Enabled = 0x1
	// Position of EWUP2 field.
	PWR_CR3_EWUP2_Pos = 0x1
	// Bit mask of EWUP2 field.
	PWR_CR3_EWUP2_Msk = 0x2
	// Bit EWUP2.
	PWR_CR3_EWUP2 = 0x2
	// WKUP pin 2 is used for general purpose I/Os. An event on the WKUP pin 2 does not wakeup the device from Standby mode
	PWR_CR3_EWUP2_Disabled = 0x0
	// WKUP pin 2 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 2 wakes-up the system from Standby mode)
	PWR_CR3_EWUP2_Enabled = 0x1
	// Position of EWUP1 field.
	PWR_CR3_EWUP1_Pos = 0x0
	// Bit mask of EWUP1 field.
	PWR_CR3_EWUP1_Msk = 0x1
	// Bit EWUP1.
	PWR_CR3_EWUP1 = 0x1
	// WKUP pin 1 is used for general purpose I/Os. An event on the WKUP pin 1 does not wakeup the device from Standby mode
	PWR_CR3_EWUP1_Disabled = 0x0
	// WKUP pin 1 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 1 wakes-up the system from Standby mode)
	PWR_CR3_EWUP1_Enabled = 0x1

	// CR4: Power control register 4
	// Position of WRFBUSYP field.
	PWR_CR4_WRFBUSYP_Pos = 0xb
	// Bit mask of WRFBUSYP field.
	PWR_CR4_WRFBUSYP_Msk = 0x800
	// Bit WRFBUSYP.
	PWR_CR4_WRFBUSYP = 0x800
	// Detection on high level (rising edge)
	PWR_CR4_WRFBUSYP_RisingEdge = 0x0
	// Detection on low level (falling edge)
	PWR_CR4_WRFBUSYP_FallingEdge = 0x1
	// Position of VBRS field.
	PWR_CR4_VBRS_Pos = 0x9
	// Bit mask of VBRS field.
	PWR_CR4_VBRS_Msk = 0x200
	// Bit VBRS.
	PWR_CR4_VBRS = 0x200
	// VBAT charging through a 5 k resistor
	PWR_CR4_VBRS_R5k = 0x0
	// VBAT charging through a 1.5 k resistor
	PWR_CR4_VBRS_R1_5k = 0x1
	// Position of VBE field.
	PWR_CR4_VBE_Pos = 0x8
	// Bit mask of VBE field.
	PWR_CR4_VBE_Msk = 0x100
	// Bit VBE.
	PWR_CR4_VBE = 0x100
	// VBAT battery charging disabled
	PWR_CR4_VBE_Disabled = 0x0
	// VBAT battery charging enabled
	PWR_CR4_VBE_Enabled = 0x1
	// Position of WP3 field.
	PWR_CR4_WP3_Pos = 0x2
	// Bit mask of WP3 field.
	PWR_CR4_WP3_Msk = 0x4
	// Bit WP3.
	PWR_CR4_WP3 = 0x4
	// Detection on high level (rising edge)
	PWR_CR4_WP3_RisingEdge = 0x0
	// Detection on low level (falling edge)
	PWR_CR4_WP3_FallingEdge = 0x1
	// Position of WP2 field.
	PWR_CR4_WP2_Pos = 0x1
	// Bit mask of WP2 field.
	PWR_CR4_WP2_Msk = 0x2
	// Bit WP2.
	PWR_CR4_WP2 = 0x2
	// Detection on high level (rising edge)
	PWR_CR4_WP2_RisingEdge = 0x0
	// Detection on low level (falling edge)
	PWR_CR4_WP2_FallingEdge = 0x1
	// Position of WP1 field.
	PWR_CR4_WP1_Pos = 0x0
	// Bit mask of WP1 field.
	PWR_CR4_WP1_Msk = 0x1
	// Bit WP1.
	PWR_CR4_WP1 = 0x1
	// Detection on high level (rising edge)
	PWR_CR4_WP1_RisingEdge = 0x0
	// Detection on low level (falling edge)
	PWR_CR4_WP1_FallingEdge = 0x1

	// SR1: Power status register 1
	// Position of WUFI field.
	PWR_SR1_WUFI_Pos = 0xf
	// Bit mask of WUFI field.
	PWR_SR1_WUFI_Msk = 0x8000
	// Bit WUFI.
	PWR_SR1_WUFI = 0x8000
	// All internal wakeup sources are cleared
	PWR_SR1_WUFI_Clear = 0x0
	// wakeup is detected on the internal wakeup line
	PWR_SR1_WUFI_Wakeup = 0x1
	// Position of WRFBUSYF field.
	PWR_SR1_WRFBUSYF_Pos = 0xb
	// Bit mask of WRFBUSYF field.
	PWR_SR1_WRFBUSYF_Msk = 0x800
	// Bit WRFBUSYF.
	PWR_SR1_WRFBUSYF = 0x800
	// No wakeup event detected on radio busy
	PWR_SR1_WRFBUSYF_Clear = 0x0
	// Wakeup event detected on radio busy
	PWR_SR1_WRFBUSYF_Wakeup = 0x1
	// Position of WPVDF field.
	PWR_SR1_WPVDF_Pos = 0x8
	// Bit mask of WPVDF field.
	PWR_SR1_WPVDF_Msk = 0x100
	// Bit WPVDF.
	PWR_SR1_WPVDF = 0x100
	// No wakeup event detected on PVD
	PWR_SR1_WPVDF_Clear = 0x0
	// Wakeup event detected on PVD
	PWR_SR1_WPVDF_Wakeup = 0x1
	// Position of WUF3 field.
	PWR_SR1_WUF3_Pos = 0x2
	// Bit mask of WUF3 field.
	PWR_SR1_WUF3_Msk = 0x4
	// Bit WUF3.
	PWR_SR1_WUF3 = 0x4
	// No wakeup event detected on WKUP3
	PWR_SR1_WUF3_Clear = 0x0
	// Wakeup event detected on WKUP3
	PWR_SR1_WUF3_Wakeup = 0x1
	// Position of WUF2 field.
	PWR_SR1_WUF2_Pos = 0x1
	// Bit mask of WUF2 field.
	PWR_SR1_WUF2_Msk = 0x2
	// Bit WUF2.
	PWR_SR1_WUF2 = 0x2
	// No wakeup event detected on WKUP2
	PWR_SR1_WUF2_Clear = 0x0
	// Wakeup event detected on WKUP2
	PWR_SR1_WUF2_Wakeup = 0x1
	// Position of WUF1 field.
	PWR_SR1_WUF1_Pos = 0x0
	// Bit mask of WUF1 field.
	PWR_SR1_WUF1_Msk = 0x1
	// Bit WUF1.
	PWR_SR1_WUF1 = 0x1
	// No wakeup event detected on WKUP1
	PWR_SR1_WUF1_Clear = 0x0
	// Wakeup event detected on WKUP1
	PWR_SR1_WUF1_Wakeup = 0x1

	// SR2: Power status register 2
	// Position of PVMO3 field.
	PWR_SR2_PVMO3_Pos = 0xe
	// Bit mask of PVMO3 field.
	PWR_SR2_PVMO3_Msk = 0x4000
	// Bit PVMO3.
	PWR_SR2_PVMO3 = 0x4000
	// VDDA voltage above PVM3 threshold (around 1.62 V)
	PWR_SR2_PVMO3_Above = 0x0
	// VDDA voltage below PVM3 threshold (around 1.62 V)
	PWR_SR2_PVMO3_Below = 0x1
	// Position of PVDO field.
	PWR_SR2_PVDO_Pos = 0xb
	// Bit mask of PVDO field.
	PWR_SR2_PVDO_Msk = 0x800
	// Bit PVDO.
	PWR_SR2_PVDO = 0x800
	// VDD or voltage level on PVD_IN above the selected PVD threshold
	PWR_SR2_PVDO_Above = 0x0
	// VDD or voltage level on PVD_IN below the selected PVD threshold
	PWR_SR2_PVDO_Below = 0x1
	// Position of VOSF field.
	PWR_SR2_VOSF_Pos = 0xa
	// Bit mask of VOSF field.
	PWR_SR2_VOSF_Msk = 0x400
	// Bit VOSF.
	PWR_SR2_VOSF = 0x400
	// Regulator ready in the selected voltage range
	PWR_SR2_VOSF_Ready = 0x0
	// Regulator output voltage changed to the required voltage level
	PWR_SR2_VOSF_Change = 0x1
	// Position of REGLPF field.
	PWR_SR2_REGLPF_Pos = 0x9
	// Bit mask of REGLPF field.
	PWR_SR2_REGLPF_Msk = 0x200
	// Bit REGLPF.
	PWR_SR2_REGLPF = 0x200
	// Main regulator (MR) ready and used
	PWR_SR2_REGLPF_Main = 0x0
	// Low-power regulator (LPR) used
	PWR_SR2_REGLPF_LowPower = 0x1
	// Position of REGLPS field.
	PWR_SR2_REGLPS_Pos = 0x8
	// Bit mask of REGLPS field.
	PWR_SR2_REGLPS_Msk = 0x100
	// Bit REGLPS.
	PWR_SR2_REGLPS = 0x100
	// LPR not ready
	PWR_SR2_REGLPS_NotReady = 0x0
	// LPR ready
	PWR_SR2_REGLPS_Ready = 0x1
	// Position of FLASHRDY field.
	PWR_SR2_FLASHRDY_Pos = 0x7
	// Bit mask of FLASHRDY field.
	PWR_SR2_FLASHRDY_Msk = 0x80
	// Bit FLASHRDY.
	PWR_SR2_FLASHRDY = 0x80
	// Flash memory not ready to be accessed
	PWR_SR2_FLASHRDY_NotReady = 0x0
	// Flash memory ready to be accessed
	PWR_SR2_FLASHRDY_Ready = 0x1
	// Position of REGMRS field.
	PWR_SR2_REGMRS_Pos = 0x6
	// Bit mask of REGMRS field.
	PWR_SR2_REGMRS_Msk = 0x40
	// Bit REGMRS.
	PWR_SR2_REGMRS = 0x40
	// Main regulator supplied directly from VDD
	PWR_SR2_REGMRS_V_DD = 0x0
	// Main regulator supplied through LDO or SMPS
	PWR_SR2_REGMRS_LDO_SMPS = 0x1
	// Position of RFEOLF field.
	PWR_SR2_RFEOLF_Pos = 0x5
	// Bit mask of RFEOLF field.
	PWR_SR2_RFEOLF_Msk = 0x20
	// Bit RFEOLF.
	PWR_SR2_RFEOLF = 0x20
	// Supply voltage above radio end-of-life operating low level
	PWR_SR2_RFEOLF_Above = 0x0
	// Supply voltage below radio end-of-life operating low level
	PWR_SR2_RFEOLF_Below = 0x1
	// Position of LDORDY field.
	PWR_SR2_LDORDY_Pos = 0x4
	// Bit mask of LDORDY field.
	PWR_SR2_LDORDY_Msk = 0x10
	// Bit LDORDY.
	PWR_SR2_LDORDY = 0x10
	// LDO not ready or off
	PWR_SR2_LDORDY_NotReady = 0x0
	// LDO ready
	PWR_SR2_LDORDY_Ready = 0x1
	// Position of SMPSRDY field.
	PWR_SR2_SMPSRDY_Pos = 0x3
	// Bit mask of SMPSRDY field.
	PWR_SR2_SMPSRDY_Msk = 0x8
	// Bit SMPSRDY.
	PWR_SR2_SMPSRDY = 0x8
	// SMPS step-down converter not ready or off
	PWR_SR2_SMPSRDY_NotReady = 0x0
	// SMPS step-down converter ready
	PWR_SR2_SMPSRDY_Ready = 0x1
	// Position of RFBUSYMS field.
	PWR_SR2_RFBUSYMS_Pos = 0x2
	// Bit mask of RFBUSYMS field.
	PWR_SR2_RFBUSYMS_Msk = 0x4
	// Bit RFBUSYMS.
	PWR_SR2_RFBUSYMS = 0x4
	// radio busy masked signal low (not busy)
	PWR_SR2_RFBUSYMS_NotBusy = 0x0
	// radio busy masked signal high (busy)
	PWR_SR2_RFBUSYMS_Busy = 0x1
	// Position of RFBUSYS field.
	PWR_SR2_RFBUSYS_Pos = 0x1
	// Bit mask of RFBUSYS field.
	PWR_SR2_RFBUSYS_Msk = 0x2
	// Bit RFBUSYS.
	PWR_SR2_RFBUSYS = 0x2
	// radio busy signal low (not busy)
	PWR_SR2_RFBUSYS_NotBusy = 0x0
	// radio busy signal high (busy)
	PWR_SR2_RFBUSYS_Busy = 0x1

	// SCR: Power status clear register
	// Position of CWRFBUSYF field.
	PWR_SCR_CWRFBUSYF_Pos = 0xb
	// Bit mask of CWRFBUSYF field.
	PWR_SCR_CWRFBUSYF_Msk = 0x800
	// Bit CWRFBUSYF.
	PWR_SCR_CWRFBUSYF = 0x800
	// Setting this bit clears the WRFBUSYF flag in the PWR_SR1. This bit is always read 0.
	PWR_SCR_CWRFBUSYF_Clear = 0x1
	// Position of CWPVDF field.
	PWR_SCR_CWPVDF_Pos = 0x8
	// Bit mask of CWPVDF field.
	PWR_SCR_CWPVDF_Msk = 0x100
	// Bit CWPVDF.
	PWR_SCR_CWPVDF = 0x100
	// Setting this bit clears the WPVDF flag in the PWR_SR1. This bit is always read as 0.
	PWR_SCR_CWPVDF_Clear = 0x1
	// Position of CWUF3 field.
	PWR_SCR_CWUF3_Pos = 0x2
	// Bit mask of CWUF3 field.
	PWR_SCR_CWUF3_Msk = 0x4
	// Bit CWUF3.
	PWR_SCR_CWUF3 = 0x4
	// Setting this bit clears the WUF3 flag in the PWR_SR1 register. This bit is always read as 0.
	PWR_SCR_CWUF3_Clear = 0x1
	// Position of CWUF2 field.
	PWR_SCR_CWUF2_Pos = 0x1
	// Bit mask of CWUF2 field.
	PWR_SCR_CWUF2_Msk = 0x2
	// Bit CWUF2.
	PWR_SCR_CWUF2 = 0x2
	// Setting this bit clears the WUF2 flag in the PWR_SR1 register. This bit is always read as 0.
	PWR_SCR_CWUF2_Clear = 0x1
	// Position of CWUF1 field.
	PWR_SCR_CWUF1_Pos = 0x0
	// Bit mask of CWUF1 field.
	PWR_SCR_CWUF1_Msk = 0x1
	// Bit CWUF1.
	PWR_SCR_CWUF1 = 0x1
	// Setting this bit clears the WUF1 flag in the PWR_SR1 register. This bit is always read as 0.
	PWR_SCR_CWUF1_Clear = 0x1

	// CR5: Power control register 5
	// Position of SMPSEN field.
	PWR_CR5_SMPSEN_Pos = 0xf
	// Bit mask of SMPSEN field.
	PWR_CR5_SMPSEN_Msk = 0x8000
	// Bit SMPSEN.
	PWR_CR5_SMPSEN = 0x8000
	// SMPS step-down converter SMPS mode disabled (LDO mode enabled)
	PWR_CR5_SMPSEN_Disabled = 0x0
	// SMPS step-down converter SMPS mode enabled
	PWR_CR5_SMPSEN_Enabled = 0x1
	// Position of RFEOLEN field.
	PWR_CR5_RFEOLEN_Pos = 0xe
	// Bit mask of RFEOLEN field.
	PWR_CR5_RFEOLEN_Msk = 0x4000
	// Bit RFEOLEN.
	PWR_CR5_RFEOLEN = 0x4000
	// Radio end-of-life detector disabled
	PWR_CR5_RFEOLEN_Disabled = 0x0
	// Radio end-of-life detector enabled
	PWR_CR5_RFEOLEN_Enabled = 0x1

	// PUCRA: Power Port A pull-up control register
	// Position of PU15 field.
	PWR_PUCRA_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRA_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRA_PU15 = 0x8000
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU15_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU15_Enabled = 0x1
	// Position of PU14 field.
	PWR_PUCRA_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRA_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRA_PU14 = 0x4000
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU14_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU14_Enabled = 0x1
	// Position of PU13 field.
	PWR_PUCRA_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRA_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRA_PU13 = 0x2000
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU13_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU13_Enabled = 0x1
	// Position of PU12 field.
	PWR_PUCRA_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRA_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRA_PU12 = 0x1000
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU12_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU12_Enabled = 0x1
	// Position of PU11 field.
	PWR_PUCRA_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRA_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRA_PU11 = 0x800
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU11_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU11_Enabled = 0x1
	// Position of PU10 field.
	PWR_PUCRA_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRA_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRA_PU10 = 0x400
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU10_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU10_Enabled = 0x1
	// Position of PU9 field.
	PWR_PUCRA_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRA_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRA_PU9 = 0x200
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU9_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU9_Enabled = 0x1
	// Position of PU8 field.
	PWR_PUCRA_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRA_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRA_PU8 = 0x100
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU8_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU8_Enabled = 0x1
	// Position of PU7 field.
	PWR_PUCRA_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRA_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRA_PU7 = 0x80
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU7_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU7_Enabled = 0x1
	// Position of PU6 field.
	PWR_PUCRA_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRA_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRA_PU6 = 0x40
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU6_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU6_Enabled = 0x1
	// Position of PU5 field.
	PWR_PUCRA_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRA_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRA_PU5 = 0x20
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU5_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU5_Enabled = 0x1
	// Position of PU4 field.
	PWR_PUCRA_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRA_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRA_PU4 = 0x10
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU4_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU4_Enabled = 0x1
	// Position of PU3 field.
	PWR_PUCRA_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRA_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRA_PU3 = 0x8
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU3_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU3_Enabled = 0x1
	// Position of PU2 field.
	PWR_PUCRA_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRA_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRA_PU2 = 0x4
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU2_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU2_Enabled = 0x1
	// Position of PU1 field.
	PWR_PUCRA_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRA_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRA_PU1 = 0x2
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU1_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU1_Enabled = 0x1
	// Position of PU0 field.
	PWR_PUCRA_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRA_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRA_PU0 = 0x1
	// Disable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRA_PU0_Disabled = 0x0
	// Enable pull-up on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PA[y] bit is also set
	PWR_PUCRA_PU0_Enabled = 0x1

	// PDCRA: Power Port A pull-down control register
	// Position of PD15 field.
	PWR_PDCRA_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRA_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRA_PD15 = 0x8000
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD15_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD15_Enabled = 0x1
	// Position of PD14 field.
	PWR_PDCRA_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRA_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRA_PD14 = 0x4000
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD14_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD14_Enabled = 0x1
	// Position of PD13 field.
	PWR_PDCRA_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRA_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRA_PD13 = 0x2000
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD13_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD13_Enabled = 0x1
	// Position of PD12 field.
	PWR_PDCRA_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRA_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRA_PD12 = 0x1000
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD12_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD12_Enabled = 0x1
	// Position of PD11 field.
	PWR_PDCRA_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRA_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRA_PD11 = 0x800
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD11_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD11_Enabled = 0x1
	// Position of PD10 field.
	PWR_PDCRA_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRA_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRA_PD10 = 0x400
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD10_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD10_Enabled = 0x1
	// Position of PD9 field.
	PWR_PDCRA_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRA_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRA_PD9 = 0x200
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD9_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD9_Enabled = 0x1
	// Position of PD8 field.
	PWR_PDCRA_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRA_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRA_PD8 = 0x100
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD8_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD8_Enabled = 0x1
	// Position of PD7 field.
	PWR_PDCRA_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRA_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRA_PD7 = 0x80
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD7_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD7_Enabled = 0x1
	// Position of PD6 field.
	PWR_PDCRA_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRA_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRA_PD6 = 0x40
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD6_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD6_Enabled = 0x1
	// Position of PD5 field.
	PWR_PDCRA_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRA_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRA_PD5 = 0x20
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD5_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD5_Enabled = 0x1
	// Position of PD4 field.
	PWR_PDCRA_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRA_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRA_PD4 = 0x10
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD4_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD4_Enabled = 0x1
	// Position of PD3 field.
	PWR_PDCRA_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRA_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRA_PD3 = 0x8
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD3_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD3_Enabled = 0x1
	// Position of PD2 field.
	PWR_PDCRA_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRA_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRA_PD2 = 0x4
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD2_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD2_Enabled = 0x1
	// Position of PD1 field.
	PWR_PDCRA_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRA_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRA_PD1 = 0x2
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD1_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD1_Enabled = 0x1
	// Position of PD0 field.
	PWR_PDCRA_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRA_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRA_PD0 = 0x1
	// Disable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD0_Disabled = 0x0
	// Enable the pull-down on PA[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRA_PD0_Enabled = 0x1

	// PUCRB: Power Port B pull-up control register
	// Position of PU15 field.
	PWR_PUCRB_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRB_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRB_PU15 = 0x8000
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU15_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU15_Enabled = 0x1
	// Position of PU14 field.
	PWR_PUCRB_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRB_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRB_PU14 = 0x4000
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU14_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU14_Enabled = 0x1
	// Position of PU13 field.
	PWR_PUCRB_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRB_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRB_PU13 = 0x2000
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU13_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU13_Enabled = 0x1
	// Position of PU12 field.
	PWR_PUCRB_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRB_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRB_PU12 = 0x1000
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU12_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU12_Enabled = 0x1
	// Position of PU11 field.
	PWR_PUCRB_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRB_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRB_PU11 = 0x800
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU11_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU11_Enabled = 0x1
	// Position of PU10 field.
	PWR_PUCRB_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRB_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRB_PU10 = 0x400
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU10_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU10_Enabled = 0x1
	// Position of PU9 field.
	PWR_PUCRB_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRB_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRB_PU9 = 0x200
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU9_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU9_Enabled = 0x1
	// Position of PU8 field.
	PWR_PUCRB_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRB_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRB_PU8 = 0x100
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU8_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU8_Enabled = 0x1
	// Position of PU7 field.
	PWR_PUCRB_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRB_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRB_PU7 = 0x80
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU7_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU7_Enabled = 0x1
	// Position of PU6 field.
	PWR_PUCRB_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRB_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRB_PU6 = 0x40
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU6_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU6_Enabled = 0x1
	// Position of PU5 field.
	PWR_PUCRB_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRB_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRB_PU5 = 0x20
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU5_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU5_Enabled = 0x1
	// Position of PU4 field.
	PWR_PUCRB_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRB_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRB_PU4 = 0x10
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU4_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU4_Enabled = 0x1
	// Position of PU3 field.
	PWR_PUCRB_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRB_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRB_PU3 = 0x8
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU3_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU3_Enabled = 0x1
	// Position of PU2 field.
	PWR_PUCRB_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRB_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRB_PU2 = 0x4
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU2_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU2_Enabled = 0x1
	// Position of PU1 field.
	PWR_PUCRB_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRB_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRB_PU1 = 0x2
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU1_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU1_Enabled = 0x1
	// Position of PU0 field.
	PWR_PUCRB_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRB_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRB_PU0 = 0x1
	// Disable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRB_PU0_Disabled = 0x0
	// Enable pull-up on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PB[y] bit is also set
	PWR_PUCRB_PU0_Enabled = 0x1

	// PDCRB: Power Port B pull-down control register
	// Position of PD15 field.
	PWR_PDCRB_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRB_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRB_PD15 = 0x8000
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD15_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD15_Enabled = 0x1
	// Position of PD14 field.
	PWR_PDCRB_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRB_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRB_PD14 = 0x4000
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD14_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD14_Enabled = 0x1
	// Position of PD13 field.
	PWR_PDCRB_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRB_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRB_PD13 = 0x2000
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD13_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD13_Enabled = 0x1
	// Position of PD12 field.
	PWR_PDCRB_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRB_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRB_PD12 = 0x1000
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD12_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD12_Enabled = 0x1
	// Position of PD11 field.
	PWR_PDCRB_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRB_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRB_PD11 = 0x800
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD11_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD11_Enabled = 0x1
	// Position of PD10 field.
	PWR_PDCRB_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRB_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRB_PD10 = 0x400
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD10_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD10_Enabled = 0x1
	// Position of PD9 field.
	PWR_PDCRB_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRB_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRB_PD9 = 0x200
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD9_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD9_Enabled = 0x1
	// Position of PD8 field.
	PWR_PDCRB_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRB_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRB_PD8 = 0x100
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD8_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD8_Enabled = 0x1
	// Position of PD7 field.
	PWR_PDCRB_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRB_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRB_PD7 = 0x80
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD7_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD7_Enabled = 0x1
	// Position of PD6 field.
	PWR_PDCRB_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRB_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRB_PD6 = 0x40
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD6_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD6_Enabled = 0x1
	// Position of PD5 field.
	PWR_PDCRB_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRB_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRB_PD5 = 0x20
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD5_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD5_Enabled = 0x1
	// Position of PD4 field.
	PWR_PDCRB_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRB_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRB_PD4 = 0x10
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD4_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD4_Enabled = 0x1
	// Position of PD3 field.
	PWR_PDCRB_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRB_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRB_PD3 = 0x8
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD3_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD3_Enabled = 0x1
	// Position of PD2 field.
	PWR_PDCRB_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRB_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRB_PD2 = 0x4
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD2_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD2_Enabled = 0x1
	// Position of PD1 field.
	PWR_PDCRB_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRB_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRB_PD1 = 0x2
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD1_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD1_Enabled = 0x1
	// Position of PD0 field.
	PWR_PDCRB_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRB_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRB_PD0 = 0x1
	// Disable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD0_Disabled = 0x0
	// Enable the pull-down on PB[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRB_PD0_Enabled = 0x1

	// PUCRC: Power Port C pull-up control register
	// Position of PU15 field.
	PWR_PUCRC_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRC_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRC_PU15 = 0x8000
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU15_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU15_Enabled = 0x1
	// Position of PU14 field.
	PWR_PUCRC_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRC_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRC_PU14 = 0x4000
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU14_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU14_Enabled = 0x1
	// Position of PU13 field.
	PWR_PUCRC_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRC_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRC_PU13 = 0x2000
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU13_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU13_Enabled = 0x1
	// Position of PU2 field.
	PWR_PUCRC_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRC_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRC_PU2 = 0x4
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU2_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU2_Enabled = 0x1
	// Position of PU1 field.
	PWR_PUCRC_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRC_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRC_PU1 = 0x2
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU1_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU1_Enabled = 0x1
	// Position of PU0 field.
	PWR_PUCRC_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRC_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRC_PU0 = 0x1
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU0_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU0_Enabled = 0x1
	// Position of PU3 field.
	PWR_PUCRC_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRC_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRC_PU3 = 0x8
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU3_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU3_Enabled = 0x1
	// Position of PU4 field.
	PWR_PUCRC_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRC_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRC_PU4 = 0x10
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU4_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU4_Enabled = 0x1
	// Position of PU5 field.
	PWR_PUCRC_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRC_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRC_PU5 = 0x20
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU5_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU5_Enabled = 0x1
	// Position of PU6 field.
	PWR_PUCRC_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRC_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRC_PU6 = 0x40
	// Disable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRC_PU6_Disabled = 0x0
	// Enable pull-up on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PC[y] bit is also set
	PWR_PUCRC_PU6_Enabled = 0x1

	// PDCRC: Power Port C pull-down control register
	// Position of PD15 field.
	PWR_PDCRC_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRC_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRC_PD15 = 0x8000
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD15_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD15_Enabled = 0x1
	// Position of PD14 field.
	PWR_PDCRC_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRC_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRC_PD14 = 0x4000
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD14_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD14_Enabled = 0x1
	// Position of PD13 field.
	PWR_PDCRC_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRC_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRC_PD13 = 0x2000
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD13_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD13_Enabled = 0x1
	// Position of PD2 field.
	PWR_PDCRC_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRC_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRC_PD2 = 0x4
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD2_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD2_Enabled = 0x1
	// Position of PD1 field.
	PWR_PDCRC_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRC_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRC_PD1 = 0x2
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD1_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD1_Enabled = 0x1
	// Position of PD0 field.
	PWR_PDCRC_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRC_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRC_PD0 = 0x1
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD0_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD0_Enabled = 0x1
	// Position of PD3 field.
	PWR_PDCRC_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRC_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRC_PD3 = 0x8
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD3_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD3_Enabled = 0x1
	// Position of PD4 field.
	PWR_PDCRC_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRC_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRC_PD4 = 0x10
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD4_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD4_Enabled = 0x1
	// Position of PD5 field.
	PWR_PDCRC_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRC_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRC_PD5 = 0x20
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD5_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD5_Enabled = 0x1
	// Position of PD6 field.
	PWR_PDCRC_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRC_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRC_PD6 = 0x40
	// Disable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD6_Disabled = 0x0
	// Enable the pull-down on PC[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRC_PD6_Enabled = 0x1

	// PUCRH: Power Port H pull-up control register
	// Position of PU3 field.
	PWR_PUCRH_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRH_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRH_PU3 = 0x8
	// Disable pull-up on PH[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PUCRH_PU3_Disabled = 0x0
	// Enable pull-up on PH[y] when both APC bits are set in PWR control register 3 (PWR_CR3). The pull-up is not activated if the corresponding PH[y] bit is also set
	PWR_PUCRH_PU3_Enabled = 0x1

	// PDCRH: Power Port H pull-down control register
	// Position of PD3 field.
	PWR_PDCRH_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRH_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRH_PD3 = 0x8
	// Disable the pull-down on PH[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRH_PD3_Disabled = 0x0
	// Enable the pull-down on PH[y] when both APC bits are set in PWR control register 3 (PWR_CR3)
	PWR_PDCRH_PD3_Enabled = 0x1

	// EXTSCR: Power extended status and status clear register
	// Position of C1DS field.
	PWR_EXTSCR_C1DS_Pos = 0xe
	// Bit mask of C1DS field.
	PWR_EXTSCR_C1DS_Msk = 0x4000
	// Bit C1DS.
	PWR_EXTSCR_C1DS = 0x4000
	// CPU is running or in sleep
	PWR_EXTSCR_C1DS_RunningOrSleep = 0x0
	// CPU is in Deep-Sleep
	PWR_EXTSCR_C1DS_DeepSleep = 0x1
	// Position of C1STOPF field.
	PWR_EXTSCR_C1STOPF_Pos = 0xa
	// Bit mask of C1STOPF field.
	PWR_EXTSCR_C1STOPF_Msk = 0x400
	// Bit C1STOPF.
	PWR_EXTSCR_C1STOPF = 0x400
	// System has not been in Stop 0 or 1 mode
	PWR_EXTSCR_C1STOPF_NoStop = 0x0
	// System has been in Stop 0 or 1 mode
	PWR_EXTSCR_C1STOPF_Stop = 0x1
	// Position of C1STOP2F field.
	PWR_EXTSCR_C1STOP2F_Pos = 0x9
	// Bit mask of C1STOP2F field.
	PWR_EXTSCR_C1STOP2F_Msk = 0x200
	// Bit C1STOP2F.
	PWR_EXTSCR_C1STOP2F = 0x200
	// System has not been in Stop 2 mode
	PWR_EXTSCR_C1STOP2F_NoStop = 0x0
	// System has been in Stop 2 mode
	PWR_EXTSCR_C1STOP2F_Stop = 0x1
	// Position of C1SBF field.
	PWR_EXTSCR_C1SBF_Pos = 0x8
	// Bit mask of C1SBF field.
	PWR_EXTSCR_C1SBF_Msk = 0x100
	// Bit C1SBF.
	PWR_EXTSCR_C1SBF = 0x100
	// System has not been in Standby mode
	PWR_EXTSCR_C1SBF_NoStandby = 0x0
	// System has been in Standby mode
	PWR_EXTSCR_C1SBF_Standby = 0x1
	// Position of C1CSSF field.
	PWR_EXTSCR_C1CSSF_Pos = 0x0
	// Bit mask of C1CSSF field.
	PWR_EXTSCR_C1CSSF_Msk = 0x1
	// Bit C1CSSF.
	PWR_EXTSCR_C1CSSF = 0x1
	// Setting this bit clears the C1STOPF and C1SBF bits
	PWR_EXTSCR_C1CSSF_Clear = 0x1

	// SUBGHZSPICR: Power SPI3 control register
	// Position of NSS field.
	PWR_SUBGHZSPICR_NSS_Pos = 0xf
	// Bit mask of NSS field.
	PWR_SUBGHZSPICR_NSS_Msk = 0x8000
	// Bit NSS.
	PWR_SUBGHZSPICR_NSS = 0x8000
	// Sub-GHz SPI NSS signal at level low
	PWR_SUBGHZSPICR_NSS_Low = 0x0
	// Sub-GHz SPI NSS signal is at level high
	PWR_SUBGHZSPICR_NSS_High = 0x1
)

// Constants for RCC: Reset and clock control
const (
	// CR: Clock control register
	// Position of PLLRDY field.
	RCC_CR_PLLRDY_Pos = 0x19
	// Bit mask of PLLRDY field.
	RCC_CR_PLLRDY_Msk = 0x2000000
	// Bit PLLRDY.
	RCC_CR_PLLRDY = 0x2000000
	// PLL unlocked
	RCC_CR_PLLRDY_Unlocked = 0x0
	// PLL Locked
	RCC_CR_PLLRDY_Locked = 0x1
	// Position of PLLON field.
	RCC_CR_PLLON_Pos = 0x18
	// Bit mask of PLLON field.
	RCC_CR_PLLON_Msk = 0x1000000
	// Bit PLLON.
	RCC_CR_PLLON = 0x1000000
	// Main PLL Off
	RCC_CR_PLLON_Off = 0x0
	// Main PLL On
	RCC_CR_PLLON_On = 0x1
	// Position of HSEBYPPWR field.
	RCC_CR_HSEBYPPWR_Pos = 0x15
	// Bit mask of HSEBYPPWR field.
	RCC_CR_HSEBYPPWR_Msk = 0x200000
	// Bit HSEBYPPWR.
	RCC_CR_HSEBYPPWR = 0x200000
	// PB0 selected
	RCC_CR_HSEBYPPWR_PB0 = 0x0
	// VDDTCXO selected
	RCC_CR_HSEBYPPWR_VDDTCXO = 0x1
	// Position of HSEPRE field.
	RCC_CR_HSEPRE_Pos = 0x14
	// Bit mask of HSEPRE field.
	RCC_CR_HSEPRE_Msk = 0x100000
	// Bit HSEPRE.
	RCC_CR_HSEPRE = 0x100000
	// SYSCLK not divided (HSE32)
	RCC_CR_HSEPRE_Div1 = 0x0
	// SYSCLK divided by two (HSE32/2)
	RCC_CR_HSEPRE_Div2 = 0x1
	// Position of CSSON field.
	RCC_CR_CSSON_Pos = 0x13
	// Bit mask of CSSON field.
	RCC_CR_CSSON_Msk = 0x80000
	// Bit CSSON.
	RCC_CR_CSSON = 0x80000
	// HSE32 CSS off
	RCC_CR_CSSON_Disabled = 0x0
	// HSE32 CSS on if the HSE32 oscillator is stable and off if not
	RCC_CR_CSSON_Enabled = 0x1
	// Position of HSERDY field.
	RCC_CR_HSERDY_Pos = 0x11
	// Bit mask of HSERDY field.
	RCC_CR_HSERDY_Msk = 0x20000
	// Bit HSERDY.
	RCC_CR_HSERDY = 0x20000
	// HSE32 oscillator not ready
	RCC_CR_HSERDY_NotReady = 0x0
	// HSE32 oscillator ready
	RCC_CR_HSERDY_Ready = 0x1
	// Position of HSEON field.
	RCC_CR_HSEON_Pos = 0x10
	// Bit mask of HSEON field.
	RCC_CR_HSEON_Msk = 0x10000
	// Bit HSEON.
	RCC_CR_HSEON = 0x10000
	// HSE32 oscillator for CPU disabled
	RCC_CR_HSEON_Disabled = 0x0
	// HSE32 oscillator for CPU enabled
	RCC_CR_HSEON_Enabled = 0x1
	// Position of HSIKERDY field.
	RCC_CR_HSIKERDY_Pos = 0xc
	// Bit mask of HSIKERDY field.
	RCC_CR_HSIKERDY_Msk = 0x1000
	// Bit HSIKERDY.
	RCC_CR_HSIKERDY = 0x1000
	// HSI16 oscillator not ready
	RCC_CR_HSIKERDY_NotReady = 0x0
	// HSI16 oscillator ready
	RCC_CR_HSIKERDY_Ready = 0x1
	// Position of HSIASFS field.
	RCC_CR_HSIASFS_Pos = 0xb
	// Bit mask of HSIASFS field.
	RCC_CR_HSIASFS_Msk = 0x800
	// Bit HSIASFS.
	RCC_CR_HSIASFS = 0x800
	// HSI16 not enabled by hardware when exiting Stop modes with MSI as wakeup clock
	RCC_CR_HSIASFS_Disabled = 0x0
	// HSI16 enabled by hardware when exiting Stop mode with MSI as wakeup clock
	RCC_CR_HSIASFS_Enabled = 0x1
	// Position of HSIRDY field.
	RCC_CR_HSIRDY_Pos = 0xa
	// Bit mask of HSIRDY field.
	RCC_CR_HSIRDY_Msk = 0x400
	// Bit HSIRDY.
	RCC_CR_HSIRDY = 0x400
	// HSI16 oscillator not ready
	RCC_CR_HSIRDY_NotReady = 0x0
	// HSI16 oscillator ready
	RCC_CR_HSIRDY_Ready = 0x1
	// Position of HSIKERON field.
	RCC_CR_HSIKERON_Pos = 0x9
	// Bit mask of HSIKERON field.
	RCC_CR_HSIKERON_Msk = 0x200
	// Bit HSIKERON.
	RCC_CR_HSIKERON = 0x200
	// No effect on HSI16 oscillator
	RCC_CR_HSIKERON_NotForced = 0x0
	// HSI16 oscillator forced on even in Stop modes
	RCC_CR_HSIKERON_Forced = 0x1
	// Position of HSION field.
	RCC_CR_HSION_Pos = 0x8
	// Bit mask of HSION field.
	RCC_CR_HSION_Msk = 0x100
	// Bit HSION.
	RCC_CR_HSION = 0x100
	// HSI16 oscillator off
	RCC_CR_HSION_Disabled = 0x0
	// HSI16 oscillator on
	RCC_CR_HSION_Enabled = 0x1
	// Position of MSIRANGE field.
	RCC_CR_MSIRANGE_Pos = 0x4
	// Bit mask of MSIRANGE field.
	RCC_CR_MSIRANGE_Msk = 0xf0
	// range 0 around 100 kHz
	RCC_CR_MSIRANGE_Range100K = 0x0
	// range 1 around 200 kHz
	RCC_CR_MSIRANGE_Range200K = 0x1
	// range 2 around 400 kHz
	RCC_CR_MSIRANGE_Range400K = 0x2
	// range 3 around 800 kHz
	RCC_CR_MSIRANGE_Range800K = 0x3
	// range 4 around 1 MHz
	RCC_CR_MSIRANGE_Range1M = 0x4
	// range 5 around 2 MHz
	RCC_CR_MSIRANGE_Range2M = 0x5
	// range 6 around 4 MHz (reset value)
	RCC_CR_MSIRANGE_Range4M = 0x6
	// range 7 around 8 MHz
	RCC_CR_MSIRANGE_Range8M = 0x7
	// range 8 around 16 MHz
	RCC_CR_MSIRANGE_Range16M = 0x8
	// range 9 around 24 MHz
	RCC_CR_MSIRANGE_Range24M = 0x9
	// range 10 around 32 MHz
	RCC_CR_MSIRANGE_Range32M = 0xa
	// range 11 around 48 MHz
	RCC_CR_MSIRANGE_Range48M = 0xb
	// Position of MSIRGSEL field.
	RCC_CR_MSIRGSEL_Pos = 0x3
	// Bit mask of MSIRGSEL field.
	RCC_CR_MSIRGSEL_Msk = 0x8
	// Bit MSIRGSEL.
	RCC_CR_MSIRGSEL = 0x8
	// MSI frequency range defined by MSISRANGE[3:0] in the RCC_CSR register
	RCC_CR_MSIRGSEL_CSR = 0x0
	// MSI frequency range defined by MSIRANGE[3:0] in the RCC_CR register
	RCC_CR_MSIRGSEL_CR = 0x1
	// Position of MSIPLLEN field.
	RCC_CR_MSIPLLEN_Pos = 0x2
	// Bit mask of MSIPLLEN field.
	RCC_CR_MSIPLLEN_Msk = 0x4
	// Bit MSIPLLEN.
	RCC_CR_MSIPLLEN = 0x4
	// MSI PLL Off
	RCC_CR_MSIPLLEN_Off = 0x0
	// MSI PLL On
	RCC_CR_MSIPLLEN_On = 0x1
	// Position of MSIRDY field.
	RCC_CR_MSIRDY_Pos = 0x1
	// Bit mask of MSIRDY field.
	RCC_CR_MSIRDY_Msk = 0x2
	// Bit MSIRDY.
	RCC_CR_MSIRDY = 0x2
	// MSI oscillator not ready
	RCC_CR_MSIRDY_NotReady = 0x0
	// MSI oscillator ready
	RCC_CR_MSIRDY_Ready = 0x1
	// Position of MSION field.
	RCC_CR_MSION_Pos = 0x0
	// Bit mask of MSION field.
	RCC_CR_MSION_Msk = 0x1
	// Bit MSION.
	RCC_CR_MSION = 0x1
	// MSI oscillator off
	RCC_CR_MSION_Disabled = 0x0
	// MSI oscillator on
	RCC_CR_MSION_Enabled = 0x1

	// ICSCR: Internal clock sources calibration register
	// Position of HSITRIM field.
	RCC_ICSCR_HSITRIM_Pos = 0x18
	// Bit mask of HSITRIM field.
	RCC_ICSCR_HSITRIM_Msk = 0x7f000000
	// Position of HSICAL field.
	RCC_ICSCR_HSICAL_Pos = 0x10
	// Bit mask of HSICAL field.
	RCC_ICSCR_HSICAL_Msk = 0xff0000
	// Position of MSITRIM field.
	RCC_ICSCR_MSITRIM_Pos = 0x8
	// Bit mask of MSITRIM field.
	RCC_ICSCR_MSITRIM_Msk = 0xff00
	// Position of MSICAL field.
	RCC_ICSCR_MSICAL_Pos = 0x0
	// Bit mask of MSICAL field.
	RCC_ICSCR_MSICAL_Msk = 0xff

	// CFGR: Clock configuration register
	// Position of MCOPRE field.
	RCC_CFGR_MCOPRE_Pos = 0x1c
	// Bit mask of MCOPRE field.
	RCC_CFGR_MCOPRE_Msk = 0x70000000
	// No division
	RCC_CFGR_MCOPRE_Div1 = 0x0
	// Division by 2
	RCC_CFGR_MCOPRE_Div2 = 0x1
	// Division by 4
	RCC_CFGR_MCOPRE_Div4 = 0x2
	// Division by 8
	RCC_CFGR_MCOPRE_Div8 = 0x3
	// Division by 16
	RCC_CFGR_MCOPRE_Div16 = 0x4
	// Position of MCOSEL field.
	RCC_CFGR_MCOSEL_Pos = 0x18
	// Bit mask of MCOSEL field.
	RCC_CFGR_MCOSEL_Msk = 0xf000000
	// No clock
	RCC_CFGR_MCOSEL_NoClock = 0x0
	// SYSCLK clock selected
	RCC_CFGR_MCOSEL_SYSCLK = 0x1
	// MSI oscillator clock selected
	RCC_CFGR_MCOSEL_MSI = 0x2
	// HSI16 oscillator clock selected
	RCC_CFGR_MCOSEL_HSI16 = 0x3
	// HSE32 oscillator clock selected
	RCC_CFGR_MCOSEL_HSE32 = 0x4
	// Main PLLRCLK clock selected
	RCC_CFGR_MCOSEL_PLLR = 0x5
	// LSI oscillator clock selected
	RCC_CFGR_MCOSEL_LSI = 0x6
	// LSE oscillator clock selected
	RCC_CFGR_MCOSEL_LSE = 0x8
	// Main PLLPCLK clock selected
	RCC_CFGR_MCOSEL_PLLP = 0xd
	// Main PLLQCLK clock selected
	RCC_CFGR_MCOSEL_PLLQ = 0xe
	// Position of PPRE2F field.
	RCC_CFGR_PPRE2F_Pos = 0x12
	// Bit mask of PPRE2F field.
	RCC_CFGR_PPRE2F_Msk = 0x40000
	// Bit PPRE2F.
	RCC_CFGR_PPRE2F = 0x40000
	// PCLK2 prescaler value not yet applied
	RCC_CFGR_PPRE2F_NotApplied = 0x0
	// PCLK2 prescaler value applied
	RCC_CFGR_PPRE2F_Applied = 0x1
	// Position of PPRE1F field.
	RCC_CFGR_PPRE1F_Pos = 0x11
	// Bit mask of PPRE1F field.
	RCC_CFGR_PPRE1F_Msk = 0x20000
	// Bit PPRE1F.
	RCC_CFGR_PPRE1F = 0x20000
	// PCLK1 prescaler value not yet applied
	RCC_CFGR_PPRE1F_NotApplied = 0x0
	// PCLK1 prescaler value applied
	RCC_CFGR_PPRE1F_Applied = 0x1
	// Position of HPREF field.
	RCC_CFGR_HPREF_Pos = 0x10
	// Bit mask of HPREF field.
	RCC_CFGR_HPREF_Msk = 0x10000
	// Bit HPREF.
	RCC_CFGR_HPREF = 0x10000
	// HCLK1 prescaler value not yet applied
	RCC_CFGR_HPREF_NotApplied = 0x0
	// HCLK1 prescaler value applied
	RCC_CFGR_HPREF_Applied = 0x1
	// Position of STOPWUCK field.
	RCC_CFGR_STOPWUCK_Pos = 0xf
	// Bit mask of STOPWUCK field.
	RCC_CFGR_STOPWUCK_Msk = 0x8000
	// Bit STOPWUCK.
	RCC_CFGR_STOPWUCK = 0x8000
	// MSI oscillator selected as wakeup from stop clock and CSS backup clock
	RCC_CFGR_STOPWUCK_MSI = 0x0
	// HSI16 oscillator selected as wakeup from stop clock and CSS backup clock
	RCC_CFGR_STOPWUCK_HSI16 = 0x1
	// Position of PPRE2 field.
	RCC_CFGR_PPRE2_Pos = 0xb
	// Bit mask of PPRE2 field.
	RCC_CFGR_PPRE2_Msk = 0x3800
	// HCLK not divided
	RCC_CFGR_PPRE2_Div1 = 0x0
	// HCLK divided by 2
	RCC_CFGR_PPRE2_Div2 = 0x4
	// HCLK divided by 4
	RCC_CFGR_PPRE2_Div4 = 0x5
	// HCLK divided by 8
	RCC_CFGR_PPRE2_Div8 = 0x6
	// HCLK divided by 16
	RCC_CFGR_PPRE2_Div16 = 0x7
	// Position of PPRE1 field.
	RCC_CFGR_PPRE1_Pos = 0x8
	// Bit mask of PPRE1 field.
	RCC_CFGR_PPRE1_Msk = 0x700
	// HCLK not divided
	RCC_CFGR_PPRE1_Div1 = 0x0
	// HCLK divided by 2
	RCC_CFGR_PPRE1_Div2 = 0x4
	// HCLK divided by 4
	RCC_CFGR_PPRE1_Div4 = 0x5
	// HCLK divided by 8
	RCC_CFGR_PPRE1_Div8 = 0x6
	// HCLK divided by 16
	RCC_CFGR_PPRE1_Div16 = 0x7
	// Position of HPRE field.
	RCC_CFGR_HPRE_Pos = 0x4
	// Bit mask of HPRE field.
	RCC_CFGR_HPRE_Msk = 0xf0
	// SYSCLK not divided
	RCC_CFGR_HPRE_Div1 = 0x0
	// SYSCLK divided by 3
	RCC_CFGR_HPRE_Div3 = 0x1
	// SYSCLK divided by 5
	RCC_CFGR_HPRE_Div5 = 0x2
	// SYSCLK divided by 6
	RCC_CFGR_HPRE_Div6 = 0x5
	// SYSCLK divided by 10
	RCC_CFGR_HPRE_Div10 = 0x6
	// SYSCLK divided by 32
	RCC_CFGR_HPRE_Div32 = 0x7
	// SYSCLK divided by 2
	RCC_CFGR_HPRE_Div2 = 0x8
	// SYSCLK divided by 4
	RCC_CFGR_HPRE_Div4 = 0x9
	// SYSCLK divided by 8
	RCC_CFGR_HPRE_Div8 = 0xa
	// SYSCLK divided by 16
	RCC_CFGR_HPRE_Div16 = 0xb
	// SYSCLK divided by 64
	RCC_CFGR_HPRE_Div64 = 0xc
	// SYSCLK divided by 128
	RCC_CFGR_HPRE_Div128 = 0xd
	// SYSCLK divided by 128
	RCC_CFGR_HPRE_Div256 = 0xe
	// SYSCLK divided by 512
	RCC_CFGR_HPRE_Div512 = 0xf
	// Position of SWS field.
	RCC_CFGR_SWS_Pos = 0x2
	// Bit mask of SWS field.
	RCC_CFGR_SWS_Msk = 0xc
	// MSI oscillator used as system clock
	RCC_CFGR_SWS_MSI = 0x0
	// HSI16 oscillator used as system clock
	RCC_CFGR_SWS_HSI16 = 0x1
	// HSE32 oscillator used as system clock
	RCC_CFGR_SWS_HSE32 = 0x2
	// PLLRCLK used as system clock
	RCC_CFGR_SWS_PLLR = 0x3
	// Position of SW field.
	RCC_CFGR_SW_Pos = 0x0
	// Bit mask of SW field.
	RCC_CFGR_SW_Msk = 0x3
	// MSI oscillator used as system clock
	RCC_CFGR_SW_MSI = 0x0
	// HSI16 oscillator used as system clock
	RCC_CFGR_SW_HSI16 = 0x1
	// HSE32 oscillator used as system clock
	RCC_CFGR_SW_HSE32 = 0x2
	// PLLRCLK used as system clock
	RCC_CFGR_SW_PLLR = 0x3

	// PLLCFGR: PLL configuration register
	// Position of PLLR field.
	RCC_PLLCFGR_PLLR_Pos = 0x1d
	// Bit mask of PLLR field.
	RCC_PLLCFGR_PLLR_Msk = 0xe0000000
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div2 = 0x1
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div3 = 0x2
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div4 = 0x3
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div5 = 0x4
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div6 = 0x5
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div7 = 0x6
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLR_Div8 = 0x7
	// Position of PLLREN field.
	RCC_PLLCFGR_PLLREN_Pos = 0x1c
	// Bit mask of PLLREN field.
	RCC_PLLCFGR_PLLREN_Msk = 0x10000000
	// Bit PLLREN.
	RCC_PLLCFGR_PLLREN = 0x10000000
	// PLLCLK output disabled
	RCC_PLLCFGR_PLLREN_Disabled = 0x0
	// PLLCLK output enabled
	RCC_PLLCFGR_PLLREN_Enabled = 0x1
	// Position of PLLQ field.
	RCC_PLLCFGR_PLLQ_Pos = 0x19
	// Bit mask of PLLQ field.
	RCC_PLLCFGR_PLLQ_Msk = 0xe000000
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div2 = 0x1
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div3 = 0x2
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div4 = 0x3
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div5 = 0x4
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div6 = 0x5
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div7 = 0x6
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLQ_Div8 = 0x7
	// Position of PLLQEN field.
	RCC_PLLCFGR_PLLQEN_Pos = 0x18
	// Bit mask of PLLQEN field.
	RCC_PLLCFGR_PLLQEN_Msk = 0x1000000
	// Bit PLLQEN.
	RCC_PLLCFGR_PLLQEN = 0x1000000
	// PLLCLK output disabled
	RCC_PLLCFGR_PLLQEN_Disabled = 0x0
	// PLLCLK output enabled
	RCC_PLLCFGR_PLLQEN_Enabled = 0x1
	// Position of PLLP field.
	RCC_PLLCFGR_PLLP_Pos = 0x11
	// Bit mask of PLLP field.
	RCC_PLLCFGR_PLLP_Msk = 0x3e0000
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div2 = 0x1
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div3 = 0x2
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div4 = 0x3
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div5 = 0x4
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div6 = 0x5
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div7 = 0x6
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div8 = 0x7
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div9 = 0x8
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div10 = 0x9
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div11 = 0xa
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div12 = 0xb
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div13 = 0xc
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div14 = 0xd
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div15 = 0xe
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div16 = 0xf
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div17 = 0x10
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div18 = 0x11
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div19 = 0x12
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div20 = 0x13
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div21 = 0x14
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div22 = 0x15
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div23 = 0x16
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div24 = 0x17
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div25 = 0x18
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div26 = 0x19
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div27 = 0x1a
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div28 = 0x1b
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div29 = 0x1c
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div30 = 0x1d
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div31 = 0x1e
	// PLL = VCO/(N+1)
	RCC_PLLCFGR_PLLP_Div32 = 0x1f
	// Position of PLLPEN field.
	RCC_PLLCFGR_PLLPEN_Pos = 0x10
	// Bit mask of PLLPEN field.
	RCC_PLLCFGR_PLLPEN_Msk = 0x10000
	// Bit PLLPEN.
	RCC_PLLCFGR_PLLPEN = 0x10000
	// PLLCLK output disabled
	RCC_PLLCFGR_PLLPEN_Disabled = 0x0
	// PLLCLK output enabled
	RCC_PLLCFGR_PLLPEN_Enabled = 0x1
	// Position of PLLN field.
	RCC_PLLCFGR_PLLN_Pos = 0x8
	// Bit mask of PLLN field.
	RCC_PLLCFGR_PLLN_Msk = 0x7f00
	// Position of PLLM field.
	RCC_PLLCFGR_PLLM_Pos = 0x4
	// Bit mask of PLLM field.
	RCC_PLLCFGR_PLLM_Msk = 0x70
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div1 = 0x0
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div2 = 0x1
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div3 = 0x2
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div4 = 0x3
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div5 = 0x4
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div6 = 0x5
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div7 = 0x6
	// VCO input = PLL input / PLLM
	RCC_PLLCFGR_PLLM_Div8 = 0x7
	// Position of PLLSRC field.
	RCC_PLLCFGR_PLLSRC_Pos = 0x0
	// Bit mask of PLLSRC field.
	RCC_PLLCFGR_PLLSRC_Msk = 0x3
	// No clock sent to PLL
	RCC_PLLCFGR_PLLSRC_NoClock = 0x0
	// MSI clock selected as PLL clock entry
	RCC_PLLCFGR_PLLSRC_MSI = 0x1
	// HSI16 clock selected as PLL clock entry
	RCC_PLLCFGR_PLLSRC_HSI16 = 0x2
	// HSE32 clock selected as PLL clock entry
	RCC_PLLCFGR_PLLSRC_HSE32 = 0x3

	// CIER: Clock interrupt enable register
	// Position of LSECSSIE field.
	RCC_CIER_LSECSSIE_Pos = 0x9
	// Bit mask of LSECSSIE field.
	RCC_CIER_LSECSSIE_Msk = 0x200
	// Bit LSECSSIE.
	RCC_CIER_LSECSSIE = 0x200
	// Interrupt disabled
	RCC_CIER_LSECSSIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_LSECSSIE_Enabled = 0x1
	// Position of PLLRDYIE field.
	RCC_CIER_PLLRDYIE_Pos = 0x5
	// Bit mask of PLLRDYIE field.
	RCC_CIER_PLLRDYIE_Msk = 0x20
	// Bit PLLRDYIE.
	RCC_CIER_PLLRDYIE = 0x20
	// Interrupt disabled
	RCC_CIER_PLLRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_PLLRDYIE_Enabled = 0x1
	// Position of HSERDYIE field.
	RCC_CIER_HSERDYIE_Pos = 0x4
	// Bit mask of HSERDYIE field.
	RCC_CIER_HSERDYIE_Msk = 0x10
	// Bit HSERDYIE.
	RCC_CIER_HSERDYIE = 0x10
	// Interrupt disabled
	RCC_CIER_HSERDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_HSERDYIE_Enabled = 0x1
	// Position of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Pos = 0x3
	// Bit mask of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Msk = 0x8
	// Bit HSIRDYIE.
	RCC_CIER_HSIRDYIE = 0x8
	// Interrupt disabled
	RCC_CIER_HSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_HSIRDYIE_Enabled = 0x1
	// Position of MSIRDYIE field.
	RCC_CIER_MSIRDYIE_Pos = 0x2
	// Bit mask of MSIRDYIE field.
	RCC_CIER_MSIRDYIE_Msk = 0x4
	// Bit MSIRDYIE.
	RCC_CIER_MSIRDYIE = 0x4
	// Interrupt disabled
	RCC_CIER_MSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_MSIRDYIE_Enabled = 0x1
	// Position of LSERDYIE field.
	RCC_CIER_LSERDYIE_Pos = 0x1
	// Bit mask of LSERDYIE field.
	RCC_CIER_LSERDYIE_Msk = 0x2
	// Bit LSERDYIE.
	RCC_CIER_LSERDYIE = 0x2
	// Interrupt disabled
	RCC_CIER_LSERDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_LSERDYIE_Enabled = 0x1
	// Position of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Pos = 0x0
	// Bit mask of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Msk = 0x1
	// Bit LSIRDYIE.
	RCC_CIER_LSIRDYIE = 0x1
	// Interrupt disabled
	RCC_CIER_LSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_LSIRDYIE_Enabled = 0x1

	// CIFR: Clock interrupt flag register
	// Position of LSECSSF field.
	RCC_CIFR_LSECSSF_Pos = 0x9
	// Bit mask of LSECSSF field.
	RCC_CIFR_LSECSSF_Msk = 0x200
	// Bit LSECSSF.
	RCC_CIFR_LSECSSF = 0x200
	// Not interrupted
	RCC_CIFR_LSECSSF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_LSECSSF_Interrupted = 0x1
	// Position of CSSF field.
	RCC_CIFR_CSSF_Pos = 0x8
	// Bit mask of CSSF field.
	RCC_CIFR_CSSF_Msk = 0x100
	// Bit CSSF.
	RCC_CIFR_CSSF = 0x100
	// Not interrupted
	RCC_CIFR_CSSF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_CSSF_Interrupted = 0x1
	// Position of PLLRDYF field.
	RCC_CIFR_PLLRDYF_Pos = 0x5
	// Bit mask of PLLRDYF field.
	RCC_CIFR_PLLRDYF_Msk = 0x20
	// Bit PLLRDYF.
	RCC_CIFR_PLLRDYF = 0x20
	// Not interrupted
	RCC_CIFR_PLLRDYF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_PLLRDYF_Interrupted = 0x1
	// Position of HSERDYF field.
	RCC_CIFR_HSERDYF_Pos = 0x4
	// Bit mask of HSERDYF field.
	RCC_CIFR_HSERDYF_Msk = 0x10
	// Bit HSERDYF.
	RCC_CIFR_HSERDYF = 0x10
	// Not interrupted
	RCC_CIFR_HSERDYF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_HSERDYF_Interrupted = 0x1
	// Position of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Pos = 0x3
	// Bit mask of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Msk = 0x8
	// Bit HSIRDYF.
	RCC_CIFR_HSIRDYF = 0x8
	// Not interrupted
	RCC_CIFR_HSIRDYF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_HSIRDYF_Interrupted = 0x1
	// Position of MSIRDYF field.
	RCC_CIFR_MSIRDYF_Pos = 0x2
	// Bit mask of MSIRDYF field.
	RCC_CIFR_MSIRDYF_Msk = 0x4
	// Bit MSIRDYF.
	RCC_CIFR_MSIRDYF = 0x4
	// Not interrupted
	RCC_CIFR_MSIRDYF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_MSIRDYF_Interrupted = 0x1
	// Position of LSERDYF field.
	RCC_CIFR_LSERDYF_Pos = 0x1
	// Bit mask of LSERDYF field.
	RCC_CIFR_LSERDYF_Msk = 0x2
	// Bit LSERDYF.
	RCC_CIFR_LSERDYF = 0x2
	// Not interrupted
	RCC_CIFR_LSERDYF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_LSERDYF_Interrupted = 0x1
	// Position of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Pos = 0x0
	// Bit mask of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Msk = 0x1
	// Bit LSIRDYF.
	RCC_CIFR_LSIRDYF = 0x1
	// Not interrupted
	RCC_CIFR_LSIRDYF_NotInterrupted = 0x0
	// Interrupted
	RCC_CIFR_LSIRDYF_Interrupted = 0x1

	// CICR: Clock interrupt clear register
	// Position of LSECSSC field.
	RCC_CICR_LSECSSC_Pos = 0x9
	// Bit mask of LSECSSC field.
	RCC_CICR_LSECSSC_Msk = 0x200
	// Bit LSECSSC.
	RCC_CICR_LSECSSC = 0x200
	// Clear interrupt flag
	RCC_CICR_LSECSSC_Clear = 0x1
	// Position of CSSC field.
	RCC_CICR_CSSC_Pos = 0x8
	// Bit mask of CSSC field.
	RCC_CICR_CSSC_Msk = 0x100
	// Bit CSSC.
	RCC_CICR_CSSC = 0x100
	// Clear interrupt flag
	RCC_CICR_CSSC_Clear = 0x1
	// Position of PLLRDYC field.
	RCC_CICR_PLLRDYC_Pos = 0x5
	// Bit mask of PLLRDYC field.
	RCC_CICR_PLLRDYC_Msk = 0x20
	// Bit PLLRDYC.
	RCC_CICR_PLLRDYC = 0x20
	// Clear interrupt flag
	RCC_CICR_PLLRDYC_Clear = 0x1
	// Position of HSERDYC field.
	RCC_CICR_HSERDYC_Pos = 0x4
	// Bit mask of HSERDYC field.
	RCC_CICR_HSERDYC_Msk = 0x10
	// Bit HSERDYC.
	RCC_CICR_HSERDYC = 0x10
	// Clear interrupt flag
	RCC_CICR_HSERDYC_Clear = 0x1
	// Position of HSIRDYC field.
	RCC_CICR_HSIRDYC_Pos = 0x3
	// Bit mask of HSIRDYC field.
	RCC_CICR_HSIRDYC_Msk = 0x8
	// Bit HSIRDYC.
	RCC_CICR_HSIRDYC = 0x8
	// Clear interrupt flag
	RCC_CICR_HSIRDYC_Clear = 0x1
	// Position of MSIRDYC field.
	RCC_CICR_MSIRDYC_Pos = 0x2
	// Bit mask of MSIRDYC field.
	RCC_CICR_MSIRDYC_Msk = 0x4
	// Bit MSIRDYC.
	RCC_CICR_MSIRDYC = 0x4
	// Clear interrupt flag
	RCC_CICR_MSIRDYC_Clear = 0x1
	// Position of LSERDYC field.
	RCC_CICR_LSERDYC_Pos = 0x1
	// Bit mask of LSERDYC field.
	RCC_CICR_LSERDYC_Msk = 0x2
	// Bit LSERDYC.
	RCC_CICR_LSERDYC = 0x2
	// Clear interrupt flag
	RCC_CICR_LSERDYC_Clear = 0x1
	// Position of LSIRDYC field.
	RCC_CICR_LSIRDYC_Pos = 0x0
	// Bit mask of LSIRDYC field.
	RCC_CICR_LSIRDYC_Msk = 0x1
	// Bit LSIRDYC.
	RCC_CICR_LSIRDYC = 0x1
	// Clear interrupt flag
	RCC_CICR_LSIRDYC_Clear = 0x1

	// AHB1RSTR: AHB1 peripheral reset register
	// Position of CRCRST field.
	RCC_AHB1RSTR_CRCRST_Pos = 0xc
	// Bit mask of CRCRST field.
	RCC_AHB1RSTR_CRCRST_Msk = 0x1000
	// Bit CRCRST.
	RCC_AHB1RSTR_CRCRST = 0x1000
	// No effect
	RCC_AHB1RSTR_CRCRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB1RSTR_CRCRST_Reset = 0x1
	// Position of DMAMUX1RST field.
	RCC_AHB1RSTR_DMAMUX1RST_Pos = 0x2
	// Bit mask of DMAMUX1RST field.
	RCC_AHB1RSTR_DMAMUX1RST_Msk = 0x4
	// Bit DMAMUX1RST.
	RCC_AHB1RSTR_DMAMUX1RST = 0x4
	// No effect
	RCC_AHB1RSTR_DMAMUX1RST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB1RSTR_DMAMUX1RST_Reset = 0x1
	// Position of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Pos = 0x1
	// Bit mask of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Msk = 0x2
	// Bit DMA2RST.
	RCC_AHB1RSTR_DMA2RST = 0x2
	// No effect
	RCC_AHB1RSTR_DMA2RST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB1RSTR_DMA2RST_Reset = 0x1
	// Position of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Pos = 0x0
	// Bit mask of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Msk = 0x1
	// Bit DMA1RST.
	RCC_AHB1RSTR_DMA1RST = 0x1
	// No effect
	RCC_AHB1RSTR_DMA1RST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB1RSTR_DMA1RST_Reset = 0x1

	// AHB2RSTR: AHB2 peripheral reset register
	// Position of GPIOHRST field.
	RCC_AHB2RSTR_GPIOHRST_Pos = 0x7
	// Bit mask of GPIOHRST field.
	RCC_AHB2RSTR_GPIOHRST_Msk = 0x80
	// Bit GPIOHRST.
	RCC_AHB2RSTR_GPIOHRST = 0x80
	// No effect
	RCC_AHB2RSTR_GPIOHRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB2RSTR_GPIOHRST_Reset = 0x1
	// Position of GPIOCRST field.
	RCC_AHB2RSTR_GPIOCRST_Pos = 0x2
	// Bit mask of GPIOCRST field.
	RCC_AHB2RSTR_GPIOCRST_Msk = 0x4
	// Bit GPIOCRST.
	RCC_AHB2RSTR_GPIOCRST = 0x4
	// No effect
	RCC_AHB2RSTR_GPIOCRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB2RSTR_GPIOCRST_Reset = 0x1
	// Position of GPIOBRST field.
	RCC_AHB2RSTR_GPIOBRST_Pos = 0x1
	// Bit mask of GPIOBRST field.
	RCC_AHB2RSTR_GPIOBRST_Msk = 0x2
	// Bit GPIOBRST.
	RCC_AHB2RSTR_GPIOBRST = 0x2
	// No effect
	RCC_AHB2RSTR_GPIOBRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB2RSTR_GPIOBRST_Reset = 0x1
	// Position of GPIOARST field.
	RCC_AHB2RSTR_GPIOARST_Pos = 0x0
	// Bit mask of GPIOARST field.
	RCC_AHB2RSTR_GPIOARST_Msk = 0x1
	// Bit GPIOARST.
	RCC_AHB2RSTR_GPIOARST = 0x1
	// No effect
	RCC_AHB2RSTR_GPIOARST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB2RSTR_GPIOARST_Reset = 0x1

	// AHB3RSTR: AHB3 peripheral reset register
	// Position of FLASHRST field.
	RCC_AHB3RSTR_FLASHRST_Pos = 0x19
	// Bit mask of FLASHRST field.
	RCC_AHB3RSTR_FLASHRST_Msk = 0x2000000
	// Bit FLASHRST.
	RCC_AHB3RSTR_FLASHRST = 0x2000000
	// No effect
	RCC_AHB3RSTR_FLASHRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB3RSTR_FLASHRST_Reset = 0x1
	// Position of HSEMRST field.
	RCC_AHB3RSTR_HSEMRST_Pos = 0x13
	// Bit mask of HSEMRST field.
	RCC_AHB3RSTR_HSEMRST_Msk = 0x80000
	// Bit HSEMRST.
	RCC_AHB3RSTR_HSEMRST = 0x80000
	// No effect
	RCC_AHB3RSTR_HSEMRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB3RSTR_HSEMRST_Reset = 0x1
	// Position of RNGRST field.
	RCC_AHB3RSTR_RNGRST_Pos = 0x12
	// Bit mask of RNGRST field.
	RCC_AHB3RSTR_RNGRST_Msk = 0x40000
	// Bit RNGRST.
	RCC_AHB3RSTR_RNGRST = 0x40000
	// No effect
	RCC_AHB3RSTR_RNGRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB3RSTR_RNGRST_Reset = 0x1
	// Position of AESRST field.
	RCC_AHB3RSTR_AESRST_Pos = 0x11
	// Bit mask of AESRST field.
	RCC_AHB3RSTR_AESRST_Msk = 0x20000
	// Bit AESRST.
	RCC_AHB3RSTR_AESRST = 0x20000
	// No effect
	RCC_AHB3RSTR_AESRST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB3RSTR_AESRST_Reset = 0x1
	// Position of PKARST field.
	RCC_AHB3RSTR_PKARST_Pos = 0x10
	// Bit mask of PKARST field.
	RCC_AHB3RSTR_PKARST_Msk = 0x10000
	// Bit PKARST.
	RCC_AHB3RSTR_PKARST = 0x10000
	// No effect
	RCC_AHB3RSTR_PKARST_NoReset = 0x0
	// Reset peripheral
	RCC_AHB3RSTR_PKARST_Reset = 0x1

	// APB1RSTR1: APB1 peripheral reset register 1
	// Position of LPTIM1RST field.
	RCC_APB1RSTR1_LPTIM1RST_Pos = 0x1f
	// Bit mask of LPTIM1RST field.
	RCC_APB1RSTR1_LPTIM1RST_Msk = 0x80000000
	// Bit LPTIM1RST.
	RCC_APB1RSTR1_LPTIM1RST = 0x80000000
	// No effect
	RCC_APB1RSTR1_LPTIM1RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_LPTIM1RST_Reset = 0x1
	// Position of DACRST field.
	RCC_APB1RSTR1_DACRST_Pos = 0x1d
	// Bit mask of DACRST field.
	RCC_APB1RSTR1_DACRST_Msk = 0x20000000
	// Bit DACRST.
	RCC_APB1RSTR1_DACRST = 0x20000000
	// No effect
	RCC_APB1RSTR1_DACRST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_DACRST_Reset = 0x1
	// Position of I2C3RST field.
	RCC_APB1RSTR1_I2C3RST_Pos = 0x17
	// Bit mask of I2C3RST field.
	RCC_APB1RSTR1_I2C3RST_Msk = 0x800000
	// Bit I2C3RST.
	RCC_APB1RSTR1_I2C3RST = 0x800000
	// No effect
	RCC_APB1RSTR1_I2C3RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_I2C3RST_Reset = 0x1
	// Position of I2C2RST field.
	RCC_APB1RSTR1_I2C2RST_Pos = 0x16
	// Bit mask of I2C2RST field.
	RCC_APB1RSTR1_I2C2RST_Msk = 0x400000
	// Bit I2C2RST.
	RCC_APB1RSTR1_I2C2RST = 0x400000
	// No effect
	RCC_APB1RSTR1_I2C2RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_I2C2RST_Reset = 0x1
	// Position of I2C1RST field.
	RCC_APB1RSTR1_I2C1RST_Pos = 0x15
	// Bit mask of I2C1RST field.
	RCC_APB1RSTR1_I2C1RST_Msk = 0x200000
	// Bit I2C1RST.
	RCC_APB1RSTR1_I2C1RST = 0x200000
	// No effect
	RCC_APB1RSTR1_I2C1RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_I2C1RST_Reset = 0x1
	// Position of USART2RST field.
	RCC_APB1RSTR1_USART2RST_Pos = 0x11
	// Bit mask of USART2RST field.
	RCC_APB1RSTR1_USART2RST_Msk = 0x20000
	// Bit USART2RST.
	RCC_APB1RSTR1_USART2RST = 0x20000
	// No effect
	RCC_APB1RSTR1_USART2RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_USART2RST_Reset = 0x1
	// Position of SPI2S2RST field.
	RCC_APB1RSTR1_SPI2S2RST_Pos = 0xe
	// Bit mask of SPI2S2RST field.
	RCC_APB1RSTR1_SPI2S2RST_Msk = 0x4000
	// Bit SPI2S2RST.
	RCC_APB1RSTR1_SPI2S2RST = 0x4000
	// No effect
	RCC_APB1RSTR1_SPI2S2RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_SPI2S2RST_Reset = 0x1
	// Position of TIM2RST field.
	RCC_APB1RSTR1_TIM2RST_Pos = 0x0
	// Bit mask of TIM2RST field.
	RCC_APB1RSTR1_TIM2RST_Msk = 0x1
	// Bit TIM2RST.
	RCC_APB1RSTR1_TIM2RST = 0x1
	// No effect
	RCC_APB1RSTR1_TIM2RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR1_TIM2RST_Reset = 0x1

	// APB1RSTR2: APB1 peripheral reset register 2
	// Position of LPTIM3RST field.
	RCC_APB1RSTR2_LPTIM3RST_Pos = 0x6
	// Bit mask of LPTIM3RST field.
	RCC_APB1RSTR2_LPTIM3RST_Msk = 0x40
	// Bit LPTIM3RST.
	RCC_APB1RSTR2_LPTIM3RST = 0x40
	// No effect
	RCC_APB1RSTR2_LPTIM3RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR2_LPTIM3RST_Reset = 0x1
	// Position of LPTIM2RST field.
	RCC_APB1RSTR2_LPTIM2RST_Pos = 0x5
	// Bit mask of LPTIM2RST field.
	RCC_APB1RSTR2_LPTIM2RST_Msk = 0x20
	// Bit LPTIM2RST.
	RCC_APB1RSTR2_LPTIM2RST = 0x20
	// No effect
	RCC_APB1RSTR2_LPTIM2RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR2_LPTIM2RST_Reset = 0x1
	// Position of LPUART1RST field.
	RCC_APB1RSTR2_LPUART1RST_Pos = 0x0
	// Bit mask of LPUART1RST field.
	RCC_APB1RSTR2_LPUART1RST_Msk = 0x1
	// Bit LPUART1RST.
	RCC_APB1RSTR2_LPUART1RST = 0x1
	// No effect
	RCC_APB1RSTR2_LPUART1RST_NoReset = 0x0
	// Reset peripheral
	RCC_APB1RSTR2_LPUART1RST_Reset = 0x1

	// APB2RSTR: APB2 peripheral reset register
	// Position of TIM17RST field.
	RCC_APB2RSTR_TIM17RST_Pos = 0x12
	// Bit mask of TIM17RST field.
	RCC_APB2RSTR_TIM17RST_Msk = 0x40000
	// Bit TIM17RST.
	RCC_APB2RSTR_TIM17RST = 0x40000
	// Position of TIM16RST field.
	RCC_APB2RSTR_TIM16RST_Pos = 0x11
	// Bit mask of TIM16RST field.
	RCC_APB2RSTR_TIM16RST_Msk = 0x20000
	// Bit TIM16RST.
	RCC_APB2RSTR_TIM16RST = 0x20000
	// Position of USART1RST field.
	RCC_APB2RSTR_USART1RST_Pos = 0xe
	// Bit mask of USART1RST field.
	RCC_APB2RSTR_USART1RST_Msk = 0x4000
	// Bit USART1RST.
	RCC_APB2RSTR_USART1RST = 0x4000
	// Position of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Pos = 0xc
	// Bit mask of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Msk = 0x1000
	// Bit SPI1RST.
	RCC_APB2RSTR_SPI1RST = 0x1000
	// Position of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Pos = 0xb
	// Bit mask of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Msk = 0x800
	// Bit TIM1RST.
	RCC_APB2RSTR_TIM1RST = 0x800
	// Position of ADCRST field.
	RCC_APB2RSTR_ADCRST_Pos = 0x9
	// Bit mask of ADCRST field.
	RCC_APB2RSTR_ADCRST_Msk = 0x200
	// Bit ADCRST.
	RCC_APB2RSTR_ADCRST = 0x200

	// APB3RSTR: APB3 peripheral reset register
	// Position of SUBGHZSPIRST field.
	RCC_APB3RSTR_SUBGHZSPIRST_Pos = 0x0
	// Bit mask of SUBGHZSPIRST field.
	RCC_APB3RSTR_SUBGHZSPIRST_Msk = 0x1
	// Bit SUBGHZSPIRST.
	RCC_APB3RSTR_SUBGHZSPIRST = 0x1

	// AHB1ENR: AHB1 peripheral clock enable register
	// Position of CRCEN field.
	RCC_AHB1ENR_CRCEN_Pos = 0xc
	// Bit mask of CRCEN field.
	RCC_AHB1ENR_CRCEN_Msk = 0x1000
	// Bit CRCEN.
	RCC_AHB1ENR_CRCEN = 0x1000
	// Clock disabled
	RCC_AHB1ENR_CRCEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB1ENR_CRCEN_Enabled = 0x1
	// Position of DMAMUX1EN field.
	RCC_AHB1ENR_DMAMUX1EN_Pos = 0x2
	// Bit mask of DMAMUX1EN field.
	RCC_AHB1ENR_DMAMUX1EN_Msk = 0x4
	// Bit DMAMUX1EN.
	RCC_AHB1ENR_DMAMUX1EN = 0x4
	// Clock disabled
	RCC_AHB1ENR_DMAMUX1EN_Disabled = 0x0
	// Clock enabled
	RCC_AHB1ENR_DMAMUX1EN_Enabled = 0x1
	// Position of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Pos = 0x1
	// Bit mask of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Msk = 0x2
	// Bit DMA2EN.
	RCC_AHB1ENR_DMA2EN = 0x2
	// Clock disabled
	RCC_AHB1ENR_DMA2EN_Disabled = 0x0
	// Clock enabled
	RCC_AHB1ENR_DMA2EN_Enabled = 0x1
	// Position of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Pos = 0x0
	// Bit mask of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Msk = 0x1
	// Bit DMA1EN.
	RCC_AHB1ENR_DMA1EN = 0x1
	// Clock disabled
	RCC_AHB1ENR_DMA1EN_Disabled = 0x0
	// Clock enabled
	RCC_AHB1ENR_DMA1EN_Enabled = 0x1

	// AHB2ENR: AHB2 peripheral clock enable register
	// Position of GPIOHEN field.
	RCC_AHB2ENR_GPIOHEN_Pos = 0x7
	// Bit mask of GPIOHEN field.
	RCC_AHB2ENR_GPIOHEN_Msk = 0x80
	// Bit GPIOHEN.
	RCC_AHB2ENR_GPIOHEN = 0x80
	// Clock disabled
	RCC_AHB2ENR_GPIOHEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB2ENR_GPIOHEN_Enabled = 0x1
	// Position of GPIOCEN field.
	RCC_AHB2ENR_GPIOCEN_Pos = 0x2
	// Bit mask of GPIOCEN field.
	RCC_AHB2ENR_GPIOCEN_Msk = 0x4
	// Bit GPIOCEN.
	RCC_AHB2ENR_GPIOCEN = 0x4
	// Clock disabled
	RCC_AHB2ENR_GPIOCEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB2ENR_GPIOCEN_Enabled = 0x1
	// Position of GPIOBEN field.
	RCC_AHB2ENR_GPIOBEN_Pos = 0x1
	// Bit mask of GPIOBEN field.
	RCC_AHB2ENR_GPIOBEN_Msk = 0x2
	// Bit GPIOBEN.
	RCC_AHB2ENR_GPIOBEN = 0x2
	// Clock disabled
	RCC_AHB2ENR_GPIOBEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB2ENR_GPIOBEN_Enabled = 0x1
	// Position of GPIOAEN field.
	RCC_AHB2ENR_GPIOAEN_Pos = 0x0
	// Bit mask of GPIOAEN field.
	RCC_AHB2ENR_GPIOAEN_Msk = 0x1
	// Bit GPIOAEN.
	RCC_AHB2ENR_GPIOAEN = 0x1
	// Clock disabled
	RCC_AHB2ENR_GPIOAEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB2ENR_GPIOAEN_Enabled = 0x1

	// AHB3ENR: AHB3 peripheral clock enable register
	// Position of FLASHEN field.
	RCC_AHB3ENR_FLASHEN_Pos = 0x19
	// Bit mask of FLASHEN field.
	RCC_AHB3ENR_FLASHEN_Msk = 0x2000000
	// Bit FLASHEN.
	RCC_AHB3ENR_FLASHEN = 0x2000000
	// Clock disabled
	RCC_AHB3ENR_FLASHEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB3ENR_FLASHEN_Enabled = 0x1
	// Position of HSEMEN field.
	RCC_AHB3ENR_HSEMEN_Pos = 0x13
	// Bit mask of HSEMEN field.
	RCC_AHB3ENR_HSEMEN_Msk = 0x80000
	// Bit HSEMEN.
	RCC_AHB3ENR_HSEMEN = 0x80000
	// Clock disabled
	RCC_AHB3ENR_HSEMEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB3ENR_HSEMEN_Enabled = 0x1
	// Position of RNGEN field.
	RCC_AHB3ENR_RNGEN_Pos = 0x12
	// Bit mask of RNGEN field.
	RCC_AHB3ENR_RNGEN_Msk = 0x40000
	// Bit RNGEN.
	RCC_AHB3ENR_RNGEN = 0x40000
	// Clock disabled
	RCC_AHB3ENR_RNGEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB3ENR_RNGEN_Enabled = 0x1
	// Position of AESEN field.
	RCC_AHB3ENR_AESEN_Pos = 0x11
	// Bit mask of AESEN field.
	RCC_AHB3ENR_AESEN_Msk = 0x20000
	// Bit AESEN.
	RCC_AHB3ENR_AESEN = 0x20000
	// Clock disabled
	RCC_AHB3ENR_AESEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB3ENR_AESEN_Enabled = 0x1
	// Position of PKAEN field.
	RCC_AHB3ENR_PKAEN_Pos = 0x10
	// Bit mask of PKAEN field.
	RCC_AHB3ENR_PKAEN_Msk = 0x10000
	// Bit PKAEN.
	RCC_AHB3ENR_PKAEN = 0x10000
	// Clock disabled
	RCC_AHB3ENR_PKAEN_Disabled = 0x0
	// Clock enabled
	RCC_AHB3ENR_PKAEN_Enabled = 0x1

	// APB1ENR1: APB1 peripheral clock enable register 1
	// Position of LPTIM1EN field.
	RCC_APB1ENR1_LPTIM1EN_Pos = 0x1f
	// Bit mask of LPTIM1EN field.
	RCC_APB1ENR1_LPTIM1EN_Msk = 0x80000000
	// Bit LPTIM1EN.
	RCC_APB1ENR1_LPTIM1EN = 0x80000000
	// Clock disabled
	RCC_APB1ENR1_LPTIM1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_LPTIM1EN_Enabled = 0x1
	// Position of DAC1EN field.
	RCC_APB1ENR1_DAC1EN_Pos = 0x1d
	// Bit mask of DAC1EN field.
	RCC_APB1ENR1_DAC1EN_Msk = 0x20000000
	// Bit DAC1EN.
	RCC_APB1ENR1_DAC1EN = 0x20000000
	// Clock disabled
	RCC_APB1ENR1_DAC1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_DAC1EN_Enabled = 0x1
	// Position of I2C3EN field.
	RCC_APB1ENR1_I2C3EN_Pos = 0x17
	// Bit mask of I2C3EN field.
	RCC_APB1ENR1_I2C3EN_Msk = 0x800000
	// Bit I2C3EN.
	RCC_APB1ENR1_I2C3EN = 0x800000
	// Clock disabled
	RCC_APB1ENR1_I2C3EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_I2C3EN_Enabled = 0x1
	// Position of I2C2EN field.
	RCC_APB1ENR1_I2C2EN_Pos = 0x16
	// Bit mask of I2C2EN field.
	RCC_APB1ENR1_I2C2EN_Msk = 0x400000
	// Bit I2C2EN.
	RCC_APB1ENR1_I2C2EN = 0x400000
	// Clock disabled
	RCC_APB1ENR1_I2C2EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_I2C2EN_Enabled = 0x1
	// Position of I2C1EN field.
	RCC_APB1ENR1_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_APB1ENR1_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_APB1ENR1_I2C1EN = 0x200000
	// Clock disabled
	RCC_APB1ENR1_I2C1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_I2C1EN_Enabled = 0x1
	// Position of USART2EN field.
	RCC_APB1ENR1_USART2EN_Pos = 0x11
	// Bit mask of USART2EN field.
	RCC_APB1ENR1_USART2EN_Msk = 0x20000
	// Bit USART2EN.
	RCC_APB1ENR1_USART2EN = 0x20000
	// Clock disabled
	RCC_APB1ENR1_USART2EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_USART2EN_Enabled = 0x1
	// Position of SPI2S2EN field.
	RCC_APB1ENR1_SPI2S2EN_Pos = 0xe
	// Bit mask of SPI2S2EN field.
	RCC_APB1ENR1_SPI2S2EN_Msk = 0x4000
	// Bit SPI2S2EN.
	RCC_APB1ENR1_SPI2S2EN = 0x4000
	// Clock disabled
	RCC_APB1ENR1_SPI2S2EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_SPI2S2EN_Enabled = 0x1
	// Position of WWDGEN field.
	RCC_APB1ENR1_WWDGEN_Pos = 0xb
	// Bit mask of WWDGEN field.
	RCC_APB1ENR1_WWDGEN_Msk = 0x800
	// Bit WWDGEN.
	RCC_APB1ENR1_WWDGEN = 0x800
	// Clock disabled
	RCC_APB1ENR1_WWDGEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_WWDGEN_Enabled = 0x1
	// Position of RTCAPBEN field.
	RCC_APB1ENR1_RTCAPBEN_Pos = 0xa
	// Bit mask of RTCAPBEN field.
	RCC_APB1ENR1_RTCAPBEN_Msk = 0x400
	// Bit RTCAPBEN.
	RCC_APB1ENR1_RTCAPBEN = 0x400
	// Clock disabled
	RCC_APB1ENR1_RTCAPBEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_RTCAPBEN_Enabled = 0x1
	// Position of TIM2EN field.
	RCC_APB1ENR1_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_APB1ENR1_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_APB1ENR1_TIM2EN = 0x1
	// Clock disabled
	RCC_APB1ENR1_TIM2EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR1_TIM2EN_Enabled = 0x1

	// APB1ENR2: APB1 peripheral clock enable register 2
	// Position of LPTIM3EN field.
	RCC_APB1ENR2_LPTIM3EN_Pos = 0x6
	// Bit mask of LPTIM3EN field.
	RCC_APB1ENR2_LPTIM3EN_Msk = 0x40
	// Bit LPTIM3EN.
	RCC_APB1ENR2_LPTIM3EN = 0x40
	// Clock disabled
	RCC_APB1ENR2_LPTIM3EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR2_LPTIM3EN_Enabled = 0x1
	// Position of LPTIM2EN field.
	RCC_APB1ENR2_LPTIM2EN_Pos = 0x5
	// Bit mask of LPTIM2EN field.
	RCC_APB1ENR2_LPTIM2EN_Msk = 0x20
	// Bit LPTIM2EN.
	RCC_APB1ENR2_LPTIM2EN = 0x20
	// Clock disabled
	RCC_APB1ENR2_LPTIM2EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR2_LPTIM2EN_Enabled = 0x1
	// Position of LPUART1EN field.
	RCC_APB1ENR2_LPUART1EN_Pos = 0x0
	// Bit mask of LPUART1EN field.
	RCC_APB1ENR2_LPUART1EN_Msk = 0x1
	// Bit LPUART1EN.
	RCC_APB1ENR2_LPUART1EN = 0x1
	// Clock disabled
	RCC_APB1ENR2_LPUART1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB1ENR2_LPUART1EN_Enabled = 0x1

	// APB2ENR: APB2 peripheral clock enable register
	// Position of TIM17EN field.
	RCC_APB2ENR_TIM17EN_Pos = 0x12
	// Bit mask of TIM17EN field.
	RCC_APB2ENR_TIM17EN_Msk = 0x40000
	// Bit TIM17EN.
	RCC_APB2ENR_TIM17EN = 0x40000
	// Clock disabled
	RCC_APB2ENR_TIM17EN_Disabled = 0x0
	// Clock enabled
	RCC_APB2ENR_TIM17EN_Enabled = 0x1
	// Position of TIM16EN field.
	RCC_APB2ENR_TIM16EN_Pos = 0x11
	// Bit mask of TIM16EN field.
	RCC_APB2ENR_TIM16EN_Msk = 0x20000
	// Bit TIM16EN.
	RCC_APB2ENR_TIM16EN = 0x20000
	// Clock disabled
	RCC_APB2ENR_TIM16EN_Disabled = 0x0
	// Clock enabled
	RCC_APB2ENR_TIM16EN_Enabled = 0x1
	// Position of USART1EN field.
	RCC_APB2ENR_USART1EN_Pos = 0xe
	// Bit mask of USART1EN field.
	RCC_APB2ENR_USART1EN_Msk = 0x4000
	// Bit USART1EN.
	RCC_APB2ENR_USART1EN = 0x4000
	// Clock disabled
	RCC_APB2ENR_USART1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB2ENR_USART1EN_Enabled = 0x1
	// Position of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_APB2ENR_SPI1EN = 0x1000
	// Clock disabled
	RCC_APB2ENR_SPI1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB2ENR_SPI1EN_Enabled = 0x1
	// Position of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Pos = 0xb
	// Bit mask of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Msk = 0x800
	// Bit TIM1EN.
	RCC_APB2ENR_TIM1EN = 0x800
	// Clock disabled
	RCC_APB2ENR_TIM1EN_Disabled = 0x0
	// Clock enabled
	RCC_APB2ENR_TIM1EN_Enabled = 0x1
	// Position of ADCEN field.
	RCC_APB2ENR_ADCEN_Pos = 0x9
	// Bit mask of ADCEN field.
	RCC_APB2ENR_ADCEN_Msk = 0x200
	// Bit ADCEN.
	RCC_APB2ENR_ADCEN = 0x200
	// Clock disabled
	RCC_APB2ENR_ADCEN_Disabled = 0x0
	// Clock enabled
	RCC_APB2ENR_ADCEN_Enabled = 0x1

	// APB3ENR: APB3 peripheral clock enable register
	// Position of SUBGHZSPIEN field.
	RCC_APB3ENR_SUBGHZSPIEN_Pos = 0x0
	// Bit mask of SUBGHZSPIEN field.
	RCC_APB3ENR_SUBGHZSPIEN_Msk = 0x1
	// Bit SUBGHZSPIEN.
	RCC_APB3ENR_SUBGHZSPIEN = 0x1
	// Clock disabled
	RCC_APB3ENR_SUBGHZSPIEN_Disabled = 0x0
	// Clock enabled
	RCC_APB3ENR_SUBGHZSPIEN_Enabled = 0x1

	// AHB1SMENR: AHB1 peripheral clocks enable in Sleep modes register
	// Position of CRCSMEN field.
	RCC_AHB1SMENR_CRCSMEN_Pos = 0xc
	// Bit mask of CRCSMEN field.
	RCC_AHB1SMENR_CRCSMEN_Msk = 0x1000
	// Bit CRCSMEN.
	RCC_AHB1SMENR_CRCSMEN = 0x1000
	// Position of DMAMUX1SMEN field.
	RCC_AHB1SMENR_DMAMUX1SMEN_Pos = 0x2
	// Bit mask of DMAMUX1SMEN field.
	RCC_AHB1SMENR_DMAMUX1SMEN_Msk = 0x4
	// Bit DMAMUX1SMEN.
	RCC_AHB1SMENR_DMAMUX1SMEN = 0x4
	// Position of DMA2SMEN field.
	RCC_AHB1SMENR_DMA2SMEN_Pos = 0x1
	// Bit mask of DMA2SMEN field.
	RCC_AHB1SMENR_DMA2SMEN_Msk = 0x2
	// Bit DMA2SMEN.
	RCC_AHB1SMENR_DMA2SMEN = 0x2
	// Position of DMA1SMEN field.
	RCC_AHB1SMENR_DMA1SMEN_Pos = 0x0
	// Bit mask of DMA1SMEN field.
	RCC_AHB1SMENR_DMA1SMEN_Msk = 0x1
	// Bit DMA1SMEN.
	RCC_AHB1SMENR_DMA1SMEN = 0x1

	// AHB2SMENR: AHB2 peripheral clocks enable in Sleep modes register
	// Position of GPIOHSMEN field.
	RCC_AHB2SMENR_GPIOHSMEN_Pos = 0x7
	// Bit mask of GPIOHSMEN field.
	RCC_AHB2SMENR_GPIOHSMEN_Msk = 0x80
	// Bit GPIOHSMEN.
	RCC_AHB2SMENR_GPIOHSMEN = 0x80
	// Position of GPIOCSMEN field.
	RCC_AHB2SMENR_GPIOCSMEN_Pos = 0x2
	// Bit mask of GPIOCSMEN field.
	RCC_AHB2SMENR_GPIOCSMEN_Msk = 0x4
	// Bit GPIOCSMEN.
	RCC_AHB2SMENR_GPIOCSMEN = 0x4
	// Position of GPIOBSMEN field.
	RCC_AHB2SMENR_GPIOBSMEN_Pos = 0x1
	// Bit mask of GPIOBSMEN field.
	RCC_AHB2SMENR_GPIOBSMEN_Msk = 0x2
	// Bit GPIOBSMEN.
	RCC_AHB2SMENR_GPIOBSMEN = 0x2
	// Position of GPIOASMEN field.
	RCC_AHB2SMENR_GPIOASMEN_Pos = 0x0
	// Bit mask of GPIOASMEN field.
	RCC_AHB2SMENR_GPIOASMEN_Msk = 0x1
	// Bit GPIOASMEN.
	RCC_AHB2SMENR_GPIOASMEN = 0x1

	// AHB3SMENR: AHB3 peripheral clocks enable in Sleep and Stop modes register
	// Position of FLASHSMEN field.
	RCC_AHB3SMENR_FLASHSMEN_Pos = 0x19
	// Bit mask of FLASHSMEN field.
	RCC_AHB3SMENR_FLASHSMEN_Msk = 0x2000000
	// Bit FLASHSMEN.
	RCC_AHB3SMENR_FLASHSMEN = 0x2000000
	// Position of SRAM2SMEN field.
	RCC_AHB3SMENR_SRAM2SMEN_Pos = 0x18
	// Bit mask of SRAM2SMEN field.
	RCC_AHB3SMENR_SRAM2SMEN_Msk = 0x1000000
	// Bit SRAM2SMEN.
	RCC_AHB3SMENR_SRAM2SMEN = 0x1000000
	// Position of SRAM1SMEN field.
	RCC_AHB3SMENR_SRAM1SMEN_Pos = 0x17
	// Bit mask of SRAM1SMEN field.
	RCC_AHB3SMENR_SRAM1SMEN_Msk = 0x800000
	// Bit SRAM1SMEN.
	RCC_AHB3SMENR_SRAM1SMEN = 0x800000
	// Position of RNGSMEN field.
	RCC_AHB3SMENR_RNGSMEN_Pos = 0x12
	// Bit mask of RNGSMEN field.
	RCC_AHB3SMENR_RNGSMEN_Msk = 0x40000
	// Bit RNGSMEN.
	RCC_AHB3SMENR_RNGSMEN = 0x40000
	// Position of AESSMEN field.
	RCC_AHB3SMENR_AESSMEN_Pos = 0x11
	// Bit mask of AESSMEN field.
	RCC_AHB3SMENR_AESSMEN_Msk = 0x20000
	// Bit AESSMEN.
	RCC_AHB3SMENR_AESSMEN = 0x20000
	// Position of PKASMEN field.
	RCC_AHB3SMENR_PKASMEN_Pos = 0x10
	// Bit mask of PKASMEN field.
	RCC_AHB3SMENR_PKASMEN_Msk = 0x10000
	// Bit PKASMEN.
	RCC_AHB3SMENR_PKASMEN = 0x10000

	// APB1SMENR1: APB1 peripheral clocks enable in Sleep mode register 1
	// Position of LPTIM1SMEN field.
	RCC_APB1SMENR1_LPTIM1SMEN_Pos = 0x1f
	// Bit mask of LPTIM1SMEN field.
	RCC_APB1SMENR1_LPTIM1SMEN_Msk = 0x80000000
	// Bit LPTIM1SMEN.
	RCC_APB1SMENR1_LPTIM1SMEN = 0x80000000
	// Clock disabled
	RCC_APB1SMENR1_LPTIM1SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_LPTIM1SMEN_Enabled = 0x1
	// Position of DACSMEN field.
	RCC_APB1SMENR1_DACSMEN_Pos = 0x1d
	// Bit mask of DACSMEN field.
	RCC_APB1SMENR1_DACSMEN_Msk = 0x20000000
	// Bit DACSMEN.
	RCC_APB1SMENR1_DACSMEN = 0x20000000
	// Clock disabled
	RCC_APB1SMENR1_DACSMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_DACSMEN_Enabled = 0x1
	// Position of I2C3SMEN field.
	RCC_APB1SMENR1_I2C3SMEN_Pos = 0x17
	// Bit mask of I2C3SMEN field.
	RCC_APB1SMENR1_I2C3SMEN_Msk = 0x800000
	// Bit I2C3SMEN.
	RCC_APB1SMENR1_I2C3SMEN = 0x800000
	// Clock disabled
	RCC_APB1SMENR1_I2C3SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_I2C3SMEN_Enabled = 0x1
	// Position of I2C2SMEN field.
	RCC_APB1SMENR1_I2C2SMEN_Pos = 0x16
	// Bit mask of I2C2SMEN field.
	RCC_APB1SMENR1_I2C2SMEN_Msk = 0x400000
	// Bit I2C2SMEN.
	RCC_APB1SMENR1_I2C2SMEN = 0x400000
	// Clock disabled
	RCC_APB1SMENR1_I2C2SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_I2C2SMEN_Enabled = 0x1
	// Position of I2C1SMEN field.
	RCC_APB1SMENR1_I2C1SMEN_Pos = 0x15
	// Bit mask of I2C1SMEN field.
	RCC_APB1SMENR1_I2C1SMEN_Msk = 0x200000
	// Bit I2C1SMEN.
	RCC_APB1SMENR1_I2C1SMEN = 0x200000
	// Clock disabled
	RCC_APB1SMENR1_I2C1SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_I2C1SMEN_Enabled = 0x1
	// Position of USART2SMEN field.
	RCC_APB1SMENR1_USART2SMEN_Pos = 0x11
	// Bit mask of USART2SMEN field.
	RCC_APB1SMENR1_USART2SMEN_Msk = 0x20000
	// Bit USART2SMEN.
	RCC_APB1SMENR1_USART2SMEN = 0x20000
	// Clock disabled
	RCC_APB1SMENR1_USART2SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_USART2SMEN_Enabled = 0x1
	// Position of SPI2S2SMEN field.
	RCC_APB1SMENR1_SPI2S2SMEN_Pos = 0xe
	// Bit mask of SPI2S2SMEN field.
	RCC_APB1SMENR1_SPI2S2SMEN_Msk = 0x4000
	// Bit SPI2S2SMEN.
	RCC_APB1SMENR1_SPI2S2SMEN = 0x4000
	// Clock disabled
	RCC_APB1SMENR1_SPI2S2SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_SPI2S2SMEN_Enabled = 0x1
	// Position of WWDGSMEN field.
	RCC_APB1SMENR1_WWDGSMEN_Pos = 0xb
	// Bit mask of WWDGSMEN field.
	RCC_APB1SMENR1_WWDGSMEN_Msk = 0x800
	// Bit WWDGSMEN.
	RCC_APB1SMENR1_WWDGSMEN = 0x800
	// Clock disabled
	RCC_APB1SMENR1_WWDGSMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_WWDGSMEN_Enabled = 0x1
	// Position of RTCAPBSMEN field.
	RCC_APB1SMENR1_RTCAPBSMEN_Pos = 0xa
	// Bit mask of RTCAPBSMEN field.
	RCC_APB1SMENR1_RTCAPBSMEN_Msk = 0x400
	// Bit RTCAPBSMEN.
	RCC_APB1SMENR1_RTCAPBSMEN = 0x400
	// Clock disabled
	RCC_APB1SMENR1_RTCAPBSMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_RTCAPBSMEN_Enabled = 0x1
	// Position of TIM2SMEN field.
	RCC_APB1SMENR1_TIM2SMEN_Pos = 0x0
	// Bit mask of TIM2SMEN field.
	RCC_APB1SMENR1_TIM2SMEN_Msk = 0x1
	// Bit TIM2SMEN.
	RCC_APB1SMENR1_TIM2SMEN = 0x1
	// Clock disabled
	RCC_APB1SMENR1_TIM2SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR1_TIM2SMEN_Enabled = 0x1

	// APB1SMENR2: APB1 peripheral clocks enable in Sleep mode register 2
	// Position of LPTIM3SMEN field.
	RCC_APB1SMENR2_LPTIM3SMEN_Pos = 0x6
	// Bit mask of LPTIM3SMEN field.
	RCC_APB1SMENR2_LPTIM3SMEN_Msk = 0x40
	// Bit LPTIM3SMEN.
	RCC_APB1SMENR2_LPTIM3SMEN = 0x40
	// Clock disabled
	RCC_APB1SMENR2_LPTIM3SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR2_LPTIM3SMEN_Enabled = 0x1
	// Position of LPTIM2SMEN field.
	RCC_APB1SMENR2_LPTIM2SMEN_Pos = 0x5
	// Bit mask of LPTIM2SMEN field.
	RCC_APB1SMENR2_LPTIM2SMEN_Msk = 0x20
	// Bit LPTIM2SMEN.
	RCC_APB1SMENR2_LPTIM2SMEN = 0x20
	// Clock disabled
	RCC_APB1SMENR2_LPTIM2SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR2_LPTIM2SMEN_Enabled = 0x1
	// Position of LPUART1SMEN field.
	RCC_APB1SMENR2_LPUART1SMEN_Pos = 0x0
	// Bit mask of LPUART1SMEN field.
	RCC_APB1SMENR2_LPUART1SMEN_Msk = 0x1
	// Bit LPUART1SMEN.
	RCC_APB1SMENR2_LPUART1SMEN = 0x1
	// Clock disabled
	RCC_APB1SMENR2_LPUART1SMEN_Disabled = 0x0
	// Clock enabled
	RCC_APB1SMENR2_LPUART1SMEN_Enabled = 0x1

	// APB2SMENR: APB2 peripheral clocks enable in Sleep mode register
	// Position of TIM17SMEN field.
	RCC_APB2SMENR_TIM17SMEN_Pos = 0x12
	// Bit mask of TIM17SMEN field.
	RCC_APB2SMENR_TIM17SMEN_Msk = 0x40000
	// Bit TIM17SMEN.
	RCC_APB2SMENR_TIM17SMEN = 0x40000
	// Position of TIM16SMEN field.
	RCC_APB2SMENR_TIM16SMEN_Pos = 0x11
	// Bit mask of TIM16SMEN field.
	RCC_APB2SMENR_TIM16SMEN_Msk = 0x20000
	// Bit TIM16SMEN.
	RCC_APB2SMENR_TIM16SMEN = 0x20000
	// Position of USART1SMEN field.
	RCC_APB2SMENR_USART1SMEN_Pos = 0xe
	// Bit mask of USART1SMEN field.
	RCC_APB2SMENR_USART1SMEN_Msk = 0x4000
	// Bit USART1SMEN.
	RCC_APB2SMENR_USART1SMEN = 0x4000
	// Position of SPI1SMEN field.
	RCC_APB2SMENR_SPI1SMEN_Pos = 0xc
	// Bit mask of SPI1SMEN field.
	RCC_APB2SMENR_SPI1SMEN_Msk = 0x1000
	// Bit SPI1SMEN.
	RCC_APB2SMENR_SPI1SMEN = 0x1000
	// Position of TIM1SMEN field.
	RCC_APB2SMENR_TIM1SMEN_Pos = 0xb
	// Bit mask of TIM1SMEN field.
	RCC_APB2SMENR_TIM1SMEN_Msk = 0x800
	// Bit TIM1SMEN.
	RCC_APB2SMENR_TIM1SMEN = 0x800
	// Position of ADCSMEN field.
	RCC_APB2SMENR_ADCSMEN_Pos = 0x9
	// Bit mask of ADCSMEN field.
	RCC_APB2SMENR_ADCSMEN_Msk = 0x200
	// Bit ADCSMEN.
	RCC_APB2SMENR_ADCSMEN = 0x200

	// APB3SMENR: APB3 peripheral clock enable in Sleep mode register
	// Position of SUBGHZSPISMEN field.
	RCC_APB3SMENR_SUBGHZSPISMEN_Pos = 0x0
	// Bit mask of SUBGHZSPISMEN field.
	RCC_APB3SMENR_SUBGHZSPISMEN_Msk = 0x1
	// Bit SUBGHZSPISMEN.
	RCC_APB3SMENR_SUBGHZSPISMEN = 0x1

	// CCIPR: Peripherals independent clock configuration register
	// Position of RNGSEL field.
	RCC_CCIPR_RNGSEL_Pos = 0x1e
	// Bit mask of RNGSEL field.
	RCC_CCIPR_RNGSEL_Msk = 0xc0000000
	// PLLQ clock selected
	RCC_CCIPR_RNGSEL_PLLQ = 0x0
	// LSI clock selected
	RCC_CCIPR_RNGSEL_LSI = 0x1
	// LSE clock selected
	RCC_CCIPR_RNGSEL_LSE = 0x2
	// MSI clock selected
	RCC_CCIPR_RNGSEL_MSI = 0x3
	// Position of ADCSEL field.
	RCC_CCIPR_ADCSEL_Pos = 0x1c
	// Bit mask of ADCSEL field.
	RCC_CCIPR_ADCSEL_Msk = 0x30000000
	// No clock selected
	RCC_CCIPR_ADCSEL_NoClock = 0x0
	// HSI16 clock selected
	RCC_CCIPR_ADCSEL_HSI16 = 0x1
	// PLLP clock selected
	RCC_CCIPR_ADCSEL_PLLP = 0x2
	// SYSCLK clock selected
	RCC_CCIPR_ADCSEL_SYSCLK = 0x3
	// Position of LPTIM3SEL field.
	RCC_CCIPR_LPTIM3SEL_Pos = 0x16
	// Bit mask of LPTIM3SEL field.
	RCC_CCIPR_LPTIM3SEL_Msk = 0xc00000
	// PCLK clock selected
	RCC_CCIPR_LPTIM3SEL_PCLK = 0x0
	// LSI clock selected
	RCC_CCIPR_LPTIM3SEL_LSI = 0x1
	// HSI16 clock selected
	RCC_CCIPR_LPTIM3SEL_HSI16 = 0x2
	// LSE clock selected
	RCC_CCIPR_LPTIM3SEL_LSE = 0x3
	// Position of LPTIM2SEL field.
	RCC_CCIPR_LPTIM2SEL_Pos = 0x14
	// Bit mask of LPTIM2SEL field.
	RCC_CCIPR_LPTIM2SEL_Msk = 0x300000
	// PCLK clock selected
	RCC_CCIPR_LPTIM2SEL_PCLK = 0x0
	// LSI clock selected
	RCC_CCIPR_LPTIM2SEL_LSI = 0x1
	// HSI16 clock selected
	RCC_CCIPR_LPTIM2SEL_HSI16 = 0x2
	// LSE clock selected
	RCC_CCIPR_LPTIM2SEL_LSE = 0x3
	// Position of LPTIM1SEL field.
	RCC_CCIPR_LPTIM1SEL_Pos = 0x12
	// Bit mask of LPTIM1SEL field.
	RCC_CCIPR_LPTIM1SEL_Msk = 0xc0000
	// PCLK clock selected
	RCC_CCIPR_LPTIM1SEL_PCLK = 0x0
	// LSI clock selected
	RCC_CCIPR_LPTIM1SEL_LSI = 0x1
	// HSI16 clock selected
	RCC_CCIPR_LPTIM1SEL_HSI16 = 0x2
	// LSE clock selected
	RCC_CCIPR_LPTIM1SEL_LSE = 0x3
	// Position of I2C3SEL field.
	RCC_CCIPR_I2C3SEL_Pos = 0x10
	// Bit mask of I2C3SEL field.
	RCC_CCIPR_I2C3SEL_Msk = 0x30000
	// PCLK clock selected
	RCC_CCIPR_I2C3SEL_PCLK = 0x0
	// SYSCLK clock selected
	RCC_CCIPR_I2C3SEL_SYSCLK = 0x1
	// HSI16 clock selected
	RCC_CCIPR_I2C3SEL_HSI16 = 0x2
	// Position of I2C2SEL field.
	RCC_CCIPR_I2C2SEL_Pos = 0xe
	// Bit mask of I2C2SEL field.
	RCC_CCIPR_I2C2SEL_Msk = 0xc000
	// PCLK clock selected
	RCC_CCIPR_I2C2SEL_PCLK = 0x0
	// SYSCLK clock selected
	RCC_CCIPR_I2C2SEL_SYSCLK = 0x1
	// HSI16 clock selected
	RCC_CCIPR_I2C2SEL_HSI16 = 0x2
	// Position of I2C1SEL field.
	RCC_CCIPR_I2C1SEL_Pos = 0xc
	// Bit mask of I2C1SEL field.
	RCC_CCIPR_I2C1SEL_Msk = 0x3000
	// PCLK clock selected
	RCC_CCIPR_I2C1SEL_PCLK = 0x0
	// SYSCLK clock selected
	RCC_CCIPR_I2C1SEL_SYSCLK = 0x1
	// HSI16 clock selected
	RCC_CCIPR_I2C1SEL_HSI16 = 0x2
	// Position of LPUART1SEL field.
	RCC_CCIPR_LPUART1SEL_Pos = 0xa
	// Bit mask of LPUART1SEL field.
	RCC_CCIPR_LPUART1SEL_Msk = 0xc00
	// PCLK clock selected
	RCC_CCIPR_LPUART1SEL_PCLK = 0x0
	// SYSCLK clock selected
	RCC_CCIPR_LPUART1SEL_SYSCLK = 0x1
	// HSI16 clock selected
	RCC_CCIPR_LPUART1SEL_HSI16 = 0x2
	// LSE clock selected
	RCC_CCIPR_LPUART1SEL_LSE = 0x3
	// Position of SPI2S2SEL field.
	RCC_CCIPR_SPI2S2SEL_Pos = 0x8
	// Bit mask of SPI2S2SEL field.
	RCC_CCIPR_SPI2S2SEL_Msk = 0x300
	// PLLQ clock selected
	RCC_CCIPR_SPI2S2SEL_PLLQ = 0x1
	// HSI16 clock selected
	RCC_CCIPR_SPI2S2SEL_HSI16 = 0x2
	// External input I2S_CKIN selected
	RCC_CCIPR_SPI2S2SEL_I2S = 0x3
	// Position of USART2SEL field.
	RCC_CCIPR_USART2SEL_Pos = 0x2
	// Bit mask of USART2SEL field.
	RCC_CCIPR_USART2SEL_Msk = 0xc
	// PCLK clock selected
	RCC_CCIPR_USART2SEL_PCLK = 0x0
	// SYSCLK clock selected
	RCC_CCIPR_USART2SEL_SYSCLK = 0x1
	// HSI16 clock selected
	RCC_CCIPR_USART2SEL_HSI16 = 0x2
	// LSE clock selected
	RCC_CCIPR_USART2SEL_LSE = 0x3
	// Position of USART1SEL field.
	RCC_CCIPR_USART1SEL_Pos = 0x0
	// Bit mask of USART1SEL field.
	RCC_CCIPR_USART1SEL_Msk = 0x3
	// PCLK clock selected
	RCC_CCIPR_USART1SEL_PCLK = 0x0
	// SYSCLK clock selected
	RCC_CCIPR_USART1SEL_SYSCLK = 0x1
	// HSI16 clock selected
	RCC_CCIPR_USART1SEL_HSI16 = 0x2
	// LSE clock selected
	RCC_CCIPR_USART1SEL_LSE = 0x3

	// BDCR: Backup domain control register
	// Position of LSCOSEL field.
	RCC_BDCR_LSCOSEL_Pos = 0x19
	// Bit mask of LSCOSEL field.
	RCC_BDCR_LSCOSEL_Msk = 0x2000000
	// Bit LSCOSEL.
	RCC_BDCR_LSCOSEL = 0x2000000
	// LSI clock selected
	RCC_BDCR_LSCOSEL_LSI = 0x0
	// LSE clock selected
	RCC_BDCR_LSCOSEL_LSE = 0x1
	// Position of LSCOEN field.
	RCC_BDCR_LSCOEN_Pos = 0x18
	// Bit mask of LSCOEN field.
	RCC_BDCR_LSCOEN_Msk = 0x1000000
	// Bit LSCOEN.
	RCC_BDCR_LSCOEN = 0x1000000
	// LSCO disabled
	RCC_BDCR_LSCOEN_Disabled = 0x0
	// LSCO enabled
	RCC_BDCR_LSCOEN_Enabled = 0x1
	// Position of BDRST field.
	RCC_BDCR_BDRST_Pos = 0x10
	// Bit mask of BDRST field.
	RCC_BDCR_BDRST_Msk = 0x10000
	// Bit BDRST.
	RCC_BDCR_BDRST = 0x10000
	// Reset not activated
	RCC_BDCR_BDRST_NotActive = 0x0
	// Entire Backup domain reset
	RCC_BDCR_BDRST_Reset = 0x1
	// Position of RTCEN field.
	RCC_BDCR_RTCEN_Pos = 0xf
	// Bit mask of RTCEN field.
	RCC_BDCR_RTCEN_Msk = 0x8000
	// Bit RTCEN.
	RCC_BDCR_RTCEN = 0x8000
	// RTC kernel clock disabled
	RCC_BDCR_RTCEN_Disabled = 0x0
	// RTC kernel clock enabled
	RCC_BDCR_RTCEN_Enabled = 0x1
	// Position of LSESYSRDY field.
	RCC_BDCR_LSESYSRDY_Pos = 0xb
	// Bit mask of LSESYSRDY field.
	RCC_BDCR_LSESYSRDY_Msk = 0x800
	// Bit LSESYSRDY.
	RCC_BDCR_LSESYSRDY = 0x800
	// LSE system clock not ready
	RCC_BDCR_LSESYSRDY_NotReady = 0x0
	// LSE system clock ready
	RCC_BDCR_LSESYSRDY_Ready = 0x1
	// Position of RTCSEL field.
	RCC_BDCR_RTCSEL_Pos = 0x8
	// Bit mask of RTCSEL field.
	RCC_BDCR_RTCSEL_Msk = 0x300
	// No clock
	RCC_BDCR_RTCSEL_NoClock = 0x0
	// LSE oscillator clock selected
	RCC_BDCR_RTCSEL_LSE = 0x1
	// LSI oscillator clock selected
	RCC_BDCR_RTCSEL_LSI = 0x2
	// HSE32 oscillator clock divided by 32 selected
	RCC_BDCR_RTCSEL_HSE32 = 0x3
	// Position of LSESYSEN field.
	RCC_BDCR_LSESYSEN_Pos = 0x7
	// Bit mask of LSESYSEN field.
	RCC_BDCR_LSESYSEN_Msk = 0x80
	// Bit LSESYSEN.
	RCC_BDCR_LSESYSEN = 0x80
	// LSE system clock disabled to USARTx, LPUARTx, LPTIMx, TIMx, RNG, system LSCO, MCO, MSI PLL mode
	RCC_BDCR_LSESYSEN_Disabled = 0x0
	// LSE system clock enabled to USARTx, LPUARTx, LPTIMx, TIMx, RNG, system LSCO, MCO, MSI PLL mode
	RCC_BDCR_LSESYSEN_Enabled = 0x1
	// Position of LSECSSD field.
	RCC_BDCR_LSECSSD_Pos = 0x6
	// Bit mask of LSECSSD field.
	RCC_BDCR_LSECSSD_Msk = 0x40
	// Bit LSECSSD.
	RCC_BDCR_LSECSSD = 0x40
	// No failure detected on LSE
	RCC_BDCR_LSECSSD_NoFailure = 0x0
	// Failure detected on LSE
	RCC_BDCR_LSECSSD_Failure = 0x1
	// Position of LSECSSON field.
	RCC_BDCR_LSECSSON_Pos = 0x5
	// Bit mask of LSECSSON field.
	RCC_BDCR_LSECSSON_Msk = 0x20
	// Bit LSECSSON.
	RCC_BDCR_LSECSSON = 0x20
	// CSS on LSE disabled
	RCC_BDCR_LSECSSON_Disabled = 0x0
	// CSS on LSE enabled
	RCC_BDCR_LSECSSON_Enabled = 0x1
	// Position of LSEDRV field.
	RCC_BDCR_LSEDRV_Pos = 0x3
	// Bit mask of LSEDRV field.
	RCC_BDCR_LSEDRV_Msk = 0x18
	// Xtal mode lower driving capability
	RCC_BDCR_LSEDRV_Low = 0x0
	// Xtal mode medium-low driving capability
	RCC_BDCR_LSEDRV_MedLow = 0x1
	// Xtal mode medium-high driving capability
	RCC_BDCR_LSEDRV_MedHigh = 0x2
	// Xtal mode higher driving capability
	RCC_BDCR_LSEDRV_High = 0x3
	// Position of LSEBYP field.
	RCC_BDCR_LSEBYP_Pos = 0x2
	// Bit mask of LSEBYP field.
	RCC_BDCR_LSEBYP_Msk = 0x4
	// Bit LSEBYP.
	RCC_BDCR_LSEBYP = 0x4
	// LSE oscillator not bypassed
	RCC_BDCR_LSEBYP_Disabled = 0x0
	// LSE oscillator bypassed
	RCC_BDCR_LSEBYP_Enabled = 0x1
	// Position of LSERDY field.
	RCC_BDCR_LSERDY_Pos = 0x1
	// Bit mask of LSERDY field.
	RCC_BDCR_LSERDY_Msk = 0x2
	// Bit LSERDY.
	RCC_BDCR_LSERDY = 0x2
	// LSE oscillator not ready
	RCC_BDCR_LSERDY_NotReady = 0x0
	// LSE oscillator ready
	RCC_BDCR_LSERDY_Ready = 0x1
	// Position of LSEON field.
	RCC_BDCR_LSEON_Pos = 0x0
	// Bit mask of LSEON field.
	RCC_BDCR_LSEON_Msk = 0x1
	// Bit LSEON.
	RCC_BDCR_LSEON = 0x1
	// LSE oscillator off
	RCC_BDCR_LSEON_Off = 0x0
	// LSE oscillator on
	RCC_BDCR_LSEON_On = 0x1

	// CSR: Control/status register
	// Position of LPWRRSTF field.
	RCC_CSR_LPWRRSTF_Pos = 0x1f
	// Bit mask of LPWRRSTF field.
	RCC_CSR_LPWRRSTF_Msk = 0x80000000
	// Bit LPWRRSTF.
	RCC_CSR_LPWRRSTF = 0x80000000
	// No reset occurred
	RCC_CSR_LPWRRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_LPWRRSTF_Reset = 0x1
	// Position of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Pos = 0x1e
	// Bit mask of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Msk = 0x40000000
	// Bit WWDGRSTF.
	RCC_CSR_WWDGRSTF = 0x40000000
	// No reset occurred
	RCC_CSR_WWDGRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_WWDGRSTF_Reset = 0x1
	// Position of IWDGRSTF field.
	RCC_CSR_IWDGRSTF_Pos = 0x1d
	// Bit mask of IWDGRSTF field.
	RCC_CSR_IWDGRSTF_Msk = 0x20000000
	// Bit IWDGRSTF.
	RCC_CSR_IWDGRSTF = 0x20000000
	// No reset occurred
	RCC_CSR_IWDGRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_IWDGRSTF_Reset = 0x1
	// Position of SFTRSTF field.
	RCC_CSR_SFTRSTF_Pos = 0x1c
	// Bit mask of SFTRSTF field.
	RCC_CSR_SFTRSTF_Msk = 0x10000000
	// Bit SFTRSTF.
	RCC_CSR_SFTRSTF = 0x10000000
	// No reset occurred
	RCC_CSR_SFTRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_SFTRSTF_Reset = 0x1
	// Position of BORRSTF field.
	RCC_CSR_BORRSTF_Pos = 0x1b
	// Bit mask of BORRSTF field.
	RCC_CSR_BORRSTF_Msk = 0x8000000
	// Bit BORRSTF.
	RCC_CSR_BORRSTF = 0x8000000
	// No reset occurred
	RCC_CSR_BORRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_BORRSTF_Reset = 0x1
	// Position of PINRSTF field.
	RCC_CSR_PINRSTF_Pos = 0x1a
	// Bit mask of PINRSTF field.
	RCC_CSR_PINRSTF_Msk = 0x4000000
	// Bit PINRSTF.
	RCC_CSR_PINRSTF = 0x4000000
	// No reset occurred
	RCC_CSR_PINRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_PINRSTF_Reset = 0x1
	// Position of OBLRSTF field.
	RCC_CSR_OBLRSTF_Pos = 0x19
	// Bit mask of OBLRSTF field.
	RCC_CSR_OBLRSTF_Msk = 0x2000000
	// Bit OBLRSTF.
	RCC_CSR_OBLRSTF = 0x2000000
	// No reset occurred
	RCC_CSR_OBLRSTF_NoReset = 0x0
	// Reset occurred
	RCC_CSR_OBLRSTF_Reset = 0x1
	// Position of RFILARSTF field.
	RCC_CSR_RFILARSTF_Pos = 0x18
	// Bit mask of RFILARSTF field.
	RCC_CSR_RFILARSTF_Msk = 0x1000000
	// Bit RFILARSTF.
	RCC_CSR_RFILARSTF = 0x1000000
	// No SUBGHZ radio illegal command occurred
	RCC_CSR_RFILARSTF_NoIllegalCommand = 0x0
	// SUBGHZ radio illegal command occurred
	RCC_CSR_RFILARSTF_IllegalCommand = 0x1
	// Position of RMVF field.
	RCC_CSR_RMVF_Pos = 0x17
	// Bit mask of RMVF field.
	RCC_CSR_RMVF_Msk = 0x800000
	// Bit RMVF.
	RCC_CSR_RMVF = 0x800000
	// No effect
	RCC_CSR_RMVF_NoEffect = 0x0
	// Reset flags reset
	RCC_CSR_RMVF_Clear = 0x1
	// Position of RFRST field.
	RCC_CSR_RFRST_Pos = 0xf
	// Bit mask of RFRST field.
	RCC_CSR_RFRST_Msk = 0x8000
	// Bit RFRST.
	RCC_CSR_RFRST = 0x8000
	// Sub-GHz radio software reset removed
	RCC_CSR_RFRST_Removed = 0x0
	// Sub-GHz radio software reset active
	RCC_CSR_RFRST_Reset = 0x1
	// Position of RFRSTF field.
	RCC_CSR_RFRSTF_Pos = 0xe
	// Bit mask of RFRSTF field.
	RCC_CSR_RFRSTF_Msk = 0x4000
	// Bit RFRSTF.
	RCC_CSR_RFRSTF = 0x4000
	// Sub-GHz radio out of reset
	RCC_CSR_RFRSTF_NoReset = 0x0
	// Sub-GHz radio in reset
	RCC_CSR_RFRSTF_Reset = 0x1
	// Position of MSISRANGE field.
	RCC_CSR_MSISRANGE_Pos = 0x8
	// Bit mask of MSISRANGE field.
	RCC_CSR_MSISRANGE_Msk = 0xf00
	// Range 4 around 1 MHz
	RCC_CSR_MSISRANGE_F_1MHZ = 0x4
	// Range 5 around 2 MHz
	RCC_CSR_MSISRANGE_F_2MHZ = 0x5
	// Range 6 around 4 MHz (reset value)
	RCC_CSR_MSISRANGE_F_4MHZ = 0x6
	// Range 7 around 8 MHz
	RCC_CSR_MSISRANGE_F_8MHZ = 0x7
	// Position of LSIPRE field.
	RCC_CSR_LSIPRE_Pos = 0x4
	// Bit mask of LSIPRE field.
	RCC_CSR_LSIPRE_Msk = 0x10
	// Bit LSIPRE.
	RCC_CSR_LSIPRE = 0x10
	// LSI clock not divided
	RCC_CSR_LSIPRE_Div1 = 0x0
	// LSI clock divided by 128
	RCC_CSR_LSIPRE_Div128 = 0x1
	// Position of LSIRDY field.
	RCC_CSR_LSIRDY_Pos = 0x1
	// Bit mask of LSIRDY field.
	RCC_CSR_LSIRDY_Msk = 0x2
	// Bit LSIRDY.
	RCC_CSR_LSIRDY = 0x2
	// LSI oscillator not ready
	RCC_CSR_LSIRDY_NotReady = 0x0
	// LSI oscillator ready
	RCC_CSR_LSIRDY_Ready = 0x1
	// Position of LSION field.
	RCC_CSR_LSION_Pos = 0x0
	// Bit mask of LSION field.
	RCC_CSR_LSION_Msk = 0x1
	// Bit LSION.
	RCC_CSR_LSION = 0x1
	// LSI oscillator off
	RCC_CSR_LSION_Off = 0x0
	// LSI oscillator on
	RCC_CSR_LSION_On = 0x1

	// EXTCFGR: Extended clock recovery register
	// Position of SHDHPREF field.
	RCC_EXTCFGR_SHDHPREF_Pos = 0x10
	// Bit mask of SHDHPREF field.
	RCC_EXTCFGR_SHDHPREF_Msk = 0x10000
	// Bit SHDHPREF.
	RCC_EXTCFGR_SHDHPREF = 0x10000
	// HCLK3 prescaler value not yet applied
	RCC_EXTCFGR_SHDHPREF_NotApplied = 0x0
	// HCLK3 prescaler value applied
	RCC_EXTCFGR_SHDHPREF_Applied = 0x1
	// Position of SHDHPRE field.
	RCC_EXTCFGR_SHDHPRE_Pos = 0x0
	// Bit mask of SHDHPRE field.
	RCC_EXTCFGR_SHDHPRE_Msk = 0xf
	// SYSCLK not divided
	RCC_EXTCFGR_SHDHPRE_Div1 = 0x0
	// SYSCLK divided by 3
	RCC_EXTCFGR_SHDHPRE_Div3 = 0x1
	// SYSCLK divided by 5
	RCC_EXTCFGR_SHDHPRE_Div5 = 0x2
	// SYSCLK divided by 6
	RCC_EXTCFGR_SHDHPRE_Div6 = 0x5
	// SYSCLK divided by 10
	RCC_EXTCFGR_SHDHPRE_Div10 = 0x6
	// SYSCLK divided by 32
	RCC_EXTCFGR_SHDHPRE_Div32 = 0x7
	// SYSCLK divided by 2
	RCC_EXTCFGR_SHDHPRE_Div2 = 0x8
	// SYSCLK divided by 4
	RCC_EXTCFGR_SHDHPRE_Div4 = 0x9
	// SYSCLK divided by 8
	RCC_EXTCFGR_SHDHPRE_Div8 = 0xa
	// SYSCLK divided by 16
	RCC_EXTCFGR_SHDHPRE_Div16 = 0xb
	// SYSCLK divided by 64
	RCC_EXTCFGR_SHDHPRE_Div64 = 0xc
	// SYSCLK divided by 128
	RCC_EXTCFGR_SHDHPRE_Div128 = 0xd
	// SYSCLK divided by 128
	RCC_EXTCFGR_SHDHPRE_Div256 = 0xe
	// SYSCLK divided by 512
	RCC_EXTCFGR_SHDHPRE_Div512 = 0xf
)

// Constants for RNG: True random number generator
const (
	// CR: control register
	// Position of RNGEN field.
	RNG_CR_RNGEN_Pos = 0x2
	// Bit mask of RNGEN field.
	RNG_CR_RNGEN_Msk = 0x4
	// Bit RNGEN.
	RNG_CR_RNGEN = 0x4
	// Random number generator is disabled
	RNG_CR_RNGEN_Disabled = 0x0
	// Random number generator is enabled
	RNG_CR_RNGEN_Enabled = 0x1
	// Position of IE field.
	RNG_CR_IE_Pos = 0x3
	// Bit mask of IE field.
	RNG_CR_IE_Msk = 0x8
	// Bit IE.
	RNG_CR_IE = 0x8
	// RNG interrupt is disabled
	RNG_CR_IE_Disabled = 0x0
	// RNG interrupt is enabled
	RNG_CR_IE_Enabled = 0x1
	// Position of CED field.
	RNG_CR_CED_Pos = 0x5
	// Bit mask of CED field.
	RNG_CR_CED_Msk = 0x20
	// Bit CED.
	RNG_CR_CED = 0x20
	// Clock error detection is enabled
	RNG_CR_CED_Enabled = 0x0
	// Clock error detection is disabled
	RNG_CR_CED_Disabled = 0x1
	// Position of RNG_CONFIG3 field.
	RNG_CR_RNG_CONFIG3_Pos = 0x8
	// Bit mask of RNG_CONFIG3 field.
	RNG_CR_RNG_CONFIG3_Msk = 0xf00
	// Recommended value for config A (NIST certifiable)
	RNG_CR_RNG_CONFIG3_ConfigA = 0xd
	// Recommended value for config B (not NIST certifiable)
	RNG_CR_RNG_CONFIG3_ConfigB = 0x0
	// Position of NISTC field.
	RNG_CR_NISTC_Pos = 0xc
	// Bit mask of NISTC field.
	RNG_CR_NISTC_Msk = 0x1000
	// Bit NISTC.
	RNG_CR_NISTC = 0x1000
	// Hardware default values for NIST compliant RNG. In this configuration per 128-bit output two conditioning loops are performed and 256 bits of noise source are used
	RNG_CR_NISTC_Default = 0x0
	// Custom values for NIST compliant RNG
	RNG_CR_NISTC_Custom = 0x1
	// Position of RNG_CONFIG2 field.
	RNG_CR_RNG_CONFIG2_Pos = 0xd
	// Bit mask of RNG_CONFIG2 field.
	RNG_CR_RNG_CONFIG2_Msk = 0xe000
	// Recommended value for config A and B
	RNG_CR_RNG_CONFIG2_ConfigA_B = 0x0
	// Position of CLKDIV field.
	RNG_CR_CLKDIV_Pos = 0x10
	// Bit mask of CLKDIV field.
	RNG_CR_CLKDIV_Msk = 0xf0000
	// Internal RNG clock after divider is similar to incoming RNG clock
	RNG_CR_CLKDIV_NoDiv = 0x0
	// Divide RNG clock by 2^1
	RNG_CR_CLKDIV_Div_2_1 = 0x1
	// Divide RNG clock by 2^2
	RNG_CR_CLKDIV_Div_2_2 = 0x2
	// Divide RNG clock by 2^3
	RNG_CR_CLKDIV_Div_2_3 = 0x3
	// Divide RNG clock by 2^4
	RNG_CR_CLKDIV_Div_2_4 = 0x4
	// Divide RNG clock by 2^5
	RNG_CR_CLKDIV_Div_2_5 = 0x5
	// Divide RNG clock by 2^6
	RNG_CR_CLKDIV_Div_2_6 = 0x6
	// Divide RNG clock by 2^7
	RNG_CR_CLKDIV_Div_2_7 = 0x7
	// Divide RNG clock by 2^8
	RNG_CR_CLKDIV_Div_2_8 = 0x8
	// Divide RNG clock by 2^9
	RNG_CR_CLKDIV_Div_2_9 = 0x9
	// Divide RNG clock by 2^10
	RNG_CR_CLKDIV_Div_2_10 = 0xa
	// Divide RNG clock by 2^11
	RNG_CR_CLKDIV_Div_2_11 = 0xb
	// Divide RNG clock by 2^12
	RNG_CR_CLKDIV_Div_2_12 = 0xc
	// Divide RNG clock by 2^13
	RNG_CR_CLKDIV_Div_2_13 = 0xd
	// Divide RNG clock by 2^14
	RNG_CR_CLKDIV_Div_2_14 = 0xe
	// Divide RNG clock by 2^15
	RNG_CR_CLKDIV_Div_2_15 = 0xf
	// Position of RNG_CONFIG1 field.
	RNG_CR_RNG_CONFIG1_Pos = 0x14
	// Bit mask of RNG_CONFIG1 field.
	RNG_CR_RNG_CONFIG1_Msk = 0x3f00000
	// Recommended value for config A (NIST certifiable)
	RNG_CR_RNG_CONFIG1_ConfigA = 0xf
	// Recommended value for config B (not NIST certifiable)
	RNG_CR_RNG_CONFIG1_ConfigB = 0x18
	// Position of CONDRST field.
	RNG_CR_CONDRST_Pos = 0x1e
	// Bit mask of CONDRST field.
	RNG_CR_CONDRST_Msk = 0x40000000
	// Bit CONDRST.
	RNG_CR_CONDRST = 0x40000000
	// Position of CONFIGLOCK field.
	RNG_CR_CONFIGLOCK_Pos = 0x1f
	// Bit mask of CONFIGLOCK field.
	RNG_CR_CONFIGLOCK_Msk = 0x80000000
	// Bit CONFIGLOCK.
	RNG_CR_CONFIGLOCK = 0x80000000
	// Writes to the RNG_CR configuration bits [29:4] are allowed
	RNG_CR_CONFIGLOCK_Enabled = 0x0
	// Writes to the RNG_CR configuration bits [29:4] are ignored until the next RNG reset
	RNG_CR_CONFIGLOCK_Disabled = 0x1

	// SR: status register
	// Position of SEIS field.
	RNG_SR_SEIS_Pos = 0x6
	// Bit mask of SEIS field.
	RNG_SR_SEIS_Msk = 0x40
	// Bit SEIS.
	RNG_SR_SEIS = 0x40
	// No faulty sequence detected
	RNG_SR_SEIS_NoFault = 0x0
	// At least one faulty sequence has been detected
	RNG_SR_SEIS_Fault = 0x1
	// Position of CEIS field.
	RNG_SR_CEIS_Pos = 0x5
	// Bit mask of CEIS field.
	RNG_SR_CEIS_Msk = 0x20
	// Bit CEIS.
	RNG_SR_CEIS = 0x20
	// The RNG clock is correct (fRNGCLK> fHCLK/32)
	RNG_SR_CEIS_Correct = 0x0
	// The RNG clock before internal divider has been detected too slow (fRNGCLK< fHCLK/32)
	RNG_SR_CEIS_Slow = 0x1
	// Position of SECS field.
	RNG_SR_SECS_Pos = 0x2
	// Bit mask of SECS field.
	RNG_SR_SECS_Msk = 0x4
	// Bit SECS.
	RNG_SR_SECS = 0x4
	// No faulty sequence has currently been detected. If the SEIS bit is set, this means that a faulty sequence was detected and the situation has been recovered
	RNG_SR_SECS_NoFault = 0x0
	// At least one faulty sequence has been detected - see ref manual for details
	RNG_SR_SECS_Fault = 0x1
	// Position of CECS field.
	RNG_SR_CECS_Pos = 0x1
	// Bit mask of CECS field.
	RNG_SR_CECS_Msk = 0x2
	// Bit CECS.
	RNG_SR_CECS = 0x2
	// The RNG clock is correct (fRNGCLK> fHCLK/32)
	RNG_SR_CECS_Correct = 0x0
	// The RNG clock before internal divider has been detected too slow (fRNGCLK< fHCLK/32)
	RNG_SR_CECS_Slow = 0x1
	// Position of DRDY field.
	RNG_SR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	RNG_SR_DRDY_Msk = 0x1
	// Bit DRDY.
	RNG_SR_DRDY = 0x1
	// The RNG_DR register is not yet valid, no random data is available
	RNG_SR_DRDY_Invalid = 0x0
	// The RNG_DR register contains valid random data
	RNG_SR_DRDY_Valid = 0x1

	// DR: data register
	// Position of RNDATA field.
	RNG_DR_RNDATA_Pos = 0x0
	// Bit mask of RNDATA field.
	RNG_DR_RNDATA_Msk = 0xffffffff

	// HTCR: health test control register
	// Position of HTCFG field.
	RNG_HTCR_HTCFG_Pos = 0x0
	// Bit mask of HTCFG field.
	RNG_HTCR_HTCFG_Msk = 0xffffffff
	// Magic number to be written before any write (0x1759_0ABC)
	RNG_HTCR_HTCFG_Magic = 0x17590abc
	// Recommended value for RNG certification (0x0000_AA74)
	RNG_HTCR_HTCFG_Recommended = 0xaa74
)

// Constants for RTC: Real-time clock
const (
	// TR: Time register
	// Position of PM field.
	RTC_TR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TR_PM = 0x400000
	// AM or 24-hour format
	RTC_TR_PM_AM = 0x0
	// PM
	RTC_TR_PM_PM = 0x1
	// Position of HT field.
	RTC_TR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_TR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TR_HU_Msk = 0xf0000
	// Position of MNT field.
	RTC_TR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_TR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TR_MNU_Msk = 0xf00
	// Position of ST field.
	RTC_TR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TR_ST_Msk = 0x70
	// Position of SU field.
	RTC_TR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TR_SU_Msk = 0xf

	// DR: Date register
	// Position of YT field.
	RTC_DR_YT_Pos = 0x14
	// Bit mask of YT field.
	RTC_DR_YT_Msk = 0xf00000
	// Position of YU field.
	RTC_DR_YU_Pos = 0x10
	// Bit mask of YU field.
	RTC_DR_YU_Msk = 0xf0000
	// Position of WDU field.
	RTC_DR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_DR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_DR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_DR_MT_Msk = 0x1000
	// Bit MT.
	RTC_DR_MT = 0x1000
	// Position of MU field.
	RTC_DR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_DR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_DR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_DR_DT_Msk = 0x30
	// Position of DU field.
	RTC_DR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_DR_DU_Msk = 0xf

	// SSR: Sub second register
	// Position of SS field.
	RTC_SSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_SSR_SS_Msk = 0xffffffff

	// ICSR: Initialization control and status register
	// Position of RECALPF field.
	RTC_ICSR_RECALPF_Pos = 0x10
	// Bit mask of RECALPF field.
	RTC_ICSR_RECALPF_Msk = 0x10000
	// Bit RECALPF.
	RTC_ICSR_RECALPF = 0x10000
	// The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0
	RTC_ICSR_RECALPF_Pending = 0x1
	// Position of BCDU field.
	RTC_ICSR_BCDU_Pos = 0xa
	// Bit mask of BCDU field.
	RTC_ICSR_BCDU_Msk = 0x1c00
	// 1s increment each time SS[7:0]=0
	RTC_ICSR_BCDU_Bit7 = 0x0
	// 1s increment each time SS[8:0]=0
	RTC_ICSR_BCDU_Bit8 = 0x1
	// 1s increment each time SS[9:0]=0
	RTC_ICSR_BCDU_Bit9 = 0x2
	// 1s increment each time SS[10:0]=0
	RTC_ICSR_BCDU_Bit10 = 0x3
	// 1s increment each time SS[11:0]=0
	RTC_ICSR_BCDU_Bit11 = 0x4
	// 1s increment each time SS[12:0]=0
	RTC_ICSR_BCDU_Bit12 = 0x5
	// 1s increment each time SS[13:0]=0
	RTC_ICSR_BCDU_Bit13 = 0x6
	// 1s increment each time SS[14:0]=0
	RTC_ICSR_BCDU_Bit14 = 0x7
	// Position of BIN field.
	RTC_ICSR_BIN_Pos = 0x8
	// Bit mask of BIN field.
	RTC_ICSR_BIN_Msk = 0x300
	// Free running BCD calendar mode (Binary mode disabled)
	RTC_ICSR_BIN_BCD = 0x0
	// Free running Binary mode (BCD mode disabled)
	RTC_ICSR_BIN_Binary = 0x1
	// Free running BCD calendar and Binary modes
	RTC_ICSR_BIN_BinBCD = 0x2
	// Free running BCD calendar and Binary modes
	RTC_ICSR_BIN_BinBCD2 = 0x3
	// Position of INIT field.
	RTC_ICSR_INIT_Pos = 0x7
	// Bit mask of INIT field.
	RTC_ICSR_INIT_Msk = 0x80
	// Bit INIT.
	RTC_ICSR_INIT = 0x80
	// Free running mode
	RTC_ICSR_INIT_FreeRunningMode = 0x0
	// Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset.
	RTC_ICSR_INIT_InitMode = 0x1
	// Position of INITF field.
	RTC_ICSR_INITF_Pos = 0x6
	// Bit mask of INITF field.
	RTC_ICSR_INITF_Msk = 0x40
	// Bit INITF.
	RTC_ICSR_INITF = 0x40
	// Calendar registers update is not allowed
	RTC_ICSR_INITF_NotAllowed = 0x0
	// Calendar registers update is allowed
	RTC_ICSR_INITF_Allowed = 0x1
	// Position of RSF field.
	RTC_ICSR_RSF_Pos = 0x5
	// Bit mask of RSF field.
	RTC_ICSR_RSF_Msk = 0x20
	// Bit RSF.
	RTC_ICSR_RSF = 0x20
	// Calendar shadow registers not yet synchronized
	RTC_ICSR_RSF_NotSynced = 0x0
	// Calendar shadow registers synchronized
	RTC_ICSR_RSF_Synced = 0x1
	// This flag is cleared by software by writing 0
	RTC_ICSR_RSF_Clear = 0x0
	// Position of INITS field.
	RTC_ICSR_INITS_Pos = 0x4
	// Bit mask of INITS field.
	RTC_ICSR_INITS_Msk = 0x10
	// Bit INITS.
	RTC_ICSR_INITS = 0x10
	// Calendar has not been initialized
	RTC_ICSR_INITS_NotInitalized = 0x0
	// Calendar has been initialized
	RTC_ICSR_INITS_Initalized = 0x1
	// Position of SHPF field.
	RTC_ICSR_SHPF_Pos = 0x3
	// Bit mask of SHPF field.
	RTC_ICSR_SHPF_Msk = 0x8
	// Bit SHPF.
	RTC_ICSR_SHPF = 0x8
	// No shift operation is pending
	RTC_ICSR_SHPF_NoShiftPending = 0x0
	// A shift operation is pending
	RTC_ICSR_SHPF_ShiftPending = 0x1
	// Position of WUTWF field.
	RTC_ICSR_WUTWF_Pos = 0x2
	// Bit mask of WUTWF field.
	RTC_ICSR_WUTWF_Msk = 0x4
	// Bit WUTWF.
	RTC_ICSR_WUTWF = 0x4
	// Wakeup timer configuration update not allowed
	RTC_ICSR_WUTWF_UpdateNotAllowed = 0x0
	// Wakeup timer configuration update allowed
	RTC_ICSR_WUTWF_UpdateAllowed = 0x1

	// PRER: Pre-scaler register
	// Position of PREDIV_A field.
	RTC_PRER_PREDIV_A_Pos = 0x10
	// Bit mask of PREDIV_A field.
	RTC_PRER_PREDIV_A_Msk = 0x7f0000
	// Position of PREDIV_S field.
	RTC_PRER_PREDIV_S_Pos = 0x0
	// Bit mask of PREDIV_S field.
	RTC_PRER_PREDIV_S_Msk = 0x7fff

	// WUTR: Wakeup timer register
	// Position of WUTOCLR field.
	RTC_WUTR_WUTOCLR_Pos = 0x10
	// Bit mask of WUTOCLR field.
	RTC_WUTR_WUTOCLR_Msk = 0xffff0000
	// Position of WUT field.
	RTC_WUTR_WUT_Pos = 0x0
	// Bit mask of WUT field.
	RTC_WUTR_WUT_Msk = 0xffff

	// CR: Control register
	// Position of OUT2EN field.
	RTC_CR_OUT2EN_Pos = 0x1f
	// Bit mask of OUT2EN field.
	RTC_CR_OUT2EN_Msk = 0x80000000
	// Bit OUT2EN.
	RTC_CR_OUT2EN = 0x80000000
	// RTC output 2 disable
	RTC_CR_OUT2EN_Disabled = 0x0
	// RTC output 2 enable
	RTC_CR_OUT2EN_Enabled = 0x1
	// Position of TAMPALRM_TYPE field.
	RTC_CR_TAMPALRM_TYPE_Pos = 0x1e
	// Bit mask of TAMPALRM_TYPE field.
	RTC_CR_TAMPALRM_TYPE_Msk = 0x40000000
	// Bit TAMPALRM_TYPE.
	RTC_CR_TAMPALRM_TYPE = 0x40000000
	// TAMPALRM is push-pull output
	RTC_CR_TAMPALRM_TYPE_PushPull = 0x0
	// TAMPALRM is open-drain output
	RTC_CR_TAMPALRM_TYPE_OpenDrain = 0x1
	// Position of TAMPALRM_PU field.
	RTC_CR_TAMPALRM_PU_Pos = 0x1d
	// Bit mask of TAMPALRM_PU field.
	RTC_CR_TAMPALRM_PU_Msk = 0x20000000
	// Bit TAMPALRM_PU.
	RTC_CR_TAMPALRM_PU = 0x20000000
	// No pull-up is applied on TAMPALRM output
	RTC_CR_TAMPALRM_PU_NoPullUp = 0x0
	// A pull-up is applied on TAMPALRM output
	RTC_CR_TAMPALRM_PU_PullUp = 0x1
	// Position of TAMPOE field.
	RTC_CR_TAMPOE_Pos = 0x1a
	// Bit mask of TAMPOE field.
	RTC_CR_TAMPOE_Msk = 0x4000000
	// Bit TAMPOE.
	RTC_CR_TAMPOE = 0x4000000
	// The tamper flag is not routed on TAMPALRM
	RTC_CR_TAMPOE_Disabled = 0x0
	// The tamper flag is routed on TAMPALRM, combined with the signal provided by OSEL and with the polarity provided by POL
	RTC_CR_TAMPOE_Enabled = 0x1
	// Position of TAMPTS field.
	RTC_CR_TAMPTS_Pos = 0x19
	// Bit mask of TAMPTS field.
	RTC_CR_TAMPTS_Msk = 0x2000000
	// Bit TAMPTS.
	RTC_CR_TAMPTS = 0x2000000
	// Tamper detection event does not cause a RTC timestamp to be saved
	RTC_CR_TAMPTS_Disabled = 0x0
	// Save RTC timestamp on tamper detection event
	RTC_CR_TAMPTS_Enabled = 0x1
	// Position of ITSE field.
	RTC_CR_ITSE_Pos = 0x18
	// Bit mask of ITSE field.
	RTC_CR_ITSE_Msk = 0x1000000
	// Bit ITSE.
	RTC_CR_ITSE = 0x1000000
	// Internal event timestamp disabled
	RTC_CR_ITSE_Disabled = 0x0
	// Internal event timestamp enabled
	RTC_CR_ITSE_Enabled = 0x1
	// Position of COE field.
	RTC_CR_COE_Pos = 0x17
	// Bit mask of COE field.
	RTC_CR_COE_Msk = 0x800000
	// Bit COE.
	RTC_CR_COE = 0x800000
	// Calibration output disabled
	RTC_CR_COE_Disabled = 0x0
	// Calibration output enabled
	RTC_CR_COE_Enabled = 0x1
	// Position of OSEL field.
	RTC_CR_OSEL_Pos = 0x15
	// Bit mask of OSEL field.
	RTC_CR_OSEL_Msk = 0x600000
	// Output disabled
	RTC_CR_OSEL_Disabled = 0x0
	// Alarm A output enabled
	RTC_CR_OSEL_AlarmA = 0x1
	// Alarm B output enabled
	RTC_CR_OSEL_AlarmB = 0x2
	// Wakeup output enabled
	RTC_CR_OSEL_Wakeup = 0x3
	// Position of POL field.
	RTC_CR_POL_Pos = 0x14
	// Bit mask of POL field.
	RTC_CR_POL_Msk = 0x100000
	// Bit POL.
	RTC_CR_POL = 0x100000
	// The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
	RTC_CR_POL_High = 0x0
	// The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
	RTC_CR_POL_Low = 0x1
	// Position of COSEL field.
	RTC_CR_COSEL_Pos = 0x13
	// Bit mask of COSEL field.
	RTC_CR_COSEL_Msk = 0x80000
	// Bit COSEL.
	RTC_CR_COSEL = 0x80000
	// Calibration output is 512 Hz (with default prescaler setting)
	RTC_CR_COSEL_CalFreq_512Hz = 0x0
	// Calibration output is 1 Hz (with default prescaler setting)
	RTC_CR_COSEL_CalFreq_1Hz = 0x1
	// Position of BKP field.
	RTC_CR_BKP_Pos = 0x12
	// Bit mask of BKP field.
	RTC_CR_BKP_Msk = 0x40000
	// Bit BKP.
	RTC_CR_BKP = 0x40000
	// Daylight Saving Time change has not been performed
	RTC_CR_BKP_DSTNotChanged = 0x0
	// Daylight Saving Time change has been performed
	RTC_CR_BKP_DSTChanged = 0x1
	// Position of SUB1H field.
	RTC_CR_SUB1H_Pos = 0x11
	// Bit mask of SUB1H field.
	RTC_CR_SUB1H_Msk = 0x20000
	// Bit SUB1H.
	RTC_CR_SUB1H = 0x20000
	// Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode
	RTC_CR_SUB1H_Sub1 = 0x1
	// Position of ADD1H field.
	RTC_CR_ADD1H_Pos = 0x10
	// Bit mask of ADD1H field.
	RTC_CR_ADD1H_Msk = 0x10000
	// Bit ADD1H.
	RTC_CR_ADD1H = 0x10000
	// Adds 1 hour to the current time. This can be used for summer time change outside initialization mode
	RTC_CR_ADD1H_Add1 = 0x1
	// Position of TSIE field.
	RTC_CR_TSIE_Pos = 0xf
	// Bit mask of TSIE field.
	RTC_CR_TSIE_Msk = 0x8000
	// Bit TSIE.
	RTC_CR_TSIE = 0x8000
	// Time-stamp Interrupt disabled
	RTC_CR_TSIE_Disabled = 0x0
	// Time-stamp Interrupt enabled
	RTC_CR_TSIE_Enabled = 0x1
	// Position of WUTIE field.
	RTC_CR_WUTIE_Pos = 0xe
	// Bit mask of WUTIE field.
	RTC_CR_WUTIE_Msk = 0x4000
	// Bit WUTIE.
	RTC_CR_WUTIE = 0x4000
	// Wakeup timer interrupt disabled
	RTC_CR_WUTIE_Disabled = 0x0
	// Wakeup timer interrupt enabled
	RTC_CR_WUTIE_Enabled = 0x1
	// Position of ALRBIE field.
	RTC_CR_ALRBIE_Pos = 0xd
	// Bit mask of ALRBIE field.
	RTC_CR_ALRBIE_Msk = 0x2000
	// Bit ALRBIE.
	RTC_CR_ALRBIE = 0x2000
	// Alarm B Interrupt disabled
	RTC_CR_ALRBIE_Disabled = 0x0
	// Alarm B Interrupt enabled
	RTC_CR_ALRBIE_Enabled = 0x1
	// Position of ALRAIE field.
	RTC_CR_ALRAIE_Pos = 0xc
	// Bit mask of ALRAIE field.
	RTC_CR_ALRAIE_Msk = 0x1000
	// Bit ALRAIE.
	RTC_CR_ALRAIE = 0x1000
	// Alarm A interrupt disabled
	RTC_CR_ALRAIE_Disabled = 0x0
	// Alarm A interrupt enabled
	RTC_CR_ALRAIE_Enabled = 0x1
	// Position of TSE field.
	RTC_CR_TSE_Pos = 0xb
	// Bit mask of TSE field.
	RTC_CR_TSE_Msk = 0x800
	// Bit TSE.
	RTC_CR_TSE = 0x800
	// Timestamp disabled
	RTC_CR_TSE_Disabled = 0x0
	// Timestamp enabled
	RTC_CR_TSE_Enabled = 0x1
	// Position of WUTE field.
	RTC_CR_WUTE_Pos = 0xa
	// Bit mask of WUTE field.
	RTC_CR_WUTE_Msk = 0x400
	// Bit WUTE.
	RTC_CR_WUTE = 0x400
	// Wakeup timer disabled
	RTC_CR_WUTE_Disabled = 0x0
	// Wakeup timer enabled
	RTC_CR_WUTE_Enabled = 0x1
	// Position of ALRBE field.
	RTC_CR_ALRBE_Pos = 0x9
	// Bit mask of ALRBE field.
	RTC_CR_ALRBE_Msk = 0x200
	// Bit ALRBE.
	RTC_CR_ALRBE = 0x200
	// Alarm B disabled
	RTC_CR_ALRBE_Disabled = 0x0
	// Alarm B enabled
	RTC_CR_ALRBE_Enabled = 0x1
	// Position of ALRAE field.
	RTC_CR_ALRAE_Pos = 0x8
	// Bit mask of ALRAE field.
	RTC_CR_ALRAE_Msk = 0x100
	// Bit ALRAE.
	RTC_CR_ALRAE = 0x100
	// Alarm A disabled
	RTC_CR_ALRAE_Disabled = 0x0
	// Alarm A enabled
	RTC_CR_ALRAE_Enabled = 0x1
	// Position of SSRUIE field.
	RTC_CR_SSRUIE_Pos = 0x7
	// Bit mask of SSRUIE field.
	RTC_CR_SSRUIE_Msk = 0x80
	// Bit SSRUIE.
	RTC_CR_SSRUIE = 0x80
	// SSR underflow interrupt disabled
	RTC_CR_SSRUIE_Disabled = 0x0
	// SSR underflow interrupt enabled
	RTC_CR_SSRUIE_Enabled = 0x1
	// Position of FMT field.
	RTC_CR_FMT_Pos = 0x6
	// Bit mask of FMT field.
	RTC_CR_FMT_Msk = 0x40
	// Bit FMT.
	RTC_CR_FMT = 0x40
	// 24 hour/day format
	RTC_CR_FMT_TwentyFourHour = 0x0
	// AM/PM hour format
	RTC_CR_FMT_AmPm = 0x1
	// Position of BYPSHAD field.
	RTC_CR_BYPSHAD_Pos = 0x5
	// Bit mask of BYPSHAD field.
	RTC_CR_BYPSHAD_Msk = 0x20
	// Bit BYPSHAD.
	RTC_CR_BYPSHAD = 0x20
	// Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles
	RTC_CR_BYPSHAD_ShadowReg = 0x0
	// Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters
	RTC_CR_BYPSHAD_BypassShadowReg = 0x1
	// Position of REFCKON field.
	RTC_CR_REFCKON_Pos = 0x4
	// Bit mask of REFCKON field.
	RTC_CR_REFCKON_Msk = 0x10
	// Bit REFCKON.
	RTC_CR_REFCKON = 0x10
	// RTC_REFIN detection disabled
	RTC_CR_REFCKON_Disabled = 0x0
	// RTC_REFIN detection enabled
	RTC_CR_REFCKON_Enabled = 0x1
	// Position of TSEDGE field.
	RTC_CR_TSEDGE_Pos = 0x3
	// Bit mask of TSEDGE field.
	RTC_CR_TSEDGE_Msk = 0x8
	// Bit TSEDGE.
	RTC_CR_TSEDGE = 0x8
	// RTC_TS input rising edge generates a time-stamp event
	RTC_CR_TSEDGE_RisingEdge = 0x0
	// RTC_TS input falling edge generates a time-stamp event
	RTC_CR_TSEDGE_FallingEdge = 0x1
	// Position of WUCKSEL field.
	RTC_CR_WUCKSEL_Pos = 0x0
	// Bit mask of WUCKSEL field.
	RTC_CR_WUCKSEL_Msk = 0x7
	// RTC/16 clock is selected
	RTC_CR_WUCKSEL_Div16 = 0x0
	// RTC/8 clock is selected
	RTC_CR_WUCKSEL_Div8 = 0x1
	// RTC/4 clock is selected
	RTC_CR_WUCKSEL_Div4 = 0x2
	// RTC/2 clock is selected
	RTC_CR_WUCKSEL_Div2 = 0x3
	// ck_spre (usually 1 Hz) clock is selected
	RTC_CR_WUCKSEL_ClockSpare = 0x4
	// ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value
	RTC_CR_WUCKSEL_ClockSpareWithOffset = 0x6

	// WPR: Write protection register
	// Position of KEY field.
	RTC_WPR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	RTC_WPR_KEY_Msk = 0xff
	// Key 1
	RTC_WPR_KEY_Deactivate1 = 0xca
	// Key 2
	RTC_WPR_KEY_Deactivate2 = 0x53
	// Activate write protection (any value that is not the keys)
	RTC_WPR_KEY_Activate = 0x0

	// CALR: Calibration register
	// Position of CALP field.
	RTC_CALR_CALP_Pos = 0xf
	// Bit mask of CALP field.
	RTC_CALR_CALP_Msk = 0x8000
	// Bit CALP.
	RTC_CALR_CALP = 0x8000
	// No RTCCLK pulses are added
	RTC_CALR_CALP_NoChange = 0x0
	// One RTCCLK pulse is effectively inserted every 2^11 pulses (frequency increased by 488.5 ppm)
	RTC_CALR_CALP_IncreaseFreq = 0x1
	// Position of CALW8 field.
	RTC_CALR_CALW8_Pos = 0xe
	// Bit mask of CALW8 field.
	RTC_CALR_CALW8_Msk = 0x4000
	// Bit CALW8.
	RTC_CALR_CALW8 = 0x4000
	// When CALW8 is set to 1, the 8-second calibration cycle period is selected
	RTC_CALR_CALW8_EightSeconds = 0x1
	// Position of CALW16 field.
	RTC_CALR_CALW16_Pos = 0xd
	// Bit mask of CALW16 field.
	RTC_CALR_CALW16_Msk = 0x2000
	// Bit CALW16.
	RTC_CALR_CALW16 = 0x2000
	// When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1
	RTC_CALR_CALW16_SixteenSeconds = 0x1
	// Position of LPCAL field.
	RTC_CALR_LPCAL_Pos = 0xc
	// Bit mask of LPCAL field.
	RTC_CALR_LPCAL_Msk = 0x1000
	// Bit LPCAL.
	RTC_CALR_LPCAL = 0x1000
	// Calibration window is 220 RTCCLK, which is a high-consumption mode. This mode should be set only when less than 32s calibration window is required
	RTC_CALR_LPCAL_RTCCLK = 0x0
	// Calibration window is 220 ck_apre, which is the required configuration for ultra-low consumption mode
	RTC_CALR_LPCAL_CkApre = 0x1
	// Position of CALM field.
	RTC_CALR_CALM_Pos = 0x0
	// Bit mask of CALM field.
	RTC_CALR_CALM_Msk = 0x1ff

	// SHIFTR: Shift control register
	// Position of ADD1S field.
	RTC_SHIFTR_ADD1S_Pos = 0x1f
	// Bit mask of ADD1S field.
	RTC_SHIFTR_ADD1S_Msk = 0x80000000
	// Bit ADD1S.
	RTC_SHIFTR_ADD1S = 0x80000000
	// Add one second to the clock/calendar
	RTC_SHIFTR_ADD1S_Add1 = 0x1
	// Position of SUBFS field.
	RTC_SHIFTR_SUBFS_Pos = 0x0
	// Bit mask of SUBFS field.
	RTC_SHIFTR_SUBFS_Msk = 0x7fff

	// TSTR: Timestamp time register
	// Position of PM field.
	RTC_TSTR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TSTR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TSTR_PM = 0x400000
	// Position of HT field.
	RTC_TSTR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TSTR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_TSTR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TSTR_HU_Msk = 0xf0000
	// Position of MNT field.
	RTC_TSTR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TSTR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_TSTR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TSTR_MNU_Msk = 0xf00
	// Position of ST field.
	RTC_TSTR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TSTR_ST_Msk = 0x70
	// Position of SU field.
	RTC_TSTR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TSTR_SU_Msk = 0xf

	// TSDR: Timestamp date register
	// Position of WDU field.
	RTC_TSDR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_TSDR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_TSDR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_TSDR_MT_Msk = 0x1000
	// Bit MT.
	RTC_TSDR_MT = 0x1000
	// Position of MU field.
	RTC_TSDR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_TSDR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_TSDR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_TSDR_DT_Msk = 0x30
	// Position of DU field.
	RTC_TSDR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_TSDR_DU_Msk = 0xf

	// TSSSR: Timestamp sub second register
	// Position of SS field.
	RTC_TSSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_TSSSR_SS_Msk = 0xffffffff

	// ALRMAR: Alarm A register
	// Position of MSK4 field.
	RTC_ALRMAR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMAR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMAR_MSK4 = 0x80000000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK4_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK4_NotMask = 0x1
	// Position of WDSEL field.
	RTC_ALRMAR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMAR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMAR_WDSEL = 0x40000000
	// DU[3:0] represents the date units
	RTC_ALRMAR_WDSEL_DateUnits = 0x0
	// DU[3:0] represents the week day. DT[1:0] is dont care.
	RTC_ALRMAR_WDSEL_WeekDay = 0x1
	// Position of DT field.
	RTC_ALRMAR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMAR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMAR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMAR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMAR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMAR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMAR_MSK3 = 0x800000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK3_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK3_NotMask = 0x1
	// Position of PM field.
	RTC_ALRMAR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMAR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMAR_PM = 0x400000
	// AM or 24-hour format
	RTC_ALRMAR_PM_AM = 0x0
	// PM
	RTC_ALRMAR_PM_PM = 0x1
	// Position of HT field.
	RTC_ALRMAR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMAR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMAR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMAR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMAR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMAR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMAR_MSK2 = 0x8000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK2_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK2_NotMask = 0x1
	// Position of MNT field.
	RTC_ALRMAR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMAR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMAR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMAR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMAR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMAR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMAR_MSK1 = 0x80
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK1_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK1_NotMask = 0x1
	// Position of ST field.
	RTC_ALRMAR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMAR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMAR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMAR_SU_Msk = 0xf

	// ALRMASSR: Alarm A sub second register
	// Position of SSCLR field.
	RTC_ALRMASSR_SSCLR_Pos = 0x1f
	// Bit mask of SSCLR field.
	RTC_ALRMASSR_SSCLR_Msk = 0x80000000
	// Bit SSCLR.
	RTC_ALRMASSR_SSCLR = 0x80000000
	// The synchronous binary counter (SS[31:0] in RTC_SSR) is free-running
	RTC_ALRMASSR_SSCLR_FreeRunning = 0x0
	// The synchronous binary counter (SS[31:0] in RTC_SSR) is running from 0xFFFF FFFF to RTC_ALRMABINR  SS[31:0] value and is automatically reloaded with 0xFFFF FFFF when reaching RTC_ALRMABINR  SS[31:0]
	RTC_ALRMASSR_SSCLR_ALRMBINR = 0x1
	// Position of MASKSS field.
	RTC_ALRMASSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMASSR_MASKSS_Msk = 0x3f000000
	// Position of SS field.
	RTC_ALRMASSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMASSR_SS_Msk = 0x7fff

	// ALRMBR: Alarm B register
	// Position of MSK4 field.
	RTC_ALRMBR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMBR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMBR_MSK4 = 0x80000000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK4_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK4_NotMask = 0x1
	// Position of WDSEL field.
	RTC_ALRMBR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMBR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMBR_WDSEL = 0x40000000
	// DU[3:0] represents the date units
	RTC_ALRMBR_WDSEL_DateUnits = 0x0
	// DU[3:0] represents the week day. DT[1:0] is dont care.
	RTC_ALRMBR_WDSEL_WeekDay = 0x1
	// Position of DT field.
	RTC_ALRMBR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMBR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMBR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMBR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMBR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMBR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMBR_MSK3 = 0x800000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK3_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK3_NotMask = 0x1
	// Position of PM field.
	RTC_ALRMBR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMBR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMBR_PM = 0x400000
	// AM or 24-hour format
	RTC_ALRMBR_PM_AM = 0x0
	// PM
	RTC_ALRMBR_PM_PM = 0x1
	// Position of HT field.
	RTC_ALRMBR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMBR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMBR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMBR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMBR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMBR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMBR_MSK2 = 0x8000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK2_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK2_NotMask = 0x1
	// Position of MNT field.
	RTC_ALRMBR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMBR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMBR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMBR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMBR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMBR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMBR_MSK1 = 0x80
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK1_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK1_NotMask = 0x1
	// Position of ST field.
	RTC_ALRMBR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMBR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMBR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMBR_SU_Msk = 0xf

	// ALRMBSSR: Alarm B sub second register
	// Position of SSCLR field.
	RTC_ALRMBSSR_SSCLR_Pos = 0x1f
	// Bit mask of SSCLR field.
	RTC_ALRMBSSR_SSCLR_Msk = 0x80000000
	// Bit SSCLR.
	RTC_ALRMBSSR_SSCLR = 0x80000000
	// The synchronous binary counter (SS[31:0] in RTC_SSR) is free-running
	RTC_ALRMBSSR_SSCLR_FreeRunning = 0x0
	// The synchronous binary counter (SS[31:0] in RTC_SSR) is running from 0xFFFF FFFF to RTC_ALRMABINR  SS[31:0] value and is automatically reloaded with 0xFFFF FFFF when reaching RTC_ALRMABINR  SS[31:0]
	RTC_ALRMBSSR_SSCLR_ALRMBINR = 0x1
	// Position of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Msk = 0x3f000000
	// Position of SS field.
	RTC_ALRMBSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMBSSR_SS_Msk = 0x7fff

	// SR: Status register (interrupts)
	// Position of SSRUF field.
	RTC_SR_SSRUF_Pos = 0x6
	// Bit mask of SSRUF field.
	RTC_SR_SSRUF_Msk = 0x40
	// Bit SSRUF.
	RTC_SR_SSRUF = 0x40
	// This flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1
	RTC_SR_SSRUF_Underflow = 0x1
	// Position of ITSF field.
	RTC_SR_ITSF_Pos = 0x5
	// Bit mask of ITSF field.
	RTC_SR_ITSF_Msk = 0x20
	// Bit ITSF.
	RTC_SR_ITSF = 0x20
	// This flag is set by hardware when a timestamp on the internal event occurs
	RTC_SR_ITSF_TimestampEvent = 0x1
	// Position of TSOVF field.
	RTC_SR_TSOVF_Pos = 0x4
	// Bit mask of TSOVF field.
	RTC_SR_TSOVF_Msk = 0x10
	// Bit TSOVF.
	RTC_SR_TSOVF = 0x10
	// This flag is set by hardware when a time-stamp event occurs while TSF is already set
	RTC_SR_TSOVF_Overflow = 0x1
	// Position of TSF field.
	RTC_SR_TSF_Pos = 0x3
	// Bit mask of TSF field.
	RTC_SR_TSF_Msk = 0x8
	// Bit TSF.
	RTC_SR_TSF = 0x8
	// This flag is set by hardware when a time-stamp event occurs
	RTC_SR_TSF_TimestampEvent = 0x1
	// Position of WUTF field.
	RTC_SR_WUTF_Pos = 0x2
	// Bit mask of WUTF field.
	RTC_SR_WUTF_Msk = 0x4
	// Bit WUTF.
	RTC_SR_WUTF = 0x4
	// This flag is set by hardware when the wakeup auto-reload counter reaches 0
	RTC_SR_WUTF_Zero = 0x1
	// Position of ALRBF field.
	RTC_SR_ALRBF_Pos = 0x1
	// Bit mask of ALRBF field.
	RTC_SR_ALRBF_Msk = 0x2
	// Bit ALRBF.
	RTC_SR_ALRBF = 0x2
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR)
	RTC_SR_ALRBF_Match = 0x1
	// Position of ALRAF field.
	RTC_SR_ALRAF_Pos = 0x0
	// Bit mask of ALRAF field.
	RTC_SR_ALRAF_Msk = 0x1
	// Bit ALRAF.
	RTC_SR_ALRAF = 0x1
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR)
	RTC_SR_ALRAF_Match = 0x1

	// MISR: Masked interrupt status register
	// Position of SSRUMF field.
	RTC_MISR_SSRUMF_Pos = 0x6
	// Bit mask of SSRUMF field.
	RTC_MISR_SSRUMF_Msk = 0x40
	// Bit SSRUMF.
	RTC_MISR_SSRUMF = 0x40
	// This flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1
	RTC_MISR_SSRUMF_Underflow = 0x1
	// Position of ITSMF field.
	RTC_MISR_ITSMF_Pos = 0x5
	// Bit mask of ITSMF field.
	RTC_MISR_ITSMF_Msk = 0x20
	// Bit ITSMF.
	RTC_MISR_ITSMF = 0x20
	// This flag is set by hardware when a timestamp on the internal event occurs
	RTC_MISR_ITSMF_TimestampEvent = 0x1
	// Position of TSOVMF field.
	RTC_MISR_TSOVMF_Pos = 0x4
	// Bit mask of TSOVMF field.
	RTC_MISR_TSOVMF_Msk = 0x10
	// Bit TSOVMF.
	RTC_MISR_TSOVMF = 0x10
	// This flag is set by hardware when a time-stamp event occurs while TSF is already set
	RTC_MISR_TSOVMF_Overflow = 0x1
	// Position of TSMF field.
	RTC_MISR_TSMF_Pos = 0x3
	// Bit mask of TSMF field.
	RTC_MISR_TSMF_Msk = 0x8
	// Bit TSMF.
	RTC_MISR_TSMF = 0x8
	// This flag is set by hardware when a time-stamp event occurs
	RTC_MISR_TSMF_TimestampEvent = 0x1
	// Position of WUTMF field.
	RTC_MISR_WUTMF_Pos = 0x2
	// Bit mask of WUTMF field.
	RTC_MISR_WUTMF_Msk = 0x4
	// Bit WUTMF.
	RTC_MISR_WUTMF = 0x4
	// This flag is set by hardware when the wakeup auto-reload counter reaches 0
	RTC_MISR_WUTMF_Zero = 0x1
	// Position of ALRBMF field.
	RTC_MISR_ALRBMF_Pos = 0x1
	// Bit mask of ALRBMF field.
	RTC_MISR_ALRBMF_Msk = 0x2
	// Bit ALRBMF.
	RTC_MISR_ALRBMF = 0x2
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR)
	RTC_MISR_ALRBMF_Match = 0x1
	// Position of ALRAMF field.
	RTC_MISR_ALRAMF_Pos = 0x0
	// Bit mask of ALRAMF field.
	RTC_MISR_ALRAMF_Msk = 0x1
	// Bit ALRAMF.
	RTC_MISR_ALRAMF = 0x1
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR)
	RTC_MISR_ALRAMF_Match = 0x1

	// SCR: Status clear register (interrupts)
	// Position of CSSRUF field.
	RTC_SCR_CSSRUF_Pos = 0x6
	// Bit mask of CSSRUF field.
	RTC_SCR_CSSRUF_Msk = 0x40
	// Bit CSSRUF.
	RTC_SCR_CSSRUF = 0x40
	// Clear interrupt flag by writing 1
	RTC_SCR_CSSRUF_Clear = 0x1
	// Position of CITSF field.
	RTC_SCR_CITSF_Pos = 0x5
	// Bit mask of CITSF field.
	RTC_SCR_CITSF_Msk = 0x20
	// Bit CITSF.
	RTC_SCR_CITSF = 0x20
	// Clear interrupt flag by writing 1
	RTC_SCR_CITSF_Clear = 0x1
	// Position of CTSOVF field.
	RTC_SCR_CTSOVF_Pos = 0x4
	// Bit mask of CTSOVF field.
	RTC_SCR_CTSOVF_Msk = 0x10
	// Bit CTSOVF.
	RTC_SCR_CTSOVF = 0x10
	// Clear interrupt flag by writing 1
	RTC_SCR_CTSOVF_Clear = 0x1
	// Position of CTSF field.
	RTC_SCR_CTSF_Pos = 0x3
	// Bit mask of CTSF field.
	RTC_SCR_CTSF_Msk = 0x8
	// Bit CTSF.
	RTC_SCR_CTSF = 0x8
	// Clear interrupt flag by writing 1
	RTC_SCR_CTSF_Clear = 0x1
	// Position of CWUTF field.
	RTC_SCR_CWUTF_Pos = 0x2
	// Bit mask of CWUTF field.
	RTC_SCR_CWUTF_Msk = 0x4
	// Bit CWUTF.
	RTC_SCR_CWUTF = 0x4
	// Clear interrupt flag by writing 1
	RTC_SCR_CWUTF_Clear = 0x1
	// Position of CALRBF field.
	RTC_SCR_CALRBF_Pos = 0x1
	// Bit mask of CALRBF field.
	RTC_SCR_CALRBF_Msk = 0x2
	// Bit CALRBF.
	RTC_SCR_CALRBF = 0x2
	// Clear interrupt flag by writing 1
	RTC_SCR_CALRBF_Clear = 0x1
	// Position of CALRAF field.
	RTC_SCR_CALRAF_Pos = 0x0
	// Bit mask of CALRAF field.
	RTC_SCR_CALRAF_Msk = 0x1
	// Bit CALRAF.
	RTC_SCR_CALRAF = 0x1
	// Clear interrupt flag by writing 1
	RTC_SCR_CALRAF_Clear = 0x1

	// ALRABINR: RTC alarm A binary mode register
	// Position of SS field.
	RTC_ALRABINR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRABINR_SS_Msk = 0xffffffff

	// ALRBBINR: RTC alarm B binary mode register
	// Position of SS field.
	RTC_ALRBBINR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRBBINR_SS_Msk = 0xffffffff
)

// Constants for SCB: System control block
const (
	// CPUID: CPUID base register
	// Position of Revision field.
	SCB_CPUID_Revision_Pos = 0x0
	// Bit mask of Revision field.
	SCB_CPUID_Revision_Msk = 0xf
	// Position of PartNo field.
	SCB_CPUID_PartNo_Pos = 0x4
	// Bit mask of PartNo field.
	SCB_CPUID_PartNo_Msk = 0xfff0
	// Position of Constant field.
	SCB_CPUID_Constant_Pos = 0x10
	// Bit mask of Constant field.
	SCB_CPUID_Constant_Msk = 0xf0000
	// Position of Variant field.
	SCB_CPUID_Variant_Pos = 0x14
	// Bit mask of Variant field.
	SCB_CPUID_Variant_Msk = 0xf00000
	// Position of Implementer field.
	SCB_CPUID_Implementer_Pos = 0x18
	// Bit mask of Implementer field.
	SCB_CPUID_Implementer_Msk = 0xff000000

	// ICSR: Interrupt control and state register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x7f000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000

	// VTOR: Vector table offset register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x9
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0x3ffffe00

	// AIRCR: Application interrupt and reset control register
	// Position of VECTRESET field.
	SCB_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SCB_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SCB_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// Position of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Pos = 0xf
	// Bit mask of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Msk = 0x8000
	// Bit ENDIANESS.
	SCB_AIRCR_ENDIANESS = 0x8000
	// Position of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Pos = 0x10
	// Bit mask of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Msk = 0xffff0000

	// SCR: System control register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// Position of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Pos = 0x4
	// Bit mask of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Msk = 0x10
	// Bit SEVEONPEND.
	SCB_SCR_SEVEONPEND = 0x10

	// CCR: Configuration and control register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// Position of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Pos = 0x3
	// Bit mask of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Msk = 0x8
	// Bit UNALIGN__TRP.
	SCB_CCR_UNALIGN__TRP = 0x8
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200

	// SHPR1: System handler priority registers
	// Position of PRI_4 field.
	SCB_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SCB_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SCB_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SCB_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SCB_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SCB_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System handler priority registers
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System handler priority registers
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System handler control and state register
	// Position of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SCB_SHCSR_MEMFAULTACT = 0x1
	// Position of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SCB_SHCSR_BUSFAULTACT = 0x2
	// Position of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SCB_SHCSR_USGFAULTACT = 0x8
	// Position of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SCB_SHCSR_SVCALLACT = 0x80
	// Position of MONITORACT field.
	SCB_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SCB_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SCB_SHCSR_MONITORACT = 0x100
	// Position of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SCB_SHCSR_PENDSVACT = 0x400
	// Position of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SCB_SHCSR_SYSTICKACT = 0x800
	// Position of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SCB_SHCSR_USGFAULTPENDED = 0x1000
	// Position of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SCB_SHCSR_MEMFAULTPENDED = 0x2000
	// Position of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SCB_SHCSR_BUSFAULTPENDED = 0x4000
	// Position of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SCB_SHCSR_SVCALLPENDED = 0x8000
	// Position of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SCB_SHCSR_MEMFAULTENA = 0x10000
	// Position of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SCB_SHCSR_BUSFAULTENA = 0x20000
	// Position of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SCB_SHCSR_USGFAULTENA = 0x40000

	// CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
	// Position of IACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_Pos = 0x1
	// Bit mask of IACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_Msk = 0x2
	// Bit IACCVIOL.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 0x2
	// Position of MUNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 0x8
	// Position of MSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 0x10
	// Position of MLSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 0x20
	// Position of MMARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 0x80
	// Position of IBUSERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 0x100
	// Position of PRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 0x200
	// Position of IMPRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 0x400
	// Position of UNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 0x800
	// Position of STKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 0x1000
	// Position of LSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 0x2000
	// Position of BFARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 0x8000
	// Position of UNDEFINSTR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 0x10000
	// Position of INVSTATE field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 0x20000
	// Position of INVPC field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 0x40000
	// Position of NOCP field.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 0x80000
	// Position of UNALIGNED field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 0x1000000
	// Position of DIVBYZERO field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 0x2000000

	// HFSR: Hard fault status register
	// Position of VECTTBL field.
	SCB_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SCB_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SCB_HFSR_VECTTBL = 0x2
	// Position of FORCED field.
	SCB_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SCB_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SCB_HFSR_FORCED = 0x40000000
	// Position of DEBUG_VT field.
	SCB_HFSR_DEBUG_VT_Pos = 0x1f
	// Bit mask of DEBUG_VT field.
	SCB_HFSR_DEBUG_VT_Msk = 0x80000000
	// Bit DEBUG_VT.
	SCB_HFSR_DEBUG_VT = 0x80000000

	// MMFAR: Memory management fault address register
	// Position of MMFAR field.
	SCB_MMFAR_MMFAR_Pos = 0x0
	// Bit mask of MMFAR field.
	SCB_MMFAR_MMFAR_Msk = 0xffffffff

	// BFAR: Bus fault address register
	// Position of BFAR field.
	SCB_BFAR_BFAR_Pos = 0x0
	// Bit mask of BFAR field.
	SCB_BFAR_BFAR_Msk = 0xffffffff

	// AFSR: Auxiliary fault status register
	// Position of IMPDEF field.
	SCB_AFSR_IMPDEF_Pos = 0x0
	// Bit mask of IMPDEF field.
	SCB_AFSR_IMPDEF_Msk = 0xffffffff
)

// Constants for SPI1: Serial peripheral interface/Inter-IC sound
const (
	// CR1: control register 1
	// Position of BIDIMODE field.
	SPI_CR1_BIDIMODE_Pos = 0xf
	// Bit mask of BIDIMODE field.
	SPI_CR1_BIDIMODE_Msk = 0x8000
	// Bit BIDIMODE.
	SPI_CR1_BIDIMODE = 0x8000
	// 2-line unidirectional data mode selected
	SPI_CR1_BIDIMODE_Unidirectional = 0x0
	// 1-line bidirectional data mode selected
	SPI_CR1_BIDIMODE_Bidirectional = 0x1
	// Position of BIDIOE field.
	SPI_CR1_BIDIOE_Pos = 0xe
	// Bit mask of BIDIOE field.
	SPI_CR1_BIDIOE_Msk = 0x4000
	// Bit BIDIOE.
	SPI_CR1_BIDIOE = 0x4000
	// Output disabled (receive-only mode)
	SPI_CR1_BIDIOE_OutputDisabled = 0x0
	// Output enabled (transmit-only mode)
	SPI_CR1_BIDIOE_OutputEnabled = 0x1
	// Position of CRCEN field.
	SPI_CR1_CRCEN_Pos = 0xd
	// Bit mask of CRCEN field.
	SPI_CR1_CRCEN_Msk = 0x2000
	// Bit CRCEN.
	SPI_CR1_CRCEN = 0x2000
	// CRC calculation disabled
	SPI_CR1_CRCEN_Disabled = 0x0
	// CRC calculation enabled
	SPI_CR1_CRCEN_Enabled = 0x1
	// Position of CRCNEXT field.
	SPI_CR1_CRCNEXT_Pos = 0xc
	// Bit mask of CRCNEXT field.
	SPI_CR1_CRCNEXT_Msk = 0x1000
	// Bit CRCNEXT.
	SPI_CR1_CRCNEXT = 0x1000
	// Next transmit value is from Tx buffer
	SPI_CR1_CRCNEXT_TxBuffer = 0x0
	// Next transmit value is from Tx CRC register
	SPI_CR1_CRCNEXT_CRC = 0x1
	// Position of CRCL field.
	SPI_CR1_CRCL_Pos = 0xb
	// Bit mask of CRCL field.
	SPI_CR1_CRCL_Msk = 0x800
	// Bit CRCL.
	SPI_CR1_CRCL = 0x800
	// 8-bit CRC length
	SPI_CR1_CRCL_EightBit = 0x0
	// 16-bit CRC length
	SPI_CR1_CRCL_SixteenBit = 0x1
	// Position of RXONLY field.
	SPI_CR1_RXONLY_Pos = 0xa
	// Bit mask of RXONLY field.
	SPI_CR1_RXONLY_Msk = 0x400
	// Bit RXONLY.
	SPI_CR1_RXONLY = 0x400
	// Full duplex (Transmit and receive)
	SPI_CR1_RXONLY_FullDuplex = 0x0
	// Output disabled (Receive-only mode)
	SPI_CR1_RXONLY_OutputDisabled = 0x1
	// Position of SSM field.
	SPI_CR1_SSM_Pos = 0x9
	// Bit mask of SSM field.
	SPI_CR1_SSM_Msk = 0x200
	// Bit SSM.
	SPI_CR1_SSM = 0x200
	// Software slave management disabled
	SPI_CR1_SSM_Disabled = 0x0
	// Software slave management enabled
	SPI_CR1_SSM_Enabled = 0x1
	// Position of SSI field.
	SPI_CR1_SSI_Pos = 0x8
	// Bit mask of SSI field.
	SPI_CR1_SSI_Msk = 0x100
	// Bit SSI.
	SPI_CR1_SSI = 0x100
	// 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
	SPI_CR1_SSI_SlaveSelected = 0x0
	// 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
	SPI_CR1_SSI_SlaveNotSelected = 0x1
	// Position of LSBFIRST field.
	SPI_CR1_LSBFIRST_Pos = 0x7
	// Bit mask of LSBFIRST field.
	SPI_CR1_LSBFIRST_Msk = 0x80
	// Bit LSBFIRST.
	SPI_CR1_LSBFIRST = 0x80
	// Data is transmitted/received with the MSB first
	SPI_CR1_LSBFIRST_MSBFirst = 0x0
	// Data is transmitted/received with the LSB first
	SPI_CR1_LSBFIRST_LSBFirst = 0x1
	// Position of SPE field.
	SPI_CR1_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI_CR1_SPE_Msk = 0x40
	// Bit SPE.
	SPI_CR1_SPE = 0x40
	// Peripheral disabled
	SPI_CR1_SPE_Disabled = 0x0
	// Peripheral enabled
	SPI_CR1_SPE_Enabled = 0x1
	// Position of BR field.
	SPI_CR1_BR_Pos = 0x3
	// Bit mask of BR field.
	SPI_CR1_BR_Msk = 0x38
	// f_PCLK / 2
	SPI_CR1_BR_Div2 = 0x0
	// f_PCLK / 4
	SPI_CR1_BR_Div4 = 0x1
	// f_PCLK / 8
	SPI_CR1_BR_Div8 = 0x2
	// f_PCLK / 16
	SPI_CR1_BR_Div16 = 0x3
	// f_PCLK / 32
	SPI_CR1_BR_Div32 = 0x4
	// f_PCLK / 64
	SPI_CR1_BR_Div64 = 0x5
	// f_PCLK / 128
	SPI_CR1_BR_Div128 = 0x6
	// f_PCLK / 256
	SPI_CR1_BR_Div256 = 0x7
	// Position of MSTR field.
	SPI_CR1_MSTR_Pos = 0x2
	// Bit mask of MSTR field.
	SPI_CR1_MSTR_Msk = 0x4
	// Bit MSTR.
	SPI_CR1_MSTR = 0x4
	// Slave configuration
	SPI_CR1_MSTR_Slave = 0x0
	// Master configuration
	SPI_CR1_MSTR_Master = 0x1
	// Position of CPOL field.
	SPI_CR1_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI_CR1_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI_CR1_CPOL = 0x2
	// CK to 0 when idle
	SPI_CR1_CPOL_IdleLow = 0x0
	// CK to 1 when idle
	SPI_CR1_CPOL_IdleHigh = 0x1
	// Position of CPHA field.
	SPI_CR1_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI_CR1_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI_CR1_CPHA = 0x1
	// The first clock transition is the first data capture edge
	SPI_CR1_CPHA_FirstEdge = 0x0
	// The second clock transition is the first data capture edge
	SPI_CR1_CPHA_SecondEdge = 0x1

	// CR2: control register 2
	// Position of RXDMAEN field.
	SPI_CR2_RXDMAEN_Pos = 0x0
	// Bit mask of RXDMAEN field.
	SPI_CR2_RXDMAEN_Msk = 0x1
	// Bit RXDMAEN.
	SPI_CR2_RXDMAEN = 0x1
	// Rx buffer DMA disabled
	SPI_CR2_RXDMAEN_Disabled = 0x0
	// Rx buffer DMA enabled
	SPI_CR2_RXDMAEN_Enabled = 0x1
	// Position of TXDMAEN field.
	SPI_CR2_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	SPI_CR2_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	SPI_CR2_TXDMAEN = 0x2
	// Tx buffer DMA disabled
	SPI_CR2_TXDMAEN_Disabled = 0x0
	// Tx buffer DMA enabled
	SPI_CR2_TXDMAEN_Enabled = 0x1
	// Position of SSOE field.
	SPI_CR2_SSOE_Pos = 0x2
	// Bit mask of SSOE field.
	SPI_CR2_SSOE_Msk = 0x4
	// Bit SSOE.
	SPI_CR2_SSOE = 0x4
	// SS output is disabled in master mode
	SPI_CR2_SSOE_Disabled = 0x0
	// SS output is enabled in master mode
	SPI_CR2_SSOE_Enabled = 0x1
	// Position of NSSP field.
	SPI_CR2_NSSP_Pos = 0x3
	// Bit mask of NSSP field.
	SPI_CR2_NSSP_Msk = 0x8
	// Bit NSSP.
	SPI_CR2_NSSP = 0x8
	// No NSS pulse
	SPI_CR2_NSSP_NoPulse = 0x0
	// NSS pulse generated
	SPI_CR2_NSSP_PulseGenerated = 0x1
	// Position of FRF field.
	SPI_CR2_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SPI_CR2_FRF_Msk = 0x10
	// Bit FRF.
	SPI_CR2_FRF = 0x10
	// SPI Motorola mode
	SPI_CR2_FRF_Motorola = 0x0
	// SPI TI mode
	SPI_CR2_FRF_TI = 0x1
	// Position of ERRIE field.
	SPI_CR2_ERRIE_Pos = 0x5
	// Bit mask of ERRIE field.
	SPI_CR2_ERRIE_Msk = 0x20
	// Bit ERRIE.
	SPI_CR2_ERRIE = 0x20
	// Error interrupt masked
	SPI_CR2_ERRIE_Masked = 0x0
	// Error interrupt not masked
	SPI_CR2_ERRIE_NotMasked = 0x1
	// Position of RXNEIE field.
	SPI_CR2_RXNEIE_Pos = 0x6
	// Bit mask of RXNEIE field.
	SPI_CR2_RXNEIE_Msk = 0x40
	// Bit RXNEIE.
	SPI_CR2_RXNEIE = 0x40
	// RXE interrupt masked
	SPI_CR2_RXNEIE_Masked = 0x0
	// RXE interrupt not masked
	SPI_CR2_RXNEIE_NotMasked = 0x1
	// Position of TXEIE field.
	SPI_CR2_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	SPI_CR2_TXEIE_Msk = 0x80
	// Bit TXEIE.
	SPI_CR2_TXEIE = 0x80
	// TXE interrupt masked
	SPI_CR2_TXEIE_Masked = 0x0
	// TXE interrupt not masked
	SPI_CR2_TXEIE_NotMasked = 0x1
	// Position of DS field.
	SPI_CR2_DS_Pos = 0x8
	// Bit mask of DS field.
	SPI_CR2_DS_Msk = 0xf00
	// 4-bit
	SPI_CR2_DS_FourBit = 0x3
	// 5-bit
	SPI_CR2_DS_FiveBit = 0x4
	// 6-bit
	SPI_CR2_DS_SixBit = 0x5
	// 7-bit
	SPI_CR2_DS_SevenBit = 0x6
	// 8-bit
	SPI_CR2_DS_EightBit = 0x7
	// 9-bit
	SPI_CR2_DS_NineBit = 0x8
	// 10-bit
	SPI_CR2_DS_TenBit = 0x9
	// 11-bit
	SPI_CR2_DS_ElevenBit = 0xa
	// 12-bit
	SPI_CR2_DS_TwelveBit = 0xb
	// 13-bit
	SPI_CR2_DS_ThirteenBit = 0xc
	// 14-bit
	SPI_CR2_DS_FourteenBit = 0xd
	// 15-bit
	SPI_CR2_DS_FifteenBit = 0xe
	// 16-bit
	SPI_CR2_DS_SixteenBit = 0xf
	// Position of FRXTH field.
	SPI_CR2_FRXTH_Pos = 0xc
	// Bit mask of FRXTH field.
	SPI_CR2_FRXTH_Msk = 0x1000
	// Bit FRXTH.
	SPI_CR2_FRXTH = 0x1000
	// RXNE event is generated if the FIFO level is greater than or equal to 1/2 (16-bit)
	SPI_CR2_FRXTH_Half = 0x0
	// RXNE event is generated if the FIFO level is greater than or equal to 1/4 (8-bit)
	SPI_CR2_FRXTH_Quarter = 0x1
	// Position of LDMA_RX field.
	SPI_CR2_LDMA_RX_Pos = 0xd
	// Bit mask of LDMA_RX field.
	SPI_CR2_LDMA_RX_Msk = 0x2000
	// Bit LDMA_RX.
	SPI_CR2_LDMA_RX = 0x2000
	// Number of data to transfer for receive is even
	SPI_CR2_LDMA_RX_Even = 0x0
	// Number of data to transfer for receive is odd
	SPI_CR2_LDMA_RX_Odd = 0x1
	// Position of LDMA_TX field.
	SPI_CR2_LDMA_TX_Pos = 0xe
	// Bit mask of LDMA_TX field.
	SPI_CR2_LDMA_TX_Msk = 0x4000
	// Bit LDMA_TX.
	SPI_CR2_LDMA_TX = 0x4000
	// Number of data to transfer for transmit is even
	SPI_CR2_LDMA_TX_Even = 0x0
	// Number of data to transfer for transmit is odd
	SPI_CR2_LDMA_TX_Odd = 0x1

	// SR: status register
	// Position of RXNE field.
	SPI_SR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPI_SR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPI_SR_RXNE = 0x1
	// Rx buffer empty
	SPI_SR_RXNE_Empty = 0x0
	// Rx buffer not empty
	SPI_SR_RXNE_NotEmpty = 0x1
	// Position of TXE field.
	SPI_SR_TXE_Pos = 0x1
	// Bit mask of TXE field.
	SPI_SR_TXE_Msk = 0x2
	// Bit TXE.
	SPI_SR_TXE = 0x2
	// Tx buffer not empty
	SPI_SR_TXE_NotEmpty = 0x0
	// Tx buffer empty
	SPI_SR_TXE_Empty = 0x1
	// Position of CHSIDE field.
	SPI_SR_CHSIDE_Pos = 0x2
	// Bit mask of CHSIDE field.
	SPI_SR_CHSIDE_Msk = 0x4
	// Bit CHSIDE.
	SPI_SR_CHSIDE = 0x4
	// Channel left has to be transmitted or has been received
	SPI_SR_CHSIDE_Left = 0x0
	// Channel right has to be transmitted or has been received
	SPI_SR_CHSIDE_Right = 0x1
	// Position of UDR field.
	SPI_SR_UDR_Pos = 0x3
	// Bit mask of UDR field.
	SPI_SR_UDR_Msk = 0x8
	// Bit UDR.
	SPI_SR_UDR = 0x8
	// No underrun occurred
	SPI_SR_UDR_NoUnderrun = 0x0
	// Underrun occurred
	SPI_SR_UDR_Underrun = 0x1
	// Position of CRCERR field.
	SPI_SR_CRCERR_Pos = 0x4
	// Bit mask of CRCERR field.
	SPI_SR_CRCERR_Msk = 0x10
	// Bit CRCERR.
	SPI_SR_CRCERR = 0x10
	// CRC value received matches the SPIx_RXCRCR value
	SPI_SR_CRCERR_Match = 0x0
	// CRC value received does not match the SPIx_RXCRCR value
	SPI_SR_CRCERR_NoMatch = 0x1
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x5
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x20
	// Bit MODF.
	SPI_SR_MODF = 0x20
	// No mode fault occurred
	SPI_SR_MODF_NoFault = 0x0
	// Mode fault occurred
	SPI_SR_MODF_Fault = 0x1
	// Position of OVR field.
	SPI_SR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	SPI_SR_OVR_Msk = 0x40
	// Bit OVR.
	SPI_SR_OVR = 0x40
	// No overrun occurred
	SPI_SR_OVR_NoOverrun = 0x0
	// Overrun occurred
	SPI_SR_OVR_Overrun = 0x1
	// Position of BSY field.
	SPI_SR_BSY_Pos = 0x7
	// Bit mask of BSY field.
	SPI_SR_BSY_Msk = 0x80
	// Bit BSY.
	SPI_SR_BSY = 0x80
	// SPI not busy
	SPI_SR_BSY_NotBusy = 0x0
	// SPI busy
	SPI_SR_BSY_Busy = 0x1
	// Position of FRE field.
	SPI_SR_FRE_Pos = 0x8
	// Bit mask of FRE field.
	SPI_SR_FRE_Msk = 0x100
	// Bit FRE.
	SPI_SR_FRE = 0x100
	// No frame format error
	SPI_SR_FRE_NoError = 0x0
	// A frame format error occurred
	SPI_SR_FRE_Error = 0x1
	// Position of FRLVL field.
	SPI_SR_FRLVL_Pos = 0x9
	// Bit mask of FRLVL field.
	SPI_SR_FRLVL_Msk = 0x600
	// Rx FIFO Empty
	SPI_SR_FRLVL_Empty = 0x0
	// Rx 1/4 FIFO
	SPI_SR_FRLVL_Quarter = 0x1
	// Rx 1/2 FIFO
	SPI_SR_FRLVL_Half = 0x2
	// Rx FIFO full
	SPI_SR_FRLVL_Full = 0x3
	// Position of FTLVL field.
	SPI_SR_FTLVL_Pos = 0xb
	// Bit mask of FTLVL field.
	SPI_SR_FTLVL_Msk = 0x1800
	// Tx FIFO Empty
	SPI_SR_FTLVL_Empty = 0x0
	// Tx 1/4 FIFO
	SPI_SR_FTLVL_Quarter = 0x1
	// Tx 1/2 FIFO
	SPI_SR_FTLVL_Half = 0x2
	// Tx FIFO full
	SPI_SR_FTLVL_Full = 0x3

	// DR: data register
	// Position of DR field.
	SPI_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	SPI_DR_DR_Msk = 0xffff

	// CRCPR: CRC polynomial register
	// Position of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Msk = 0xffff

	// RXCRCR: RX CRC register
	// Position of RxCRC field.
	SPI_RXCRCR_RxCRC_Pos = 0x0
	// Bit mask of RxCRC field.
	SPI_RXCRCR_RxCRC_Msk = 0xffff

	// TXCRCR: TX CRC register
	// Position of TxCRC field.
	SPI_TXCRCR_TxCRC_Pos = 0x0
	// Bit mask of TxCRC field.
	SPI_TXCRCR_TxCRC_Msk = 0xffff

	// I2SCFGR: configuration register
	// Position of CHLEN field.
	SPI_I2SCFGR_CHLEN_Pos = 0x0
	// Bit mask of CHLEN field.
	SPI_I2SCFGR_CHLEN_Msk = 0x1
	// Bit CHLEN.
	SPI_I2SCFGR_CHLEN = 0x1
	// 16-bit wide
	SPI_I2SCFGR_CHLEN_SixteenBit = 0x0
	// 32-bit wide
	SPI_I2SCFGR_CHLEN_ThirtyTwoBit = 0x1
	// Position of DATLEN field.
	SPI_I2SCFGR_DATLEN_Pos = 0x1
	// Bit mask of DATLEN field.
	SPI_I2SCFGR_DATLEN_Msk = 0x6
	// 16-bit data length
	SPI_I2SCFGR_DATLEN_SixteenBit = 0x0
	// 24-bit data length
	SPI_I2SCFGR_DATLEN_TwentyFourBit = 0x1
	// 32-bit data length
	SPI_I2SCFGR_DATLEN_ThirtyTwoBit = 0x2
	// Position of CKPOL field.
	SPI_I2SCFGR_CKPOL_Pos = 0x3
	// Bit mask of CKPOL field.
	SPI_I2SCFGR_CKPOL_Msk = 0x8
	// Bit CKPOL.
	SPI_I2SCFGR_CKPOL = 0x8
	// I2S clock inactive state is low level
	SPI_I2SCFGR_CKPOL_IdleLow = 0x0
	// I2S clock inactive state is high level
	SPI_I2SCFGR_CKPOL_IdleHigh = 0x1
	// Position of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Pos = 0x4
	// Bit mask of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Msk = 0x30
	// I2S Philips standard
	SPI_I2SCFGR_I2SSTD_Philips = 0x0
	// MSB justified standard
	SPI_I2SCFGR_I2SSTD_MSB = 0x1
	// LSB justified standard
	SPI_I2SCFGR_I2SSTD_LSB = 0x2
	// PCM standard
	SPI_I2SCFGR_I2SSTD_PCM = 0x3
	// Position of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Pos = 0x7
	// Bit mask of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Msk = 0x80
	// Bit PCMSYNC.
	SPI_I2SCFGR_PCMSYNC = 0x80
	// Short frame synchronisation
	SPI_I2SCFGR_PCMSYNC_Short = 0x0
	// Long frame synchronisation
	SPI_I2SCFGR_PCMSYNC_Long = 0x1
	// Position of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Pos = 0x8
	// Bit mask of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Msk = 0x300
	// Slave - transmit
	SPI_I2SCFGR_I2SCFG_SlaveTx = 0x0
	// Slave - receive
	SPI_I2SCFGR_I2SCFG_SlaveRx = 0x1
	// Master - transmit
	SPI_I2SCFGR_I2SCFG_MasterTx = 0x2
	// Master - receive
	SPI_I2SCFGR_I2SCFG_MasterRx = 0x3
	// Position of I2SE field.
	SPI_I2SCFGR_I2SE_Pos = 0xa
	// Bit mask of I2SE field.
	SPI_I2SCFGR_I2SE_Msk = 0x400
	// Bit I2SE.
	SPI_I2SCFGR_I2SE = 0x400
	// I2S peripheral is disabled
	SPI_I2SCFGR_I2SE_Disabled = 0x0
	// I2S peripheral is enabled
	SPI_I2SCFGR_I2SE_Enabled = 0x1
	// Position of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Pos = 0xb
	// Bit mask of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Msk = 0x800
	// Bit I2SMOD.
	SPI_I2SCFGR_I2SMOD = 0x800
	// SPI mode is selected
	SPI_I2SCFGR_I2SMOD_SPIMode = 0x0
	// I2S mode is selected
	SPI_I2SCFGR_I2SMOD_I2SMode = 0x1
	// Position of ASTRTEN field.
	SPI_I2SCFGR_ASTRTEN_Pos = 0xc
	// Bit mask of ASTRTEN field.
	SPI_I2SCFGR_ASTRTEN_Msk = 0x1000
	// Bit ASTRTEN.
	SPI_I2SCFGR_ASTRTEN = 0x1000

	// I2SPR: prescaler register
	// Position of I2SDIV field.
	SPI_I2SPR_I2SDIV_Pos = 0x0
	// Bit mask of I2SDIV field.
	SPI_I2SPR_I2SDIV_Msk = 0xff
	// Position of ODD field.
	SPI_I2SPR_ODD_Pos = 0x8
	// Bit mask of ODD field.
	SPI_I2SPR_ODD_Msk = 0x100
	// Bit ODD.
	SPI_I2SPR_ODD = 0x100
	// Real divider value is I2SDIV * 2
	SPI_I2SPR_ODD_Even = 0x0
	// Real divider value is (I2SDIV * 2) + 1
	SPI_I2SPR_ODD_Odd = 0x1
	// Position of MCKOE field.
	SPI_I2SPR_MCKOE_Pos = 0x9
	// Bit mask of MCKOE field.
	SPI_I2SPR_MCKOE_Msk = 0x200
	// Bit MCKOE.
	SPI_I2SPR_MCKOE = 0x200
	// Master clock output is disabled
	SPI_I2SPR_MCKOE_Disabled = 0x0
	// Master clock output is enabled
	SPI_I2SPR_MCKOE_Enabled = 0x1
)

// Constants for STK: SysTick timer
const (
	// CTRL: SysTick control and status register
	// Position of ENABLE field.
	STK_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	STK_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	STK_CTRL_ENABLE = 0x1
	// Position of TICKINT field.
	STK_CTRL_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	STK_CTRL_TICKINT_Msk = 0x2
	// Bit TICKINT.
	STK_CTRL_TICKINT = 0x2
	// Position of CLKSOURCE field.
	STK_CTRL_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	STK_CTRL_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	STK_CTRL_CLKSOURCE = 0x4
	// Position of COUNTFLAG field.
	STK_CTRL_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	STK_CTRL_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	STK_CTRL_COUNTFLAG = 0x10000

	// LOAD: SysTick reload value register
	// Position of RELOAD field.
	STK_LOAD_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	STK_LOAD_RELOAD_Msk = 0xffffff

	// VAL: SysTick current value register
	// Position of CURRENT field.
	STK_VAL_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	STK_VAL_CURRENT_Msk = 0xffffff

	// CALIB: SysTick calibration value register
	// Position of TENMS field.
	STK_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	STK_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	STK_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	STK_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	STK_CALIB_SKEW = 0x40000000
	// Position of NOREF field.
	STK_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	STK_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	STK_CALIB_NOREF = 0x80000000
)

// Constants for SYSCFG: System configuration controller
const (
	// MEMRMP: memory remap register
	// Position of MEM_MODE field.
	SYSCFG_MEMRMP_MEM_MODE_Pos = 0x0
	// Bit mask of MEM_MODE field.
	SYSCFG_MEMRMP_MEM_MODE_Msk = 0x7
	// Main Flash memory mapped at 0x0000_0000
	SYSCFG_MEMRMP_MEM_MODE_MainFlash = 0x0
	// System Flash memory mapped at 0x0000_0000
	SYSCFG_MEMRMP_MEM_MODE_SystemFlash = 0x1
	// Embedded SRAM mapped at 0x0000_0000
	SYSCFG_MEMRMP_MEM_MODE_SRAM = 0x3

	// CFGR1: configuration register 1
	// Position of I2C3_FMP field.
	SYSCFG_CFGR1_I2C3_FMP_Pos = 0x16
	// Bit mask of I2C3_FMP field.
	SYSCFG_CFGR1_I2C3_FMP_Msk = 0x400000
	// Bit I2C3_FMP.
	SYSCFG_CFGR1_I2C3_FMP = 0x400000
	// FM+ mode is controlled by I2C_Pxx_FMP bits only
	SYSCFG_CFGR1_I2C3_FMP_Standard = 0x0
	// FM+ mode is enabled on all I2C3 pins selected through selection bits in GPIOx_AFR registers
	SYSCFG_CFGR1_I2C3_FMP_FMP = 0x1
	// Position of I2C2_FMP field.
	SYSCFG_CFGR1_I2C2_FMP_Pos = 0x15
	// Bit mask of I2C2_FMP field.
	SYSCFG_CFGR1_I2C2_FMP_Msk = 0x200000
	// Bit I2C2_FMP.
	SYSCFG_CFGR1_I2C2_FMP = 0x200000
	// FM+ mode is controlled by I2C_Pxx_FMP bits only
	SYSCFG_CFGR1_I2C2_FMP_Standard = 0x0
	// FM+ mode is enabled on all I2C2 pins selected through selection bits in GPIOx_AFR registers
	SYSCFG_CFGR1_I2C2_FMP_FMP = 0x1
	// Position of I2C1_FMP field.
	SYSCFG_CFGR1_I2C1_FMP_Pos = 0x14
	// Bit mask of I2C1_FMP field.
	SYSCFG_CFGR1_I2C1_FMP_Msk = 0x100000
	// Bit I2C1_FMP.
	SYSCFG_CFGR1_I2C1_FMP = 0x100000
	// FM+ mode is controlled by I2C_Pxx_FMP bits only
	SYSCFG_CFGR1_I2C1_FMP_Standard = 0x0
	// FM+ mode is enabled on all I2C1 pins selected through selection bits in GPIOx_AFR registers
	SYSCFG_CFGR1_I2C1_FMP_FMP = 0x1
	// Position of I2C_PB9_FMP field.
	SYSCFG_CFGR1_I2C_PB9_FMP_Pos = 0x13
	// Bit mask of I2C_PB9_FMP field.
	SYSCFG_CFGR1_I2C_PB9_FMP_Msk = 0x80000
	// Bit I2C_PB9_FMP.
	SYSCFG_CFGR1_I2C_PB9_FMP = 0x80000
	// PB9 pin operate in standard mode
	SYSCFG_CFGR1_I2C_PB9_FMP_Standard = 0x0
	// I2C FM+ mode enabled on PB9 and the Speed control is bypassed
	SYSCFG_CFGR1_I2C_PB9_FMP_FMP = 0x1
	// Position of I2C_PB8_FMP field.
	SYSCFG_CFGR1_I2C_PB8_FMP_Pos = 0x12
	// Bit mask of I2C_PB8_FMP field.
	SYSCFG_CFGR1_I2C_PB8_FMP_Msk = 0x40000
	// Bit I2C_PB8_FMP.
	SYSCFG_CFGR1_I2C_PB8_FMP = 0x40000
	// PB8 pin operate in standard mode
	SYSCFG_CFGR1_I2C_PB8_FMP_Standard = 0x0
	// I2C FM+ mode enabled on PB8 and the Speed control is bypassed
	SYSCFG_CFGR1_I2C_PB8_FMP_FMP = 0x1
	// Position of I2C_PB7_FMP field.
	SYSCFG_CFGR1_I2C_PB7_FMP_Pos = 0x11
	// Bit mask of I2C_PB7_FMP field.
	SYSCFG_CFGR1_I2C_PB7_FMP_Msk = 0x20000
	// Bit I2C_PB7_FMP.
	SYSCFG_CFGR1_I2C_PB7_FMP = 0x20000
	// PB7 pin operate in standard mode
	SYSCFG_CFGR1_I2C_PB7_FMP_Standard = 0x0
	// I2C FM+ mode enabled on PB7 and the Speed control is bypassed
	SYSCFG_CFGR1_I2C_PB7_FMP_FMP = 0x1
	// Position of I2C_PB6_FMP field.
	SYSCFG_CFGR1_I2C_PB6_FMP_Pos = 0x10
	// Bit mask of I2C_PB6_FMP field.
	SYSCFG_CFGR1_I2C_PB6_FMP_Msk = 0x10000
	// Bit I2C_PB6_FMP.
	SYSCFG_CFGR1_I2C_PB6_FMP = 0x10000
	// PB6 pin operate in standard mode
	SYSCFG_CFGR1_I2C_PB6_FMP_Standard = 0x0
	// I2C FM+ mode enabled on PB6 and the Speed control is bypassed
	SYSCFG_CFGR1_I2C_PB6_FMP_FMP = 0x1
	// Position of BOOSTEN field.
	SYSCFG_CFGR1_BOOSTEN_Pos = 0x8
	// Bit mask of BOOSTEN field.
	SYSCFG_CFGR1_BOOSTEN_Msk = 0x100
	// Bit BOOSTEN.
	SYSCFG_CFGR1_BOOSTEN = 0x100
	// I/O analog switches are supplied by VDDA voltage. This is the recommended configuration when using the ADC in high VDDA voltage operation
	SYSCFG_CFGR1_BOOSTEN_Disabled = 0x0
	// I/O analog switches are supplied by a dedicated voltage booster (supplied by VDD). This is the recommended configuration when using the ADC in low VDDA voltage operation
	SYSCFG_CFGR1_BOOSTEN_Enabled = 0x1

	// EXTICR1: external interrupt configuration register 1
	// Position of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Pos = 0xc
	// Bit mask of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Msk = 0x7000
	// Select PA3 as the source input for the EXTI3 external interrupt
	SYSCFG_EXTICR1_EXTI3_PA3 = 0x0
	// Select PB3 as the source input for the EXTI3 external interrupt
	SYSCFG_EXTICR1_EXTI3_PB3 = 0x1
	// Select PC3 as the source input for the EXTI3 external interrupt
	SYSCFG_EXTICR1_EXTI3_PC3 = 0x2
	// Select PH3 as the source input for the EXTI3 external interrupt
	SYSCFG_EXTICR1_EXTI3_PH3 = 0x7
	// Position of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Pos = 0x8
	// Bit mask of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Msk = 0x700
	// Select PA2 as the source input for the EXTI2 external interrupt
	SYSCFG_EXTICR1_EXTI2_PA2 = 0x0
	// Select PB2 as the source input for the EXTI2 external interrupt
	SYSCFG_EXTICR1_EXTI2_PB2 = 0x1
	// Select PC2 as the source input for the EXTI2 external interrupt
	SYSCFG_EXTICR1_EXTI2_PC2 = 0x2
	// Position of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Pos = 0x4
	// Bit mask of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Msk = 0x70
	// Select PA1 as the source input for the EXTI1 external interrupt
	SYSCFG_EXTICR1_EXTI1_PA1 = 0x0
	// Select PB1 as the source input for the EXTI1 external interrupt
	SYSCFG_EXTICR1_EXTI1_PB1 = 0x1
	// Select PC1 as the source input for the EXTI1 external interrupt
	SYSCFG_EXTICR1_EXTI1_PC1 = 0x2
	// Position of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Pos = 0x0
	// Bit mask of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Msk = 0x7
	// Select PA0 as the source input for the EXTI0 external interrupt
	SYSCFG_EXTICR1_EXTI0_PA0 = 0x0
	// Select PB0 as the source input for the EXTI0 external interrupt
	SYSCFG_EXTICR1_EXTI0_PB0 = 0x1
	// Select PC0 as the source input for the EXTI0 external interrupt
	SYSCFG_EXTICR1_EXTI0_PC0 = 0x2

	// EXTICR2: external interrupt configuration register 2
	// Position of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Pos = 0xc
	// Bit mask of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Msk = 0x7000
	// Select PA7 as the source input for the EXTI7 external interrupt
	SYSCFG_EXTICR2_EXTI7_PA7 = 0x0
	// Select PB7 as the source input for the EXTI7 external interrupt
	SYSCFG_EXTICR2_EXTI7_PB7 = 0x1
	// Position of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Pos = 0x8
	// Bit mask of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Msk = 0x700
	// Select PA6 as the source input for the EXTI6 external interrupt
	SYSCFG_EXTICR2_EXTI6_PA6 = 0x0
	// Select PB6 as the source input for the EXTI6 external interrupt
	SYSCFG_EXTICR2_EXTI6_PB6 = 0x1
	// Select PC6 as the source input for the EXTI6 external interrupt
	SYSCFG_EXTICR2_EXTI6_PC6 = 0x2
	// Position of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Pos = 0x4
	// Bit mask of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Msk = 0x70
	// Select PA5 as the source input for the EXTI5 external interrupt
	SYSCFG_EXTICR2_EXTI5_PA5 = 0x0
	// Select PB5 as the source input for the EXTI5 external interrupt
	SYSCFG_EXTICR2_EXTI5_PB5 = 0x1
	// Select PC5 as the source input for the EXTI5 external interrupt
	SYSCFG_EXTICR2_EXTI5_PC5 = 0x2
	// Position of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Pos = 0x0
	// Bit mask of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Msk = 0x7
	// Select PA4 as the source input for the EXTI4 external interrupt
	SYSCFG_EXTICR2_EXTI4_PA4 = 0x0
	// Select PB4 as the source input for the EXTI4 external interrupt
	SYSCFG_EXTICR2_EXTI4_PB4 = 0x1
	// Select PC4 as the source input for the EXTI4 external interrupt
	SYSCFG_EXTICR2_EXTI4_PC4 = 0x2

	// EXTICR3: external interrupt configuration register 3
	// Position of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Pos = 0xc
	// Bit mask of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Msk = 0x7000
	// Select PA11 as the source input for the EXTI11 external interrupt
	SYSCFG_EXTICR3_EXTI11_PA11 = 0x0
	// Select PB11 as the source input for the EXTI11 external interrupt
	SYSCFG_EXTICR3_EXTI11_PB11 = 0x1
	// Position of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Pos = 0x8
	// Bit mask of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Msk = 0x700
	// Select PA10 as the source input for the EXTI10 external interrupt
	SYSCFG_EXTICR3_EXTI10_PA10 = 0x0
	// Select PB10 as the source input for the EXTI10 external interrupt
	SYSCFG_EXTICR3_EXTI10_PB10 = 0x1
	// Position of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Pos = 0x4
	// Bit mask of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Msk = 0x70
	// Select PA9 as the source input for the EXTI9 external interrupt
	SYSCFG_EXTICR3_EXTI9_PA9 = 0x0
	// Select PB9 as the source input for the EXTI9 external interrupt
	SYSCFG_EXTICR3_EXTI9_PB9 = 0x1
	// Position of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Pos = 0x0
	// Bit mask of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Msk = 0x7
	// Select PA8 as the source input for the EXTI8 external interrupt
	SYSCFG_EXTICR3_EXTI8_PA8 = 0x0
	// Select PB8 as the source input for the EXTI8 external interrupt
	SYSCFG_EXTICR3_EXTI8_PB8 = 0x1

	// EXTICR4: external interrupt configuration register 4
	// Position of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Pos = 0xc
	// Bit mask of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Msk = 0x7000
	// Select PA15 as the source input for the EXTI15 external interrupt
	SYSCFG_EXTICR4_EXTI15_PA15 = 0x0
	// Select PB15 as the source input for the EXTI15 external interrupt
	SYSCFG_EXTICR4_EXTI15_PB15 = 0x1
	// Select PC15 as the source input for the EXTI15 external interrupt
	SYSCFG_EXTICR4_EXTI15_PC15 = 0x2
	// Position of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Pos = 0x8
	// Bit mask of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Msk = 0x700
	// Select PA14 as the source input for the EXTI14 external interrupt
	SYSCFG_EXTICR4_EXTI14_PA14 = 0x0
	// Select PB14 as the source input for the EXTI14 external interrupt
	SYSCFG_EXTICR4_EXTI14_PB14 = 0x1
	// Select PC14 as the source input for the EXTI14 external interrupt
	SYSCFG_EXTICR4_EXTI14_PC14 = 0x2
	// Position of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Pos = 0x4
	// Bit mask of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Msk = 0x70
	// Select PA13 as the source input for the EXTI13 external interrupt
	SYSCFG_EXTICR4_EXTI13_PA13 = 0x0
	// Select PB13 as the source input for the EXTI13 external interrupt
	SYSCFG_EXTICR4_EXTI13_PB13 = 0x1
	// Select PC13 as the source input for the EXTI13 external interrupt
	SYSCFG_EXTICR4_EXTI13_PC13 = 0x2
	// Position of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Pos = 0x0
	// Bit mask of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Msk = 0x7
	// Select PA12 as the source input for the EXTI12 external interrupt
	SYSCFG_EXTICR4_EXTI12_PA12 = 0x0
	// Select PB12 as the source input for the EXTI12 external interrupt
	SYSCFG_EXTICR4_EXTI12_PB12 = 0x1

	// SCSR: SCSR
	// Position of PKASRAMBSY field.
	SYSCFG_SCSR_PKASRAMBSY_Pos = 0x8
	// Bit mask of PKASRAMBSY field.
	SYSCFG_SCSR_PKASRAMBSY_Msk = 0x100
	// Bit PKASRAMBSY.
	SYSCFG_SCSR_PKASRAMBSY = 0x100
	// No PKA SRAM erase operation is ongoing
	SYSCFG_SCSR_PKASRAMBSY_Idle = 0x0
	// PKA SRAM erase operation is ongoing
	SYSCFG_SCSR_PKASRAMBSY_Busy = 0x1
	// Position of SRAMBSY field.
	SYSCFG_SCSR_SRAMBSY_Pos = 0x1
	// Bit mask of SRAMBSY field.
	SYSCFG_SCSR_SRAMBSY_Msk = 0x2
	// Bit SRAMBSY.
	SYSCFG_SCSR_SRAMBSY = 0x2
	// No SRAM1 or SRAM2 erase operation is ongoing
	SYSCFG_SCSR_SRAMBSY_Idle = 0x0
	// SRAM1 or SRAM2 erase operation is ongoing
	SYSCFG_SCSR_SRAMBSY_Busy = 0x1
	// Position of SRAM2ER field.
	SYSCFG_SCSR_SRAM2ER_Pos = 0x0
	// Bit mask of SRAM2ER field.
	SYSCFG_SCSR_SRAM2ER_Msk = 0x1
	// Bit SRAM2ER.
	SYSCFG_SCSR_SRAM2ER = 0x1
	// Start SRAM2 erase operation
	SYSCFG_SCSR_SRAM2ER_Erase = 0x1

	// CFGR2: CFGR2
	// Position of SPF field.
	SYSCFG_CFGR2_SPF_Pos = 0x8
	// Bit mask of SPF field.
	SYSCFG_CFGR2_SPF_Msk = 0x100
	// Bit SPF.
	SYSCFG_CFGR2_SPF = 0x100
	// No SRAM2 parity error detected
	SYSCFG_CFGR2_SPF_Nominal = 0x0
	// SRAM2 parity error detected
	SYSCFG_CFGR2_SPF_Error = 0x1
	// Clear SRAM2 parity error flag
	SYSCFG_CFGR2_SPF_Clear = 0x1
	// Position of ECCL field.
	SYSCFG_CFGR2_ECCL_Pos = 0x3
	// Bit mask of ECCL field.
	SYSCFG_CFGR2_ECCL_Msk = 0x8
	// Bit ECCL.
	SYSCFG_CFGR2_ECCL = 0x8
	// ECC error disconnected from TIM1/16/17 break input
	SYSCFG_CFGR2_ECCL_Disconnected = 0x0
	// ECC error connected to TIM1/16/17 break input
	SYSCFG_CFGR2_ECCL_Connected = 0x1
	// Connect ECC error to TIM1/16/17 break input
	SYSCFG_CFGR2_ECCL_Connect = 0x1
	// Position of PVDL field.
	SYSCFG_CFGR2_PVDL_Pos = 0x2
	// Bit mask of PVDL field.
	SYSCFG_CFGR2_PVDL_Msk = 0x4
	// Bit PVDL.
	SYSCFG_CFGR2_PVDL = 0x4
	// PVD interrupt disconnected from TIM1/16/17 break input. PVDE and PLS[2:0] bits can be programmed by the application
	SYSCFG_CFGR2_PVDL_Disconnected = 0x0
	// PVD interrupt connected to TIM1/16/17 break input. PVDE and PLS[2:0] bits are read only
	SYSCFG_CFGR2_PVDL_Connected = 0x1
	// Connect PVD interretup to TIM1/16/17 break input
	SYSCFG_CFGR2_PVDL_Connect = 0x1
	// Position of SPL field.
	SYSCFG_CFGR2_SPL_Pos = 0x1
	// Bit mask of SPL field.
	SYSCFG_CFGR2_SPL_Msk = 0x2
	// Bit SPL.
	SYSCFG_CFGR2_SPL = 0x2
	// SRAM2 parity error signal disconnected from TIM1/16/17 break input
	SYSCFG_CFGR2_SPL_Disconnected = 0x0
	// SRAM2 parity error signal connected to TIM1/16/17 break input
	SYSCFG_CFGR2_SPL_Connected = 0x1
	// Connect SRAM2 parity error signal to TIM1/16/17 break input
	SYSCFG_CFGR2_SPL_Connect = 0x1
	// Position of CLL field.
	SYSCFG_CFGR2_CLL_Pos = 0x0
	// Bit mask of CLL field.
	SYSCFG_CFGR2_CLL_Msk = 0x1
	// Bit CLL.
	SYSCFG_CFGR2_CLL = 0x1
	// CPU LOCKUP output disconnected from TIM1/16/17 break input
	SYSCFG_CFGR2_CLL_Disconnected = 0x0
	// CPU LOCKUP output connected to TIM1/16/17 break input
	SYSCFG_CFGR2_CLL_Connected = 0x1
	// Connect CPU LOCKUP output to TIM1/16/17 break input
	SYSCFG_CFGR2_CLL_Connect = 0x1

	// SWPR: SWPR
	// Position of P31WP field.
	SYSCFG_SWPR_P31WP_Pos = 0x1f
	// Bit mask of P31WP field.
	SYSCFG_SWPR_P31WP_Msk = 0x80000000
	// Bit P31WP.
	SYSCFG_SWPR_P31WP = 0x80000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P31WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P31WP_Enabled = 0x1
	// Position of P30WP field.
	SYSCFG_SWPR_P30WP_Pos = 0x1e
	// Bit mask of P30WP field.
	SYSCFG_SWPR_P30WP_Msk = 0x40000000
	// Bit P30WP.
	SYSCFG_SWPR_P30WP = 0x40000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P30WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P30WP_Enabled = 0x1
	// Position of P29WP field.
	SYSCFG_SWPR_P29WP_Pos = 0x1d
	// Bit mask of P29WP field.
	SYSCFG_SWPR_P29WP_Msk = 0x20000000
	// Bit P29WP.
	SYSCFG_SWPR_P29WP = 0x20000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P29WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P29WP_Enabled = 0x1
	// Position of P28WP field.
	SYSCFG_SWPR_P28WP_Pos = 0x1c
	// Bit mask of P28WP field.
	SYSCFG_SWPR_P28WP_Msk = 0x10000000
	// Bit P28WP.
	SYSCFG_SWPR_P28WP = 0x10000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P28WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P28WP_Enabled = 0x1
	// Position of P27WP field.
	SYSCFG_SWPR_P27WP_Pos = 0x1b
	// Bit mask of P27WP field.
	SYSCFG_SWPR_P27WP_Msk = 0x8000000
	// Bit P27WP.
	SYSCFG_SWPR_P27WP = 0x8000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P27WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P27WP_Enabled = 0x1
	// Position of P26WP field.
	SYSCFG_SWPR_P26WP_Pos = 0x1a
	// Bit mask of P26WP field.
	SYSCFG_SWPR_P26WP_Msk = 0x4000000
	// Bit P26WP.
	SYSCFG_SWPR_P26WP = 0x4000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P26WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P26WP_Enabled = 0x1
	// Position of P25WP field.
	SYSCFG_SWPR_P25WP_Pos = 0x19
	// Bit mask of P25WP field.
	SYSCFG_SWPR_P25WP_Msk = 0x2000000
	// Bit P25WP.
	SYSCFG_SWPR_P25WP = 0x2000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P25WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P25WP_Enabled = 0x1
	// Position of P24WP field.
	SYSCFG_SWPR_P24WP_Pos = 0x18
	// Bit mask of P24WP field.
	SYSCFG_SWPR_P24WP_Msk = 0x1000000
	// Bit P24WP.
	SYSCFG_SWPR_P24WP = 0x1000000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P24WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P24WP_Enabled = 0x1
	// Position of P23WP field.
	SYSCFG_SWPR_P23WP_Pos = 0x17
	// Bit mask of P23WP field.
	SYSCFG_SWPR_P23WP_Msk = 0x800000
	// Bit P23WP.
	SYSCFG_SWPR_P23WP = 0x800000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P23WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P23WP_Enabled = 0x1
	// Position of P22WP field.
	SYSCFG_SWPR_P22WP_Pos = 0x16
	// Bit mask of P22WP field.
	SYSCFG_SWPR_P22WP_Msk = 0x400000
	// Bit P22WP.
	SYSCFG_SWPR_P22WP = 0x400000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P22WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P22WP_Enabled = 0x1
	// Position of P21WP field.
	SYSCFG_SWPR_P21WP_Pos = 0x15
	// Bit mask of P21WP field.
	SYSCFG_SWPR_P21WP_Msk = 0x200000
	// Bit P21WP.
	SYSCFG_SWPR_P21WP = 0x200000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P21WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P21WP_Enabled = 0x1
	// Position of P20WP field.
	SYSCFG_SWPR_P20WP_Pos = 0x14
	// Bit mask of P20WP field.
	SYSCFG_SWPR_P20WP_Msk = 0x100000
	// Bit P20WP.
	SYSCFG_SWPR_P20WP = 0x100000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P20WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P20WP_Enabled = 0x1
	// Position of P19WP field.
	SYSCFG_SWPR_P19WP_Pos = 0x13
	// Bit mask of P19WP field.
	SYSCFG_SWPR_P19WP_Msk = 0x80000
	// Bit P19WP.
	SYSCFG_SWPR_P19WP = 0x80000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P19WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P19WP_Enabled = 0x1
	// Position of P18WP field.
	SYSCFG_SWPR_P18WP_Pos = 0x12
	// Bit mask of P18WP field.
	SYSCFG_SWPR_P18WP_Msk = 0x40000
	// Bit P18WP.
	SYSCFG_SWPR_P18WP = 0x40000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P18WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P18WP_Enabled = 0x1
	// Position of P17WP field.
	SYSCFG_SWPR_P17WP_Pos = 0x11
	// Bit mask of P17WP field.
	SYSCFG_SWPR_P17WP_Msk = 0x20000
	// Bit P17WP.
	SYSCFG_SWPR_P17WP = 0x20000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P17WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P17WP_Enabled = 0x1
	// Position of P16WP field.
	SYSCFG_SWPR_P16WP_Pos = 0x10
	// Bit mask of P16WP field.
	SYSCFG_SWPR_P16WP_Msk = 0x10000
	// Bit P16WP.
	SYSCFG_SWPR_P16WP = 0x10000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P16WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P16WP_Enabled = 0x1
	// Position of P15WP field.
	SYSCFG_SWPR_P15WP_Pos = 0xf
	// Bit mask of P15WP field.
	SYSCFG_SWPR_P15WP_Msk = 0x8000
	// Bit P15WP.
	SYSCFG_SWPR_P15WP = 0x8000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P15WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P15WP_Enabled = 0x1
	// Position of P14WP field.
	SYSCFG_SWPR_P14WP_Pos = 0xe
	// Bit mask of P14WP field.
	SYSCFG_SWPR_P14WP_Msk = 0x4000
	// Bit P14WP.
	SYSCFG_SWPR_P14WP = 0x4000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P14WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P14WP_Enabled = 0x1
	// Position of P13WP field.
	SYSCFG_SWPR_P13WP_Pos = 0xd
	// Bit mask of P13WP field.
	SYSCFG_SWPR_P13WP_Msk = 0x2000
	// Bit P13WP.
	SYSCFG_SWPR_P13WP = 0x2000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P13WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P13WP_Enabled = 0x1
	// Position of P12WP field.
	SYSCFG_SWPR_P12WP_Pos = 0xc
	// Bit mask of P12WP field.
	SYSCFG_SWPR_P12WP_Msk = 0x1000
	// Bit P12WP.
	SYSCFG_SWPR_P12WP = 0x1000
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P12WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P12WP_Enabled = 0x1
	// Position of P11WP field.
	SYSCFG_SWPR_P11WP_Pos = 0xb
	// Bit mask of P11WP field.
	SYSCFG_SWPR_P11WP_Msk = 0x800
	// Bit P11WP.
	SYSCFG_SWPR_P11WP = 0x800
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P11WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P11WP_Enabled = 0x1
	// Position of P10WP field.
	SYSCFG_SWPR_P10WP_Pos = 0xa
	// Bit mask of P10WP field.
	SYSCFG_SWPR_P10WP_Msk = 0x400
	// Bit P10WP.
	SYSCFG_SWPR_P10WP = 0x400
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P10WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P10WP_Enabled = 0x1
	// Position of P9WP field.
	SYSCFG_SWPR_P9WP_Pos = 0x9
	// Bit mask of P9WP field.
	SYSCFG_SWPR_P9WP_Msk = 0x200
	// Bit P9WP.
	SYSCFG_SWPR_P9WP = 0x200
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P9WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P9WP_Enabled = 0x1
	// Position of P8WP field.
	SYSCFG_SWPR_P8WP_Pos = 0x8
	// Bit mask of P8WP field.
	SYSCFG_SWPR_P8WP_Msk = 0x100
	// Bit P8WP.
	SYSCFG_SWPR_P8WP = 0x100
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P8WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P8WP_Enabled = 0x1
	// Position of P7WP field.
	SYSCFG_SWPR_P7WP_Pos = 0x7
	// Bit mask of P7WP field.
	SYSCFG_SWPR_P7WP_Msk = 0x80
	// Bit P7WP.
	SYSCFG_SWPR_P7WP = 0x80
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P7WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P7WP_Enabled = 0x1
	// Position of P6WP field.
	SYSCFG_SWPR_P6WP_Pos = 0x6
	// Bit mask of P6WP field.
	SYSCFG_SWPR_P6WP_Msk = 0x40
	// Bit P6WP.
	SYSCFG_SWPR_P6WP = 0x40
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P6WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P6WP_Enabled = 0x1
	// Position of P5WP field.
	SYSCFG_SWPR_P5WP_Pos = 0x5
	// Bit mask of P5WP field.
	SYSCFG_SWPR_P5WP_Msk = 0x20
	// Bit P5WP.
	SYSCFG_SWPR_P5WP = 0x20
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P5WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P5WP_Enabled = 0x1
	// Position of P4WP field.
	SYSCFG_SWPR_P4WP_Pos = 0x4
	// Bit mask of P4WP field.
	SYSCFG_SWPR_P4WP_Msk = 0x10
	// Bit P4WP.
	SYSCFG_SWPR_P4WP = 0x10
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P4WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P4WP_Enabled = 0x1
	// Position of P3WP field.
	SYSCFG_SWPR_P3WP_Pos = 0x3
	// Bit mask of P3WP field.
	SYSCFG_SWPR_P3WP_Msk = 0x8
	// Bit P3WP.
	SYSCFG_SWPR_P3WP = 0x8
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P3WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P3WP_Enabled = 0x1
	// Position of P2WP field.
	SYSCFG_SWPR_P2WP_Pos = 0x2
	// Bit mask of P2WP field.
	SYSCFG_SWPR_P2WP_Msk = 0x4
	// Bit P2WP.
	SYSCFG_SWPR_P2WP = 0x4
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P2WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P2WP_Enabled = 0x1
	// Position of P1WP field.
	SYSCFG_SWPR_P1WP_Pos = 0x1
	// Bit mask of P1WP field.
	SYSCFG_SWPR_P1WP_Msk = 0x2
	// Bit P1WP.
	SYSCFG_SWPR_P1WP = 0x2
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P1WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P1WP_Enabled = 0x1
	// Position of P0WP field.
	SYSCFG_SWPR_P0WP_Pos = 0x0
	// Bit mask of P0WP field.
	SYSCFG_SWPR_P0WP_Msk = 0x1
	// Bit P0WP.
	SYSCFG_SWPR_P0WP = 0x1
	// SRAM2 1 KB page protection disabled
	SYSCFG_SWPR_P0WP_Disabled = 0x0
	// SRAM2 1 KB page protection enabled
	SYSCFG_SWPR_P0WP_Enabled = 0x1

	// SKR: SKR
	// Position of KEY field.
	SYSCFG_SKR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	SYSCFG_SKR_KEY_Msk = 0xff
	// Step 1 to remove SRAM2ER bits write protection
	SYSCFG_SKR_KEY_Step1 = 0xca
	// Step 2 to remove SRAM2ER bits write protection
	SYSCFG_SKR_KEY_Step2 = 0x53
	// Activate SRAM2ER bits write protection
	SYSCFG_SKR_KEY_WriteProtect = 0x11

	// RFDCR: radio debug control register
	// Position of RFTBSEL field.
	SYSCFG_RFDCR_RFTBSEL_Pos = 0x0
	// Bit mask of RFTBSEL field.
	SYSCFG_RFDCR_RFTBSEL_Msk = 0x1
	// Bit RFTBSEL.
	SYSCFG_RFDCR_RFTBSEL = 0x1
	// Digital test bus selected on RF_ADTB[3:0]
	SYSCFG_RFDCR_RFTBSEL_Digital = 0x0
	// Analog test bus selected on RF_ADTB[3:0]
	SYSCFG_RFDCR_RFTBSEL_Analog = 0x1
)

// Constants for TAMP: Tamper and backup registers
const (
	// CR1: control register 1
	// Position of TAMP1E field.
	TAMP_CR1_TAMP1E_Pos = 0x0
	// Bit mask of TAMP1E field.
	TAMP_CR1_TAMP1E_Msk = 0x1
	// Bit TAMP1E.
	TAMP_CR1_TAMP1E = 0x1
	// Tamper detection on TAMP_INx is disabled
	TAMP_CR1_TAMP1E_Disabled = 0x0
	// Tamper detection on TAMP_IN3 is enabled
	TAMP_CR1_TAMP1E_Enabled = 0x1
	// Position of TAMP2E field.
	TAMP_CR1_TAMP2E_Pos = 0x1
	// Bit mask of TAMP2E field.
	TAMP_CR1_TAMP2E_Msk = 0x2
	// Bit TAMP2E.
	TAMP_CR1_TAMP2E = 0x2
	// Tamper detection on TAMP_INx is disabled
	TAMP_CR1_TAMP2E_Disabled = 0x0
	// Tamper detection on TAMP_IN3 is enabled
	TAMP_CR1_TAMP2E_Enabled = 0x1
	// Position of TAMP3E field.
	TAMP_CR1_TAMP3E_Pos = 0x2
	// Bit mask of TAMP3E field.
	TAMP_CR1_TAMP3E_Msk = 0x4
	// Bit TAMP3E.
	TAMP_CR1_TAMP3E = 0x4
	// Tamper detection on TAMP_INx is disabled
	TAMP_CR1_TAMP3E_Disabled = 0x0
	// Tamper detection on TAMP_IN3 is enabled
	TAMP_CR1_TAMP3E_Enabled = 0x1
	// Position of ITAMP3E field.
	TAMP_CR1_ITAMP3E_Pos = 0x12
	// Bit mask of ITAMP3E field.
	TAMP_CR1_ITAMP3E_Msk = 0x40000
	// Bit ITAMP3E.
	TAMP_CR1_ITAMP3E = 0x40000
	// Internal tamper x disabled
	TAMP_CR1_ITAMP3E_Disabled = 0x0
	// Internal tamper x enabled
	TAMP_CR1_ITAMP3E_Enabled = 0x1
	// Position of ITAMP5E field.
	TAMP_CR1_ITAMP5E_Pos = 0x14
	// Bit mask of ITAMP5E field.
	TAMP_CR1_ITAMP5E_Msk = 0x100000
	// Bit ITAMP5E.
	TAMP_CR1_ITAMP5E = 0x100000
	// Internal tamper x disabled
	TAMP_CR1_ITAMP5E_Disabled = 0x0
	// Internal tamper x enabled
	TAMP_CR1_ITAMP5E_Enabled = 0x1
	// Position of ITAMP6E field.
	TAMP_CR1_ITAMP6E_Pos = 0x15
	// Bit mask of ITAMP6E field.
	TAMP_CR1_ITAMP6E_Msk = 0x200000
	// Bit ITAMP6E.
	TAMP_CR1_ITAMP6E = 0x200000
	// Internal tamper x disabled
	TAMP_CR1_ITAMP6E_Disabled = 0x0
	// Internal tamper x enabled
	TAMP_CR1_ITAMP6E_Enabled = 0x1
	// Position of ITAMP8E field.
	TAMP_CR1_ITAMP8E_Pos = 0x17
	// Bit mask of ITAMP8E field.
	TAMP_CR1_ITAMP8E_Msk = 0x800000
	// Bit ITAMP8E.
	TAMP_CR1_ITAMP8E = 0x800000
	// Internal tamper x disabled
	TAMP_CR1_ITAMP8E_Disabled = 0x0
	// Internal tamper x enabled
	TAMP_CR1_ITAMP8E_Enabled = 0x1

	// CR2: control register 2
	// Position of TAMP1NOER field.
	TAMP_CR2_TAMP1NOER_Pos = 0x0
	// Bit mask of TAMP1NOER field.
	TAMP_CR2_TAMP1NOER_Msk = 0x1
	// Bit TAMP1NOER.
	TAMP_CR2_TAMP1NOER = 0x1
	// Tamper x event erases the backup registers
	TAMP_CR2_TAMP1NOER_Erase = 0x0
	// Tamper x event does not erase the backup registers
	TAMP_CR2_TAMP1NOER_NotErase = 0x1
	// Position of TAMP2NOER field.
	TAMP_CR2_TAMP2NOER_Pos = 0x1
	// Bit mask of TAMP2NOER field.
	TAMP_CR2_TAMP2NOER_Msk = 0x2
	// Bit TAMP2NOER.
	TAMP_CR2_TAMP2NOER = 0x2
	// Tamper x event erases the backup registers
	TAMP_CR2_TAMP2NOER_Erase = 0x0
	// Tamper x event does not erase the backup registers
	TAMP_CR2_TAMP2NOER_NotErase = 0x1
	// Position of TAMP3NOER field.
	TAMP_CR2_TAMP3NOER_Pos = 0x2
	// Bit mask of TAMP3NOER field.
	TAMP_CR2_TAMP3NOER_Msk = 0x4
	// Bit TAMP3NOER.
	TAMP_CR2_TAMP3NOER = 0x4
	// Tamper x event erases the backup registers
	TAMP_CR2_TAMP3NOER_Erase = 0x0
	// Tamper x event does not erase the backup registers
	TAMP_CR2_TAMP3NOER_NotErase = 0x1
	// Position of TAMP1MSK field.
	TAMP_CR2_TAMP1MSK_Pos = 0x10
	// Bit mask of TAMP1MSK field.
	TAMP_CR2_TAMP1MSK_Msk = 0x10000
	// Bit TAMP1MSK.
	TAMP_CR2_TAMP1MSK = 0x10000
	// Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection
	TAMP_CR2_TAMP1MSK_ResetBySoftware = 0x0
	// Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased. The tamper x interrupt must not be enabled when TAMP3MSK is set
	TAMP_CR2_TAMP1MSK_ResetByHardware = 0x1
	// Position of TAMP2MSK field.
	TAMP_CR2_TAMP2MSK_Pos = 0x11
	// Bit mask of TAMP2MSK field.
	TAMP_CR2_TAMP2MSK_Msk = 0x20000
	// Bit TAMP2MSK.
	TAMP_CR2_TAMP2MSK = 0x20000
	// Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection
	TAMP_CR2_TAMP2MSK_ResetBySoftware = 0x0
	// Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased. The tamper x interrupt must not be enabled when TAMP3MSK is set
	TAMP_CR2_TAMP2MSK_ResetByHardware = 0x1
	// Position of TAMP3MSK field.
	TAMP_CR2_TAMP3MSK_Pos = 0x12
	// Bit mask of TAMP3MSK field.
	TAMP_CR2_TAMP3MSK_Msk = 0x40000
	// Bit TAMP3MSK.
	TAMP_CR2_TAMP3MSK = 0x40000
	// Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection
	TAMP_CR2_TAMP3MSK_ResetBySoftware = 0x0
	// Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased. The tamper x interrupt must not be enabled when TAMP3MSK is set
	TAMP_CR2_TAMP3MSK_ResetByHardware = 0x1
	// Position of BKERASE field.
	TAMP_CR2_BKERASE_Pos = 0x17
	// Bit mask of BKERASE field.
	TAMP_CR2_BKERASE_Msk = 0x800000
	// Bit BKERASE.
	TAMP_CR2_BKERASE = 0x800000
	// Reset backup registers
	TAMP_CR2_BKERASE_Reset = 0x1
	// Position of TAMP1TRG field.
	TAMP_CR2_TAMP1TRG_Pos = 0x18
	// Bit mask of TAMP1TRG field.
	TAMP_CR2_TAMP1TRG_Msk = 0x1000000
	// Bit TAMP1TRG.
	TAMP_CR2_TAMP1TRG = 0x1000000
	// If TAMPFLT != 00 Tamper x input staying low triggers a tamper detection event. If TAMPFLT = 00 Tamper x input rising edge and high level triggers a tamper detection event
	TAMP_CR2_TAMP1TRG_FilteredLowOrUnfilteredHigh = 0x0
	// If TAMPFLT != 00 Tamper x input staying high triggers a tamper detection event. If TAMPFLT = 00 Tamper x input falling edge and low level triggers a tamper detection event
	TAMP_CR2_TAMP1TRG_FilteredHighOrUnfilteredLow = 0x1
	// Position of TAMP2TRG field.
	TAMP_CR2_TAMP2TRG_Pos = 0x19
	// Bit mask of TAMP2TRG field.
	TAMP_CR2_TAMP2TRG_Msk = 0x2000000
	// Bit TAMP2TRG.
	TAMP_CR2_TAMP2TRG = 0x2000000
	// If TAMPFLT != 00 Tamper x input staying low triggers a tamper detection event. If TAMPFLT = 00 Tamper x input rising edge and high level triggers a tamper detection event
	TAMP_CR2_TAMP2TRG_FilteredLowOrUnfilteredHigh = 0x0
	// If TAMPFLT != 00 Tamper x input staying high triggers a tamper detection event. If TAMPFLT = 00 Tamper x input falling edge and low level triggers a tamper detection event
	TAMP_CR2_TAMP2TRG_FilteredHighOrUnfilteredLow = 0x1
	// Position of TAMP3TRG field.
	TAMP_CR2_TAMP3TRG_Pos = 0x1a
	// Bit mask of TAMP3TRG field.
	TAMP_CR2_TAMP3TRG_Msk = 0x4000000
	// Bit TAMP3TRG.
	TAMP_CR2_TAMP3TRG = 0x4000000
	// If TAMPFLT != 00 Tamper x input staying low triggers a tamper detection event. If TAMPFLT = 00 Tamper x input rising edge and high level triggers a tamper detection event
	TAMP_CR2_TAMP3TRG_FilteredLowOrUnfilteredHigh = 0x0
	// If TAMPFLT != 00 Tamper x input staying high triggers a tamper detection event. If TAMPFLT = 00 Tamper x input falling edge and low level triggers a tamper detection event
	TAMP_CR2_TAMP3TRG_FilteredHighOrUnfilteredLow = 0x1

	// CR3: TAMP control register 3
	// Position of ITAMP3NOER field.
	TAMP_CR3_ITAMP3NOER_Pos = 0x2
	// Bit mask of ITAMP3NOER field.
	TAMP_CR3_ITAMP3NOER_Msk = 0x4
	// Bit ITAMP3NOER.
	TAMP_CR3_ITAMP3NOER = 0x4
	// Internal tamper x event erases the backup registers
	TAMP_CR3_ITAMP3NOER_Erase = 0x0
	// Internal tamper x event does not erase the backup registers
	TAMP_CR3_ITAMP3NOER_NotErase = 0x1
	// Position of ITAMP5NOER field.
	TAMP_CR3_ITAMP5NOER_Pos = 0x4
	// Bit mask of ITAMP5NOER field.
	TAMP_CR3_ITAMP5NOER_Msk = 0x10
	// Bit ITAMP5NOER.
	TAMP_CR3_ITAMP5NOER = 0x10
	// Internal tamper x event erases the backup registers
	TAMP_CR3_ITAMP5NOER_Erase = 0x0
	// Internal tamper x event does not erase the backup registers
	TAMP_CR3_ITAMP5NOER_NotErase = 0x1
	// Position of ITAMP6NOER field.
	TAMP_CR3_ITAMP6NOER_Pos = 0x5
	// Bit mask of ITAMP6NOER field.
	TAMP_CR3_ITAMP6NOER_Msk = 0x20
	// Bit ITAMP6NOER.
	TAMP_CR3_ITAMP6NOER = 0x20
	// Internal tamper x event erases the backup registers
	TAMP_CR3_ITAMP6NOER_Erase = 0x0
	// Internal tamper x event does not erase the backup registers
	TAMP_CR3_ITAMP6NOER_NotErase = 0x1
	// Position of ITAMP8NOER field.
	TAMP_CR3_ITAMP8NOER_Pos = 0x7
	// Bit mask of ITAMP8NOER field.
	TAMP_CR3_ITAMP8NOER_Msk = 0x80
	// Bit ITAMP8NOER.
	TAMP_CR3_ITAMP8NOER = 0x80
	// Internal tamper x event erases the backup registers
	TAMP_CR3_ITAMP8NOER_Erase = 0x0
	// Internal tamper x event does not erase the backup registers
	TAMP_CR3_ITAMP8NOER_NotErase = 0x1

	// FLTCR: TAMP filter control register
	// Position of TAMPFREQ field.
	TAMP_FLTCR_TAMPFREQ_Pos = 0x0
	// Bit mask of TAMPFREQ field.
	TAMP_FLTCR_TAMPFREQ_Msk = 0x7
	// RTCCLK / 32768 (1 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_1 = 0x0
	// RTCCLK / 16384 (2 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_2 = 0x1
	// RTCCLK / 8192 (4 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_4 = 0x2
	// RTCCLK / 4096 (8 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_8 = 0x3
	// RTCCLK / 2048 (16 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_16 = 0x4
	// RTCCLK / 1024 (32 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_32 = 0x5
	// RTCCLK / 512 (64 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_64 = 0x6
	// RTCCLK / 256 (128 Hz when RTCCLK = 32768 Hz)
	TAMP_FLTCR_TAMPFREQ_Hz_128 = 0x7
	// Position of TAMPFLT field.
	TAMP_FLTCR_TAMPFLT_Pos = 0x3
	// Bit mask of TAMPFLT field.
	TAMP_FLTCR_TAMPFLT_Msk = 0x18
	// Tamper event is activated on edge of TAMP_INx input transitions to the active level (no internal pull-up on TAMP_INx input)"
	TAMP_FLTCR_TAMPFLT_NoFilter = 0x0
	// Tamper event is activated after 2 consecutive samples at the active level"
	TAMP_FLTCR_TAMPFLT_Filter2 = 0x1
	// Tamper event is activated after 4 consecutive samples at the active level"
	TAMP_FLTCR_TAMPFLT_Filter4 = 0x2
	// Tamper event is activated after 8 consecutive samples at the active level"
	TAMP_FLTCR_TAMPFLT_Filter8 = 0x3
	// Position of TAMPPRCH field.
	TAMP_FLTCR_TAMPPRCH_Pos = 0x5
	// Bit mask of TAMPPRCH field.
	TAMP_FLTCR_TAMPPRCH_Msk = 0x60
	// 1 RTCCLK cycle
	TAMP_FLTCR_TAMPPRCH_Cycles1 = 0x0
	// 2 RTCCLK cycles
	TAMP_FLTCR_TAMPPRCH_Cycles2 = 0x1
	// 4 RTCCLK cycles
	TAMP_FLTCR_TAMPPRCH_Cycles4 = 0x2
	// 8 RTCCLK cycles
	TAMP_FLTCR_TAMPPRCH_Cycles8 = 0x3
	// Position of TAMPPUDIS field.
	TAMP_FLTCR_TAMPPUDIS_Pos = 0x7
	// Bit mask of TAMPPUDIS field.
	TAMP_FLTCR_TAMPPUDIS_Msk = 0x80
	// Bit TAMPPUDIS.
	TAMP_FLTCR_TAMPPUDIS = 0x80
	// Precharge TAMP_INx pins before sampling (enable internal pull-up)
	TAMP_FLTCR_TAMPPUDIS_Enabled = 0x0
	// Disable precharge of TAMP_INx pins
	TAMP_FLTCR_TAMPPUDIS_Disabled = 0x1

	// IER: TAMP interrupt enable register
	// Position of TAMP1IE field.
	TAMP_IER_TAMP1IE_Pos = 0x0
	// Bit mask of TAMP1IE field.
	TAMP_IER_TAMP1IE_Msk = 0x1
	// Bit TAMP1IE.
	TAMP_IER_TAMP1IE = 0x1
	// Tamper x interrupt disabled
	TAMP_IER_TAMP1IE_Disabled = 0x0
	// Tampoer x interrupt enabled
	TAMP_IER_TAMP1IE_Enabled = 0x1
	// Position of TAMP2IE field.
	TAMP_IER_TAMP2IE_Pos = 0x1
	// Bit mask of TAMP2IE field.
	TAMP_IER_TAMP2IE_Msk = 0x2
	// Bit TAMP2IE.
	TAMP_IER_TAMP2IE = 0x2
	// Tamper x interrupt disabled
	TAMP_IER_TAMP2IE_Disabled = 0x0
	// Tampoer x interrupt enabled
	TAMP_IER_TAMP2IE_Enabled = 0x1
	// Position of TAMP3IE field.
	TAMP_IER_TAMP3IE_Pos = 0x2
	// Bit mask of TAMP3IE field.
	TAMP_IER_TAMP3IE_Msk = 0x4
	// Bit TAMP3IE.
	TAMP_IER_TAMP3IE = 0x4
	// Tamper x interrupt disabled
	TAMP_IER_TAMP3IE_Disabled = 0x0
	// Tampoer x interrupt enabled
	TAMP_IER_TAMP3IE_Enabled = 0x1
	// Position of ITAMP3IE field.
	TAMP_IER_ITAMP3IE_Pos = 0x12
	// Bit mask of ITAMP3IE field.
	TAMP_IER_ITAMP3IE_Msk = 0x40000
	// Bit ITAMP3IE.
	TAMP_IER_ITAMP3IE = 0x40000
	// Internal tamper x interrupt disabled
	TAMP_IER_ITAMP3IE_Disabled = 0x0
	// Internal tamper x interrupt enabled
	TAMP_IER_ITAMP3IE_Enabled = 0x1
	// Position of ITAMP5IE field.
	TAMP_IER_ITAMP5IE_Pos = 0x14
	// Bit mask of ITAMP5IE field.
	TAMP_IER_ITAMP5IE_Msk = 0x100000
	// Bit ITAMP5IE.
	TAMP_IER_ITAMP5IE = 0x100000
	// Internal tamper x interrupt disabled
	TAMP_IER_ITAMP5IE_Disabled = 0x0
	// Internal tamper x interrupt enabled
	TAMP_IER_ITAMP5IE_Enabled = 0x1
	// Position of ITAMP6IE field.
	TAMP_IER_ITAMP6IE_Pos = 0x15
	// Bit mask of ITAMP6IE field.
	TAMP_IER_ITAMP6IE_Msk = 0x200000
	// Bit ITAMP6IE.
	TAMP_IER_ITAMP6IE = 0x200000
	// Internal tamper x interrupt disabled
	TAMP_IER_ITAMP6IE_Disabled = 0x0
	// Internal tamper x interrupt enabled
	TAMP_IER_ITAMP6IE_Enabled = 0x1
	// Position of ITAMP8IE field.
	TAMP_IER_ITAMP8IE_Pos = 0x17
	// Bit mask of ITAMP8IE field.
	TAMP_IER_ITAMP8IE_Msk = 0x800000
	// Bit ITAMP8IE.
	TAMP_IER_ITAMP8IE = 0x800000
	// Internal tamper x interrupt disabled
	TAMP_IER_ITAMP8IE_Disabled = 0x0
	// Internal tamper x interrupt enabled
	TAMP_IER_ITAMP8IE_Enabled = 0x1

	// SR: TAMP status register
	// Position of TAMP1F field.
	TAMP_SR_TAMP1F_Pos = 0x0
	// Bit mask of TAMP1F field.
	TAMP_SR_TAMP1F_Msk = 0x1
	// Bit TAMP1F.
	TAMP_SR_TAMP1F = 0x1
	// No tamper detected
	TAMP_SR_TAMP1F_Idle = 0x0
	// Tamper detected
	TAMP_SR_TAMP1F_Tamper = 0x1
	// Position of TAMP2F field.
	TAMP_SR_TAMP2F_Pos = 0x1
	// Bit mask of TAMP2F field.
	TAMP_SR_TAMP2F_Msk = 0x2
	// Bit TAMP2F.
	TAMP_SR_TAMP2F = 0x2
	// No tamper detected
	TAMP_SR_TAMP2F_Idle = 0x0
	// Tamper detected
	TAMP_SR_TAMP2F_Tamper = 0x1
	// Position of TAMP3F field.
	TAMP_SR_TAMP3F_Pos = 0x2
	// Bit mask of TAMP3F field.
	TAMP_SR_TAMP3F_Msk = 0x4
	// Bit TAMP3F.
	TAMP_SR_TAMP3F = 0x4
	// No tamper detected
	TAMP_SR_TAMP3F_Idle = 0x0
	// Tamper detected
	TAMP_SR_TAMP3F_Tamper = 0x1
	// Position of ITAMP3F field.
	TAMP_SR_ITAMP3F_Pos = 0x12
	// Bit mask of ITAMP3F field.
	TAMP_SR_ITAMP3F_Msk = 0x40000
	// Bit ITAMP3F.
	TAMP_SR_ITAMP3F = 0x40000
	// No tamper detected
	TAMP_SR_ITAMP3F_Idle = 0x0
	// Internal tamper detected
	TAMP_SR_ITAMP3F_Tamper = 0x1
	// Position of ITAMP5F field.
	TAMP_SR_ITAMP5F_Pos = 0x14
	// Bit mask of ITAMP5F field.
	TAMP_SR_ITAMP5F_Msk = 0x100000
	// Bit ITAMP5F.
	TAMP_SR_ITAMP5F = 0x100000
	// No tamper detected
	TAMP_SR_ITAMP5F_Idle = 0x0
	// Internal tamper detected
	TAMP_SR_ITAMP5F_Tamper = 0x1
	// Position of ITAMP6F field.
	TAMP_SR_ITAMP6F_Pos = 0x15
	// Bit mask of ITAMP6F field.
	TAMP_SR_ITAMP6F_Msk = 0x200000
	// Bit ITAMP6F.
	TAMP_SR_ITAMP6F = 0x200000
	// No tamper detected
	TAMP_SR_ITAMP6F_Idle = 0x0
	// Internal tamper detected
	TAMP_SR_ITAMP6F_Tamper = 0x1
	// Position of ITAMP8F field.
	TAMP_SR_ITAMP8F_Pos = 0x17
	// Bit mask of ITAMP8F field.
	TAMP_SR_ITAMP8F_Msk = 0x800000
	// Bit ITAMP8F.
	TAMP_SR_ITAMP8F = 0x800000
	// No tamper detected
	TAMP_SR_ITAMP8F_Idle = 0x0
	// Internal tamper detected
	TAMP_SR_ITAMP8F_Tamper = 0x1

	// MISR: TAMP masked interrupt status register
	// Position of TAMP1MF field.
	TAMP_MISR_TAMP1MF_Pos = 0x0
	// Bit mask of TAMP1MF field.
	TAMP_MISR_TAMP1MF_Msk = 0x1
	// Bit TAMP1MF.
	TAMP_MISR_TAMP1MF = 0x1
	// No tamper detected - Masked
	TAMP_MISR_TAMP1MF_Idle = 0x0
	// Tamper detected - Masked
	TAMP_MISR_TAMP1MF_Tamper = 0x1
	// Position of TAMP2MF field.
	TAMP_MISR_TAMP2MF_Pos = 0x1
	// Bit mask of TAMP2MF field.
	TAMP_MISR_TAMP2MF_Msk = 0x2
	// Bit TAMP2MF.
	TAMP_MISR_TAMP2MF = 0x2
	// No tamper detected - Masked
	TAMP_MISR_TAMP2MF_Idle = 0x0
	// Tamper detected - Masked
	TAMP_MISR_TAMP2MF_Tamper = 0x1
	// Position of TAMP3MF field.
	TAMP_MISR_TAMP3MF_Pos = 0x2
	// Bit mask of TAMP3MF field.
	TAMP_MISR_TAMP3MF_Msk = 0x4
	// Bit TAMP3MF.
	TAMP_MISR_TAMP3MF = 0x4
	// No tamper detected - Masked
	TAMP_MISR_TAMP3MF_Idle = 0x0
	// Tamper detected - Masked
	TAMP_MISR_TAMP3MF_Tamper = 0x1
	// Position of ITAMP3MF field.
	TAMP_MISR_ITAMP3MF_Pos = 0x12
	// Bit mask of ITAMP3MF field.
	TAMP_MISR_ITAMP3MF_Msk = 0x40000
	// Bit ITAMP3MF.
	TAMP_MISR_ITAMP3MF = 0x40000
	// No tamper detected - Masked
	TAMP_MISR_ITAMP3MF_Idle = 0x0
	// Internal tamper detected - Masked
	TAMP_MISR_ITAMP3MF_Tamper = 0x1
	// Position of ITAMP5MF field.
	TAMP_MISR_ITAMP5MF_Pos = 0x14
	// Bit mask of ITAMP5MF field.
	TAMP_MISR_ITAMP5MF_Msk = 0x100000
	// Bit ITAMP5MF.
	TAMP_MISR_ITAMP5MF = 0x100000
	// No tamper detected - Masked
	TAMP_MISR_ITAMP5MF_Idle = 0x0
	// Internal tamper detected - Masked
	TAMP_MISR_ITAMP5MF_Tamper = 0x1
	// Position of ITAMP6MF field.
	TAMP_MISR_ITAMP6MF_Pos = 0x15
	// Bit mask of ITAMP6MF field.
	TAMP_MISR_ITAMP6MF_Msk = 0x200000
	// Bit ITAMP6MF.
	TAMP_MISR_ITAMP6MF = 0x200000
	// No tamper detected - Masked
	TAMP_MISR_ITAMP6MF_Idle = 0x0
	// Internal tamper detected - Masked
	TAMP_MISR_ITAMP6MF_Tamper = 0x1
	// Position of ITAMP8MF field.
	TAMP_MISR_ITAMP8MF_Pos = 0x17
	// Bit mask of ITAMP8MF field.
	TAMP_MISR_ITAMP8MF_Msk = 0x800000
	// Bit ITAMP8MF.
	TAMP_MISR_ITAMP8MF = 0x800000
	// No tamper detected - Masked
	TAMP_MISR_ITAMP8MF_Idle = 0x0
	// Internal tamper detected - Masked
	TAMP_MISR_ITAMP8MF_Tamper = 0x1

	// SCR: TAMP status clear register
	// Position of CTAMP1F field.
	TAMP_SCR_CTAMP1F_Pos = 0x0
	// Bit mask of CTAMP1F field.
	TAMP_SCR_CTAMP1F_Msk = 0x1
	// Bit CTAMP1F.
	TAMP_SCR_CTAMP1F = 0x1
	// Clear tamper flag
	TAMP_SCR_CTAMP1F_Clear = 0x1
	// Position of CTAMP2F field.
	TAMP_SCR_CTAMP2F_Pos = 0x1
	// Bit mask of CTAMP2F field.
	TAMP_SCR_CTAMP2F_Msk = 0x2
	// Bit CTAMP2F.
	TAMP_SCR_CTAMP2F = 0x2
	// Clear tamper flag
	TAMP_SCR_CTAMP2F_Clear = 0x1
	// Position of CTAMP3F field.
	TAMP_SCR_CTAMP3F_Pos = 0x2
	// Bit mask of CTAMP3F field.
	TAMP_SCR_CTAMP3F_Msk = 0x4
	// Bit CTAMP3F.
	TAMP_SCR_CTAMP3F = 0x4
	// Clear tamper flag
	TAMP_SCR_CTAMP3F_Clear = 0x1
	// Position of CITAMP3F field.
	TAMP_SCR_CITAMP3F_Pos = 0x12
	// Bit mask of CITAMP3F field.
	TAMP_SCR_CITAMP3F_Msk = 0x40000
	// Bit CITAMP3F.
	TAMP_SCR_CITAMP3F = 0x40000
	// Clear tamper flag
	TAMP_SCR_CITAMP3F_Clear = 0x1
	// Position of CITAMP5F field.
	TAMP_SCR_CITAMP5F_Pos = 0x14
	// Bit mask of CITAMP5F field.
	TAMP_SCR_CITAMP5F_Msk = 0x100000
	// Bit CITAMP5F.
	TAMP_SCR_CITAMP5F = 0x100000
	// Clear tamper flag
	TAMP_SCR_CITAMP5F_Clear = 0x1
	// Position of CITAMP6F field.
	TAMP_SCR_CITAMP6F_Pos = 0x15
	// Bit mask of CITAMP6F field.
	TAMP_SCR_CITAMP6F_Msk = 0x200000
	// Bit CITAMP6F.
	TAMP_SCR_CITAMP6F = 0x200000
	// Clear tamper flag
	TAMP_SCR_CITAMP6F_Clear = 0x1
	// Position of CITAMP8F field.
	TAMP_SCR_CITAMP8F_Pos = 0x17
	// Bit mask of CITAMP8F field.
	TAMP_SCR_CITAMP8F_Msk = 0x800000
	// Bit CITAMP8F.
	TAMP_SCR_CITAMP8F = 0x800000
	// Clear tamper flag
	TAMP_SCR_CITAMP8F_Clear = 0x1

	// COUNTR: monotonic counter register
	// Position of COUNT field.
	TAMP_COUNTR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	TAMP_COUNTR_COUNT_Msk = 0xffffffff

	// BKP0R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP0R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP0R_BKP_Msk = 0xffffffff

	// BKP1R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP1R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP1R_BKP_Msk = 0xffffffff

	// BKP2R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP2R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP2R_BKP_Msk = 0xffffffff

	// BKP3R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP3R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP3R_BKP_Msk = 0xffffffff

	// BKP4R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP4R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP4R_BKP_Msk = 0xffffffff

	// BKP5R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP5R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP5R_BKP_Msk = 0xffffffff

	// BKP6R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP6R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP6R_BKP_Msk = 0xffffffff

	// BKP7R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP7R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP7R_BKP_Msk = 0xffffffff

	// BKP8R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP8R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP8R_BKP_Msk = 0xffffffff

	// BKP9R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP9R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP9R_BKP_Msk = 0xffffffff

	// BKP10R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP10R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP10R_BKP_Msk = 0xffffffff

	// BKP11R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP11R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP11R_BKP_Msk = 0xffffffff

	// BKP12R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP12R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP12R_BKP_Msk = 0xffffffff

	// BKP13R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP13R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP13R_BKP_Msk = 0xffffffff

	// BKP14R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP14R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP14R_BKP_Msk = 0xffffffff

	// BKP15R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP15R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP15R_BKP_Msk = 0xffffffff

	// BKP16R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP16R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP16R_BKP_Msk = 0xffffffff

	// BKP17R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP17R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP17R_BKP_Msk = 0xffffffff

	// BKP18R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP18R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP18R_BKP_Msk = 0xffffffff

	// BKP19R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP19R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP19R_BKP_Msk = 0xffffffff
)

// Constants for TIM1: Advanced-control timers
const (
	// CR1: control register 1
	// Position of UIFREMAP field.
	TIM_CR1_UIFREMAP_Pos = 0xb
	// Bit mask of UIFREMAP field.
	TIM_CR1_UIFREMAP_Msk = 0x800
	// Bit UIFREMAP.
	TIM_CR1_UIFREMAP = 0x800
	// No remapping. UIF status bit is not copied to TIMx_CNT register bit 31
	TIM_CR1_UIFREMAP_Disabled = 0x0
	// Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31
	TIM_CR1_UIFREMAP_Enabled = 0x1
	// Position of CKD field.
	TIM_CR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIM_CR1_CKD_Msk = 0x300
	// t_DTS = t_CK_INT
	TIM_CR1_CKD_Div1 = 0x0
	// t_DTS = 2  t_CK_INT
	TIM_CR1_CKD_Div2 = 0x1
	// t_DTS = 4  t_CK_INT
	TIM_CR1_CKD_Div4 = 0x2
	// Position of ARPE field.
	TIM_CR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIM_CR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIM_CR1_ARPE = 0x80
	// TIMx_APRR register is not buffered
	TIM_CR1_ARPE_Disabled = 0x0
	// TIMx_APRR register is buffered
	TIM_CR1_ARPE_Enabled = 0x1
	// Position of CMS field.
	TIM_CR1_CMS_Pos = 0x5
	// Bit mask of CMS field.
	TIM_CR1_CMS_Msk = 0x60
	// The counter counts up or down depending on the direction bit
	TIM_CR1_CMS_EdgeAligned = 0x0
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
	TIM_CR1_CMS_CenterAligned1 = 0x1
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
	TIM_CR1_CMS_CenterAligned2 = 0x2
	// The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
	TIM_CR1_CMS_CenterAligned3 = 0x3
	// Position of DIR field.
	TIM_CR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	TIM_CR1_DIR_Msk = 0x10
	// Bit DIR.
	TIM_CR1_DIR = 0x10
	// Counter used as upcounter
	TIM_CR1_DIR_Up = 0x0
	// Counter used as downcounter
	TIM_CR1_DIR_Down = 0x1
	// Position of OPM field.
	TIM_CR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIM_CR1_OPM_Msk = 0x8
	// Bit OPM.
	TIM_CR1_OPM = 0x8
	// Counter is not stopped at update event
	TIM_CR1_OPM_Disabled = 0x0
	// Counter stops counting at the next update event (clearing the CEN bit)
	TIM_CR1_OPM_Enabled = 0x1
	// Position of URS field.
	TIM_CR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIM_CR1_URS_Msk = 0x4
	// Bit URS.
	TIM_CR1_URS = 0x4
	// Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
	TIM_CR1_URS_AnyEvent = 0x0
	// Only counter overflow/underflow generates an update interrupt or DMA request
	TIM_CR1_URS_CounterOnly = 0x1
	// Position of UDIS field.
	TIM_CR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIM_CR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIM_CR1_UDIS = 0x2
	// Update event enabled
	TIM_CR1_UDIS_Enabled = 0x0
	// Update event disabled
	TIM_CR1_UDIS_Disabled = 0x1
	// Position of CEN field.
	TIM_CR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIM_CR1_CEN_Msk = 0x1
	// Bit CEN.
	TIM_CR1_CEN = 0x1
	// Counter disabled
	TIM_CR1_CEN_Disabled = 0x0
	// Counter enabled
	TIM_CR1_CEN_Enabled = 0x1

	// CR2: control register 2
	// Position of MMS2 field.
	TIM_CR2_MMS2_Pos = 0x14
	// Bit mask of MMS2 field.
	TIM_CR2_MMS2_Msk = 0xf00000
	// Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset
	TIM_CR2_MMS2_Reset = 0x0
	// Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register)
	TIM_CR2_MMS2_Enable = 0x1
	// Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer
	TIM_CR2_MMS2_Update = 0x2
	// Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2)
	TIM_CR2_MMS2_ComparePulse = 0x3
	// Compare - OC1REFC signal is used as trigger output (TRGO2)
	TIM_CR2_MMS2_CompareOC1 = 0x4
	// Compare - OC2REFC signal is used as trigger output (TRGO2)
	TIM_CR2_MMS2_CompareOC2 = 0x5
	// Compare - OC3REFC signal is used as trigger output (TRGO2)
	TIM_CR2_MMS2_CompareOC3 = 0x6
	// Compare - OC4REFC signal is used as trigger output (TRGO2)
	TIM_CR2_MMS2_CompareOC4 = 0x7
	// Compare - OC5REFC signal is used as trigger output (TRGO2)
	TIM_CR2_MMS2_CompareOC5 = 0x8
	// Compare - OC6REFC signal is used as trigger output (TRGO2)
	TIM_CR2_MMS2_CompareOC6 = 0x9
	// Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2
	TIM_CR2_MMS2_PulseOC4 = 0xa
	// Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2
	TIM_CR2_MMS2_PulseOC6 = 0xb
	// Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2
	TIM_CR2_MMS2_RisingOC4_6 = 0xc
	// Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2
	TIM_CR2_MMS2_RisingOC4_FallingOC6 = 0xd
	// Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2
	TIM_CR2_MMS2_RisingOC5_6 = 0xe
	// Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2
	TIM_CR2_MMS2_RisingOC5_FallingOC6 = 0xf
	// Position of OIS6 field.
	TIM_CR2_OIS6_Pos = 0x12
	// Bit mask of OIS6 field.
	TIM_CR2_OIS6_Msk = 0x40000
	// Bit OIS6.
	TIM_CR2_OIS6 = 0x40000
	// OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS6_Disabled = 0x0
	// OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS6_Enabled = 0x1
	// Position of OIS5 field.
	TIM_CR2_OIS5_Pos = 0x10
	// Bit mask of OIS5 field.
	TIM_CR2_OIS5_Msk = 0x10000
	// Bit OIS5.
	TIM_CR2_OIS5 = 0x10000
	// OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS5_Disabled = 0x0
	// OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS5_Enabled = 0x1
	// Position of OIS4 field.
	TIM_CR2_OIS4_Pos = 0xe
	// Bit mask of OIS4 field.
	TIM_CR2_OIS4_Msk = 0x4000
	// Bit OIS4.
	TIM_CR2_OIS4 = 0x4000
	// OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS4_Disabled = 0x0
	// OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS4_Enabled = 0x1
	// Position of OIS3N field.
	TIM_CR2_OIS3N_Pos = 0xd
	// Bit mask of OIS3N field.
	TIM_CR2_OIS3N_Msk = 0x2000
	// Bit OIS3N.
	TIM_CR2_OIS3N = 0x2000
	// OCxN=0 after a dead-time when MOE=0
	TIM_CR2_OIS3N_Disabled = 0x0
	// OCxN=1 after a dead-time when MOE=0
	TIM_CR2_OIS3N_Enabled = 0x1
	// Position of OIS3 field.
	TIM_CR2_OIS3_Pos = 0xc
	// Bit mask of OIS3 field.
	TIM_CR2_OIS3_Msk = 0x1000
	// Bit OIS3.
	TIM_CR2_OIS3 = 0x1000
	// OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS3_Disabled = 0x0
	// OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS3_Enabled = 0x1
	// Position of OIS2N field.
	TIM_CR2_OIS2N_Pos = 0xb
	// Bit mask of OIS2N field.
	TIM_CR2_OIS2N_Msk = 0x800
	// Bit OIS2N.
	TIM_CR2_OIS2N = 0x800
	// OCxN=0 after a dead-time when MOE=0
	TIM_CR2_OIS2N_Disabled = 0x0
	// OCxN=1 after a dead-time when MOE=0
	TIM_CR2_OIS2N_Enabled = 0x1
	// Position of OIS2 field.
	TIM_CR2_OIS2_Pos = 0xa
	// Bit mask of OIS2 field.
	TIM_CR2_OIS2_Msk = 0x400
	// Bit OIS2.
	TIM_CR2_OIS2 = 0x400
	// OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS2_Disabled = 0x0
	// OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS2_Enabled = 0x1
	// Position of OIS1N field.
	TIM_CR2_OIS1N_Pos = 0x9
	// Bit mask of OIS1N field.
	TIM_CR2_OIS1N_Msk = 0x200
	// Bit OIS1N.
	TIM_CR2_OIS1N = 0x200
	// OCxN=0 after a dead-time when MOE=0
	TIM_CR2_OIS1N_Disabled = 0x0
	// OCxN=1 after a dead-time when MOE=0
	TIM_CR2_OIS1N_Enabled = 0x1
	// Position of OIS1 field.
	TIM_CR2_OIS1_Pos = 0x8
	// Bit mask of OIS1 field.
	TIM_CR2_OIS1_Msk = 0x100
	// Bit OIS1.
	TIM_CR2_OIS1 = 0x100
	// OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS1_Disabled = 0x0
	// OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0
	TIM_CR2_OIS1_Enabled = 0x1
	// Position of TI1S field.
	TIM_CR2_TI1S_Pos = 0x7
	// Bit mask of TI1S field.
	TIM_CR2_TI1S_Msk = 0x80
	// Bit TI1S.
	TIM_CR2_TI1S = 0x80
	// The TIMx_CH1 pin is connected to TI1 input
	TIM_CR2_TI1S_Normal = 0x0
	// The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
	TIM_CR2_TI1S_XOR = 0x1
	// Position of MMS field.
	TIM_CR2_MMS_Pos = 0x4
	// Bit mask of MMS field.
	TIM_CR2_MMS_Msk = 0x70
	// The UG bit from the TIMx_EGR register is used as trigger output
	TIM_CR2_MMS_Reset = 0x0
	// The counter enable signal, CNT_EN, is used as trigger output
	TIM_CR2_MMS_Enable = 0x1
	// The update event is selected as trigger output
	TIM_CR2_MMS_Update = 0x2
	// The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
	TIM_CR2_MMS_ComparePulse = 0x3
	// OC1REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC1 = 0x4
	// OC2REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC2 = 0x5
	// OC3REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC3 = 0x6
	// OC4REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC4 = 0x7
	// Position of CCDS field.
	TIM_CR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIM_CR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIM_CR2_CCDS = 0x8
	// CCx DMA request sent when CCx event occurs
	TIM_CR2_CCDS_OnCompare = 0x0
	// CCx DMA request sent when update event occurs
	TIM_CR2_CCDS_OnUpdate = 0x1
	// Position of CCUS field.
	TIM_CR2_CCUS_Pos = 0x2
	// Bit mask of CCUS field.
	TIM_CR2_CCUS_Msk = 0x4
	// Bit CCUS.
	TIM_CR2_CCUS = 0x4
	// When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only
	TIM_CR2_CCUS_Bit = 0x0
	// When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI
	TIM_CR2_CCUS_BitOrEdge = 0x1
	// Position of CCPC field.
	TIM_CR2_CCPC_Pos = 0x0
	// Bit mask of CCPC field.
	TIM_CR2_CCPC_Msk = 0x1
	// Bit CCPC.
	TIM_CR2_CCPC = 0x1
	// CCxE, CCxNE and OCxM bits are not preloaded
	TIM_CR2_CCPC_NotPreloaded = 0x0
	// CCxE, CCxNE and OCxM bits are preloaded
	TIM_CR2_CCPC_Preloaded = 0x1

	// SMCR: slave mode control register
	// Position of TS3_4 field.
	TIM_SMCR_TS3_4_Pos = 0x14
	// Bit mask of TS3_4 field.
	TIM_SMCR_TS3_4_Msk = 0x300000
	// Position of SMS_3 field.
	TIM_SMCR_SMS_3_Pos = 0x10
	// Bit mask of SMS_3 field.
	TIM_SMCR_SMS_3_Msk = 0x10000
	// Bit SMS_3.
	TIM_SMCR_SMS_3 = 0x10000
	// Slave mode disabled (see SMS[0:2])
	TIM_SMCR_SMS_3_Disabled = 0x0
	// SMS[0:2] must be 0b000 (DisabledOrCombined). Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter
	TIM_SMCR_SMS_3_CombinedResetTrigger = 0x1
	// Position of ETP field.
	TIM_SMCR_ETP_Pos = 0xf
	// Bit mask of ETP field.
	TIM_SMCR_ETP_Msk = 0x8000
	// Bit ETP.
	TIM_SMCR_ETP = 0x8000
	// ETR is noninverted, active at high level or rising edge
	TIM_SMCR_ETP_NotInverted = 0x0
	// ETR is inverted, active at low level or falling edge
	TIM_SMCR_ETP_Inverted = 0x1
	// Position of ECE field.
	TIM_SMCR_ECE_Pos = 0xe
	// Bit mask of ECE field.
	TIM_SMCR_ECE_Msk = 0x4000
	// Bit ECE.
	TIM_SMCR_ECE = 0x4000
	// External clock mode 2 disabled
	TIM_SMCR_ECE_Disabled = 0x0
	// External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal
	TIM_SMCR_ECE_Enabled = 0x1
	// Position of ETPS field.
	TIM_SMCR_ETPS_Pos = 0xc
	// Bit mask of ETPS field.
	TIM_SMCR_ETPS_Msk = 0x3000
	// Prescaler OFF
	TIM_SMCR_ETPS_Div1 = 0x0
	// ETRP frequency divided by 2
	TIM_SMCR_ETPS_Div2 = 0x1
	// ETRP frequency divided by 4
	TIM_SMCR_ETPS_Div4 = 0x2
	// ETRP frequency divided by 8
	TIM_SMCR_ETPS_Div8 = 0x3
	// Position of ETF field.
	TIM_SMCR_ETF_Pos = 0x8
	// Bit mask of ETF field.
	TIM_SMCR_ETF_Msk = 0xf00
	// No filter, sampling is done at fDTS
	TIM_SMCR_ETF_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_SMCR_ETF_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_SMCR_ETF_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_SMCR_ETF_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_SMCR_ETF_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_SMCR_ETF_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_SMCR_ETF_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_SMCR_ETF_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_SMCR_ETF_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_SMCR_ETF_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_SMCR_ETF_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_SMCR_ETF_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_SMCR_ETF_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_SMCR_ETF_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_SMCR_ETF_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_SMCR_ETF_FDTS_Div32_N8 = 0xf
	// Position of MSM field.
	TIM_SMCR_MSM_Pos = 0x7
	// Bit mask of MSM field.
	TIM_SMCR_MSM_Msk = 0x80
	// Bit MSM.
	TIM_SMCR_MSM = 0x80
	// No action
	TIM_SMCR_MSM_NoSync = 0x0
	// The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event
	TIM_SMCR_MSM_Sync = 0x1
	// Position of TS field.
	TIM_SMCR_TS_Pos = 0x4
	// Bit mask of TS field.
	TIM_SMCR_TS_Msk = 0x70
	// Internal Trigger 0 (ITR0)
	TIM_SMCR_TS_ITR0 = 0x0
	// Internal Trigger 1 (ITR1)
	TIM_SMCR_TS_ITR1 = 0x1
	// Internal Trigger 2 (ITR2)
	TIM_SMCR_TS_ITR2 = 0x2
	// TI1 Edge Detector (TI1F_ED)
	TIM_SMCR_TS_TI1F_ED = 0x4
	// Filtered Timer Input 1 (TI1FP1)
	TIM_SMCR_TS_TI1FP1 = 0x5
	// Filtered Timer Input 2 (TI2FP2)
	TIM_SMCR_TS_TI2FP2 = 0x6
	// External Trigger input (ETRF)
	TIM_SMCR_TS_ETRF = 0x7
	// Position of OCCS field.
	TIM_SMCR_OCCS_Pos = 0x3
	// Bit mask of OCCS field.
	TIM_SMCR_OCCS_Msk = 0x8
	// Bit OCCS.
	TIM_SMCR_OCCS = 0x8
	// Position of SMS field.
	TIM_SMCR_SMS_Pos = 0x0
	// Bit mask of SMS field.
	TIM_SMCR_SMS_Msk = 0x7
	// Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock. If SMS[3]=1 then Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter
	TIM_SMCR_SMS_DisabledOrCombined = 0x0
	// Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level
	TIM_SMCR_SMS_EncoderMode1 = 0x1
	// Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level
	TIM_SMCR_SMS_EncoderMode2 = 0x2
	// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input
	TIM_SMCR_SMS_EncoderMode3 = 0x3
	// Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers
	TIM_SMCR_SMS_ResetMode = 0x4
	// Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled
	TIM_SMCR_SMS_GatedMode = 0x5
	// Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled
	TIM_SMCR_SMS_TriggerMode = 0x6
	// External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter
	TIM_SMCR_SMS_ExtClockMode = 0x7

	// DIER: DMA/interrupt enable register
	// Position of TDE field.
	TIM_DIER_TDE_Pos = 0xe
	// Bit mask of TDE field.
	TIM_DIER_TDE_Msk = 0x4000
	// Bit TDE.
	TIM_DIER_TDE = 0x4000
	// Trigger DMA request disabled
	TIM_DIER_TDE_Disabled = 0x0
	// Trigger DMA request enabled
	TIM_DIER_TDE_Enabled = 0x1
	// Position of COMDE field.
	TIM_DIER_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIM_DIER_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIM_DIER_COMDE = 0x2000
	// COM DMA request disabled
	TIM_DIER_COMDE_Disabled = 0x0
	// COM DMA request enabled
	TIM_DIER_COMDE_Enabled = 0x1
	// Position of CC4DE field.
	TIM_DIER_CC4DE_Pos = 0xc
	// Bit mask of CC4DE field.
	TIM_DIER_CC4DE_Msk = 0x1000
	// Bit CC4DE.
	TIM_DIER_CC4DE = 0x1000
	// CCx DMA request disabled
	TIM_DIER_CC4DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC4DE_Enabled = 0x1
	// Position of CC3DE field.
	TIM_DIER_CC3DE_Pos = 0xb
	// Bit mask of CC3DE field.
	TIM_DIER_CC3DE_Msk = 0x800
	// Bit CC3DE.
	TIM_DIER_CC3DE = 0x800
	// CCx DMA request disabled
	TIM_DIER_CC3DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC3DE_Enabled = 0x1
	// Position of CC2DE field.
	TIM_DIER_CC2DE_Pos = 0xa
	// Bit mask of CC2DE field.
	TIM_DIER_CC2DE_Msk = 0x400
	// Bit CC2DE.
	TIM_DIER_CC2DE = 0x400
	// CCx DMA request disabled
	TIM_DIER_CC2DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC2DE_Enabled = 0x1
	// Position of CC1DE field.
	TIM_DIER_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIM_DIER_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIM_DIER_CC1DE = 0x200
	// CCx DMA request disabled
	TIM_DIER_CC1DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC1DE_Enabled = 0x1
	// Position of UDE field.
	TIM_DIER_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIM_DIER_UDE_Msk = 0x100
	// Bit UDE.
	TIM_DIER_UDE = 0x100
	// Update DMA request disabled
	TIM_DIER_UDE_Disabled = 0x0
	// Update DMA request enabled
	TIM_DIER_UDE_Enabled = 0x1
	// Position of BIE field.
	TIM_DIER_BIE_Pos = 0x7
	// Bit mask of BIE field.
	TIM_DIER_BIE_Msk = 0x80
	// Bit BIE.
	TIM_DIER_BIE = 0x80
	// Break interrupt disabled
	TIM_DIER_BIE_Disabled = 0x0
	// Break interrupt enabled
	TIM_DIER_BIE_Enabled = 0x1
	// Position of TIE field.
	TIM_DIER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	TIM_DIER_TIE_Msk = 0x40
	// Bit TIE.
	TIM_DIER_TIE = 0x40
	// Trigger interrupt disabled
	TIM_DIER_TIE_Disabled = 0x0
	// Trigger interrupt enabled
	TIM_DIER_TIE_Enabled = 0x1
	// Position of COMIE field.
	TIM_DIER_COMIE_Pos = 0x5
	// Bit mask of COMIE field.
	TIM_DIER_COMIE_Msk = 0x20
	// Bit COMIE.
	TIM_DIER_COMIE = 0x20
	// COM interrupt disabled
	TIM_DIER_COMIE_Disabled = 0x0
	// COM interrupt enabled
	TIM_DIER_COMIE_Enabled = 0x1
	// Position of CC4IE field.
	TIM_DIER_CC4IE_Pos = 0x4
	// Bit mask of CC4IE field.
	TIM_DIER_CC4IE_Msk = 0x10
	// Bit CC4IE.
	TIM_DIER_CC4IE = 0x10
	// CCx interrupt disabled
	TIM_DIER_CC4IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC4IE_Enabled = 0x1
	// Position of CC3IE field.
	TIM_DIER_CC3IE_Pos = 0x3
	// Bit mask of CC3IE field.
	TIM_DIER_CC3IE_Msk = 0x8
	// Bit CC3IE.
	TIM_DIER_CC3IE = 0x8
	// CCx interrupt disabled
	TIM_DIER_CC3IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC3IE_Enabled = 0x1
	// Position of CC2IE field.
	TIM_DIER_CC2IE_Pos = 0x2
	// Bit mask of CC2IE field.
	TIM_DIER_CC2IE_Msk = 0x4
	// Bit CC2IE.
	TIM_DIER_CC2IE = 0x4
	// CCx interrupt disabled
	TIM_DIER_CC2IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC2IE_Enabled = 0x1
	// Position of CC1IE field.
	TIM_DIER_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIM_DIER_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIM_DIER_CC1IE = 0x2
	// CCx interrupt disabled
	TIM_DIER_CC1IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC1IE_Enabled = 0x1
	// Position of UIE field.
	TIM_DIER_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIM_DIER_UIE_Msk = 0x1
	// Bit UIE.
	TIM_DIER_UIE = 0x1
	// Update interrupt disabled
	TIM_DIER_UIE_Disabled = 0x0
	// Update interrupt enabled
	TIM_DIER_UIE_Enabled = 0x1

	// SR: status register
	// Position of CC6IF field.
	TIM_SR_CC6IF_Pos = 0x11
	// Bit mask of CC6IF field.
	TIM_SR_CC6IF_Msk = 0x20000
	// Bit CC6IF.
	TIM_SR_CC6IF = 0x20000
	// No campture/compare has been detected
	TIM_SR_CC6IF_NoMatch = 0x0
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register
	TIM_SR_CC6IF_Match = 0x1
	// Clear flag
	TIM_SR_CC6IF_Clear = 0x0
	// Position of CC5IF field.
	TIM_SR_CC5IF_Pos = 0x10
	// Bit mask of CC5IF field.
	TIM_SR_CC5IF_Msk = 0x10000
	// Bit CC5IF.
	TIM_SR_CC5IF = 0x10000
	// No campture/compare has been detected
	TIM_SR_CC5IF_NoMatch = 0x0
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register
	TIM_SR_CC5IF_Match = 0x1
	// Clear flag
	TIM_SR_CC5IF_Clear = 0x0
	// Position of SBIF field.
	TIM_SR_SBIF_Pos = 0xd
	// Bit mask of SBIF field.
	TIM_SR_SBIF_Msk = 0x2000
	// Bit SBIF.
	TIM_SR_SBIF = 0x2000
	// No break event occurred
	TIM_SR_SBIF_NoTrigger = 0x0
	// An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register
	TIM_SR_SBIF_Trigger = 0x1
	// Clear flag
	TIM_SR_SBIF_Clear = 0x0
	// Position of CC4OF field.
	TIM_SR_CC4OF_Pos = 0xc
	// Bit mask of CC4OF field.
	TIM_SR_CC4OF_Msk = 0x1000
	// Bit CC4OF.
	TIM_SR_CC4OF = 0x1000
	// No overcapture has been detected
	TIM_SR_CC4OF_NoOvercapture = 0x0
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC4OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC4OF_Clear = 0x0
	// Position of CC3OF field.
	TIM_SR_CC3OF_Pos = 0xb
	// Bit mask of CC3OF field.
	TIM_SR_CC3OF_Msk = 0x800
	// Bit CC3OF.
	TIM_SR_CC3OF = 0x800
	// No overcapture has been detected
	TIM_SR_CC3OF_NoOvercapture = 0x0
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC3OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC3OF_Clear = 0x0
	// Position of CC2OF field.
	TIM_SR_CC2OF_Pos = 0xa
	// Bit mask of CC2OF field.
	TIM_SR_CC2OF_Msk = 0x400
	// Bit CC2OF.
	TIM_SR_CC2OF = 0x400
	// No overcapture has been detected
	TIM_SR_CC2OF_NoOvercapture = 0x0
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC2OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC2OF_Clear = 0x0
	// Position of CC1OF field.
	TIM_SR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIM_SR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIM_SR_CC1OF = 0x200
	// No overcapture has been detected
	TIM_SR_CC1OF_NoOvercapture = 0x0
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC1OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC1OF_Clear = 0x0
	// Position of B2IF field.
	TIM_SR_B2IF_Pos = 0x8
	// Bit mask of B2IF field.
	TIM_SR_B2IF_Msk = 0x100
	// Bit B2IF.
	TIM_SR_B2IF = 0x100
	// No break event occurred
	TIM_SR_B2IF_NoTrigger = 0x0
	// An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register
	TIM_SR_B2IF_Trigger = 0x1
	// Clear flag
	TIM_SR_B2IF_Clear = 0x0
	// Position of BIF field.
	TIM_SR_BIF_Pos = 0x7
	// Bit mask of BIF field.
	TIM_SR_BIF_Msk = 0x80
	// Bit BIF.
	TIM_SR_BIF = 0x80
	// No break event occurred
	TIM_SR_BIF_NoTrigger = 0x0
	// An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register
	TIM_SR_BIF_Trigger = 0x1
	// Clear flag
	TIM_SR_BIF_Clear = 0x0
	// Position of TIF field.
	TIM_SR_TIF_Pos = 0x6
	// Bit mask of TIF field.
	TIM_SR_TIF_Msk = 0x40
	// Bit TIF.
	TIM_SR_TIF = 0x40
	// No trigger event occurred
	TIM_SR_TIF_NoTrigger = 0x0
	// Trigger interrupt pending
	TIM_SR_TIF_Trigger = 0x1
	// Clear flag
	TIM_SR_TIF_Clear = 0x0
	// Position of COMIF field.
	TIM_SR_COMIF_Pos = 0x5
	// Bit mask of COMIF field.
	TIM_SR_COMIF_Msk = 0x20
	// Bit COMIF.
	TIM_SR_COMIF = 0x20
	// Position of CC4IF field.
	TIM_SR_CC4IF_Pos = 0x4
	// Bit mask of CC4IF field.
	TIM_SR_CC4IF_Msk = 0x10
	// Bit CC4IF.
	TIM_SR_CC4IF = 0x10
	// No campture/compare has been detected
	TIM_SR_CC4IF_NoMatch = 0x0
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register
	TIM_SR_CC4IF_Match = 0x1
	// Clear flag
	TIM_SR_CC4IF_Clear = 0x0
	// Position of CC3IF field.
	TIM_SR_CC3IF_Pos = 0x3
	// Bit mask of CC3IF field.
	TIM_SR_CC3IF_Msk = 0x8
	// Bit CC3IF.
	TIM_SR_CC3IF = 0x8
	// No campture/compare has been detected
	TIM_SR_CC3IF_NoMatch = 0x0
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register
	TIM_SR_CC3IF_Match = 0x1
	// Clear flag
	TIM_SR_CC3IF_Clear = 0x0
	// Position of CC2IF field.
	TIM_SR_CC2IF_Pos = 0x2
	// Bit mask of CC2IF field.
	TIM_SR_CC2IF_Msk = 0x4
	// Bit CC2IF.
	TIM_SR_CC2IF = 0x4
	// No campture/compare has been detected
	TIM_SR_CC2IF_NoMatch = 0x0
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register
	TIM_SR_CC2IF_Match = 0x1
	// Clear flag
	TIM_SR_CC2IF_Clear = 0x0
	// Position of CC1IF field.
	TIM_SR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIM_SR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIM_SR_CC1IF = 0x2
	// No campture/compare has been detected
	TIM_SR_CC1IF_NoMatch = 0x0
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register
	TIM_SR_CC1IF_Match = 0x1
	// Clear flag
	TIM_SR_CC1IF_Clear = 0x0
	// Position of UIF field.
	TIM_SR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIM_SR_UIF_Msk = 0x1
	// Bit UIF.
	TIM_SR_UIF = 0x1
	// No update occurred
	TIM_SR_UIF_Clear = 0x0
	// Update interrupt pending.
	TIM_SR_UIF_UpdatePending = 0x1

	// EGR: event generation register
	// Position of B2G field.
	TIM_EGR_B2G_Pos = 0x8
	// Bit mask of B2G field.
	TIM_EGR_B2G_Msk = 0x100
	// Bit B2G.
	TIM_EGR_B2G = 0x100
	// A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled
	TIM_EGR_B2G_Trigger = 0x1
	// Position of BG field.
	TIM_EGR_BG_Pos = 0x7
	// Bit mask of BG field.
	TIM_EGR_BG_Msk = 0x80
	// Bit BG.
	TIM_EGR_BG = 0x80
	// A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled
	TIM_EGR_BG_Trigger = 0x1
	// Position of TG field.
	TIM_EGR_TG_Pos = 0x6
	// Bit mask of TG field.
	TIM_EGR_TG_Msk = 0x40
	// Bit TG.
	TIM_EGR_TG = 0x40
	// The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled
	TIM_EGR_TG_Trigger = 0x1
	// Position of COMG field.
	TIM_EGR_COMG_Pos = 0x5
	// Bit mask of COMG field.
	TIM_EGR_COMG_Msk = 0x20
	// Bit COMG.
	TIM_EGR_COMG = 0x20
	// When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated
	TIM_EGR_COMG_Trigger = 0x1
	// Position of CC4G field.
	TIM_EGR_CC4G_Pos = 0x4
	// Bit mask of CC4G field.
	TIM_EGR_CC4G_Msk = 0x10
	// Bit CC4G.
	TIM_EGR_CC4G = 0x10
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register
	TIM_EGR_CC4G_Trigger = 0x1
	// Position of CC3G field.
	TIM_EGR_CC3G_Pos = 0x3
	// Bit mask of CC3G field.
	TIM_EGR_CC3G_Msk = 0x8
	// Bit CC3G.
	TIM_EGR_CC3G = 0x8
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register
	TIM_EGR_CC3G_Trigger = 0x1
	// Position of CC2G field.
	TIM_EGR_CC2G_Pos = 0x2
	// Bit mask of CC2G field.
	TIM_EGR_CC2G_Msk = 0x4
	// Bit CC2G.
	TIM_EGR_CC2G = 0x4
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register
	TIM_EGR_CC2G_Trigger = 0x1
	// Position of CC1G field.
	TIM_EGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIM_EGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIM_EGR_CC1G = 0x2
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register
	TIM_EGR_CC1G_Trigger = 0x1
	// Position of UG field.
	TIM_EGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIM_EGR_UG_Msk = 0x1
	// Bit UG.
	TIM_EGR_UG = 0x1
	// Re-initializes the timer counter and generates an update of the registers.
	TIM_EGR_UG_Update = 0x1

	// CCMR1_Output: capture/compare mode register 1 (output mode)
	// Position of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Pos = 0x18
	// Bit mask of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Msk = 0x1000000
	// Bit OC2M_3.
	TIM_CCMR1_Output_OC2M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC2M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC2M_3_Extended = 0x1
	// Position of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Pos = 0x10
	// Bit mask of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Msk = 0x10000
	// Bit OC1M_3.
	TIM_CCMR1_Output_OC1M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC1M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC1M_3_Extended = 0x1
	// Position of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Pos = 0xf
	// Bit mask of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Msk = 0x8000
	// Bit OC2CE.
	TIM_CCMR1_Output_OC2CE = 0x8000
	// OCxRef is not affected by the ocref_clr_int signal
	TIM_CCMR1_Output_OC2CE_Disabled = 0x0
	// OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal
	TIM_CCMR1_Output_OC2CE_Enabled = 0x1
	// Position of OC2M field.
	TIM_CCMR1_Output_OC2M_Pos = 0xc
	// Bit mask of OC2M field.
	TIM_CCMR1_Output_OC2M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC2M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC2M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC2M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC2M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC2M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC2M_PwmMode2 = 0x7
	// Position of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Pos = 0xb
	// Bit mask of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Msk = 0x800
	// Bit OC2PE.
	TIM_CCMR1_Output_OC2PE = 0x800
	// Preload register on CCRx disabled. New values written to CCRx are taken into account immediately
	TIM_CCMR1_Output_OC2PE_Disabled = 0x0
	// Preload register on CCRx enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC2PE_Enabled = 0x1
	// Position of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Pos = 0xa
	// Bit mask of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Msk = 0x400
	// Bit OC2FE.
	TIM_CCMR1_Output_OC2FE = 0x400
	// Fast output disabled
	TIM_CCMR1_Output_OC2FE_Disabled = 0x0
	// Fast output enabled
	TIM_CCMR1_Output_OC2FE_Enabled = 0x1
	// Position of CC2S field.
	TIM_CCMR1_Output_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Output_CC2S_Msk = 0x300
	// CCx channel is configured as output
	TIM_CCMR1_Output_CC2S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR1_Output_CC2S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR1_Output_CC2S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR1_Output_CC2S_TRC = 0x3
	// Position of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Pos = 0x7
	// Bit mask of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Msk = 0x80
	// Bit OC1CE.
	TIM_CCMR1_Output_OC1CE = 0x80
	// OCxRef is not affected by the ocref_clr_int signal
	TIM_CCMR1_Output_OC1CE_Disabled = 0x0
	// OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal
	TIM_CCMR1_Output_OC1CE_Enabled = 0x1
	// Position of OC1M field.
	TIM_CCMR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIM_CCMR1_Output_OC1M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC1M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC1M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC1M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC1M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC1M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC1M_PwmMode2 = 0x7
	// Position of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIM_CCMR1_Output_OC1PE = 0x8
	// Preload register on CCRx disabled. New values written to CCRx are taken into account immediately
	TIM_CCMR1_Output_OC1PE_Disabled = 0x0
	// Preload register on CCRx enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC1PE_Enabled = 0x1
	// Position of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIM_CCMR1_Output_OC1FE = 0x4
	// Fast output disabled
	TIM_CCMR1_Output_OC1FE_Disabled = 0x0
	// Fast output enabled
	TIM_CCMR1_Output_OC1FE_Enabled = 0x1
	// Position of CC1S field.
	TIM_CCMR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Output_CC1S_Msk = 0x3
	// CCx channel is configured as output
	TIM_CCMR1_Output_CC1S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR1_Output_CC1S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR1_Output_CC1S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR1_Output_CC1S_TRC = 0x3

	// CCMR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC2F field.
	TIM_CCMR1_Input_IC2F_Pos = 0xc
	// Bit mask of IC2F field.
	TIM_CCMR1_Input_IC2F_Msk = 0xf000
	// No filter, sampling is done at fDTS
	TIM_CCMR1_Input_IC2F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR1_Input_IC2F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR1_Input_IC2F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR1_Input_IC2F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR1_Input_IC2F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR1_Input_IC2F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR1_Input_IC2F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR1_Input_IC2F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR1_Input_IC2F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR1_Input_IC2F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR1_Input_IC2F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR1_Input_IC2F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR1_Input_IC2F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR1_Input_IC2F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR1_Input_IC2F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR1_Input_IC2F_FDTS_Div32_N8 = 0xf
	// Position of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Pos = 0xa
	// Bit mask of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Msk = 0xc00
	// CCx channel is configured as output
	TIM_CCMR1_Input_IC2PSC_Output = 0x0
	// Capture is done once every 2 events
	TIM_CCMR1_Input_IC2PSC_Capture2 = 0x1
	// Capture is done once every 4 events
	TIM_CCMR1_Input_IC2PSC_Capture4 = 0x2
	// Capture is done once every 8 events
	TIM_CCMR1_Input_IC2PSC_Capture8 = 0x3
	// Position of CC2S field.
	TIM_CCMR1_Input_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Input_CC2S_Msk = 0x300
	// CCx channel is configured as output
	TIM_CCMR1_Input_CC2S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR1_Input_CC2S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR1_Input_CC2S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR1_Input_CC2S_TRC = 0x3
	// Position of IC1F field.
	TIM_CCMR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIM_CCMR1_Input_IC1F_Msk = 0xf0
	// No filter, sampling is done at fDTS
	TIM_CCMR1_Input_IC1F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR1_Input_IC1F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR1_Input_IC1F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR1_Input_IC1F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N8 = 0xf
	// Position of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Msk = 0xc
	// CCx channel is configured as output
	TIM_CCMR1_Input_IC1PSC_Output = 0x0
	// Capture is done once every 2 events
	TIM_CCMR1_Input_IC1PSC_Capture2 = 0x1
	// Capture is done once every 4 events
	TIM_CCMR1_Input_IC1PSC_Capture4 = 0x2
	// Capture is done once every 8 events
	TIM_CCMR1_Input_IC1PSC_Capture8 = 0x3
	// Position of CC1S field.
	TIM_CCMR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Input_CC1S_Msk = 0x3
	// CCx channel is configured as output
	TIM_CCMR1_Input_CC1S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR1_Input_CC1S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR1_Input_CC1S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR1_Input_CC1S_TRC = 0x3

	// CCMR2_Output: capture/compare mode register 2 (output mode)
	// Position of OC4M_3 field.
	TIM_CCMR2_Output_OC4M_3_Pos = 0x18
	// Bit mask of OC4M_3 field.
	TIM_CCMR2_Output_OC4M_3_Msk = 0x1000000
	// Bit OC4M_3.
	TIM_CCMR2_Output_OC4M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC4M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC4M_3_Extended = 0x1
	// Position of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Pos = 0x10
	// Bit mask of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Msk = 0x10000
	// Bit OC3M_3.
	TIM_CCMR2_Output_OC3M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC3M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC3M_3_Extended = 0x1
	// Position of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Pos = 0xf
	// Bit mask of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Msk = 0x8000
	// Bit OC4CE.
	TIM_CCMR2_Output_OC4CE = 0x8000
	// OCxRef is not affected by the ocref_clr_int signal
	TIM_CCMR2_Output_OC4CE_Disabled = 0x0
	// OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal
	TIM_CCMR2_Output_OC4CE_Enabled = 0x1
	// Position of OC4M field.
	TIM_CCMR2_Output_OC4M_Pos = 0xc
	// Bit mask of OC4M field.
	TIM_CCMR2_Output_OC4M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC4M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC4M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC4M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC4M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC4M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC4M_PwmMode2 = 0x7
	// Position of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Pos = 0xb
	// Bit mask of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Msk = 0x800
	// Bit OC4PE.
	TIM_CCMR2_Output_OC4PE = 0x800
	// Preload register on CCRx disabled. New values written to CCRx are taken into account immediately
	TIM_CCMR2_Output_OC4PE_Disabled = 0x0
	// Preload register on CCRx enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC4PE_Enabled = 0x1
	// Position of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Pos = 0xa
	// Bit mask of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Msk = 0x400
	// Bit OC4FE.
	TIM_CCMR2_Output_OC4FE = 0x400
	// Fast output disabled
	TIM_CCMR2_Output_OC4FE_Disabled = 0x0
	// Fast output enabled
	TIM_CCMR2_Output_OC4FE_Enabled = 0x1
	// Position of CC4S field.
	TIM_CCMR2_Output_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Output_CC4S_Msk = 0x300
	// CCx channel is configured as output
	TIM_CCMR2_Output_CC4S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR2_Output_CC4S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR2_Output_CC4S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR2_Output_CC4S_TRC = 0x3
	// Position of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Pos = 0x7
	// Bit mask of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Msk = 0x80
	// Bit OC3CE.
	TIM_CCMR2_Output_OC3CE = 0x80
	// OCxRef is not affected by the ocref_clr_int signal
	TIM_CCMR2_Output_OC3CE_Disabled = 0x0
	// OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal
	TIM_CCMR2_Output_OC3CE_Enabled = 0x1
	// Position of OC3M field.
	TIM_CCMR2_Output_OC3M_Pos = 0x4
	// Bit mask of OC3M field.
	TIM_CCMR2_Output_OC3M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC3M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC3M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC3M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC3M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC3M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC3M_PwmMode2 = 0x7
	// Position of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Pos = 0x3
	// Bit mask of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Msk = 0x8
	// Bit OC3PE.
	TIM_CCMR2_Output_OC3PE = 0x8
	// Preload register on CCRx disabled. New values written to CCRx are taken into account immediately
	TIM_CCMR2_Output_OC3PE_Disabled = 0x0
	// Preload register on CCRx enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC3PE_Enabled = 0x1
	// Position of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Pos = 0x2
	// Bit mask of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Msk = 0x4
	// Bit OC3FE.
	TIM_CCMR2_Output_OC3FE = 0x4
	// Fast output disabled
	TIM_CCMR2_Output_OC3FE_Disabled = 0x0
	// Fast output enabled
	TIM_CCMR2_Output_OC3FE_Enabled = 0x1
	// Position of CC3S field.
	TIM_CCMR2_Output_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Output_CC3S_Msk = 0x3
	// CCx channel is configured as output
	TIM_CCMR2_Output_CC3S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR2_Output_CC3S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR2_Output_CC3S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR2_Output_CC3S_TRC = 0x3

	// CCMR2_Input: capture/compare mode register 2 (input mode)
	// Position of IC4F field.
	TIM_CCMR2_Input_IC4F_Pos = 0xc
	// Bit mask of IC4F field.
	TIM_CCMR2_Input_IC4F_Msk = 0xf000
	// No filter, sampling is done at fDTS
	TIM_CCMR2_Input_IC4F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR2_Input_IC4F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR2_Input_IC4F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR2_Input_IC4F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR2_Input_IC4F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR2_Input_IC4F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR2_Input_IC4F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR2_Input_IC4F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR2_Input_IC4F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR2_Input_IC4F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR2_Input_IC4F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR2_Input_IC4F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR2_Input_IC4F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR2_Input_IC4F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR2_Input_IC4F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR2_Input_IC4F_FDTS_Div32_N8 = 0xf
	// Position of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Pos = 0xa
	// Bit mask of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Msk = 0xc00
	// CCx channel is configured as output
	TIM_CCMR2_Input_IC4PSC_Output = 0x0
	// Capture is done once every 2 events
	TIM_CCMR2_Input_IC4PSC_Capture2 = 0x1
	// Capture is done once every 4 events
	TIM_CCMR2_Input_IC4PSC_Capture4 = 0x2
	// Capture is done once every 8 events
	TIM_CCMR2_Input_IC4PSC_Capture8 = 0x3
	// Position of CC4S field.
	TIM_CCMR2_Input_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Input_CC4S_Msk = 0x300
	// CCx channel is configured as output
	TIM_CCMR2_Input_CC4S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR2_Input_CC4S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR2_Input_CC4S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR2_Input_CC4S_TRC = 0x3
	// Position of IC3F field.
	TIM_CCMR2_Input_IC3F_Pos = 0x4
	// Bit mask of IC3F field.
	TIM_CCMR2_Input_IC3F_Msk = 0xf0
	// No filter, sampling is done at fDTS
	TIM_CCMR2_Input_IC3F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR2_Input_IC3F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR2_Input_IC3F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR2_Input_IC3F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR2_Input_IC3F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR2_Input_IC3F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR2_Input_IC3F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR2_Input_IC3F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR2_Input_IC3F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR2_Input_IC3F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR2_Input_IC3F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR2_Input_IC3F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR2_Input_IC3F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR2_Input_IC3F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR2_Input_IC3F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR2_Input_IC3F_FDTS_Div32_N8 = 0xf
	// Position of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Pos = 0x2
	// Bit mask of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Msk = 0xc
	// CCx channel is configured as output
	TIM_CCMR2_Input_IC3PSC_Output = 0x0
	// Capture is done once every 2 events
	TIM_CCMR2_Input_IC3PSC_Capture2 = 0x1
	// Capture is done once every 4 events
	TIM_CCMR2_Input_IC3PSC_Capture4 = 0x2
	// Capture is done once every 8 events
	TIM_CCMR2_Input_IC3PSC_Capture8 = 0x3
	// Position of CC3S field.
	TIM_CCMR2_Input_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Input_CC3S_Msk = 0x3
	// CCx channel is configured as output
	TIM_CCMR2_Input_CC3S_Output = 0x0
	// CCx channel is configured as input, ICx is mapped on TI1
	TIM_CCMR2_Input_CC3S_TI1 = 0x1
	// CCx channel is configured as input, ICx is mapped on TI2
	TIM_CCMR2_Input_CC3S_TI2 = 0x2
	// CCx channel is configured as input, ICx is mapped on TRC
	TIM_CCMR2_Input_CC3S_TRC = 0x3

	// CCER: capture/compare enable register
	// Position of CC6P field.
	TIM_CCER_CC6P_Pos = 0x15
	// Bit mask of CC6P field.
	TIM_CCER_CC6P_Msk = 0x200000
	// Bit CC6P.
	TIM_CCER_CC6P = 0x200000
	// Noninverted/rising edge
	TIM_CCER_CC6P_RisingEdge = 0x0
	// Inverted/falling edge
	TIM_CCER_CC6P_FallingEdge = 0x1
	// Position of CC6E field.
	TIM_CCER_CC6E_Pos = 0x14
	// Bit mask of CC6E field.
	TIM_CCER_CC6E_Msk = 0x100000
	// Bit CC6E.
	TIM_CCER_CC6E = 0x100000
	// Capture disabled
	TIM_CCER_CC6E_Disabled = 0x0
	// Capture enabled
	TIM_CCER_CC6E_Enabled = 0x1
	// Position of CC5P field.
	TIM_CCER_CC5P_Pos = 0x11
	// Bit mask of CC5P field.
	TIM_CCER_CC5P_Msk = 0x20000
	// Bit CC5P.
	TIM_CCER_CC5P = 0x20000
	// Noninverted/rising edge
	TIM_CCER_CC5P_RisingEdge = 0x0
	// Inverted/falling edge
	TIM_CCER_CC5P_FallingEdge = 0x1
	// Position of CC5E field.
	TIM_CCER_CC5E_Pos = 0x10
	// Bit mask of CC5E field.
	TIM_CCER_CC5E_Msk = 0x10000
	// Bit CC5E.
	TIM_CCER_CC5E = 0x10000
	// Capture disabled
	TIM_CCER_CC5E_Disabled = 0x0
	// Capture enabled
	TIM_CCER_CC5E_Enabled = 0x1
	// Position of CC4P field.
	TIM_CCER_CC4P_Pos = 0xd
	// Bit mask of CC4P field.
	TIM_CCER_CC4P_Msk = 0x2000
	// Bit CC4P.
	TIM_CCER_CC4P = 0x2000
	// Noninverted/rising edge
	TIM_CCER_CC4P_RisingEdge = 0x0
	// Inverted/falling edge
	TIM_CCER_CC4P_FallingEdge = 0x1
	// Position of CC4E field.
	TIM_CCER_CC4E_Pos = 0xc
	// Bit mask of CC4E field.
	TIM_CCER_CC4E_Msk = 0x1000
	// Bit CC4E.
	TIM_CCER_CC4E = 0x1000
	// Capture disabled
	TIM_CCER_CC4E_Disabled = 0x0
	// Capture enabled
	TIM_CCER_CC4E_Enabled = 0x1
	// Position of CC3NP field.
	TIM_CCER_CC3NP_Pos = 0xb
	// Bit mask of CC3NP field.
	TIM_CCER_CC3NP_Msk = 0x800
	// Bit CC3NP.
	TIM_CCER_CC3NP = 0x800
	// OCxN active high
	TIM_CCER_CC3NP_ActiveHigh = 0x0
	// OCxN active low
	TIM_CCER_CC3NP_ActiveLow = 0x1
	// Position of CC3NE field.
	TIM_CCER_CC3NE_Pos = 0xa
	// Bit mask of CC3NE field.
	TIM_CCER_CC3NE_Msk = 0x400
	// Bit CC3NE.
	TIM_CCER_CC3NE = 0x400
	// Complementary output disabled
	TIM_CCER_CC3NE_Disabled = 0x0
	// Complementary output enabled
	TIM_CCER_CC3NE_Enabled = 0x1
	// Position of CC3P field.
	TIM_CCER_CC3P_Pos = 0x9
	// Bit mask of CC3P field.
	TIM_CCER_CC3P_Msk = 0x200
	// Bit CC3P.
	TIM_CCER_CC3P = 0x200
	// Noninverted/rising edge
	TIM_CCER_CC3P_RisingEdge = 0x0
	// Inverted/falling edge
	TIM_CCER_CC3P_FallingEdge = 0x1
	// Position of CC3E field.
	TIM_CCER_CC3E_Pos = 0x8
	// Bit mask of CC3E field.
	TIM_CCER_CC3E_Msk = 0x100
	// Bit CC3E.
	TIM_CCER_CC3E = 0x100
	// Capture disabled
	TIM_CCER_CC3E_Disabled = 0x0
	// Capture enabled
	TIM_CCER_CC3E_Enabled = 0x1
	// Position of CC2NP field.
	TIM_CCER_CC2NP_Pos = 0x7
	// Bit mask of CC2NP field.
	TIM_CCER_CC2NP_Msk = 0x80
	// Bit CC2NP.
	TIM_CCER_CC2NP = 0x80
	// OCxN active high
	TIM_CCER_CC2NP_ActiveHigh = 0x0
	// OCxN active low
	TIM_CCER_CC2NP_ActiveLow = 0x1
	// Position of CC2NE field.
	TIM_CCER_CC2NE_Pos = 0x6
	// Bit mask of CC2NE field.
	TIM_CCER_CC2NE_Msk = 0x40
	// Bit CC2NE.
	TIM_CCER_CC2NE = 0x40
	// Complementary output disabled
	TIM_CCER_CC2NE_Disabled = 0x0
	// Complementary output enabled
	TIM_CCER_CC2NE_Enabled = 0x1
	// Position of CC2P field.
	TIM_CCER_CC2P_Pos = 0x5
	// Bit mask of CC2P field.
	TIM_CCER_CC2P_Msk = 0x20
	// Bit CC2P.
	TIM_CCER_CC2P = 0x20
	// Noninverted/rising edge
	TIM_CCER_CC2P_RisingEdge = 0x0
	// Inverted/falling edge
	TIM_CCER_CC2P_FallingEdge = 0x1
	// Position of CC2E field.
	TIM_CCER_CC2E_Pos = 0x4
	// Bit mask of CC2E field.
	TIM_CCER_CC2E_Msk = 0x10
	// Bit CC2E.
	TIM_CCER_CC2E = 0x10
	// Capture disabled
	TIM_CCER_CC2E_Disabled = 0x0
	// Capture enabled
	TIM_CCER_CC2E_Enabled = 0x1
	// Position of CC1NP field.
	TIM_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIM_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIM_CCER_CC1NP = 0x8
	// OCxN active high
	TIM_CCER_CC1NP_ActiveHigh = 0x0
	// OCxN active low
	TIM_CCER_CC1NP_ActiveLow = 0x1
	// Position of CC1NE field.
	TIM_CCER_CC1NE_Pos = 0x2
	// Bit mask of CC1NE field.
	TIM_CCER_CC1NE_Msk = 0x4
	// Bit CC1NE.
	TIM_CCER_CC1NE = 0x4
	// Complementary output disabled
	TIM_CCER_CC1NE_Disabled = 0x0
	// Complementary output enabled
	TIM_CCER_CC1NE_Enabled = 0x1
	// Position of CC1P field.
	TIM_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIM_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIM_CCER_CC1P = 0x2
	// Noninverted/rising edge
	TIM_CCER_CC1P_RisingEdge = 0x0
	// Inverted/falling edge
	TIM_CCER_CC1P_FallingEdge = 0x1
	// Position of CC1E field.
	TIM_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIM_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIM_CCER_CC1E = 0x1
	// Capture disabled
	TIM_CCER_CC1E_Disabled = 0x0
	// Capture enabled
	TIM_CCER_CC1E_Enabled = 0x1

	// CNT: counter
	// Position of UIFCPY field.
	TIM_CNT_UIFCPY_Pos = 0x1f
	// Bit mask of UIFCPY field.
	TIM_CNT_UIFCPY_Msk = 0x80000000
	// Bit UIFCPY.
	TIM_CNT_UIFCPY = 0x80000000
	// Position of CNT field.
	TIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIM_CNT_CNT_Msk = 0xffff

	// PSC: prescaler
	// Position of PSC field.
	TIM_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIM_PSC_PSC_Msk = 0xffff

	// ARR: auto-reload register
	// Position of ARR field.
	TIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	TIM_ARR_ARR_Msk = 0xffff

	// RCR: repetition counter register
	// Position of REP field.
	TIM_RCR_REP_Pos = 0x0
	// Bit mask of REP field.
	TIM_RCR_REP_Msk = 0xffff

	// CCR1: capture/compare register 1
	// Position of CCR1 field.
	TIM_CCR1_CCR1_Pos = 0x0
	// Bit mask of CCR1 field.
	TIM_CCR1_CCR1_Msk = 0xffff

	// CCR2: capture/compare register 2
	// Position of CCR2 field.
	TIM_CCR2_CCR2_Pos = 0x0
	// Bit mask of CCR2 field.
	TIM_CCR2_CCR2_Msk = 0xffff

	// CCR3: capture/compare register 3
	// Position of CCR3 field.
	TIM_CCR3_CCR3_Pos = 0x0
	// Bit mask of CCR3 field.
	TIM_CCR3_CCR3_Msk = 0xffff

	// CCR4: capture/compare register 4
	// Position of CCR4 field.
	TIM_CCR4_CCR4_Pos = 0x0
	// Bit mask of CCR4 field.
	TIM_CCR4_CCR4_Msk = 0xffff

	// BDTR: break and dead-time register
	// Position of BK2BID field.
	TIM_BDTR_BK2BID_Pos = 0x1d
	// Bit mask of BK2BID field.
	TIM_BDTR_BK2BID_Msk = 0x20000000
	// Bit BK2BID.
	TIM_BDTR_BK2BID = 0x20000000
	// Break input BRK2 in input mode
	TIM_BDTR_BK2BID_Input = 0x0
	// Break input BRK2 in bidirectional mode
	TIM_BDTR_BK2BID_Bidirectional = 0x1
	// Position of BKBID field.
	TIM_BDTR_BKBID_Pos = 0x1c
	// Bit mask of BKBID field.
	TIM_BDTR_BKBID_Msk = 0x10000000
	// Bit BKBID.
	TIM_BDTR_BKBID = 0x10000000
	// Break input BRK in input mode
	TIM_BDTR_BKBID_Input = 0x0
	// Break input BRK in bidirectional mode
	TIM_BDTR_BKBID_Bidirectional = 0x1
	// Position of BK2DSRM field.
	TIM_BDTR_BK2DSRM_Pos = 0x1b
	// Bit mask of BK2DSRM field.
	TIM_BDTR_BK2DSRM_Msk = 0x8000000
	// Bit BK2DSRM.
	TIM_BDTR_BK2DSRM = 0x8000000
	// Break input BRK2 is armed
	TIM_BDTR_BK2DSRM_Armed = 0x0
	// Break input BRK2 is disarmed
	TIM_BDTR_BK2DSRM_Disarmed = 0x1
	// Position of BKDSRM field.
	TIM_BDTR_BKDSRM_Pos = 0x1a
	// Bit mask of BKDSRM field.
	TIM_BDTR_BKDSRM_Msk = 0x4000000
	// Bit BKDSRM.
	TIM_BDTR_BKDSRM = 0x4000000
	// Break input BRK is armed
	TIM_BDTR_BKDSRM_Armed = 0x0
	// Break input BRK is disarmed
	TIM_BDTR_BKDSRM_Disarmed = 0x1
	// Position of BK2P field.
	TIM_BDTR_BK2P_Pos = 0x19
	// Bit mask of BK2P field.
	TIM_BDTR_BK2P_Msk = 0x2000000
	// Bit BK2P.
	TIM_BDTR_BK2P = 0x2000000
	// Break input BRK2 is active low
	TIM_BDTR_BK2P_Low = 0x0
	// Break input BRK2 is active high
	TIM_BDTR_BK2P_High = 0x1
	// Position of BK2E field.
	TIM_BDTR_BK2E_Pos = 0x18
	// Bit mask of BK2E field.
	TIM_BDTR_BK2E_Msk = 0x1000000
	// Bit BK2E.
	TIM_BDTR_BK2E = 0x1000000
	// Break function disabled
	TIM_BDTR_BK2E_Disabled = 0x0
	// Break function enabled
	TIM_BDTR_BK2E_Enabled = 0x1
	// Position of BK2F field.
	TIM_BDTR_BK2F_Pos = 0x14
	// Bit mask of BK2F field.
	TIM_BDTR_BK2F_Msk = 0xf00000
	// No filter, sampling is done at fDTS
	TIM_BDTR_BK2F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_BDTR_BK2F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_BDTR_BK2F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_BDTR_BK2F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_BDTR_BK2F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_BDTR_BK2F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_BDTR_BK2F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_BDTR_BK2F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_BDTR_BK2F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_BDTR_BK2F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_BDTR_BK2F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_BDTR_BK2F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_BDTR_BK2F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_BDTR_BK2F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_BDTR_BK2F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_BDTR_BK2F_FDTS_Div32_N8 = 0xf
	// Position of BKF field.
	TIM_BDTR_BKF_Pos = 0x10
	// Bit mask of BKF field.
	TIM_BDTR_BKF_Msk = 0xf0000
	// No filter, sampling is done at fDTS
	TIM_BDTR_BKF_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_BDTR_BKF_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_BDTR_BKF_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_BDTR_BKF_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_BDTR_BKF_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_BDTR_BKF_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_BDTR_BKF_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_BDTR_BKF_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_BDTR_BKF_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_BDTR_BKF_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_BDTR_BKF_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_BDTR_BKF_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_BDTR_BKF_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_BDTR_BKF_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_BDTR_BKF_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_BDTR_BKF_FDTS_Div32_N8 = 0xf
	// Position of MOE field.
	TIM_BDTR_MOE_Pos = 0xf
	// Bit mask of MOE field.
	TIM_BDTR_MOE_Msk = 0x8000
	// Bit MOE.
	TIM_BDTR_MOE = 0x8000
	// In response to a break 2 event OC and OCN outputs are disabled - In response to a break event or if MOE is written to 0 OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit
	TIM_BDTR_MOE_Disabled = 0x0
	// OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)
	TIM_BDTR_MOE_Enabled = 0x1
	// Position of AOE field.
	TIM_BDTR_AOE_Pos = 0xe
	// Bit mask of AOE field.
	TIM_BDTR_AOE_Msk = 0x4000
	// Bit AOE.
	TIM_BDTR_AOE = 0x4000
	// MOE can be set only by software
	TIM_BDTR_AOE_Disabled = 0x0
	// MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)
	TIM_BDTR_AOE_Enabled = 0x1
	// Position of BKP field.
	TIM_BDTR_BKP_Pos = 0xd
	// Bit mask of BKP field.
	TIM_BDTR_BKP_Msk = 0x2000
	// Bit BKP.
	TIM_BDTR_BKP = 0x2000
	// Break input BRK is active low
	TIM_BDTR_BKP_ActiveLow = 0x0
	// Break input BRK is active high
	TIM_BDTR_BKP_ActiveHigh = 0x1
	// Position of BKE field.
	TIM_BDTR_BKE_Pos = 0xc
	// Bit mask of BKE field.
	TIM_BDTR_BKE_Msk = 0x1000
	// Bit BKE.
	TIM_BDTR_BKE = 0x1000
	// Break function disabled
	TIM_BDTR_BKE_Disabled = 0x0
	// Break function enabled
	TIM_BDTR_BKE_Enabled = 0x1
	// Position of OSSR field.
	TIM_BDTR_OSSR_Pos = 0xb
	// Bit mask of OSSR field.
	TIM_BDTR_OSSR_Msk = 0x800
	// Bit OSSR.
	TIM_BDTR_OSSR = 0x800
	// OC/OCN outputs are disabled when inactive
	TIM_BDTR_OSSR_Disabled = 0x0
	// OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1
	TIM_BDTR_OSSR_Enabled = 0x1
	// Position of OSSI field.
	TIM_BDTR_OSSI_Pos = 0xa
	// Bit mask of OSSI field.
	TIM_BDTR_OSSI_Msk = 0x400
	// Bit OSSI.
	TIM_BDTR_OSSI = 0x400
	// OC/OCN outputs are disabled when inactive
	TIM_BDTR_OSSI_Disabled = 0x0
	// OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime
	TIM_BDTR_OSSI_Enabled = 0x1
	// Position of LOCK field.
	TIM_BDTR_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	TIM_BDTR_LOCK_Msk = 0x300
	// No write protection
	TIM_BDTR_LOCK_Off = 0x0
	// Level 1 write protection
	TIM_BDTR_LOCK_Level1 = 0x1
	// Level 2 write protection
	TIM_BDTR_LOCK_Level2 = 0x2
	// Level 3 write protection
	TIM_BDTR_LOCK_Level3 = 0x3
	// Position of DTG field.
	TIM_BDTR_DTG_Pos = 0x0
	// Bit mask of DTG field.
	TIM_BDTR_DTG_Msk = 0xff

	// DCR: DMA control register
	// Position of DBL field.
	TIM_DCR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIM_DCR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIM_DCR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIM_DCR_DBA_Msk = 0x1f

	// DMAR: DMA address for full transfer
	// Position of DMAB field.
	TIM_DMAR_DMAB_Pos = 0x0
	// Bit mask of DMAB field.
	TIM_DMAR_DMAB_Msk = 0xffff

	// OR1: option register 1
	// Position of TI1_RMP field.
	TIM_OR1_TI1_RMP_Pos = 0x4
	// Bit mask of TI1_RMP field.
	TIM_OR1_TI1_RMP_Msk = 0x10
	// Bit TI1_RMP.
	TIM_OR1_TI1_RMP = 0x10
	// TIM1 input capture 1 is connected to I/O
	TIM_OR1_TI1_RMP_IO = 0x0
	// TIM1 input capture 1 is connected to COMP1 output
	TIM_OR1_TI1_RMP_COMP1 = 0x1
	// Position of TIM1_ETR_ADC1_RMP field.
	TIM_OR1_TIM1_ETR_ADC1_RMP_Pos = 0x0
	// Bit mask of TIM1_ETR_ADC1_RMP field.
	TIM_OR1_TIM1_ETR_ADC1_RMP_Msk = 0x3
	// TIM1_ETR is not connected to ADC AWDx (must be selected when the ETR comes from the ETR input pin)
	TIM_OR1_TIM1_ETR_ADC1_RMP_Select = 0x0
	// TIM1_ETR is connected to ADC AWD1
	TIM_OR1_TIM1_ETR_ADC1_RMP_ADC_AWD1 = 0x1
	// TIM1_ETR is connected to ADC AWD2
	TIM_OR1_TIM1_ETR_ADC1_RMP_ADC_AWD2 = 0x2
	// TIM1_ETR is connected to ADC AWD3
	TIM_OR1_TIM1_ETR_ADC1_RMP_ADC_AWD3 = 0x3

	// CCMR3_Output: capture/compare mode register 3
	// Position of OC6M_3 field.
	TIM_CCMR3_Output_OC6M_3_Pos = 0x18
	// Bit mask of OC6M_3 field.
	TIM_CCMR3_Output_OC6M_3_Msk = 0x1000000
	// Bit OC6M_3.
	TIM_CCMR3_Output_OC6M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR3_Output_OC6M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR3_Output_OC6M_3_Extended = 0x1
	// Position of OC5M_3 field.
	TIM_CCMR3_Output_OC5M_3_Pos = 0x10
	// Bit mask of OC5M_3 field.
	TIM_CCMR3_Output_OC5M_3_Msk = 0x10000
	// Bit OC5M_3.
	TIM_CCMR3_Output_OC5M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR3_Output_OC5M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR3_Output_OC5M_3_Extended = 0x1
	// Position of OC6CE field.
	TIM_CCMR3_Output_OC6CE_Pos = 0xf
	// Bit mask of OC6CE field.
	TIM_CCMR3_Output_OC6CE_Msk = 0x8000
	// Bit OC6CE.
	TIM_CCMR3_Output_OC6CE = 0x8000
	// OCxRef is not affected by the ocref_clr_int signal
	TIM_CCMR3_Output_OC6CE_Disabled = 0x0
	// OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal
	TIM_CCMR3_Output_OC6CE_Enabled = 0x1
	// Position of OC6M field.
	TIM_CCMR3_Output_OC6M_Pos = 0xc
	// Bit mask of OC6M field.
	TIM_CCMR3_Output_OC6M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR3_Output_OC6M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR3_Output_OC6M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR3_Output_OC6M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR3_Output_OC6M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR3_Output_OC6M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR3_Output_OC6M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR3_Output_OC6M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR3_Output_OC6M_PwmMode2 = 0x7
	// Position of OC6PE field.
	TIM_CCMR3_Output_OC6PE_Pos = 0xb
	// Bit mask of OC6PE field.
	TIM_CCMR3_Output_OC6PE_Msk = 0x800
	// Bit OC6PE.
	TIM_CCMR3_Output_OC6PE = 0x800
	// Preload register on CCRx disabled. New values written to CCRx are taken into account immediately
	TIM_CCMR3_Output_OC6PE_Disabled = 0x0
	// Preload register on CCRx enabled. Preload value is loaded into active register on each update event
	TIM_CCMR3_Output_OC6PE_Enabled = 0x1
	// Position of OC6FE field.
	TIM_CCMR3_Output_OC6FE_Pos = 0xa
	// Bit mask of OC6FE field.
	TIM_CCMR3_Output_OC6FE_Msk = 0x400
	// Bit OC6FE.
	TIM_CCMR3_Output_OC6FE = 0x400
	// Fast output disabled
	TIM_CCMR3_Output_OC6FE_Disabled = 0x0
	// Fast output enabled
	TIM_CCMR3_Output_OC6FE_Enabled = 0x1
	// Position of OC5CE field.
	TIM_CCMR3_Output_OC5CE_Pos = 0x7
	// Bit mask of OC5CE field.
	TIM_CCMR3_Output_OC5CE_Msk = 0x80
	// Bit OC5CE.
	TIM_CCMR3_Output_OC5CE = 0x80
	// OCxRef is not affected by the ocref_clr_int signal
	TIM_CCMR3_Output_OC5CE_Disabled = 0x0
	// OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal
	TIM_CCMR3_Output_OC5CE_Enabled = 0x1
	// Position of OC5M field.
	TIM_CCMR3_Output_OC5M_Pos = 0x4
	// Bit mask of OC5M field.
	TIM_CCMR3_Output_OC5M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR3_Output_OC5M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR3_Output_OC5M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR3_Output_OC5M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR3_Output_OC5M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR3_Output_OC5M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR3_Output_OC5M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR3_Output_OC5M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR3_Output_OC5M_PwmMode2 = 0x7
	// Position of OC5PE field.
	TIM_CCMR3_Output_OC5PE_Pos = 0x3
	// Bit mask of OC5PE field.
	TIM_CCMR3_Output_OC5PE_Msk = 0x8
	// Bit OC5PE.
	TIM_CCMR3_Output_OC5PE = 0x8
	// Preload register on CCRx disabled. New values written to CCRx are taken into account immediately
	TIM_CCMR3_Output_OC5PE_Disabled = 0x0
	// Preload register on CCRx enabled. Preload value is loaded into active register on each update event
	TIM_CCMR3_Output_OC5PE_Enabled = 0x1
	// Position of OC5FE field.
	TIM_CCMR3_Output_OC5FE_Pos = 0x2
	// Bit mask of OC5FE field.
	TIM_CCMR3_Output_OC5FE_Msk = 0x4
	// Bit OC5FE.
	TIM_CCMR3_Output_OC5FE = 0x4
	// Fast output disabled
	TIM_CCMR3_Output_OC5FE_Disabled = 0x0
	// Fast output enabled
	TIM_CCMR3_Output_OC5FE_Enabled = 0x1

	// CCR5: capture/compare register 5
	// Position of GC5C3 field.
	TIM_CCR5_GC5C3_Pos = 0x1f
	// Bit mask of GC5C3 field.
	TIM_CCR5_GC5C3_Msk = 0x80000000
	// Bit GC5C3.
	TIM_CCR5_GC5C3 = 0x80000000
	// No effect of OC5REF on OC3REFC
	TIM_CCR5_GC5C3_Disabled = 0x0
	// OC3REFC is the logical AND of OC3REFC and OC5REF
	TIM_CCR5_GC5C3_Enabled = 0x1
	// Position of GC5C2 field.
	TIM_CCR5_GC5C2_Pos = 0x1e
	// Bit mask of GC5C2 field.
	TIM_CCR5_GC5C2_Msk = 0x40000000
	// Bit GC5C2.
	TIM_CCR5_GC5C2 = 0x40000000
	// No effect of OC5REF on OC2REFC
	TIM_CCR5_GC5C2_Disabled = 0x0
	// OC2REFC is the logical AND of OC2REFC and OC5REF
	TIM_CCR5_GC5C2_Enabled = 0x1
	// Position of GC5C1 field.
	TIM_CCR5_GC5C1_Pos = 0x1d
	// Bit mask of GC5C1 field.
	TIM_CCR5_GC5C1_Msk = 0x20000000
	// Bit GC5C1.
	TIM_CCR5_GC5C1 = 0x20000000
	// No effect of OC5REF on OC1REFC
	TIM_CCR5_GC5C1_Disabled = 0x0
	// OC1REFC is the logical AND of OC1REFC and OC5REF
	TIM_CCR5_GC5C1_Enabled = 0x1
	// Position of CCR5 field.
	TIM_CCR5_CCR5_Pos = 0x0
	// Bit mask of CCR5 field.
	TIM_CCR5_CCR5_Msk = 0xffff

	// CCR6: capture/compare register 6
	// Position of CCR6 field.
	TIM_CCR6_CCR6_Pos = 0x0
	// Bit mask of CCR6 field.
	TIM_CCR6_CCR6_Msk = 0xffff

	// AF1: alternate function option register 1
	// Position of ETRSEL field.
	TIM_AF1_ETRSEL_Pos = 0xe
	// Bit mask of ETRSEL field.
	TIM_AF1_ETRSEL_Msk = 0x3c000
	// ETR legacy mode
	TIM_AF1_ETRSEL_Legacy = 0x0
	// COMP1 output
	TIM_AF1_ETRSEL_COMP1 = 0x1
	// COMP2 output
	TIM_AF1_ETRSEL_COMP2 = 0x2
	// Position of BKCMP2P field.
	TIM_AF1_BKCMP2P_Pos = 0xb
	// Bit mask of BKCMP2P field.
	TIM_AF1_BKCMP2P_Msk = 0x800
	// Bit BKCMP2P.
	TIM_AF1_BKCMP2P = 0x800
	// Input polarity not inverted
	TIM_AF1_BKCMP2P_NotInverted = 0x0
	// Input polarity inverted
	TIM_AF1_BKCMP2P_Inverted = 0x1
	// Position of BKCMP1P field.
	TIM_AF1_BKCMP1P_Pos = 0xa
	// Bit mask of BKCMP1P field.
	TIM_AF1_BKCMP1P_Msk = 0x400
	// Bit BKCMP1P.
	TIM_AF1_BKCMP1P = 0x400
	// Input polarity not inverted
	TIM_AF1_BKCMP1P_NotInverted = 0x0
	// Input polarity inverted
	TIM_AF1_BKCMP1P_Inverted = 0x1
	// Position of BKINP field.
	TIM_AF1_BKINP_Pos = 0x9
	// Bit mask of BKINP field.
	TIM_AF1_BKINP_Msk = 0x200
	// Bit BKINP.
	TIM_AF1_BKINP = 0x200
	// Input polarity not inverted
	TIM_AF1_BKINP_NotInverted = 0x0
	// Input polarity inverted
	TIM_AF1_BKINP_Inverted = 0x1
	// Position of BKCMP2E field.
	TIM_AF1_BKCMP2E_Pos = 0x2
	// Bit mask of BKCMP2E field.
	TIM_AF1_BKCMP2E_Msk = 0x4
	// Bit BKCMP2E.
	TIM_AF1_BKCMP2E = 0x4
	// COMP2 input disabled
	TIM_AF1_BKCMP2E_Disabled = 0x0
	// COMP2 input enabled
	TIM_AF1_BKCMP2E_Enabled = 0x1
	// Position of BKCMP1E field.
	TIM_AF1_BKCMP1E_Pos = 0x1
	// Bit mask of BKCMP1E field.
	TIM_AF1_BKCMP1E_Msk = 0x2
	// Bit BKCMP1E.
	TIM_AF1_BKCMP1E = 0x2
	// COMP1 input disabled
	TIM_AF1_BKCMP1E_Disabled = 0x0
	// COMP1 input enabled
	TIM_AF1_BKCMP1E_Enabled = 0x1
	// Position of BKINE field.
	TIM_AF1_BKINE_Pos = 0x0
	// Bit mask of BKINE field.
	TIM_AF1_BKINE_Msk = 0x1
	// Bit BKINE.
	TIM_AF1_BKINE = 0x1
	// BKIN input disabled
	TIM_AF1_BKINE_Disabled = 0x0
	// BKIN input enabled
	TIM_AF1_BKINE_Enabled = 0x1

	// AF2: Alternate function register 2
	// Position of BK2CMP2P field.
	TIM_AF2_BK2CMP2P_Pos = 0xb
	// Bit mask of BK2CMP2P field.
	TIM_AF2_BK2CMP2P_Msk = 0x800
	// Bit BK2CMP2P.
	TIM_AF2_BK2CMP2P = 0x800
	// Input polarity not inverted
	TIM_AF2_BK2CMP2P_NotInverted = 0x0
	// Input polarity inverted
	TIM_AF2_BK2CMP2P_Inverted = 0x1
	// Position of BK2CMP1P field.
	TIM_AF2_BK2CMP1P_Pos = 0xa
	// Bit mask of BK2CMP1P field.
	TIM_AF2_BK2CMP1P_Msk = 0x400
	// Bit BK2CMP1P.
	TIM_AF2_BK2CMP1P = 0x400
	// Input polarity not inverted
	TIM_AF2_BK2CMP1P_NotInverted = 0x0
	// Input polarity inverted
	TIM_AF2_BK2CMP1P_Inverted = 0x1
	// Position of BK2INP field.
	TIM_AF2_BK2INP_Pos = 0x9
	// Bit mask of BK2INP field.
	TIM_AF2_BK2INP_Msk = 0x200
	// Bit BK2INP.
	TIM_AF2_BK2INP = 0x200
	// Input polarity not inverted
	TIM_AF2_BK2INP_NotInverted = 0x0
	// Input polarity inverted
	TIM_AF2_BK2INP_Inverted = 0x1
	// Position of BK2CMP2E field.
	TIM_AF2_BK2CMP2E_Pos = 0x2
	// Bit mask of BK2CMP2E field.
	TIM_AF2_BK2CMP2E_Msk = 0x4
	// Bit BK2CMP2E.
	TIM_AF2_BK2CMP2E = 0x4
	// COMP2 input disabled
	TIM_AF2_BK2CMP2E_Disabled = 0x0
	// COMP2 input enabled
	TIM_AF2_BK2CMP2E_Enabled = 0x1
	// Position of BK2CMP1E field.
	TIM_AF2_BK2CMP1E_Pos = 0x1
	// Bit mask of BK2CMP1E field.
	TIM_AF2_BK2CMP1E_Msk = 0x2
	// Bit BK2CMP1E.
	TIM_AF2_BK2CMP1E = 0x2
	// COMP1 input disabled
	TIM_AF2_BK2CMP1E_Disabled = 0x0
	// COMP1 input enabled
	TIM_AF2_BK2CMP1E_Enabled = 0x1
	// Position of BK2INE field.
	TIM_AF2_BK2INE_Pos = 0x0
	// Bit mask of BK2INE field.
	TIM_AF2_BK2INE_Msk = 0x1
	// Bit BK2INE.
	TIM_AF2_BK2INE = 0x1
	// BKIN input disabled
	TIM_AF2_BK2INE_Disabled = 0x0
	// BKIN input enabled
	TIM_AF2_BK2INE_Enabled = 0x1

	// TISEL: timer input selection register
	// Position of TI4SEL field.
	TIM_TISEL_TI4SEL_Pos = 0x18
	// Bit mask of TI4SEL field.
	TIM_TISEL_TI4SEL_Msk = 0xf000000
	// TIM1_CHx input selected
	TIM_TISEL_TI4SEL_Selected = 0x0
	// Position of TI3SEL field.
	TIM_TISEL_TI3SEL_Pos = 0x10
	// Bit mask of TI3SEL field.
	TIM_TISEL_TI3SEL_Msk = 0xf0000
	// TIM1_CHx input selected
	TIM_TISEL_TI3SEL_Selected = 0x0
	// Position of TI2SEL field.
	TIM_TISEL_TI2SEL_Pos = 0x8
	// Bit mask of TI2SEL field.
	TIM_TISEL_TI2SEL_Msk = 0xf00
	// TIM1_CHx input selected
	TIM_TISEL_TI2SEL_Selected = 0x0
	// Position of TI1SEL field.
	TIM_TISEL_TI1SEL_Pos = 0x0
	// Bit mask of TI1SEL field.
	TIM_TISEL_TI1SEL_Msk = 0xf
	// TIM1_CHx input selected
	TIM_TISEL_TI1SEL_Selected = 0x0
)

// Constants for VREFBUF: Voltage reference buffer
const (
	// CSR: control and status register
	// Position of VRR field.
	VREFBUF_CSR_VRR_Pos = 0x3
	// Bit mask of VRR field.
	VREFBUF_CSR_VRR_Msk = 0x8
	// Bit VRR.
	VREFBUF_CSR_VRR = 0x8
	// The voltage reference buffer output is not ready
	VREFBUF_CSR_VRR_NotReady = 0x0
	// The voltage reference buffer output reached the requested level
	VREFBUF_CSR_VRR_Ready = 0x1
	// Position of VRS field.
	VREFBUF_CSR_VRS_Pos = 0x2
	// Bit mask of VRS field.
	VREFBUF_CSR_VRS_Msk = 0x4
	// Bit VRS.
	VREFBUF_CSR_VRS = 0x4
	// Voltage reference set to VREF_OUT1 (around 2.048 V)
	VREFBUF_CSR_VRS_V2_048 = 0x0
	// Voltage reference set to VREF_OUT2 (around 2.5 V)
	VREFBUF_CSR_VRS_V2_5 = 0x1
	// Position of HIZ field.
	VREFBUF_CSR_HIZ_Pos = 0x1
	// Bit mask of HIZ field.
	VREFBUF_CSR_HIZ_Msk = 0x2
	// Bit HIZ.
	VREFBUF_CSR_HIZ = 0x2
	// VREF+ pin is internally connected to the voltage reference buffer output
	VREFBUF_CSR_HIZ_Connected = 0x0
	// VREF+ pin is high impedance
	VREFBUF_CSR_HIZ_HighZ = 0x1
	// Position of ENVR field.
	VREFBUF_CSR_ENVR_Pos = 0x0
	// Bit mask of ENVR field.
	VREFBUF_CSR_ENVR_Msk = 0x1
	// Bit ENVR.
	VREFBUF_CSR_ENVR = 0x1
	// Internal voltage reference mode disable (external voltage reference mode)
	VREFBUF_CSR_ENVR_Disabled = 0x0
	// Internal voltage reference mode (reference buffer enable or hold mode) enable
	VREFBUF_CSR_ENVR_Enabled = 0x1

	// CCR: calibration control register
	// Position of TRIM field.
	VREFBUF_CCR_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	VREFBUF_CCR_TRIM_Msk = 0x3f
)

// Constants for WWDG: System window watchdog
const (
	// CR: Control register
	// Position of WDGA field.
	WWDG_CR_WDGA_Pos = 0x7
	// Bit mask of WDGA field.
	WWDG_CR_WDGA_Msk = 0x80
	// Bit WDGA.
	WWDG_CR_WDGA = 0x80
	// Watchdog disabled
	WWDG_CR_WDGA_Disabled = 0x0
	// Watchdog enabled
	WWDG_CR_WDGA_Enabled = 0x1
	// Position of T field.
	WWDG_CR_T_Pos = 0x0
	// Bit mask of T field.
	WWDG_CR_T_Msk = 0x7f

	// CFR: Configuration register
	// Position of EWI field.
	WWDG_CFR_EWI_Pos = 0x9
	// Bit mask of EWI field.
	WWDG_CFR_EWI_Msk = 0x200
	// Bit EWI.
	WWDG_CFR_EWI = 0x200
	// interrupt occurs whenever the counter reaches the value 0x40
	WWDG_CFR_EWI_Enable = 0x1
	// Position of W field.
	WWDG_CFR_W_Pos = 0x0
	// Bit mask of W field.
	WWDG_CFR_W_Msk = 0x7f
	// Position of WDGTB field.
	WWDG_CFR_WDGTB_Pos = 0xb
	// Bit mask of WDGTB field.
	WWDG_CFR_WDGTB_Msk = 0x3800
	// Counter clock (PCLK1 div 4096) div 1
	WWDG_CFR_WDGTB_Div1 = 0x0
	// Counter clock (PCLK1 div 4096) div 2
	WWDG_CFR_WDGTB_Div2 = 0x1
	// Counter clock (PCLK1 div 4096) div 4
	WWDG_CFR_WDGTB_Div4 = 0x2
	// Counter clock (PCLK1 div 4096) div 8
	WWDG_CFR_WDGTB_Div8 = 0x3

	// SR: Status register
	// Position of EWIF field.
	WWDG_SR_EWIF_Pos = 0x0
	// Bit mask of EWIF field.
	WWDG_SR_EWIF_Msk = 0x1
	// Bit EWIF.
	WWDG_SR_EWIF = 0x1
	// The EWI Interrupt Service Routine has been triggered
	WWDG_SR_EWIF_Pending = 0x1
	// The EWI Interrupt Service Routine has been serviced
	WWDG_SR_EWIF_Finished = 0x0
)
