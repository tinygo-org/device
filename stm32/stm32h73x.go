// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from stm32h735.svd, see https://github.com/tinygo-org/stm32-svd

//go:build stm32 && stm32h73x
// +build stm32,stm32h73x

// STM32H73x
//

package stm32

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "STM32H73x"
	CPU          = "CM7"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// WWDG
	IRQ_WWDG1 = 0

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_PVD_PVM = 1

	// RTC
	IRQ_RTC_TAMP_STAMP_CSS_LSE = 2

	// RTC
	IRQ_RTC_WKUP = 3

	// Flash
	IRQ_FLASH = 4

	// Reset and clock control
	IRQ_RCC = 5

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI0 = 6

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI1 = 7

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI2 = 8

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI3 = 9

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI4 = 10

	// DMA controller
	IRQ_DMA_STR0 = 11

	// DMA controller
	IRQ_DMA1_STR0 = 11

	// DMA controller
	IRQ_DMA_STR1 = 12

	// DMA controller
	IRQ_DMA1_STR1 = 12

	// DMA controller
	IRQ_DMA_STR2 = 13

	// DMA controller
	IRQ_DMA1_STR2 = 13

	// DMA controller
	IRQ_DMA_STR3 = 14

	// DMA controller
	IRQ_DMA1_STR3 = 14

	// DMA controller
	IRQ_DMA_STR4 = 15

	// DMA controller
	IRQ_DMA1_STR4 = 15

	// DMA controller
	IRQ_DMA_STR5 = 16

	// DMA controller
	IRQ_DMA1_STR5 = 16

	// DMA controller
	IRQ_DMA_STR6 = 17

	// DMA controller
	IRQ_DMA1_STR6 = 17

	// Analog-to-Digital Converter
	IRQ_ADC1_2 = 18

	// FDCAN1
	IRQ_FDCAN1_IT0 = 19

	IRQ_FDCAN2_IT0 = 20

	// FDCAN1
	IRQ_FDCAN1_IT1 = 21

	IRQ_FDCAN2_IT1 = 22

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI9_5 = 23

	// Advanced-timers
	IRQ_TIM1_BRK = 24

	// Advanced-timers
	IRQ_TIM1_UP = 25

	// Advanced-timers
	IRQ_TIM1_TRG_COM = 26

	// Advanced-timers
	IRQ_TIM_CC = 27

	// General purpose timers
	IRQ_TIM2 = 28

	// General purpose timers
	IRQ_TIM3 = 29

	// General purpose timers
	IRQ_TIM4 = 30

	// I2C
	IRQ_I2C1_EV = 31

	// I2C
	IRQ_I2C1_ER = 32

	IRQ_I2C2_EV = 33

	IRQ_I2C2_ER = 34

	// Serial peripheral interface
	IRQ_SPI1 = 35

	IRQ_SPI2 = 36

	// Universal synchronous asynchronous receiver transmitter
	IRQ_USART1 = 37

	IRQ_USART2 = 38

	IRQ_USART3 = 39

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_EXTI15_10 = 40

	// RTC
	IRQ_RTC_ALARM = 41

	IRQ_TIM8_BRK_TIM12 = 43

	IRQ_TIM8_UP_TIM13 = 44

	IRQ_TIM8_TRG_COM_TIM14 = 45

	IRQ_TIM8_CC = 46

	// DMA controller
	IRQ_DMA1_STR7 = 47

	// FMC
	IRQ_FMC = 48

	// SDMMC1
	IRQ_SDMMC1 = 49

	IRQ_TIM5 = 50

	IRQ_SPI3 = 51

	IRQ_UART4 = 52

	IRQ_UART5 = 53

	// Basic timers
	IRQ_TIM6_DAC = 54

	IRQ_TIM7 = 55

	IRQ_DMA2_STR0 = 56

	IRQ_DMA2_STR1 = 57

	IRQ_DMA2_STR2 = 58

	IRQ_DMA2_STR3 = 59

	IRQ_DMA2_STR4 = 60

	// Ethernet: media access control (MAC)
	IRQ_ETH = 61

	// Ethernet: media access control (MAC)
	IRQ_ETH_WKUP = 62

	// FDCAN1
	IRQ_FDCAN_CAL = 63

	IRQ_DMA2_STR5 = 68

	IRQ_DMA2_STR6 = 69

	IRQ_DMA2_STR7 = 70

	IRQ_USART6 = 71

	IRQ_I2C3_EV = 72

	IRQ_I2C3_ER = 73

	// Digital camera interface
	IRQ_DCMI = 78

	// Cryptographic processor
	IRQ_CRYP = 79

	// Floting point unit
	IRQ_FPU = 81

	IRQ_UART7 = 82

	IRQ_UART8 = 83

	IRQ_SPI4 = 84

	IRQ_SPI5 = 85

	IRQ_SPI6 = 86

	// SAI
	IRQ_SAI1 = 87

	// LCD-TFT Controller
	IRQ_LTDC = 88

	// LCD-TFT Controller
	IRQ_LTDC_ER = 89

	// DMA2D
	IRQ_DMA2D = 90

	// OctoSPI
	IRQ_OCTOSPI1 = 92

	// Low power timer
	IRQ_LPTIM1 = 93

	// CEC
	IRQ_CEC = 94

	IRQ_I2C4_EV = 95

	IRQ_I2C4_ER = 96

	// Receiver Interface
	IRQ_SPDIF = 97

	// DMAMUX
	IRQ_DMAMUX1_OV = 102

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT0 = 110

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT1 = 111

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT2 = 112

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT3 = 113

	// Single Wire Protocol Master Interface
	IRQ_SWPMI1 = 115

	// General purpose timers
	IRQ_TIM15 = 116

	// General-purpose-timers
	IRQ_TIM16 = 117

	// General-purpose-timers
	IRQ_TIM17 = 118

	// Management data input/output slave
	IRQ_MDIOS_WKUP = 119

	// Management data input/output slave
	IRQ_MDIOS = 120

	// MDMA
	IRQ_MDMA = 122

	IRQ_SDMMC2 = 124

	// HSEM
	IRQ_HSEM0 = 125

	IRQ_ADC3 = 127

	// DMAMUX2
	IRQ_DMAMUX2_OVR = 128

	// Basic Direct Memory Access
	IRQ_BDMA_CH0 = 129

	// Basic Direct Memory Access
	IRQ_BDMA_CH1 = 130

	// Basic Direct Memory Access
	IRQ_BDMA_CH2 = 131

	// Basic Direct Memory Access
	IRQ_BDMA_CH3 = 132

	// Basic Direct Memory Access
	IRQ_BDMA_CH4 = 133

	// Basic Direct Memory Access
	IRQ_BDMA_CH5 = 134

	// Basic Direct Memory Access
	IRQ_BDMA_CH6 = 135

	// Basic Direct Memory Access
	IRQ_BDMA_CH7 = 136

	// COMP1
	IRQ_COMP = 137

	IRQ_LPTIM2 = 138

	// Low power timer
	IRQ_LPTIM3 = 139

	IRQ_LPTIM4 = 140

	IRQ_LPTIM5 = 141

	// LPUART1
	IRQ_LPUART = 142

	// Clock Recovery System
	IRQ_CRS = 144

	IRQ_SAI4 = 146

	// DELAY_Block_SDMMC1 // External interrupt/event controller
	IRQ_WKUP = 149

	IRQ_OCTOSPI2 = 150

	// Highest interrupt number on this device.
	IRQ_max = 150
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export WWDG1_IRQHandler
func interruptWWDG1() {
	callHandlers(IRQ_WWDG1)
}

//export PVD_PVM_IRQHandler
func interruptPVD_PVM() {
	callHandlers(IRQ_PVD_PVM)
}

//export RTC_TAMP_STAMP_CSS_LSE_IRQHandler
func interruptRTC_TAMP_STAMP_CSS_LSE() {
	callHandlers(IRQ_RTC_TAMP_STAMP_CSS_LSE)
}

//export RTC_WKUP_IRQHandler
func interruptRTC_WKUP() {
	callHandlers(IRQ_RTC_WKUP)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export RCC_IRQHandler
func interruptRCC() {
	callHandlers(IRQ_RCC)
}

//export EXTI0_IRQHandler
func interruptEXTI0() {
	callHandlers(IRQ_EXTI0)
}

//export EXTI1_IRQHandler
func interruptEXTI1() {
	callHandlers(IRQ_EXTI1)
}

//export EXTI2_IRQHandler
func interruptEXTI2() {
	callHandlers(IRQ_EXTI2)
}

//export EXTI3_IRQHandler
func interruptEXTI3() {
	callHandlers(IRQ_EXTI3)
}

//export EXTI4_IRQHandler
func interruptEXTI4() {
	callHandlers(IRQ_EXTI4)
}

//export DMA_STR0_IRQHandler
func interruptDMA_STR0() {
	callHandlers(IRQ_DMA_STR0)
}

//export DMA1_STR0_IRQHandler
func interruptDMA1_STR0() {
	callHandlers(IRQ_DMA1_STR0)
}

//export DMA_STR1_IRQHandler
func interruptDMA_STR1() {
	callHandlers(IRQ_DMA_STR1)
}

//export DMA1_STR1_IRQHandler
func interruptDMA1_STR1() {
	callHandlers(IRQ_DMA1_STR1)
}

//export DMA_STR2_IRQHandler
func interruptDMA_STR2() {
	callHandlers(IRQ_DMA_STR2)
}

//export DMA1_STR2_IRQHandler
func interruptDMA1_STR2() {
	callHandlers(IRQ_DMA1_STR2)
}

//export DMA_STR3_IRQHandler
func interruptDMA_STR3() {
	callHandlers(IRQ_DMA_STR3)
}

//export DMA1_STR3_IRQHandler
func interruptDMA1_STR3() {
	callHandlers(IRQ_DMA1_STR3)
}

//export DMA_STR4_IRQHandler
func interruptDMA_STR4() {
	callHandlers(IRQ_DMA_STR4)
}

//export DMA1_STR4_IRQHandler
func interruptDMA1_STR4() {
	callHandlers(IRQ_DMA1_STR4)
}

//export DMA_STR5_IRQHandler
func interruptDMA_STR5() {
	callHandlers(IRQ_DMA_STR5)
}

//export DMA1_STR5_IRQHandler
func interruptDMA1_STR5() {
	callHandlers(IRQ_DMA1_STR5)
}

//export DMA_STR6_IRQHandler
func interruptDMA_STR6() {
	callHandlers(IRQ_DMA_STR6)
}

//export DMA1_STR6_IRQHandler
func interruptDMA1_STR6() {
	callHandlers(IRQ_DMA1_STR6)
}

//export ADC1_2_IRQHandler
func interruptADC1_2() {
	callHandlers(IRQ_ADC1_2)
}

//export FDCAN1_IT0_IRQHandler
func interruptFDCAN1_IT0() {
	callHandlers(IRQ_FDCAN1_IT0)
}

//export FDCAN2_IT0_IRQHandler
func interruptFDCAN2_IT0() {
	callHandlers(IRQ_FDCAN2_IT0)
}

//export FDCAN1_IT1_IRQHandler
func interruptFDCAN1_IT1() {
	callHandlers(IRQ_FDCAN1_IT1)
}

//export FDCAN2_IT1_IRQHandler
func interruptFDCAN2_IT1() {
	callHandlers(IRQ_FDCAN2_IT1)
}

//export EXTI9_5_IRQHandler
func interruptEXTI9_5() {
	callHandlers(IRQ_EXTI9_5)
}

//export TIM1_BRK_IRQHandler
func interruptTIM1_BRK() {
	callHandlers(IRQ_TIM1_BRK)
}

//export TIM1_UP_IRQHandler
func interruptTIM1_UP() {
	callHandlers(IRQ_TIM1_UP)
}

//export TIM1_TRG_COM_IRQHandler
func interruptTIM1_TRG_COM() {
	callHandlers(IRQ_TIM1_TRG_COM)
}

//export TIM_CC_IRQHandler
func interruptTIM_CC() {
	callHandlers(IRQ_TIM_CC)
}

//export TIM2_IRQHandler
func interruptTIM2() {
	callHandlers(IRQ_TIM2)
}

//export TIM3_IRQHandler
func interruptTIM3() {
	callHandlers(IRQ_TIM3)
}

//export TIM4_IRQHandler
func interruptTIM4() {
	callHandlers(IRQ_TIM4)
}

//export I2C1_EV_IRQHandler
func interruptI2C1_EV() {
	callHandlers(IRQ_I2C1_EV)
}

//export I2C1_ER_IRQHandler
func interruptI2C1_ER() {
	callHandlers(IRQ_I2C1_ER)
}

//export I2C2_EV_IRQHandler
func interruptI2C2_EV() {
	callHandlers(IRQ_I2C2_EV)
}

//export I2C2_ER_IRQHandler
func interruptI2C2_ER() {
	callHandlers(IRQ_I2C2_ER)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export SPI2_IRQHandler
func interruptSPI2() {
	callHandlers(IRQ_SPI2)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export EXTI15_10_IRQHandler
func interruptEXTI15_10() {
	callHandlers(IRQ_EXTI15_10)
}

//export RTC_ALARM_IRQHandler
func interruptRTC_ALARM() {
	callHandlers(IRQ_RTC_ALARM)
}

//export TIM8_BRK_TIM12_IRQHandler
func interruptTIM8_BRK_TIM12() {
	callHandlers(IRQ_TIM8_BRK_TIM12)
}

//export TIM8_UP_TIM13_IRQHandler
func interruptTIM8_UP_TIM13() {
	callHandlers(IRQ_TIM8_UP_TIM13)
}

//export TIM8_TRG_COM_TIM14_IRQHandler
func interruptTIM8_TRG_COM_TIM14() {
	callHandlers(IRQ_TIM8_TRG_COM_TIM14)
}

//export TIM8_CC_IRQHandler
func interruptTIM8_CC() {
	callHandlers(IRQ_TIM8_CC)
}

//export DMA1_STR7_IRQHandler
func interruptDMA1_STR7() {
	callHandlers(IRQ_DMA1_STR7)
}

//export FMC_IRQHandler
func interruptFMC() {
	callHandlers(IRQ_FMC)
}

//export SDMMC1_IRQHandler
func interruptSDMMC1() {
	callHandlers(IRQ_SDMMC1)
}

//export TIM5_IRQHandler
func interruptTIM5() {
	callHandlers(IRQ_TIM5)
}

//export SPI3_IRQHandler
func interruptSPI3() {
	callHandlers(IRQ_SPI3)
}

//export UART4_IRQHandler
func interruptUART4() {
	callHandlers(IRQ_UART4)
}

//export UART5_IRQHandler
func interruptUART5() {
	callHandlers(IRQ_UART5)
}

//export TIM6_DAC_IRQHandler
func interruptTIM6_DAC() {
	callHandlers(IRQ_TIM6_DAC)
}

//export TIM7_IRQHandler
func interruptTIM7() {
	callHandlers(IRQ_TIM7)
}

//export DMA2_STR0_IRQHandler
func interruptDMA2_STR0() {
	callHandlers(IRQ_DMA2_STR0)
}

//export DMA2_STR1_IRQHandler
func interruptDMA2_STR1() {
	callHandlers(IRQ_DMA2_STR1)
}

//export DMA2_STR2_IRQHandler
func interruptDMA2_STR2() {
	callHandlers(IRQ_DMA2_STR2)
}

//export DMA2_STR3_IRQHandler
func interruptDMA2_STR3() {
	callHandlers(IRQ_DMA2_STR3)
}

//export DMA2_STR4_IRQHandler
func interruptDMA2_STR4() {
	callHandlers(IRQ_DMA2_STR4)
}

//export ETH_IRQHandler
func interruptETH() {
	callHandlers(IRQ_ETH)
}

//export ETH_WKUP_IRQHandler
func interruptETH_WKUP() {
	callHandlers(IRQ_ETH_WKUP)
}

//export FDCAN_CAL_IRQHandler
func interruptFDCAN_CAL() {
	callHandlers(IRQ_FDCAN_CAL)
}

//export DMA2_STR5_IRQHandler
func interruptDMA2_STR5() {
	callHandlers(IRQ_DMA2_STR5)
}

//export DMA2_STR6_IRQHandler
func interruptDMA2_STR6() {
	callHandlers(IRQ_DMA2_STR6)
}

//export DMA2_STR7_IRQHandler
func interruptDMA2_STR7() {
	callHandlers(IRQ_DMA2_STR7)
}

//export USART6_IRQHandler
func interruptUSART6() {
	callHandlers(IRQ_USART6)
}

//export I2C3_EV_IRQHandler
func interruptI2C3_EV() {
	callHandlers(IRQ_I2C3_EV)
}

//export I2C3_ER_IRQHandler
func interruptI2C3_ER() {
	callHandlers(IRQ_I2C3_ER)
}

//export DCMI_IRQHandler
func interruptDCMI() {
	callHandlers(IRQ_DCMI)
}

//export CRYP_IRQHandler
func interruptCRYP() {
	callHandlers(IRQ_CRYP)
}

//export FPU_IRQHandler
func interruptFPU() {
	callHandlers(IRQ_FPU)
}

//export UART7_IRQHandler
func interruptUART7() {
	callHandlers(IRQ_UART7)
}

//export UART8_IRQHandler
func interruptUART8() {
	callHandlers(IRQ_UART8)
}

//export SPI4_IRQHandler
func interruptSPI4() {
	callHandlers(IRQ_SPI4)
}

//export SPI5_IRQHandler
func interruptSPI5() {
	callHandlers(IRQ_SPI5)
}

//export SPI6_IRQHandler
func interruptSPI6() {
	callHandlers(IRQ_SPI6)
}

//export SAI1_IRQHandler
func interruptSAI1() {
	callHandlers(IRQ_SAI1)
}

//export LTDC_IRQHandler
func interruptLTDC() {
	callHandlers(IRQ_LTDC)
}

//export LTDC_ER_IRQHandler
func interruptLTDC_ER() {
	callHandlers(IRQ_LTDC_ER)
}

//export DMA2D_IRQHandler
func interruptDMA2D() {
	callHandlers(IRQ_DMA2D)
}

//export OCTOSPI1_IRQHandler
func interruptOCTOSPI1() {
	callHandlers(IRQ_OCTOSPI1)
}

//export LPTIM1_IRQHandler
func interruptLPTIM1() {
	callHandlers(IRQ_LPTIM1)
}

//export CEC_IRQHandler
func interruptCEC() {
	callHandlers(IRQ_CEC)
}

//export I2C4_EV_IRQHandler
func interruptI2C4_EV() {
	callHandlers(IRQ_I2C4_EV)
}

//export I2C4_ER_IRQHandler
func interruptI2C4_ER() {
	callHandlers(IRQ_I2C4_ER)
}

//export SPDIF_IRQHandler
func interruptSPDIF() {
	callHandlers(IRQ_SPDIF)
}

//export DMAMUX1_OV_IRQHandler
func interruptDMAMUX1_OV() {
	callHandlers(IRQ_DMAMUX1_OV)
}

//export DFSDM1_FLT0_IRQHandler
func interruptDFSDM1_FLT0() {
	callHandlers(IRQ_DFSDM1_FLT0)
}

//export DFSDM1_FLT1_IRQHandler
func interruptDFSDM1_FLT1() {
	callHandlers(IRQ_DFSDM1_FLT1)
}

//export DFSDM1_FLT2_IRQHandler
func interruptDFSDM1_FLT2() {
	callHandlers(IRQ_DFSDM1_FLT2)
}

//export DFSDM1_FLT3_IRQHandler
func interruptDFSDM1_FLT3() {
	callHandlers(IRQ_DFSDM1_FLT3)
}

//export SWPMI1_IRQHandler
func interruptSWPMI1() {
	callHandlers(IRQ_SWPMI1)
}

//export TIM15_IRQHandler
func interruptTIM15() {
	callHandlers(IRQ_TIM15)
}

//export TIM16_IRQHandler
func interruptTIM16() {
	callHandlers(IRQ_TIM16)
}

//export TIM17_IRQHandler
func interruptTIM17() {
	callHandlers(IRQ_TIM17)
}

//export MDIOS_WKUP_IRQHandler
func interruptMDIOS_WKUP() {
	callHandlers(IRQ_MDIOS_WKUP)
}

//export MDIOS_IRQHandler
func interruptMDIOS() {
	callHandlers(IRQ_MDIOS)
}

//export MDMA_IRQHandler
func interruptMDMA() {
	callHandlers(IRQ_MDMA)
}

//export SDMMC2_IRQHandler
func interruptSDMMC2() {
	callHandlers(IRQ_SDMMC2)
}

//export HSEM0_IRQHandler
func interruptHSEM0() {
	callHandlers(IRQ_HSEM0)
}

//export ADC3_IRQHandler
func interruptADC3() {
	callHandlers(IRQ_ADC3)
}

//export DMAMUX2_OVR_IRQHandler
func interruptDMAMUX2_OVR() {
	callHandlers(IRQ_DMAMUX2_OVR)
}

//export BDMA_CH0_IRQHandler
func interruptBDMA_CH0() {
	callHandlers(IRQ_BDMA_CH0)
}

//export BDMA_CH1_IRQHandler
func interruptBDMA_CH1() {
	callHandlers(IRQ_BDMA_CH1)
}

//export BDMA_CH2_IRQHandler
func interruptBDMA_CH2() {
	callHandlers(IRQ_BDMA_CH2)
}

//export BDMA_CH3_IRQHandler
func interruptBDMA_CH3() {
	callHandlers(IRQ_BDMA_CH3)
}

//export BDMA_CH4_IRQHandler
func interruptBDMA_CH4() {
	callHandlers(IRQ_BDMA_CH4)
}

//export BDMA_CH5_IRQHandler
func interruptBDMA_CH5() {
	callHandlers(IRQ_BDMA_CH5)
}

//export BDMA_CH6_IRQHandler
func interruptBDMA_CH6() {
	callHandlers(IRQ_BDMA_CH6)
}

//export BDMA_CH7_IRQHandler
func interruptBDMA_CH7() {
	callHandlers(IRQ_BDMA_CH7)
}

//export COMP_IRQHandler
func interruptCOMP() {
	callHandlers(IRQ_COMP)
}

//export LPTIM2_IRQHandler
func interruptLPTIM2() {
	callHandlers(IRQ_LPTIM2)
}

//export LPTIM3_IRQHandler
func interruptLPTIM3() {
	callHandlers(IRQ_LPTIM3)
}

//export LPTIM4_IRQHandler
func interruptLPTIM4() {
	callHandlers(IRQ_LPTIM4)
}

//export LPTIM5_IRQHandler
func interruptLPTIM5() {
	callHandlers(IRQ_LPTIM5)
}

//export LPUART_IRQHandler
func interruptLPUART() {
	callHandlers(IRQ_LPUART)
}

//export CRS_IRQHandler
func interruptCRS() {
	callHandlers(IRQ_CRS)
}

//export SAI4_IRQHandler
func interruptSAI4() {
	callHandlers(IRQ_SAI4)
}

//export WKUP_IRQHandler
func interruptWKUP() {
	callHandlers(IRQ_WKUP)
}

//export OCTOSPI2_IRQHandler
func interruptOCTOSPI2() {
	callHandlers(IRQ_OCTOSPI2)
}

// Peripherals.
var (
	// Access control
	AC = (*AC_Type)(unsafe.Pointer(uintptr(0xe000ef90)))

	// Analog to Digital Converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// Analog-to-Digital Converter
	ADC12_Common = (*ADC_Type)(unsafe.Pointer(uintptr(0x40022300)))

	// AXI interconnect registers
	AXI = (*AXI_Type)(unsafe.Pointer(uintptr(0x51000000)))

	// CCU registers
	CAN_CCU = (*FDCAN_Type)(unsafe.Pointer(uintptr(0x4000a800)))

	// CEC
	CEC = (*CEC_Type)(unsafe.Pointer(uintptr(0x40006c00)))

	// COMP1
	COMP1 = (*COMP1_Type)(unsafe.Pointer(uintptr(0x58003800)))

	// Cryptographic processor
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x58024c00)))

	// Clock Recovery System
	CRS = (*CRS_Type)(unsafe.Pointer(uintptr(0x40008400)))

	// Cryptographic processor
	CRYP = (*CRYP_Type)(unsafe.Pointer(uintptr(0x48021000)))

	// DAC
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x40007400)))

	// Microcontroller Debug Unit
	DBGMCU = (*DBGMCU_Type)(unsafe.Pointer(uintptr(0x5c001000)))

	// Digital camera interface
	DCMI = (*DCMI_Type)(unsafe.Pointer(uintptr(0x48020000)))

	// DELAY_Block_SDMMC1
	DELAY_Block_SDMMC1 = (*DLYB_Type)(unsafe.Pointer(uintptr(0x52008000)))

	// Digital filter for sigma delta modulators
	DFSDM = (*DFSDM_Type)(unsafe.Pointer(uintptr(0x40017800)))

	// DMA controller
	DMA1 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// DMA2D
	DMA2D = (*DMA2D_Type)(unsafe.Pointer(uintptr(0x52001000)))

	// DMAMUX
	DMAMUX1 = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x40020800)))

	// DMAMUX2
	DMAMUX2 = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x58025800)))

	// External interrupt/event controller
	EXTI = (*EXTI_Type)(unsafe.Pointer(uintptr(0x58000000)))

	// Ethernet: media access control (MAC)
	Ethernet_MAC = (*Ethernet_Type)(unsafe.Pointer(uintptr(0x40028000)))

	// FDCAN1
	FDCAN1 = (*FDCAN_Type)(unsafe.Pointer(uintptr(0x4000a000)))

	// FMC
	FMC = (*FMC_Type)(unsafe.Pointer(uintptr(0x52004000)))

	// Floting point unit
	FPU = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ef34)))

	// Floating point unit CPACR
	FPU_CPACR = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ed88)))

	// Flash
	FLASH = (*FLASH_Type)(unsafe.Pointer(uintptr(0x52002000)))

	// GPIO
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58020000)))

	// HSEM
	HSEM = (*HSEM_Type)(unsafe.Pointer(uintptr(0x58026400)))

	// I2C
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// IWDG
	IWDG1 = (*IWDG_Type)(unsafe.Pointer(uintptr(0x58004800)))

	// Low power timer
	LPTIM1 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40002400)))

	// Low power timer
	LPTIM3 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x58002800)))

	// LPUART1
	LPUART1 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x58000c00)))

	// LCD-TFT Controller
	LTDC = (*LTDC_Type)(unsafe.Pointer(uintptr(0x50001000)))

	// Management data input/output slave
	MDIOS = (*MDIOS_Type)(unsafe.Pointer(uintptr(0x40009400)))

	// MDMA
	MDMA = (*MDMA_Type)(unsafe.Pointer(uintptr(0x52000000)))

	// Memory protection unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Nested vectored interrupt controller
	NVIC_STIR = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000ef00)))

	// OctoSPI
	OCTOSPI1 = (*OctoSPI_Type)(unsafe.Pointer(uintptr(0x52005000)))

	// Operational amplifiers
	OPAMP = (*OPAMP_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// USB 1 on the go high speed
	OTG1_HS_DEVICE = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040800)))

	// USB 1 on the go high speed
	OTG1_HS_GLOBAL = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// USB 1 on the go high speed
	OTG1_HS_HOST = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040400)))

	// USB 1 on the go high speed
	OTG1_HS_PWRCLK = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040e00)))

	// OctoSPI IO Manager
	OctoSPII_O_Manager = (*OctoSPII_O_Manager_Type)(unsafe.Pointer(uintptr(0x5200b400)))

	// Processor features
	PF = (*PF_Type)(unsafe.Pointer(uintptr(0xe000ed78)))

	// PWR
	PWR = (*PWR_Type)(unsafe.Pointer(uintptr(0x58024800)))

	// ECC controller is associated to each RAM area
	RAMECC1 = (*RAMECC_Type)(unsafe.Pointer(uintptr(0x52009000)))

	// ECC controller is associated to each RAM area
	RAMECC2 = (*RAMECC_Type)(unsafe.Pointer(uintptr(0x48023000)))

	// ECC controller is associated to each RAM area
	RAMECC3 = (*RAMECC_Type)(unsafe.Pointer(uintptr(0x58027000)))

	// Reset and clock control
	RCC = (*RCC_Type)(unsafe.Pointer(uintptr(0x58024400)))

	// RNG
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x48021800)))

	// RTC
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x58004000)))

	// SAI
	SAI1 = (*SAI_Type)(unsafe.Pointer(uintptr(0x40015800)))

	// System control block
	SCB = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000ed00)))

	// System control block ACTLR
	SCB_ACTRL = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000e008)))

	// SDMMC1
	SDMMC1 = (*SDMMC_Type)(unsafe.Pointer(uintptr(0x52007000)))

	// Receiver Interface
	SPDIFRX = (*SPDIFRX_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Serial peripheral interface
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// SysTick timer
	STK = (*STK_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// Single Wire Protocol Master Interface
	SWPMI = (*SWPMI_Type)(unsafe.Pointer(uintptr(0x40008800)))

	// System configuration controller
	SYSCFG = (*SYSCFG_Type)(unsafe.Pointer(uintptr(0x58000400)))

	// Advanced-timers
	TIM1 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// General purpose timers
	TIM2 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Basic timers
	TIM6 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// General purpose timers
	TIM15 = (*TIMs_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// General-purpose-timers
	TIM16 = (*TIMs_Type)(unsafe.Pointer(uintptr(0x40014400)))

	// General-purpose-timers
	TIM17 = (*TIMs_Type)(unsafe.Pointer(uintptr(0x40014800)))

	// Universal synchronous asynchronous receiver transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40011000)))

	// VREFBUF
	VREFBUF = (*VREFBUF_Type)(unsafe.Pointer(uintptr(0x58003c00)))

	// WWDG
	WWDG1 = (*WWDG_Type)(unsafe.Pointer(uintptr(0x50003000)))

	// General purpose timers
	TIM3 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000400)))

	// General purpose timers
	TIM4 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000800)))

	// General purpose timers
	TIM12 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001800)))

	// General purpose timers
	TIM13 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001c00)))

	// General purpose timers
	TIM14 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Basic Direct Memory Access
	BDMA = (*BDMA_Type)(unsafe.Pointer(uintptr(0x58025400)))

	// Ethernet DMA
	Ethernet_DMA = (*Ethernet_DMA_Type)(unsafe.Pointer(uintptr(0x40029000)))

	// Ethernet MTL
	Ethernet_MTL = (*Ethernet_MTL_Type)(unsafe.Pointer(uintptr(0x40028c00)))

	// Analog to Digital Converter
	ADC3 = (*ADC_Type)(unsafe.Pointer(uintptr(0x58026000)))

	// Analog-to-Digital Converter
	ADC3_Common = (*ADC_Type)(unsafe.Pointer(uintptr(0x58026300)))

	// DELAY_Block_SDMMC1
	DELAY_Block_SDMMC2 = (*DLYB_Type)(unsafe.Pointer(uintptr(0x48022800)))

	// DELAY_Block_SDMMC1
	Delay_Block_OCTOSPI1 = (*DLYB_Type)(unsafe.Pointer(uintptr(0x52006000)))

	// DELAY_Block_SDMMC1
	Delay_Block_OCTOSPI2 = (*DLYB_Type)(unsafe.Pointer(uintptr(0x5200b000)))

	// FDCAN1
	FDCAN2 = (*FDCAN_Type)(unsafe.Pointer(uintptr(0x4000a400)))

	// GPIO
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58020400)))

	// GPIO
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58020800)))

	// GPIO
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58020c00)))

	// GPIO
	GPIOE = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58021000)))

	// GPIO
	GPIOF = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58021400)))

	// GPIO
	GPIOG = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58021800)))

	// GPIO
	GPIOH = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58021c00)))

	// GPIO
	GPIOJ = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58022400)))

	// GPIO
	GPIOK = (*GPIO_Type)(unsafe.Pointer(uintptr(0x58022800)))

	// I2C
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005800)))

	// I2C
	I2C3 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005c00)))

	// I2C
	I2C4 = (*I2C_Type)(unsafe.Pointer(uintptr(0x58001c00)))

	// Low power timer
	LPTIM2 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x58002400)))

	// Low power timer
	LPTIM4 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x58002c00)))

	// Low power timer
	LPTIM5 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x58003000)))

	// OctoSPI
	OCTOSPI2 = (*OctoSPI_Type)(unsafe.Pointer(uintptr(0x5200a000)))

	// USB 1 on the go high speed
	OTG2_HS_DEVICE = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40080800)))

	// USB 1 on the go high speed
	OTG2_HS_HOST = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40080400)))

	// USB 1 on the go high speed
	OTG2_HS_PWRCLK = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40080e00)))

	// SAI
	SAI4 = (*SAI_Type)(unsafe.Pointer(uintptr(0x58005400)))

	// SDMMC1
	SDMMC2 = (*SDMMC_Type)(unsafe.Pointer(uintptr(0x48022400)))

	// Serial peripheral interface
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Serial peripheral interface
	SPI3 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003c00)))

	// Serial peripheral interface
	SPI4 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013400)))

	// Serial peripheral interface
	SPI5 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Serial peripheral interface
	SPI6 = (*SPI_Type)(unsafe.Pointer(uintptr(0x58001400)))

	// General purpose timers
	TIM5 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// Basic timers
	TIM7 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001400)))

	// Advanced-timers
	TIM8 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40010400)))

	// Universal synchronous asynchronous receiver transmitter
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004400)))

	// Universal synchronous asynchronous receiver transmitter
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004800)))

	// Universal synchronous asynchronous receiver transmitter
	UART4 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004c00)))

	// Universal synchronous asynchronous receiver transmitter
	UART5 = (*USART_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Universal synchronous asynchronous receiver transmitter
	USART6 = (*USART_Type)(unsafe.Pointer(uintptr(0x40011400)))

	// Universal synchronous asynchronous receiver transmitter
	UART7 = (*USART_Type)(unsafe.Pointer(uintptr(0x40007800)))

	// Universal synchronous asynchronous receiver transmitter
	UART8 = (*USART_Type)(unsafe.Pointer(uintptr(0x40007c00)))

	// Analog to Digital Converter
	ADC2 = (*ADC_Type)(unsafe.Pointer(uintptr(0x40022100)))

	// DMA controller
	DMA2 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020400)))
)

// Access control
type AC_Type struct {
	ITCMCR volatile.Register32 // 0x0
	DTCMCR volatile.Register32 // 0x4
	AHBPCR volatile.Register32 // 0x8
	CACR   volatile.Register32 // 0xC
	AHBSCR volatile.Register32 // 0x10
	_      [4]byte
	ABFSR  volatile.Register32 // 0x18
}

// AC.ITCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
func (o *AC_Type) SetITCMCR_EN(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetITCMCR_EN() uint32 {
	return volatile.LoadUint32(&o.ITCMCR.Reg) & 0x1
}
func (o *AC_Type) SetITCMCR_RMW(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetITCMCR_RMW() uint32 {
	return (volatile.LoadUint32(&o.ITCMCR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetITCMCR_RETEN(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetITCMCR_RETEN() uint32 {
	return (volatile.LoadUint32(&o.ITCMCR.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetITCMCR_SZ(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x78)|value<<3)
}
func (o *AC_Type) GetITCMCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.ITCMCR.Reg) & 0x78) >> 3
}

// AC.DTCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
func (o *AC_Type) SetDTCMCR_EN(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetDTCMCR_EN() uint32 {
	return volatile.LoadUint32(&o.DTCMCR.Reg) & 0x1
}
func (o *AC_Type) SetDTCMCR_RMW(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetDTCMCR_RMW() uint32 {
	return (volatile.LoadUint32(&o.DTCMCR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetDTCMCR_RETEN(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetDTCMCR_RETEN() uint32 {
	return (volatile.LoadUint32(&o.DTCMCR.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetDTCMCR_SZ(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x78)|value<<3)
}
func (o *AC_Type) GetDTCMCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.DTCMCR.Reg) & 0x78) >> 3
}

// AC.AHBPCR: AHBP Control register
func (o *AC_Type) SetAHBPCR_EN(value uint32) {
	volatile.StoreUint32(&o.AHBPCR.Reg, volatile.LoadUint32(&o.AHBPCR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetAHBPCR_EN() uint32 {
	return volatile.LoadUint32(&o.AHBPCR.Reg) & 0x1
}
func (o *AC_Type) SetAHBPCR_SZ(value uint32) {
	volatile.StoreUint32(&o.AHBPCR.Reg, volatile.LoadUint32(&o.AHBPCR.Reg)&^(0xe)|value<<1)
}
func (o *AC_Type) GetAHBPCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.AHBPCR.Reg) & 0xe) >> 1
}

// AC.CACR: Auxiliary Cache Control register
func (o *AC_Type) SetCACR_SIWT(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetCACR_SIWT() uint32 {
	return volatile.LoadUint32(&o.CACR.Reg) & 0x1
}
func (o *AC_Type) SetCACR_ECCEN(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetCACR_ECCEN() uint32 {
	return (volatile.LoadUint32(&o.CACR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetCACR_FORCEWT(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetCACR_FORCEWT() uint32 {
	return (volatile.LoadUint32(&o.CACR.Reg) & 0x4) >> 2
}

// AC.AHBSCR: AHB Slave Control register
func (o *AC_Type) SetAHBSCR_CTL(value uint32) {
	volatile.StoreUint32(&o.AHBSCR.Reg, volatile.LoadUint32(&o.AHBSCR.Reg)&^(0x3)|value)
}
func (o *AC_Type) GetAHBSCR_CTL() uint32 {
	return volatile.LoadUint32(&o.AHBSCR.Reg) & 0x3
}
func (o *AC_Type) SetAHBSCR_TPRI(value uint32) {
	volatile.StoreUint32(&o.AHBSCR.Reg, volatile.LoadUint32(&o.AHBSCR.Reg)&^(0x7fc)|value<<2)
}
func (o *AC_Type) GetAHBSCR_TPRI() uint32 {
	return (volatile.LoadUint32(&o.AHBSCR.Reg) & 0x7fc) >> 2
}
func (o *AC_Type) SetAHBSCR_INITCOUNT(value uint32) {
	volatile.StoreUint32(&o.AHBSCR.Reg, volatile.LoadUint32(&o.AHBSCR.Reg)&^(0xf800)|value<<11)
}
func (o *AC_Type) GetAHBSCR_INITCOUNT() uint32 {
	return (volatile.LoadUint32(&o.AHBSCR.Reg) & 0xf800) >> 11
}

// AC.ABFSR: Auxiliary Bus Fault Status register
func (o *AC_Type) SetABFSR_ITCM(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetABFSR_ITCM() uint32 {
	return volatile.LoadUint32(&o.ABFSR.Reg) & 0x1
}
func (o *AC_Type) SetABFSR_DTCM(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetABFSR_DTCM() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetABFSR_AHBP(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetABFSR_AHBP() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetABFSR_AXIM(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x8)|value<<3)
}
func (o *AC_Type) GetABFSR_AXIM() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x8) >> 3
}
func (o *AC_Type) SetABFSR_EPPB(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetABFSR_EPPB() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x10) >> 4
}
func (o *AC_Type) SetABFSR_AXIMTYPE(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x300)|value<<8)
}
func (o *AC_Type) GetABFSR_AXIMTYPE() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x300) >> 8
}

// Analog to Digital Converter
type ADC_Type struct {
	ISR      volatile.Register32 // 0x0
	IER      volatile.Register32 // 0x4
	CR       volatile.Register32 // 0x8
	CFGR     volatile.Register32 // 0xC
	CFGR2    volatile.Register32 // 0x10
	SMPR1    volatile.Register32 // 0x14
	SMPR2    volatile.Register32 // 0x18
	PCSEL    volatile.Register32 // 0x1C
	LTR1     volatile.Register32 // 0x20
	HTR1     volatile.Register32 // 0x24
	_        [8]byte
	SQR1     volatile.Register32 // 0x30
	SQR2     volatile.Register32 // 0x34
	SQR3     volatile.Register32 // 0x38
	SQR4     volatile.Register32 // 0x3C
	DR       volatile.Register32 // 0x40
	_        [8]byte
	JSQR     volatile.Register32 // 0x4C
	_        [16]byte
	OFR1     volatile.Register32 // 0x60
	OFR2     volatile.Register32 // 0x64
	OFR3     volatile.Register32 // 0x68
	OFR4     volatile.Register32 // 0x6C
	_        [16]byte
	JDR1     volatile.Register32 // 0x80
	JDR2     volatile.Register32 // 0x84
	JDR3     volatile.Register32 // 0x88
	JDR4     volatile.Register32 // 0x8C
	_        [16]byte
	AWD2CR   volatile.Register32 // 0xA0
	AWD3CR   volatile.Register32 // 0xA4
	_        [8]byte
	LTR2     volatile.Register32 // 0xB0
	HTR2     volatile.Register32 // 0xB4
	LTR3     volatile.Register32 // 0xB8
	HTR3     volatile.Register32 // 0xBC
	DIFSEL   volatile.Register32 // 0xC0
	CALFACT  volatile.Register32 // 0xC4
	CALFACT2 volatile.Register32 // 0xC8
}

// ADC.ISR: ADC interrupt and status register
func (o *ADC_Type) SetISR_JQOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetISR_JQOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetISR_AWD3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetISR_AWD3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetISR_AWD2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetISR_AWD2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetISR_AWD1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetISR_AWD1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetISR_JEOS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetISR_JEOS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetISR_JEOC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetISR_JEOC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetISR_EOS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetISR_EOS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetISR_EOC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetISR_EOC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetISR_EOSMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetISR_EOSMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetISR_ADRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetISR_ADRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// ADC.IER: ADC interrupt enable register
func (o *ADC_Type) SetIER_JQOVFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIER_JQOVFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIER_AWD3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIER_AWD3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIER_AWD2IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIER_AWD2IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIER_AWD1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIER_AWD1IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIER_JEOSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIER_JEOSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIER_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIER_JEOCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIER_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIER_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIER_EOSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIER_EOSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIER_EOCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIER_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIER_EOSMPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIER_EOSMPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIER_ADRDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIER_ADRDYIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// ADC.CR: ADC control register
func (o *ADC_Type) SetCR_ADCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetCR_ADCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetCR_ADCALDIF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetCR_ADCALDIF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetCR_DEEPPWD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetCR_DEEPPWD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetCR_ADVREGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_Type) GetCR_ADVREGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *ADC_Type) SetCR_LINCALRDYW6(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *ADC_Type) GetCR_LINCALRDYW6() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *ADC_Type) SetCR_LINCALRDYW5(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetCR_LINCALRDYW5() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetCR_LINCALRDYW4(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetCR_LINCALRDYW4() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetCR_LINCALRDYW3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCR_LINCALRDYW3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetCR_LINCALRDYW2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCR_LINCALRDYW2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCR_LINCALRDYW1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCR_LINCALRDYW1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCR_ADCALLIN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCR_ADCALLIN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCR_BOOST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *ADC_Type) GetCR_BOOST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *ADC_Type) SetCR_JADSTP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCR_JADSTP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCR_ADSTP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCR_ADSTP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCR_JADSTART(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCR_JADSTART() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCR_ADSTART(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCR_ADSTART() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCR_ADDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR_ADDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR_ADEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR_ADEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// ADC.CFGR: ADC configuration register 1
func (o *ADC_Type) SetCFGR_JQDIS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetCFGR_JQDIS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetCFGR_AWD1CH(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetCFGR_AWD1CH() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetCFGR_JAUTO(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetCFGR_JAUTO() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetCFGR_JAWD1EN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCFGR_JAWD1EN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetCFGR_AWD1EN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCFGR_AWD1EN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCFGR_AWD1SGL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCFGR_AWD1SGL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCFGR_JQM(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCFGR_JQM() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCFGR_JDISCEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetCFGR_JDISCEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetCFGR_DISCNUM(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe0000)|value<<17)
}
func (o *ADC_Type) GetCFGR_DISCNUM() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe0000) >> 17
}
func (o *ADC_Type) SetCFGR_DISCEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCFGR_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCFGR_AUTDLY(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetCFGR_AUTDLY() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetCFGR_CONT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFGR_CONT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFGR_OVRMOD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCFGR_OVRMOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCFGR_EXTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc00)|value<<10)
}
func (o *ADC_Type) GetCFGR_EXTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc00) >> 10
}
func (o *ADC_Type) SetCFGR_EXTSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC_Type) GetCFGR_EXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x3e0) >> 5
}
func (o *ADC_Type) SetCFGR_RES(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1c)|value<<2)
}
func (o *ADC_Type) GetCFGR_RES() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1c) >> 2
}
func (o *ADC_Type) SetCFGR_DMNGT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCFGR_DMNGT() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x3
}

// ADC.CFGR2: ADC configuration register 2
func (o *ADC_Type) SetCFGR2_ROVSE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR2_ROVSE() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}
func (o *ADC_Type) SetCFGR2_JOVSE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCFGR2_JOVSE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCFGR2_OVSS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1e0)|value<<5)
}
func (o *ADC_Type) GetCFGR2_OVSS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1e0) >> 5
}
func (o *ADC_Type) SetCFGR2_TROVS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCFGR2_TROVS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCFGR2_ROVSM(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCFGR2_ROVSM() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCFGR2_RSHIFT1(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCFGR2_RSHIFT1() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetCFGR2_RSHIFT2(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCFGR2_RSHIFT2() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCFGR2_RSHIFT3(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFGR2_RSHIFT3() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFGR2_RSHIFT4(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetCFGR2_RSHIFT4() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetCFGR2_OSVR(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x3ff0000)|value<<16)
}
func (o *ADC_Type) GetCFGR2_OSVR() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x3ff0000) >> 16
}
func (o *ADC_Type) SetCFGR2_LSHIFT(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetCFGR2_LSHIFT() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xf0000000) >> 28
}

// ADC.SMPR1: ADC sampling time register 1
func (o *ADC_Type) SetSMPR1_SMP9(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC_Type) GetSMPR1_SMP9() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x38000000) >> 27
}
func (o *ADC_Type) SetSMPR1_SMP8(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetSMPR1_SMP8() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetSMPR1_SMP7(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0xe00000)|value<<21)
}
func (o *ADC_Type) GetSMPR1_SMP7() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0xe00000) >> 21
}
func (o *ADC_Type) SetSMPR1_SMP6(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x1c0000)|value<<18)
}
func (o *ADC_Type) GetSMPR1_SMP6() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x1c0000) >> 18
}
func (o *ADC_Type) SetSMPR1_SMP5(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x38000)|value<<15)
}
func (o *ADC_Type) GetSMPR1_SMP5() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x38000) >> 15
}
func (o *ADC_Type) SetSMPR1_SMP4(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_Type) GetSMPR1_SMP4() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x7000) >> 12
}
func (o *ADC_Type) SetSMPR1_SMP3(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0xe00)|value<<9)
}
func (o *ADC_Type) GetSMPR1_SMP3() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0xe00) >> 9
}
func (o *ADC_Type) SetSMPR1_SMP2(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC_Type) GetSMPR1_SMP2() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x1c0) >> 6
}
func (o *ADC_Type) SetSMPR1_SMP1(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x38)|value<<3)
}
func (o *ADC_Type) GetSMPR1_SMP1() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x38) >> 3
}
func (o *ADC_Type) SetSMPR1_SMP0(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetSMPR1_SMP0() uint32 {
	return volatile.LoadUint32(&o.SMPR1.Reg) & 0x7
}

// ADC.SMPR2: ADC sampling time register 2
func (o *ADC_Type) SetSMPR2_SMP19(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC_Type) GetSMPR2_SMP19() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x38000000) >> 27
}
func (o *ADC_Type) SetSMPR2_SMP18(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetSMPR2_SMP18() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetSMPR2_SMP17(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0xe00000)|value<<21)
}
func (o *ADC_Type) GetSMPR2_SMP17() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0xe00000) >> 21
}
func (o *ADC_Type) SetSMPR2_SMP16(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x1c0000)|value<<18)
}
func (o *ADC_Type) GetSMPR2_SMP16() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x1c0000) >> 18
}
func (o *ADC_Type) SetSMPR2_SMP15(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x38000)|value<<15)
}
func (o *ADC_Type) GetSMPR2_SMP15() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x38000) >> 15
}
func (o *ADC_Type) SetSMPR2_SMP14(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_Type) GetSMPR2_SMP14() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x7000) >> 12
}
func (o *ADC_Type) SetSMPR2_SMP13(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0xe00)|value<<9)
}
func (o *ADC_Type) GetSMPR2_SMP13() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0xe00) >> 9
}
func (o *ADC_Type) SetSMPR2_SMP12(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC_Type) GetSMPR2_SMP12() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x1c0) >> 6
}
func (o *ADC_Type) SetSMPR2_SMP11(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x38)|value<<3)
}
func (o *ADC_Type) GetSMPR2_SMP11() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x38) >> 3
}
func (o *ADC_Type) SetSMPR2_SMP10(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetSMPR2_SMP10() uint32 {
	return volatile.LoadUint32(&o.SMPR2.Reg) & 0x7
}

// ADC.PCSEL: ADC pre channel selection register
func (o *ADC_Type) SetPCSEL(value uint32) {
	volatile.StoreUint32(&o.PCSEL.Reg, volatile.LoadUint32(&o.PCSEL.Reg)&^(0xfffff)|value)
}
func (o *ADC_Type) GetPCSEL() uint32 {
	return volatile.LoadUint32(&o.PCSEL.Reg) & 0xfffff
}

// ADC.LTR1: ADC analog watchdog 1 threshold register
func (o *ADC_Type) SetLTR1(value uint32) {
	volatile.StoreUint32(&o.LTR1.Reg, volatile.LoadUint32(&o.LTR1.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetLTR1() uint32 {
	return volatile.LoadUint32(&o.LTR1.Reg) & 0x3ffffff
}

// ADC.HTR1: ADC analog watchdog 2 threshold register
func (o *ADC_Type) SetHTR1(value uint32) {
	volatile.StoreUint32(&o.HTR1.Reg, volatile.LoadUint32(&o.HTR1.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetHTR1() uint32 {
	return volatile.LoadUint32(&o.HTR1.Reg) & 0x3ffffff
}

// ADC.SQR1: ADC group regular sequencer ranks register 1
func (o *ADC_Type) SetSQR1_SQ4(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetSQR1_SQ4() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x1f000000) >> 24
}
func (o *ADC_Type) SetSQR1_SQ3(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x7c0000)|value<<18)
}
func (o *ADC_Type) GetSQR1_SQ3() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x7c0000) >> 18
}
func (o *ADC_Type) SetSQR1_SQ2(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x1f000)|value<<12)
}
func (o *ADC_Type) GetSQR1_SQ2() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x1f000) >> 12
}
func (o *ADC_Type) SetSQR1_SQ1(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR1_SQ1() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR1_L(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetSQR1_L() uint32 {
	return volatile.LoadUint32(&o.SQR1.Reg) & 0xf
}

// ADC.SQR2: ADC group regular sequencer ranks register 2
func (o *ADC_Type) SetSQR2_SQ9(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetSQR2_SQ9() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x1f000000) >> 24
}
func (o *ADC_Type) SetSQR2_SQ8(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x7c0000)|value<<18)
}
func (o *ADC_Type) GetSQR2_SQ8() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x7c0000) >> 18
}
func (o *ADC_Type) SetSQR2_SQ7(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f000)|value<<12)
}
func (o *ADC_Type) GetSQR2_SQ7() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x1f000) >> 12
}
func (o *ADC_Type) SetSQR2_SQ6(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR2_SQ6() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR2_SQ5(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR2_SQ5() uint32 {
	return volatile.LoadUint32(&o.SQR2.Reg) & 0x1f
}

// ADC.SQR3: ADC group regular sequencer ranks register 3
func (o *ADC_Type) SetSQR3_SQ14(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetSQR3_SQ14() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x1f000000) >> 24
}
func (o *ADC_Type) SetSQR3_SQ13(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x7c0000)|value<<18)
}
func (o *ADC_Type) GetSQR3_SQ13() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x7c0000) >> 18
}
func (o *ADC_Type) SetSQR3_SQ12(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f000)|value<<12)
}
func (o *ADC_Type) GetSQR3_SQ12() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x1f000) >> 12
}
func (o *ADC_Type) SetSQR3_SQ11(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR3_SQ11() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR3_SQ10(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR3_SQ10() uint32 {
	return volatile.LoadUint32(&o.SQR3.Reg) & 0x1f
}

// ADC.SQR4: ADC group regular sequencer ranks register 4
func (o *ADC_Type) SetSQR4_SQ16(value uint32) {
	volatile.StoreUint32(&o.SQR4.Reg, volatile.LoadUint32(&o.SQR4.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR4_SQ16() uint32 {
	return (volatile.LoadUint32(&o.SQR4.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR4_SQ15(value uint32) {
	volatile.StoreUint32(&o.SQR4.Reg, volatile.LoadUint32(&o.SQR4.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR4_SQ15() uint32 {
	return volatile.LoadUint32(&o.SQR4.Reg) & 0x1f
}

// ADC.DR: ADC group regular conversion data register
func (o *ADC_Type) SetDR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetDR_RDATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// ADC.JSQR: ADC group injected sequencer register
func (o *ADC_Type) SetJSQR_JSQ4(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0xf8000000)|value<<27)
}
func (o *ADC_Type) GetJSQR_JSQ4() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0xf8000000) >> 27
}
func (o *ADC_Type) SetJSQR_JSQ3(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x3e00000)|value<<21)
}
func (o *ADC_Type) GetJSQR_JSQ3() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x3e00000) >> 21
}
func (o *ADC_Type) SetJSQR_JSQ2(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC_Type) GetJSQR_JSQ2() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0xf8000) >> 15
}
func (o *ADC_Type) SetJSQR_JSQ1(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x3e00)|value<<9)
}
func (o *ADC_Type) GetJSQR_JSQ1() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x3e00) >> 9
}
func (o *ADC_Type) SetJSQR_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x180)|value<<7)
}
func (o *ADC_Type) GetJSQR_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x180) >> 7
}
func (o *ADC_Type) SetJSQR_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x7c)|value<<2)
}
func (o *ADC_Type) GetJSQR_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x7c) >> 2
}
func (o *ADC_Type) SetJSQR_JL(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetJSQR_JL() uint32 {
	return volatile.LoadUint32(&o.JSQR.Reg) & 0x3
}

// ADC.OFR1: ADC offset number 1 register
func (o *ADC_Type) SetOFR1_SSATE(value uint32) {
	volatile.StoreUint32(&o.OFR1.Reg, volatile.LoadUint32(&o.OFR1.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR1_SSATE() uint32 {
	return (volatile.LoadUint32(&o.OFR1.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR1_OFFSET1_CH(value uint32) {
	volatile.StoreUint32(&o.OFR1.Reg, volatile.LoadUint32(&o.OFR1.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR1_OFFSET1_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR1.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR1_OFFSET1(value uint32) {
	volatile.StoreUint32(&o.OFR1.Reg, volatile.LoadUint32(&o.OFR1.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetOFR1_OFFSET1() uint32 {
	return volatile.LoadUint32(&o.OFR1.Reg) & 0x3ffffff
}

// ADC.OFR2: ADC offset number 2 register
func (o *ADC_Type) SetOFR2_SSATE(value uint32) {
	volatile.StoreUint32(&o.OFR2.Reg, volatile.LoadUint32(&o.OFR2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR2_SSATE() uint32 {
	return (volatile.LoadUint32(&o.OFR2.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR2_OFFSET2_CH(value uint32) {
	volatile.StoreUint32(&o.OFR2.Reg, volatile.LoadUint32(&o.OFR2.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR2_OFFSET2_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR2.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR2_OFFSET2(value uint32) {
	volatile.StoreUint32(&o.OFR2.Reg, volatile.LoadUint32(&o.OFR2.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetOFR2_OFFSET2() uint32 {
	return volatile.LoadUint32(&o.OFR2.Reg) & 0x3ffffff
}

// ADC.OFR3: ADC offset number 3 register
func (o *ADC_Type) SetOFR3_SSATE(value uint32) {
	volatile.StoreUint32(&o.OFR3.Reg, volatile.LoadUint32(&o.OFR3.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR3_SSATE() uint32 {
	return (volatile.LoadUint32(&o.OFR3.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR3_OFFSET3_CH(value uint32) {
	volatile.StoreUint32(&o.OFR3.Reg, volatile.LoadUint32(&o.OFR3.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR3_OFFSET3_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR3.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR3_OFFSET3(value uint32) {
	volatile.StoreUint32(&o.OFR3.Reg, volatile.LoadUint32(&o.OFR3.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetOFR3_OFFSET3() uint32 {
	return volatile.LoadUint32(&o.OFR3.Reg) & 0x3ffffff
}

// ADC.OFR4: ADC offset number 4 register
func (o *ADC_Type) SetOFR4_SSATE(value uint32) {
	volatile.StoreUint32(&o.OFR4.Reg, volatile.LoadUint32(&o.OFR4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR4_SSATE() uint32 {
	return (volatile.LoadUint32(&o.OFR4.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR4_OFFSET4_CH(value uint32) {
	volatile.StoreUint32(&o.OFR4.Reg, volatile.LoadUint32(&o.OFR4.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR4_OFFSET4_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR4.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR4_OFFSET4(value uint32) {
	volatile.StoreUint32(&o.OFR4.Reg, volatile.LoadUint32(&o.OFR4.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetOFR4_OFFSET4() uint32 {
	return volatile.LoadUint32(&o.OFR4.Reg) & 0x3ffffff
}

// ADC.JDR1: ADC group injected sequencer rank 1 register
func (o *ADC_Type) SetJDR1(value uint32) {
	volatile.StoreUint32(&o.JDR1.Reg, value)
}
func (o *ADC_Type) GetJDR1() uint32 {
	return volatile.LoadUint32(&o.JDR1.Reg)
}

// ADC.JDR2: ADC group injected sequencer rank 2 register
func (o *ADC_Type) SetJDR2(value uint32) {
	volatile.StoreUint32(&o.JDR2.Reg, value)
}
func (o *ADC_Type) GetJDR2() uint32 {
	return volatile.LoadUint32(&o.JDR2.Reg)
}

// ADC.JDR3: ADC group injected sequencer rank 3 register
func (o *ADC_Type) SetJDR3(value uint32) {
	volatile.StoreUint32(&o.JDR3.Reg, value)
}
func (o *ADC_Type) GetJDR3() uint32 {
	return volatile.LoadUint32(&o.JDR3.Reg)
}

// ADC.JDR4: ADC group injected sequencer rank 4 register
func (o *ADC_Type) SetJDR4(value uint32) {
	volatile.StoreUint32(&o.JDR4.Reg, value)
}
func (o *ADC_Type) GetJDR4() uint32 {
	return volatile.LoadUint32(&o.JDR4.Reg)
}

// ADC.AWD2CR: ADC analog watchdog 2 configuration register
func (o *ADC_Type) SetAWD2CR_AWD2CH0(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH0() uint32 {
	return volatile.LoadUint32(&o.AWD2CR.Reg) & 0x1
}
func (o *ADC_Type) SetAWD2CR_AWD2CH1(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH1() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetAWD2CR_AWD2CH2(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH2() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetAWD2CR_AWD2CH3(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH3() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetAWD2CR_AWD2CH4(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH4() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetAWD2CR_AWD2CH5(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH5() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetAWD2CR_AWD2CH6(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH6() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetAWD2CR_AWD2CH7(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH7() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetAWD2CR_AWD2CH8(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH8() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetAWD2CR_AWD2CH9(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH9() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetAWD2CR_AWD2CH10(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH10() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetAWD2CR_AWD2CH11(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH11() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetAWD2CR_AWD2CH12(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH12() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetAWD2CR_AWD2CH13(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH13() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetAWD2CR_AWD2CH14(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH14() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetAWD2CR_AWD2CH15(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH15() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetAWD2CR_AWD2CH16(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH16() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetAWD2CR_AWD2CH17(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH17() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x20000) >> 17
}
func (o *ADC_Type) SetAWD2CR_AWD2CH18(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH18() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetAWD2CR_AWD2CH19(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH19() uint32 {
	return (volatile.LoadUint32(&o.AWD2CR.Reg) & 0x80000) >> 19
}

// ADC.AWD3CR: ADC analog watchdog 3 configuration register
func (o *ADC_Type) SetAWD3CR_AWD3CH0(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH0() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetAWD3CR_AWD3CH1(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH1() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetAWD3CR_AWD3CH2(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH2() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetAWD3CR_AWD3CH3(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH3() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetAWD3CR_AWD3CH4(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH4() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetAWD3CR_AWD3CH5(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH5() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetAWD3CR_AWD3CH6(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH6() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetAWD3CR_AWD3CH7(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH7() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetAWD3CR_AWD3CH8(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH8() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetAWD3CR_AWD3CH9(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH9() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetAWD3CR_AWD3CH10(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH10() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetAWD3CR_AWD3CH11(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH11() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetAWD3CR_AWD3CH12(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH12() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetAWD3CR_AWD3CH13(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH13() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetAWD3CR_AWD3CH14(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH14() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetAWD3CR_AWD3CH15(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH15() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetAWD3CR_AWD3CH16(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH16() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x20000) >> 17
}
func (o *ADC_Type) SetAWD3CR_AWD3CH17(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH17() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetAWD3CR_AWD3CH18(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH18() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x80000) >> 19
}
func (o *ADC_Type) SetAWD3CR_AWD3CH19(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH19() uint32 {
	return (volatile.LoadUint32(&o.AWD3CR.Reg) & 0x100000) >> 20
}

// ADC.LTR2: ADC watchdog lower threshold register 2
func (o *ADC_Type) SetLTR2(value uint32) {
	volatile.StoreUint32(&o.LTR2.Reg, volatile.LoadUint32(&o.LTR2.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetLTR2() uint32 {
	return volatile.LoadUint32(&o.LTR2.Reg) & 0x3ffffff
}

// ADC.HTR2: ADC watchdog higher threshold register 2
func (o *ADC_Type) SetHTR2(value uint32) {
	volatile.StoreUint32(&o.HTR2.Reg, volatile.LoadUint32(&o.HTR2.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetHTR2() uint32 {
	return volatile.LoadUint32(&o.HTR2.Reg) & 0x3ffffff
}

// ADC.LTR3: ADC watchdog lower threshold register 3
func (o *ADC_Type) SetLTR3(value uint32) {
	volatile.StoreUint32(&o.LTR3.Reg, volatile.LoadUint32(&o.LTR3.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetLTR3() uint32 {
	return volatile.LoadUint32(&o.LTR3.Reg) & 0x3ffffff
}

// ADC.HTR3: ADC watchdog higher threshold register 3
func (o *ADC_Type) SetHTR3(value uint32) {
	volatile.StoreUint32(&o.HTR3.Reg, volatile.LoadUint32(&o.HTR3.Reg)&^(0x3ffffff)|value)
}
func (o *ADC_Type) GetHTR3() uint32 {
	return volatile.LoadUint32(&o.HTR3.Reg) & 0x3ffffff
}

// ADC.DIFSEL: ADC channel differential or single-ended mode selection register
func (o *ADC_Type) SetDIFSEL_DIFSEL0(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL0() uint32 {
	return volatile.LoadUint32(&o.DIFSEL.Reg) & 0x1
}
func (o *ADC_Type) SetDIFSEL_DIFSEL1(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL1() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetDIFSEL_DIFSEL2(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL2() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetDIFSEL_DIFSEL3(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL3() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetDIFSEL_DIFSEL4(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL4() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetDIFSEL_DIFSEL5(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL5() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetDIFSEL_DIFSEL6(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL6() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetDIFSEL_DIFSEL7(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL7() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetDIFSEL_DIFSEL8(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL8() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetDIFSEL_DIFSEL9(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL9() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetDIFSEL_DIFSEL10(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL10() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetDIFSEL_DIFSEL11(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL11() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetDIFSEL_DIFSEL12(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL12() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetDIFSEL_DIFSEL13(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL13() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetDIFSEL_DIFSEL14(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL14() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetDIFSEL_DIFSEL15(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL15() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetDIFSEL_DIFSEL16(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL16() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetDIFSEL_DIFSEL17(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL17() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x20000) >> 17
}
func (o *ADC_Type) SetDIFSEL_DIFSEL18(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL18() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetDIFSEL_DIFSEL19(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL19() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x80000) >> 19
}

// ADC.CALFACT: ADC calibration factors register
func (o *ADC_Type) SetCALFACT_CALFACT_D(value uint32) {
	volatile.StoreUint32(&o.CALFACT.Reg, volatile.LoadUint32(&o.CALFACT.Reg)&^(0x7ff0000)|value<<16)
}
func (o *ADC_Type) GetCALFACT_CALFACT_D() uint32 {
	return (volatile.LoadUint32(&o.CALFACT.Reg) & 0x7ff0000) >> 16
}
func (o *ADC_Type) SetCALFACT_CALFACT_S(value uint32) {
	volatile.StoreUint32(&o.CALFACT.Reg, volatile.LoadUint32(&o.CALFACT.Reg)&^(0x7ff)|value)
}
func (o *ADC_Type) GetCALFACT_CALFACT_S() uint32 {
	return volatile.LoadUint32(&o.CALFACT.Reg) & 0x7ff
}

// ADC.CALFACT2: ADC Calibration Factor register 2
func (o *ADC_Type) SetCALFACT2_LINCALFACT(value uint32) {
	volatile.StoreUint32(&o.CALFACT2.Reg, volatile.LoadUint32(&o.CALFACT2.Reg)&^(0x3fffffff)|value)
}
func (o *ADC_Type) GetCALFACT2_LINCALFACT() uint32 {
	return volatile.LoadUint32(&o.CALFACT2.Reg) & 0x3fffffff
}

// AXI interconnect registers
type AXI_Type struct {
	_                   [8144]byte
	PERIPH_ID_4         volatile.Register32 // 0x1FD0
	_                   [12]byte
	PERIPH_ID_0         volatile.Register32 // 0x1FE0
	PERIPH_ID_1         volatile.Register32 // 0x1FE4
	PERIPH_ID_2         volatile.Register32 // 0x1FE8
	PERIPH_ID_3         volatile.Register32 // 0x1FEC
	COMP_ID_0           volatile.Register32 // 0x1FF0
	COMP_ID_1           volatile.Register32 // 0x1FF4
	COMP_ID_2           volatile.Register32 // 0x1FF8
	COMP_ID_3           volatile.Register32 // 0x1FFC
	_                   [8]byte
	TARG1_FN_MOD_ISS_BM volatile.Register32 // 0x2008
	_                   [24]byte
	TARG1_FN_MOD2       volatile.Register32 // 0x2024
	_                   [4]byte
	TARG1_FN_MOD_LB     volatile.Register32 // 0x202C
	_                   [216]byte
	TARG1_FN_MOD        volatile.Register32 // 0x2108
	_                   [3836]byte
	TARG2_FN_MOD_ISS_BM volatile.Register32 // 0x3008
	_                   [24]byte
	TARG2_FN_MOD2       volatile.Register32 // 0x3024
	_                   [4]byte
	TARG2_FN_MOD_LB     volatile.Register32 // 0x302C
	_                   [216]byte
	TARG2_FN_MOD        volatile.Register32 // 0x3108
	_                   [3836]byte
	TARG3_FN_MOD_ISS_BM volatile.Register32 // 0x4008
	_                   [4092]byte
	TARG4_FN_MOD_ISS_BM volatile.Register32 // 0x5008
	_                   [4092]byte
	TARG5_FN_MOD_ISS_BM volatile.Register32 // 0x6008
	_                   [4092]byte
	TARG6_FN_MOD_ISS_BM volatile.Register32 // 0x7008
	_                   [4096]byte
	TARG7_FN_MOD_ISS_BM volatile.Register32 // 0x800C
	_                   [20]byte
	TARG7_FN_MOD2       volatile.Register32 // 0x8024
	_                   [224]byte
	TARG7_FN_MOD        volatile.Register32 // 0x8108
	_                   [237336]byte
	INI1_FN_MOD2        volatile.Register32 // 0x42024
	INI1_FN_MOD_AHB     volatile.Register32 // 0x42028
	_                   [212]byte
	INI1_READ_QOS       volatile.Register32 // 0x42100
	INI1_WRITE_QOS      volatile.Register32 // 0x42104
	INI1_FN_MOD         volatile.Register32 // 0x42108
	_                   [4084]byte
	INI2_READ_QOS       volatile.Register32 // 0x43100
	INI2_WRITE_QOS      volatile.Register32 // 0x43104
	INI2_FN_MOD         volatile.Register32 // 0x43108
	_                   [3864]byte
	INI3_FN_MOD2        volatile.Register32 // 0x44024
	INI3_FN_MOD_AHB     volatile.Register32 // 0x44028
	_                   [212]byte
	INI3_READ_QOS       volatile.Register32 // 0x44100
	INI3_WRITE_QOS      volatile.Register32 // 0x44104
	INI3_FN_MOD         volatile.Register32 // 0x44108
	_                   [4084]byte
	INI4_READ_QOS       volatile.Register32 // 0x45100
	INI4_WRITE_QOS      volatile.Register32 // 0x45104
	INI4_FN_MOD         volatile.Register32 // 0x45108
	_                   [4084]byte
	INI5_READ_QOS       volatile.Register32 // 0x46100
	INI5_WRITE_QOS      volatile.Register32 // 0x46104
	INI5_FN_MOD         volatile.Register32 // 0x46108
	_                   [4084]byte
	INI6_READ_QOS       volatile.Register32 // 0x47100
	INI6_WRITE_QOS      volatile.Register32 // 0x47104
	INI6_FN_MOD         volatile.Register32 // 0x47108
}

// AXI.PERIPH_ID_4: AXI interconnect - peripheral ID4 register
func (o *AXI_Type) SetPERIPH_ID_4_JEP106CON(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_4.Reg, volatile.LoadUint32(&o.PERIPH_ID_4.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetPERIPH_ID_4_JEP106CON() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID_4.Reg) & 0xf
}
func (o *AXI_Type) SetPERIPH_ID_4_KCOUNT4(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_4.Reg, volatile.LoadUint32(&o.PERIPH_ID_4.Reg)&^(0xf0)|value<<4)
}
func (o *AXI_Type) GetPERIPH_ID_4_KCOUNT4() uint32 {
	return (volatile.LoadUint32(&o.PERIPH_ID_4.Reg) & 0xf0) >> 4
}

// AXI.PERIPH_ID_0: AXI interconnect - peripheral ID0 register
func (o *AXI_Type) SetPERIPH_ID_0_PARTNUM(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_0.Reg, volatile.LoadUint32(&o.PERIPH_ID_0.Reg)&^(0xff)|value)
}
func (o *AXI_Type) GetPERIPH_ID_0_PARTNUM() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID_0.Reg) & 0xff
}

// AXI.PERIPH_ID_1: AXI interconnect - peripheral ID1 register
func (o *AXI_Type) SetPERIPH_ID_1_PARTNUM(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_1.Reg, volatile.LoadUint32(&o.PERIPH_ID_1.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetPERIPH_ID_1_PARTNUM() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID_1.Reg) & 0xf
}
func (o *AXI_Type) SetPERIPH_ID_1_JEP106I(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_1.Reg, volatile.LoadUint32(&o.PERIPH_ID_1.Reg)&^(0xf0)|value<<4)
}
func (o *AXI_Type) GetPERIPH_ID_1_JEP106I() uint32 {
	return (volatile.LoadUint32(&o.PERIPH_ID_1.Reg) & 0xf0) >> 4
}

// AXI.PERIPH_ID_2: AXI interconnect - peripheral ID2 register
func (o *AXI_Type) SetPERIPH_ID_2_JEP106ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_2.Reg, volatile.LoadUint32(&o.PERIPH_ID_2.Reg)&^(0x7)|value)
}
func (o *AXI_Type) GetPERIPH_ID_2_JEP106ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID_2.Reg) & 0x7
}
func (o *AXI_Type) SetPERIPH_ID_2_JEDEC(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_2.Reg, volatile.LoadUint32(&o.PERIPH_ID_2.Reg)&^(0x8)|value<<3)
}
func (o *AXI_Type) GetPERIPH_ID_2_JEDEC() uint32 {
	return (volatile.LoadUint32(&o.PERIPH_ID_2.Reg) & 0x8) >> 3
}
func (o *AXI_Type) SetPERIPH_ID_2_REVISION(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_2.Reg, volatile.LoadUint32(&o.PERIPH_ID_2.Reg)&^(0xf0)|value<<4)
}
func (o *AXI_Type) GetPERIPH_ID_2_REVISION() uint32 {
	return (volatile.LoadUint32(&o.PERIPH_ID_2.Reg) & 0xf0) >> 4
}

// AXI.PERIPH_ID_3: AXI interconnect - peripheral ID3 register
func (o *AXI_Type) SetPERIPH_ID_3_CUST_MOD_NUM(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_3.Reg, volatile.LoadUint32(&o.PERIPH_ID_3.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetPERIPH_ID_3_CUST_MOD_NUM() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID_3.Reg) & 0xf
}
func (o *AXI_Type) SetPERIPH_ID_3_REV_AND(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID_3.Reg, volatile.LoadUint32(&o.PERIPH_ID_3.Reg)&^(0xf0)|value<<4)
}
func (o *AXI_Type) GetPERIPH_ID_3_REV_AND() uint32 {
	return (volatile.LoadUint32(&o.PERIPH_ID_3.Reg) & 0xf0) >> 4
}

// AXI.COMP_ID_0: AXI interconnect - component ID0 register
func (o *AXI_Type) SetCOMP_ID_0_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.COMP_ID_0.Reg, volatile.LoadUint32(&o.COMP_ID_0.Reg)&^(0xff)|value)
}
func (o *AXI_Type) GetCOMP_ID_0_PREAMBLE() uint32 {
	return volatile.LoadUint32(&o.COMP_ID_0.Reg) & 0xff
}

// AXI.COMP_ID_1: AXI interconnect - component ID1 register
func (o *AXI_Type) SetCOMP_ID_1_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.COMP_ID_1.Reg, volatile.LoadUint32(&o.COMP_ID_1.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetCOMP_ID_1_PREAMBLE() uint32 {
	return volatile.LoadUint32(&o.COMP_ID_1.Reg) & 0xf
}
func (o *AXI_Type) SetCOMP_ID_1_CLASS(value uint32) {
	volatile.StoreUint32(&o.COMP_ID_1.Reg, volatile.LoadUint32(&o.COMP_ID_1.Reg)&^(0xf0)|value<<4)
}
func (o *AXI_Type) GetCOMP_ID_1_CLASS() uint32 {
	return (volatile.LoadUint32(&o.COMP_ID_1.Reg) & 0xf0) >> 4
}

// AXI.COMP_ID_2: AXI interconnect - component ID2 register
func (o *AXI_Type) SetCOMP_ID_2_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.COMP_ID_2.Reg, volatile.LoadUint32(&o.COMP_ID_2.Reg)&^(0xff)|value)
}
func (o *AXI_Type) GetCOMP_ID_2_PREAMBLE() uint32 {
	return volatile.LoadUint32(&o.COMP_ID_2.Reg) & 0xff
}

// AXI.COMP_ID_3: AXI interconnect - component ID3 register
func (o *AXI_Type) SetCOMP_ID_3_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.COMP_ID_3.Reg, volatile.LoadUint32(&o.COMP_ID_3.Reg)&^(0xff)|value)
}
func (o *AXI_Type) GetCOMP_ID_3_PREAMBLE() uint32 {
	return volatile.LoadUint32(&o.COMP_ID_3.Reg) & 0xff
}

// AXI.TARG1_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG1_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG1_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG1_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG1_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG1_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG1_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG1_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
func (o *AXI_Type) SetTARG1_FN_MOD2_BYPASS_MERGE(value uint32) {
	volatile.StoreUint32(&o.TARG1_FN_MOD2.Reg, volatile.LoadUint32(&o.TARG1_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG1_FN_MOD2_BYPASS_MERGE() uint32 {
	return volatile.LoadUint32(&o.TARG1_FN_MOD2.Reg) & 0x1
}

// AXI.TARG1_FN_MOD_LB: AXI interconnect - TARG x long burst functionality modification
func (o *AXI_Type) SetTARG1_FN_MOD_LB_FN_MOD_LB(value uint32) {
	volatile.StoreUint32(&o.TARG1_FN_MOD_LB.Reg, volatile.LoadUint32(&o.TARG1_FN_MOD_LB.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG1_FN_MOD_LB_FN_MOD_LB() uint32 {
	return volatile.LoadUint32(&o.TARG1_FN_MOD_LB.Reg) & 0x1
}

// AXI.TARG1_FN_MOD: AXI interconnect - TARG x long burst functionality modification
func (o *AXI_Type) SetTARG1_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG1_FN_MOD.Reg, volatile.LoadUint32(&o.TARG1_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG1_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG1_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetTARG1_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG1_FN_MOD.Reg, volatile.LoadUint32(&o.TARG1_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG1_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG1_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.TARG2_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG2_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG2_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG2_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG2_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG2_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG2_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG2_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
func (o *AXI_Type) SetTARG2_FN_MOD2_BYPASS_MERGE(value uint32) {
	volatile.StoreUint32(&o.TARG2_FN_MOD2.Reg, volatile.LoadUint32(&o.TARG2_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG2_FN_MOD2_BYPASS_MERGE() uint32 {
	return volatile.LoadUint32(&o.TARG2_FN_MOD2.Reg) & 0x1
}

// AXI.TARG2_FN_MOD_LB: AXI interconnect - TARG x long burst functionality modification
func (o *AXI_Type) SetTARG2_FN_MOD_LB_FN_MOD_LB(value uint32) {
	volatile.StoreUint32(&o.TARG2_FN_MOD_LB.Reg, volatile.LoadUint32(&o.TARG2_FN_MOD_LB.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG2_FN_MOD_LB_FN_MOD_LB() uint32 {
	return volatile.LoadUint32(&o.TARG2_FN_MOD_LB.Reg) & 0x1
}

// AXI.TARG2_FN_MOD: AXI interconnect - TARG x long burst functionality modification
func (o *AXI_Type) SetTARG2_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG2_FN_MOD.Reg, volatile.LoadUint32(&o.TARG2_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG2_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG2_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetTARG2_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG2_FN_MOD.Reg, volatile.LoadUint32(&o.TARG2_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG2_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG2_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.TARG3_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG3_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG3_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG3_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG3_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG3_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG3_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG4_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG4_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG4_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG4_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG4_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG4_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG4_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG5_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG5_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG5_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG5_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG5_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG5_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG5_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG6_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG6_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG6_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG6_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG6_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG6_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG6_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG7_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
func (o *AXI_Type) SetTARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG7_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG7_FN_MOD_ISS_BM.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG7_FN_MOD_ISS_BM.Reg) & 0x1
}
func (o *AXI_Type) SetTARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG7_FN_MOD_ISS_BM.Reg, volatile.LoadUint32(&o.TARG7_FN_MOD_ISS_BM.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG7_FN_MOD_ISS_BM.Reg) & 0x2) >> 1
}

// AXI.TARG7_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
func (o *AXI_Type) SetTARG7_FN_MOD2_BYPASS_MERGE(value uint32) {
	volatile.StoreUint32(&o.TARG7_FN_MOD2.Reg, volatile.LoadUint32(&o.TARG7_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG7_FN_MOD2_BYPASS_MERGE() uint32 {
	return volatile.LoadUint32(&o.TARG7_FN_MOD2.Reg) & 0x1
}

// AXI.TARG7_FN_MOD: AXI interconnect - TARG x long burst functionality modification
func (o *AXI_Type) SetTARG7_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG7_FN_MOD.Reg, volatile.LoadUint32(&o.TARG7_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetTARG7_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TARG7_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetTARG7_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TARG7_FN_MOD.Reg, volatile.LoadUint32(&o.TARG7_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetTARG7_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TARG7_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.INI1_FN_MOD2: AXI interconnect - INI x functionality modification 2 register
func (o *AXI_Type) SetINI1_FN_MOD2_BYPASS_MERGE(value uint32) {
	volatile.StoreUint32(&o.INI1_FN_MOD2.Reg, volatile.LoadUint32(&o.INI1_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI1_FN_MOD2_BYPASS_MERGE() uint32 {
	return volatile.LoadUint32(&o.INI1_FN_MOD2.Reg) & 0x1
}

// AXI.INI1_FN_MOD_AHB: AXI interconnect - INI x AHB functionality modification register
func (o *AXI_Type) SetINI1_FN_MOD_AHB_RD_INC_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.INI1_FN_MOD_AHB.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI1_FN_MOD_AHB_RD_INC_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI1_FN_MOD_AHB.Reg) & 0x1
}
func (o *AXI_Type) SetINI1_FN_MOD_AHB_WR_INC_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.INI1_FN_MOD_AHB.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI1_FN_MOD_AHB_WR_INC_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI1_FN_MOD_AHB.Reg) & 0x2) >> 1
}

// AXI.INI1_READ_QOS: AXI interconnect - INI x read QoS register
func (o *AXI_Type) SetINI1_READ_QOS_AR_QOS(value uint32) {
	volatile.StoreUint32(&o.INI1_READ_QOS.Reg, volatile.LoadUint32(&o.INI1_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI1_READ_QOS_AR_QOS() uint32 {
	return volatile.LoadUint32(&o.INI1_READ_QOS.Reg) & 0xf
}

// AXI.INI1_WRITE_QOS: AXI interconnect - INI x write QoS register
func (o *AXI_Type) SetINI1_WRITE_QOS_AW_QOS(value uint32) {
	volatile.StoreUint32(&o.INI1_WRITE_QOS.Reg, volatile.LoadUint32(&o.INI1_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI1_WRITE_QOS_AW_QOS() uint32 {
	return volatile.LoadUint32(&o.INI1_WRITE_QOS.Reg) & 0xf
}

// AXI.INI1_FN_MOD: AXI interconnect - INI x issuing functionality modification register
func (o *AXI_Type) SetINI1_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI1_FN_MOD.Reg, volatile.LoadUint32(&o.INI1_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI1_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI1_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetINI1_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI1_FN_MOD.Reg, volatile.LoadUint32(&o.INI1_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI1_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI1_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.INI2_READ_QOS: AXI interconnect - INI x read QoS register
func (o *AXI_Type) SetINI2_READ_QOS_AR_QOS(value uint32) {
	volatile.StoreUint32(&o.INI2_READ_QOS.Reg, volatile.LoadUint32(&o.INI2_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI2_READ_QOS_AR_QOS() uint32 {
	return volatile.LoadUint32(&o.INI2_READ_QOS.Reg) & 0xf
}

// AXI.INI2_WRITE_QOS: AXI interconnect - INI x write QoS register
func (o *AXI_Type) SetINI2_WRITE_QOS_AW_QOS(value uint32) {
	volatile.StoreUint32(&o.INI2_WRITE_QOS.Reg, volatile.LoadUint32(&o.INI2_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI2_WRITE_QOS_AW_QOS() uint32 {
	return volatile.LoadUint32(&o.INI2_WRITE_QOS.Reg) & 0xf
}

// AXI.INI2_FN_MOD: AXI interconnect - INI x issuing functionality modification register
func (o *AXI_Type) SetINI2_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI2_FN_MOD.Reg, volatile.LoadUint32(&o.INI2_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI2_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI2_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetINI2_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI2_FN_MOD.Reg, volatile.LoadUint32(&o.INI2_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI2_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI2_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.INI3_FN_MOD2: AXI interconnect - INI x functionality modification 2 register
func (o *AXI_Type) SetINI3_FN_MOD2_BYPASS_MERGE(value uint32) {
	volatile.StoreUint32(&o.INI3_FN_MOD2.Reg, volatile.LoadUint32(&o.INI3_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI3_FN_MOD2_BYPASS_MERGE() uint32 {
	return volatile.LoadUint32(&o.INI3_FN_MOD2.Reg) & 0x1
}

// AXI.INI3_FN_MOD_AHB: AXI interconnect - INI x AHB functionality modification register
func (o *AXI_Type) SetINI3_FN_MOD_AHB_RD_INC_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI3_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.INI3_FN_MOD_AHB.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI3_FN_MOD_AHB_RD_INC_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI3_FN_MOD_AHB.Reg) & 0x1
}
func (o *AXI_Type) SetINI3_FN_MOD_AHB_WR_INC_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI3_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.INI3_FN_MOD_AHB.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI3_FN_MOD_AHB_WR_INC_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI3_FN_MOD_AHB.Reg) & 0x2) >> 1
}

// AXI.INI3_READ_QOS: AXI interconnect - INI x read QoS register
func (o *AXI_Type) SetINI3_READ_QOS_AR_QOS(value uint32) {
	volatile.StoreUint32(&o.INI3_READ_QOS.Reg, volatile.LoadUint32(&o.INI3_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI3_READ_QOS_AR_QOS() uint32 {
	return volatile.LoadUint32(&o.INI3_READ_QOS.Reg) & 0xf
}

// AXI.INI3_WRITE_QOS: AXI interconnect - INI x write QoS register
func (o *AXI_Type) SetINI3_WRITE_QOS_AW_QOS(value uint32) {
	volatile.StoreUint32(&o.INI3_WRITE_QOS.Reg, volatile.LoadUint32(&o.INI3_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI3_WRITE_QOS_AW_QOS() uint32 {
	return volatile.LoadUint32(&o.INI3_WRITE_QOS.Reg) & 0xf
}

// AXI.INI3_FN_MOD: AXI interconnect - INI x issuing functionality modification register
func (o *AXI_Type) SetINI3_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI3_FN_MOD.Reg, volatile.LoadUint32(&o.INI3_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI3_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI3_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetINI3_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI3_FN_MOD.Reg, volatile.LoadUint32(&o.INI3_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI3_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI3_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.INI4_READ_QOS: AXI interconnect - INI x read QoS register
func (o *AXI_Type) SetINI4_READ_QOS_AR_QOS(value uint32) {
	volatile.StoreUint32(&o.INI4_READ_QOS.Reg, volatile.LoadUint32(&o.INI4_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI4_READ_QOS_AR_QOS() uint32 {
	return volatile.LoadUint32(&o.INI4_READ_QOS.Reg) & 0xf
}

// AXI.INI4_WRITE_QOS: AXI interconnect - INI x write QoS register
func (o *AXI_Type) SetINI4_WRITE_QOS_AW_QOS(value uint32) {
	volatile.StoreUint32(&o.INI4_WRITE_QOS.Reg, volatile.LoadUint32(&o.INI4_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI4_WRITE_QOS_AW_QOS() uint32 {
	return volatile.LoadUint32(&o.INI4_WRITE_QOS.Reg) & 0xf
}

// AXI.INI4_FN_MOD: AXI interconnect - INI x issuing functionality modification register
func (o *AXI_Type) SetINI4_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI4_FN_MOD.Reg, volatile.LoadUint32(&o.INI4_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI4_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI4_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetINI4_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI4_FN_MOD.Reg, volatile.LoadUint32(&o.INI4_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI4_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI4_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.INI5_READ_QOS: AXI interconnect - INI x read QoS register
func (o *AXI_Type) SetINI5_READ_QOS_AR_QOS(value uint32) {
	volatile.StoreUint32(&o.INI5_READ_QOS.Reg, volatile.LoadUint32(&o.INI5_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI5_READ_QOS_AR_QOS() uint32 {
	return volatile.LoadUint32(&o.INI5_READ_QOS.Reg) & 0xf
}

// AXI.INI5_WRITE_QOS: AXI interconnect - INI x write QoS register
func (o *AXI_Type) SetINI5_WRITE_QOS_AW_QOS(value uint32) {
	volatile.StoreUint32(&o.INI5_WRITE_QOS.Reg, volatile.LoadUint32(&o.INI5_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI5_WRITE_QOS_AW_QOS() uint32 {
	return volatile.LoadUint32(&o.INI5_WRITE_QOS.Reg) & 0xf
}

// AXI.INI5_FN_MOD: AXI interconnect - INI x issuing functionality modification register
func (o *AXI_Type) SetINI5_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI5_FN_MOD.Reg, volatile.LoadUint32(&o.INI5_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI5_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI5_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetINI5_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI5_FN_MOD.Reg, volatile.LoadUint32(&o.INI5_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI5_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI5_FN_MOD.Reg) & 0x2) >> 1
}

// AXI.INI6_READ_QOS: AXI interconnect - INI x read QoS register
func (o *AXI_Type) SetINI6_READ_QOS_AR_QOS(value uint32) {
	volatile.StoreUint32(&o.INI6_READ_QOS.Reg, volatile.LoadUint32(&o.INI6_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI6_READ_QOS_AR_QOS() uint32 {
	return volatile.LoadUint32(&o.INI6_READ_QOS.Reg) & 0xf
}

// AXI.INI6_WRITE_QOS: AXI interconnect - INI x write QoS register
func (o *AXI_Type) SetINI6_WRITE_QOS_AW_QOS(value uint32) {
	volatile.StoreUint32(&o.INI6_WRITE_QOS.Reg, volatile.LoadUint32(&o.INI6_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXI_Type) GetINI6_WRITE_QOS_AW_QOS() uint32 {
	return volatile.LoadUint32(&o.INI6_WRITE_QOS.Reg) & 0xf
}

// AXI.INI6_FN_MOD: AXI interconnect - INI x issuing functionality modification register
func (o *AXI_Type) SetINI6_FN_MOD_READ_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI6_FN_MOD.Reg, volatile.LoadUint32(&o.INI6_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXI_Type) GetINI6_FN_MOD_READ_ISS_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.INI6_FN_MOD.Reg) & 0x1
}
func (o *AXI_Type) SetINI6_FN_MOD_WRITE_ISS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.INI6_FN_MOD.Reg, volatile.LoadUint32(&o.INI6_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXI_Type) GetINI6_FN_MOD_WRITE_ISS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.INI6_FN_MOD.Reg) & 0x2) >> 1
}

// CCU registers
type FDCAN_Type struct {
	CREL  volatile.Register32 // 0x0
	CCFG  volatile.Register32 // 0x4
	CSTAT volatile.Register32 // 0x8
	CWD   volatile.Register32 // 0xC
	IR    volatile.Register32 // 0x10
	IE    volatile.Register32 // 0x14
}

// FDCAN.CREL: Clock Calibration Unit Core Release Register
func (o *FDCAN_Type) SetCREL_DAY(value uint32) {
	volatile.StoreUint32(&o.CREL.Reg, volatile.LoadUint32(&o.CREL.Reg)&^(0xff)|value)
}
func (o *FDCAN_Type) GetCREL_DAY() uint32 {
	return volatile.LoadUint32(&o.CREL.Reg) & 0xff
}
func (o *FDCAN_Type) SetCREL_MON(value uint32) {
	volatile.StoreUint32(&o.CREL.Reg, volatile.LoadUint32(&o.CREL.Reg)&^(0xff00)|value<<8)
}
func (o *FDCAN_Type) GetCREL_MON() uint32 {
	return (volatile.LoadUint32(&o.CREL.Reg) & 0xff00) >> 8
}
func (o *FDCAN_Type) SetCREL_YEAR(value uint32) {
	volatile.StoreUint32(&o.CREL.Reg, volatile.LoadUint32(&o.CREL.Reg)&^(0xf0000)|value<<16)
}
func (o *FDCAN_Type) GetCREL_YEAR() uint32 {
	return (volatile.LoadUint32(&o.CREL.Reg) & 0xf0000) >> 16
}
func (o *FDCAN_Type) SetCREL_SUBSTEP(value uint32) {
	volatile.StoreUint32(&o.CREL.Reg, volatile.LoadUint32(&o.CREL.Reg)&^(0xf00000)|value<<20)
}
func (o *FDCAN_Type) GetCREL_SUBSTEP() uint32 {
	return (volatile.LoadUint32(&o.CREL.Reg) & 0xf00000) >> 20
}
func (o *FDCAN_Type) SetCREL_STEP(value uint32) {
	volatile.StoreUint32(&o.CREL.Reg, volatile.LoadUint32(&o.CREL.Reg)&^(0xf000000)|value<<24)
}
func (o *FDCAN_Type) GetCREL_STEP() uint32 {
	return (volatile.LoadUint32(&o.CREL.Reg) & 0xf000000) >> 24
}
func (o *FDCAN_Type) SetCREL_REL(value uint32) {
	volatile.StoreUint32(&o.CREL.Reg, volatile.LoadUint32(&o.CREL.Reg)&^(0xf0000000)|value<<28)
}
func (o *FDCAN_Type) GetCREL_REL() uint32 {
	return (volatile.LoadUint32(&o.CREL.Reg) & 0xf0000000) >> 28
}

// FDCAN.CCFG: Calibration Configuration Register
func (o *FDCAN_Type) SetCCFG_TQBT(value uint32) {
	volatile.StoreUint32(&o.CCFG.Reg, volatile.LoadUint32(&o.CCFG.Reg)&^(0x1f)|value)
}
func (o *FDCAN_Type) GetCCFG_TQBT() uint32 {
	return volatile.LoadUint32(&o.CCFG.Reg) & 0x1f
}
func (o *FDCAN_Type) SetCCFG_BCC(value uint32) {
	volatile.StoreUint32(&o.CCFG.Reg, volatile.LoadUint32(&o.CCFG.Reg)&^(0x40)|value<<6)
}
func (o *FDCAN_Type) GetCCFG_BCC() uint32 {
	return (volatile.LoadUint32(&o.CCFG.Reg) & 0x40) >> 6
}
func (o *FDCAN_Type) SetCCFG_CFL(value uint32) {
	volatile.StoreUint32(&o.CCFG.Reg, volatile.LoadUint32(&o.CCFG.Reg)&^(0x80)|value<<7)
}
func (o *FDCAN_Type) GetCCFG_CFL() uint32 {
	return (volatile.LoadUint32(&o.CCFG.Reg) & 0x80) >> 7
}
func (o *FDCAN_Type) SetCCFG_OCPM(value uint32) {
	volatile.StoreUint32(&o.CCFG.Reg, volatile.LoadUint32(&o.CCFG.Reg)&^(0xff00)|value<<8)
}
func (o *FDCAN_Type) GetCCFG_OCPM() uint32 {
	return (volatile.LoadUint32(&o.CCFG.Reg) & 0xff00) >> 8
}
func (o *FDCAN_Type) SetCCFG_CDIV(value uint32) {
	volatile.StoreUint32(&o.CCFG.Reg, volatile.LoadUint32(&o.CCFG.Reg)&^(0xf0000)|value<<16)
}
func (o *FDCAN_Type) GetCCFG_CDIV() uint32 {
	return (volatile.LoadUint32(&o.CCFG.Reg) & 0xf0000) >> 16
}
func (o *FDCAN_Type) SetCCFG_SWR(value uint32) {
	volatile.StoreUint32(&o.CCFG.Reg, volatile.LoadUint32(&o.CCFG.Reg)&^(0x80000000)|value<<31)
}
func (o *FDCAN_Type) GetCCFG_SWR() uint32 {
	return (volatile.LoadUint32(&o.CCFG.Reg) & 0x80000000) >> 31
}

// FDCAN.CSTAT: Calibration Status Register
func (o *FDCAN_Type) SetCSTAT_OCPC(value uint32) {
	volatile.StoreUint32(&o.CSTAT.Reg, volatile.LoadUint32(&o.CSTAT.Reg)&^(0x3ffff)|value)
}
func (o *FDCAN_Type) GetCSTAT_OCPC() uint32 {
	return volatile.LoadUint32(&o.CSTAT.Reg) & 0x3ffff
}
func (o *FDCAN_Type) SetCSTAT_TQC(value uint32) {
	volatile.StoreUint32(&o.CSTAT.Reg, volatile.LoadUint32(&o.CSTAT.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *FDCAN_Type) GetCSTAT_TQC() uint32 {
	return (volatile.LoadUint32(&o.CSTAT.Reg) & 0x1ffc0000) >> 18
}
func (o *FDCAN_Type) SetCSTAT_CALS(value uint32) {
	volatile.StoreUint32(&o.CSTAT.Reg, volatile.LoadUint32(&o.CSTAT.Reg)&^(0xc0000000)|value<<30)
}
func (o *FDCAN_Type) GetCSTAT_CALS() uint32 {
	return (volatile.LoadUint32(&o.CSTAT.Reg) & 0xc0000000) >> 30
}

// FDCAN.CWD: Calibration Watchdog Register
func (o *FDCAN_Type) SetCWD_WDC(value uint32) {
	volatile.StoreUint32(&o.CWD.Reg, volatile.LoadUint32(&o.CWD.Reg)&^(0xffff)|value)
}
func (o *FDCAN_Type) GetCWD_WDC() uint32 {
	return volatile.LoadUint32(&o.CWD.Reg) & 0xffff
}
func (o *FDCAN_Type) SetCWD_WDV(value uint32) {
	volatile.StoreUint32(&o.CWD.Reg, volatile.LoadUint32(&o.CWD.Reg)&^(0xffff0000)|value<<16)
}
func (o *FDCAN_Type) GetCWD_WDV() uint32 {
	return (volatile.LoadUint32(&o.CWD.Reg) & 0xffff0000) >> 16
}

// FDCAN.IR: Clock Calibration Unit Interrupt Register
func (o *FDCAN_Type) SetIR_CWE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *FDCAN_Type) GetIR_CWE() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *FDCAN_Type) SetIR_CSC(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *FDCAN_Type) GetIR_CSC() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}

// FDCAN.IE: Clock Calibration Unit Interrupt Enable Register
func (o *FDCAN_Type) SetIE_CWEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1)|value)
}
func (o *FDCAN_Type) GetIE_CWEE() uint32 {
	return volatile.LoadUint32(&o.IE.Reg) & 0x1
}
func (o *FDCAN_Type) SetIE_CSCE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2)|value<<1)
}
func (o *FDCAN_Type) GetIE_CSCE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2) >> 1
}

// CEC
type CEC_Type struct {
	CR   volatile.Register32 // 0x0
	CFGR volatile.Register32 // 0x4
	TXDR volatile.Register32 // 0x8
	RXDR volatile.Register32 // 0xC
	ISR  volatile.Register32 // 0x10
	IER  volatile.Register32 // 0x14
}

// CEC.CR: CEC control register
func (o *CEC_Type) SetCR_CECEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetCR_CECEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *CEC_Type) SetCR_TXSOM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetCR_TXSOM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetCR_TXEOM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetCR_TXEOM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}

// CEC.CFGR: This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
func (o *CEC_Type) SetCFGR_SFT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7)|value)
}
func (o *CEC_Type) GetCFGR_SFT() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x7
}
func (o *CEC_Type) SetCFGR_RXTOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetCFGR_RXTOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetCFGR_BRESTP(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetCFGR_BRESTP() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetCFGR_BREGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetCFGR_BREGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetCFGR_LBPEGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetCFGR_LBPEGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetCFGR_BRDNOGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetCFGR_BRDNOGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetCFGR_SFTOPT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetCFGR_SFTOPT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetCFGR_OAR(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7fff0000)|value<<16)
}
func (o *CEC_Type) GetCFGR_OAR() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7fff0000) >> 16
}
func (o *CEC_Type) SetCFGR_LSTN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *CEC_Type) GetCFGR_LSTN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}

// CEC.TXDR: CEC Tx data register
func (o *CEC_Type) SetTXDR_TXD(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *CEC_Type) GetTXDR_TXD() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// CEC.RXDR: CEC Rx Data Register
func (o *CEC_Type) SetRXDR_RXD(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *CEC_Type) GetRXDR_RXD() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// CEC.ISR: CEC Interrupt and Status Register
func (o *CEC_Type) SetISR_RXBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetISR_RXBR() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *CEC_Type) SetISR_RXEND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetISR_RXEND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetISR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetISR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetISR_BRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetISR_BRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetISR_SBPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetISR_SBPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetISR_LBPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetISR_LBPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetISR_RXACKE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetISR_RXACKE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetISR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetISR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetISR_TXBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetISR_TXBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetISR_TXEND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *CEC_Type) GetISR_TXEND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *CEC_Type) SetISR_TXUDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *CEC_Type) GetISR_TXUDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *CEC_Type) SetISR_TXERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *CEC_Type) GetISR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *CEC_Type) SetISR_TXACKE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *CEC_Type) GetISR_TXACKE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}

// CEC.IER: CEC interrupt enable register
func (o *CEC_Type) SetIER_RXBRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetIER_RXBRIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *CEC_Type) SetIER_RXENDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetIER_RXENDIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetIER_RXOVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetIER_RXOVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetIER_BREIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetIER_BREIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetIER_SBPEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetIER_SBPEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetIER_LBPEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetIER_LBPEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetIER_RXACKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetIER_RXACKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetIER_ARBLSTIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetIER_ARBLSTIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetIER_TXBRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetIER_TXBRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetIER_TXENDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *CEC_Type) GetIER_TXENDIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *CEC_Type) SetIER_TXUDRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *CEC_Type) GetIER_TXUDRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *CEC_Type) SetIER_TXERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *CEC_Type) GetIER_TXERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *CEC_Type) SetIER_TXACKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *CEC_Type) GetIER_TXACKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}

// COMP1
type COMP1_Type struct {
	SR    volatile.Register32 // 0x0
	ICFR  volatile.Register32 // 0x4
	OR    volatile.Register32 // 0x8
	CFGR1 volatile.Register32 // 0xC
	CFGR2 volatile.Register32 // 0x10
}

// COMP1.SR: Comparator status register
func (o *COMP1_Type) SetSR_C1VAL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *COMP1_Type) GetSR_C1VAL() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *COMP1_Type) SetSR_C2VAL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *COMP1_Type) GetSR_C2VAL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *COMP1_Type) SetSR_C1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *COMP1_Type) GetSR_C1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *COMP1_Type) SetSR_C2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *COMP1_Type) GetSR_C2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// COMP1.ICFR: Comparator interrupt clear flag register
func (o *COMP1_Type) SetICFR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.ICFR.Reg, volatile.LoadUint32(&o.ICFR.Reg)&^(0x10000)|value<<16)
}
func (o *COMP1_Type) GetICFR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.ICFR.Reg) & 0x10000) >> 16
}
func (o *COMP1_Type) SetICFR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.ICFR.Reg, volatile.LoadUint32(&o.ICFR.Reg)&^(0x20000)|value<<17)
}
func (o *COMP1_Type) GetICFR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.ICFR.Reg) & 0x20000) >> 17
}

// COMP1.OR: Comparator option register
func (o *COMP1_Type) SetOR_AFOP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x7ff)|value)
}
func (o *COMP1_Type) GetOR_AFOP() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x7ff
}
func (o *COMP1_Type) SetOR(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0xfffff800)|value<<11)
}
func (o *COMP1_Type) GetOR() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0xfffff800) >> 11
}

// COMP1.CFGR1: Comparator configuration register 1
func (o *COMP1_Type) SetCFGR1_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *COMP1_Type) GetCFGR1_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}
func (o *COMP1_Type) SetCFGR1_BRGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2)|value<<1)
}
func (o *COMP1_Type) GetCFGR1_BRGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2) >> 1
}
func (o *COMP1_Type) SetCFGR1_SCALEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4)|value<<2)
}
func (o *COMP1_Type) GetCFGR1_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4) >> 2
}
func (o *COMP1_Type) SetCFGR1_POLARITY(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x8)|value<<3)
}
func (o *COMP1_Type) GetCFGR1_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x8) >> 3
}
func (o *COMP1_Type) SetCFGR1_ITEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *COMP1_Type) GetCFGR1_ITEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x40) >> 6
}
func (o *COMP1_Type) SetCFGR1_HYST(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x300)|value<<8)
}
func (o *COMP1_Type) GetCFGR1_HYST() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x300) >> 8
}
func (o *COMP1_Type) SetCFGR1_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *COMP1_Type) GetCFGR1_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x3000) >> 12
}
func (o *COMP1_Type) SetCFGR1_INMSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x70000)|value<<16)
}
func (o *COMP1_Type) GetCFGR1_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x70000) >> 16
}
func (o *COMP1_Type) SetCFGR1_INPSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100000)|value<<20)
}
func (o *COMP1_Type) GetCFGR1_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100000) >> 20
}
func (o *COMP1_Type) SetCFGR1_BLANKING(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xf000000)|value<<24)
}
func (o *COMP1_Type) GetCFGR1_BLANKING() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xf000000) >> 24
}
func (o *COMP1_Type) SetCFGR1_LOCK(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP1_Type) GetCFGR1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x80000000) >> 31
}

// COMP1.CFGR2: Comparator configuration register 2
func (o *COMP1_Type) SetCFGR2_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *COMP1_Type) GetCFGR2_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}
func (o *COMP1_Type) SetCFGR2_BRGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *COMP1_Type) GetCFGR2_BRGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *COMP1_Type) SetCFGR2_SCALEN(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4)|value<<2)
}
func (o *COMP1_Type) GetCFGR2_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4) >> 2
}
func (o *COMP1_Type) SetCFGR2_POLARITY(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x8)|value<<3)
}
func (o *COMP1_Type) GetCFGR2_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x8) >> 3
}
func (o *COMP1_Type) SetCFGR2_WINMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x10)|value<<4)
}
func (o *COMP1_Type) GetCFGR2_WINMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x10) >> 4
}
func (o *COMP1_Type) SetCFGR2_ITEN(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x40)|value<<6)
}
func (o *COMP1_Type) GetCFGR2_ITEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x40) >> 6
}
func (o *COMP1_Type) SetCFGR2_HYST(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x300)|value<<8)
}
func (o *COMP1_Type) GetCFGR2_HYST() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x300) >> 8
}
func (o *COMP1_Type) SetCFGR2_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x3000)|value<<12)
}
func (o *COMP1_Type) GetCFGR2_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x3000) >> 12
}
func (o *COMP1_Type) SetCFGR2_INMSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x70000)|value<<16)
}
func (o *COMP1_Type) GetCFGR2_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x70000) >> 16
}
func (o *COMP1_Type) SetCFGR2_INPSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x100000)|value<<20)
}
func (o *COMP1_Type) GetCFGR2_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x100000) >> 20
}
func (o *COMP1_Type) SetCFGR2_BLANKING(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xf000000)|value<<24)
}
func (o *COMP1_Type) GetCFGR2_BLANKING() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xf000000) >> 24
}
func (o *COMP1_Type) SetCFGR2_LOCK(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP1_Type) GetCFGR2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x80000000) >> 31
}

// Cryptographic processor
type CRC_Type struct {
	DR   volatile.Register32 // 0x0
	IDR  volatile.Register32 // 0x4
	CR   volatile.Register32 // 0x8
	_    [4]byte
	INIT volatile.Register32 // 0x10
	POL  volatile.Register32 // 0x14
}

// CRC.DR: Data register
func (o *CRC_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *CRC_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// CRC.IDR: Independent Data register
func (o *CRC_Type) SetIDR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, value)
}
func (o *CRC_Type) GetIDR() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg)
}

// CRC.CR: Control register
func (o *CRC_Type) SetCR_RESET(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRC_Type) GetCR_RESET() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *CRC_Type) SetCR_POLYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *CRC_Type) GetCR_POLYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *CRC_Type) SetCR_REV_IN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *CRC_Type) GetCR_REV_IN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *CRC_Type) SetCR_REV_OUT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCR_REV_OUT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// CRC.INIT: Initial CRC value
func (o *CRC_Type) SetINIT(value uint32) {
	volatile.StoreUint32(&o.INIT.Reg, value)
}
func (o *CRC_Type) GetINIT() uint32 {
	return volatile.LoadUint32(&o.INIT.Reg)
}

// CRC.POL: CRC polynomial
func (o *CRC_Type) SetPOL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, value)
}
func (o *CRC_Type) GetPOL() uint32 {
	return volatile.LoadUint32(&o.POL.Reg)
}

// Clock Recovery System
type CRS_Type struct {
	CR   volatile.Register32 // 0x0
	CFGR volatile.Register32 // 0x4
	ISR  volatile.Register32 // 0x8
	ICR  volatile.Register32 // 0xC
}

// CRS.CR: CRS control register
func (o *CRS_Type) SetCR_SYNCOKIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRS_Type) GetCR_SYNCOKIE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *CRS_Type) SetCR_SYNCWARNIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *CRS_Type) GetCR_SYNCWARNIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *CRS_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *CRS_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *CRS_Type) SetCR_ESYNCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *CRS_Type) GetCR_ESYNCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *CRS_Type) SetCR_CEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *CRS_Type) GetCR_CEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *CRS_Type) SetCR_AUTOTRIMEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *CRS_Type) GetCR_AUTOTRIMEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *CRS_Type) SetCR_SWSYNC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRS_Type) GetCR_SWSYNC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *CRS_Type) SetCR_TRIM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f00)|value<<8)
}
func (o *CRS_Type) GetCR_TRIM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3f00) >> 8
}

// CRS.CFGR: This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
func (o *CRS_Type) SetCFGR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xffff)|value)
}
func (o *CRS_Type) GetCFGR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0xffff
}
func (o *CRS_Type) SetCFGR_FELIM(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *CRS_Type) GetCFGR_FELIM() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xff0000) >> 16
}
func (o *CRS_Type) SetCFGR_SYNCDIV(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7000000)|value<<24)
}
func (o *CRS_Type) GetCFGR_SYNCDIV() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7000000) >> 24
}
func (o *CRS_Type) SetCFGR_SYNCSRC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x30000000)|value<<28)
}
func (o *CRS_Type) GetCFGR_SYNCSRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x30000000) >> 28
}
func (o *CRS_Type) SetCFGR_SYNCPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *CRS_Type) GetCFGR_SYNCPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}

// CRS.ISR: CRS interrupt and status register
func (o *CRS_Type) SetISR_SYNCOKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *CRS_Type) GetISR_SYNCOKF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *CRS_Type) SetISR_SYNCWARNF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *CRS_Type) GetISR_SYNCWARNF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *CRS_Type) SetISR_ERRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *CRS_Type) GetISR_ERRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *CRS_Type) SetISR_ESYNCF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *CRS_Type) GetISR_ESYNCF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *CRS_Type) SetISR_SYNCERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *CRS_Type) GetISR_SYNCERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *CRS_Type) SetISR_SYNCMISS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *CRS_Type) GetISR_SYNCMISS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *CRS_Type) SetISR_TRIMOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *CRS_Type) GetISR_TRIMOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *CRS_Type) SetISR_FEDIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *CRS_Type) GetISR_FEDIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *CRS_Type) SetISR_FECAP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CRS_Type) GetISR_FECAP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xffff0000) >> 16
}

// CRS.ICR: CRS interrupt flag clear register
func (o *CRS_Type) SetICR_SYNCOKC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *CRS_Type) GetICR_SYNCOKC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *CRS_Type) SetICR_SYNCWARNC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *CRS_Type) GetICR_SYNCWARNC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *CRS_Type) SetICR_ERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *CRS_Type) GetICR_ERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *CRS_Type) SetICR_ESYNCC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *CRS_Type) GetICR_ESYNCC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}

// Cryptographic processor
type CRYP_Type struct {
	CR         volatile.Register32 // 0x0
	SR         volatile.Register32 // 0x4
	DIN        volatile.Register32 // 0x8
	DOUT       volatile.Register32 // 0xC
	DMACR      volatile.Register32 // 0x10
	IMSCR      volatile.Register32 // 0x14
	RISR       volatile.Register32 // 0x18
	MISR       volatile.Register32 // 0x1C
	K0LR       volatile.Register32 // 0x20
	K0RR       volatile.Register32 // 0x24
	K1LR       volatile.Register32 // 0x28
	K1RR       volatile.Register32 // 0x2C
	K2LR       volatile.Register32 // 0x30
	K2RR       volatile.Register32 // 0x34
	K3LR       volatile.Register32 // 0x38
	K3RR       volatile.Register32 // 0x3C
	IV0LR      volatile.Register32 // 0x40
	IV0RR      volatile.Register32 // 0x44
	IV1LR      volatile.Register32 // 0x48
	IV1RR      volatile.Register32 // 0x4C
	CSGCMCCM0R volatile.Register32 // 0x50
	CSGCMCCM1R volatile.Register32 // 0x54
	CSGCMCCM2R volatile.Register32 // 0x58
	CSGCMCCM3R volatile.Register32 // 0x5C
	CSGCMCCM4R volatile.Register32 // 0x60
	CSGCMCCM5R volatile.Register32 // 0x64
	CSGCMCCM6R volatile.Register32 // 0x68
	CSGCMCCM7R volatile.Register32 // 0x6C
	CSGCM0R    volatile.Register32 // 0x70
	CSGCM1R    volatile.Register32 // 0x74
	CSGCM2R    volatile.Register32 // 0x78
	CSGCM3R    volatile.Register32 // 0x7C
	CSGCM4R    volatile.Register32 // 0x80
	CSGCM5R    volatile.Register32 // 0x84
	CSGCM6R    volatile.Register32 // 0x88
	CSGCM7R    volatile.Register32 // 0x8C
}

// CRYP.CR: control register
func (o *CRYP_Type) SetCR_ALGODIR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *CRYP_Type) GetCR_ALGODIR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *CRYP_Type) SetCR_ALGOMODE0(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x38)|value<<3)
}
func (o *CRYP_Type) GetCR_ALGOMODE0() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x38) >> 3
}
func (o *CRYP_Type) SetCR_DATATYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *CRYP_Type) GetCR_DATATYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *CRYP_Type) SetCR_KEYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *CRYP_Type) GetCR_KEYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *CRYP_Type) SetCR_FFLUSH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *CRYP_Type) GetCR_FFLUSH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *CRYP_Type) SetCR_CRYPEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *CRYP_Type) GetCR_CRYPEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *CRYP_Type) SetCR_GCM_CCMPH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *CRYP_Type) GetCR_GCM_CCMPH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *CRYP_Type) SetCR_ALGOMODE3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *CRYP_Type) GetCR_ALGOMODE3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}

// CRYP.SR: status register
func (o *CRYP_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *CRYP_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *CRYP_Type) SetSR_OFFU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *CRYP_Type) GetSR_OFFU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *CRYP_Type) SetSR_OFNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *CRYP_Type) GetSR_OFNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *CRYP_Type) SetSR_IFNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetSR_IFNF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetSR_IFEM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetSR_IFEM() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// CRYP.DIN: data input register
func (o *CRYP_Type) SetDIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, value)
}
func (o *CRYP_Type) GetDIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg)
}

// CRYP.DOUT: data output register
func (o *CRYP_Type) SetDOUT(value uint32) {
	volatile.StoreUint32(&o.DOUT.Reg, value)
}
func (o *CRYP_Type) GetDOUT() uint32 {
	return volatile.LoadUint32(&o.DOUT.Reg)
}

// CRYP.DMACR: DMA control register
func (o *CRYP_Type) SetDMACR_DOEN(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetDMACR_DOEN() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetDMACR_DIEN(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetDMACR_DIEN() uint32 {
	return volatile.LoadUint32(&o.DMACR.Reg) & 0x1
}

// CRYP.IMSCR: interrupt mask set/clear register
func (o *CRYP_Type) SetIMSCR_OUTIM(value uint32) {
	volatile.StoreUint32(&o.IMSCR.Reg, volatile.LoadUint32(&o.IMSCR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetIMSCR_OUTIM() uint32 {
	return (volatile.LoadUint32(&o.IMSCR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetIMSCR_INIM(value uint32) {
	volatile.StoreUint32(&o.IMSCR.Reg, volatile.LoadUint32(&o.IMSCR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetIMSCR_INIM() uint32 {
	return volatile.LoadUint32(&o.IMSCR.Reg) & 0x1
}

// CRYP.RISR: raw interrupt status register
func (o *CRYP_Type) SetRISR_OUTRIS(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetRISR_OUTRIS() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetRISR_INRIS(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetRISR_INRIS() uint32 {
	return volatile.LoadUint32(&o.RISR.Reg) & 0x1
}

// CRYP.MISR: masked interrupt status register
func (o *CRYP_Type) SetMISR_OUTMIS(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetMISR_OUTMIS() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetMISR_INMIS(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetMISR_INMIS() uint32 {
	return volatile.LoadUint32(&o.MISR.Reg) & 0x1
}

// CRYP.K0LR: key registers
func (o *CRYP_Type) SetK0LR(value uint32) {
	volatile.StoreUint32(&o.K0LR.Reg, value)
}
func (o *CRYP_Type) GetK0LR() uint32 {
	return volatile.LoadUint32(&o.K0LR.Reg)
}

// CRYP.K0RR: key registers
func (o *CRYP_Type) SetK0RR(value uint32) {
	volatile.StoreUint32(&o.K0RR.Reg, value)
}
func (o *CRYP_Type) GetK0RR() uint32 {
	return volatile.LoadUint32(&o.K0RR.Reg)
}

// CRYP.K1LR: key registers
func (o *CRYP_Type) SetK1LR(value uint32) {
	volatile.StoreUint32(&o.K1LR.Reg, value)
}
func (o *CRYP_Type) GetK1LR() uint32 {
	return volatile.LoadUint32(&o.K1LR.Reg)
}

// CRYP.K1RR: key registers
func (o *CRYP_Type) SetK1RR(value uint32) {
	volatile.StoreUint32(&o.K1RR.Reg, value)
}
func (o *CRYP_Type) GetK1RR() uint32 {
	return volatile.LoadUint32(&o.K1RR.Reg)
}

// CRYP.K2LR: key registers
func (o *CRYP_Type) SetK2LR_B121(value uint32) {
	volatile.StoreUint32(&o.K2LR.Reg, volatile.LoadUint32(&o.K2LR.Reg)&^(0x2000000)|value<<25)
}
func (o *CRYP_Type) GetK2LR_B121() uint32 {
	return (volatile.LoadUint32(&o.K2LR.Reg) & 0x2000000) >> 25
}
func (o *CRYP_Type) SetK2LR_K(value uint32) {
	volatile.StoreUint32(&o.K2LR.Reg, volatile.LoadUint32(&o.K2LR.Reg)&^(0x7fffffff)|value)
}
func (o *CRYP_Type) GetK2LR_K() uint32 {
	return volatile.LoadUint32(&o.K2LR.Reg) & 0x7fffffff
}

// CRYP.K2RR: key registers
func (o *CRYP_Type) SetK2RR(value uint32) {
	volatile.StoreUint32(&o.K2RR.Reg, value)
}
func (o *CRYP_Type) GetK2RR() uint32 {
	return volatile.LoadUint32(&o.K2RR.Reg)
}

// CRYP.K3LR: key registers
func (o *CRYP_Type) SetK3LR(value uint32) {
	volatile.StoreUint32(&o.K3LR.Reg, value)
}
func (o *CRYP_Type) GetK3LR() uint32 {
	return volatile.LoadUint32(&o.K3LR.Reg)
}

// CRYP.K3RR: key registers
func (o *CRYP_Type) SetK3RR(value uint32) {
	volatile.StoreUint32(&o.K3RR.Reg, value)
}
func (o *CRYP_Type) GetK3RR() uint32 {
	return volatile.LoadUint32(&o.K3RR.Reg)
}

// CRYP.IV0LR: Initialization vector register 0L
func (o *CRYP_Type) SetIV0LR(value uint32) {
	volatile.StoreUint32(&o.IV0LR.Reg, value)
}
func (o *CRYP_Type) GetIV0LR() uint32 {
	return volatile.LoadUint32(&o.IV0LR.Reg)
}

// CRYP.IV0RR: initialization vector register 0R
func (o *CRYP_Type) SetIV0RR(value uint32) {
	volatile.StoreUint32(&o.IV0RR.Reg, value)
}
func (o *CRYP_Type) GetIV0RR() uint32 {
	return volatile.LoadUint32(&o.IV0RR.Reg)
}

// CRYP.IV1LR: Initialization vector register 1L
func (o *CRYP_Type) SetIV1LR(value uint32) {
	volatile.StoreUint32(&o.IV1LR.Reg, value)
}
func (o *CRYP_Type) GetIV1LR() uint32 {
	return volatile.LoadUint32(&o.IV1LR.Reg)
}

// CRYP.IV1RR: Initialization vector register 1R
func (o *CRYP_Type) SetIV1RR(value uint32) {
	volatile.StoreUint32(&o.IV1RR.Reg, value)
}
func (o *CRYP_Type) GetIV1RR() uint32 {
	return volatile.LoadUint32(&o.IV1RR.Reg)
}

// CRYP.CSGCMCCM0R: context swap register
func (o *CRYP_Type) SetCSGCMCCM0R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM0R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM0R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM0R.Reg)
}

// CRYP.CSGCMCCM1R: context swap register
func (o *CRYP_Type) SetCSGCMCCM1R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM1R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM1R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM1R.Reg)
}

// CRYP.CSGCMCCM2R: context swap register
func (o *CRYP_Type) SetCSGCMCCM2R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM2R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM2R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM2R.Reg)
}

// CRYP.CSGCMCCM3R: context swap register
func (o *CRYP_Type) SetCSGCMCCM3R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM3R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM3R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM3R.Reg)
}

// CRYP.CSGCMCCM4R: context swap register
func (o *CRYP_Type) SetCSGCMCCM4R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM4R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM4R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM4R.Reg)
}

// CRYP.CSGCMCCM5R: context swap register
func (o *CRYP_Type) SetCSGCMCCM5R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM5R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM5R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM5R.Reg)
}

// CRYP.CSGCMCCM6R: context swap register
func (o *CRYP_Type) SetCSGCMCCM6R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM6R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM6R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM6R.Reg)
}

// CRYP.CSGCMCCM7R: context swap register
func (o *CRYP_Type) SetCSGCMCCM7R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM7R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM7R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM7R.Reg)
}

// CRYP.CSGCM0R: context swap register
func (o *CRYP_Type) SetCSGCM0R(value uint32) {
	volatile.StoreUint32(&o.CSGCM0R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM0R() uint32 {
	return volatile.LoadUint32(&o.CSGCM0R.Reg)
}

// CRYP.CSGCM1R: context swap register
func (o *CRYP_Type) SetCSGCM1R(value uint32) {
	volatile.StoreUint32(&o.CSGCM1R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM1R() uint32 {
	return volatile.LoadUint32(&o.CSGCM1R.Reg)
}

// CRYP.CSGCM2R: context swap register
func (o *CRYP_Type) SetCSGCM2R(value uint32) {
	volatile.StoreUint32(&o.CSGCM2R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM2R() uint32 {
	return volatile.LoadUint32(&o.CSGCM2R.Reg)
}

// CRYP.CSGCM3R: context swap register
func (o *CRYP_Type) SetCSGCM3R(value uint32) {
	volatile.StoreUint32(&o.CSGCM3R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM3R() uint32 {
	return volatile.LoadUint32(&o.CSGCM3R.Reg)
}

// CRYP.CSGCM4R: context swap register
func (o *CRYP_Type) SetCSGCM4R(value uint32) {
	volatile.StoreUint32(&o.CSGCM4R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM4R() uint32 {
	return volatile.LoadUint32(&o.CSGCM4R.Reg)
}

// CRYP.CSGCM5R: context swap register
func (o *CRYP_Type) SetCSGCM5R(value uint32) {
	volatile.StoreUint32(&o.CSGCM5R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM5R() uint32 {
	return volatile.LoadUint32(&o.CSGCM5R.Reg)
}

// CRYP.CSGCM6R: context swap register
func (o *CRYP_Type) SetCSGCM6R(value uint32) {
	volatile.StoreUint32(&o.CSGCM6R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM6R() uint32 {
	return volatile.LoadUint32(&o.CSGCM6R.Reg)
}

// CRYP.CSGCM7R: context swap register
func (o *CRYP_Type) SetCSGCM7R(value uint32) {
	volatile.StoreUint32(&o.CSGCM7R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM7R() uint32 {
	return volatile.LoadUint32(&o.CSGCM7R.Reg)
}

// DAC
type DAC_Type struct {
	CR      volatile.Register32 // 0x0
	SWTRGR  volatile.Register32 // 0x4
	DHR12R1 volatile.Register32 // 0x8
	DHR12L1 volatile.Register32 // 0xC
	DHR8R1  volatile.Register32 // 0x10
	DHR12R2 volatile.Register32 // 0x14
	DHR12L2 volatile.Register32 // 0x18
	DHR8R2  volatile.Register32 // 0x1C
	DHR12RD volatile.Register32 // 0x20
	DHR12LD volatile.Register32 // 0x24
	DHR8RD  volatile.Register32 // 0x28
	DOR1    volatile.Register32 // 0x2C
	DOR2    volatile.Register32 // 0x30
	SR      volatile.Register32 // 0x34
	CCR     volatile.Register32 // 0x38
	MCR     volatile.Register32 // 0x3C
	SHSR1   volatile.Register32 // 0x40
	SHSR2   volatile.Register32 // 0x44
	SHHR    volatile.Register32 // 0x48
	SHRR    volatile.Register32 // 0x4C
}

// DAC.CR: DAC control register
func (o *DAC_Type) SetCR_EN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCR_EN1() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DAC_Type) SetCR_TEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCR_TEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCR_TSEL1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1c)|value<<2)
}
func (o *DAC_Type) GetCR_TSEL1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1c) >> 2
}
func (o *DAC_Type) SetCR_WAVE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DAC_Type) GetCR_WAVE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DAC_Type) SetCR_MAMP1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetCR_MAMP1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetCR_DMAEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DAC_Type) GetCR_DMAEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DAC_Type) SetCR_DMAUDRIE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetCR_DMAUDRIE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetCR_CEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetCR_CEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetCR_EN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetCR_EN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DAC_Type) SetCR_TEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *DAC_Type) GetCR_TEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *DAC_Type) SetCR_TSEL2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1c0000)|value<<18)
}
func (o *DAC_Type) GetCR_TSEL2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1c0000) >> 18
}
func (o *DAC_Type) SetCR_WAVE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00000)|value<<22)
}
func (o *DAC_Type) GetCR_WAVE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00000) >> 22
}
func (o *DAC_Type) SetCR_MAMP2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf000000)|value<<24)
}
func (o *DAC_Type) GetCR_MAMP2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf000000) >> 24
}
func (o *DAC_Type) SetCR_DMAEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *DAC_Type) GetCR_DMAEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *DAC_Type) SetCR_DMAUDRIE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetCR_DMAUDRIE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetCR_CEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *DAC_Type) GetCR_CEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}

// DAC.SWTRGR: DAC software trigger register
func (o *DAC_Type) SetSWTRGR_SWTRIG1(value uint32) {
	volatile.StoreUint32(&o.SWTRGR.Reg, volatile.LoadUint32(&o.SWTRGR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSWTRGR_SWTRIG1() uint32 {
	return volatile.LoadUint32(&o.SWTRGR.Reg) & 0x1
}
func (o *DAC_Type) SetSWTRGR_SWTRIG2(value uint32) {
	volatile.StoreUint32(&o.SWTRGR.Reg, volatile.LoadUint32(&o.SWTRGR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSWTRGR_SWTRIG2() uint32 {
	return (volatile.LoadUint32(&o.SWTRGR.Reg) & 0x2) >> 1
}

// DAC.DHR12R1: DAC channel1 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R1.Reg, volatile.LoadUint32(&o.DHR12R1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R1.Reg) & 0xfff
}

// DAC.DHR12L1: DAC channel1 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L1.Reg, volatile.LoadUint32(&o.DHR12L1.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L1_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L1.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R1: DAC channel1 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R1.Reg, volatile.LoadUint32(&o.DHR8R1.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R1.Reg) & 0xff
}

// DAC.DHR12R2: DAC channel2 12-bit right aligned data holding register
func (o *DAC_Type) SetDHR12R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R2.Reg, volatile.LoadUint32(&o.DHR12R2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R2.Reg) & 0xfff
}

// DAC.DHR12L2: DAC channel2 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L2.Reg, volatile.LoadUint32(&o.DHR12L2.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L2_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L2.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R2: DAC channel2 8-bit right-aligned data holding register
func (o *DAC_Type) SetDHR8R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R2.Reg, volatile.LoadUint32(&o.DHR8R2.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R2.Reg) & 0xff
}

// DAC.DHR12RD: Dual DAC 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff
}
func (o *DAC_Type) SetDHR12RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff0000)|value<<16)
}
func (o *DAC_Type) GetDHR12RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff0000) >> 16
}

// DAC.DHR12LD: DUAL DAC 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12LD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12LD_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff0) >> 4
}
func (o *DAC_Type) SetDHR12LD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff00000)|value<<20)
}
func (o *DAC_Type) GetDHR12LD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff00000) >> 20
}

// DAC.DHR8RD: DUAL DAC 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff
}
func (o *DAC_Type) SetDHR8RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff00)|value<<8)
}
func (o *DAC_Type) GetDHR8RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff00) >> 8
}

// DAC.DOR1: DAC channel1 data output register
func (o *DAC_Type) SetDOR1_DACC1DOR(value uint32) {
	volatile.StoreUint32(&o.DOR1.Reg, volatile.LoadUint32(&o.DOR1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR1_DACC1DOR() uint32 {
	return volatile.LoadUint32(&o.DOR1.Reg) & 0xfff
}

// DAC.DOR2: DAC channel2 data output register
func (o *DAC_Type) SetDOR2_DACC2DOR(value uint32) {
	volatile.StoreUint32(&o.DOR2.Reg, volatile.LoadUint32(&o.DOR2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR2_DACC2DOR() uint32 {
	return volatile.LoadUint32(&o.DOR2.Reg) & 0xfff
}

// DAC.SR: DAC status register
func (o *DAC_Type) SetSR_DMAUDR1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetSR_DMAUDR1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetSR_CAL_FLAG1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetSR_CAL_FLAG1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetSR_BWST1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *DAC_Type) GetSR_BWST1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *DAC_Type) SetSR_DMAUDR2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetSR_DMAUDR2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetSR_CAL_FLAG2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *DAC_Type) GetSR_CAL_FLAG2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *DAC_Type) SetSR_BWST2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *DAC_Type) GetSR_BWST2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// DAC.CCR: DAC calibration control register
func (o *DAC_Type) SetCCR_OTRIM1(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f)|value)
}
func (o *DAC_Type) GetCCR_OTRIM1() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1f
}
func (o *DAC_Type) SetCCR_OTRIM2(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DAC_Type) GetCCR_OTRIM2() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1f0000) >> 16
}

// DAC.MCR: DAC mode control register
func (o *DAC_Type) SetMCR_MODE1(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x7)|value)
}
func (o *DAC_Type) GetMCR_MODE1() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x7
}
func (o *DAC_Type) SetMCR_MODE2(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x70000)|value<<16)
}
func (o *DAC_Type) GetMCR_MODE2() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x70000) >> 16
}

// DAC.SHSR1: DAC Sample and Hold sample time register 1
func (o *DAC_Type) SetSHSR1_TSAMPLE1(value uint32) {
	volatile.StoreUint32(&o.SHSR1.Reg, volatile.LoadUint32(&o.SHSR1.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR1_TSAMPLE1() uint32 {
	return volatile.LoadUint32(&o.SHSR1.Reg) & 0x3ff
}

// DAC.SHSR2: DAC Sample and Hold sample time register 2
func (o *DAC_Type) SetSHSR2_TSAMPLE2(value uint32) {
	volatile.StoreUint32(&o.SHSR2.Reg, volatile.LoadUint32(&o.SHSR2.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR2_TSAMPLE2() uint32 {
	return volatile.LoadUint32(&o.SHSR2.Reg) & 0x3ff
}

// DAC.SHHR: DAC Sample and Hold hold time register
func (o *DAC_Type) SetSHHR_THOLD1(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHHR_THOLD1() uint32 {
	return volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff
}
func (o *DAC_Type) SetSHHR_THOLD2(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DAC_Type) GetSHHR_THOLD2() uint32 {
	return (volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff0000) >> 16
}

// DAC.SHRR: DAC Sample and Hold refresh time register
func (o *DAC_Type) SetSHRR_TREFRESH1(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetSHRR_TREFRESH1() uint32 {
	return volatile.LoadUint32(&o.SHRR.Reg) & 0xff
}
func (o *DAC_Type) SetSHRR_TREFRESH2(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff0000)|value<<16)
}
func (o *DAC_Type) GetSHRR_TREFRESH2() uint32 {
	return (volatile.LoadUint32(&o.SHRR.Reg) & 0xff0000) >> 16
}

// Microcontroller Debug Unit
type DBGMCU_Type struct {
	IDC      volatile.Register32 // 0x0
	CR       volatile.Register32 // 0x4
	_        [44]byte
	APB3FZ1  volatile.Register32 // 0x34
	APB3FZ2  volatile.Register32 // 0x38
	APB1LFZ1 volatile.Register32 // 0x3C
	APB1LFZ2 volatile.Register32 // 0x40
	_        [8]byte
	APB2FZ1  volatile.Register32 // 0x4C
	APB2FZ2  volatile.Register32 // 0x50
	APB4FZ1  volatile.Register32 // 0x54
	APB4FZ2  volatile.Register32 // 0x58
}

// DBGMCU.IDC: DBGMCU Identity Code Register
func (o *DBGMCU_Type) SetIDC_DEV_ID(value uint32) {
	volatile.StoreUint32(&o.IDC.Reg, volatile.LoadUint32(&o.IDC.Reg)&^(0xfff)|value)
}
func (o *DBGMCU_Type) GetIDC_DEV_ID() uint32 {
	return volatile.LoadUint32(&o.IDC.Reg) & 0xfff
}
func (o *DBGMCU_Type) SetIDC_REV_ID(value uint32) {
	volatile.StoreUint32(&o.IDC.Reg, volatile.LoadUint32(&o.IDC.Reg)&^(0xffff0000)|value<<16)
}
func (o *DBGMCU_Type) GetIDC_REV_ID() uint32 {
	return (volatile.LoadUint32(&o.IDC.Reg) & 0xffff0000) >> 16
}

// DBGMCU.CR: DBGMCU Configuration Register
func (o *DBGMCU_Type) SetCR_DBGSLPD1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetCR_DBGSLPD1() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DBGMCU_Type) SetCR_DBGSTPD1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetCR_DBGSTPD1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetCR_DBGSTBD1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetCR_DBGSTBD1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetCR_DBGSLPD2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DBGMCU_Type) GetCR_DBGSLPD2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DBGMCU_Type) SetCR_DBGSTPD2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DBGMCU_Type) GetCR_DBGSTPD2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DBGMCU_Type) SetCR_DBGSTBD2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetCR_DBGSTBD2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetCR_DBGSTPD3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DBGMCU_Type) GetCR_DBGSTPD3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DBGMCU_Type) SetCR_DBGSTBD3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DBGMCU_Type) GetCR_DBGSTBD3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DBGMCU_Type) SetCR_TRACECLKEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *DBGMCU_Type) GetCR_TRACECLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *DBGMCU_Type) SetCR_D1DBGCKEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *DBGMCU_Type) GetCR_D1DBGCKEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *DBGMCU_Type) SetCR_D3DBGCKEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *DBGMCU_Type) GetCR_D3DBGCKEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *DBGMCU_Type) SetCR_TRGOEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *DBGMCU_Type) GetCR_TRGOEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}

// DBGMCU.APB3FZ1: DBGMCU APB3 peripheral freeze register CPU1
func (o *DBGMCU_Type) SetAPB3FZ1_WWDG1(value uint32) {
	volatile.StoreUint32(&o.APB3FZ1.Reg, volatile.LoadUint32(&o.APB3FZ1.Reg)&^(0x40)|value<<6)
}
func (o *DBGMCU_Type) GetAPB3FZ1_WWDG1() uint32 {
	return (volatile.LoadUint32(&o.APB3FZ1.Reg) & 0x40) >> 6
}

// DBGMCU.APB3FZ2: DBGMCU APB3 peripheral freeze register CPU2
func (o *DBGMCU_Type) SetAPB3FZ2_WWDG1(value uint32) {
	volatile.StoreUint32(&o.APB3FZ2.Reg, volatile.LoadUint32(&o.APB3FZ2.Reg)&^(0x40)|value<<6)
}
func (o *DBGMCU_Type) GetAPB3FZ2_WWDG1() uint32 {
	return (volatile.LoadUint32(&o.APB3FZ2.Reg) & 0x40) >> 6
}

// DBGMCU.APB1LFZ1: DBGMCU APB1L peripheral freeze register
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM2(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM2() uint32 {
	return volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM3(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM3() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM4(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM4() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM5(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x8)|value<<3)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM5() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x8) >> 3
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM6(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x10)|value<<4)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM6() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x10) >> 4
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM7(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM7() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM12(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x40)|value<<6)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM12() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x40) >> 6
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM13(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x80)|value<<7)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM13() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x80) >> 7
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_TIM14(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x100)|value<<8)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_TIM14() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x100) >> 8
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_LPTIM1(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x200)|value<<9)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_LPTIM1() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x200) >> 9
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_WWDG2(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_WWDG2() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_I2C1(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x200000)|value<<21)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_I2C1() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x200000) >> 21
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_I2C2(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x400000)|value<<22)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_I2C2() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x400000) >> 22
}
func (o *DBGMCU_Type) SetAPB1LFZ1_DBG_I2C3(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ1.Reg, volatile.LoadUint32(&o.APB1LFZ1.Reg)&^(0x800000)|value<<23)
}
func (o *DBGMCU_Type) GetAPB1LFZ1_DBG_I2C3() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ1.Reg) & 0x800000) >> 23
}

// DBGMCU.APB1LFZ2: DBGMCU APB1L peripheral freeze register CPU2
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM2(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM2() uint32 {
	return volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM3(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM3() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM4(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM4() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM5(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x8)|value<<3)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM5() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x8) >> 3
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM6(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x10)|value<<4)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM6() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x10) >> 4
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM7(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM7() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM12(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x40)|value<<6)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM12() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x40) >> 6
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM13(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x80)|value<<7)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM13() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x80) >> 7
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_TIM14(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x100)|value<<8)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_TIM14() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x100) >> 8
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_LPTIM1(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x200)|value<<9)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_LPTIM1() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x200) >> 9
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_WWDG2(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_WWDG2() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_I2C1(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x200000)|value<<21)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_I2C1() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x200000) >> 21
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_I2C2(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x400000)|value<<22)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_I2C2() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x400000) >> 22
}
func (o *DBGMCU_Type) SetAPB1LFZ2_DBG_I2C3(value uint32) {
	volatile.StoreUint32(&o.APB1LFZ2.Reg, volatile.LoadUint32(&o.APB1LFZ2.Reg)&^(0x800000)|value<<23)
}
func (o *DBGMCU_Type) GetAPB1LFZ2_DBG_I2C3() uint32 {
	return (volatile.LoadUint32(&o.APB1LFZ2.Reg) & 0x800000) >> 23
}

// DBGMCU.APB2FZ1: DBGMCU APB2 peripheral freeze register
func (o *DBGMCU_Type) SetAPB2FZ1_DBG_TIM1(value uint32) {
	volatile.StoreUint32(&o.APB2FZ1.Reg, volatile.LoadUint32(&o.APB2FZ1.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB2FZ1_DBG_TIM1() uint32 {
	return volatile.LoadUint32(&o.APB2FZ1.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB2FZ1_DBG_TIM8(value uint32) {
	volatile.StoreUint32(&o.APB2FZ1.Reg, volatile.LoadUint32(&o.APB2FZ1.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB2FZ1_DBG_TIM8() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ1.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB2FZ1_DBG_TIM15(value uint32) {
	volatile.StoreUint32(&o.APB2FZ1.Reg, volatile.LoadUint32(&o.APB2FZ1.Reg)&^(0x10000)|value<<16)
}
func (o *DBGMCU_Type) GetAPB2FZ1_DBG_TIM15() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ1.Reg) & 0x10000) >> 16
}
func (o *DBGMCU_Type) SetAPB2FZ1_DBG_TIM16(value uint32) {
	volatile.StoreUint32(&o.APB2FZ1.Reg, volatile.LoadUint32(&o.APB2FZ1.Reg)&^(0x20000)|value<<17)
}
func (o *DBGMCU_Type) GetAPB2FZ1_DBG_TIM16() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ1.Reg) & 0x20000) >> 17
}
func (o *DBGMCU_Type) SetAPB2FZ1_DBG_TIM17(value uint32) {
	volatile.StoreUint32(&o.APB2FZ1.Reg, volatile.LoadUint32(&o.APB2FZ1.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB2FZ1_DBG_TIM17() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ1.Reg) & 0x40000) >> 18
}
func (o *DBGMCU_Type) SetAPB2FZ1_DBG_HRTIM(value uint32) {
	volatile.StoreUint32(&o.APB2FZ1.Reg, volatile.LoadUint32(&o.APB2FZ1.Reg)&^(0x20000000)|value<<29)
}
func (o *DBGMCU_Type) GetAPB2FZ1_DBG_HRTIM() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ1.Reg) & 0x20000000) >> 29
}

// DBGMCU.APB2FZ2: DBGMCU APB2 peripheral freeze register CPU2
func (o *DBGMCU_Type) SetAPB2FZ2_DBG_TIM1(value uint32) {
	volatile.StoreUint32(&o.APB2FZ2.Reg, volatile.LoadUint32(&o.APB2FZ2.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB2FZ2_DBG_TIM1() uint32 {
	return volatile.LoadUint32(&o.APB2FZ2.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB2FZ2_DBG_TIM8(value uint32) {
	volatile.StoreUint32(&o.APB2FZ2.Reg, volatile.LoadUint32(&o.APB2FZ2.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB2FZ2_DBG_TIM8() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ2.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB2FZ2_DBG_TIM15(value uint32) {
	volatile.StoreUint32(&o.APB2FZ2.Reg, volatile.LoadUint32(&o.APB2FZ2.Reg)&^(0x10000)|value<<16)
}
func (o *DBGMCU_Type) GetAPB2FZ2_DBG_TIM15() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ2.Reg) & 0x10000) >> 16
}
func (o *DBGMCU_Type) SetAPB2FZ2_DBG_TIM16(value uint32) {
	volatile.StoreUint32(&o.APB2FZ2.Reg, volatile.LoadUint32(&o.APB2FZ2.Reg)&^(0x20000)|value<<17)
}
func (o *DBGMCU_Type) GetAPB2FZ2_DBG_TIM16() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ2.Reg) & 0x20000) >> 17
}
func (o *DBGMCU_Type) SetAPB2FZ2_DBG_TIM17(value uint32) {
	volatile.StoreUint32(&o.APB2FZ2.Reg, volatile.LoadUint32(&o.APB2FZ2.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB2FZ2_DBG_TIM17() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ2.Reg) & 0x40000) >> 18
}
func (o *DBGMCU_Type) SetAPB2FZ2_DBG_HRTIM(value uint32) {
	volatile.StoreUint32(&o.APB2FZ2.Reg, volatile.LoadUint32(&o.APB2FZ2.Reg)&^(0x20000000)|value<<29)
}
func (o *DBGMCU_Type) GetAPB2FZ2_DBG_HRTIM() uint32 {
	return (volatile.LoadUint32(&o.APB2FZ2.Reg) & 0x20000000) >> 29
}

// DBGMCU.APB4FZ1: DBGMCU APB4 peripheral freeze register
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_I2C4(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x80)|value<<7)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_I2C4() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x80) >> 7
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_LPTIM2(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x200)|value<<9)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_LPTIM2() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x200) >> 9
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_LPTIM3(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x400)|value<<10)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_LPTIM3() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x400) >> 10
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_LPTIM4(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_LPTIM4() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_LPTIM5(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x1000)|value<<12)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_LPTIM5() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x1000) >> 12
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_RTC(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x10000)|value<<16)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_RTC() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x10000) >> 16
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_WDGLSD1(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_WDGLSD1() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x40000) >> 18
}
func (o *DBGMCU_Type) SetAPB4FZ1_DBG_WDGLSD2(value uint32) {
	volatile.StoreUint32(&o.APB4FZ1.Reg, volatile.LoadUint32(&o.APB4FZ1.Reg)&^(0x80000)|value<<19)
}
func (o *DBGMCU_Type) GetAPB4FZ1_DBG_WDGLSD2() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ1.Reg) & 0x80000) >> 19
}

// DBGMCU.APB4FZ2: DBGMCU APB4 peripheral freeze register CPU2
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_I2C4(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x80)|value<<7)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_I2C4() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x80) >> 7
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_LPTIM2(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x200)|value<<9)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_LPTIM2() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x200) >> 9
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_LPTIM3(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x400)|value<<10)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_LPTIM3() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x400) >> 10
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_LPTIM4(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_LPTIM4() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_LPTIM5(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x1000)|value<<12)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_LPTIM5() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x1000) >> 12
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_RTC(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x10000)|value<<16)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_RTC() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x10000) >> 16
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_WDGLSD1(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_WDGLSD1() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x40000) >> 18
}
func (o *DBGMCU_Type) SetAPB4FZ2_DBG_WDGLSD2(value uint32) {
	volatile.StoreUint32(&o.APB4FZ2.Reg, volatile.LoadUint32(&o.APB4FZ2.Reg)&^(0x80000)|value<<19)
}
func (o *DBGMCU_Type) GetAPB4FZ2_DBG_WDGLSD2() uint32 {
	return (volatile.LoadUint32(&o.APB4FZ2.Reg) & 0x80000) >> 19
}

// Digital camera interface
type DCMI_Type struct {
	CR     volatile.Register32 // 0x0
	SR     volatile.Register32 // 0x4
	RIS    volatile.Register32 // 0x8
	IER    volatile.Register32 // 0xC
	MIS    volatile.Register32 // 0x10
	ICR    volatile.Register32 // 0x14
	ESCR   volatile.Register32 // 0x18
	ESUR   volatile.Register32 // 0x1C
	CWSTRT volatile.Register32 // 0x20
	CWSIZE volatile.Register32 // 0x24
	DR     volatile.Register32 // 0x28
}

// DCMI.CR: control register 1
func (o *DCMI_Type) SetCR_OELS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *DCMI_Type) GetCR_OELS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *DCMI_Type) SetCR_LSM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *DCMI_Type) GetCR_LSM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *DCMI_Type) SetCR_OEBS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DCMI_Type) GetCR_OEBS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *DCMI_Type) SetCR_BSM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DCMI_Type) GetCR_BSM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *DCMI_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DCMI_Type) GetCR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DCMI_Type) SetCR_EDM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *DCMI_Type) GetCR_EDM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *DCMI_Type) SetCR_FCRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *DCMI_Type) GetCR_FCRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *DCMI_Type) SetCR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DCMI_Type) GetCR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DCMI_Type) SetCR_HSPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DCMI_Type) GetCR_HSPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DCMI_Type) SetCR_PCKPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DCMI_Type) GetCR_PCKPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DCMI_Type) SetCR_ESS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetCR_ESS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetCR_JPEG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetCR_JPEG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetCR_CROP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetCR_CROP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetCR_CM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetCR_CM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetCR_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetCR_CAPTURE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DCMI.SR: status register
func (o *DCMI_Type) SetSR_FNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetSR_FNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetSR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetSR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetSR_HSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetSR_HSYNC() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// DCMI.RIS: raw interrupt status register
func (o *DCMI_Type) SetRIS_LINE_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetRIS_LINE_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetRIS_VSYNC_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetRIS_VSYNC_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetRIS_ERR_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetRIS_ERR_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetRIS_OVR_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetRIS_OVR_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetRIS_FRAME_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetRIS_FRAME_RIS() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}

// DCMI.IER: interrupt enable register
func (o *DCMI_Type) SetIER_LINE_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetIER_LINE_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetIER_VSYNC_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetIER_VSYNC_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetIER_ERR_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetIER_ERR_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetIER_OVR_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetIER_OVR_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetIER_FRAME_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetIER_FRAME_IE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// DCMI.MIS: masked interrupt status register
func (o *DCMI_Type) SetMIS_LINE_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetMIS_LINE_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetMIS_VSYNC_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetMIS_VSYNC_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetMIS_ERR_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetMIS_ERR_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetMIS_OVR_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetMIS_OVR_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetMIS_FRAME_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetMIS_FRAME_MIS() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}

// DCMI.ICR: interrupt clear register
func (o *DCMI_Type) SetICR_LINE_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetICR_LINE_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetICR_VSYNC_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetICR_VSYNC_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetICR_ERR_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetICR_ERR_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetICR_OVR_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetICR_OVR_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetICR_FRAME_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetICR_FRAME_ISC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// DCMI.ESCR: embedded synchronization code register
func (o *DCMI_Type) SetESCR_FEC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetESCR_FEC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetESCR_LEC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetESCR_LEC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetESCR_LSC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetESCR_LSC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetESCR_FSC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetESCR_FSC() uint32 {
	return volatile.LoadUint32(&o.ESCR.Reg) & 0xff
}

// DCMI.ESUR: embedded synchronization unmask register
func (o *DCMI_Type) SetESUR_FEU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetESUR_FEU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetESUR_LEU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetESUR_LEU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetESUR_LSU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetESUR_LSU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetESUR_FSU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetESUR_FSU() uint32 {
	return volatile.LoadUint32(&o.ESUR.Reg) & 0xff
}

// DCMI.CWSTRT: crop window start
func (o *DCMI_Type) SetCWSTRT_VST(value uint32) {
	volatile.StoreUint32(&o.CWSTRT.Reg, volatile.LoadUint32(&o.CWSTRT.Reg)&^(0x1fff0000)|value<<16)
}
func (o *DCMI_Type) GetCWSTRT_VST() uint32 {
	return (volatile.LoadUint32(&o.CWSTRT.Reg) & 0x1fff0000) >> 16
}
func (o *DCMI_Type) SetCWSTRT_HOFFCNT(value uint32) {
	volatile.StoreUint32(&o.CWSTRT.Reg, volatile.LoadUint32(&o.CWSTRT.Reg)&^(0x3fff)|value)
}
func (o *DCMI_Type) GetCWSTRT_HOFFCNT() uint32 {
	return volatile.LoadUint32(&o.CWSTRT.Reg) & 0x3fff
}

// DCMI.CWSIZE: crop window size
func (o *DCMI_Type) SetCWSIZE_VLINE(value uint32) {
	volatile.StoreUint32(&o.CWSIZE.Reg, volatile.LoadUint32(&o.CWSIZE.Reg)&^(0x3fff0000)|value<<16)
}
func (o *DCMI_Type) GetCWSIZE_VLINE() uint32 {
	return (volatile.LoadUint32(&o.CWSIZE.Reg) & 0x3fff0000) >> 16
}
func (o *DCMI_Type) SetCWSIZE_CAPCNT(value uint32) {
	volatile.StoreUint32(&o.CWSIZE.Reg, volatile.LoadUint32(&o.CWSIZE.Reg)&^(0x3fff)|value)
}
func (o *DCMI_Type) GetCWSIZE_CAPCNT() uint32 {
	return volatile.LoadUint32(&o.CWSIZE.Reg) & 0x3fff
}

// DCMI.DR: data register
func (o *DCMI_Type) SetDR_Byte3(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetDR_Byte3() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetDR_Byte2(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetDR_Byte2() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetDR_Byte1(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetDR_Byte1() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetDR_Byte0(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetDR_Byte0() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xff
}

// DELAY_Block_SDMMC1
type DLYB_Type struct {
	CR   volatile.Register32 // 0x0
	CFGR volatile.Register32 // 0x4
}

// DLYB.CR: DLYB control register
func (o *DLYB_Type) SetCR_DEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DLYB_Type) GetCR_DEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DLYB_Type) SetCR_SEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DLYB_Type) GetCR_SEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}

// DLYB.CFGR: DLYB configuration register
func (o *DLYB_Type) SetCFGR_SEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xf)|value)
}
func (o *DLYB_Type) GetCFGR_SEL() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0xf
}
func (o *DLYB_Type) SetCFGR_UNIT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7f00)|value<<8)
}
func (o *DLYB_Type) GetCFGR_UNIT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7f00) >> 8
}
func (o *DLYB_Type) SetCFGR_LNG(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xfff0000)|value<<16)
}
func (o *DLYB_Type) GetCFGR_LNG() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xfff0000) >> 16
}
func (o *DLYB_Type) SetCFGR_LNGF(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *DLYB_Type) GetCFGR_LNGF() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}

// Digital filter for sigma delta modulators
type DFSDM_Type struct {
	CH  [8]DFSDM_CH_Type  // 0x0
	FLT [4]DFSDM_FLT_Type // 0x100
}

type DFSDM_CH_Type struct {
	CFGR1  volatile.Register32 // 0x0
	CFGR2  volatile.Register32 // 0x4
	AWSCDR volatile.Register32 // 0x8
	WDATR  volatile.Register32 // 0xC
	DATINR volatile.Register32 // 0x10
	_      [12]byte
}

// DFSDM_CH.CFGR1: channel configuration y register
func (o *DFSDM_CH_Type) SetCFGR1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_CH_Type) GetCFGR1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x80000000) >> 31
}
func (o *DFSDM_CH_Type) SetCFGR1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_CH_Type) GetCFGR1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_CH_Type) SetCFGR1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_CH_Type) GetCFGR1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_CH_Type) SetCFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_CH_Type) GetCFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_CH_Type) SetCFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_CH_Type) GetCFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_CH_Type) SetCFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_CH_Type) GetCFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_CH_Type) SetCFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_CH_Type) GetCFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_CH_Type) SetCFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_CH_Type) GetCFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_CH_Type) SetCFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_CH_Type) GetCFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_CH_Type) SetCFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_CH_Type) GetCFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_CH_Type) SetCFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_CH_Type) GetCFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x3
}

// DFSDM_CH.CFGR2: channel configuration y register
func (o *DFSDM_CH_Type) SetCFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_CH_Type) GetCFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_CH_Type) SetCFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_CH_Type) GetCFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM_CH.AWSCDR: analog watchdog and short-circuit detector register
func (o *DFSDM_CH_Type) SetAWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCDR.Reg, volatile.LoadUint32(&o.AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_CH_Type) GetAWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_CH_Type) SetAWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCDR.Reg, volatile.LoadUint32(&o.AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_CH_Type) GetAWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_CH_Type) SetAWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCDR.Reg, volatile.LoadUint32(&o.AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_CH_Type) GetAWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_CH_Type) SetAWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCDR.Reg, volatile.LoadUint32(&o.AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_CH_Type) GetAWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCDR.Reg) & 0xff
}

// DFSDM_CH.WDATR: channel watchdog filter data register
func (o *DFSDM_CH_Type) SetWDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.WDATR.Reg, volatile.LoadUint32(&o.WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_CH_Type) GetWDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.WDATR.Reg) & 0xffff
}

// DFSDM_CH.DATINR: channel data input register
func (o *DFSDM_CH_Type) SetDATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.DATINR.Reg, volatile.LoadUint32(&o.DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_CH_Type) GetDATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_CH_Type) SetDATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.DATINR.Reg, volatile.LoadUint32(&o.DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_CH_Type) GetDATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.DATINR.Reg) & 0xffff
}

type DFSDM_FLT_Type struct {
	CR1        volatile.Register32 // 0x100
	CR2        volatile.Register32 // 0x104
	ISR        volatile.Register32 // 0x108
	ICR        volatile.Register32 // 0x10C
	JCHGR      volatile.Register32 // 0x110
	FCR        volatile.Register32 // 0x114
	JDATAR     volatile.Register32 // 0x118
	RDATAR     volatile.Register32 // 0x11C
	AWHTR      volatile.Register32 // 0x120
	AWLTR      volatile.Register32 // 0x124
	AWSR       volatile.Register32 // 0x128
	AWCFR      volatile.Register32 // 0x12C
	EXMAX      volatile.Register32 // 0x130
	EXMIN      volatile.Register32 // 0x134
	FLTCNVTIMR volatile.Register32 // 0x138
	_          [68]byte
}

// DFSDM_FLT.CR1: control register 1
func (o *DFSDM_FLT_Type) SetCR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_FLT_Type) GetCR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_FLT_Type) SetCR1_FAST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_FLT_Type) GetCR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_FLT_Type) SetCR1_RCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_FLT_Type) GetCR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_FLT_Type) SetCR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_FLT_Type) GetCR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_FLT_Type) SetCR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_FLT_Type) GetCR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_FLT_Type) SetCR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_FLT_Type) GetCR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_FLT_Type) SetCR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_FLT_Type) GetCR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_FLT_Type) SetCR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_FLT_Type) GetCR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_FLT_Type) SetCR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x700)|value<<8)
}
func (o *DFSDM_FLT_Type) GetCR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x700) >> 8
}
func (o *DFSDM_FLT_Type) SetCR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_FLT_Type) GetCR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_FLT_Type) SetCR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_FLT_Type) GetCR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_FLT_Type) SetCR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_FLT_Type) GetCR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_FLT_Type) SetCR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_FLT_Type) GetCR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_FLT_Type) SetCR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_FLT_Type) GetCR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// DFSDM_FLT.CR2: control register 2
func (o *DFSDM_FLT_Type) SetCR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_FLT_Type) GetCR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_FLT_Type) SetCR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetCR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_FLT_Type) SetCR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_FLT_Type) GetCR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_FLT_Type) SetCR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_FLT_Type) GetCR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_FLT_Type) SetCR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_FLT_Type) GetCR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_FLT_Type) SetCR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_FLT_Type) GetCR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_FLT_Type) SetCR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_FLT_Type) GetCR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_FLT_Type) SetCR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_FLT_Type) GetCR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_FLT_Type) SetCR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_FLT_Type) GetCR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// DFSDM_FLT.ISR: interrupt and status register
func (o *DFSDM_FLT_Type) SetISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_FLT_Type) GetISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_FLT_Type) SetISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_FLT_Type) GetISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_FLT_Type) SetISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_FLT_Type) GetISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_FLT_Type) SetISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_FLT_Type) GetISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_FLT_Type) SetISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_FLT_Type) GetISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_FLT_Type) SetISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_FLT_Type) GetISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_FLT_Type) SetISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_FLT_Type) GetISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_FLT_Type) SetISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_FLT_Type) GetISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_FLT_Type) SetISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_FLT_Type) GetISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// DFSDM_FLT.ICR: interrupt flag clear register
func (o *DFSDM_FLT_Type) SetICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_FLT_Type) GetICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_FLT_Type) SetICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_FLT_Type) GetICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_FLT_Type) SetICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_FLT_Type) GetICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_FLT_Type) SetICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_FLT_Type) GetICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}

// DFSDM_FLT.JCHGR: injected channel group selection register
func (o *DFSDM_FLT_Type) SetJCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.JCHGR.Reg, volatile.LoadUint32(&o.JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_FLT_Type) GetJCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.JCHGR.Reg) & 0xff
}

// DFSDM_FLT.FCR: filter control register
func (o *DFSDM_FLT_Type) SetFCR_FORD(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_FLT_Type) GetFCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0xe0000000) >> 29
}
func (o *DFSDM_FLT_Type) SetFCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_FLT_Type) GetFCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_FLT_Type) SetFCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_FLT_Type) GetFCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0xff
}

// DFSDM_FLT.JDATAR: data register for injected group
func (o *DFSDM_FLT_Type) SetJDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.JDATAR.Reg, volatile.LoadUint32(&o.JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetJDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.JDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_FLT_Type) SetJDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.JDATAR.Reg, volatile.LoadUint32(&o.JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_FLT_Type) GetJDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.JDATAR.Reg) & 0x7
}

// DFSDM_FLT.RDATAR: data register for the regular channel
func (o *DFSDM_FLT_Type) SetRDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.RDATAR.Reg, volatile.LoadUint32(&o.RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetRDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.RDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_FLT_Type) SetRDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.RDATAR.Reg, volatile.LoadUint32(&o.RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_FLT_Type) GetRDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_FLT_Type) SetRDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.RDATAR.Reg, volatile.LoadUint32(&o.RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_FLT_Type) GetRDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.RDATAR.Reg) & 0x7
}

// DFSDM_FLT.AWHTR: analog watchdog high threshold register
func (o *DFSDM_FLT_Type) SetAWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.AWHTR.Reg, volatile.LoadUint32(&o.AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetAWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.AWHTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_FLT_Type) SetAWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.AWHTR.Reg, volatile.LoadUint32(&o.AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_FLT_Type) GetAWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.AWHTR.Reg) & 0xf
}

// DFSDM_FLT.AWLTR: analog watchdog low threshold register
func (o *DFSDM_FLT_Type) SetAWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.AWLTR.Reg, volatile.LoadUint32(&o.AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetAWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.AWLTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_FLT_Type) SetAWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.AWLTR.Reg, volatile.LoadUint32(&o.AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_FLT_Type) GetAWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.AWLTR.Reg) & 0xf
}

// DFSDM_FLT.AWSR: analog watchdog status register
func (o *DFSDM_FLT_Type) SetAWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.AWSR.Reg, volatile.LoadUint32(&o.AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetAWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.AWSR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_FLT_Type) SetAWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.AWSR.Reg, volatile.LoadUint32(&o.AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_FLT_Type) GetAWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.AWSR.Reg) & 0xff
}

// DFSDM_FLT.AWCFR: analog watchdog clear flag register
func (o *DFSDM_FLT_Type) SetAWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.AWCFR.Reg, volatile.LoadUint32(&o.AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetAWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.AWCFR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_FLT_Type) SetAWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.AWCFR.Reg, volatile.LoadUint32(&o.AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_FLT_Type) GetAWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.AWCFR.Reg) & 0xff
}

// DFSDM_FLT.EXMAX: Extremes detector maximum register
func (o *DFSDM_FLT_Type) SetEXMAX(value uint32) {
	volatile.StoreUint32(&o.EXMAX.Reg, volatile.LoadUint32(&o.EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetEXMAX() uint32 {
	return (volatile.LoadUint32(&o.EXMAX.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_FLT_Type) SetEXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.EXMAX.Reg, volatile.LoadUint32(&o.EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_FLT_Type) GetEXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.EXMAX.Reg) & 0x7
}

// DFSDM_FLT.EXMIN: Extremes detector minimum register
func (o *DFSDM_FLT_Type) SetEXMIN(value uint32) {
	volatile.StoreUint32(&o.EXMIN.Reg, volatile.LoadUint32(&o.EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_FLT_Type) GetEXMIN() uint32 {
	return (volatile.LoadUint32(&o.EXMIN.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_FLT_Type) SetEXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.EXMIN.Reg, volatile.LoadUint32(&o.EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_FLT_Type) GetEXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.EXMIN.Reg) & 0x7
}

// DFSDM_FLT.FLTCNVTIMR: conversion timer register
func (o *DFSDM_FLT_Type) SetFLTCNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.FLTCNVTIMR.Reg, volatile.LoadUint32(&o.FLTCNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_FLT_Type) GetFLTCNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.FLTCNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DMA controller
type DMA_Type struct {
	LISR  volatile.Register32 // 0x0
	HISR  volatile.Register32 // 0x4
	LIFCR volatile.Register32 // 0x8
	HIFCR volatile.Register32 // 0xC
	ST    [8]DMA_ST_Type      // 0x10
}

// DMA.LISR: low interrupt status register
func (o *DMA_Type) SetLISR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetLISR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetLISR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetLISR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetLISR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetLISR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetLISR_DMEIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetLISR_DMEIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetLISR_FEIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetLISR_FEIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetLISR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetLISR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetLISR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetLISR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetLISR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetLISR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetLISR_DMEIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetLISR_DMEIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetLISR_FEIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetLISR_FEIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetLISR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetLISR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetLISR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetLISR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetLISR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetLISR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetLISR_DMEIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetLISR_DMEIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetLISR_FEIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetLISR_FEIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetLISR_TCIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetLISR_TCIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetLISR_HTIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetLISR_HTIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetLISR_TEIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetLISR_TEIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetLISR_DMEIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetLISR_DMEIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetLISR_FEIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetLISR_FEIF0() uint32 {
	return volatile.LoadUint32(&o.LISR.Reg) & 0x1
}

// DMA.HISR: high interrupt status register
func (o *DMA_Type) SetHISR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetHISR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetHISR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetHISR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetHISR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetHISR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetHISR_DMEIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetHISR_DMEIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetHISR_FEIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetHISR_FEIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetHISR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetHISR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetHISR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetHISR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetHISR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetHISR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetHISR_DMEIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetHISR_DMEIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetHISR_FEIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetHISR_FEIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetHISR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHISR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHISR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHISR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHISR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHISR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHISR_DMEIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHISR_DMEIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHISR_FEIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHISR_FEIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHISR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHISR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHISR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHISR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHISR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHISR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHISR_DMEIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHISR_DMEIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHISR_FEIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHISR_FEIF4() uint32 {
	return volatile.LoadUint32(&o.HISR.Reg) & 0x1
}

// DMA.LIFCR: low interrupt flag clear register
func (o *DMA_Type) SetLIFCR_CTCIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetLIFCR_CTCIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetLIFCR_CHTIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetLIFCR_CHTIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetLIFCR_CTEIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetLIFCR_CTEIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetLIFCR_CDMEIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetLIFCR_CDMEIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetLIFCR_CFEIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetLIFCR_CFEIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetLIFCR_CTCIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetLIFCR_CTCIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetLIFCR_CHTIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetLIFCR_CHTIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetLIFCR_CTEIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetLIFCR_CTEIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetLIFCR_CDMEIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetLIFCR_CDMEIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetLIFCR_CFEIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetLIFCR_CFEIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetLIFCR_CTCIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetLIFCR_CTCIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetLIFCR_CHTIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetLIFCR_CHTIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetLIFCR_CTEIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetLIFCR_CTEIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetLIFCR_CDMEIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetLIFCR_CDMEIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetLIFCR_CFEIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetLIFCR_CFEIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetLIFCR_CTCIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetLIFCR_CTCIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetLIFCR_CHTIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetLIFCR_CHTIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetLIFCR_CTEIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetLIFCR_CTEIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetLIFCR_CDMEIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetLIFCR_CDMEIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetLIFCR_CFEIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetLIFCR_CFEIF0() uint32 {
	return volatile.LoadUint32(&o.LIFCR.Reg) & 0x1
}
func (o *DMA_Type) SetLIFCR_TRBUFF(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetLIFCR_TRBUFF() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x100000) >> 20
}

// DMA.HIFCR: high interrupt flag clear register
func (o *DMA_Type) SetHIFCR_CTCIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetHIFCR_CTCIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetHIFCR_CHTIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetHIFCR_CHTIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetHIFCR_CTEIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetHIFCR_CTEIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetHIFCR_CDMEIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetHIFCR_CDMEIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetHIFCR_CFEIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetHIFCR_CFEIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetHIFCR_CTCIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetHIFCR_CTCIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetHIFCR_CHTIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetHIFCR_CHTIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetHIFCR_CTEIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetHIFCR_CTEIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetHIFCR_CDMEIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetHIFCR_CDMEIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetHIFCR_CFEIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetHIFCR_CFEIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetHIFCR_CTCIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHIFCR_CTCIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHIFCR_CHTIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHIFCR_CHTIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHIFCR_CTEIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHIFCR_CTEIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHIFCR_CDMEIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHIFCR_CDMEIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHIFCR_CFEIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHIFCR_CFEIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHIFCR_CTCIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHIFCR_CTCIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHIFCR_CHTIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHIFCR_CHTIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHIFCR_CTEIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHIFCR_CTEIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHIFCR_CDMEIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHIFCR_CDMEIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHIFCR_CFEIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHIFCR_CFEIF4() uint32 {
	return volatile.LoadUint32(&o.HIFCR.Reg) & 0x1
}
func (o *DMA_Type) SetHIFCR_TRBUFF(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetHIFCR_TRBUFF() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x100000) >> 20
}

type DMA_ST_Type struct {
	CR   volatile.Register32 // 0x10
	NDTR volatile.Register32 // 0x14
	PAR  volatile.Register32 // 0x18
	M0AR volatile.Register32 // 0x1C
	M1AR volatile.Register32 // 0x20
	FCR  volatile.Register32 // 0x24
}

// DMA_ST.CR: stream x configuration register
func (o *DMA_ST_Type) SetCR_MBURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1800000)|value<<23)
}
func (o *DMA_ST_Type) GetCR_MBURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1800000) >> 23
}
func (o *DMA_ST_Type) SetCR_PBURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *DMA_ST_Type) GetCR_PBURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *DMA_ST_Type) SetCR_CT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_ST_Type) GetCR_CT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *DMA_ST_Type) SetCR_DBM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_ST_Type) GetCR_DBM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *DMA_ST_Type) SetCR_PL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA_ST_Type) GetCR_PL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *DMA_ST_Type) SetCR_PINCOS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_ST_Type) GetCR_PINCOS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *DMA_ST_Type) SetCR_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x6000)|value<<13)
}
func (o *DMA_ST_Type) GetCR_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x6000) >> 13
}
func (o *DMA_ST_Type) SetCR_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1800)|value<<11)
}
func (o *DMA_ST_Type) GetCR_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1800) >> 11
}
func (o *DMA_ST_Type) SetCR_MINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_ST_Type) GetCR_MINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *DMA_ST_Type) SetCR_PINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_ST_Type) GetCR_PINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *DMA_ST_Type) SetCR_CIRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_ST_Type) GetCR_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DMA_ST_Type) SetCR_DIR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DMA_ST_Type) GetCR_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DMA_ST_Type) SetCR_PFCTRL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_ST_Type) GetCR_PFCTRL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DMA_ST_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_ST_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DMA_ST_Type) SetCR_HTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_ST_Type) GetCR_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DMA_ST_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_ST_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA_ST_Type) SetCR_DMEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_ST_Type) GetCR_DMEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA_ST_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DMA_ST_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DMA_ST_Type) SetCR_TRBUFF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_ST_Type) GetCR_TRBUFF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}

// DMA_ST.NDTR: stream x number of data register
func (o *DMA_ST_Type) SetNDTR_NDT(value uint32) {
	volatile.StoreUint32(&o.NDTR.Reg, volatile.LoadUint32(&o.NDTR.Reg)&^(0xffff)|value)
}
func (o *DMA_ST_Type) GetNDTR_NDT() uint32 {
	return volatile.LoadUint32(&o.NDTR.Reg) & 0xffff
}

// DMA_ST.PAR: stream x peripheral address register
func (o *DMA_ST_Type) SetPAR(value uint32) {
	volatile.StoreUint32(&o.PAR.Reg, value)
}
func (o *DMA_ST_Type) GetPAR() uint32 {
	return volatile.LoadUint32(&o.PAR.Reg)
}

// DMA_ST.M0AR: stream x memory 0 address register
func (o *DMA_ST_Type) SetM0AR(value uint32) {
	volatile.StoreUint32(&o.M0AR.Reg, value)
}
func (o *DMA_ST_Type) GetM0AR() uint32 {
	return volatile.LoadUint32(&o.M0AR.Reg)
}

// DMA_ST.M1AR: stream x memory 1 address register
func (o *DMA_ST_Type) SetM1AR(value uint32) {
	volatile.StoreUint32(&o.M1AR.Reg, value)
}
func (o *DMA_ST_Type) GetM1AR() uint32 {
	return volatile.LoadUint32(&o.M1AR.Reg)
}

// DMA_ST.FCR: stream x FIFO control register
func (o *DMA_ST_Type) SetFCR_FEIE(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_ST_Type) GetFCR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x80) >> 7
}
func (o *DMA_ST_Type) SetFCR_FS(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x38)|value<<3)
}
func (o *DMA_ST_Type) GetFCR_FS() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x38) >> 3
}
func (o *DMA_ST_Type) SetFCR_DMDIS(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_ST_Type) GetFCR_DMDIS() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x4) >> 2
}
func (o *DMA_ST_Type) SetFCR_FTH(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x3)|value)
}
func (o *DMA_ST_Type) GetFCR_FTH() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0x3
}
func (o *DMA_ST_Type) SetFCR_TRBUFF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_ST_Type) GetFCR_TRBUFF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x100000) >> 20
}

// DMA2D
type DMA2D_Type struct {
	CR      volatile.Register32 // 0x0
	ISR     volatile.Register32 // 0x4
	IFCR    volatile.Register32 // 0x8
	FGMAR   volatile.Register32 // 0xC
	FGOR    volatile.Register32 // 0x10
	BGMAR   volatile.Register32 // 0x14
	BGOR    volatile.Register32 // 0x18
	FGPFCCR volatile.Register32 // 0x1C
	FGCOLR  volatile.Register32 // 0x20
	BGPFCCR volatile.Register32 // 0x24
	BGCOLR  volatile.Register32 // 0x28
	FGCMAR  volatile.Register32 // 0x2C
	BGCMAR  volatile.Register32 // 0x30
	OPFCCR  volatile.Register32 // 0x34
	OCOLR   volatile.Register32 // 0x38
	OMAR    volatile.Register32 // 0x3C
	OOR     volatile.Register32 // 0x40
	NLR     volatile.Register32 // 0x44
	LWR     volatile.Register32 // 0x48
	AMTCR   volatile.Register32 // 0x4C
}

// DMA2D.CR: DMA2D control register
func (o *DMA2D_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DMA2D_Type) SetCR_SUSP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetCR_SUSP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetCR_ABORT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetCR_ABORT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DMA2D_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DMA2D_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *DMA2D_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *DMA2D_Type) SetCR_TWIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *DMA2D_Type) GetCR_TWIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *DMA2D_Type) SetCR_CAEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *DMA2D_Type) GetCR_CAEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *DMA2D_Type) SetCR_CTCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA2D_Type) GetCR_CTCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DMA2D_Type) SetCR_CEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA2D_Type) GetCR_CEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DMA2D_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}

// DMA2D.ISR: DMA2D Interrupt Status Register
func (o *DMA2D_Type) SetISR_TEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetISR_TEIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *DMA2D_Type) SetISR_TCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetISR_TCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetISR_TWIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetISR_TWIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetISR_CAEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA2D_Type) GetISR_CAEIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DMA2D_Type) SetISR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetISR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetISR_CEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetISR_CEIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}

// DMA2D.IFCR: DMA2D interrupt flag clear register
func (o *DMA2D_Type) SetIFCR_CTEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetIFCR_CTEIF() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}
func (o *DMA2D_Type) SetIFCR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetIFCR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetIFCR_CTWIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetIFCR_CTWIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetIFCR_CAECIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA2D_Type) GetIFCR_CAECIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *DMA2D_Type) SetIFCR_CCTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetIFCR_CCTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetIFCR_CCEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetIFCR_CCEIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}

// DMA2D.FGMAR: DMA2D foreground memory address register
func (o *DMA2D_Type) SetFGMAR(value uint32) {
	volatile.StoreUint32(&o.FGMAR.Reg, value)
}
func (o *DMA2D_Type) GetFGMAR() uint32 {
	return volatile.LoadUint32(&o.FGMAR.Reg)
}

// DMA2D.FGOR: DMA2D foreground offset register
func (o *DMA2D_Type) SetFGOR_LO(value uint32) {
	volatile.StoreUint32(&o.FGOR.Reg, volatile.LoadUint32(&o.FGOR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetFGOR_LO() uint32 {
	return volatile.LoadUint32(&o.FGOR.Reg) & 0xffff
}

// DMA2D.BGMAR: DMA2D background memory address register
func (o *DMA2D_Type) SetBGMAR(value uint32) {
	volatile.StoreUint32(&o.BGMAR.Reg, value)
}
func (o *DMA2D_Type) GetBGMAR() uint32 {
	return volatile.LoadUint32(&o.BGMAR.Reg)
}

// DMA2D.BGOR: DMA2D background offset register
func (o *DMA2D_Type) SetBGOR_LO(value uint32) {
	volatile.StoreUint32(&o.BGOR.Reg, volatile.LoadUint32(&o.BGOR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetBGOR_LO() uint32 {
	return volatile.LoadUint32(&o.BGOR.Reg) & 0xffff
}

// DMA2D.FGPFCCR: DMA2D foreground PFC control register
func (o *DMA2D_Type) SetFGPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xf)|value)
}
func (o *DMA2D_Type) GetFGPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xf
}
func (o *DMA2D_Type) SetFGPFCCR_CCM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetFGPFCCR_CCM() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetFGPFCCR_START(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetFGPFCCR_START() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetFGPFCCR_CS(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGPFCCR_CS() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGPFCCR_AM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetFGPFCCR_AM() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetFGPFCCR_CSS(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA2D_Type) GetFGPFCCR_CSS() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xc0000) >> 18
}
func (o *DMA2D_Type) SetFGPFCCR_AI(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA2D_Type) GetFGPFCCR_AI() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x100000) >> 20
}
func (o *DMA2D_Type) SetFGPFCCR_RBS(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA2D_Type) GetFGPFCCR_RBS() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x200000) >> 21
}
func (o *DMA2D_Type) SetFGPFCCR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetFGPFCCR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xff000000) >> 24
}

// DMA2D.FGCOLR: DMA2D foreground color register
func (o *DMA2D_Type) SetFGCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetFGCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff
}
func (o *DMA2D_Type) SetFGCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetFGCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff0000) >> 16
}

// DMA2D.BGPFCCR: DMA2D background PFC control register
func (o *DMA2D_Type) SetBGPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xf)|value)
}
func (o *DMA2D_Type) GetBGPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xf
}
func (o *DMA2D_Type) SetBGPFCCR_CCM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetBGPFCCR_CCM() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetBGPFCCR_START(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetBGPFCCR_START() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetBGPFCCR_CS(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGPFCCR_CS() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGPFCCR_AM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetBGPFCCR_AM() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetBGPFCCR_AI(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA2D_Type) GetBGPFCCR_AI() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x100000) >> 20
}
func (o *DMA2D_Type) SetBGPFCCR_RBS(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA2D_Type) GetBGPFCCR_RBS() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x200000) >> 21
}
func (o *DMA2D_Type) SetBGPFCCR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetBGPFCCR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xff000000) >> 24
}

// DMA2D.BGCOLR: DMA2D background color register
func (o *DMA2D_Type) SetBGCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetBGCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff
}
func (o *DMA2D_Type) SetBGCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetBGCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff0000) >> 16
}

// DMA2D.FGCMAR: DMA2D foreground CLUT memory address register
func (o *DMA2D_Type) SetFGCMAR(value uint32) {
	volatile.StoreUint32(&o.FGCMAR.Reg, value)
}
func (o *DMA2D_Type) GetFGCMAR() uint32 {
	return volatile.LoadUint32(&o.FGCMAR.Reg)
}

// DMA2D.BGCMAR: DMA2D background CLUT memory address register
func (o *DMA2D_Type) SetBGCMAR(value uint32) {
	volatile.StoreUint32(&o.BGCMAR.Reg, value)
}
func (o *DMA2D_Type) GetBGCMAR() uint32 {
	return volatile.LoadUint32(&o.BGCMAR.Reg)
}

// DMA2D.OPFCCR: DMA2D output PFC control register
func (o *DMA2D_Type) SetOPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x7)|value)
}
func (o *DMA2D_Type) GetOPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.OPFCCR.Reg) & 0x7
}
func (o *DMA2D_Type) SetOPFCCR_AI(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA2D_Type) GetOPFCCR_AI() uint32 {
	return (volatile.LoadUint32(&o.OPFCCR.Reg) & 0x100000) >> 20
}
func (o *DMA2D_Type) SetOPFCCR_RBS(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA2D_Type) GetOPFCCR_RBS() uint32 {
	return (volatile.LoadUint32(&o.OPFCCR.Reg) & 0x200000) >> 21
}
func (o *DMA2D_Type) SetOPFCCR_SB(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA2D_Type) GetOPFCCR_SB() uint32 {
	return (volatile.LoadUint32(&o.OPFCCR.Reg) & 0x100) >> 8
}

// DMA2D.OCOLR: DMA2D output color register
func (o *DMA2D_Type) SetOCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetOCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.OCOLR.Reg) & 0xff
}
func (o *DMA2D_Type) SetOCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetOCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetOCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetOCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetOCOLR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetOCOLR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff000000) >> 24
}

// DMA2D.OMAR: DMA2D output memory address register
func (o *DMA2D_Type) SetOMAR(value uint32) {
	volatile.StoreUint32(&o.OMAR.Reg, value)
}
func (o *DMA2D_Type) GetOMAR() uint32 {
	return volatile.LoadUint32(&o.OMAR.Reg)
}

// DMA2D.OOR: DMA2D output offset register
func (o *DMA2D_Type) SetOOR_LO(value uint32) {
	volatile.StoreUint32(&o.OOR.Reg, volatile.LoadUint32(&o.OOR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetOOR_LO() uint32 {
	return volatile.LoadUint32(&o.OOR.Reg) & 0xffff
}

// DMA2D.NLR: DMA2D number of line register
func (o *DMA2D_Type) SetNLR_NL(value uint32) {
	volatile.StoreUint32(&o.NLR.Reg, volatile.LoadUint32(&o.NLR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetNLR_NL() uint32 {
	return volatile.LoadUint32(&o.NLR.Reg) & 0xffff
}
func (o *DMA2D_Type) SetNLR_PL(value uint32) {
	volatile.StoreUint32(&o.NLR.Reg, volatile.LoadUint32(&o.NLR.Reg)&^(0x3fff0000)|value<<16)
}
func (o *DMA2D_Type) GetNLR_PL() uint32 {
	return (volatile.LoadUint32(&o.NLR.Reg) & 0x3fff0000) >> 16
}

// DMA2D.LWR: DMA2D line watermark register
func (o *DMA2D_Type) SetLWR_LW(value uint32) {
	volatile.StoreUint32(&o.LWR.Reg, volatile.LoadUint32(&o.LWR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetLWR_LW() uint32 {
	return volatile.LoadUint32(&o.LWR.Reg) & 0xffff
}

// DMA2D.AMTCR: DMA2D AXI master timer configuration register
func (o *DMA2D_Type) SetAMTCR_EN(value uint32) {
	volatile.StoreUint32(&o.AMTCR.Reg, volatile.LoadUint32(&o.AMTCR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetAMTCR_EN() uint32 {
	return volatile.LoadUint32(&o.AMTCR.Reg) & 0x1
}
func (o *DMA2D_Type) SetAMTCR_DT(value uint32) {
	volatile.StoreUint32(&o.AMTCR.Reg, volatile.LoadUint32(&o.AMTCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetAMTCR_DT() uint32 {
	return (volatile.LoadUint32(&o.AMTCR.Reg) & 0xff00) >> 8
}

// DMAMUX
type DMAMUX_Type struct {
	CCR0  volatile.Register32 // 0x0
	CCR1  volatile.Register32 // 0x4
	CCR2  volatile.Register32 // 0x8
	CCR3  volatile.Register32 // 0xC
	CCR4  volatile.Register32 // 0x10
	CCR5  volatile.Register32 // 0x14
	CCR6  volatile.Register32 // 0x18
	CCR7  volatile.Register32 // 0x1C
	CCR8  volatile.Register32 // 0x20
	CCR9  volatile.Register32 // 0x24
	CCR10 volatile.Register32 // 0x28
	CCR11 volatile.Register32 // 0x2C
	CCR12 volatile.Register32 // 0x30
	CCR13 volatile.Register32 // 0x34
	CCR14 volatile.Register32 // 0x38
	CCR15 volatile.Register32 // 0x3C
	_     [64]byte
	CSR   volatile.Register32 // 0x80
	CFR   volatile.Register32 // 0x84
	_     [120]byte
	RGCR0 volatile.Register32 // 0x100
	RGCR1 volatile.Register32 // 0x104
	RGCR2 volatile.Register32 // 0x108
	RGCR3 volatile.Register32 // 0x10C
	RGCR4 volatile.Register32 // 0x110
	RGCR5 volatile.Register32 // 0x114
	RGCR6 volatile.Register32 // 0x118
	RGCR7 volatile.Register32 // 0x11C
	_     [32]byte
	RGSR  volatile.Register32 // 0x140
	RGCFR volatile.Register32 // 0x144
}

// DMAMUX.CCR0: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR0_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR0_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR0.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR0_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR0_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR0_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR0_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR0_SE(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR0_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR0_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR0_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR0_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR0_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR0_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR0_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR1: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR1_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR1_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR1_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR1_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR1_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR1_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR1_SE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR1_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR1_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR1_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR1_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR1_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR1_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR1_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR2: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR2_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR2_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR2_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR2_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR2_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR2_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR2_SE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR2_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR2_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR2_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR2_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR2_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR2_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR2_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR3: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR3_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR3_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR3_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR3_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR3_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR3_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR3_SE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR3_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR3_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR3_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR3_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR3_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR3_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR3_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR4: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR4_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR4_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR4_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR4_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR4_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR4_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR4_SE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR4_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR4_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR4_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR4_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR4_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR4_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR4_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR5: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR5_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR5_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR5.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR5_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR5_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR5_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR5_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR5_SE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR5_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR5_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR5_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR5_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR5_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR5_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR5_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR6: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR6_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR6_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR6.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR6_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR6_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR6_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR6_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR6_SE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR6_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR6_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR6_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR6_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR6_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR6_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR6_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR7: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR7_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR7_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR7.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR7_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR7_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR7_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR7_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR7_SE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR7_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR7_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR7_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR7_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR7_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR7_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR7_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR8: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR8_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR8_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR8.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR8_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR8_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR8.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR8_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR8_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR8.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR8_SE(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR8_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR8.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR8_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR8_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR8.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR8_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR8_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR8.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR8_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR8.Reg, volatile.LoadUint32(&o.CCR8.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR8_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR8.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR9: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR9_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR9_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR9.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR9_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR9_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR9.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR9_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR9_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR9.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR9_SE(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR9_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR9.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR9_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR9_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR9.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR9_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR9_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR9.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR9_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR9.Reg, volatile.LoadUint32(&o.CCR9.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR9_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR9.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR10: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR10_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR10_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR10.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR10_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR10_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR10.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR10_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR10_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR10.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR10_SE(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR10_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR10.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR10_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR10_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR10.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR10_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR10_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR10.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR10_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR10.Reg, volatile.LoadUint32(&o.CCR10.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR10_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR10.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR11: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR11_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR11_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR11.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR11_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR11_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR11.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR11_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR11_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR11.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR11_SE(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR11_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR11.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR11_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR11_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR11.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR11_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR11_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR11.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR11_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR11.Reg, volatile.LoadUint32(&o.CCR11.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR11_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR11.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR12: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR12_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR12_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR12.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR12_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR12_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR12.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR12_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR12_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR12.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR12_SE(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR12_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR12.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR12_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR12_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR12.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR12_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR12_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR12.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR12_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR12.Reg, volatile.LoadUint32(&o.CCR12.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR12_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR12.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR13: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR13_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR13_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR13.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR13_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR13_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR13.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR13_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR13_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR13.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR13_SE(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR13_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR13.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR13_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR13_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR13.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR13_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR13_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR13.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR13_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR13.Reg, volatile.LoadUint32(&o.CCR13.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR13_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR13.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR14: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR14_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR14_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR14.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR14_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR14_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR14.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR14_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR14_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR14.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR14_SE(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR14_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR14.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR14_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR14_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR14.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR14_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR14_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR14.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR14_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR14.Reg, volatile.LoadUint32(&o.CCR14.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR14_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR14.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CCR15: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetCCR15_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetCCR15_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.CCR15.Reg) & 0xff
}
func (o *DMAMUX_Type) SetCCR15_SOIE(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCCR15_SOIE() uint32 {
	return (volatile.LoadUint32(&o.CCR15.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCCR15_EGE(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCCR15_EGE() uint32 {
	return (volatile.LoadUint32(&o.CCR15.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCCR15_SE(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetCCR15_SE() uint32 {
	return (volatile.LoadUint32(&o.CCR15.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetCCR15_SPOL(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetCCR15_SPOL() uint32 {
	return (volatile.LoadUint32(&o.CCR15.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetCCR15_NBREQ(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetCCR15_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.CCR15.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetCCR15_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.CCR15.Reg, volatile.LoadUint32(&o.CCR15.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetCCR15_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.CCR15.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CSR: DMAMUX request line multiplexer interrupt channel status register
func (o *DMAMUX_Type) SetCSR_SOF0(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetCSR_SOF0() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *DMAMUX_Type) SetCSR_SOF1(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetCSR_SOF1() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetCSR_SOF2(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetCSR_SOF2() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetCSR_SOF3(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetCSR_SOF3() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetCSR_SOF4(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetCSR_SOF4() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetCSR_SOF5(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetCSR_SOF5() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetCSR_SOF6(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCSR_SOF6() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCSR_SOF7(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCSR_SOF7() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}
func (o *DMAMUX_Type) SetCSR_SOF8(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCSR_SOF8() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCSR_SOF9(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCSR_SOF9() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCSR_SOF10(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x400)|value<<10)
}
func (o *DMAMUX_Type) GetCSR_SOF10() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x400) >> 10
}
func (o *DMAMUX_Type) SetCSR_SOF11(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800)|value<<11)
}
func (o *DMAMUX_Type) GetCSR_SOF11() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800) >> 11
}
func (o *DMAMUX_Type) SetCSR_SOF12(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAMUX_Type) GetCSR_SOF12() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000) >> 12
}
func (o *DMAMUX_Type) SetCSR_SOF13(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAMUX_Type) GetCSR_SOF13() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000) >> 13
}
func (o *DMAMUX_Type) SetCSR_SOF14(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAMUX_Type) GetCSR_SOF14() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4000) >> 14
}
func (o *DMAMUX_Type) SetCSR_SOF15(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAMUX_Type) GetCSR_SOF15() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8000) >> 15
}

// DMAMUX.CFR: DMAMUX request line multiplexer interrupt clear flag register
func (o *DMAMUX_Type) SetCFR_CSOF0(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetCFR_CSOF0() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x1
}
func (o *DMAMUX_Type) SetCFR_CSOF1(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetCFR_CSOF1() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetCFR_CSOF2(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetCFR_CSOF2() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetCFR_CSOF3(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetCFR_CSOF3() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetCFR_CSOF4(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetCFR_CSOF4() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetCFR_CSOF5(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetCFR_CSOF5() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetCFR_CSOF6(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCFR_CSOF6() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCFR_CSOF7(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCFR_CSOF7() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x80) >> 7
}
func (o *DMAMUX_Type) SetCFR_CSOF8(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCFR_CSOF8() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCFR_CSOF9(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCFR_CSOF9() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCFR_CSOF10(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x400)|value<<10)
}
func (o *DMAMUX_Type) GetCFR_CSOF10() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x400) >> 10
}
func (o *DMAMUX_Type) SetCFR_CSOF11(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x800)|value<<11)
}
func (o *DMAMUX_Type) GetCFR_CSOF11() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x800) >> 11
}
func (o *DMAMUX_Type) SetCFR_CSOF12(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAMUX_Type) GetCFR_CSOF12() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x1000) >> 12
}
func (o *DMAMUX_Type) SetCFR_CSOF13(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAMUX_Type) GetCFR_CSOF13() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x2000) >> 13
}
func (o *DMAMUX_Type) SetCFR_CSOF14(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAMUX_Type) GetCFR_CSOF14() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x4000) >> 14
}
func (o *DMAMUX_Type) SetCFR_CSOF15(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAMUX_Type) GetCFR_CSOF15() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x8000) >> 15
}

// DMAMUX.RGCR0: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR0_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR0.Reg, volatile.LoadUint32(&o.RGCR0.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR0_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR0.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR0_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR0.Reg, volatile.LoadUint32(&o.RGCR0.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR0_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR0.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR0_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR0.Reg, volatile.LoadUint32(&o.RGCR0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR0_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR0.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR0_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR0.Reg, volatile.LoadUint32(&o.RGCR0.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR0_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR0.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR0_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR0.Reg, volatile.LoadUint32(&o.RGCR0.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR0_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR0.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR1: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR1_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR1.Reg, volatile.LoadUint32(&o.RGCR1.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR1_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR1.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR1_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR1.Reg, volatile.LoadUint32(&o.RGCR1.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR1_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR1.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR1_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR1.Reg, volatile.LoadUint32(&o.RGCR1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR1_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR1.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR1_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR1.Reg, volatile.LoadUint32(&o.RGCR1.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR1_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR1.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR1_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR1.Reg, volatile.LoadUint32(&o.RGCR1.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR1_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR1.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR2: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR2_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR2.Reg, volatile.LoadUint32(&o.RGCR2.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR2_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR2.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR2_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR2.Reg, volatile.LoadUint32(&o.RGCR2.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR2_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR2.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR2_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR2.Reg, volatile.LoadUint32(&o.RGCR2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR2_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR2.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR2_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR2.Reg, volatile.LoadUint32(&o.RGCR2.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR2_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR2.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR2_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR2.Reg, volatile.LoadUint32(&o.RGCR2.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR2_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR2.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR3: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR3_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR3.Reg, volatile.LoadUint32(&o.RGCR3.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR3_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR3.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR3_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR3.Reg, volatile.LoadUint32(&o.RGCR3.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR3_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR3.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR3_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR3.Reg, volatile.LoadUint32(&o.RGCR3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR3_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR3.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR3_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR3.Reg, volatile.LoadUint32(&o.RGCR3.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR3_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR3.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR3_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR3.Reg, volatile.LoadUint32(&o.RGCR3.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR3_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR3.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR4: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR4_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR4.Reg, volatile.LoadUint32(&o.RGCR4.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR4_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR4.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR4_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR4.Reg, volatile.LoadUint32(&o.RGCR4.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR4_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR4.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR4_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR4.Reg, volatile.LoadUint32(&o.RGCR4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR4_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR4.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR4_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR4.Reg, volatile.LoadUint32(&o.RGCR4.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR4_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR4.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR4_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR4.Reg, volatile.LoadUint32(&o.RGCR4.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR4_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR4.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR5: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR5_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR5.Reg, volatile.LoadUint32(&o.RGCR5.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR5_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR5.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR5_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR5.Reg, volatile.LoadUint32(&o.RGCR5.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR5_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR5.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR5_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR5.Reg, volatile.LoadUint32(&o.RGCR5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR5_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR5.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR5_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR5.Reg, volatile.LoadUint32(&o.RGCR5.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR5_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR5.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR5_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR5.Reg, volatile.LoadUint32(&o.RGCR5.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR5_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR5.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR6: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR6_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR6.Reg, volatile.LoadUint32(&o.RGCR6.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR6_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR6.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR6_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR6.Reg, volatile.LoadUint32(&o.RGCR6.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR6_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR6.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR6_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR6.Reg, volatile.LoadUint32(&o.RGCR6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR6_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR6.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR6_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR6.Reg, volatile.LoadUint32(&o.RGCR6.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR6_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR6.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR6_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR6.Reg, volatile.LoadUint32(&o.RGCR6.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR6_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR6.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGCR7: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRGCR7_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RGCR7.Reg, volatile.LoadUint32(&o.RGCR7.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRGCR7_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RGCR7.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRGCR7_OIE(value uint32) {
	volatile.StoreUint32(&o.RGCR7.Reg, volatile.LoadUint32(&o.RGCR7.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRGCR7_OIE() uint32 {
	return (volatile.LoadUint32(&o.RGCR7.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRGCR7_GE(value uint32) {
	volatile.StoreUint32(&o.RGCR7.Reg, volatile.LoadUint32(&o.RGCR7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRGCR7_GE() uint32 {
	return (volatile.LoadUint32(&o.RGCR7.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRGCR7_GPOL(value uint32) {
	volatile.StoreUint32(&o.RGCR7.Reg, volatile.LoadUint32(&o.RGCR7.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRGCR7_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RGCR7.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRGCR7_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RGCR7.Reg, volatile.LoadUint32(&o.RGCR7.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRGCR7_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RGCR7.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGSR: DMAMux - DMA request generator status register
func (o *DMAMUX_Type) SetRGSR_OF0(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetRGSR_OF0() uint32 {
	return volatile.LoadUint32(&o.RGSR.Reg) & 0x1
}
func (o *DMAMUX_Type) SetRGSR_OF1(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetRGSR_OF1() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetRGSR_OF2(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetRGSR_OF2() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetRGSR_OF3(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetRGSR_OF3() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetRGSR_OF4(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetRGSR_OF4() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetRGSR_OF5(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetRGSR_OF5() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetRGSR_OF6(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetRGSR_OF6() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetRGSR_OF7(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetRGSR_OF7() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x80) >> 7
}

// DMAMUX.RGCFR: DMAMux - DMA request generator clear flag register
func (o *DMAMUX_Type) SetRGCFR_COF0(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetRGCFR_COF0() uint32 {
	return volatile.LoadUint32(&o.RGCFR.Reg) & 0x1
}
func (o *DMAMUX_Type) SetRGCFR_COF1(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetRGCFR_COF1() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetRGCFR_COF2(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetRGCFR_COF2() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetRGCFR_COF3(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetRGCFR_COF3() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetRGCFR_COF4(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetRGCFR_COF4() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetRGCFR_COF5(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetRGCFR_COF5() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetRGCFR_COF6(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetRGCFR_COF6() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetRGCFR_COF7(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetRGCFR_COF7() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x80) >> 7
}

// External interrupt/event controller
type EXTI_Type struct {
	RTSR1   volatile.Register32 // 0x0
	FTSR1   volatile.Register32 // 0x4
	SWIER1  volatile.Register32 // 0x8
	D3PMR1  volatile.Register32 // 0xC
	D3PCR1L volatile.Register32 // 0x10
	D3PCR1H volatile.Register32 // 0x14
	_       [8]byte
	RTSR2   volatile.Register32 // 0x20
	FTSR2   volatile.Register32 // 0x24
	SWIER2  volatile.Register32 // 0x28
	D3PMR2  volatile.Register32 // 0x2C
	D3PCR2L volatile.Register32 // 0x30
	D3PCR2H volatile.Register32 // 0x34
	_       [8]byte
	RTSR3   volatile.Register32 // 0x40
	FTSR3   volatile.Register32 // 0x44
	SWIER3  volatile.Register32 // 0x48
	D3PMR3  volatile.Register32 // 0x4C
	_       [4]byte
	D3PCR3H volatile.Register32 // 0x54
	_       [40]byte
	CPUIMR1 volatile.Register32 // 0x80
	CPUEMR1 volatile.Register32 // 0x84
	CPUPR1  volatile.Register32 // 0x88
	_       [4]byte
	CPUIMR2 volatile.Register32 // 0x90
	CPUEMR2 volatile.Register32 // 0x94
	CPUPR2  volatile.Register32 // 0x98
	_       [4]byte
	CPUIMR3 volatile.Register32 // 0xA0
	CPUEMR3 volatile.Register32 // 0xA4
	CPUPR3  volatile.Register32 // 0xA8
}

// EXTI.RTSR1: EXTI rising trigger selection register
func (o *EXTI_Type) SetRTSR1_TR0(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRTSR1_TR0() uint32 {
	return volatile.LoadUint32(&o.RTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetRTSR1_TR1(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRTSR1_TR1() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRTSR1_TR2(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTSR1_TR2() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTSR1_TR3(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTSR1_TR3() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTSR1_TR4(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTSR1_TR4() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTSR1_TR5(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTSR1_TR5() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTSR1_TR6(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTSR1_TR6() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRTSR1_TR7(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRTSR1_TR7() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRTSR1_TR8(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRTSR1_TR8() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRTSR1_TR9(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRTSR1_TR9() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetRTSR1_TR10(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetRTSR1_TR10() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetRTSR1_TR11(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetRTSR1_TR11() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetRTSR1_TR12(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetRTSR1_TR12() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetRTSR1_TR13(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRTSR1_TR13() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetRTSR1_TR14(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetRTSR1_TR14() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetRTSR1_TR15(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetRTSR1_TR15() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetRTSR1_TR16(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetRTSR1_TR16() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetRTSR1_TR17(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetRTSR1_TR17() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetRTSR1_TR18(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetRTSR1_TR18() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetRTSR1_TR19(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetRTSR1_TR19() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetRTSR1_TR20(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetRTSR1_TR20() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetRTSR1_TR21(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetRTSR1_TR21() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200000) >> 21
}

// EXTI.FTSR1: EXTI falling trigger selection register
func (o *EXTI_Type) SetFTSR1_TR0(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFTSR1_TR0() uint32 {
	return volatile.LoadUint32(&o.FTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetFTSR1_TR1(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFTSR1_TR1() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFTSR1_TR2(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTSR1_TR2() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTSR1_TR3(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTSR1_TR3() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTSR1_TR4(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTSR1_TR4() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTSR1_TR5(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTSR1_TR5() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTSR1_TR6(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTSR1_TR6() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFTSR1_TR7(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFTSR1_TR7() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFTSR1_TR8(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFTSR1_TR8() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFTSR1_TR9(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFTSR1_TR9() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetFTSR1_TR10(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetFTSR1_TR10() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetFTSR1_TR11(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetFTSR1_TR11() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetFTSR1_TR12(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetFTSR1_TR12() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetFTSR1_TR13(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFTSR1_TR13() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetFTSR1_TR14(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetFTSR1_TR14() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetFTSR1_TR15(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetFTSR1_TR15() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetFTSR1_TR16(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetFTSR1_TR16() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetFTSR1_TR17(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetFTSR1_TR17() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetFTSR1_TR18(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetFTSR1_TR18() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetFTSR1_TR19(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetFTSR1_TR19() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetFTSR1_TR20(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetFTSR1_TR20() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetFTSR1_TR21(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetFTSR1_TR21() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200000) >> 21
}

// EXTI.SWIER1: EXTI software interrupt event register
func (o *EXTI_Type) SetSWIER1_SWIER0(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetSWIER1_SWIER0() uint32 {
	return volatile.LoadUint32(&o.SWIER1.Reg) & 0x1
}
func (o *EXTI_Type) SetSWIER1(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetSWIER1() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetSWIER1_SWIER2(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIER1_SWIER2() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIER1_SWIER3(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIER1_SWIER3() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIER1_SWIER4(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIER1_SWIER4() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIER1_SWIER5(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIER1_SWIER5() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIER1_SWIER6(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIER1_SWIER6() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetSWIER1_SWIER7(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetSWIER1_SWIER7() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetSWIER1_SWIER8(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetSWIER1_SWIER8() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetSWIER1_SWIER9(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetSWIER1_SWIER9() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetSWIER1_SWIER10(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetSWIER1_SWIER10() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetSWIER1_SWIER11(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetSWIER1_SWIER11() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetSWIER1_SWIER12(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetSWIER1_SWIER12() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetSWIER1_SWIER13(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetSWIER1_SWIER13() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetSWIER1_SWIER14(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetSWIER1_SWIER14() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetSWIER1_SWIER15(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetSWIER1_SWIER15() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetSWIER1_SWIER16(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetSWIER1_SWIER16() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetSWIER1_SWIER17(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetSWIER1_SWIER17() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetSWIER1_SWIER18(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetSWIER1_SWIER18() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetSWIER1_SWIER19(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetSWIER1_SWIER19() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetSWIER1_SWIER20(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetSWIER1_SWIER20() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetSWIER1_SWIER21(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetSWIER1_SWIER21() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200000) >> 21
}

// EXTI.D3PMR1: EXTI D3 pending mask register
func (o *EXTI_Type) SetD3PMR1_MR0(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetD3PMR1_MR0() uint32 {
	return volatile.LoadUint32(&o.D3PMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetD3PMR1_MR1(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetD3PMR1_MR1() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetD3PMR1_MR2(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetD3PMR1_MR2() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetD3PMR1_MR3(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetD3PMR1_MR3() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetD3PMR1_MR4(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetD3PMR1_MR4() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetD3PMR1_MR5(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetD3PMR1_MR5() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetD3PMR1_MR6(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetD3PMR1_MR6() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetD3PMR1_MR7(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetD3PMR1_MR7() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetD3PMR1_MR8(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetD3PMR1_MR8() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetD3PMR1_MR9(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetD3PMR1_MR9() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetD3PMR1_MR10(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetD3PMR1_MR10() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetD3PMR1_MR11(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetD3PMR1_MR11() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetD3PMR1_MR12(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetD3PMR1_MR12() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetD3PMR1_MR13(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetD3PMR1_MR13() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetD3PMR1_MR14(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetD3PMR1_MR14() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetD3PMR1_MR15(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetD3PMR1_MR15() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetD3PMR1_MR19(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetD3PMR1_MR19() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetD3PMR1_MR20(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetD3PMR1_MR20() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetD3PMR1_MR21(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetD3PMR1_MR21() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetD3PMR1_MR25(value uint32) {
	volatile.StoreUint32(&o.D3PMR1.Reg, volatile.LoadUint32(&o.D3PMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetD3PMR1_MR25() uint32 {
	return (volatile.LoadUint32(&o.D3PMR1.Reg) & 0x2000000) >> 25
}

// EXTI.D3PCR1L: EXTI D3 pending clear selection register low
func (o *EXTI_Type) SetD3PCR1L_PCS0(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x3)|value)
}
func (o *EXTI_Type) GetD3PCR1L_PCS0() uint32 {
	return volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x3
}
func (o *EXTI_Type) SetD3PCR1L_PCS1(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc)|value<<2)
}
func (o *EXTI_Type) GetD3PCR1L_PCS1() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc) >> 2
}
func (o *EXTI_Type) SetD3PCR1L_PCS2(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x30)|value<<4)
}
func (o *EXTI_Type) GetD3PCR1L_PCS2() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x30) >> 4
}
func (o *EXTI_Type) SetD3PCR1L_PCS3(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc0)|value<<6)
}
func (o *EXTI_Type) GetD3PCR1L_PCS3() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc0) >> 6
}
func (o *EXTI_Type) SetD3PCR1L_PCS4(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x300)|value<<8)
}
func (o *EXTI_Type) GetD3PCR1L_PCS4() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x300) >> 8
}
func (o *EXTI_Type) SetD3PCR1L_PCS5(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc00)|value<<10)
}
func (o *EXTI_Type) GetD3PCR1L_PCS5() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc00) >> 10
}
func (o *EXTI_Type) SetD3PCR1L_PCS6(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x3000)|value<<12)
}
func (o *EXTI_Type) GetD3PCR1L_PCS6() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x3000) >> 12
}
func (o *EXTI_Type) SetD3PCR1L_PCS7(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc000)|value<<14)
}
func (o *EXTI_Type) GetD3PCR1L_PCS7() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc000) >> 14
}
func (o *EXTI_Type) SetD3PCR1L_PCS8(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x30000)|value<<16)
}
func (o *EXTI_Type) GetD3PCR1L_PCS8() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x30000) >> 16
}
func (o *EXTI_Type) SetD3PCR1L_PCS9(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc0000)|value<<18)
}
func (o *EXTI_Type) GetD3PCR1L_PCS9() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc0000) >> 18
}
func (o *EXTI_Type) SetD3PCR1L_PCS10(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x300000)|value<<20)
}
func (o *EXTI_Type) GetD3PCR1L_PCS10() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x300000) >> 20
}
func (o *EXTI_Type) SetD3PCR1L_PCS11(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc00000)|value<<22)
}
func (o *EXTI_Type) GetD3PCR1L_PCS11() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc00000) >> 22
}
func (o *EXTI_Type) SetD3PCR1L_PCS12(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x3000000)|value<<24)
}
func (o *EXTI_Type) GetD3PCR1L_PCS12() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x3000000) >> 24
}
func (o *EXTI_Type) SetD3PCR1L_PCS13(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc000000)|value<<26)
}
func (o *EXTI_Type) GetD3PCR1L_PCS13() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc000000) >> 26
}
func (o *EXTI_Type) SetD3PCR1L_PCS14(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0x30000000)|value<<28)
}
func (o *EXTI_Type) GetD3PCR1L_PCS14() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0x30000000) >> 28
}
func (o *EXTI_Type) SetD3PCR1L_PCS15(value uint32) {
	volatile.StoreUint32(&o.D3PCR1L.Reg, volatile.LoadUint32(&o.D3PCR1L.Reg)&^(0xc0000000)|value<<30)
}
func (o *EXTI_Type) GetD3PCR1L_PCS15() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1L.Reg) & 0xc0000000) >> 30
}

// EXTI.D3PCR1H: EXTI D3 pending clear selection register high
func (o *EXTI_Type) SetD3PCR1H_PCS19(value uint32) {
	volatile.StoreUint32(&o.D3PCR1H.Reg, volatile.LoadUint32(&o.D3PCR1H.Reg)&^(0xc0)|value<<6)
}
func (o *EXTI_Type) GetD3PCR1H_PCS19() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1H.Reg) & 0xc0) >> 6
}
func (o *EXTI_Type) SetD3PCR1H_PCS20(value uint32) {
	volatile.StoreUint32(&o.D3PCR1H.Reg, volatile.LoadUint32(&o.D3PCR1H.Reg)&^(0x300)|value<<8)
}
func (o *EXTI_Type) GetD3PCR1H_PCS20() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1H.Reg) & 0x300) >> 8
}
func (o *EXTI_Type) SetD3PCR1H_PCS21(value uint32) {
	volatile.StoreUint32(&o.D3PCR1H.Reg, volatile.LoadUint32(&o.D3PCR1H.Reg)&^(0xc00)|value<<10)
}
func (o *EXTI_Type) GetD3PCR1H_PCS21() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1H.Reg) & 0xc00) >> 10
}
func (o *EXTI_Type) SetD3PCR1H_PCS25(value uint32) {
	volatile.StoreUint32(&o.D3PCR1H.Reg, volatile.LoadUint32(&o.D3PCR1H.Reg)&^(0xc0000)|value<<18)
}
func (o *EXTI_Type) GetD3PCR1H_PCS25() uint32 {
	return (volatile.LoadUint32(&o.D3PCR1H.Reg) & 0xc0000) >> 18
}

// EXTI.RTSR2: EXTI rising trigger selection register
func (o *EXTI_Type) SetRTSR2_TR49(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetRTSR2_TR49() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetRTSR2_TR51(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetRTSR2_TR51() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x80000) >> 19
}

// EXTI.FTSR2: EXTI falling trigger selection register
func (o *EXTI_Type) SetFTSR2_TR49(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetFTSR2_TR49() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetFTSR2_TR51(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetFTSR2_TR51() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x80000) >> 19
}

// EXTI.SWIER2: EXTI software interrupt event register
func (o *EXTI_Type) SetSWIER2_SWIER49(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetSWIER2_SWIER49() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetSWIER2_SWIER51(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetSWIER2_SWIER51() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x80000) >> 19
}

// EXTI.D3PMR2: EXTI D3 pending mask register
func (o *EXTI_Type) SetD3PMR2_MR34(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetD3PMR2_MR34() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetD3PMR2_MR35(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetD3PMR2_MR35() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetD3PMR2_MR41(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetD3PMR2_MR41() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetD3PMR2_MR48(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetD3PMR2_MR48() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetD3PMR2_MR49(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetD3PMR2_MR49() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetD3PMR2_MR50(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetD3PMR2_MR50() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetD3PMR2_MR51(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetD3PMR2_MR51() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetD3PMR2_MR52(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetD3PMR2_MR52() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetD3PMR2_MR53(value uint32) {
	volatile.StoreUint32(&o.D3PMR2.Reg, volatile.LoadUint32(&o.D3PMR2.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetD3PMR2_MR53() uint32 {
	return (volatile.LoadUint32(&o.D3PMR2.Reg) & 0x200000) >> 21
}

// EXTI.D3PCR2L: EXTI D3 pending clear selection register low
func (o *EXTI_Type) SetD3PCR2L_PCS35(value uint32) {
	volatile.StoreUint32(&o.D3PCR2L.Reg, volatile.LoadUint32(&o.D3PCR2L.Reg)&^(0xc0)|value<<6)
}
func (o *EXTI_Type) GetD3PCR2L_PCS35() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2L.Reg) & 0xc0) >> 6
}
func (o *EXTI_Type) SetD3PCR2L_PCS34(value uint32) {
	volatile.StoreUint32(&o.D3PCR2L.Reg, volatile.LoadUint32(&o.D3PCR2L.Reg)&^(0x30)|value<<4)
}
func (o *EXTI_Type) GetD3PCR2L_PCS34() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2L.Reg) & 0x30) >> 4
}
func (o *EXTI_Type) SetD3PCR2L_PCS41(value uint32) {
	volatile.StoreUint32(&o.D3PCR2L.Reg, volatile.LoadUint32(&o.D3PCR2L.Reg)&^(0xc0000)|value<<18)
}
func (o *EXTI_Type) GetD3PCR2L_PCS41() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2L.Reg) & 0xc0000) >> 18
}

// EXTI.D3PCR2H: EXTI D3 pending clear selection register high
func (o *EXTI_Type) SetD3PCR2H_PCS48(value uint32) {
	volatile.StoreUint32(&o.D3PCR2H.Reg, volatile.LoadUint32(&o.D3PCR2H.Reg)&^(0x3)|value)
}
func (o *EXTI_Type) GetD3PCR2H_PCS48() uint32 {
	return volatile.LoadUint32(&o.D3PCR2H.Reg) & 0x3
}
func (o *EXTI_Type) SetD3PCR2H_PCS49(value uint32) {
	volatile.StoreUint32(&o.D3PCR2H.Reg, volatile.LoadUint32(&o.D3PCR2H.Reg)&^(0xc)|value<<2)
}
func (o *EXTI_Type) GetD3PCR2H_PCS49() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2H.Reg) & 0xc) >> 2
}
func (o *EXTI_Type) SetD3PCR2H_PCS50(value uint32) {
	volatile.StoreUint32(&o.D3PCR2H.Reg, volatile.LoadUint32(&o.D3PCR2H.Reg)&^(0x30)|value<<4)
}
func (o *EXTI_Type) GetD3PCR2H_PCS50() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2H.Reg) & 0x30) >> 4
}
func (o *EXTI_Type) SetD3PCR2H_PCS51(value uint32) {
	volatile.StoreUint32(&o.D3PCR2H.Reg, volatile.LoadUint32(&o.D3PCR2H.Reg)&^(0xc0)|value<<6)
}
func (o *EXTI_Type) GetD3PCR2H_PCS51() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2H.Reg) & 0xc0) >> 6
}
func (o *EXTI_Type) SetD3PCR2H_PCS52(value uint32) {
	volatile.StoreUint32(&o.D3PCR2H.Reg, volatile.LoadUint32(&o.D3PCR2H.Reg)&^(0x300)|value<<8)
}
func (o *EXTI_Type) GetD3PCR2H_PCS52() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2H.Reg) & 0x300) >> 8
}
func (o *EXTI_Type) SetD3PCR2H_PCS53(value uint32) {
	volatile.StoreUint32(&o.D3PCR2H.Reg, volatile.LoadUint32(&o.D3PCR2H.Reg)&^(0xc00)|value<<10)
}
func (o *EXTI_Type) GetD3PCR2H_PCS53() uint32 {
	return (volatile.LoadUint32(&o.D3PCR2H.Reg) & 0xc00) >> 10
}

// EXTI.RTSR3: EXTI rising trigger selection register
func (o *EXTI_Type) SetRTSR3_TR82(value uint32) {
	volatile.StoreUint32(&o.RTSR3.Reg, volatile.LoadUint32(&o.RTSR3.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetRTSR3_TR82() uint32 {
	return (volatile.LoadUint32(&o.RTSR3.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetRTSR3_TR84(value uint32) {
	volatile.StoreUint32(&o.RTSR3.Reg, volatile.LoadUint32(&o.RTSR3.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetRTSR3_TR84() uint32 {
	return (volatile.LoadUint32(&o.RTSR3.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetRTSR3_TR85(value uint32) {
	volatile.StoreUint32(&o.RTSR3.Reg, volatile.LoadUint32(&o.RTSR3.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetRTSR3_TR85() uint32 {
	return (volatile.LoadUint32(&o.RTSR3.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetRTSR3_TR86(value uint32) {
	volatile.StoreUint32(&o.RTSR3.Reg, volatile.LoadUint32(&o.RTSR3.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetRTSR3_TR86() uint32 {
	return (volatile.LoadUint32(&o.RTSR3.Reg) & 0x400000) >> 22
}

// EXTI.FTSR3: EXTI falling trigger selection register
func (o *EXTI_Type) SetFTSR3_TR82(value uint32) {
	volatile.StoreUint32(&o.FTSR3.Reg, volatile.LoadUint32(&o.FTSR3.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetFTSR3_TR82() uint32 {
	return (volatile.LoadUint32(&o.FTSR3.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetFTSR3_TR84(value uint32) {
	volatile.StoreUint32(&o.FTSR3.Reg, volatile.LoadUint32(&o.FTSR3.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetFTSR3_TR84() uint32 {
	return (volatile.LoadUint32(&o.FTSR3.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetFTSR3_TR85(value uint32) {
	volatile.StoreUint32(&o.FTSR3.Reg, volatile.LoadUint32(&o.FTSR3.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetFTSR3_TR85() uint32 {
	return (volatile.LoadUint32(&o.FTSR3.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetFTSR3_TR86(value uint32) {
	volatile.StoreUint32(&o.FTSR3.Reg, volatile.LoadUint32(&o.FTSR3.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetFTSR3_TR86() uint32 {
	return (volatile.LoadUint32(&o.FTSR3.Reg) & 0x400000) >> 22
}

// EXTI.SWIER3: EXTI software interrupt event register
func (o *EXTI_Type) SetSWIER3_SWIER82(value uint32) {
	volatile.StoreUint32(&o.SWIER3.Reg, volatile.LoadUint32(&o.SWIER3.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetSWIER3_SWIER82() uint32 {
	return (volatile.LoadUint32(&o.SWIER3.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetSWIER3_SWIER84(value uint32) {
	volatile.StoreUint32(&o.SWIER3.Reg, volatile.LoadUint32(&o.SWIER3.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetSWIER3_SWIER84() uint32 {
	return (volatile.LoadUint32(&o.SWIER3.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetSWIER3_SWIER85(value uint32) {
	volatile.StoreUint32(&o.SWIER3.Reg, volatile.LoadUint32(&o.SWIER3.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetSWIER3_SWIER85() uint32 {
	return (volatile.LoadUint32(&o.SWIER3.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetSWIER3_SWIER86(value uint32) {
	volatile.StoreUint32(&o.SWIER3.Reg, volatile.LoadUint32(&o.SWIER3.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetSWIER3_SWIER86() uint32 {
	return (volatile.LoadUint32(&o.SWIER3.Reg) & 0x400000) >> 22
}

// EXTI.D3PMR3: EXTI D3 pending mask register
func (o *EXTI_Type) SetD3PMR3_MR88(value uint32) {
	volatile.StoreUint32(&o.D3PMR3.Reg, volatile.LoadUint32(&o.D3PMR3.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetD3PMR3_MR88() uint32 {
	return (volatile.LoadUint32(&o.D3PMR3.Reg) & 0x1000000) >> 24
}

// EXTI.D3PCR3H: EXTI D3 pending clear selection register high
func (o *EXTI_Type) SetD3PCR3H_PCS88(value uint32) {
	volatile.StoreUint32(&o.D3PCR3H.Reg, volatile.LoadUint32(&o.D3PCR3H.Reg)&^(0xc0000)|value<<18)
}
func (o *EXTI_Type) GetD3PCR3H_PCS88() uint32 {
	return (volatile.LoadUint32(&o.D3PCR3H.Reg) & 0xc0000) >> 18
}

// EXTI.CPUIMR1: EXTI interrupt mask register
func (o *EXTI_Type) SetCPUIMR1_MR0(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUIMR1_MR0() uint32 {
	return volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUIMR1_MR1(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUIMR1_MR1() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUIMR1_MR2(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUIMR1_MR2() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUIMR1_MR3(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUIMR1_MR3() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUIMR1_MR4(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUIMR1_MR4() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUIMR1_MR5(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUIMR1_MR5() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUIMR1_MR6(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUIMR1_MR6() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUIMR1_MR7(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUIMR1_MR7() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUIMR1_MR8(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUIMR1_MR8() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUIMR1_MR9(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUIMR1_MR9() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUIMR1_MR10(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUIMR1_MR10() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUIMR1_MR11(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUIMR1_MR11() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUIMR1_MR12(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUIMR1_MR12() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUIMR1_MR13(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetCPUIMR1_MR13() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetCPUIMR1_MR14(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUIMR1_MR14() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUIMR1_MR15(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUIMR1_MR15() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUIMR1_MR16(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUIMR1_MR16() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUIMR1_MR17(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetCPUIMR1_MR17() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetCPUIMR1_MR18(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUIMR1_MR18() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUIMR1_MR19(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetCPUIMR1_MR19() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetCPUIMR1_MR20(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUIMR1_MR20() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUIMR1_MR21(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUIMR1_MR21() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUIMR1_MR22(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUIMR1_MR22() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetCPUIMR1_MR23(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetCPUIMR1_MR23() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetCPUIMR1_MR24(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetCPUIMR1_MR24() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetCPUIMR1_MR25(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetCPUIMR1_MR25() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetCPUIMR1_MR26(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetCPUIMR1_MR26() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetCPUIMR1_MR27(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetCPUIMR1_MR27() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetCPUIMR1_MR28(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetCPUIMR1_MR28() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetCPUIMR1_MR29(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetCPUIMR1_MR29() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetCPUIMR1_MR30(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetCPUIMR1_MR30() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetCPUIMR1_MR31(value uint32) {
	volatile.StoreUint32(&o.CPUIMR1.Reg, volatile.LoadUint32(&o.CPUIMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetCPUIMR1_MR31() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR1.Reg) & 0x80000000) >> 31
}

// EXTI.CPUEMR1: EXTI event mask register
func (o *EXTI_Type) SetCPUEMR1_MR0(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUEMR1_MR0() uint32 {
	return volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUEMR1_MR1(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUEMR1_MR1() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUEMR1_MR2(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUEMR1_MR2() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUEMR1_MR3(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUEMR1_MR3() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUEMR1_MR4(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUEMR1_MR4() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUEMR1_MR5(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUEMR1_MR5() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUEMR1_MR6(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUEMR1_MR6() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUEMR1_MR7(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUEMR1_MR7() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUEMR1_MR8(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUEMR1_MR8() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUEMR1_MR9(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUEMR1_MR9() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUEMR1_MR10(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUEMR1_MR10() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUEMR1_MR11(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUEMR1_MR11() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUEMR1_MR12(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUEMR1_MR12() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUEMR1_MR13(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetCPUEMR1_MR13() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetCPUEMR1_MR14(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUEMR1_MR14() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUEMR1_MR15(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUEMR1_MR15() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUEMR1_MR16(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUEMR1_MR16() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUEMR1_MR17(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetCPUEMR1_MR17() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetCPUEMR1_MR18(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUEMR1_MR18() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUEMR1_MR19(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetCPUEMR1_MR19() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetCPUEMR1_MR20(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUEMR1_MR20() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUEMR1_MR21(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUEMR1_MR21() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUEMR1_MR22(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUEMR1_MR22() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetCPUEMR1_MR23(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetCPUEMR1_MR23() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetCPUEMR1_MR24(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetCPUEMR1_MR24() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetCPUEMR1_MR25(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetCPUEMR1_MR25() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetCPUEMR1_MR26(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetCPUEMR1_MR26() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetCPUEMR1_MR27(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetCPUEMR1_MR27() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetCPUEMR1_MR28(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetCPUEMR1_MR28() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetCPUEMR1_MR29(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetCPUEMR1_MR29() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetCPUEMR1_MR30(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetCPUEMR1_MR30() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetCPUEMR1_MR31(value uint32) {
	volatile.StoreUint32(&o.CPUEMR1.Reg, volatile.LoadUint32(&o.CPUEMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetCPUEMR1_MR31() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR1.Reg) & 0x80000000) >> 31
}

// EXTI.CPUPR1: EXTI pending register
func (o *EXTI_Type) SetCPUPR1_PR0(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUPR1_PR0() uint32 {
	return volatile.LoadUint32(&o.CPUPR1.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUPR1_PR1(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUPR1_PR1() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUPR1_PR2(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUPR1_PR2() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUPR1_PR3(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUPR1_PR3() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUPR1_PR4(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUPR1_PR4() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUPR1_PR5(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUPR1_PR5() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUPR1_PR6(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUPR1_PR6() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUPR1_PR7(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUPR1_PR7() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUPR1_PR8(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUPR1_PR8() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUPR1_PR9(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUPR1_PR9() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUPR1_PR10(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUPR1_PR10() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUPR1_PR11(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUPR1_PR11() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUPR1_PR12(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUPR1_PR12() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUPR1_PR13(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetCPUPR1_PR13() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetCPUPR1_PR14(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUPR1_PR14() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUPR1_PR15(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUPR1_PR15() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUPR1_PR16(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUPR1_PR16() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUPR1_PR17(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetCPUPR1_PR17() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetCPUPR1_PR18(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUPR1_PR18() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUPR1_PR19(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetCPUPR1_PR19() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetCPUPR1_PR20(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUPR1_PR20() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUPR1_PR21(value uint32) {
	volatile.StoreUint32(&o.CPUPR1.Reg, volatile.LoadUint32(&o.CPUPR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUPR1_PR21() uint32 {
	return (volatile.LoadUint32(&o.CPUPR1.Reg) & 0x200000) >> 21
}

// EXTI.CPUIMR2: EXTI interrupt mask register
func (o *EXTI_Type) SetCPUIMR2_MR0(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUIMR2_MR0() uint32 {
	return volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUIMR2_MR1(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUIMR2_MR1() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUIMR2_MR2(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUIMR2_MR2() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUIMR2_MR3(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUIMR2_MR3() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUIMR2_MR4(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUIMR2_MR4() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUIMR2_MR5(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUIMR2_MR5() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUIMR2_MR6(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUIMR2_MR6() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUIMR2_MR7(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUIMR2_MR7() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUIMR2_MR8(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUIMR2_MR8() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUIMR2_MR9(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUIMR2_MR9() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUIMR2_MR10(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUIMR2_MR10() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUIMR2_MR11(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUIMR2_MR11() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUIMR2_MR12(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUIMR2_MR12() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUIMR2_MR14(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUIMR2_MR14() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUIMR2_MR15(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUIMR2_MR15() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUIMR2_MR16(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUIMR2_MR16() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUIMR2_MR17(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetCPUIMR2_MR17() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetCPUIMR2_MR18(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUIMR2_MR18() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUIMR2_MR19(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetCPUIMR2_MR19() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetCPUIMR2_MR20(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUIMR2_MR20() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUIMR2_MR21(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUIMR2_MR21() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUIMR2_MR22(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUIMR2_MR22() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetCPUIMR2_MR23(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetCPUIMR2_MR23() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetCPUIMR2_MR24(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetCPUIMR2_MR24() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetCPUIMR2_MR25(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetCPUIMR2_MR25() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetCPUIMR2_MR26(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetCPUIMR2_MR26() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetCPUIMR2_MR27(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetCPUIMR2_MR27() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetCPUIMR2_MR28(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetCPUIMR2_MR28() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetCPUIMR2_MR29(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetCPUIMR2_MR29() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetCPUIMR2_MR30(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetCPUIMR2_MR30() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetCPUIMR2_MR31(value uint32) {
	volatile.StoreUint32(&o.CPUIMR2.Reg, volatile.LoadUint32(&o.CPUIMR2.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetCPUIMR2_MR31() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR2.Reg) & 0x80000000) >> 31
}

// EXTI.CPUEMR2: EXTI event mask register
func (o *EXTI_Type) SetCPUEMR2_MR32(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUEMR2_MR32() uint32 {
	return volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUEMR2_MR33(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUEMR2_MR33() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUEMR2_MR34(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUEMR2_MR34() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUEMR2_MR35(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUEMR2_MR35() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUEMR2_MR36(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUEMR2_MR36() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUEMR2_MR37(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUEMR2_MR37() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUEMR2_MR38(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUEMR2_MR38() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUEMR2_MR39(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUEMR2_MR39() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUEMR2_MR40(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUEMR2_MR40() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUEMR2_MR41(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUEMR2_MR41() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUEMR2_MR42(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUEMR2_MR42() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUEMR2_MR43(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUEMR2_MR43() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUEMR2_MR44(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUEMR2_MR44() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUEMR2_MR46(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUEMR2_MR46() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUEMR2_MR47(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUEMR2_MR47() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUEMR2_MR48(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUEMR2_MR48() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUEMR2_MR49(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetCPUEMR2_MR49() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetCPUEMR2_MR50(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUEMR2_MR50() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUEMR2_MR51(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetCPUEMR2_MR51() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetCPUEMR2_MR52(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUEMR2_MR52() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUEMR2_MR53(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUEMR2_MR53() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUEMR2_MR54(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUEMR2_MR54() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetCPUEMR2_MR55(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetCPUEMR2_MR55() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetCPUEMR2_MR56(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetCPUEMR2_MR56() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetCPUEMR2_MR57(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetCPUEMR2_MR57() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetCPUEMR2_MR58(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetCPUEMR2_MR58() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetCPUEMR2_MR59(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetCPUEMR2_MR59() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetCPUEMR2_MR60(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetCPUEMR2_MR60() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetCPUEMR2_MR61(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetCPUEMR2_MR61() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetCPUEMR2_MR62(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetCPUEMR2_MR62() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetCPUEMR2_MR63(value uint32) {
	volatile.StoreUint32(&o.CPUEMR2.Reg, volatile.LoadUint32(&o.CPUEMR2.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetCPUEMR2_MR63() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR2.Reg) & 0x80000000) >> 31
}

// EXTI.CPUPR2: EXTI pending register
func (o *EXTI_Type) SetCPUPR2_PR49(value uint32) {
	volatile.StoreUint32(&o.CPUPR2.Reg, volatile.LoadUint32(&o.CPUPR2.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetCPUPR2_PR49() uint32 {
	return (volatile.LoadUint32(&o.CPUPR2.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetCPUPR2_PR51(value uint32) {
	volatile.StoreUint32(&o.CPUPR2.Reg, volatile.LoadUint32(&o.CPUPR2.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetCPUPR2_PR51() uint32 {
	return (volatile.LoadUint32(&o.CPUPR2.Reg) & 0x80000) >> 19
}

// EXTI.CPUIMR3: EXTI interrupt mask register
func (o *EXTI_Type) SetCPUIMR3_MR64(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUIMR3_MR64() uint32 {
	return volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUIMR3_MR65(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUIMR3_MR65() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUIMR3_MR66(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUIMR3_MR66() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUIMR3_MR67(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUIMR3_MR67() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUIMR3_MR68(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUIMR3_MR68() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUIMR3_MR69(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUIMR3_MR69() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUIMR3_MR70(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUIMR3_MR70() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUIMR3_MR71(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUIMR3_MR71() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUIMR3_MR72(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUIMR3_MR72() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUIMR3_MR73(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUIMR3_MR73() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUIMR3_MR74(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUIMR3_MR74() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUIMR3_MR75(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUIMR3_MR75() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUIMR3_MR76(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUIMR3_MR76() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUIMR3_MR77(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetCPUIMR3_MR77() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetCPUIMR3_MR78(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUIMR3_MR78() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUIMR3_MR79(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUIMR3_MR79() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUIMR3_MR80(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUIMR3_MR80() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUIMR3_MR82(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUIMR3_MR82() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUIMR3_MR84(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUIMR3_MR84() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUIMR3_MR85(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUIMR3_MR85() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUIMR3_MR86(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUIMR3_MR86() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetCPUIMR3_MR87(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetCPUIMR3_MR87() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetCPUIMR3_MR88(value uint32) {
	volatile.StoreUint32(&o.CPUIMR3.Reg, volatile.LoadUint32(&o.CPUIMR3.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetCPUIMR3_MR88() uint32 {
	return (volatile.LoadUint32(&o.CPUIMR3.Reg) & 0x1000000) >> 24
}

// EXTI.CPUEMR3: EXTI event mask register
func (o *EXTI_Type) SetCPUEMR3_MR64(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetCPUEMR3_MR64() uint32 {
	return volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x1
}
func (o *EXTI_Type) SetCPUEMR3_MR65(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetCPUEMR3_MR65() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetCPUEMR3_MR66(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetCPUEMR3_MR66() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetCPUEMR3_MR67(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetCPUEMR3_MR67() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetCPUEMR3_MR68(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetCPUEMR3_MR68() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetCPUEMR3_MR69(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetCPUEMR3_MR69() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetCPUEMR3_MR70(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetCPUEMR3_MR70() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetCPUEMR3_MR71(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetCPUEMR3_MR71() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetCPUEMR3_MR72(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetCPUEMR3_MR72() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetCPUEMR3_MR73(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetCPUEMR3_MR73() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetCPUEMR3_MR74(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetCPUEMR3_MR74() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetCPUEMR3_MR75(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetCPUEMR3_MR75() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetCPUEMR3_MR76(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetCPUEMR3_MR76() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetCPUEMR3_MR77(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetCPUEMR3_MR77() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetCPUEMR3_MR78(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetCPUEMR3_MR78() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetCPUEMR3_MR79(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetCPUEMR3_MR79() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetCPUEMR3_MR80(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetCPUEMR3_MR80() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetCPUEMR3_MR82(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUEMR3_MR82() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUEMR3_MR84(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUEMR3_MR84() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUEMR3_MR85(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUEMR3_MR85() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUEMR3_MR86(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUEMR3_MR86() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetCPUEMR3_MR87(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetCPUEMR3_MR87() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetCPUEMR3_MR88(value uint32) {
	volatile.StoreUint32(&o.CPUEMR3.Reg, volatile.LoadUint32(&o.CPUEMR3.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetCPUEMR3_MR88() uint32 {
	return (volatile.LoadUint32(&o.CPUEMR3.Reg) & 0x1000000) >> 24
}

// EXTI.CPUPR3: EXTI pending register
func (o *EXTI_Type) SetCPUPR3_PR82(value uint32) {
	volatile.StoreUint32(&o.CPUPR3.Reg, volatile.LoadUint32(&o.CPUPR3.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetCPUPR3_PR82() uint32 {
	return (volatile.LoadUint32(&o.CPUPR3.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetCPUPR3_PR84(value uint32) {
	volatile.StoreUint32(&o.CPUPR3.Reg, volatile.LoadUint32(&o.CPUPR3.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetCPUPR3_PR84() uint32 {
	return (volatile.LoadUint32(&o.CPUPR3.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetCPUPR3_PR85(value uint32) {
	volatile.StoreUint32(&o.CPUPR3.Reg, volatile.LoadUint32(&o.CPUPR3.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetCPUPR3_PR85() uint32 {
	return (volatile.LoadUint32(&o.CPUPR3.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetCPUPR3_PR86(value uint32) {
	volatile.StoreUint32(&o.CPUPR3.Reg, volatile.LoadUint32(&o.CPUPR3.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetCPUPR3_PR86() uint32 {
	return (volatile.LoadUint32(&o.CPUPR3.Reg) & 0x400000) >> 22
}

// Ethernet: media access control (MAC)
type Ethernet_Type struct {
	MACCR                              volatile.Register32 // 0x0
	MACECR                             volatile.Register32 // 0x4
	MACPFR                             volatile.Register32 // 0x8
	MACWTR                             volatile.Register32 // 0xC
	MACHT0R                            volatile.Register32 // 0x10
	MACHT1R                            volatile.Register32 // 0x14
	_                                  [56]byte
	MACVTR                             volatile.Register32 // 0x50
	_                                  [4]byte
	MACVHTR                            volatile.Register32 // 0x58
	_                                  [4]byte
	MACVIR                             volatile.Register32 // 0x60
	MACIVIR                            volatile.Register32 // 0x64
	_                                  [8]byte
	MACQTxFCR                          volatile.Register32 // 0x70
	_                                  [28]byte
	MACRxFCR                           volatile.Register32 // 0x90
	_                                  [28]byte
	MACISR                             volatile.Register32 // 0xB0
	MACIER                             volatile.Register32 // 0xB4
	MACRxTxSR                          volatile.Register32 // 0xB8
	_                                  [4]byte
	MACPCSR                            volatile.Register32 // 0xC0
	MACRWKPFR                          volatile.Register32 // 0xC4
	_                                  [8]byte
	MACLCSR                            volatile.Register32 // 0xD0
	MACLTCR                            volatile.Register32 // 0xD4
	MACLETR                            volatile.Register32 // 0xD8
	MAC1USTCR                          volatile.Register32 // 0xDC
	_                                  [48]byte
	MACVR                              volatile.Register32 // 0x110
	MACDR                              volatile.Register32 // 0x114
	_                                  [8]byte
	MACHWF1R                           volatile.Register32 // 0x120
	MACHWF2R                           volatile.Register32 // 0x124
	_                                  [216]byte
	MACMDIOAR                          volatile.Register32 // 0x200
	MACMDIODR                          volatile.Register32 // 0x204
	_                                  [248]byte
	MACA0HR                            volatile.Register32 // 0x300
	MACA0LR                            volatile.Register32 // 0x304
	MACA1HR                            volatile.Register32 // 0x308
	MACA1LR                            volatile.Register32 // 0x30C
	MACA2HR                            volatile.Register32 // 0x310
	MACA2LR                            volatile.Register32 // 0x314
	MACA3HR                            volatile.Register32 // 0x318
	MACA3LR                            volatile.Register32 // 0x31C
	_                                  [992]byte
	MMC_CONTROL                        volatile.Register32 // 0x700
	MMC_RX_INTERRUPT                   volatile.Register32 // 0x704
	MMC_TX_INTERRUPT                   volatile.Register32 // 0x708
	MMC_RX_INTERRUPT_MASK              volatile.Register32 // 0x70C
	MMC_TX_INTERRUPT_MASK              volatile.Register32 // 0x710
	_                                  [56]byte
	TX_SINGLE_COLLISION_GOOD_PACKETS   volatile.Register32 // 0x74C
	TX_MULTIPLE_COLLISION_GOOD_PACKETS volatile.Register32 // 0x750
	_                                  [20]byte
	TX_PACKET_COUNT_GOOD               volatile.Register32 // 0x768
	_                                  [40]byte
	RX_CRC_ERROR_PACKETS               volatile.Register32 // 0x794
	RX_ALIGNMENT_ERROR_PACKETS         volatile.Register32 // 0x798
	_                                  [40]byte
	RX_UNICAST_PACKETS_GOOD            volatile.Register32 // 0x7C4
	_                                  [36]byte
	TX_LPI_USEC_CNTR                   volatile.Register32 // 0x7EC
	TX_LPI_TRAN_CNTR                   volatile.Register32 // 0x7F0
	RX_LPI_USEC_CNTR                   volatile.Register32 // 0x7F4
	RX_LPI_TRAN_CNTR                   volatile.Register32 // 0x7F8
	_                                  [260]byte
	MACL3L4C0R                         volatile.Register32 // 0x900
	MACL4A0R                           volatile.Register32 // 0x904
	_                                  [8]byte
	MACL3A00R                          volatile.Register32 // 0x910
	MACL3A10R                          volatile.Register32 // 0x914
	MACL3A20                           volatile.Register32 // 0x918
	MACL3A30                           volatile.Register32 // 0x91C
	_                                  [16]byte
	MACL3L4C1R                         volatile.Register32 // 0x930
	MACL4A1R                           volatile.Register32 // 0x934
	_                                  [8]byte
	MACL3A01R                          volatile.Register32 // 0x940
	MACL3A11R                          volatile.Register32 // 0x944
	MACL3A21R                          volatile.Register32 // 0x948
	MACL3A31R                          volatile.Register32 // 0x94C
	_                                  [400]byte
	MACARPAR                           volatile.Register32 // 0xAE0
	_                                  [28]byte
	MACTSCR                            volatile.Register32 // 0xB00
	MACSSIR                            volatile.Register32 // 0xB04
	MACSTSR                            volatile.Register32 // 0xB08
	MACSTNR                            volatile.Register32 // 0xB0C
	MACSTSUR                           volatile.Register32 // 0xB10
	MACSTNUR                           volatile.Register32 // 0xB14
	MACTSAR                            volatile.Register32 // 0xB18
	_                                  [4]byte
	MACTSSR                            volatile.Register32 // 0xB20
	_                                  [12]byte
	MACTxTSSNR                         volatile.Register32 // 0xB30
	MACTxTSSSR                         volatile.Register32 // 0xB34
	_                                  [8]byte
	MACACR                             volatile.Register32 // 0xB40
	_                                  [4]byte
	MACATSNR                           volatile.Register32 // 0xB48
	MACATSSR                           volatile.Register32 // 0xB4C
	MACTSIACR                          volatile.Register32 // 0xB50
	MACTSEACR                          volatile.Register32 // 0xB54
	MACTSICNR                          volatile.Register32 // 0xB58
	MACTSECNR                          volatile.Register32 // 0xB5C
	_                                  [16]byte
	MACPPSCR                           volatile.Register32 // 0xB70
	_                                  [12]byte
	MACPPSTTSR                         volatile.Register32 // 0xB80
	MACPPSTTNR                         volatile.Register32 // 0xB84
	MACPPSIR                           volatile.Register32 // 0xB88
	MACPPSWR                           volatile.Register32 // 0xB8C
	_                                  [48]byte
	MACPOCR                            volatile.Register32 // 0xBC0
	MACSPI0R                           volatile.Register32 // 0xBC4
	MACSPI1R                           volatile.Register32 // 0xBC8
	MACSPI2R                           volatile.Register32 // 0xBCC
	MACLMIR                            volatile.Register32 // 0xBD0
}

// Ethernet.MACCR: Operating mode configuration register
func (o *Ethernet_Type) SetMACCR_RE(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACCR_RE() uint32 {
	return volatile.LoadUint32(&o.MACCR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACCR_TE(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACCR_TE() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACCR_PRELEN(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0xc)|value<<2)
}
func (o *Ethernet_Type) GetMACCR_PRELEN() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0xc) >> 2
}
func (o *Ethernet_Type) SetMACCR_DC(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACCR_DC() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACCR_BL(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x60)|value<<5)
}
func (o *Ethernet_Type) GetMACCR_BL() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x60) >> 5
}
func (o *Ethernet_Type) SetMACCR_DR(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACCR_DR() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x100) >> 8
}
func (o *Ethernet_Type) SetMACCR_DCRS(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACCR_DCRS() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACCR_DO(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_Type) GetMACCR_DO() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x400) >> 10
}
func (o *Ethernet_Type) SetMACCR_ECRSFD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_Type) GetMACCR_ECRSFD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x800) >> 11
}
func (o *Ethernet_Type) SetMACCR_LM(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_Type) GetMACCR_LM() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_Type) SetMACCR_DM(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_Type) GetMACCR_DM() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x2000) >> 13
}
func (o *Ethernet_Type) SetMACCR_FES(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMACCR_FES() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x4000) >> 14
}
func (o *Ethernet_Type) SetMACCR_JE(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACCR_JE() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACCR_JD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMACCR_JD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMACCR_WD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACCR_WD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACCR_ACS(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACCR_ACS() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACCR_CST(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMACCR_CST() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x200000) >> 21
}
func (o *Ethernet_Type) SetMACCR_S2KP(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x400000)|value<<22)
}
func (o *Ethernet_Type) GetMACCR_S2KP() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x400000) >> 22
}
func (o *Ethernet_Type) SetMACCR_GPSLCE(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x800000)|value<<23)
}
func (o *Ethernet_Type) GetMACCR_GPSLCE() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x800000) >> 23
}
func (o *Ethernet_Type) SetMACCR_IPG(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x7000000)|value<<24)
}
func (o *Ethernet_Type) GetMACCR_IPG() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x7000000) >> 24
}
func (o *Ethernet_Type) SetMACCR_IPC(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMACCR_IPC() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x8000000) >> 27
}
func (o *Ethernet_Type) SetMACCR_SARC(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x70000000)|value<<28)
}
func (o *Ethernet_Type) GetMACCR_SARC() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x70000000) >> 28
}
func (o *Ethernet_Type) SetMACCR_ARPEN(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACCR_ARPEN() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACECR: Extended operating mode configuration register
func (o *Ethernet_Type) SetMACECR_GPSL(value uint32) {
	volatile.StoreUint32(&o.MACECR.Reg, volatile.LoadUint32(&o.MACECR.Reg)&^(0x3fff)|value)
}
func (o *Ethernet_Type) GetMACECR_GPSL() uint32 {
	return volatile.LoadUint32(&o.MACECR.Reg) & 0x3fff
}
func (o *Ethernet_Type) SetMACECR_DCRCC(value uint32) {
	volatile.StoreUint32(&o.MACECR.Reg, volatile.LoadUint32(&o.MACECR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACECR_DCRCC() uint32 {
	return (volatile.LoadUint32(&o.MACECR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACECR_SPEN(value uint32) {
	volatile.StoreUint32(&o.MACECR.Reg, volatile.LoadUint32(&o.MACECR.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMACECR_SPEN() uint32 {
	return (volatile.LoadUint32(&o.MACECR.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMACECR_USP(value uint32) {
	volatile.StoreUint32(&o.MACECR.Reg, volatile.LoadUint32(&o.MACECR.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACECR_USP() uint32 {
	return (volatile.LoadUint32(&o.MACECR.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACECR_EIPGEN(value uint32) {
	volatile.StoreUint32(&o.MACECR.Reg, volatile.LoadUint32(&o.MACECR.Reg)&^(0x1000000)|value<<24)
}
func (o *Ethernet_Type) GetMACECR_EIPGEN() uint32 {
	return (volatile.LoadUint32(&o.MACECR.Reg) & 0x1000000) >> 24
}
func (o *Ethernet_Type) SetMACECR_EIPG(value uint32) {
	volatile.StoreUint32(&o.MACECR.Reg, volatile.LoadUint32(&o.MACECR.Reg)&^(0x3e000000)|value<<25)
}
func (o *Ethernet_Type) GetMACECR_EIPG() uint32 {
	return (volatile.LoadUint32(&o.MACECR.Reg) & 0x3e000000) >> 25
}

// Ethernet.MACPFR: Packet filtering control register
func (o *Ethernet_Type) SetMACPFR_PR(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACPFR_PR() uint32 {
	return volatile.LoadUint32(&o.MACPFR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACPFR_HUC(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACPFR_HUC() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACPFR_HMC(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACPFR_HMC() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACPFR_DAIF(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACPFR_DAIF() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACPFR_PM(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACPFR_PM() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACPFR_DBF(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACPFR_DBF() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACPFR_PCF(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0xc0)|value<<6)
}
func (o *Ethernet_Type) GetMACPFR_PCF() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0xc0) >> 6
}
func (o *Ethernet_Type) SetMACPFR_SAIF(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACPFR_SAIF() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x100) >> 8
}
func (o *Ethernet_Type) SetMACPFR_SAF(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACPFR_SAF() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACPFR_HPF(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_Type) GetMACPFR_HPF() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x400) >> 10
}
func (o *Ethernet_Type) SetMACPFR_VTFE(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACPFR_VTFE() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACPFR_IPFE(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACPFR_IPFE() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACPFR_DNTU(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMACPFR_DNTU() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x200000) >> 21
}
func (o *Ethernet_Type) SetMACPFR_RA(value uint32) {
	volatile.StoreUint32(&o.MACPFR.Reg, volatile.LoadUint32(&o.MACPFR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACPFR_RA() uint32 {
	return (volatile.LoadUint32(&o.MACPFR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACWTR: Watchdog timeout register
func (o *Ethernet_Type) SetMACWTR_WTO(value uint32) {
	volatile.StoreUint32(&o.MACWTR.Reg, volatile.LoadUint32(&o.MACWTR.Reg)&^(0xf)|value)
}
func (o *Ethernet_Type) GetMACWTR_WTO() uint32 {
	return volatile.LoadUint32(&o.MACWTR.Reg) & 0xf
}
func (o *Ethernet_Type) SetMACWTR_PWE(value uint32) {
	volatile.StoreUint32(&o.MACWTR.Reg, volatile.LoadUint32(&o.MACWTR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACWTR_PWE() uint32 {
	return (volatile.LoadUint32(&o.MACWTR.Reg) & 0x100) >> 8
}

// Ethernet.MACHT0R: Hash Table 0 register
func (o *Ethernet_Type) SetMACHT0R(value uint32) {
	volatile.StoreUint32(&o.MACHT0R.Reg, value)
}
func (o *Ethernet_Type) GetMACHT0R() uint32 {
	return volatile.LoadUint32(&o.MACHT0R.Reg)
}

// Ethernet.MACHT1R: Hash Table 1 register
func (o *Ethernet_Type) SetMACHT1R(value uint32) {
	volatile.StoreUint32(&o.MACHT1R.Reg, value)
}
func (o *Ethernet_Type) GetMACHT1R() uint32 {
	return volatile.LoadUint32(&o.MACHT1R.Reg)
}

// Ethernet.MACVTR: VLAN tag register
func (o *Ethernet_Type) SetMACVTR_VL(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACVTR_VL() uint32 {
	return volatile.LoadUint32(&o.MACVTR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACVTR_ETV(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACVTR_ETV() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACVTR_VTIM(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMACVTR_VTIM() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMACVTR_ESVL(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACVTR_ESVL() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACVTR_ERSVLM(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACVTR_ERSVLM() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACVTR_DOVLTC(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACVTR_DOVLTC() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACVTR_EVLS(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x600000)|value<<21)
}
func (o *Ethernet_Type) GetMACVTR_EVLS() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x600000) >> 21
}
func (o *Ethernet_Type) SetMACVTR_EVLRXS(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x1000000)|value<<24)
}
func (o *Ethernet_Type) GetMACVTR_EVLRXS() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x1000000) >> 24
}
func (o *Ethernet_Type) SetMACVTR_VTHM(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x2000000)|value<<25)
}
func (o *Ethernet_Type) GetMACVTR_VTHM() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x2000000) >> 25
}
func (o *Ethernet_Type) SetMACVTR_EDVLP(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x4000000)|value<<26)
}
func (o *Ethernet_Type) GetMACVTR_EDVLP() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x4000000) >> 26
}
func (o *Ethernet_Type) SetMACVTR_ERIVLT(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMACVTR_ERIVLT() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x8000000) >> 27
}
func (o *Ethernet_Type) SetMACVTR_EIVLS(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x30000000)|value<<28)
}
func (o *Ethernet_Type) GetMACVTR_EIVLS() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x30000000) >> 28
}
func (o *Ethernet_Type) SetMACVTR_EIVLRXS(value uint32) {
	volatile.StoreUint32(&o.MACVTR.Reg, volatile.LoadUint32(&o.MACVTR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACVTR_EIVLRXS() uint32 {
	return (volatile.LoadUint32(&o.MACVTR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACVHTR: VLAN Hash table register
func (o *Ethernet_Type) SetMACVHTR_VLHT(value uint32) {
	volatile.StoreUint32(&o.MACVHTR.Reg, volatile.LoadUint32(&o.MACVHTR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACVHTR_VLHT() uint32 {
	return volatile.LoadUint32(&o.MACVHTR.Reg) & 0xffff
}

// Ethernet.MACVIR: VLAN inclusion register
func (o *Ethernet_Type) SetMACVIR_VLT(value uint32) {
	volatile.StoreUint32(&o.MACVIR.Reg, volatile.LoadUint32(&o.MACVIR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACVIR_VLT() uint32 {
	return volatile.LoadUint32(&o.MACVIR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACVIR_VLC(value uint32) {
	volatile.StoreUint32(&o.MACVIR.Reg, volatile.LoadUint32(&o.MACVIR.Reg)&^(0x30000)|value<<16)
}
func (o *Ethernet_Type) GetMACVIR_VLC() uint32 {
	return (volatile.LoadUint32(&o.MACVIR.Reg) & 0x30000) >> 16
}
func (o *Ethernet_Type) SetMACVIR_VLP(value uint32) {
	volatile.StoreUint32(&o.MACVIR.Reg, volatile.LoadUint32(&o.MACVIR.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACVIR_VLP() uint32 {
	return (volatile.LoadUint32(&o.MACVIR.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACVIR_CSVL(value uint32) {
	volatile.StoreUint32(&o.MACVIR.Reg, volatile.LoadUint32(&o.MACVIR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACVIR_CSVL() uint32 {
	return (volatile.LoadUint32(&o.MACVIR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACVIR_VLTI(value uint32) {
	volatile.StoreUint32(&o.MACVIR.Reg, volatile.LoadUint32(&o.MACVIR.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACVIR_VLTI() uint32 {
	return (volatile.LoadUint32(&o.MACVIR.Reg) & 0x100000) >> 20
}

// Ethernet.MACIVIR: Inner VLAN inclusion register
func (o *Ethernet_Type) SetMACIVIR_VLT(value uint32) {
	volatile.StoreUint32(&o.MACIVIR.Reg, volatile.LoadUint32(&o.MACIVIR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACIVIR_VLT() uint32 {
	return volatile.LoadUint32(&o.MACIVIR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACIVIR_VLC(value uint32) {
	volatile.StoreUint32(&o.MACIVIR.Reg, volatile.LoadUint32(&o.MACIVIR.Reg)&^(0x30000)|value<<16)
}
func (o *Ethernet_Type) GetMACIVIR_VLC() uint32 {
	return (volatile.LoadUint32(&o.MACIVIR.Reg) & 0x30000) >> 16
}
func (o *Ethernet_Type) SetMACIVIR_VLP(value uint32) {
	volatile.StoreUint32(&o.MACIVIR.Reg, volatile.LoadUint32(&o.MACIVIR.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACIVIR_VLP() uint32 {
	return (volatile.LoadUint32(&o.MACIVIR.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACIVIR_CSVL(value uint32) {
	volatile.StoreUint32(&o.MACIVIR.Reg, volatile.LoadUint32(&o.MACIVIR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACIVIR_CSVL() uint32 {
	return (volatile.LoadUint32(&o.MACIVIR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACIVIR_VLTI(value uint32) {
	volatile.StoreUint32(&o.MACIVIR.Reg, volatile.LoadUint32(&o.MACIVIR.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACIVIR_VLTI() uint32 {
	return (volatile.LoadUint32(&o.MACIVIR.Reg) & 0x100000) >> 20
}

// Ethernet.MACQTxFCR: Tx Queue flow control register
func (o *Ethernet_Type) SetMACQTxFCR_FCB_BPA(value uint32) {
	volatile.StoreUint32(&o.MACQTxFCR.Reg, volatile.LoadUint32(&o.MACQTxFCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACQTxFCR_FCB_BPA() uint32 {
	return volatile.LoadUint32(&o.MACQTxFCR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACQTxFCR_TFE(value uint32) {
	volatile.StoreUint32(&o.MACQTxFCR.Reg, volatile.LoadUint32(&o.MACQTxFCR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACQTxFCR_TFE() uint32 {
	return (volatile.LoadUint32(&o.MACQTxFCR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACQTxFCR_PLT(value uint32) {
	volatile.StoreUint32(&o.MACQTxFCR.Reg, volatile.LoadUint32(&o.MACQTxFCR.Reg)&^(0x70)|value<<4)
}
func (o *Ethernet_Type) GetMACQTxFCR_PLT() uint32 {
	return (volatile.LoadUint32(&o.MACQTxFCR.Reg) & 0x70) >> 4
}
func (o *Ethernet_Type) SetMACQTxFCR_DZPQ(value uint32) {
	volatile.StoreUint32(&o.MACQTxFCR.Reg, volatile.LoadUint32(&o.MACQTxFCR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_Type) GetMACQTxFCR_DZPQ() uint32 {
	return (volatile.LoadUint32(&o.MACQTxFCR.Reg) & 0x80) >> 7
}
func (o *Ethernet_Type) SetMACQTxFCR_PT(value uint32) {
	volatile.StoreUint32(&o.MACQTxFCR.Reg, volatile.LoadUint32(&o.MACQTxFCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACQTxFCR_PT() uint32 {
	return (volatile.LoadUint32(&o.MACQTxFCR.Reg) & 0xffff0000) >> 16
}

// Ethernet.MACRxFCR: Rx flow control register
func (o *Ethernet_Type) SetMACRxFCR_RFE(value uint32) {
	volatile.StoreUint32(&o.MACRxFCR.Reg, volatile.LoadUint32(&o.MACRxFCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACRxFCR_RFE() uint32 {
	return volatile.LoadUint32(&o.MACRxFCR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACRxFCR_UP(value uint32) {
	volatile.StoreUint32(&o.MACRxFCR.Reg, volatile.LoadUint32(&o.MACRxFCR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACRxFCR_UP() uint32 {
	return (volatile.LoadUint32(&o.MACRxFCR.Reg) & 0x2) >> 1
}

// Ethernet.MACISR: Interrupt status register
func (o *Ethernet_Type) SetMACISR_PHYIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACISR_PHYIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACISR_PMTIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACISR_PMTIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACISR_LPIIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACISR_LPIIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACISR_MMCIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACISR_MMCIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x100) >> 8
}
func (o *Ethernet_Type) SetMACISR_MMCRXIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACISR_MMCRXIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACISR_MMCTXIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_Type) GetMACISR_MMCTXIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x400) >> 10
}
func (o *Ethernet_Type) SetMACISR_TSIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_Type) GetMACISR_TSIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_Type) SetMACISR_TXSTSIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_Type) GetMACISR_TXSTSIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x2000) >> 13
}
func (o *Ethernet_Type) SetMACISR_RXSTSIS(value uint32) {
	volatile.StoreUint32(&o.MACISR.Reg, volatile.LoadUint32(&o.MACISR.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMACISR_RXSTSIS() uint32 {
	return (volatile.LoadUint32(&o.MACISR.Reg) & 0x4000) >> 14
}

// Ethernet.MACIER: Interrupt enable register
func (o *Ethernet_Type) SetMACIER_PHYIE(value uint32) {
	volatile.StoreUint32(&o.MACIER.Reg, volatile.LoadUint32(&o.MACIER.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACIER_PHYIE() uint32 {
	return (volatile.LoadUint32(&o.MACIER.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACIER_PMTIE(value uint32) {
	volatile.StoreUint32(&o.MACIER.Reg, volatile.LoadUint32(&o.MACIER.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACIER_PMTIE() uint32 {
	return (volatile.LoadUint32(&o.MACIER.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACIER_LPIIE(value uint32) {
	volatile.StoreUint32(&o.MACIER.Reg, volatile.LoadUint32(&o.MACIER.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACIER_LPIIE() uint32 {
	return (volatile.LoadUint32(&o.MACIER.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACIER_TSIE(value uint32) {
	volatile.StoreUint32(&o.MACIER.Reg, volatile.LoadUint32(&o.MACIER.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_Type) GetMACIER_TSIE() uint32 {
	return (volatile.LoadUint32(&o.MACIER.Reg) & 0x1000) >> 12
}
func (o *Ethernet_Type) SetMACIER_TXSTSIE(value uint32) {
	volatile.StoreUint32(&o.MACIER.Reg, volatile.LoadUint32(&o.MACIER.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_Type) GetMACIER_TXSTSIE() uint32 {
	return (volatile.LoadUint32(&o.MACIER.Reg) & 0x2000) >> 13
}
func (o *Ethernet_Type) SetMACIER_RXSTSIE(value uint32) {
	volatile.StoreUint32(&o.MACIER.Reg, volatile.LoadUint32(&o.MACIER.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMACIER_RXSTSIE() uint32 {
	return (volatile.LoadUint32(&o.MACIER.Reg) & 0x4000) >> 14
}

// Ethernet.MACRxTxSR: Rx Tx status register
func (o *Ethernet_Type) SetMACRxTxSR_TJT(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACRxTxSR_TJT() uint32 {
	return volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACRxTxSR_NCARR(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACRxTxSR_NCARR() uint32 {
	return (volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACRxTxSR_LCARR(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACRxTxSR_LCARR() uint32 {
	return (volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACRxTxSR_EXDEF(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACRxTxSR_EXDEF() uint32 {
	return (volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACRxTxSR_LCOL(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACRxTxSR_LCOL() uint32 {
	return (volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACRxTxSR_EXCOL(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACRxTxSR_EXCOL() uint32 {
	return (volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACRxTxSR_RWT(value uint32) {
	volatile.StoreUint32(&o.MACRxTxSR.Reg, volatile.LoadUint32(&o.MACRxTxSR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACRxTxSR_RWT() uint32 {
	return (volatile.LoadUint32(&o.MACRxTxSR.Reg) & 0x100) >> 8
}

// Ethernet.MACPCSR: PMT control status register
func (o *Ethernet_Type) SetMACPCSR_PWRDWN(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACPCSR_PWRDWN() uint32 {
	return volatile.LoadUint32(&o.MACPCSR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACPCSR_MGKPKTEN(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACPCSR_MGKPKTEN() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACPCSR_RWKPKTEN(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACPCSR_RWKPKTEN() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACPCSR_MGKPRCVD(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACPCSR_MGKPRCVD() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACPCSR_RWKPRCVD(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMACPCSR_RWKPRCVD() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMACPCSR_GLBLUCAST(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACPCSR_GLBLUCAST() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACPCSR_RWKPFE(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_Type) GetMACPCSR_RWKPFE() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x400) >> 10
}
func (o *Ethernet_Type) SetMACPCSR_RWKPTR(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x1f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACPCSR_RWKPTR() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x1f000000) >> 24
}
func (o *Ethernet_Type) SetMACPCSR_RWKFILTRST(value uint32) {
	volatile.StoreUint32(&o.MACPCSR.Reg, volatile.LoadUint32(&o.MACPCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACPCSR_RWKFILTRST() uint32 {
	return (volatile.LoadUint32(&o.MACPCSR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACRWKPFR: Remove wakeup packet filter register
func (o *Ethernet_Type) SetMACRWKPFR(value uint32) {
	volatile.StoreUint32(&o.MACRWKPFR.Reg, value)
}
func (o *Ethernet_Type) GetMACRWKPFR() uint32 {
	return volatile.LoadUint32(&o.MACRWKPFR.Reg)
}

// Ethernet.MACLCSR: LPI control status register
func (o *Ethernet_Type) SetMACLCSR_TLPIEN(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACLCSR_TLPIEN() uint32 {
	return volatile.LoadUint32(&o.MACLCSR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACLCSR_TLPIEX(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACLCSR_TLPIEX() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACLCSR_RLPIEN(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACLCSR_RLPIEN() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACLCSR_RLPIEX(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACLCSR_RLPIEX() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACLCSR_TLPIST(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACLCSR_TLPIST() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x100) >> 8
}
func (o *Ethernet_Type) SetMACLCSR_RLPIST(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACLCSR_RLPIST() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACLCSR_LPIEN(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACLCSR_LPIEN() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACLCSR_PLS(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMACLCSR_PLS() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMACLCSR_PLSEN(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACLCSR_PLSEN() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACLCSR_LPITXA(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACLCSR_LPITXA() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACLCSR_LPITE(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACLCSR_LPITE() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACLCSR_LPITCSE(value uint32) {
	volatile.StoreUint32(&o.MACLCSR.Reg, volatile.LoadUint32(&o.MACLCSR.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMACLCSR_LPITCSE() uint32 {
	return (volatile.LoadUint32(&o.MACLCSR.Reg) & 0x200000) >> 21
}

// Ethernet.MACLTCR: LPI timers control register
func (o *Ethernet_Type) SetMACLTCR_TWT(value uint32) {
	volatile.StoreUint32(&o.MACLTCR.Reg, volatile.LoadUint32(&o.MACLTCR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACLTCR_TWT() uint32 {
	return volatile.LoadUint32(&o.MACLTCR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACLTCR_LST(value uint32) {
	volatile.StoreUint32(&o.MACLTCR.Reg, volatile.LoadUint32(&o.MACLTCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACLTCR_LST() uint32 {
	return (volatile.LoadUint32(&o.MACLTCR.Reg) & 0x3ff0000) >> 16
}

// Ethernet.MACLETR: LPI entry timer register
func (o *Ethernet_Type) SetMACLETR_LPIET(value uint32) {
	volatile.StoreUint32(&o.MACLETR.Reg, volatile.LoadUint32(&o.MACLETR.Reg)&^(0xffff8)|value<<3)
}
func (o *Ethernet_Type) GetMACLETR_LPIET() uint32 {
	return (volatile.LoadUint32(&o.MACLETR.Reg) & 0xffff8) >> 3
}

// Ethernet.MAC1USTCR: 1-microsecond-tick counter register
func (o *Ethernet_Type) SetMAC1USTCR_TIC_1US_CNTR(value uint32) {
	volatile.StoreUint32(&o.MAC1USTCR.Reg, volatile.LoadUint32(&o.MAC1USTCR.Reg)&^(0xfff)|value)
}
func (o *Ethernet_Type) GetMAC1USTCR_TIC_1US_CNTR() uint32 {
	return volatile.LoadUint32(&o.MAC1USTCR.Reg) & 0xfff
}

// Ethernet.MACVR: Version register
func (o *Ethernet_Type) SetMACVR_SNPSVER(value uint32) {
	volatile.StoreUint32(&o.MACVR.Reg, volatile.LoadUint32(&o.MACVR.Reg)&^(0xff)|value)
}
func (o *Ethernet_Type) GetMACVR_SNPSVER() uint32 {
	return volatile.LoadUint32(&o.MACVR.Reg) & 0xff
}
func (o *Ethernet_Type) SetMACVR_USERVER(value uint32) {
	volatile.StoreUint32(&o.MACVR.Reg, volatile.LoadUint32(&o.MACVR.Reg)&^(0xff00)|value<<8)
}
func (o *Ethernet_Type) GetMACVR_USERVER() uint32 {
	return (volatile.LoadUint32(&o.MACVR.Reg) & 0xff00) >> 8
}

// Ethernet.MACDR: Debug register
func (o *Ethernet_Type) SetMACDR_RPESTS(value uint32) {
	volatile.StoreUint32(&o.MACDR.Reg, volatile.LoadUint32(&o.MACDR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACDR_RPESTS() uint32 {
	return volatile.LoadUint32(&o.MACDR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACDR_RFCFCSTS(value uint32) {
	volatile.StoreUint32(&o.MACDR.Reg, volatile.LoadUint32(&o.MACDR.Reg)&^(0x6)|value<<1)
}
func (o *Ethernet_Type) GetMACDR_RFCFCSTS() uint32 {
	return (volatile.LoadUint32(&o.MACDR.Reg) & 0x6) >> 1
}
func (o *Ethernet_Type) SetMACDR_TPESTS(value uint32) {
	volatile.StoreUint32(&o.MACDR.Reg, volatile.LoadUint32(&o.MACDR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACDR_TPESTS() uint32 {
	return (volatile.LoadUint32(&o.MACDR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACDR_TFCSTS(value uint32) {
	volatile.StoreUint32(&o.MACDR.Reg, volatile.LoadUint32(&o.MACDR.Reg)&^(0x60000)|value<<17)
}
func (o *Ethernet_Type) GetMACDR_TFCSTS() uint32 {
	return (volatile.LoadUint32(&o.MACDR.Reg) & 0x60000) >> 17
}

// Ethernet.MACHWF1R: HW feature 1 register
func (o *Ethernet_Type) SetMACHWF1R_RXFIFOSIZE(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x1f)|value)
}
func (o *Ethernet_Type) GetMACHWF1R_RXFIFOSIZE() uint32 {
	return volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x1f
}
func (o *Ethernet_Type) SetMACHWF1R_TXFIFOSIZE(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x7c0)|value<<6)
}
func (o *Ethernet_Type) GetMACHWF1R_TXFIFOSIZE() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x7c0) >> 6
}
func (o *Ethernet_Type) SetMACHWF1R_OSTEN(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_Type) GetMACHWF1R_OSTEN() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x800) >> 11
}
func (o *Ethernet_Type) SetMACHWF1R_PTOEN(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_Type) GetMACHWF1R_PTOEN() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x1000) >> 12
}
func (o *Ethernet_Type) SetMACHWF1R_ADVTHWORD(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_Type) GetMACHWF1R_ADVTHWORD() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x2000) >> 13
}
func (o *Ethernet_Type) SetMACHWF1R_DCBEN(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACHWF1R_DCBEN() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACHWF1R_SPHEN(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMACHWF1R_SPHEN() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMACHWF1R_TSOEN(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACHWF1R_TSOEN() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACHWF1R_DBGMEMA(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACHWF1R_DBGMEMA() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACHWF1R_AVSEL(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACHWF1R_AVSEL() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACHWF1R_HASHTBLSZ(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x3000000)|value<<24)
}
func (o *Ethernet_Type) GetMACHWF1R_HASHTBLSZ() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x3000000) >> 24
}
func (o *Ethernet_Type) SetMACHWF1R_L3L4FNUM(value uint32) {
	volatile.StoreUint32(&o.MACHWF1R.Reg, volatile.LoadUint32(&o.MACHWF1R.Reg)&^(0x78000000)|value<<27)
}
func (o *Ethernet_Type) GetMACHWF1R_L3L4FNUM() uint32 {
	return (volatile.LoadUint32(&o.MACHWF1R.Reg) & 0x78000000) >> 27
}

// Ethernet.MACHWF2R: HW feature 2 register
func (o *Ethernet_Type) SetMACHWF2R_RXQCNT(value uint32) {
	volatile.StoreUint32(&o.MACHWF2R.Reg, volatile.LoadUint32(&o.MACHWF2R.Reg)&^(0xf)|value)
}
func (o *Ethernet_Type) GetMACHWF2R_RXQCNT() uint32 {
	return volatile.LoadUint32(&o.MACHWF2R.Reg) & 0xf
}
func (o *Ethernet_Type) SetMACHWF2R_TXQCNT(value uint32) {
	volatile.StoreUint32(&o.MACHWF2R.Reg, volatile.LoadUint32(&o.MACHWF2R.Reg)&^(0x3c0)|value<<6)
}
func (o *Ethernet_Type) GetMACHWF2R_TXQCNT() uint32 {
	return (volatile.LoadUint32(&o.MACHWF2R.Reg) & 0x3c0) >> 6
}
func (o *Ethernet_Type) SetMACHWF2R_RXCHCNT(value uint32) {
	volatile.StoreUint32(&o.MACHWF2R.Reg, volatile.LoadUint32(&o.MACHWF2R.Reg)&^(0xf000)|value<<12)
}
func (o *Ethernet_Type) GetMACHWF2R_RXCHCNT() uint32 {
	return (volatile.LoadUint32(&o.MACHWF2R.Reg) & 0xf000) >> 12
}
func (o *Ethernet_Type) SetMACHWF2R_TXCHCNT(value uint32) {
	volatile.StoreUint32(&o.MACHWF2R.Reg, volatile.LoadUint32(&o.MACHWF2R.Reg)&^(0x3c0000)|value<<18)
}
func (o *Ethernet_Type) GetMACHWF2R_TXCHCNT() uint32 {
	return (volatile.LoadUint32(&o.MACHWF2R.Reg) & 0x3c0000) >> 18
}
func (o *Ethernet_Type) SetMACHWF2R_PPSOUTNUM(value uint32) {
	volatile.StoreUint32(&o.MACHWF2R.Reg, volatile.LoadUint32(&o.MACHWF2R.Reg)&^(0x7000000)|value<<24)
}
func (o *Ethernet_Type) GetMACHWF2R_PPSOUTNUM() uint32 {
	return (volatile.LoadUint32(&o.MACHWF2R.Reg) & 0x7000000) >> 24
}
func (o *Ethernet_Type) SetMACHWF2R_AUXSNAPNUM(value uint32) {
	volatile.StoreUint32(&o.MACHWF2R.Reg, volatile.LoadUint32(&o.MACHWF2R.Reg)&^(0x70000000)|value<<28)
}
func (o *Ethernet_Type) GetMACHWF2R_AUXSNAPNUM() uint32 {
	return (volatile.LoadUint32(&o.MACHWF2R.Reg) & 0x70000000) >> 28
}

// Ethernet.MACMDIOAR: MDIO address register
func (o *Ethernet_Type) SetMACMDIOAR_MB(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACMDIOAR_MB() uint32 {
	return volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACMDIOAR_C45E(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACMDIOAR_C45E() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACMDIOAR_GOC(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0xc)|value<<2)
}
func (o *Ethernet_Type) GetMACMDIOAR_GOC() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0xc) >> 2
}
func (o *Ethernet_Type) SetMACMDIOAR_SKAP(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACMDIOAR_SKAP() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACMDIOAR_CR(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0xf00)|value<<8)
}
func (o *Ethernet_Type) GetMACMDIOAR_CR() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0xf00) >> 8
}
func (o *Ethernet_Type) SetMACMDIOAR_NTC(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x7000)|value<<12)
}
func (o *Ethernet_Type) GetMACMDIOAR_NTC() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x7000) >> 12
}
func (o *Ethernet_Type) SetMACMDIOAR_RDA(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x1f0000)|value<<16)
}
func (o *Ethernet_Type) GetMACMDIOAR_RDA() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x1f0000) >> 16
}
func (o *Ethernet_Type) SetMACMDIOAR_PA(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x3e00000)|value<<21)
}
func (o *Ethernet_Type) GetMACMDIOAR_PA() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x3e00000) >> 21
}
func (o *Ethernet_Type) SetMACMDIOAR_BTB(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x4000000)|value<<26)
}
func (o *Ethernet_Type) GetMACMDIOAR_BTB() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x4000000) >> 26
}
func (o *Ethernet_Type) SetMACMDIOAR_PSE(value uint32) {
	volatile.StoreUint32(&o.MACMDIOAR.Reg, volatile.LoadUint32(&o.MACMDIOAR.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMACMDIOAR_PSE() uint32 {
	return (volatile.LoadUint32(&o.MACMDIOAR.Reg) & 0x8000000) >> 27
}

// Ethernet.MACMDIODR: MDIO data register
func (o *Ethernet_Type) SetMACMDIODR_MD(value uint32) {
	volatile.StoreUint32(&o.MACMDIODR.Reg, volatile.LoadUint32(&o.MACMDIODR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACMDIODR_MD() uint32 {
	return volatile.LoadUint32(&o.MACMDIODR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACMDIODR_RA(value uint32) {
	volatile.StoreUint32(&o.MACMDIODR.Reg, volatile.LoadUint32(&o.MACMDIODR.Reg)&^(0xffff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACMDIODR_RA() uint32 {
	return (volatile.LoadUint32(&o.MACMDIODR.Reg) & 0xffff0000) >> 16
}

// Ethernet.MACA0HR: Address 0 high register
func (o *Ethernet_Type) SetMACA0HR_ADDRHI(value uint32) {
	volatile.StoreUint32(&o.MACA0HR.Reg, volatile.LoadUint32(&o.MACA0HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA0HR_ADDRHI() uint32 {
	return volatile.LoadUint32(&o.MACA0HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA0HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA0HR.Reg, volatile.LoadUint32(&o.MACA0HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA0HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA0HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA0LR: Address 0 low register
func (o *Ethernet_Type) SetMACA0LR(value uint32) {
	volatile.StoreUint32(&o.MACA0LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA0LR() uint32 {
	return volatile.LoadUint32(&o.MACA0LR.Reg)
}

// Ethernet.MACA1HR: Address 1 high register
func (o *Ethernet_Type) SetMACA1HR_ADDRHI(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA1HR_ADDRHI() uint32 {
	return volatile.LoadUint32(&o.MACA1HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA1HR_MBC(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0x3f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACA1HR_MBC() uint32 {
	return (volatile.LoadUint32(&o.MACA1HR.Reg) & 0x3f000000) >> 24
}
func (o *Ethernet_Type) SetMACA1HR_SA(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0x40000000)|value<<30)
}
func (o *Ethernet_Type) GetMACA1HR_SA() uint32 {
	return (volatile.LoadUint32(&o.MACA1HR.Reg) & 0x40000000) >> 30
}
func (o *Ethernet_Type) SetMACA1HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA1HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA1HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA1LR: Address 1 low register
func (o *Ethernet_Type) SetMACA1LR(value uint32) {
	volatile.StoreUint32(&o.MACA1LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA1LR() uint32 {
	return volatile.LoadUint32(&o.MACA1LR.Reg)
}

// Ethernet.MACA2HR: Address 2 high register
func (o *Ethernet_Type) SetMACA2HR_ADDRHI(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA2HR_ADDRHI() uint32 {
	return volatile.LoadUint32(&o.MACA2HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA2HR_MBC(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0x3f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACA2HR_MBC() uint32 {
	return (volatile.LoadUint32(&o.MACA2HR.Reg) & 0x3f000000) >> 24
}
func (o *Ethernet_Type) SetMACA2HR_SA(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0x40000000)|value<<30)
}
func (o *Ethernet_Type) GetMACA2HR_SA() uint32 {
	return (volatile.LoadUint32(&o.MACA2HR.Reg) & 0x40000000) >> 30
}
func (o *Ethernet_Type) SetMACA2HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA2HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA2HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA2LR: Address 2 low register
func (o *Ethernet_Type) SetMACA2LR(value uint32) {
	volatile.StoreUint32(&o.MACA2LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA2LR() uint32 {
	return volatile.LoadUint32(&o.MACA2LR.Reg)
}

// Ethernet.MACA3HR: Address 3 high register
func (o *Ethernet_Type) SetMACA3HR_ADDRHI(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA3HR_ADDRHI() uint32 {
	return volatile.LoadUint32(&o.MACA3HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA3HR_MBC(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0x3f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACA3HR_MBC() uint32 {
	return (volatile.LoadUint32(&o.MACA3HR.Reg) & 0x3f000000) >> 24
}
func (o *Ethernet_Type) SetMACA3HR_SA(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0x40000000)|value<<30)
}
func (o *Ethernet_Type) GetMACA3HR_SA() uint32 {
	return (volatile.LoadUint32(&o.MACA3HR.Reg) & 0x40000000) >> 30
}
func (o *Ethernet_Type) SetMACA3HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA3HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA3HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA3LR: Address 3 low register
func (o *Ethernet_Type) SetMACA3LR(value uint32) {
	volatile.StoreUint32(&o.MACA3LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA3LR() uint32 {
	return volatile.LoadUint32(&o.MACA3LR.Reg)
}

// Ethernet.MMC_CONTROL: MMC control register
func (o *Ethernet_Type) SetMMC_CONTROL_CNTRST(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMMC_CONTROL_CNTRST() uint32 {
	return volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x1
}
func (o *Ethernet_Type) SetMMC_CONTROL_CNTSTOPRO(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMMC_CONTROL_CNTSTOPRO() uint32 {
	return (volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMMC_CONTROL_RSTONRD(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMMC_CONTROL_RSTONRD() uint32 {
	return (volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMMC_CONTROL_CNTFREEZ(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMMC_CONTROL_CNTFREEZ() uint32 {
	return (volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMMC_CONTROL_CNTPRST(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMMC_CONTROL_CNTPRST() uint32 {
	return (volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMMC_CONTROL_CNTPRSTLVL(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMMC_CONTROL_CNTPRSTLVL() uint32 {
	return (volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMMC_CONTROL_UCDBC(value uint32) {
	volatile.StoreUint32(&o.MMC_CONTROL.Reg, volatile.LoadUint32(&o.MMC_CONTROL.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMMC_CONTROL_UCDBC() uint32 {
	return (volatile.LoadUint32(&o.MMC_CONTROL.Reg) & 0x100) >> 8
}

// Ethernet.MMC_RX_INTERRUPT: MMC Rx interrupt register
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_RXCRCERPIS(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_RXCRCERPIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_RXALGNERPIS(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_RXALGNERPIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_RXUCGPIS(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_RXUCGPIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_RXLPIUSCIS(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg)&^(0x4000000)|value<<26)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_RXLPIUSCIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg) & 0x4000000) >> 26
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_RXLPITRCIS(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_RXLPITRCIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT.Reg) & 0x8000000) >> 27
}

// Ethernet.MMC_TX_INTERRUPT: MMC Tx interrupt register
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_TXSCOLGPIS(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_TXSCOLGPIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg) & 0x4000) >> 14
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_TXMCOLGPIS(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_TXMCOLGPIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg) & 0x8000) >> 15
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_TXGPKTIS(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_TXGPKTIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg) & 0x200000) >> 21
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_TXLPIUSCIS(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg)&^(0x4000000)|value<<26)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_TXLPIUSCIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg) & 0x4000000) >> 26
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_TXLPITRCIS(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_TXLPITRCIS() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT.Reg) & 0x8000000) >> 27
}

// Ethernet.MMC_RX_INTERRUPT_MASK: MMC Rx interrupt mask register
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_MASK_RXCRCERPIM(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_MASK_RXCRCERPIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_MASK_RXALGNERPIM(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_MASK_RXALGNERPIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_MASK_RXUCGPIM(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_MASK_RXUCGPIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg) & 0x20000) >> 17
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_MASK_RXLPIUSCIM(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg)&^(0x4000000)|value<<26)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_MASK_RXLPIUSCIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg) & 0x4000000) >> 26
}
func (o *Ethernet_Type) SetMMC_RX_INTERRUPT_MASK_RXLPITRCIM(value uint32) {
	volatile.StoreUint32(&o.MMC_RX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMMC_RX_INTERRUPT_MASK_RXLPITRCIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_RX_INTERRUPT_MASK.Reg) & 0x8000000) >> 27
}

// Ethernet.MMC_TX_INTERRUPT_MASK: MMC Tx interrupt mask register
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_MASK_TXSCOLGPIM(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_MASK_TXSCOLGPIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg) & 0x4000) >> 14
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_MASK_TXMCOLGPIM(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_MASK_TXMCOLGPIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg) & 0x8000) >> 15
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_MASK_TXGPKTIM(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_MASK_TXGPKTIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg) & 0x200000) >> 21
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_MASK_TXLPIUSCIM(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg)&^(0x4000000)|value<<26)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_MASK_TXLPIUSCIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg) & 0x4000000) >> 26
}
func (o *Ethernet_Type) SetMMC_TX_INTERRUPT_MASK_TXLPITRCIM(value uint32) {
	volatile.StoreUint32(&o.MMC_TX_INTERRUPT_MASK.Reg, volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_Type) GetMMC_TX_INTERRUPT_MASK_TXLPITRCIM() uint32 {
	return (volatile.LoadUint32(&o.MMC_TX_INTERRUPT_MASK.Reg) & 0x8000000) >> 27
}

// Ethernet.TX_SINGLE_COLLISION_GOOD_PACKETS: Tx single collision good packets register
func (o *Ethernet_Type) SetTX_SINGLE_COLLISION_GOOD_PACKETS(value uint32) {
	volatile.StoreUint32(&o.TX_SINGLE_COLLISION_GOOD_PACKETS.Reg, value)
}
func (o *Ethernet_Type) GetTX_SINGLE_COLLISION_GOOD_PACKETS() uint32 {
	return volatile.LoadUint32(&o.TX_SINGLE_COLLISION_GOOD_PACKETS.Reg)
}

// Ethernet.TX_MULTIPLE_COLLISION_GOOD_PACKETS: Tx multiple collision good packets register
func (o *Ethernet_Type) SetTX_MULTIPLE_COLLISION_GOOD_PACKETS(value uint32) {
	volatile.StoreUint32(&o.TX_MULTIPLE_COLLISION_GOOD_PACKETS.Reg, value)
}
func (o *Ethernet_Type) GetTX_MULTIPLE_COLLISION_GOOD_PACKETS() uint32 {
	return volatile.LoadUint32(&o.TX_MULTIPLE_COLLISION_GOOD_PACKETS.Reg)
}

// Ethernet.TX_PACKET_COUNT_GOOD: Tx packet count good register
func (o *Ethernet_Type) SetTX_PACKET_COUNT_GOOD(value uint32) {
	volatile.StoreUint32(&o.TX_PACKET_COUNT_GOOD.Reg, value)
}
func (o *Ethernet_Type) GetTX_PACKET_COUNT_GOOD() uint32 {
	return volatile.LoadUint32(&o.TX_PACKET_COUNT_GOOD.Reg)
}

// Ethernet.RX_CRC_ERROR_PACKETS: Rx CRC error packets register
func (o *Ethernet_Type) SetRX_CRC_ERROR_PACKETS(value uint32) {
	volatile.StoreUint32(&o.RX_CRC_ERROR_PACKETS.Reg, value)
}
func (o *Ethernet_Type) GetRX_CRC_ERROR_PACKETS() uint32 {
	return volatile.LoadUint32(&o.RX_CRC_ERROR_PACKETS.Reg)
}

// Ethernet.RX_ALIGNMENT_ERROR_PACKETS: Rx alignment error packets register
func (o *Ethernet_Type) SetRX_ALIGNMENT_ERROR_PACKETS(value uint32) {
	volatile.StoreUint32(&o.RX_ALIGNMENT_ERROR_PACKETS.Reg, value)
}
func (o *Ethernet_Type) GetRX_ALIGNMENT_ERROR_PACKETS() uint32 {
	return volatile.LoadUint32(&o.RX_ALIGNMENT_ERROR_PACKETS.Reg)
}

// Ethernet.RX_UNICAST_PACKETS_GOOD: Rx unicast packets good register
func (o *Ethernet_Type) SetRX_UNICAST_PACKETS_GOOD(value uint32) {
	volatile.StoreUint32(&o.RX_UNICAST_PACKETS_GOOD.Reg, value)
}
func (o *Ethernet_Type) GetRX_UNICAST_PACKETS_GOOD() uint32 {
	return volatile.LoadUint32(&o.RX_UNICAST_PACKETS_GOOD.Reg)
}

// Ethernet.TX_LPI_USEC_CNTR: Tx LPI microsecond timer register
func (o *Ethernet_Type) SetTX_LPI_USEC_CNTR(value uint32) {
	volatile.StoreUint32(&o.TX_LPI_USEC_CNTR.Reg, value)
}
func (o *Ethernet_Type) GetTX_LPI_USEC_CNTR() uint32 {
	return volatile.LoadUint32(&o.TX_LPI_USEC_CNTR.Reg)
}

// Ethernet.TX_LPI_TRAN_CNTR: Tx LPI transition counter register
func (o *Ethernet_Type) SetTX_LPI_TRAN_CNTR(value uint32) {
	volatile.StoreUint32(&o.TX_LPI_TRAN_CNTR.Reg, value)
}
func (o *Ethernet_Type) GetTX_LPI_TRAN_CNTR() uint32 {
	return volatile.LoadUint32(&o.TX_LPI_TRAN_CNTR.Reg)
}

// Ethernet.RX_LPI_USEC_CNTR: Rx LPI microsecond counter register
func (o *Ethernet_Type) SetRX_LPI_USEC_CNTR(value uint32) {
	volatile.StoreUint32(&o.RX_LPI_USEC_CNTR.Reg, value)
}
func (o *Ethernet_Type) GetRX_LPI_USEC_CNTR() uint32 {
	return volatile.LoadUint32(&o.RX_LPI_USEC_CNTR.Reg)
}

// Ethernet.RX_LPI_TRAN_CNTR: Rx LPI transition counter register
func (o *Ethernet_Type) SetRX_LPI_TRAN_CNTR(value uint32) {
	volatile.StoreUint32(&o.RX_LPI_TRAN_CNTR.Reg, value)
}
func (o *Ethernet_Type) GetRX_LPI_TRAN_CNTR() uint32 {
	return volatile.LoadUint32(&o.RX_LPI_TRAN_CNTR.Reg)
}

// Ethernet.MACL3L4C0R: L3 and L4 control 0 register
func (o *Ethernet_Type) SetMACL3L4C0R_L3PEN0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3PEN0() uint32 {
	return volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACL3L4C0R_L3SAM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3SAM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACL3L4C0R_L3SAIM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3SAIM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACL3L4C0R_L3DAM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3DAM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACL3L4C0R_L3DAIM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3DAIM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACL3L4C0R_L3HSBM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x7c0)|value<<6)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3HSBM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x7c0) >> 6
}
func (o *Ethernet_Type) SetMACL3L4C0R_L3HDBM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0xf800)|value<<11)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L3HDBM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0xf800) >> 11
}
func (o *Ethernet_Type) SetMACL3L4C0R_L4PEN0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L4PEN0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACL3L4C0R_L4SPM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L4SPM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACL3L4C0R_L4SPIM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L4SPIM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACL3L4C0R_L4DPM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L4DPM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACL3L4C0R_L4DPIM0(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C0R.Reg, volatile.LoadUint32(&o.MACL3L4C0R.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMACL3L4C0R_L4DPIM0() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C0R.Reg) & 0x200000) >> 21
}

// Ethernet.MACL4A0R: Layer4 address filter 0 register
func (o *Ethernet_Type) SetMACL4A0R_L4SP0(value uint32) {
	volatile.StoreUint32(&o.MACL4A0R.Reg, volatile.LoadUint32(&o.MACL4A0R.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACL4A0R_L4SP0() uint32 {
	return volatile.LoadUint32(&o.MACL4A0R.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACL4A0R_L4DP0(value uint32) {
	volatile.StoreUint32(&o.MACL4A0R.Reg, volatile.LoadUint32(&o.MACL4A0R.Reg)&^(0xffff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACL4A0R_L4DP0() uint32 {
	return (volatile.LoadUint32(&o.MACL4A0R.Reg) & 0xffff0000) >> 16
}

// Ethernet.MACL3A00R: MACL3A00R
func (o *Ethernet_Type) SetMACL3A00R(value uint32) {
	volatile.StoreUint32(&o.MACL3A00R.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A00R() uint32 {
	return volatile.LoadUint32(&o.MACL3A00R.Reg)
}

// Ethernet.MACL3A10R: Layer3 address 1 filter 0 register
func (o *Ethernet_Type) SetMACL3A10R(value uint32) {
	volatile.StoreUint32(&o.MACL3A10R.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A10R() uint32 {
	return volatile.LoadUint32(&o.MACL3A10R.Reg)
}

// Ethernet.MACL3A20: Layer3 Address 2 filter 0 register
func (o *Ethernet_Type) SetMACL3A20(value uint32) {
	volatile.StoreUint32(&o.MACL3A20.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A20() uint32 {
	return volatile.LoadUint32(&o.MACL3A20.Reg)
}

// Ethernet.MACL3A30: Layer3 Address 3 filter 0 register
func (o *Ethernet_Type) SetMACL3A30(value uint32) {
	volatile.StoreUint32(&o.MACL3A30.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A30() uint32 {
	return volatile.LoadUint32(&o.MACL3A30.Reg)
}

// Ethernet.MACL3L4C1R: L3 and L4 control 1 register
func (o *Ethernet_Type) SetMACL3L4C1R_L3PEN1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3PEN1() uint32 {
	return volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACL3L4C1R_L3SAM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3SAM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACL3L4C1R_L3SAIM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3SAIM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACL3L4C1R_L3DAM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3DAM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACL3L4C1R_L3DAIM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3DAIM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACL3L4C1R_L3HSBM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x7c0)|value<<6)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3HSBM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x7c0) >> 6
}
func (o *Ethernet_Type) SetMACL3L4C1R_L3HDBM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0xf800)|value<<11)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L3HDBM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0xf800) >> 11
}
func (o *Ethernet_Type) SetMACL3L4C1R_L4PEN1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L4PEN1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACL3L4C1R_L4SPM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L4SPM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACL3L4C1R_L4SPIM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L4SPIM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACL3L4C1R_L4DPM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x100000)|value<<20)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L4DPM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x100000) >> 20
}
func (o *Ethernet_Type) SetMACL3L4C1R_L4DPIM1(value uint32) {
	volatile.StoreUint32(&o.MACL3L4C1R.Reg, volatile.LoadUint32(&o.MACL3L4C1R.Reg)&^(0x200000)|value<<21)
}
func (o *Ethernet_Type) GetMACL3L4C1R_L4DPIM1() uint32 {
	return (volatile.LoadUint32(&o.MACL3L4C1R.Reg) & 0x200000) >> 21
}

// Ethernet.MACL4A1R: Layer 4 address filter 1 register
func (o *Ethernet_Type) SetMACL4A1R_L4SP1(value uint32) {
	volatile.StoreUint32(&o.MACL4A1R.Reg, volatile.LoadUint32(&o.MACL4A1R.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACL4A1R_L4SP1() uint32 {
	return volatile.LoadUint32(&o.MACL4A1R.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACL4A1R_L4DP1(value uint32) {
	volatile.StoreUint32(&o.MACL4A1R.Reg, volatile.LoadUint32(&o.MACL4A1R.Reg)&^(0xffff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACL4A1R_L4DP1() uint32 {
	return (volatile.LoadUint32(&o.MACL4A1R.Reg) & 0xffff0000) >> 16
}

// Ethernet.MACL3A01R: Layer3 address 0 filter 1 Register
func (o *Ethernet_Type) SetMACL3A01R(value uint32) {
	volatile.StoreUint32(&o.MACL3A01R.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A01R() uint32 {
	return volatile.LoadUint32(&o.MACL3A01R.Reg)
}

// Ethernet.MACL3A11R: Layer3 address 1 filter 1 register
func (o *Ethernet_Type) SetMACL3A11R(value uint32) {
	volatile.StoreUint32(&o.MACL3A11R.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A11R() uint32 {
	return volatile.LoadUint32(&o.MACL3A11R.Reg)
}

// Ethernet.MACL3A21R: Layer3 address 2 filter 1 Register
func (o *Ethernet_Type) SetMACL3A21R(value uint32) {
	volatile.StoreUint32(&o.MACL3A21R.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A21R() uint32 {
	return volatile.LoadUint32(&o.MACL3A21R.Reg)
}

// Ethernet.MACL3A31R: Layer3 address 3 filter 1 register
func (o *Ethernet_Type) SetMACL3A31R(value uint32) {
	volatile.StoreUint32(&o.MACL3A31R.Reg, value)
}
func (o *Ethernet_Type) GetMACL3A31R() uint32 {
	return volatile.LoadUint32(&o.MACL3A31R.Reg)
}

// Ethernet.MACARPAR: ARP address register
func (o *Ethernet_Type) SetMACARPAR(value uint32) {
	volatile.StoreUint32(&o.MACARPAR.Reg, value)
}
func (o *Ethernet_Type) GetMACARPAR() uint32 {
	return volatile.LoadUint32(&o.MACARPAR.Reg)
}

// Ethernet.MACTSCR: Timestamp control Register
func (o *Ethernet_Type) SetMACTSCR_TSENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACTSCR_TSENA() uint32 {
	return volatile.LoadUint32(&o.MACTSCR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACTSCR_TSCFUPDT(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACTSCR_TSCFUPDT() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACTSCR_TSINIT(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACTSCR_TSINIT() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACTSCR_TSUPDT(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACTSCR_TSUPDT() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACTSCR_TSADDREG(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACTSCR_TSADDREG() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACTSCR_TSENALL(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACTSCR_TSENALL() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x100) >> 8
}
func (o *Ethernet_Type) SetMACTSCR_TSCTRLSSR(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACTSCR_TSCTRLSSR() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACTSCR_TSVER2ENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_Type) GetMACTSCR_TSVER2ENA() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x400) >> 10
}
func (o *Ethernet_Type) SetMACTSCR_TSIPENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_Type) GetMACTSCR_TSIPENA() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x800) >> 11
}
func (o *Ethernet_Type) SetMACTSCR_TSIPV6ENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_Type) GetMACTSCR_TSIPV6ENA() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_Type) SetMACTSCR_TSIPV4ENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_Type) GetMACTSCR_TSIPV4ENA() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x2000) >> 13
}
func (o *Ethernet_Type) SetMACTSCR_TSEVNTENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMACTSCR_TSEVNTENA() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x4000) >> 14
}
func (o *Ethernet_Type) SetMACTSCR_TSMSTRENA(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_Type) GetMACTSCR_TSMSTRENA() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x8000) >> 15
}
func (o *Ethernet_Type) SetMACTSCR_SNAPTYPSEL(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x30000)|value<<16)
}
func (o *Ethernet_Type) GetMACTSCR_SNAPTYPSEL() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x30000) >> 16
}
func (o *Ethernet_Type) SetMACTSCR_TSENMACADDR(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x40000)|value<<18)
}
func (o *Ethernet_Type) GetMACTSCR_TSENMACADDR() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x40000) >> 18
}
func (o *Ethernet_Type) SetMACTSCR_CSC(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACTSCR_CSC() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACTSCR_TXTSSTSM(value uint32) {
	volatile.StoreUint32(&o.MACTSCR.Reg, volatile.LoadUint32(&o.MACTSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *Ethernet_Type) GetMACTSCR_TXTSSTSM() uint32 {
	return (volatile.LoadUint32(&o.MACTSCR.Reg) & 0x1000000) >> 24
}

// Ethernet.MACSSIR: Sub-second increment register
func (o *Ethernet_Type) SetMACSSIR_SNSINC(value uint32) {
	volatile.StoreUint32(&o.MACSSIR.Reg, volatile.LoadUint32(&o.MACSSIR.Reg)&^(0xff00)|value<<8)
}
func (o *Ethernet_Type) GetMACSSIR_SNSINC() uint32 {
	return (volatile.LoadUint32(&o.MACSSIR.Reg) & 0xff00) >> 8
}
func (o *Ethernet_Type) SetMACSSIR_SSINC(value uint32) {
	volatile.StoreUint32(&o.MACSSIR.Reg, volatile.LoadUint32(&o.MACSSIR.Reg)&^(0xff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACSSIR_SSINC() uint32 {
	return (volatile.LoadUint32(&o.MACSSIR.Reg) & 0xff0000) >> 16
}

// Ethernet.MACSTSR: System time seconds register
func (o *Ethernet_Type) SetMACSTSR(value uint32) {
	volatile.StoreUint32(&o.MACSTSR.Reg, value)
}
func (o *Ethernet_Type) GetMACSTSR() uint32 {
	return volatile.LoadUint32(&o.MACSTSR.Reg)
}

// Ethernet.MACSTNR: System time nanoseconds register
func (o *Ethernet_Type) SetMACSTNR_TSSS(value uint32) {
	volatile.StoreUint32(&o.MACSTNR.Reg, volatile.LoadUint32(&o.MACSTNR.Reg)&^(0x7fffffff)|value)
}
func (o *Ethernet_Type) GetMACSTNR_TSSS() uint32 {
	return volatile.LoadUint32(&o.MACSTNR.Reg) & 0x7fffffff
}

// Ethernet.MACSTSUR: System time seconds update register
func (o *Ethernet_Type) SetMACSTSUR(value uint32) {
	volatile.StoreUint32(&o.MACSTSUR.Reg, value)
}
func (o *Ethernet_Type) GetMACSTSUR() uint32 {
	return volatile.LoadUint32(&o.MACSTSUR.Reg)
}

// Ethernet.MACSTNUR: System time nanoseconds update register
func (o *Ethernet_Type) SetMACSTNUR_TSSS(value uint32) {
	volatile.StoreUint32(&o.MACSTNUR.Reg, volatile.LoadUint32(&o.MACSTNUR.Reg)&^(0x7fffffff)|value)
}
func (o *Ethernet_Type) GetMACSTNUR_TSSS() uint32 {
	return volatile.LoadUint32(&o.MACSTNUR.Reg) & 0x7fffffff
}
func (o *Ethernet_Type) SetMACSTNUR_ADDSUB(value uint32) {
	volatile.StoreUint32(&o.MACSTNUR.Reg, volatile.LoadUint32(&o.MACSTNUR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACSTNUR_ADDSUB() uint32 {
	return (volatile.LoadUint32(&o.MACSTNUR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACTSAR: Timestamp addend register
func (o *Ethernet_Type) SetMACTSAR(value uint32) {
	volatile.StoreUint32(&o.MACTSAR.Reg, value)
}
func (o *Ethernet_Type) GetMACTSAR() uint32 {
	return volatile.LoadUint32(&o.MACTSAR.Reg)
}

// Ethernet.MACTSSR: Timestamp status register
func (o *Ethernet_Type) SetMACTSSR_TSSOVF(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACTSSR_TSSOVF() uint32 {
	return volatile.LoadUint32(&o.MACTSSR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACTSSR_TSTARGT0(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACTSSR_TSTARGT0() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACTSSR_AUXTSTRIG(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACTSSR_AUXTSTRIG() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACTSSR_TSTRGTERR0(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACTSSR_TSTRGTERR0() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACTSSR_TXTSSIS(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_Type) GetMACTSSR_TXTSSIS() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0x8000) >> 15
}
func (o *Ethernet_Type) SetMACTSSR_ATSSTN(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0xf0000)|value<<16)
}
func (o *Ethernet_Type) GetMACTSSR_ATSSTN() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0xf0000) >> 16
}
func (o *Ethernet_Type) SetMACTSSR_ATSSTM(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x1000000)|value<<24)
}
func (o *Ethernet_Type) GetMACTSSR_ATSSTM() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0x1000000) >> 24
}
func (o *Ethernet_Type) SetMACTSSR_ATSNS(value uint32) {
	volatile.StoreUint32(&o.MACTSSR.Reg, volatile.LoadUint32(&o.MACTSSR.Reg)&^(0x3e000000)|value<<25)
}
func (o *Ethernet_Type) GetMACTSSR_ATSNS() uint32 {
	return (volatile.LoadUint32(&o.MACTSSR.Reg) & 0x3e000000) >> 25
}

// Ethernet.MACTxTSSNR: Tx timestamp status nanoseconds register
func (o *Ethernet_Type) SetMACTxTSSNR_TXTSSLO(value uint32) {
	volatile.StoreUint32(&o.MACTxTSSNR.Reg, volatile.LoadUint32(&o.MACTxTSSNR.Reg)&^(0x7fffffff)|value)
}
func (o *Ethernet_Type) GetMACTxTSSNR_TXTSSLO() uint32 {
	return volatile.LoadUint32(&o.MACTxTSSNR.Reg) & 0x7fffffff
}
func (o *Ethernet_Type) SetMACTxTSSNR_TXTSSMIS(value uint32) {
	volatile.StoreUint32(&o.MACTxTSSNR.Reg, volatile.LoadUint32(&o.MACTxTSSNR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACTxTSSNR_TXTSSMIS() uint32 {
	return (volatile.LoadUint32(&o.MACTxTSSNR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACTxTSSSR: Tx timestamp status seconds register
func (o *Ethernet_Type) SetMACTxTSSSR(value uint32) {
	volatile.StoreUint32(&o.MACTxTSSSR.Reg, value)
}
func (o *Ethernet_Type) GetMACTxTSSSR() uint32 {
	return volatile.LoadUint32(&o.MACTxTSSSR.Reg)
}

// Ethernet.MACACR: Auxiliary control register
func (o *Ethernet_Type) SetMACACR_ATSFC(value uint32) {
	volatile.StoreUint32(&o.MACACR.Reg, volatile.LoadUint32(&o.MACACR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACACR_ATSFC() uint32 {
	return volatile.LoadUint32(&o.MACACR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACACR_ATSEN0(value uint32) {
	volatile.StoreUint32(&o.MACACR.Reg, volatile.LoadUint32(&o.MACACR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACACR_ATSEN0() uint32 {
	return (volatile.LoadUint32(&o.MACACR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACACR_ATSEN1(value uint32) {
	volatile.StoreUint32(&o.MACACR.Reg, volatile.LoadUint32(&o.MACACR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACACR_ATSEN1() uint32 {
	return (volatile.LoadUint32(&o.MACACR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACACR_ATSEN2(value uint32) {
	volatile.StoreUint32(&o.MACACR.Reg, volatile.LoadUint32(&o.MACACR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMACACR_ATSEN2() uint32 {
	return (volatile.LoadUint32(&o.MACACR.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMACACR_ATSEN3(value uint32) {
	volatile.StoreUint32(&o.MACACR.Reg, volatile.LoadUint32(&o.MACACR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_Type) GetMACACR_ATSEN3() uint32 {
	return (volatile.LoadUint32(&o.MACACR.Reg) & 0x80) >> 7
}

// Ethernet.MACATSNR: Auxiliary timestamp nanoseconds register
func (o *Ethernet_Type) SetMACATSNR_AUXTSLO(value uint32) {
	volatile.StoreUint32(&o.MACATSNR.Reg, volatile.LoadUint32(&o.MACATSNR.Reg)&^(0x7fffffff)|value)
}
func (o *Ethernet_Type) GetMACATSNR_AUXTSLO() uint32 {
	return volatile.LoadUint32(&o.MACATSNR.Reg) & 0x7fffffff
}

// Ethernet.MACATSSR: Auxiliary timestamp seconds register
func (o *Ethernet_Type) SetMACATSSR(value uint32) {
	volatile.StoreUint32(&o.MACATSSR.Reg, value)
}
func (o *Ethernet_Type) GetMACATSSR() uint32 {
	return volatile.LoadUint32(&o.MACATSSR.Reg)
}

// Ethernet.MACTSIACR: Timestamp Ingress asymmetric correction register
func (o *Ethernet_Type) SetMACTSIACR(value uint32) {
	volatile.StoreUint32(&o.MACTSIACR.Reg, value)
}
func (o *Ethernet_Type) GetMACTSIACR() uint32 {
	return volatile.LoadUint32(&o.MACTSIACR.Reg)
}

// Ethernet.MACTSEACR: Timestamp Egress asymmetric correction register
func (o *Ethernet_Type) SetMACTSEACR(value uint32) {
	volatile.StoreUint32(&o.MACTSEACR.Reg, value)
}
func (o *Ethernet_Type) GetMACTSEACR() uint32 {
	return volatile.LoadUint32(&o.MACTSEACR.Reg)
}

// Ethernet.MACTSICNR: Timestamp Ingress correction nanosecond register
func (o *Ethernet_Type) SetMACTSICNR(value uint32) {
	volatile.StoreUint32(&o.MACTSICNR.Reg, value)
}
func (o *Ethernet_Type) GetMACTSICNR() uint32 {
	return volatile.LoadUint32(&o.MACTSICNR.Reg)
}

// Ethernet.MACTSECNR: Timestamp Egress correction nanosecond register
func (o *Ethernet_Type) SetMACTSECNR(value uint32) {
	volatile.StoreUint32(&o.MACTSECNR.Reg, value)
}
func (o *Ethernet_Type) GetMACTSECNR() uint32 {
	return volatile.LoadUint32(&o.MACTSECNR.Reg)
}

// Ethernet.MACPPSCR: PPS control register
func (o *Ethernet_Type) SetMACPPSCR_PPSCTRL(value uint32) {
	volatile.StoreUint32(&o.MACPPSCR.Reg, volatile.LoadUint32(&o.MACPPSCR.Reg)&^(0xf)|value)
}
func (o *Ethernet_Type) GetMACPPSCR_PPSCTRL() uint32 {
	return volatile.LoadUint32(&o.MACPPSCR.Reg) & 0xf
}
func (o *Ethernet_Type) SetMACPPSCR_PPSEN0(value uint32) {
	volatile.StoreUint32(&o.MACPPSCR.Reg, volatile.LoadUint32(&o.MACPPSCR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACPPSCR_PPSEN0() uint32 {
	return (volatile.LoadUint32(&o.MACPPSCR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACPPSCR_TRGTMODSEL0(value uint32) {
	volatile.StoreUint32(&o.MACPPSCR.Reg, volatile.LoadUint32(&o.MACPPSCR.Reg)&^(0x60)|value<<5)
}
func (o *Ethernet_Type) GetMACPPSCR_TRGTMODSEL0() uint32 {
	return (volatile.LoadUint32(&o.MACPPSCR.Reg) & 0x60) >> 5
}

// Ethernet.MACPPSTTSR: PPS target time seconds register
func (o *Ethernet_Type) SetMACPPSTTSR_TSTRH0(value uint32) {
	volatile.StoreUint32(&o.MACPPSTTSR.Reg, volatile.LoadUint32(&o.MACPPSTTSR.Reg)&^(0x7fffffff)|value)
}
func (o *Ethernet_Type) GetMACPPSTTSR_TSTRH0() uint32 {
	return volatile.LoadUint32(&o.MACPPSTTSR.Reg) & 0x7fffffff
}

// Ethernet.MACPPSTTNR: PPS target time nanoseconds register
func (o *Ethernet_Type) SetMACPPSTTNR_TTSL0(value uint32) {
	volatile.StoreUint32(&o.MACPPSTTNR.Reg, volatile.LoadUint32(&o.MACPPSTTNR.Reg)&^(0x7fffffff)|value)
}
func (o *Ethernet_Type) GetMACPPSTTNR_TTSL0() uint32 {
	return volatile.LoadUint32(&o.MACPPSTTNR.Reg) & 0x7fffffff
}
func (o *Ethernet_Type) SetMACPPSTTNR_TRGTBUSY0(value uint32) {
	volatile.StoreUint32(&o.MACPPSTTNR.Reg, volatile.LoadUint32(&o.MACPPSTTNR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACPPSTTNR_TRGTBUSY0() uint32 {
	return (volatile.LoadUint32(&o.MACPPSTTNR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACPPSIR: PPS interval register
func (o *Ethernet_Type) SetMACPPSIR(value uint32) {
	volatile.StoreUint32(&o.MACPPSIR.Reg, value)
}
func (o *Ethernet_Type) GetMACPPSIR() uint32 {
	return volatile.LoadUint32(&o.MACPPSIR.Reg)
}

// Ethernet.MACPPSWR: PPS width register
func (o *Ethernet_Type) SetMACPPSWR(value uint32) {
	volatile.StoreUint32(&o.MACPPSWR.Reg, value)
}
func (o *Ethernet_Type) GetMACPPSWR() uint32 {
	return volatile.LoadUint32(&o.MACPPSWR.Reg)
}

// Ethernet.MACPOCR: PTP Offload control register
func (o *Ethernet_Type) SetMACPOCR_PTOEN(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACPOCR_PTOEN() uint32 {
	return volatile.LoadUint32(&o.MACPOCR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACPOCR_ASYNCEN(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACPOCR_ASYNCEN() uint32 {
	return (volatile.LoadUint32(&o.MACPOCR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACPOCR_APDREQEN(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACPOCR_APDREQEN() uint32 {
	return (volatile.LoadUint32(&o.MACPOCR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACPOCR_ASYNCTRIG(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACPOCR_ASYNCTRIG() uint32 {
	return (volatile.LoadUint32(&o.MACPOCR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACPOCR_APDREQTRIG(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACPOCR_APDREQTRIG() uint32 {
	return (volatile.LoadUint32(&o.MACPOCR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACPOCR_DRRDIS(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMACPOCR_DRRDIS() uint32 {
	return (volatile.LoadUint32(&o.MACPOCR.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMACPOCR_DN(value uint32) {
	volatile.StoreUint32(&o.MACPOCR.Reg, volatile.LoadUint32(&o.MACPOCR.Reg)&^(0xff00)|value<<8)
}
func (o *Ethernet_Type) GetMACPOCR_DN() uint32 {
	return (volatile.LoadUint32(&o.MACPOCR.Reg) & 0xff00) >> 8
}

// Ethernet.MACSPI0R: PTP Source Port Identity 0 Register
func (o *Ethernet_Type) SetMACSPI0R(value uint32) {
	volatile.StoreUint32(&o.MACSPI0R.Reg, value)
}
func (o *Ethernet_Type) GetMACSPI0R() uint32 {
	return volatile.LoadUint32(&o.MACSPI0R.Reg)
}

// Ethernet.MACSPI1R: PTP Source port identity 1 register
func (o *Ethernet_Type) SetMACSPI1R(value uint32) {
	volatile.StoreUint32(&o.MACSPI1R.Reg, value)
}
func (o *Ethernet_Type) GetMACSPI1R() uint32 {
	return volatile.LoadUint32(&o.MACSPI1R.Reg)
}

// Ethernet.MACSPI2R: PTP Source port identity 2 register
func (o *Ethernet_Type) SetMACSPI2R_SPI2(value uint32) {
	volatile.StoreUint32(&o.MACSPI2R.Reg, volatile.LoadUint32(&o.MACSPI2R.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACSPI2R_SPI2() uint32 {
	return volatile.LoadUint32(&o.MACSPI2R.Reg) & 0xffff
}

// Ethernet.MACLMIR: Log message interval register
func (o *Ethernet_Type) SetMACLMIR_LSI(value uint32) {
	volatile.StoreUint32(&o.MACLMIR.Reg, volatile.LoadUint32(&o.MACLMIR.Reg)&^(0xff)|value)
}
func (o *Ethernet_Type) GetMACLMIR_LSI() uint32 {
	return volatile.LoadUint32(&o.MACLMIR.Reg) & 0xff
}
func (o *Ethernet_Type) SetMACLMIR_DRSYNCR(value uint32) {
	volatile.StoreUint32(&o.MACLMIR.Reg, volatile.LoadUint32(&o.MACLMIR.Reg)&^(0x700)|value<<8)
}
func (o *Ethernet_Type) GetMACLMIR_DRSYNCR() uint32 {
	return (volatile.LoadUint32(&o.MACLMIR.Reg) & 0x700) >> 8
}
func (o *Ethernet_Type) SetMACLMIR_LMPDRI(value uint32) {
	volatile.StoreUint32(&o.MACLMIR.Reg, volatile.LoadUint32(&o.MACLMIR.Reg)&^(0xff000000)|value<<24)
}
func (o *Ethernet_Type) GetMACLMIR_LMPDRI() uint32 {
	return (volatile.LoadUint32(&o.MACLMIR.Reg) & 0xff000000) >> 24
}

// FMC
type FMC_Type struct {
	BCR1   volatile.Register32 // 0x0
	BTR1   volatile.Register32 // 0x4
	BCR2   volatile.Register32 // 0x8
	BTR2   volatile.Register32 // 0xC
	BCR3   volatile.Register32 // 0x10
	BTR3   volatile.Register32 // 0x14
	BCR4   volatile.Register32 // 0x18
	BTR4   volatile.Register32 // 0x1C
	_      [96]byte
	PCR    volatile.Register32 // 0x80
	SR     volatile.Register32 // 0x84
	PMEM   volatile.Register32 // 0x88
	PATT   volatile.Register32 // 0x8C
	_      [4]byte
	ECCR   volatile.Register32 // 0x94
	_      [108]byte
	BWTR1  volatile.Register32 // 0x104
	_      [4]byte
	BWTR2  volatile.Register32 // 0x10C
	_      [4]byte
	BWTR3  volatile.Register32 // 0x114
	_      [4]byte
	BWTR4  volatile.Register32 // 0x11C
	_      [32]byte
	SDBANK [2]FMC_SDBANK_Type // 0x140
	_      [8]byte
	SDCMR  volatile.Register32 // 0x150
	SDRTR  volatile.Register32 // 0x154
	SDSR   volatile.Register32 // 0x158
}

// FMC.BCR1: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
func (o *FMC_Type) SetBCR1_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR1_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR1.Reg) & 0x1
}
func (o *FMC_Type) SetBCR1_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR1_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR1_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR1_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR1_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR1_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR1_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR1_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR1_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR1_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR1_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR1_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR1_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR1_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR1_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR1_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR1_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR1_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR1_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR1_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR1_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR1_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR1_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x70000)|value<<16)
}
func (o *FMC_Type) GetBCR1_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x70000) >> 16
}
func (o *FMC_Type) SetBCR1_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR1_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR1_CCLKEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetBCR1_CCLKEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetBCR1_WFDIS(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetBCR1_WFDIS() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x200000) >> 21
}
func (o *FMC_Type) SetBCR1_BMAP(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x3000000)|value<<24)
}
func (o *FMC_Type) GetBCR1_BMAP() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x3000000) >> 24
}
func (o *FMC_Type) SetBCR1_FMCEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *FMC_Type) GetBCR1_FMCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x80000000) >> 31
}

// FMC.BTR1: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
func (o *FMC_Type) SetBTR1_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR1_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR1.Reg) & 0xf
}
func (o *FMC_Type) SetBTR1_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR1_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR1_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR1_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR1_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR1_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR1_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR1_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR1_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR1_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR1_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR1_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0x30000000) >> 28
}

// FMC.BCR2: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
func (o *FMC_Type) SetBCR2_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR2_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR2.Reg) & 0x1
}
func (o *FMC_Type) SetBCR2_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR2_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR2_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR2_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR2_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR2_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR2_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR2_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR2_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR2_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR2_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR2_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR2_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR2_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR2_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR2_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR2_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR2_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR2_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR2_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR2_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR2_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR2_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x70000)|value<<16)
}
func (o *FMC_Type) GetBCR2_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x70000) >> 16
}
func (o *FMC_Type) SetBCR2_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR2_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR2_CCLKEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetBCR2_CCLKEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetBCR2_WFDIS(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetBCR2_WFDIS() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x200000) >> 21
}
func (o *FMC_Type) SetBCR2_BMAP(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x3000000)|value<<24)
}
func (o *FMC_Type) GetBCR2_BMAP() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x3000000) >> 24
}
func (o *FMC_Type) SetBCR2_FMCEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x80000000)|value<<31)
}
func (o *FMC_Type) GetBCR2_FMCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x80000000) >> 31
}

// FMC.BTR2: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
func (o *FMC_Type) SetBTR2_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR2_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR2.Reg) & 0xf
}
func (o *FMC_Type) SetBTR2_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR2_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR2_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR2_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR2_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR2_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR2_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR2_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR2_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR2_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR2_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR2_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0x30000000) >> 28
}

// FMC.BCR3: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
func (o *FMC_Type) SetBCR3_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR3_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR3.Reg) & 0x1
}
func (o *FMC_Type) SetBCR3_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR3_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR3_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR3_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR3_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR3_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR3_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR3_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR3_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR3_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR3_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR3_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR3_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR3_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR3_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR3_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR3_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR3_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR3_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR3_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR3_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR3_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR3_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x70000)|value<<16)
}
func (o *FMC_Type) GetBCR3_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x70000) >> 16
}
func (o *FMC_Type) SetBCR3_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR3_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR3_CCLKEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetBCR3_CCLKEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetBCR3_WFDIS(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetBCR3_WFDIS() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x200000) >> 21
}
func (o *FMC_Type) SetBCR3_BMAP(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x3000000)|value<<24)
}
func (o *FMC_Type) GetBCR3_BMAP() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x3000000) >> 24
}
func (o *FMC_Type) SetBCR3_FMCEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x80000000)|value<<31)
}
func (o *FMC_Type) GetBCR3_FMCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x80000000) >> 31
}

// FMC.BTR3: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
func (o *FMC_Type) SetBTR3_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR3_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR3.Reg) & 0xf
}
func (o *FMC_Type) SetBTR3_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR3_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR3_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR3_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR3_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR3_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR3_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR3_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR3_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR3_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR3_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR3_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0x30000000) >> 28
}

// FMC.BCR4: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
func (o *FMC_Type) SetBCR4_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR4_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR4.Reg) & 0x1
}
func (o *FMC_Type) SetBCR4_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR4_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR4_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR4_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR4_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR4_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR4_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR4_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR4_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR4_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR4_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR4_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR4_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR4_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR4_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR4_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR4_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR4_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR4_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR4_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR4_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR4_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR4_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x70000)|value<<16)
}
func (o *FMC_Type) GetBCR4_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x70000) >> 16
}
func (o *FMC_Type) SetBCR4_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR4_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR4_CCLKEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetBCR4_CCLKEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetBCR4_WFDIS(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetBCR4_WFDIS() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x200000) >> 21
}
func (o *FMC_Type) SetBCR4_BMAP(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x3000000)|value<<24)
}
func (o *FMC_Type) GetBCR4_BMAP() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x3000000) >> 24
}
func (o *FMC_Type) SetBCR4_FMCEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x80000000)|value<<31)
}
func (o *FMC_Type) GetBCR4_FMCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x80000000) >> 31
}

// FMC.BTR4: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
func (o *FMC_Type) SetBTR4_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR4_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR4.Reg) & 0xf
}
func (o *FMC_Type) SetBTR4_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR4_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR4_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR4_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR4_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR4_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR4_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR4_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR4_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR4_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR4_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR4_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0x30000000) >> 28
}

// FMC.PCR: NAND Flash control registers
func (o *FMC_Type) SetPCR_PWAITEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetPCR_PWAITEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetPCR_PBKEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetPCR_PBKEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetPCR_PWID(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetPCR_PWID() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetPCR_ECCEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetPCR_ECCEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetPCR_TCLR(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1e00)|value<<9)
}
func (o *FMC_Type) GetPCR_TCLR() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1e00) >> 9
}
func (o *FMC_Type) SetPCR_TAR(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1e000)|value<<13)
}
func (o *FMC_Type) GetPCR_TAR() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1e000) >> 13
}
func (o *FMC_Type) SetPCR_ECCPS(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0xe0000)|value<<17)
}
func (o *FMC_Type) GetPCR_ECCPS() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0xe0000) >> 17
}

// FMC.SR: This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
func (o *FMC_Type) SetSR_IRS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetSR_IRS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *FMC_Type) SetSR_ILS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetSR_ILS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetSR_IFS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetSR_IFS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetSR_IREN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetSR_IREN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetSR_ILEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetSR_ILEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetSR_IFEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *FMC_Type) GetSR_IFEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *FMC_Type) SetSR_FEMPT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetSR_FEMPT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}

// FMC.PMEM: The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
func (o *FMC_Type) SetPMEM_MEMSET(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff)|value)
}
func (o *FMC_Type) GetPMEM_MEMSET() uint32 {
	return volatile.LoadUint32(&o.PMEM.Reg) & 0xff
}
func (o *FMC_Type) SetPMEM_MEMWAIT(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetPMEM_MEMWAIT() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetPMEM_MEMHOLD(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff0000)|value<<16)
}
func (o *FMC_Type) GetPMEM_MEMHOLD() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff0000) >> 16
}
func (o *FMC_Type) SetPMEM_MEMHIZ(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff000000)|value<<24)
}
func (o *FMC_Type) GetPMEM_MEMHIZ() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff000000) >> 24
}

// FMC.PATT: The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
func (o *FMC_Type) SetPATT_ATTSET(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff)|value)
}
func (o *FMC_Type) GetPATT_ATTSET() uint32 {
	return volatile.LoadUint32(&o.PATT.Reg) & 0xff
}
func (o *FMC_Type) SetPATT_ATTWAIT(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetPATT_ATTWAIT() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetPATT_ATTHOLD(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff0000)|value<<16)
}
func (o *FMC_Type) GetPATT_ATTHOLD() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff0000) >> 16
}
func (o *FMC_Type) SetPATT_ATTHIZ(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff000000)|value<<24)
}
func (o *FMC_Type) GetPATT_ATTHIZ() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff000000) >> 24
}

// FMC.ECCR: This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
func (o *FMC_Type) SetECCR(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, value)
}
func (o *FMC_Type) GetECCR() uint32 {
	return volatile.LoadUint32(&o.ECCR.Reg)
}

// FMC.BWTR1: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
func (o *FMC_Type) SetBWTR1_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR1_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR1.Reg) & 0xf
}
func (o *FMC_Type) SetBWTR1_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR1_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR1_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR1_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR1_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBWTR1_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBWTR1_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR1_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0x30000000) >> 28
}

// FMC.BWTR2: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
func (o *FMC_Type) SetBWTR2_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR2_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR2.Reg) & 0xf
}
func (o *FMC_Type) SetBWTR2_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR2_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR2_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR2_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR2_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBWTR2_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBWTR2_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR2_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0x30000000) >> 28
}

// FMC.BWTR3: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
func (o *FMC_Type) SetBWTR3_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR3_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR3.Reg) & 0xf
}
func (o *FMC_Type) SetBWTR3_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR3_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR3_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR3_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR3_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBWTR3_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBWTR3_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR3_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0x30000000) >> 28
}

// FMC.BWTR4: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
func (o *FMC_Type) SetBWTR4_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR4_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR4.Reg) & 0xf
}
func (o *FMC_Type) SetBWTR4_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR4_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR4_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR4_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR4_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBWTR4_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBWTR4_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR4_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0x30000000) >> 28
}

// FMC.SDCMR: This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
func (o *FMC_Type) SetSDCMR_MODE(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x7)|value)
}
func (o *FMC_Type) GetSDCMR_MODE() uint32 {
	return volatile.LoadUint32(&o.SDCMR.Reg) & 0x7
}
func (o *FMC_Type) SetSDCMR_CTB2(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetSDCMR_CTB2() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetSDCMR_CTB1(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetSDCMR_CTB1() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetSDCMR_NRFS(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x1e0)|value<<5)
}
func (o *FMC_Type) GetSDCMR_NRFS() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x1e0) >> 5
}
func (o *FMC_Type) SetSDCMR_MRD(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x7ffe00)|value<<9)
}
func (o *FMC_Type) GetSDCMR_MRD() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x7ffe00) >> 9
}

// FMC.SDRTR: This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
func (o *FMC_Type) SetSDRTR_CRE(value uint32) {
	volatile.StoreUint32(&o.SDRTR.Reg, volatile.LoadUint32(&o.SDRTR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetSDRTR_CRE() uint32 {
	return volatile.LoadUint32(&o.SDRTR.Reg) & 0x1
}
func (o *FMC_Type) SetSDRTR_COUNT(value uint32) {
	volatile.StoreUint32(&o.SDRTR.Reg, volatile.LoadUint32(&o.SDRTR.Reg)&^(0x3ffe)|value<<1)
}
func (o *FMC_Type) GetSDRTR_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SDRTR.Reg) & 0x3ffe) >> 1
}
func (o *FMC_Type) SetSDRTR_REIE(value uint32) {
	volatile.StoreUint32(&o.SDRTR.Reg, volatile.LoadUint32(&o.SDRTR.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetSDRTR_REIE() uint32 {
	return (volatile.LoadUint32(&o.SDRTR.Reg) & 0x4000) >> 14
}

// FMC.SDSR: SDRAM Status register
func (o *FMC_Type) SetSDSR_RE(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetSDSR_RE() uint32 {
	return volatile.LoadUint32(&o.SDSR.Reg) & 0x1
}
func (o *FMC_Type) SetSDSR_MODES1(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x6)|value<<1)
}
func (o *FMC_Type) GetSDSR_MODES1() uint32 {
	return (volatile.LoadUint32(&o.SDSR.Reg) & 0x6) >> 1
}
func (o *FMC_Type) SetSDSR_MODES2(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x18)|value<<3)
}
func (o *FMC_Type) GetSDSR_MODES2() uint32 {
	return (volatile.LoadUint32(&o.SDSR.Reg) & 0x18) >> 3
}

type FMC_SDBANK_Type struct {
	SDCR volatile.Register32 // 0x140
	_    [4]byte
	SDTR volatile.Register32 // 0x148
}

// FMC_SDBANK.SDCR: This register contains the control parameters for each SDRAM memory bank
func (o *FMC_SDBANK_Type) SetSDCR_NC(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x3)|value)
}
func (o *FMC_SDBANK_Type) GetSDCR_NC() uint32 {
	return volatile.LoadUint32(&o.SDCR.Reg) & 0x3
}
func (o *FMC_SDBANK_Type) SetSDCR_NR(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0xc)|value<<2)
}
func (o *FMC_SDBANK_Type) GetSDCR_NR() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0xc) >> 2
}
func (o *FMC_SDBANK_Type) SetSDCR_MWID(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x30)|value<<4)
}
func (o *FMC_SDBANK_Type) GetSDCR_MWID() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0x30) >> 4
}
func (o *FMC_SDBANK_Type) SetSDCR_NB(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x40)|value<<6)
}
func (o *FMC_SDBANK_Type) GetSDCR_NB() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0x40) >> 6
}
func (o *FMC_SDBANK_Type) SetSDCR_CAS(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x180)|value<<7)
}
func (o *FMC_SDBANK_Type) GetSDCR_CAS() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0x180) >> 7
}
func (o *FMC_SDBANK_Type) SetSDCR_WP(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x200)|value<<9)
}
func (o *FMC_SDBANK_Type) GetSDCR_WP() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0x200) >> 9
}
func (o *FMC_SDBANK_Type) SetSDCR_SDCLK(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0xc00)|value<<10)
}
func (o *FMC_SDBANK_Type) GetSDCR_SDCLK() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0xc00) >> 10
}
func (o *FMC_SDBANK_Type) SetSDCR_RBURST(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_SDBANK_Type) GetSDCR_RBURST() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0x1000) >> 12
}
func (o *FMC_SDBANK_Type) SetSDCR_RPIPE(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x6000)|value<<13)
}
func (o *FMC_SDBANK_Type) GetSDCR_RPIPE() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0x6000) >> 13
}

// FMC_SDBANK.SDTR: This register contains the timing parameters of each SDRAM bank
func (o *FMC_SDBANK_Type) SetSDTR_TMRD(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf)|value)
}
func (o *FMC_SDBANK_Type) GetSDTR_TMRD() uint32 {
	return volatile.LoadUint32(&o.SDTR.Reg) & 0xf
}
func (o *FMC_SDBANK_Type) SetSDTR_TXSR(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_SDBANK_Type) GetSDTR_TXSR() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xf0) >> 4
}
func (o *FMC_SDBANK_Type) SetSDTR_TRAS(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf00)|value<<8)
}
func (o *FMC_SDBANK_Type) GetSDTR_TRAS() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xf00) >> 8
}
func (o *FMC_SDBANK_Type) SetSDTR_TRC(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf000)|value<<12)
}
func (o *FMC_SDBANK_Type) GetSDTR_TRC() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xf000) >> 12
}
func (o *FMC_SDBANK_Type) SetSDTR_TWR(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_SDBANK_Type) GetSDTR_TWR() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xf0000) >> 16
}
func (o *FMC_SDBANK_Type) SetSDTR_TRP(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_SDBANK_Type) GetSDTR_TRP() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xf00000) >> 20
}
func (o *FMC_SDBANK_Type) SetSDTR_TRCD(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_SDBANK_Type) GetSDTR_TRCD() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xf000000) >> 24
}

// Floting point unit
type FPU_Type struct {
	FPCCR volatile.Register32 // 0x0
	FPCAR volatile.Register32 // 0x4
	FPSCR volatile.Register32 // 0x8
}

// FPU.FPCCR: Floating-point context control register
func (o *FPU_Type) SetFPCCR_LSPACT(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetFPCCR_LSPACT() uint32 {
	return volatile.LoadUint32(&o.FPCCR.Reg) & 0x1
}
func (o *FPU_Type) SetFPCCR_USER(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetFPCCR_USER() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetFPCCR_THREAD(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetFPCCR_THREAD() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetFPCCR_HFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetFPCCR_HFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetFPCCR_MMRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetFPCCR_MMRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x20) >> 5
}
func (o *FPU_Type) SetFPCCR_BFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40)|value<<6)
}
func (o *FPU_Type) GetFPCCR_BFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40) >> 6
}
func (o *FPU_Type) SetFPCCR_MONRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x100)|value<<8)
}
func (o *FPU_Type) GetFPCCR_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x100) >> 8
}
func (o *FPU_Type) SetFPCCR_LSPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FPU_Type) GetFPCCR_LSPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40000000) >> 30
}
func (o *FPU_Type) SetFPCCR_ASPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FPU_Type) GetFPCCR_ASPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x80000000) >> 31
}

// FPU.FPCAR: Floating-point context address register
func (o *FPU_Type) SetFPCAR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.FPCAR.Reg, volatile.LoadUint32(&o.FPCAR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *FPU_Type) GetFPCAR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.FPCAR.Reg) & 0xfffffff8) >> 3
}

// FPU.FPSCR: Floating-point status control register
func (o *FPU_Type) SetFPSCR_IOC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetFPSCR_IOC() uint32 {
	return volatile.LoadUint32(&o.FPSCR.Reg) & 0x1
}
func (o *FPU_Type) SetFPSCR_DZC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetFPSCR_DZC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetFPSCR_OFC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x4)|value<<2)
}
func (o *FPU_Type) GetFPSCR_OFC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x4) >> 2
}
func (o *FPU_Type) SetFPSCR_UFC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetFPSCR_UFC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetFPSCR_IXC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetFPSCR_IXC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetFPSCR_IDC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x80)|value<<7)
}
func (o *FPU_Type) GetFPSCR_IDC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x80) >> 7
}
func (o *FPU_Type) SetFPSCR_RMode(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *FPU_Type) GetFPSCR_RMode() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0xc00000) >> 22
}
func (o *FPU_Type) SetFPSCR_FZ(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *FPU_Type) GetFPSCR_FZ() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x1000000) >> 24
}
func (o *FPU_Type) SetFPSCR_DN(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *FPU_Type) GetFPSCR_DN() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x2000000) >> 25
}
func (o *FPU_Type) SetFPSCR_AHP(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *FPU_Type) GetFPSCR_AHP() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x4000000) >> 26
}
func (o *FPU_Type) SetFPSCR_V(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x10000000)|value<<28)
}
func (o *FPU_Type) GetFPSCR_V() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x10000000) >> 28
}
func (o *FPU_Type) SetFPSCR_C(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *FPU_Type) GetFPSCR_C() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x20000000) >> 29
}
func (o *FPU_Type) SetFPSCR_Z(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FPU_Type) GetFPSCR_Z() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x40000000) >> 30
}
func (o *FPU_Type) SetFPSCR_N(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FPU_Type) GetFPSCR_N() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x80000000) >> 31
}

// Flash
type FLASH_Type struct {
	ACR  volatile.Register32 // 0x0
	BANK [2]FLASH_BANK_Type  // 0x4
}

// FLASH.ACR: Access control register
func (o *FLASH_Type) SetACR_LATENCY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x7)|value)
}
func (o *FLASH_Type) GetACR_LATENCY() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x7
}
func (o *FLASH_Type) SetACR_WRHIGHFREQ(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x30)|value<<4)
}
func (o *FLASH_Type) GetACR_WRHIGHFREQ() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x30) >> 4
}

type FLASH_BANK_Type struct {
	KEYR      volatile.Register32 // 0x4
	_         [4]byte
	CR        volatile.Register32 // 0xC
	SR        volatile.Register32 // 0x10
	CCR       volatile.Register32 // 0x14
	_         [16]byte
	PRAR_CUR  volatile.Register32 // 0x28
	PRAR_PRG  volatile.Register32 // 0x2C
	SCAR_CUR  volatile.Register32 // 0x30
	SCAR_PRG  volatile.Register32 // 0x34
	WPSN_CURR volatile.Register32 // 0x38
	WPSN_PRGR volatile.Register32 // 0x3C
	_         [16]byte
	CRCCR     volatile.Register32 // 0x50
	CRCSADDR  volatile.Register32 // 0x54
	CRCEADDR  volatile.Register32 // 0x58
	_         [4]byte
	FAR       volatile.Register32 // 0x60
	_         [160]byte
}

// FLASH_BANK.KEYR: FLASH key register for bank 1
func (o *FLASH_BANK_Type) SetKEYR(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, value)
}
func (o *FLASH_BANK_Type) GetKEYR() uint32 {
	return volatile.LoadUint32(&o.KEYR.Reg)
}

// FLASH_BANK.CR: FLASH control register for bank 1
func (o *FLASH_BANK_Type) SetCR_LOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *FLASH_BANK_Type) GetCR_LOCK() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *FLASH_BANK_Type) SetCR_PG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_BANK_Type) GetCR_PG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *FLASH_BANK_Type) SetCR_SER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_BANK_Type) GetCR_SER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *FLASH_BANK_Type) SetCR_BER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_BANK_Type) GetCR_BER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *FLASH_BANK_Type) SetCR_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30)|value<<4)
}
func (o *FLASH_BANK_Type) GetCR_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30) >> 4
}
func (o *FLASH_BANK_Type) SetCR_FW(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *FLASH_BANK_Type) GetCR_FW() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *FLASH_BANK_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *FLASH_BANK_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *FLASH_BANK_Type) SetCR_SNB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x700)|value<<8)
}
func (o *FLASH_BANK_Type) GetCR_SNB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x700) >> 8
}
func (o *FLASH_BANK_Type) SetCR_CRC_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *FLASH_BANK_Type) GetCR_CRC_EN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *FLASH_BANK_Type) SetCR_EOPIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_BANK_Type) GetCR_EOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *FLASH_BANK_Type) SetCR_WRPERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *FLASH_BANK_Type) GetCR_WRPERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *FLASH_BANK_Type) SetCR_PGSERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *FLASH_BANK_Type) GetCR_PGSERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *FLASH_BANK_Type) SetCR_STRBERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *FLASH_BANK_Type) GetCR_STRBERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *FLASH_BANK_Type) SetCR_INCERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *FLASH_BANK_Type) GetCR_INCERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *FLASH_BANK_Type) SetCR_OPERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *FLASH_BANK_Type) GetCR_OPERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *FLASH_BANK_Type) SetCR_RDPERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *FLASH_BANK_Type) GetCR_RDPERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *FLASH_BANK_Type) SetCR_RDSERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *FLASH_BANK_Type) GetCR_RDSERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *FLASH_BANK_Type) SetCR_SNECCERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *FLASH_BANK_Type) GetCR_SNECCERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *FLASH_BANK_Type) SetCR_DBECCERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASH_BANK_Type) GetCR_DBECCERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *FLASH_BANK_Type) SetCR_CRCENDIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASH_BANK_Type) GetCR_CRCENDIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}

// FLASH_BANK.SR: FLASH status register for bank 1
func (o *FLASH_BANK_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *FLASH_BANK_Type) GetSR_BSY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *FLASH_BANK_Type) SetSR_WBNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_BANK_Type) GetSR_WBNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *FLASH_BANK_Type) SetSR_QW(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_BANK_Type) GetSR_QW() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *FLASH_BANK_Type) SetSR_CRC_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_BANK_Type) GetSR_CRC_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *FLASH_BANK_Type) SetSR_EOP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_BANK_Type) GetSR_EOP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *FLASH_BANK_Type) SetSR_WRPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *FLASH_BANK_Type) GetSR_WRPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *FLASH_BANK_Type) SetSR_PGSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *FLASH_BANK_Type) GetSR_PGSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *FLASH_BANK_Type) SetSR_STRBERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *FLASH_BANK_Type) GetSR_STRBERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *FLASH_BANK_Type) SetSR_INCERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *FLASH_BANK_Type) GetSR_INCERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *FLASH_BANK_Type) SetSR_OPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *FLASH_BANK_Type) GetSR_OPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *FLASH_BANK_Type) SetSR_RDPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *FLASH_BANK_Type) GetSR_RDPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *FLASH_BANK_Type) SetSR_RDSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *FLASH_BANK_Type) GetSR_RDSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *FLASH_BANK_Type) SetSR_SNECCERR1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *FLASH_BANK_Type) GetSR_SNECCERR1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *FLASH_BANK_Type) SetSR_DBECCERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASH_BANK_Type) GetSR_DBECCERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *FLASH_BANK_Type) SetSR_CRCEND(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASH_BANK_Type) GetSR_CRCEND() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}

// FLASH_BANK.CCR: FLASH clear control register for bank 1
func (o *FLASH_BANK_Type) SetCCR_CLR_EOP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_EOP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10000) >> 16
}
func (o *FLASH_BANK_Type) SetCCR_CLR_WRPERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20000)|value<<17)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_WRPERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20000) >> 17
}
func (o *FLASH_BANK_Type) SetCCR_CLR_PGSERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40000)|value<<18)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_PGSERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40000) >> 18
}
func (o *FLASH_BANK_Type) SetCCR_CLR_STRBERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80000)|value<<19)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_STRBERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80000) >> 19
}
func (o *FLASH_BANK_Type) SetCCR_CLR_INCERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200000)|value<<21)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_INCERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200000) >> 21
}
func (o *FLASH_BANK_Type) SetCCR_CLR_OPERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x400000)|value<<22)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_OPERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x400000) >> 22
}
func (o *FLASH_BANK_Type) SetCCR_CLR_RDPERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x800000)|value<<23)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_RDPERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x800000) >> 23
}
func (o *FLASH_BANK_Type) SetCCR_CLR_RDSERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1000000)|value<<24)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_RDSERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1000000) >> 24
}
func (o *FLASH_BANK_Type) SetCCR_CLR_SNECCERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2000000)|value<<25)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_SNECCERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2000000) >> 25
}
func (o *FLASH_BANK_Type) SetCCR_CLR_DBECCERR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_DBECCERR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4000000) >> 26
}
func (o *FLASH_BANK_Type) SetCCR_CLR_CRCEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASH_BANK_Type) GetCCR_CLR_CRCEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8000000) >> 27
}

// FLASH_BANK.PRAR_CUR: FLASH protection address for bank 1
func (o *FLASH_BANK_Type) SetPRAR_CUR_PROT_AREA_START(value uint32) {
	volatile.StoreUint32(&o.PRAR_CUR.Reg, volatile.LoadUint32(&o.PRAR_CUR.Reg)&^(0xfff)|value)
}
func (o *FLASH_BANK_Type) GetPRAR_CUR_PROT_AREA_START() uint32 {
	return volatile.LoadUint32(&o.PRAR_CUR.Reg) & 0xfff
}
func (o *FLASH_BANK_Type) SetPRAR_CUR_PROT_AREA_END(value uint32) {
	volatile.StoreUint32(&o.PRAR_CUR.Reg, volatile.LoadUint32(&o.PRAR_CUR.Reg)&^(0xfff0000)|value<<16)
}
func (o *FLASH_BANK_Type) GetPRAR_CUR_PROT_AREA_END() uint32 {
	return (volatile.LoadUint32(&o.PRAR_CUR.Reg) & 0xfff0000) >> 16
}
func (o *FLASH_BANK_Type) SetPRAR_CUR_DMEP(value uint32) {
	volatile.StoreUint32(&o.PRAR_CUR.Reg, volatile.LoadUint32(&o.PRAR_CUR.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_BANK_Type) GetPRAR_CUR_DMEP() uint32 {
	return (volatile.LoadUint32(&o.PRAR_CUR.Reg) & 0x80000000) >> 31
}

// FLASH_BANK.PRAR_PRG: FLASH protection address for bank 1
func (o *FLASH_BANK_Type) SetPRAR_PRG_PROT_AREA_START(value uint32) {
	volatile.StoreUint32(&o.PRAR_PRG.Reg, volatile.LoadUint32(&o.PRAR_PRG.Reg)&^(0xfff)|value)
}
func (o *FLASH_BANK_Type) GetPRAR_PRG_PROT_AREA_START() uint32 {
	return volatile.LoadUint32(&o.PRAR_PRG.Reg) & 0xfff
}
func (o *FLASH_BANK_Type) SetPRAR_PRG_PROT_AREA_END(value uint32) {
	volatile.StoreUint32(&o.PRAR_PRG.Reg, volatile.LoadUint32(&o.PRAR_PRG.Reg)&^(0xfff0000)|value<<16)
}
func (o *FLASH_BANK_Type) GetPRAR_PRG_PROT_AREA_END() uint32 {
	return (volatile.LoadUint32(&o.PRAR_PRG.Reg) & 0xfff0000) >> 16
}
func (o *FLASH_BANK_Type) SetPRAR_PRG_DMEP(value uint32) {
	volatile.StoreUint32(&o.PRAR_PRG.Reg, volatile.LoadUint32(&o.PRAR_PRG.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_BANK_Type) GetPRAR_PRG_DMEP() uint32 {
	return (volatile.LoadUint32(&o.PRAR_PRG.Reg) & 0x80000000) >> 31
}

// FLASH_BANK.SCAR_CUR: FLASH secure address for bank 1
func (o *FLASH_BANK_Type) SetSCAR_CUR_SEC_AREA_START(value uint32) {
	volatile.StoreUint32(&o.SCAR_CUR.Reg, volatile.LoadUint32(&o.SCAR_CUR.Reg)&^(0xfff)|value)
}
func (o *FLASH_BANK_Type) GetSCAR_CUR_SEC_AREA_START() uint32 {
	return volatile.LoadUint32(&o.SCAR_CUR.Reg) & 0xfff
}
func (o *FLASH_BANK_Type) SetSCAR_CUR_SEC_AREA_END(value uint32) {
	volatile.StoreUint32(&o.SCAR_CUR.Reg, volatile.LoadUint32(&o.SCAR_CUR.Reg)&^(0xfff0000)|value<<16)
}
func (o *FLASH_BANK_Type) GetSCAR_CUR_SEC_AREA_END() uint32 {
	return (volatile.LoadUint32(&o.SCAR_CUR.Reg) & 0xfff0000) >> 16
}
func (o *FLASH_BANK_Type) SetSCAR_CUR_DMES(value uint32) {
	volatile.StoreUint32(&o.SCAR_CUR.Reg, volatile.LoadUint32(&o.SCAR_CUR.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_BANK_Type) GetSCAR_CUR_DMES() uint32 {
	return (volatile.LoadUint32(&o.SCAR_CUR.Reg) & 0x80000000) >> 31
}

// FLASH_BANK.SCAR_PRG: FLASH secure address for bank 1
func (o *FLASH_BANK_Type) SetSCAR_PRG_SEC_AREA_START(value uint32) {
	volatile.StoreUint32(&o.SCAR_PRG.Reg, volatile.LoadUint32(&o.SCAR_PRG.Reg)&^(0xfff)|value)
}
func (o *FLASH_BANK_Type) GetSCAR_PRG_SEC_AREA_START() uint32 {
	return volatile.LoadUint32(&o.SCAR_PRG.Reg) & 0xfff
}
func (o *FLASH_BANK_Type) SetSCAR_PRG_SEC_AREA_END(value uint32) {
	volatile.StoreUint32(&o.SCAR_PRG.Reg, volatile.LoadUint32(&o.SCAR_PRG.Reg)&^(0xfff0000)|value<<16)
}
func (o *FLASH_BANK_Type) GetSCAR_PRG_SEC_AREA_END() uint32 {
	return (volatile.LoadUint32(&o.SCAR_PRG.Reg) & 0xfff0000) >> 16
}
func (o *FLASH_BANK_Type) SetSCAR_PRG_DMES(value uint32) {
	volatile.StoreUint32(&o.SCAR_PRG.Reg, volatile.LoadUint32(&o.SCAR_PRG.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_BANK_Type) GetSCAR_PRG_DMES() uint32 {
	return (volatile.LoadUint32(&o.SCAR_PRG.Reg) & 0x80000000) >> 31
}

// FLASH_BANK.WPSN_CURR: FLASH write sector protection for bank 1
func (o *FLASH_BANK_Type) SetWPSN_CURR_WRPSn(value uint32) {
	volatile.StoreUint32(&o.WPSN_CURR.Reg, volatile.LoadUint32(&o.WPSN_CURR.Reg)&^(0xff)|value)
}
func (o *FLASH_BANK_Type) GetWPSN_CURR_WRPSn() uint32 {
	return volatile.LoadUint32(&o.WPSN_CURR.Reg) & 0xff
}

// FLASH_BANK.WPSN_PRGR: FLASH write sector protection for bank 1
func (o *FLASH_BANK_Type) SetWPSN_PRGR_WRPSn(value uint32) {
	volatile.StoreUint32(&o.WPSN_PRGR.Reg, volatile.LoadUint32(&o.WPSN_PRGR.Reg)&^(0xff)|value)
}
func (o *FLASH_BANK_Type) GetWPSN_PRGR_WRPSn() uint32 {
	return volatile.LoadUint32(&o.WPSN_PRGR.Reg) & 0xff
}

// FLASH_BANK.CRCCR: FLASH CRC control register for bank 1
func (o *FLASH_BANK_Type) SetCRCCR_CRC_SECT(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x7)|value)
}
func (o *FLASH_BANK_Type) GetCRCCR_CRC_SECT() uint32 {
	return volatile.LoadUint32(&o.CRCCR.Reg) & 0x7
}
func (o *FLASH_BANK_Type) SetCRCCR_ALL_BANK(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x80)|value<<7)
}
func (o *FLASH_BANK_Type) GetCRCCR_ALL_BANK() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x80) >> 7
}
func (o *FLASH_BANK_Type) SetCRCCR_CRC_BY_SECT(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x100)|value<<8)
}
func (o *FLASH_BANK_Type) GetCRCCR_CRC_BY_SECT() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x100) >> 8
}
func (o *FLASH_BANK_Type) SetCRCCR_ADD_SECT(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_BANK_Type) GetCRCCR_ADD_SECT() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x200) >> 9
}
func (o *FLASH_BANK_Type) SetCRCCR_CLEAN_SECT(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x400)|value<<10)
}
func (o *FLASH_BANK_Type) GetCRCCR_CLEAN_SECT() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x400) >> 10
}
func (o *FLASH_BANK_Type) SetCRCCR_START_CRC(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_BANK_Type) GetCRCCR_START_CRC() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x10000) >> 16
}
func (o *FLASH_BANK_Type) SetCRCCR_CLEAN_CRC(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x20000)|value<<17)
}
func (o *FLASH_BANK_Type) GetCRCCR_CLEAN_CRC() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x20000) >> 17
}
func (o *FLASH_BANK_Type) SetCRCCR_CRC_BURST(value uint32) {
	volatile.StoreUint32(&o.CRCCR.Reg, volatile.LoadUint32(&o.CRCCR.Reg)&^(0x300000)|value<<20)
}
func (o *FLASH_BANK_Type) GetCRCCR_CRC_BURST() uint32 {
	return (volatile.LoadUint32(&o.CRCCR.Reg) & 0x300000) >> 20
}

// FLASH_BANK.CRCSADDR: FLASH CRC start address register for bank 1
func (o *FLASH_BANK_Type) SetCRCSADDR(value uint32) {
	volatile.StoreUint32(&o.CRCSADDR.Reg, value)
}
func (o *FLASH_BANK_Type) GetCRCSADDR() uint32 {
	return volatile.LoadUint32(&o.CRCSADDR.Reg)
}

// FLASH_BANK.CRCEADDR: FLASH CRC end address register for bank 1
func (o *FLASH_BANK_Type) SetCRCEADDR(value uint32) {
	volatile.StoreUint32(&o.CRCEADDR.Reg, value)
}
func (o *FLASH_BANK_Type) GetCRCEADDR() uint32 {
	return volatile.LoadUint32(&o.CRCEADDR.Reg)
}

// FLASH_BANK.FAR: FLASH ECC fail address for bank 1
func (o *FLASH_BANK_Type) SetFAR_FAIL_ECC_ADDR(value uint32) {
	volatile.StoreUint32(&o.FAR.Reg, volatile.LoadUint32(&o.FAR.Reg)&^(0x7fff)|value)
}
func (o *FLASH_BANK_Type) GetFAR_FAIL_ECC_ADDR() uint32 {
	return volatile.LoadUint32(&o.FAR.Reg) & 0x7fff
}

// GPIO
type GPIO_Type struct {
	MODER   volatile.Register32 // 0x0
	OTYPER  volatile.Register32 // 0x4
	OSPEEDR volatile.Register32 // 0x8
	PUPDR   volatile.Register32 // 0xC
	IDR     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	BSRR    volatile.Register32 // 0x18
	LCKR    volatile.Register32 // 0x1C
	AFRL    volatile.Register32 // 0x20
	AFRH    volatile.Register32 // 0x24
}

// GPIO.MODER: GPIO port mode register
func (o *GPIO_Type) SetMODER_MODER0(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetMODER_MODER0() uint32 {
	return volatile.LoadUint32(&o.MODER.Reg) & 0x3
}
func (o *GPIO_Type) SetMODER_MODER1(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetMODER_MODER1() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetMODER_MODER2(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetMODER_MODER2() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetMODER_MODER3(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetMODER_MODER3() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetMODER_MODER4(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetMODER_MODER4() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetMODER_MODER5(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetMODER_MODER5() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetMODER_MODER6(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetMODER_MODER6() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetMODER_MODER7(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetMODER_MODER7() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetMODER_MODER8(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetMODER_MODER8() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetMODER_MODER9(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetMODER_MODER9() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetMODER_MODER10(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetMODER_MODER10() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetMODER_MODER11(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetMODER_MODER11() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetMODER_MODER12(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetMODER_MODER12() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetMODER_MODER13(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetMODER_MODER13() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetMODER_MODER14(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetMODER_MODER14() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetMODER_MODER15(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetMODER_MODER15() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000000) >> 30
}

// GPIO.OTYPER: GPIO port output type register
func (o *GPIO_Type) SetOTYPER_OT0(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOTYPER_OT0() uint32 {
	return volatile.LoadUint32(&o.OTYPER.Reg) & 0x1
}
func (o *GPIO_Type) SetOTYPER_OT1(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOTYPER_OT1() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOTYPER_OT2(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOTYPER_OT2() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOTYPER_OT3(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOTYPER_OT3() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOTYPER_OT4(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOTYPER_OT4() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOTYPER_OT5(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOTYPER_OT5() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOTYPER_OT6(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOTYPER_OT6() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOTYPER_OT7(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOTYPER_OT7() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOTYPER_OT8(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOTYPER_OT8() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOTYPER_OT9(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOTYPER_OT9() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOTYPER_OT10(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOTYPER_OT10() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOTYPER_OT11(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOTYPER_OT11() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOTYPER_OT12(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOTYPER_OT12() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOTYPER_OT13(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOTYPER_OT13() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOTYPER_OT14(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOTYPER_OT14() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOTYPER_OT15(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOTYPER_OT15() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8000) >> 15
}

// GPIO.OSPEEDR: GPIO port output speed register
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR0(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR0() uint32 {
	return volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR1(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR1() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR2(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR2() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR3(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR3() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR4(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR4() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR5(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR5() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR6(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR6() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR7(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR7() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR8(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR8() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR9(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR9() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR10(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR10() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR11(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR11() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR12(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR12() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR13(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR13() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR14(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR14() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR15(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR15() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000000) >> 30
}

// GPIO.PUPDR: GPIO port pull-up/pull-down register
func (o *GPIO_Type) SetPUPDR_PUPDR0(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPUPDR_PUPDR0() uint32 {
	return volatile.LoadUint32(&o.PUPDR.Reg) & 0x3
}
func (o *GPIO_Type) SetPUPDR_PUPDR1(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPUPDR_PUPDR1() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPUPDR_PUPDR2(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetPUPDR_PUPDR2() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetPUPDR_PUPDR3(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetPUPDR_PUPDR3() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetPUPDR_PUPDR4(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetPUPDR_PUPDR4() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetPUPDR_PUPDR5(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetPUPDR_PUPDR5() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetPUPDR_PUPDR6(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetPUPDR_PUPDR6() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetPUPDR_PUPDR7(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetPUPDR_PUPDR7() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetPUPDR_PUPDR8(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPUPDR_PUPDR8() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetPUPDR_PUPDR9(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetPUPDR_PUPDR9() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetPUPDR_PUPDR10(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetPUPDR_PUPDR10() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetPUPDR_PUPDR11(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetPUPDR_PUPDR11() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetPUPDR_PUPDR12(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetPUPDR_PUPDR12() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetPUPDR_PUPDR13(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetPUPDR_PUPDR13() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetPUPDR_PUPDR14(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetPUPDR_PUPDR14() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetPUPDR_PUPDR15(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetPUPDR_PUPDR15() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000000) >> 30
}

// GPIO.IDR: GPIO port input data register
func (o *GPIO_Type) SetIDR_IDR0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIDR_IDR0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *GPIO_Type) SetIDR_IDR1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIDR_IDR1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIDR_IDR2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIDR_IDR2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIDR_IDR3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIDR_IDR3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIDR_IDR4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIDR_IDR4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIDR_IDR5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIDR_IDR5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIDR_IDR6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIDR_IDR6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIDR_IDR7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIDR_IDR7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIDR_IDR8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIDR_IDR8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIDR_IDR9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIDR_IDR9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIDR_IDR10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIDR_IDR10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIDR_IDR11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIDR_IDR11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIDR_IDR12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIDR_IDR12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIDR_IDR13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIDR_IDR13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIDR_IDR14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIDR_IDR14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIDR_IDR15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIDR_IDR15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}

// GPIO.ODR: GPIO port output data register
func (o *GPIO_Type) SetODR_ODR0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetODR_ODR0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}
func (o *GPIO_Type) SetODR_ODR1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetODR_ODR1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetODR_ODR2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetODR_ODR2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetODR_ODR3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetODR_ODR3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetODR_ODR4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetODR_ODR4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetODR_ODR5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetODR_ODR5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetODR_ODR6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetODR_ODR6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetODR_ODR7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetODR_ODR7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetODR_ODR8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetODR_ODR8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetODR_ODR9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetODR_ODR9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetODR_ODR10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetODR_ODR10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetODR_ODR11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetODR_ODR11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetODR_ODR12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetODR_ODR12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetODR_ODR13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetODR_ODR13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetODR_ODR14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetODR_ODR14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetODR_ODR15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetODR_ODR15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}

// GPIO.BSRR: GPIO port bit set/reset register
func (o *GPIO_Type) SetBSRR_BS0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBSRR_BS0() uint32 {
	return volatile.LoadUint32(&o.BSRR.Reg) & 0x1
}
func (o *GPIO_Type) SetBSRR_BS1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBSRR_BS1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBSRR_BS2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBSRR_BS2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBSRR_BS3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBSRR_BS3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBSRR_BS4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBSRR_BS4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBSRR_BS5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBSRR_BS5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBSRR_BS6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBSRR_BS6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBSRR_BS7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBSRR_BS7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBSRR_BS8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBSRR_BS8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBSRR_BS9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBSRR_BS9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBSRR_BS10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBSRR_BS10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBSRR_BS11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBSRR_BS11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBSRR_BS12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBSRR_BS12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBSRR_BS13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBSRR_BS13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBSRR_BS14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBSRR_BS14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBSRR_BS15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBSRR_BS15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetBSRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetBSRR_BR0() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetBSRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetBSRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetBSRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetBSRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetBSRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetBSRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetBSRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetBSRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetBSRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetBSRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetBSRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetBSRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetBSRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetBSRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetBSRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetBSRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetBSRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetBSRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetBSRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetBSRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetBSRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetBSRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetBSRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetBSRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetBSRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetBSRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetBSRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetBSRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetBSRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetBSRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000000) >> 31
}

// GPIO.LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
func (o *GPIO_Type) SetLCKR_LCK0(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLCKR_LCK0() uint32 {
	return volatile.LoadUint32(&o.LCKR.Reg) & 0x1
}
func (o *GPIO_Type) SetLCKR_LCK1(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLCKR_LCK1() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLCKR_LCK2(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLCKR_LCK2() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLCKR_LCK3(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLCKR_LCK3() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLCKR_LCK4(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLCKR_LCK4() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLCKR_LCK5(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLCKR_LCK5() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLCKR_LCK6(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLCKR_LCK6() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLCKR_LCK7(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLCKR_LCK7() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLCKR_LCK8(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLCKR_LCK8() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLCKR_LCK9(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLCKR_LCK9() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLCKR_LCK10(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLCKR_LCK10() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLCKR_LCK11(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLCKR_LCK11() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLCKR_LCK12(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLCKR_LCK12() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLCKR_LCK13(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLCKR_LCK13() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLCKR_LCK14(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLCKR_LCK14() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLCKR_LCK15(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLCKR_LCK15() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLCKR_LCKK(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLCKR_LCKK() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10000) >> 16
}

// GPIO.AFRL: GPIO alternate function low register
func (o *GPIO_Type) SetAFRL_AFR0(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRL_AFR0() uint32 {
	return volatile.LoadUint32(&o.AFRL.Reg) & 0xf
}
func (o *GPIO_Type) SetAFRL_AFR1(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRL_AFR1() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRL_AFR2(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRL_AFR2() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRL_AFR3(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRL_AFR3() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRL_AFR4(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRL_AFR4() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRL_AFR5(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRL_AFR5() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRL_AFR6(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRL_AFR6() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRL_AFR7(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRL_AFR7() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000000) >> 28
}

// GPIO.AFRH: GPIO alternate function high register
func (o *GPIO_Type) SetAFRH_AFR8(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRH_AFR8() uint32 {
	return volatile.LoadUint32(&o.AFRH.Reg) & 0xf
}
func (o *GPIO_Type) SetAFRH_AFR9(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRH_AFR9() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRH_AFR10(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRH_AFR10() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRH_AFR11(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRH_AFR11() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRH_AFR12(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRH_AFR12() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRH_AFR13(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRH_AFR13() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRH_AFR14(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRH_AFR14() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRH_AFR15(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRH_AFR15() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000000) >> 28
}

// HSEM
type HSEM_Type struct {
	R0     volatile.Register32 // 0x0
	R1     volatile.Register32 // 0x4
	R2     volatile.Register32 // 0x8
	R3     volatile.Register32 // 0xC
	R4     volatile.Register32 // 0x10
	R5     volatile.Register32 // 0x14
	R6     volatile.Register32 // 0x18
	R7     volatile.Register32 // 0x1C
	R8     volatile.Register32 // 0x20
	R9     volatile.Register32 // 0x24
	R10    volatile.Register32 // 0x28
	R11    volatile.Register32 // 0x2C
	R12    volatile.Register32 // 0x30
	R13    volatile.Register32 // 0x34
	R14    volatile.Register32 // 0x38
	R15    volatile.Register32 // 0x3C
	R16    volatile.Register32 // 0x40
	R17    volatile.Register32 // 0x44
	R18    volatile.Register32 // 0x48
	R19    volatile.Register32 // 0x4C
	R20    volatile.Register32 // 0x50
	R21    volatile.Register32 // 0x54
	R22    volatile.Register32 // 0x58
	R23    volatile.Register32 // 0x5C
	R24    volatile.Register32 // 0x60
	R25    volatile.Register32 // 0x64
	R26    volatile.Register32 // 0x68
	R27    volatile.Register32 // 0x6C
	R28    volatile.Register32 // 0x70
	R29    volatile.Register32 // 0x74
	R30    volatile.Register32 // 0x78
	R31    volatile.Register32 // 0x7C
	RLR0   volatile.Register32 // 0x80
	RLR1   volatile.Register32 // 0x84
	RLR2   volatile.Register32 // 0x88
	RLR3   volatile.Register32 // 0x8C
	RLR4   volatile.Register32 // 0x90
	RLR5   volatile.Register32 // 0x94
	RLR6   volatile.Register32 // 0x98
	RLR7   volatile.Register32 // 0x9C
	RLR8   volatile.Register32 // 0xA0
	RLR9   volatile.Register32 // 0xA4
	RLR10  volatile.Register32 // 0xA8
	RLR11  volatile.Register32 // 0xAC
	RLR12  volatile.Register32 // 0xB0
	RLR13  volatile.Register32 // 0xB4
	RLR14  volatile.Register32 // 0xB8
	RLR15  volatile.Register32 // 0xBC
	RLR16  volatile.Register32 // 0xC0
	RLR17  volatile.Register32 // 0xC4
	RLR18  volatile.Register32 // 0xC8
	RLR19  volatile.Register32 // 0xCC
	RLR20  volatile.Register32 // 0xD0
	RLR21  volatile.Register32 // 0xD4
	RLR22  volatile.Register32 // 0xD8
	RLR23  volatile.Register32 // 0xDC
	RLR24  volatile.Register32 // 0xE0
	RLR25  volatile.Register32 // 0xE4
	RLR26  volatile.Register32 // 0xE8
	RLR27  volatile.Register32 // 0xEC
	RLR28  volatile.Register32 // 0xF0
	RLR29  volatile.Register32 // 0xF4
	RLR30  volatile.Register32 // 0xF8
	RLR31  volatile.Register32 // 0xFC
	C1IER  volatile.Register32 // 0x100
	C1ICR  volatile.Register32 // 0x104
	C1ISR  volatile.Register32 // 0x108
	C1MISR volatile.Register32 // 0x10C
	_      [48]byte
	CR     volatile.Register32 // 0x140
	KEYR   volatile.Register32 // 0x144
}

// HSEM.R0: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR0_PROCID(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR0_PROCID() uint32 {
	return volatile.LoadUint32(&o.R0.Reg) & 0xff
}
func (o *HSEM_Type) SetR0_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR0_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R0.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR0_LOCK(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR0_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R0.Reg) & 0x80000000) >> 31
}

// HSEM.R1: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR1_PROCID(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR1_PROCID() uint32 {
	return volatile.LoadUint32(&o.R1.Reg) & 0xff
}
func (o *HSEM_Type) SetR1_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR1_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R1.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR1_LOCK(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R1.Reg) & 0x80000000) >> 31
}

// HSEM.R2: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR2_PROCID(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR2_PROCID() uint32 {
	return volatile.LoadUint32(&o.R2.Reg) & 0xff
}
func (o *HSEM_Type) SetR2_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR2_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R2.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR2_LOCK(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R2.Reg) & 0x80000000) >> 31
}

// HSEM.R3: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR3_PROCID(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR3_PROCID() uint32 {
	return volatile.LoadUint32(&o.R3.Reg) & 0xff
}
func (o *HSEM_Type) SetR3_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR3_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R3.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR3_LOCK(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR3_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R3.Reg) & 0x80000000) >> 31
}

// HSEM.R4: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR4_PROCID(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR4_PROCID() uint32 {
	return volatile.LoadUint32(&o.R4.Reg) & 0xff
}
func (o *HSEM_Type) SetR4_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR4_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R4.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR4_LOCK(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR4_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R4.Reg) & 0x80000000) >> 31
}

// HSEM.R5: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR5_PROCID(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR5_PROCID() uint32 {
	return volatile.LoadUint32(&o.R5.Reg) & 0xff
}
func (o *HSEM_Type) SetR5_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR5_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R5.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR5_LOCK(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR5_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R5.Reg) & 0x80000000) >> 31
}

// HSEM.R6: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR6_PROCID(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR6_PROCID() uint32 {
	return volatile.LoadUint32(&o.R6.Reg) & 0xff
}
func (o *HSEM_Type) SetR6_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR6_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R6.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR6_LOCK(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR6_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R6.Reg) & 0x80000000) >> 31
}

// HSEM.R7: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR7_PROCID(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR7_PROCID() uint32 {
	return volatile.LoadUint32(&o.R7.Reg) & 0xff
}
func (o *HSEM_Type) SetR7_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR7_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R7.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR7_LOCK(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR7_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R7.Reg) & 0x80000000) >> 31
}

// HSEM.R8: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR8_PROCID(value uint32) {
	volatile.StoreUint32(&o.R8.Reg, volatile.LoadUint32(&o.R8.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR8_PROCID() uint32 {
	return volatile.LoadUint32(&o.R8.Reg) & 0xff
}
func (o *HSEM_Type) SetR8_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R8.Reg, volatile.LoadUint32(&o.R8.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR8_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R8.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR8_LOCK(value uint32) {
	volatile.StoreUint32(&o.R8.Reg, volatile.LoadUint32(&o.R8.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR8_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R8.Reg) & 0x80000000) >> 31
}

// HSEM.R9: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR9_PROCID(value uint32) {
	volatile.StoreUint32(&o.R9.Reg, volatile.LoadUint32(&o.R9.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR9_PROCID() uint32 {
	return volatile.LoadUint32(&o.R9.Reg) & 0xff
}
func (o *HSEM_Type) SetR9_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R9.Reg, volatile.LoadUint32(&o.R9.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR9_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R9.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR9_LOCK(value uint32) {
	volatile.StoreUint32(&o.R9.Reg, volatile.LoadUint32(&o.R9.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR9_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R9.Reg) & 0x80000000) >> 31
}

// HSEM.R10: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR10_PROCID(value uint32) {
	volatile.StoreUint32(&o.R10.Reg, volatile.LoadUint32(&o.R10.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR10_PROCID() uint32 {
	return volatile.LoadUint32(&o.R10.Reg) & 0xff
}
func (o *HSEM_Type) SetR10_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R10.Reg, volatile.LoadUint32(&o.R10.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR10_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R10.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR10_LOCK(value uint32) {
	volatile.StoreUint32(&o.R10.Reg, volatile.LoadUint32(&o.R10.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR10_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R10.Reg) & 0x80000000) >> 31
}

// HSEM.R11: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR11_PROCID(value uint32) {
	volatile.StoreUint32(&o.R11.Reg, volatile.LoadUint32(&o.R11.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR11_PROCID() uint32 {
	return volatile.LoadUint32(&o.R11.Reg) & 0xff
}
func (o *HSEM_Type) SetR11_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R11.Reg, volatile.LoadUint32(&o.R11.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR11_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R11.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR11_LOCK(value uint32) {
	volatile.StoreUint32(&o.R11.Reg, volatile.LoadUint32(&o.R11.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR11_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R11.Reg) & 0x80000000) >> 31
}

// HSEM.R12: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR12_PROCID(value uint32) {
	volatile.StoreUint32(&o.R12.Reg, volatile.LoadUint32(&o.R12.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR12_PROCID() uint32 {
	return volatile.LoadUint32(&o.R12.Reg) & 0xff
}
func (o *HSEM_Type) SetR12_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R12.Reg, volatile.LoadUint32(&o.R12.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR12_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R12.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR12_LOCK(value uint32) {
	volatile.StoreUint32(&o.R12.Reg, volatile.LoadUint32(&o.R12.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR12_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R12.Reg) & 0x80000000) >> 31
}

// HSEM.R13: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR13_PROCID(value uint32) {
	volatile.StoreUint32(&o.R13.Reg, volatile.LoadUint32(&o.R13.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR13_PROCID() uint32 {
	return volatile.LoadUint32(&o.R13.Reg) & 0xff
}
func (o *HSEM_Type) SetR13_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R13.Reg, volatile.LoadUint32(&o.R13.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR13_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R13.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR13_LOCK(value uint32) {
	volatile.StoreUint32(&o.R13.Reg, volatile.LoadUint32(&o.R13.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR13_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R13.Reg) & 0x80000000) >> 31
}

// HSEM.R14: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR14_PROCID(value uint32) {
	volatile.StoreUint32(&o.R14.Reg, volatile.LoadUint32(&o.R14.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR14_PROCID() uint32 {
	return volatile.LoadUint32(&o.R14.Reg) & 0xff
}
func (o *HSEM_Type) SetR14_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R14.Reg, volatile.LoadUint32(&o.R14.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR14_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R14.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR14_LOCK(value uint32) {
	volatile.StoreUint32(&o.R14.Reg, volatile.LoadUint32(&o.R14.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR14_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R14.Reg) & 0x80000000) >> 31
}

// HSEM.R15: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR15_PROCID(value uint32) {
	volatile.StoreUint32(&o.R15.Reg, volatile.LoadUint32(&o.R15.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR15_PROCID() uint32 {
	return volatile.LoadUint32(&o.R15.Reg) & 0xff
}
func (o *HSEM_Type) SetR15_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R15.Reg, volatile.LoadUint32(&o.R15.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR15_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R15.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR15_LOCK(value uint32) {
	volatile.StoreUint32(&o.R15.Reg, volatile.LoadUint32(&o.R15.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR15_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R15.Reg) & 0x80000000) >> 31
}

// HSEM.R16: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR16_PROCID(value uint32) {
	volatile.StoreUint32(&o.R16.Reg, volatile.LoadUint32(&o.R16.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR16_PROCID() uint32 {
	return volatile.LoadUint32(&o.R16.Reg) & 0xff
}
func (o *HSEM_Type) SetR16_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R16.Reg, volatile.LoadUint32(&o.R16.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR16_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R16.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR16_LOCK(value uint32) {
	volatile.StoreUint32(&o.R16.Reg, volatile.LoadUint32(&o.R16.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR16_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R16.Reg) & 0x80000000) >> 31
}

// HSEM.R17: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR17_PROCID(value uint32) {
	volatile.StoreUint32(&o.R17.Reg, volatile.LoadUint32(&o.R17.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR17_PROCID() uint32 {
	return volatile.LoadUint32(&o.R17.Reg) & 0xff
}
func (o *HSEM_Type) SetR17_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R17.Reg, volatile.LoadUint32(&o.R17.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR17_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R17.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR17_LOCK(value uint32) {
	volatile.StoreUint32(&o.R17.Reg, volatile.LoadUint32(&o.R17.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR17_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R17.Reg) & 0x80000000) >> 31
}

// HSEM.R18: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR18_PROCID(value uint32) {
	volatile.StoreUint32(&o.R18.Reg, volatile.LoadUint32(&o.R18.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR18_PROCID() uint32 {
	return volatile.LoadUint32(&o.R18.Reg) & 0xff
}
func (o *HSEM_Type) SetR18_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R18.Reg, volatile.LoadUint32(&o.R18.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR18_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R18.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR18_LOCK(value uint32) {
	volatile.StoreUint32(&o.R18.Reg, volatile.LoadUint32(&o.R18.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR18_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R18.Reg) & 0x80000000) >> 31
}

// HSEM.R19: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR19_PROCID(value uint32) {
	volatile.StoreUint32(&o.R19.Reg, volatile.LoadUint32(&o.R19.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR19_PROCID() uint32 {
	return volatile.LoadUint32(&o.R19.Reg) & 0xff
}
func (o *HSEM_Type) SetR19_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R19.Reg, volatile.LoadUint32(&o.R19.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR19_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R19.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR19_LOCK(value uint32) {
	volatile.StoreUint32(&o.R19.Reg, volatile.LoadUint32(&o.R19.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR19_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R19.Reg) & 0x80000000) >> 31
}

// HSEM.R20: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR20_PROCID(value uint32) {
	volatile.StoreUint32(&o.R20.Reg, volatile.LoadUint32(&o.R20.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR20_PROCID() uint32 {
	return volatile.LoadUint32(&o.R20.Reg) & 0xff
}
func (o *HSEM_Type) SetR20_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R20.Reg, volatile.LoadUint32(&o.R20.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR20_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R20.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR20_LOCK(value uint32) {
	volatile.StoreUint32(&o.R20.Reg, volatile.LoadUint32(&o.R20.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR20_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R20.Reg) & 0x80000000) >> 31
}

// HSEM.R21: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR21_PROCID(value uint32) {
	volatile.StoreUint32(&o.R21.Reg, volatile.LoadUint32(&o.R21.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR21_PROCID() uint32 {
	return volatile.LoadUint32(&o.R21.Reg) & 0xff
}
func (o *HSEM_Type) SetR21_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R21.Reg, volatile.LoadUint32(&o.R21.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR21_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R21.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR21_LOCK(value uint32) {
	volatile.StoreUint32(&o.R21.Reg, volatile.LoadUint32(&o.R21.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR21_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R21.Reg) & 0x80000000) >> 31
}

// HSEM.R22: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR22_PROCID(value uint32) {
	volatile.StoreUint32(&o.R22.Reg, volatile.LoadUint32(&o.R22.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR22_PROCID() uint32 {
	return volatile.LoadUint32(&o.R22.Reg) & 0xff
}
func (o *HSEM_Type) SetR22_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R22.Reg, volatile.LoadUint32(&o.R22.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR22_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R22.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR22_LOCK(value uint32) {
	volatile.StoreUint32(&o.R22.Reg, volatile.LoadUint32(&o.R22.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR22_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R22.Reg) & 0x80000000) >> 31
}

// HSEM.R23: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR23_PROCID(value uint32) {
	volatile.StoreUint32(&o.R23.Reg, volatile.LoadUint32(&o.R23.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR23_PROCID() uint32 {
	return volatile.LoadUint32(&o.R23.Reg) & 0xff
}
func (o *HSEM_Type) SetR23_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R23.Reg, volatile.LoadUint32(&o.R23.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR23_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R23.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR23_LOCK(value uint32) {
	volatile.StoreUint32(&o.R23.Reg, volatile.LoadUint32(&o.R23.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR23_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R23.Reg) & 0x80000000) >> 31
}

// HSEM.R24: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR24_PROCID(value uint32) {
	volatile.StoreUint32(&o.R24.Reg, volatile.LoadUint32(&o.R24.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR24_PROCID() uint32 {
	return volatile.LoadUint32(&o.R24.Reg) & 0xff
}
func (o *HSEM_Type) SetR24_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R24.Reg, volatile.LoadUint32(&o.R24.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR24_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R24.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR24_LOCK(value uint32) {
	volatile.StoreUint32(&o.R24.Reg, volatile.LoadUint32(&o.R24.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR24_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R24.Reg) & 0x80000000) >> 31
}

// HSEM.R25: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR25_PROCID(value uint32) {
	volatile.StoreUint32(&o.R25.Reg, volatile.LoadUint32(&o.R25.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR25_PROCID() uint32 {
	return volatile.LoadUint32(&o.R25.Reg) & 0xff
}
func (o *HSEM_Type) SetR25_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R25.Reg, volatile.LoadUint32(&o.R25.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR25_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R25.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR25_LOCK(value uint32) {
	volatile.StoreUint32(&o.R25.Reg, volatile.LoadUint32(&o.R25.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR25_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R25.Reg) & 0x80000000) >> 31
}

// HSEM.R26: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR26_PROCID(value uint32) {
	volatile.StoreUint32(&o.R26.Reg, volatile.LoadUint32(&o.R26.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR26_PROCID() uint32 {
	return volatile.LoadUint32(&o.R26.Reg) & 0xff
}
func (o *HSEM_Type) SetR26_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R26.Reg, volatile.LoadUint32(&o.R26.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR26_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R26.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR26_LOCK(value uint32) {
	volatile.StoreUint32(&o.R26.Reg, volatile.LoadUint32(&o.R26.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR26_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R26.Reg) & 0x80000000) >> 31
}

// HSEM.R27: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR27_PROCID(value uint32) {
	volatile.StoreUint32(&o.R27.Reg, volatile.LoadUint32(&o.R27.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR27_PROCID() uint32 {
	return volatile.LoadUint32(&o.R27.Reg) & 0xff
}
func (o *HSEM_Type) SetR27_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R27.Reg, volatile.LoadUint32(&o.R27.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR27_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R27.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR27_LOCK(value uint32) {
	volatile.StoreUint32(&o.R27.Reg, volatile.LoadUint32(&o.R27.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR27_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R27.Reg) & 0x80000000) >> 31
}

// HSEM.R28: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR28_PROCID(value uint32) {
	volatile.StoreUint32(&o.R28.Reg, volatile.LoadUint32(&o.R28.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR28_PROCID() uint32 {
	return volatile.LoadUint32(&o.R28.Reg) & 0xff
}
func (o *HSEM_Type) SetR28_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R28.Reg, volatile.LoadUint32(&o.R28.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR28_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R28.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR28_LOCK(value uint32) {
	volatile.StoreUint32(&o.R28.Reg, volatile.LoadUint32(&o.R28.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR28_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R28.Reg) & 0x80000000) >> 31
}

// HSEM.R29: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR29_PROCID(value uint32) {
	volatile.StoreUint32(&o.R29.Reg, volatile.LoadUint32(&o.R29.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR29_PROCID() uint32 {
	return volatile.LoadUint32(&o.R29.Reg) & 0xff
}
func (o *HSEM_Type) SetR29_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R29.Reg, volatile.LoadUint32(&o.R29.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR29_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R29.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR29_LOCK(value uint32) {
	volatile.StoreUint32(&o.R29.Reg, volatile.LoadUint32(&o.R29.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR29_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R29.Reg) & 0x80000000) >> 31
}

// HSEM.R30: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR30_PROCID(value uint32) {
	volatile.StoreUint32(&o.R30.Reg, volatile.LoadUint32(&o.R30.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR30_PROCID() uint32 {
	return volatile.LoadUint32(&o.R30.Reg) & 0xff
}
func (o *HSEM_Type) SetR30_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R30.Reg, volatile.LoadUint32(&o.R30.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR30_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R30.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR30_LOCK(value uint32) {
	volatile.StoreUint32(&o.R30.Reg, volatile.LoadUint32(&o.R30.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR30_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R30.Reg) & 0x80000000) >> 31
}

// HSEM.R31: HSEM register HSEM_R0 HSEM_R31
func (o *HSEM_Type) SetR31_PROCID(value uint32) {
	volatile.StoreUint32(&o.R31.Reg, volatile.LoadUint32(&o.R31.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetR31_PROCID() uint32 {
	return volatile.LoadUint32(&o.R31.Reg) & 0xff
}
func (o *HSEM_Type) SetR31_MASTERID(value uint32) {
	volatile.StoreUint32(&o.R31.Reg, volatile.LoadUint32(&o.R31.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetR31_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.R31.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetR31_LOCK(value uint32) {
	volatile.StoreUint32(&o.R31.Reg, volatile.LoadUint32(&o.R31.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetR31_LOCK() uint32 {
	return (volatile.LoadUint32(&o.R31.Reg) & 0x80000000) >> 31
}

// HSEM.RLR0: HSEM Read lock register
func (o *HSEM_Type) SetRLR0_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR0.Reg, volatile.LoadUint32(&o.RLR0.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR0_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR0.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR0_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR0.Reg, volatile.LoadUint32(&o.RLR0.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR0_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR0.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR0_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR0.Reg, volatile.LoadUint32(&o.RLR0.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR0_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR0.Reg) & 0x80000000) >> 31
}

// HSEM.RLR1: HSEM Read lock register
func (o *HSEM_Type) SetRLR1_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR1.Reg, volatile.LoadUint32(&o.RLR1.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR1_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR1.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR1_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR1.Reg, volatile.LoadUint32(&o.RLR1.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR1_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR1.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR1_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR1.Reg, volatile.LoadUint32(&o.RLR1.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR1.Reg) & 0x80000000) >> 31
}

// HSEM.RLR2: HSEM Read lock register
func (o *HSEM_Type) SetRLR2_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR2.Reg, volatile.LoadUint32(&o.RLR2.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR2_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR2.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR2_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR2.Reg, volatile.LoadUint32(&o.RLR2.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR2_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR2.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR2_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR2.Reg, volatile.LoadUint32(&o.RLR2.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR2.Reg) & 0x80000000) >> 31
}

// HSEM.RLR3: HSEM Read lock register
func (o *HSEM_Type) SetRLR3_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR3.Reg, volatile.LoadUint32(&o.RLR3.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR3_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR3.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR3_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR3.Reg, volatile.LoadUint32(&o.RLR3.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR3_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR3.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR3_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR3.Reg, volatile.LoadUint32(&o.RLR3.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR3_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR3.Reg) & 0x80000000) >> 31
}

// HSEM.RLR4: HSEM Read lock register
func (o *HSEM_Type) SetRLR4_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR4.Reg, volatile.LoadUint32(&o.RLR4.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR4_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR4.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR4_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR4.Reg, volatile.LoadUint32(&o.RLR4.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR4_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR4.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR4_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR4.Reg, volatile.LoadUint32(&o.RLR4.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR4_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR4.Reg) & 0x80000000) >> 31
}

// HSEM.RLR5: HSEM Read lock register
func (o *HSEM_Type) SetRLR5_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR5.Reg, volatile.LoadUint32(&o.RLR5.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR5_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR5.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR5_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR5.Reg, volatile.LoadUint32(&o.RLR5.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR5_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR5.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR5_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR5.Reg, volatile.LoadUint32(&o.RLR5.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR5_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR5.Reg) & 0x80000000) >> 31
}

// HSEM.RLR6: HSEM Read lock register
func (o *HSEM_Type) SetRLR6_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR6.Reg, volatile.LoadUint32(&o.RLR6.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR6_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR6.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR6_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR6.Reg, volatile.LoadUint32(&o.RLR6.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR6_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR6.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR6_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR6.Reg, volatile.LoadUint32(&o.RLR6.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR6_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR6.Reg) & 0x80000000) >> 31
}

// HSEM.RLR7: HSEM Read lock register
func (o *HSEM_Type) SetRLR7_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR7.Reg, volatile.LoadUint32(&o.RLR7.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR7_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR7.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR7_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR7.Reg, volatile.LoadUint32(&o.RLR7.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR7_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR7.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR7_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR7.Reg, volatile.LoadUint32(&o.RLR7.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR7_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR7.Reg) & 0x80000000) >> 31
}

// HSEM.RLR8: HSEM Read lock register
func (o *HSEM_Type) SetRLR8_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR8.Reg, volatile.LoadUint32(&o.RLR8.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR8_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR8.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR8_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR8.Reg, volatile.LoadUint32(&o.RLR8.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR8_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR8.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR8_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR8.Reg, volatile.LoadUint32(&o.RLR8.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR8_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR8.Reg) & 0x80000000) >> 31
}

// HSEM.RLR9: HSEM Read lock register
func (o *HSEM_Type) SetRLR9_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR9.Reg, volatile.LoadUint32(&o.RLR9.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR9_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR9.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR9_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR9.Reg, volatile.LoadUint32(&o.RLR9.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR9_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR9.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR9_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR9.Reg, volatile.LoadUint32(&o.RLR9.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR9_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR9.Reg) & 0x80000000) >> 31
}

// HSEM.RLR10: HSEM Read lock register
func (o *HSEM_Type) SetRLR10_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR10.Reg, volatile.LoadUint32(&o.RLR10.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR10_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR10.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR10_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR10.Reg, volatile.LoadUint32(&o.RLR10.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR10_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR10.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR10_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR10.Reg, volatile.LoadUint32(&o.RLR10.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR10_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR10.Reg) & 0x80000000) >> 31
}

// HSEM.RLR11: HSEM Read lock register
func (o *HSEM_Type) SetRLR11_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR11.Reg, volatile.LoadUint32(&o.RLR11.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR11_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR11.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR11_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR11.Reg, volatile.LoadUint32(&o.RLR11.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR11_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR11.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR11_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR11.Reg, volatile.LoadUint32(&o.RLR11.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR11_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR11.Reg) & 0x80000000) >> 31
}

// HSEM.RLR12: HSEM Read lock register
func (o *HSEM_Type) SetRLR12_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR12.Reg, volatile.LoadUint32(&o.RLR12.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR12_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR12.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR12_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR12.Reg, volatile.LoadUint32(&o.RLR12.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR12_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR12.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR12_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR12.Reg, volatile.LoadUint32(&o.RLR12.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR12_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR12.Reg) & 0x80000000) >> 31
}

// HSEM.RLR13: HSEM Read lock register
func (o *HSEM_Type) SetRLR13_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR13.Reg, volatile.LoadUint32(&o.RLR13.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR13_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR13.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR13_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR13.Reg, volatile.LoadUint32(&o.RLR13.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR13_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR13.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR13_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR13.Reg, volatile.LoadUint32(&o.RLR13.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR13_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR13.Reg) & 0x80000000) >> 31
}

// HSEM.RLR14: HSEM Read lock register
func (o *HSEM_Type) SetRLR14_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR14.Reg, volatile.LoadUint32(&o.RLR14.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR14_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR14.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR14_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR14.Reg, volatile.LoadUint32(&o.RLR14.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR14_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR14.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR14_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR14.Reg, volatile.LoadUint32(&o.RLR14.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR14_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR14.Reg) & 0x80000000) >> 31
}

// HSEM.RLR15: HSEM Read lock register
func (o *HSEM_Type) SetRLR15_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR15.Reg, volatile.LoadUint32(&o.RLR15.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR15_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR15.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR15_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR15.Reg, volatile.LoadUint32(&o.RLR15.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR15_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR15.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR15_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR15.Reg, volatile.LoadUint32(&o.RLR15.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR15_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR15.Reg) & 0x80000000) >> 31
}

// HSEM.RLR16: HSEM Read lock register
func (o *HSEM_Type) SetRLR16_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR16.Reg, volatile.LoadUint32(&o.RLR16.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR16_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR16.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR16_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR16.Reg, volatile.LoadUint32(&o.RLR16.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR16_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR16.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR16_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR16.Reg, volatile.LoadUint32(&o.RLR16.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR16_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR16.Reg) & 0x80000000) >> 31
}

// HSEM.RLR17: HSEM Read lock register
func (o *HSEM_Type) SetRLR17_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR17.Reg, volatile.LoadUint32(&o.RLR17.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR17_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR17.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR17_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR17.Reg, volatile.LoadUint32(&o.RLR17.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR17_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR17.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR17_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR17.Reg, volatile.LoadUint32(&o.RLR17.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR17_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR17.Reg) & 0x80000000) >> 31
}

// HSEM.RLR18: HSEM Read lock register
func (o *HSEM_Type) SetRLR18_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR18.Reg, volatile.LoadUint32(&o.RLR18.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR18_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR18.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR18_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR18.Reg, volatile.LoadUint32(&o.RLR18.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR18_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR18.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR18_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR18.Reg, volatile.LoadUint32(&o.RLR18.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR18_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR18.Reg) & 0x80000000) >> 31
}

// HSEM.RLR19: HSEM Read lock register
func (o *HSEM_Type) SetRLR19_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR19.Reg, volatile.LoadUint32(&o.RLR19.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR19_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR19.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR19_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR19.Reg, volatile.LoadUint32(&o.RLR19.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR19_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR19.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR19_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR19.Reg, volatile.LoadUint32(&o.RLR19.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR19_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR19.Reg) & 0x80000000) >> 31
}

// HSEM.RLR20: HSEM Read lock register
func (o *HSEM_Type) SetRLR20_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR20.Reg, volatile.LoadUint32(&o.RLR20.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR20_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR20.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR20_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR20.Reg, volatile.LoadUint32(&o.RLR20.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR20_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR20.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR20_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR20.Reg, volatile.LoadUint32(&o.RLR20.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR20_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR20.Reg) & 0x80000000) >> 31
}

// HSEM.RLR21: HSEM Read lock register
func (o *HSEM_Type) SetRLR21_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR21.Reg, volatile.LoadUint32(&o.RLR21.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR21_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR21.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR21_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR21.Reg, volatile.LoadUint32(&o.RLR21.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR21_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR21.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR21_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR21.Reg, volatile.LoadUint32(&o.RLR21.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR21_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR21.Reg) & 0x80000000) >> 31
}

// HSEM.RLR22: HSEM Read lock register
func (o *HSEM_Type) SetRLR22_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR22.Reg, volatile.LoadUint32(&o.RLR22.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR22_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR22.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR22_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR22.Reg, volatile.LoadUint32(&o.RLR22.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR22_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR22.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR22_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR22.Reg, volatile.LoadUint32(&o.RLR22.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR22_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR22.Reg) & 0x80000000) >> 31
}

// HSEM.RLR23: HSEM Read lock register
func (o *HSEM_Type) SetRLR23_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR23.Reg, volatile.LoadUint32(&o.RLR23.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR23_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR23.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR23_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR23.Reg, volatile.LoadUint32(&o.RLR23.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR23_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR23.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR23_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR23.Reg, volatile.LoadUint32(&o.RLR23.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR23_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR23.Reg) & 0x80000000) >> 31
}

// HSEM.RLR24: HSEM Read lock register
func (o *HSEM_Type) SetRLR24_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR24.Reg, volatile.LoadUint32(&o.RLR24.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR24_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR24.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR24_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR24.Reg, volatile.LoadUint32(&o.RLR24.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR24_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR24.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR24_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR24.Reg, volatile.LoadUint32(&o.RLR24.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR24_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR24.Reg) & 0x80000000) >> 31
}

// HSEM.RLR25: HSEM Read lock register
func (o *HSEM_Type) SetRLR25_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR25.Reg, volatile.LoadUint32(&o.RLR25.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR25_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR25.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR25_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR25.Reg, volatile.LoadUint32(&o.RLR25.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR25_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR25.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR25_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR25.Reg, volatile.LoadUint32(&o.RLR25.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR25_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR25.Reg) & 0x80000000) >> 31
}

// HSEM.RLR26: HSEM Read lock register
func (o *HSEM_Type) SetRLR26_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR26.Reg, volatile.LoadUint32(&o.RLR26.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR26_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR26.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR26_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR26.Reg, volatile.LoadUint32(&o.RLR26.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR26_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR26.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR26_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR26.Reg, volatile.LoadUint32(&o.RLR26.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR26_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR26.Reg) & 0x80000000) >> 31
}

// HSEM.RLR27: HSEM Read lock register
func (o *HSEM_Type) SetRLR27_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR27.Reg, volatile.LoadUint32(&o.RLR27.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR27_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR27.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR27_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR27.Reg, volatile.LoadUint32(&o.RLR27.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR27_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR27.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR27_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR27.Reg, volatile.LoadUint32(&o.RLR27.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR27_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR27.Reg) & 0x80000000) >> 31
}

// HSEM.RLR28: HSEM Read lock register
func (o *HSEM_Type) SetRLR28_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR28.Reg, volatile.LoadUint32(&o.RLR28.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR28_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR28.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR28_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR28.Reg, volatile.LoadUint32(&o.RLR28.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR28_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR28.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR28_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR28.Reg, volatile.LoadUint32(&o.RLR28.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR28_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR28.Reg) & 0x80000000) >> 31
}

// HSEM.RLR29: HSEM Read lock register
func (o *HSEM_Type) SetRLR29_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR29.Reg, volatile.LoadUint32(&o.RLR29.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR29_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR29.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR29_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR29.Reg, volatile.LoadUint32(&o.RLR29.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR29_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR29.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR29_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR29.Reg, volatile.LoadUint32(&o.RLR29.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR29_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR29.Reg) & 0x80000000) >> 31
}

// HSEM.RLR30: HSEM Read lock register
func (o *HSEM_Type) SetRLR30_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR30.Reg, volatile.LoadUint32(&o.RLR30.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR30_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR30.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR30_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR30.Reg, volatile.LoadUint32(&o.RLR30.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR30_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR30.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR30_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR30.Reg, volatile.LoadUint32(&o.RLR30.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR30_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR30.Reg) & 0x80000000) >> 31
}

// HSEM.RLR31: HSEM Read lock register
func (o *HSEM_Type) SetRLR31_PROCID(value uint32) {
	volatile.StoreUint32(&o.RLR31.Reg, volatile.LoadUint32(&o.RLR31.Reg)&^(0xff)|value)
}
func (o *HSEM_Type) GetRLR31_PROCID() uint32 {
	return volatile.LoadUint32(&o.RLR31.Reg) & 0xff
}
func (o *HSEM_Type) SetRLR31_MASTERID(value uint32) {
	volatile.StoreUint32(&o.RLR31.Reg, volatile.LoadUint32(&o.RLR31.Reg)&^(0xff00)|value<<8)
}
func (o *HSEM_Type) GetRLR31_MASTERID() uint32 {
	return (volatile.LoadUint32(&o.RLR31.Reg) & 0xff00) >> 8
}
func (o *HSEM_Type) SetRLR31_LOCK(value uint32) {
	volatile.StoreUint32(&o.RLR31.Reg, volatile.LoadUint32(&o.RLR31.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetRLR31_LOCK() uint32 {
	return (volatile.LoadUint32(&o.RLR31.Reg) & 0x80000000) >> 31
}

// HSEM.C1IER: HSEM Interrupt enable register
func (o *HSEM_Type) SetC1IER_ISEM0(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1IER_ISEM0() uint32 {
	return volatile.LoadUint32(&o.C1IER.Reg) & 0x1
}
func (o *HSEM_Type) SetC1IER_ISEM1(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1IER_ISEM1() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1IER_ISEM2(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1IER_ISEM2() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1IER_ISEM3(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1IER_ISEM3() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1IER_ISEM4(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1IER_ISEM4() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1IER_ISEM5(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1IER_ISEM5() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1IER_ISEM6(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1IER_ISEM6() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1IER_ISEM7(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1IER_ISEM7() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1IER_ISEM8(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1IER_ISEM8() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1IER_ISEM9(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1IER_ISEM9() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1IER_ISEM10(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1IER_ISEM10() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1IER_ISEM11(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1IER_ISEM11() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1IER_ISEM12(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1IER_ISEM12() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1IER_ISEM13(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1IER_ISEM13() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1IER_ISEM14(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1IER_ISEM14() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1IER_ISEM15(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1IER_ISEM15() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x8000) >> 15
}
func (o *HSEM_Type) SetC1IER_ISEM16(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x10000)|value<<16)
}
func (o *HSEM_Type) GetC1IER_ISEM16() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x10000) >> 16
}
func (o *HSEM_Type) SetC1IER_ISEM17(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x20000)|value<<17)
}
func (o *HSEM_Type) GetC1IER_ISEM17() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x20000) >> 17
}
func (o *HSEM_Type) SetC1IER_ISEM18(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x40000)|value<<18)
}
func (o *HSEM_Type) GetC1IER_ISEM18() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x40000) >> 18
}
func (o *HSEM_Type) SetC1IER_ISEM19(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x80000)|value<<19)
}
func (o *HSEM_Type) GetC1IER_ISEM19() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x80000) >> 19
}
func (o *HSEM_Type) SetC1IER_ISEM20(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x100000)|value<<20)
}
func (o *HSEM_Type) GetC1IER_ISEM20() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x100000) >> 20
}
func (o *HSEM_Type) SetC1IER_ISEM21(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x200000)|value<<21)
}
func (o *HSEM_Type) GetC1IER_ISEM21() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x200000) >> 21
}
func (o *HSEM_Type) SetC1IER_ISEM22(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x400000)|value<<22)
}
func (o *HSEM_Type) GetC1IER_ISEM22() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x400000) >> 22
}
func (o *HSEM_Type) SetC1IER_ISEM23(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x800000)|value<<23)
}
func (o *HSEM_Type) GetC1IER_ISEM23() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x800000) >> 23
}
func (o *HSEM_Type) SetC1IER_ISEM24(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x1000000)|value<<24)
}
func (o *HSEM_Type) GetC1IER_ISEM24() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x1000000) >> 24
}
func (o *HSEM_Type) SetC1IER_ISEM25(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x2000000)|value<<25)
}
func (o *HSEM_Type) GetC1IER_ISEM25() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x2000000) >> 25
}
func (o *HSEM_Type) SetC1IER_ISEM26(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x4000000)|value<<26)
}
func (o *HSEM_Type) GetC1IER_ISEM26() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x4000000) >> 26
}
func (o *HSEM_Type) SetC1IER_ISEM27(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x8000000)|value<<27)
}
func (o *HSEM_Type) GetC1IER_ISEM27() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x8000000) >> 27
}
func (o *HSEM_Type) SetC1IER_ISEM28(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x10000000)|value<<28)
}
func (o *HSEM_Type) GetC1IER_ISEM28() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x10000000) >> 28
}
func (o *HSEM_Type) SetC1IER_ISEM29(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x20000000)|value<<29)
}
func (o *HSEM_Type) GetC1IER_ISEM29() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x20000000) >> 29
}
func (o *HSEM_Type) SetC1IER_ISEM30(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x40000000)|value<<30)
}
func (o *HSEM_Type) GetC1IER_ISEM30() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x40000000) >> 30
}
func (o *HSEM_Type) SetC1IER_ISEM31(value uint32) {
	volatile.StoreUint32(&o.C1IER.Reg, volatile.LoadUint32(&o.C1IER.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetC1IER_ISEM31() uint32 {
	return (volatile.LoadUint32(&o.C1IER.Reg) & 0x80000000) >> 31
}

// HSEM.C1ICR: HSEM Interrupt clear register
func (o *HSEM_Type) SetC1ICR_ISEM0(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1ICR_ISEM0() uint32 {
	return volatile.LoadUint32(&o.C1ICR.Reg) & 0x1
}
func (o *HSEM_Type) SetC1ICR_ISEM1(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1ICR_ISEM1() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1ICR_ISEM2(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1ICR_ISEM2() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1ICR_ISEM3(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1ICR_ISEM3() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1ICR_ISEM4(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1ICR_ISEM4() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1ICR_ISEM5(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1ICR_ISEM5() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1ICR_ISEM6(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1ICR_ISEM6() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1ICR_ISEM7(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1ICR_ISEM7() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1ICR_ISEM8(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1ICR_ISEM8() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1ICR_ISEM9(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1ICR_ISEM9() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1ICR_ISEM10(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1ICR_ISEM10() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1ICR_ISEM11(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1ICR_ISEM11() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1ICR_ISEM12(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1ICR_ISEM12() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1ICR_ISEM13(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1ICR_ISEM13() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1ICR_ISEM14(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1ICR_ISEM14() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1ICR_ISEM15(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1ICR_ISEM15() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x8000) >> 15
}
func (o *HSEM_Type) SetC1ICR_ISEM16(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x10000)|value<<16)
}
func (o *HSEM_Type) GetC1ICR_ISEM16() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x10000) >> 16
}
func (o *HSEM_Type) SetC1ICR_ISEM17(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x20000)|value<<17)
}
func (o *HSEM_Type) GetC1ICR_ISEM17() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x20000) >> 17
}
func (o *HSEM_Type) SetC1ICR_ISEM18(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x40000)|value<<18)
}
func (o *HSEM_Type) GetC1ICR_ISEM18() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x40000) >> 18
}
func (o *HSEM_Type) SetC1ICR_ISEM19(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x80000)|value<<19)
}
func (o *HSEM_Type) GetC1ICR_ISEM19() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x80000) >> 19
}
func (o *HSEM_Type) SetC1ICR_ISEM20(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x100000)|value<<20)
}
func (o *HSEM_Type) GetC1ICR_ISEM20() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x100000) >> 20
}
func (o *HSEM_Type) SetC1ICR_ISEM21(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x200000)|value<<21)
}
func (o *HSEM_Type) GetC1ICR_ISEM21() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x200000) >> 21
}
func (o *HSEM_Type) SetC1ICR_ISEM22(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x400000)|value<<22)
}
func (o *HSEM_Type) GetC1ICR_ISEM22() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x400000) >> 22
}
func (o *HSEM_Type) SetC1ICR_ISEM23(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x800000)|value<<23)
}
func (o *HSEM_Type) GetC1ICR_ISEM23() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x800000) >> 23
}
func (o *HSEM_Type) SetC1ICR_ISEM24(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSEM_Type) GetC1ICR_ISEM24() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x1000000) >> 24
}
func (o *HSEM_Type) SetC1ICR_ISEM25(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSEM_Type) GetC1ICR_ISEM25() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x2000000) >> 25
}
func (o *HSEM_Type) SetC1ICR_ISEM26(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSEM_Type) GetC1ICR_ISEM26() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x4000000) >> 26
}
func (o *HSEM_Type) SetC1ICR_ISEM27(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSEM_Type) GetC1ICR_ISEM27() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x8000000) >> 27
}
func (o *HSEM_Type) SetC1ICR_ISEM28(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSEM_Type) GetC1ICR_ISEM28() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x10000000) >> 28
}
func (o *HSEM_Type) SetC1ICR_ISEM29(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSEM_Type) GetC1ICR_ISEM29() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x20000000) >> 29
}
func (o *HSEM_Type) SetC1ICR_ISEM30(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSEM_Type) GetC1ICR_ISEM30() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x40000000) >> 30
}
func (o *HSEM_Type) SetC1ICR_ISEM31(value uint32) {
	volatile.StoreUint32(&o.C1ICR.Reg, volatile.LoadUint32(&o.C1ICR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetC1ICR_ISEM31() uint32 {
	return (volatile.LoadUint32(&o.C1ICR.Reg) & 0x80000000) >> 31
}

// HSEM.C1ISR: HSEM Interrupt status register
func (o *HSEM_Type) SetC1ISR_ISEM0(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1ISR_ISEM0() uint32 {
	return volatile.LoadUint32(&o.C1ISR.Reg) & 0x1
}
func (o *HSEM_Type) SetC1ISR_ISEM1(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1ISR_ISEM1() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1ISR_ISEM2(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1ISR_ISEM2() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1ISR_ISEM3(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1ISR_ISEM3() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1ISR_ISEM4(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1ISR_ISEM4() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1ISR_ISEM5(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1ISR_ISEM5() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1ISR_ISEM6(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1ISR_ISEM6() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1ISR_ISEM7(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1ISR_ISEM7() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1ISR_ISEM8(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1ISR_ISEM8() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1ISR_ISEM9(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1ISR_ISEM9() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1ISR_ISEM10(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1ISR_ISEM10() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1ISR_ISEM11(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1ISR_ISEM11() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1ISR_ISEM12(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1ISR_ISEM12() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1ISR_ISEM13(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1ISR_ISEM13() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1ISR_ISEM14(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1ISR_ISEM14() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1ISR_ISEM15(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1ISR_ISEM15() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x8000) >> 15
}
func (o *HSEM_Type) SetC1ISR_ISEM16(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x10000)|value<<16)
}
func (o *HSEM_Type) GetC1ISR_ISEM16() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x10000) >> 16
}
func (o *HSEM_Type) SetC1ISR_ISEM17(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x20000)|value<<17)
}
func (o *HSEM_Type) GetC1ISR_ISEM17() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x20000) >> 17
}
func (o *HSEM_Type) SetC1ISR_ISEM18(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x40000)|value<<18)
}
func (o *HSEM_Type) GetC1ISR_ISEM18() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x40000) >> 18
}
func (o *HSEM_Type) SetC1ISR_ISEM19(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x80000)|value<<19)
}
func (o *HSEM_Type) GetC1ISR_ISEM19() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x80000) >> 19
}
func (o *HSEM_Type) SetC1ISR_ISEM20(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x100000)|value<<20)
}
func (o *HSEM_Type) GetC1ISR_ISEM20() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x100000) >> 20
}
func (o *HSEM_Type) SetC1ISR_ISEM21(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x200000)|value<<21)
}
func (o *HSEM_Type) GetC1ISR_ISEM21() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x200000) >> 21
}
func (o *HSEM_Type) SetC1ISR_ISEM22(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x400000)|value<<22)
}
func (o *HSEM_Type) GetC1ISR_ISEM22() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x400000) >> 22
}
func (o *HSEM_Type) SetC1ISR_ISEM23(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x800000)|value<<23)
}
func (o *HSEM_Type) GetC1ISR_ISEM23() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x800000) >> 23
}
func (o *HSEM_Type) SetC1ISR_ISEM24(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSEM_Type) GetC1ISR_ISEM24() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x1000000) >> 24
}
func (o *HSEM_Type) SetC1ISR_ISEM25(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSEM_Type) GetC1ISR_ISEM25() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x2000000) >> 25
}
func (o *HSEM_Type) SetC1ISR_ISEM26(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSEM_Type) GetC1ISR_ISEM26() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x4000000) >> 26
}
func (o *HSEM_Type) SetC1ISR_ISEM27(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSEM_Type) GetC1ISR_ISEM27() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x8000000) >> 27
}
func (o *HSEM_Type) SetC1ISR_ISEM28(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSEM_Type) GetC1ISR_ISEM28() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x10000000) >> 28
}
func (o *HSEM_Type) SetC1ISR_ISEM29(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSEM_Type) GetC1ISR_ISEM29() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x20000000) >> 29
}
func (o *HSEM_Type) SetC1ISR_ISEM30(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSEM_Type) GetC1ISR_ISEM30() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x40000000) >> 30
}
func (o *HSEM_Type) SetC1ISR_ISEM31(value uint32) {
	volatile.StoreUint32(&o.C1ISR.Reg, volatile.LoadUint32(&o.C1ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetC1ISR_ISEM31() uint32 {
	return (volatile.LoadUint32(&o.C1ISR.Reg) & 0x80000000) >> 31
}

// HSEM.C1MISR: HSEM Masked interrupt status register
func (o *HSEM_Type) SetC1MISR_ISEM0(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x1)|value)
}
func (o *HSEM_Type) GetC1MISR_ISEM0() uint32 {
	return volatile.LoadUint32(&o.C1MISR.Reg) & 0x1
}
func (o *HSEM_Type) SetC1MISR_ISEM1(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x2)|value<<1)
}
func (o *HSEM_Type) GetC1MISR_ISEM1() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x2) >> 1
}
func (o *HSEM_Type) SetC1MISR_ISEM2(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x4)|value<<2)
}
func (o *HSEM_Type) GetC1MISR_ISEM2() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x4) >> 2
}
func (o *HSEM_Type) SetC1MISR_ISEM3(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x8)|value<<3)
}
func (o *HSEM_Type) GetC1MISR_ISEM3() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x8) >> 3
}
func (o *HSEM_Type) SetC1MISR_ISEM4(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x10)|value<<4)
}
func (o *HSEM_Type) GetC1MISR_ISEM4() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x10) >> 4
}
func (o *HSEM_Type) SetC1MISR_ISEM5(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x20)|value<<5)
}
func (o *HSEM_Type) GetC1MISR_ISEM5() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x20) >> 5
}
func (o *HSEM_Type) SetC1MISR_ISEM6(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x40)|value<<6)
}
func (o *HSEM_Type) GetC1MISR_ISEM6() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x40) >> 6
}
func (o *HSEM_Type) SetC1MISR_ISEM7(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x80)|value<<7)
}
func (o *HSEM_Type) GetC1MISR_ISEM7() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x80) >> 7
}
func (o *HSEM_Type) SetC1MISR_ISEM8(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x100)|value<<8)
}
func (o *HSEM_Type) GetC1MISR_ISEM8() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x100) >> 8
}
func (o *HSEM_Type) SetC1MISR_ISEM9(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x200)|value<<9)
}
func (o *HSEM_Type) GetC1MISR_ISEM9() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x200) >> 9
}
func (o *HSEM_Type) SetC1MISR_ISEM10(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x400)|value<<10)
}
func (o *HSEM_Type) GetC1MISR_ISEM10() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x400) >> 10
}
func (o *HSEM_Type) SetC1MISR_ISEM11(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x800)|value<<11)
}
func (o *HSEM_Type) GetC1MISR_ISEM11() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x800) >> 11
}
func (o *HSEM_Type) SetC1MISR_ISEM12(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x1000)|value<<12)
}
func (o *HSEM_Type) GetC1MISR_ISEM12() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x1000) >> 12
}
func (o *HSEM_Type) SetC1MISR_ISEM13(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x2000)|value<<13)
}
func (o *HSEM_Type) GetC1MISR_ISEM13() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x2000) >> 13
}
func (o *HSEM_Type) SetC1MISR_ISEM14(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x4000)|value<<14)
}
func (o *HSEM_Type) GetC1MISR_ISEM14() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x4000) >> 14
}
func (o *HSEM_Type) SetC1MISR_ISEM15(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x8000)|value<<15)
}
func (o *HSEM_Type) GetC1MISR_ISEM15() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x8000) >> 15
}
func (o *HSEM_Type) SetC1MISR_ISEM16(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x10000)|value<<16)
}
func (o *HSEM_Type) GetC1MISR_ISEM16() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x10000) >> 16
}
func (o *HSEM_Type) SetC1MISR_ISEM17(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x20000)|value<<17)
}
func (o *HSEM_Type) GetC1MISR_ISEM17() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x20000) >> 17
}
func (o *HSEM_Type) SetC1MISR_ISEM18(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x40000)|value<<18)
}
func (o *HSEM_Type) GetC1MISR_ISEM18() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x40000) >> 18
}
func (o *HSEM_Type) SetC1MISR_ISEM19(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x80000)|value<<19)
}
func (o *HSEM_Type) GetC1MISR_ISEM19() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x80000) >> 19
}
func (o *HSEM_Type) SetC1MISR_ISEM20(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x100000)|value<<20)
}
func (o *HSEM_Type) GetC1MISR_ISEM20() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x100000) >> 20
}
func (o *HSEM_Type) SetC1MISR_ISEM21(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x200000)|value<<21)
}
func (o *HSEM_Type) GetC1MISR_ISEM21() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x200000) >> 21
}
func (o *HSEM_Type) SetC1MISR_ISEM22(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x400000)|value<<22)
}
func (o *HSEM_Type) GetC1MISR_ISEM22() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x400000) >> 22
}
func (o *HSEM_Type) SetC1MISR_ISEM23(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x800000)|value<<23)
}
func (o *HSEM_Type) GetC1MISR_ISEM23() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x800000) >> 23
}
func (o *HSEM_Type) SetC1MISR_ISEM24(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSEM_Type) GetC1MISR_ISEM24() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x1000000) >> 24
}
func (o *HSEM_Type) SetC1MISR_ISEM25(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSEM_Type) GetC1MISR_ISEM25() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x2000000) >> 25
}
func (o *HSEM_Type) SetC1MISR_ISEM26(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSEM_Type) GetC1MISR_ISEM26() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x4000000) >> 26
}
func (o *HSEM_Type) SetC1MISR_ISEM27(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSEM_Type) GetC1MISR_ISEM27() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x8000000) >> 27
}
func (o *HSEM_Type) SetC1MISR_ISEM28(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSEM_Type) GetC1MISR_ISEM28() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x10000000) >> 28
}
func (o *HSEM_Type) SetC1MISR_ISEM29(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSEM_Type) GetC1MISR_ISEM29() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x20000000) >> 29
}
func (o *HSEM_Type) SetC1MISR_ISEM30(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSEM_Type) GetC1MISR_ISEM30() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x40000000) >> 30
}
func (o *HSEM_Type) SetC1MISR_ISEM31(value uint32) {
	volatile.StoreUint32(&o.C1MISR.Reg, volatile.LoadUint32(&o.C1MISR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSEM_Type) GetC1MISR_ISEM31() uint32 {
	return (volatile.LoadUint32(&o.C1MISR.Reg) & 0x80000000) >> 31
}

// HSEM.CR: HSEM Clear register
func (o *HSEM_Type) SetCR_COREID(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *HSEM_Type) GetCR_COREID() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *HSEM_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSEM_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffff0000) >> 16
}

// HSEM.KEYR: HSEM Interrupt clear register
func (o *HSEM_Type) SetKEYR_KEY(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, volatile.LoadUint32(&o.KEYR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSEM_Type) GetKEYR_KEY() uint32 {
	return (volatile.LoadUint32(&o.KEYR.Reg) & 0xffff0000) >> 16
}

// I2C
type I2C_Type struct {
	CR1      volatile.Register32 // 0x0
	CR2      volatile.Register32 // 0x4
	OAR1     volatile.Register32 // 0x8
	OAR2     volatile.Register32 // 0xC
	TIMINGR  volatile.Register32 // 0x10
	TIMEOUTR volatile.Register32 // 0x14
	ISR      volatile.Register32 // 0x18
	ICR      volatile.Register32 // 0x1C
	PECR     volatile.Register32 // 0x20
	RXDR     volatile.Register32 // 0x24
	TXDR     volatile.Register32 // 0x28
}

// I2C.CR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
func (o *I2C_Type) SetCR1_PE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCR1_PE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *I2C_Type) SetCR1_TXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCR1_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCR1_RXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCR1_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCR1_ADDRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCR1_ADDRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCR1_NACKIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCR1_NACKIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCR1_STOPIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCR1_STOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCR1_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCR1_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCR1_DNF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00)|value<<8)
}
func (o *I2C_Type) GetCR1_DNF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00) >> 8
}
func (o *I2C_Type) SetCR1_ANFOFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR1_ANFOFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR1_SBC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetCR1_SBC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetCR1_NOSTRETCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetCR1_NOSTRETCH() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetCR1_WUPEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetCR1_WUPEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *I2C_Type) SetCR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetCR1_GCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetCR1_SMBHEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetCR1_SMBHEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetCR1_SMBDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetCR1_SMBDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *I2C_Type) SetCR1_ALERTEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400000)|value<<22)
}
func (o *I2C_Type) GetCR1_ALERTEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400000) >> 22
}
func (o *I2C_Type) SetCR1_PECEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *I2C_Type) GetCR1_PECEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}

// I2C.CR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
func (o *I2C_Type) SetCR2_RD_WRN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCR2_RD_WRN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCR2_ADD10(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCR2_ADD10() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCR2_HEAD10R(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR2_HEAD10R() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR2_START(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetCR2_START() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR2_NACK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR2_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR2_NBYTES(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C_Type) GetCR2_NBYTES() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff0000) >> 16
}
func (o *I2C_Type) SetCR2_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetCR2_RELOAD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetCR2_AUTOEND(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetCR2_AUTOEND() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}
func (o *I2C_Type) SetCR2_PECBYTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C_Type) GetCR2_PECBYTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000000) >> 26
}
func (o *I2C_Type) SetCR2_SADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetCR2_SADD() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x3ff
}

// I2C.OAR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
func (o *I2C_Type) SetOAR1_OA1(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetOAR1_OA1() uint32 {
	return volatile.LoadUint32(&o.OAR1.Reg) & 0x3ff
}
func (o *I2C_Type) SetOAR1_OA1MODE(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetOAR1_OA1MODE() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetOAR1_OA1EN(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR1_OA1EN() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x8000) >> 15
}

// I2C.OAR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
func (o *I2C_Type) SetOAR2_OA2(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOAR2_OA2() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOAR2_OA2MSK(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x700)|value<<8)
}
func (o *I2C_Type) GetOAR2_OA2MSK() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x700) >> 8
}
func (o *I2C_Type) SetOAR2_OA2EN(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR2_OA2EN() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x8000) >> 15
}

// I2C.TIMINGR: Access: No wait states
func (o *I2C_Type) SetTIMINGR_SCLL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTIMINGR_SCLL() uint32 {
	return volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff
}
func (o *I2C_Type) SetTIMINGR_SCLH(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff00)|value<<8)
}
func (o *I2C_Type) GetTIMINGR_SCLH() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff00) >> 8
}
func (o *I2C_Type) SetTIMINGR_SDADEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000)|value<<16)
}
func (o *I2C_Type) GetTIMINGR_SDADEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000) >> 16
}
func (o *I2C_Type) SetTIMINGR_SCLDEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf00000)|value<<20)
}
func (o *I2C_Type) GetTIMINGR_SCLDEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf00000) >> 20
}
func (o *I2C_Type) SetTIMINGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000000)|value<<28)
}
func (o *I2C_Type) GetTIMINGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000000) >> 28
}

// I2C.TIMEOUTR: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTA(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff)|value)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTA() uint32 {
	return volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff
}
func (o *I2C_Type) SetTIMEOUTR_TIDLE(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetTIMEOUTR_TIDLE() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetTIMEOUTR_TIMOUTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetTIMEOUTR_TIMOUTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTB(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff0000)|value<<16)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTB() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff0000) >> 16
}
func (o *I2C_Type) SetTIMEOUTR_TEXTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetTIMEOUTR_TEXTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x80000000) >> 31
}

// I2C.ISR: Access: No wait states
func (o *I2C_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetISR_TXE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *I2C_Type) SetISR_TXIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetISR_TXIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetISR_ADDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetISR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetISR_NACKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetISR_NACKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetISR_STOPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetISR_STOPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetISR_TCR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetISR_TCR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetISR_BERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetISR_BERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetISR_ARLO(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetISR_ARLO() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetISR_PECERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetISR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetISR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetISR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetISR_ALERT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetISR_ALERT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetISR_DIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetISR_ADDCODE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xfe0000)|value<<17)
}
func (o *I2C_Type) GetISR_ADDCODE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xfe0000) >> 17
}

// I2C.ICR: Access: No wait states
func (o *I2C_Type) SetICR_ADDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetICR_ADDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetICR_NACKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetICR_NACKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetICR_STOPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetICR_STOPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetICR_BERRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetICR_BERRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetICR_ARLOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetICR_ARLOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetICR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetICR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetICR_PECCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetICR_PECCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetICR_TIMOUTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetICR_TIMOUTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetICR_ALERTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetICR_ALERTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}

// I2C.PECR: Access: No wait states
func (o *I2C_Type) SetPECR_PEC(value uint32) {
	volatile.StoreUint32(&o.PECR.Reg, volatile.LoadUint32(&o.PECR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetPECR_PEC() uint32 {
	return volatile.LoadUint32(&o.PECR.Reg) & 0xff
}

// I2C.RXDR: Access: No wait states
func (o *I2C_Type) SetRXDR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetRXDR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// I2C.TXDR: Access: No wait states
func (o *I2C_Type) SetTXDR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTXDR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// IWDG
type IWDG_Type struct {
	KR   volatile.Register32 // 0x0
	PR   volatile.Register32 // 0x4
	RLR  volatile.Register32 // 0x8
	SR   volatile.Register32 // 0xC
	WINR volatile.Register32 // 0x10
}

// IWDG.KR: Key register
func (o *IWDG_Type) SetKR_KEY(value uint32) {
	volatile.StoreUint32(&o.KR.Reg, volatile.LoadUint32(&o.KR.Reg)&^(0xffff)|value)
}
func (o *IWDG_Type) GetKR_KEY() uint32 {
	return volatile.LoadUint32(&o.KR.Reg) & 0xffff
}

// IWDG.PR: Prescaler register
func (o *IWDG_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x7)|value)
}
func (o *IWDG_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0x7
}

// IWDG.RLR: Reload register
func (o *IWDG_Type) SetRLR_RL(value uint32) {
	volatile.StoreUint32(&o.RLR.Reg, volatile.LoadUint32(&o.RLR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetRLR_RL() uint32 {
	return volatile.LoadUint32(&o.RLR.Reg) & 0xfff
}

// IWDG.SR: Status register
func (o *IWDG_Type) SetSR_PVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *IWDG_Type) GetSR_PVU() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *IWDG_Type) SetSR_RVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *IWDG_Type) GetSR_RVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *IWDG_Type) SetSR_WVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *IWDG_Type) GetSR_WVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}

// IWDG.WINR: Window register
func (o *IWDG_Type) SetWINR_WIN(value uint32) {
	volatile.StoreUint32(&o.WINR.Reg, volatile.LoadUint32(&o.WINR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetWINR_WIN() uint32 {
	return volatile.LoadUint32(&o.WINR.Reg) & 0xfff
}

// Low power timer
type LPTIM_Type struct {
	ISR   volatile.Register32 // 0x0
	ICR   volatile.Register32 // 0x4
	IER   volatile.Register32 // 0x8
	CFGR  volatile.Register32 // 0xC
	CR    volatile.Register32 // 0x10
	CMP   volatile.Register32 // 0x14
	ARR   volatile.Register32 // 0x18
	CNT   volatile.Register32 // 0x1C
	_     [4]byte
	CFGR2 volatile.Register32 // 0x24
}

// LPTIM.ISR: Interrupt and Status Register
func (o *LPTIM_Type) SetISR_DOWN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetISR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetISR_UP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetISR_UP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetISR_ARROK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetISR_ARROK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetISR_CMPOK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetISR_CMPOK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetISR_EXTTRIG(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetISR_EXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetISR_ARRM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetISR_ARRM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetISR_CMPM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetISR_CMPM() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LPTIM.ICR: Interrupt Clear Register
func (o *LPTIM_Type) SetICR_DOWNCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetICR_DOWNCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetICR_UPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetICR_UPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetICR_ARROKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetICR_ARROKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetICR_CMPOKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetICR_CMPOKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetICR_EXTTRIGCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetICR_EXTTRIGCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetICR_ARRMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetICR_ARRMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetICR_CMPMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetICR_CMPMCF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LPTIM.IER: Interrupt Enable Register
func (o *LPTIM_Type) SetIER_DOWNIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetIER_DOWNIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetIER_UPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetIER_UPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetIER_ARROKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetIER_ARROKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetIER_CMPOKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetIER_CMPOKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetIER_EXTTRIGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetIER_EXTTRIGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetIER_ARRMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetIER_ARRMIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetIER_CMPMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetIER_CMPMIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LPTIM.CFGR: Configuration Register
func (o *LPTIM_Type) SetCFGR_ENC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPTIM_Type) GetCFGR_ENC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *LPTIM_Type) SetCFGR_COUNTMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *LPTIM_Type) GetCFGR_COUNTMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *LPTIM_Type) SetCFGR_PRELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *LPTIM_Type) GetCFGR_PRELOAD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *LPTIM_Type) SetCFGR_WAVPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *LPTIM_Type) GetCFGR_WAVPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *LPTIM_Type) SetCFGR_WAVE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *LPTIM_Type) GetCFGR_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *LPTIM_Type) SetCFGR_TIMOUT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000)|value<<19)
}
func (o *LPTIM_Type) GetCFGR_TIMOUT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000) >> 19
}
func (o *LPTIM_Type) SetCFGR_TRIGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x60000)|value<<17)
}
func (o *LPTIM_Type) GetCFGR_TRIGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x60000) >> 17
}
func (o *LPTIM_Type) SetCFGR_TRIGSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe000)|value<<13)
}
func (o *LPTIM_Type) GetCFGR_TRIGSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe000) >> 13
}
func (o *LPTIM_Type) SetCFGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe00)|value<<9)
}
func (o *LPTIM_Type) GetCFGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe00) >> 9
}
func (o *LPTIM_Type) SetCFGR_TRGFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc0)|value<<6)
}
func (o *LPTIM_Type) GetCFGR_TRGFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc0) >> 6
}
func (o *LPTIM_Type) SetCFGR_CKFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x18)|value<<3)
}
func (o *LPTIM_Type) GetCFGR_CKFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x18) >> 3
}
func (o *LPTIM_Type) SetCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x6)|value<<1)
}
func (o *LPTIM_Type) GetCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x6) >> 1
}
func (o *LPTIM_Type) SetCFGR_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCFGR_CKSEL() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x1
}

// LPTIM.CR: Control Register
func (o *LPTIM_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *LPTIM_Type) SetCR_SNGSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetCR_SNGSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetCR_CNTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetCR_CNTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetCR_COUNTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetCR_COUNTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetCR_RSTARE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetCR_RSTARE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}

// LPTIM.CMP: Compare Register
func (o *LPTIM_Type) SetCMP(value uint32) {
	volatile.StoreUint32(&o.CMP.Reg, volatile.LoadUint32(&o.CMP.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCMP() uint32 {
	return volatile.LoadUint32(&o.CMP.Reg) & 0xffff
}

// LPTIM.ARR: Autoreload Register
func (o *LPTIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// LPTIM.CNT: Counter Register
func (o *LPTIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// LPTIM.CFGR2: LPTIM configuration register 2
func (o *LPTIM_Type) SetCFGR2_IN1SEL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x3)|value)
}
func (o *LPTIM_Type) GetCFGR2_IN1SEL() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x3
}
func (o *LPTIM_Type) SetCFGR2_IN2SEL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x30)|value<<4)
}
func (o *LPTIM_Type) GetCFGR2_IN2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x30) >> 4
}

// LPUART1
type LPUART_Type struct {
	CR1   volatile.Register32 // 0x0
	CR2   volatile.Register32 // 0x4
	CR3   volatile.Register32 // 0x8
	BRR   volatile.Register32 // 0xC
	GTPR  volatile.Register32 // 0x10
	RTOR  volatile.Register32 // 0x14
	RQR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	ICR   volatile.Register32 // 0x20
	RDR   volatile.Register32 // 0x24
	TDR   volatile.Register32 // 0x28
	PRESC volatile.Register32 // 0x2C
}

// LPUART.CR1: Control register 1
func (o *LPUART_Type) SetCR1_RXFFIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART_Type) GetCR1_RXFFIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000000) >> 31
}
func (o *LPUART_Type) SetCR1_TXFEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART_Type) GetCR1_TXFEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000000) >> 30
}
func (o *LPUART_Type) SetCR1_FIFOEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART_Type) GetCR1_FIFOEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000000) >> 29
}
func (o *LPUART_Type) SetCR1_M1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000000)|value<<28)
}
func (o *LPUART_Type) GetCR1_M1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000000) >> 28
}
func (o *LPUART_Type) SetCR1_DEAT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3e00000)|value<<21)
}
func (o *LPUART_Type) GetCR1_DEAT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3e00000) >> 21
}
func (o *LPUART_Type) SetCR1_DEDT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *LPUART_Type) GetCR1_DEDT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1f0000) >> 16
}
func (o *LPUART_Type) SetCR1_CMIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetCR1_CMIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetCR1_MME(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *LPUART_Type) GetCR1_MME() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *LPUART_Type) SetCR1_M0(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *LPUART_Type) GetCR1_M0() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *LPUART_Type) SetCR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *LPUART_Type) GetCR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *LPUART_Type) SetCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *LPUART_Type) GetCR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *LPUART_Type) SetCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *LPUART_Type) GetCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *LPUART_Type) SetCR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *LPUART_Type) GetCR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *LPUART_Type) SetCR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *LPUART_Type) GetCR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *LPUART_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *LPUART_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *LPUART_Type) SetCR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *LPUART_Type) GetCR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *LPUART_Type) SetCR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetCR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetCR1_TE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetCR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetCR1_RE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetCR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetCR1_UESM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetCR1_UESM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetCR1_UE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetCR1_UE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// LPUART.CR2: Control register 2
func (o *LPUART_Type) SetCR2_ADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff000000)|value<<24)
}
func (o *LPUART_Type) GetCR2_ADD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff000000) >> 24
}
func (o *LPUART_Type) SetCR2_MSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80000)|value<<19)
}
func (o *LPUART_Type) GetCR2_MSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80000) >> 19
}
func (o *LPUART_Type) SetCR2_DATAINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART_Type) GetCR2_DATAINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *LPUART_Type) SetCR2_TXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetCR2_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetCR2_RXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART_Type) GetCR2_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *LPUART_Type) SetCR2_SWAP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetCR2_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *LPUART_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3000)|value<<12)
}
func (o *LPUART_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x3000) >> 12
}
func (o *LPUART_Type) SetCR2_ADDM7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetCR2_ADDM7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}

// LPUART.CR3: Control register 3
func (o *LPUART_Type) SetCR3_TXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000000)|value<<29)
}
func (o *LPUART_Type) GetCR3_TXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000000) >> 29
}
func (o *LPUART_Type) SetCR3_RXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10000000)|value<<28)
}
func (o *LPUART_Type) GetCR3_RXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10000000) >> 28
}
func (o *LPUART_Type) SetCR3_RXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe000000)|value<<25)
}
func (o *LPUART_Type) GetCR3_RXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe000000) >> 25
}
func (o *LPUART_Type) SetCR3_TXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART_Type) GetCR3_TXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800000) >> 23
}
func (o *LPUART_Type) SetCR3_WUFIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART_Type) GetCR3_WUFIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400000) >> 22
}
func (o *LPUART_Type) SetCR3_WUS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x300000)|value<<20)
}
func (o *LPUART_Type) GetCR3_WUS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x300000) >> 20
}
func (o *LPUART_Type) SetCR3_DEP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetCR3_DEP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *LPUART_Type) SetCR3_DEM(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetCR3_DEM() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetCR3_DDRE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *LPUART_Type) GetCR3_DDRE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *LPUART_Type) SetCR3_OVRDIS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000)|value<<12)
}
func (o *LPUART_Type) GetCR3_OVRDIS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000) >> 12
}
func (o *LPUART_Type) SetCR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *LPUART_Type) GetCR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *LPUART_Type) SetCR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *LPUART_Type) GetCR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *LPUART_Type) SetCR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *LPUART_Type) GetCR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *LPUART_Type) SetCR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *LPUART_Type) GetCR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *LPUART_Type) SetCR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x40)|value<<6)
}
func (o *LPUART_Type) GetCR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x40) >> 6
}
func (o *LPUART_Type) SetCR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetCR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetCR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetCR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// LPUART.BRR: Baud rate register
func (o *LPUART_Type) SetBRR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xfffff)|value)
}
func (o *LPUART_Type) GetBRR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xfffff
}

// LPUART.GTPR: Guard time and prescaler register
func (o *LPUART_Type) SetGTPR_GT(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff00)|value<<8)
}
func (o *LPUART_Type) GetGTPR_GT() uint32 {
	return (volatile.LoadUint32(&o.GTPR.Reg) & 0xff00) >> 8
}
func (o *LPUART_Type) SetGTPR_PSC(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff)|value)
}
func (o *LPUART_Type) GetGTPR_PSC() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg) & 0xff
}

// LPUART.RTOR: Receiver timeout register
func (o *LPUART_Type) SetRTOR_BLEN(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xff000000)|value<<24)
}
func (o *LPUART_Type) GetRTOR_BLEN() uint32 {
	return (volatile.LoadUint32(&o.RTOR.Reg) & 0xff000000) >> 24
}
func (o *LPUART_Type) SetRTOR_RTO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffffff)|value)
}
func (o *LPUART_Type) GetRTOR_RTO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffffff
}

// LPUART.RQR: Request register
func (o *LPUART_Type) SetRQR_TXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetRQR_TXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetRQR_RXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetRQR_RXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetRQR_MMRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetRQR_MMRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetRQR_SBKRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetRQR_SBKRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetRQR_ABRRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetRQR_ABRRQ() uint32 {
	return volatile.LoadUint32(&o.RQR.Reg) & 0x1
}

// LPUART.ISR: Interrupt & status register
func (o *LPUART_Type) SetISR_TXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *LPUART_Type) GetISR_TXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *LPUART_Type) SetISR_RXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *LPUART_Type) GetISR_RXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *LPUART_Type) SetISR_RXFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPUART_Type) GetISR_RXFF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *LPUART_Type) SetISR_TXFE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART_Type) GetISR_TXFE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *LPUART_Type) SetISR_REACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART_Type) GetISR_REACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *LPUART_Type) SetISR_TEACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART_Type) GetISR_TEACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *LPUART_Type) SetISR_WUF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART_Type) GetISR_WUF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *LPUART_Type) SetISR_RWU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *LPUART_Type) GetISR_RWU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *LPUART_Type) SetISR_SBKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART_Type) GetISR_SBKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *LPUART_Type) SetISR_CMF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetISR_CMF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *LPUART_Type) SetISR_CTS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *LPUART_Type) GetISR_CTS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *LPUART_Type) SetISR_CTSIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *LPUART_Type) GetISR_CTSIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *LPUART_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *LPUART_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *LPUART_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *LPUART_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *LPUART_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *LPUART_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *LPUART_Type) SetISR_IDLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetISR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetISR_ORE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetISR_ORE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetISR_NE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetISR_NE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetISR_FE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetISR_FE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetISR_PE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetISR_PE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LPUART.ICR: Interrupt flag clear register
func (o *LPUART_Type) SetICR_WUCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART_Type) GetICR_WUCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}
func (o *LPUART_Type) SetICR_CMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetICR_CMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetICR_CTSCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *LPUART_Type) GetICR_CTSCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *LPUART_Type) SetICR_TCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *LPUART_Type) GetICR_TCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *LPUART_Type) SetICR_IDLECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetICR_IDLECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetICR_ORECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetICR_ORECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetICR_NCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetICR_NCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetICR_FECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetICR_FECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetICR_PECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetICR_PECF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LPUART.RDR: Receive data register
func (o *LPUART_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0x1ff)|value)
}
func (o *LPUART_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0x1ff
}

// LPUART.TDR: Transmit data register
func (o *LPUART_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1ff)|value)
}
func (o *LPUART_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0x1ff
}

// LPUART.PRESC: Prescaler register
func (o *LPUART_Type) SetPRESC_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESC.Reg, volatile.LoadUint32(&o.PRESC.Reg)&^(0xf)|value)
}
func (o *LPUART_Type) GetPRESC_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESC.Reg) & 0xf
}

// LCD-TFT Controller
type LTDC_Type struct {
	_     [8]byte
	SSCR  volatile.Register32 // 0x8
	BPCR  volatile.Register32 // 0xC
	AWCR  volatile.Register32 // 0x10
	TWCR  volatile.Register32 // 0x14
	GCR   volatile.Register32 // 0x18
	_     [8]byte
	SRCR  volatile.Register32 // 0x24
	_     [4]byte
	BCCR  volatile.Register32 // 0x2C
	_     [4]byte
	IER   volatile.Register32 // 0x34
	ISR   volatile.Register32 // 0x38
	ICR   volatile.Register32 // 0x3C
	LIPCR volatile.Register32 // 0x40
	CPSR  volatile.Register32 // 0x44
	CDSR  volatile.Register32 // 0x48
	_     [56]byte
	LAYER [2]LTDC_LAYER_Type // 0x84
}

// LTDC.SSCR: Synchronization Size Configuration Register
func (o *LTDC_Type) SetSSCR_HSW(value uint32) {
	volatile.StoreUint32(&o.SSCR.Reg, volatile.LoadUint32(&o.SSCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetSSCR_HSW() uint32 {
	return (volatile.LoadUint32(&o.SSCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetSSCR_VSH(value uint32) {
	volatile.StoreUint32(&o.SSCR.Reg, volatile.LoadUint32(&o.SSCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetSSCR_VSH() uint32 {
	return volatile.LoadUint32(&o.SSCR.Reg) & 0x7ff
}

// LTDC.BPCR: Back Porch Configuration Register
func (o *LTDC_Type) SetBPCR_AHBP(value uint32) {
	volatile.StoreUint32(&o.BPCR.Reg, volatile.LoadUint32(&o.BPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetBPCR_AHBP() uint32 {
	return (volatile.LoadUint32(&o.BPCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetBPCR_AVBP(value uint32) {
	volatile.StoreUint32(&o.BPCR.Reg, volatile.LoadUint32(&o.BPCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetBPCR_AVBP() uint32 {
	return volatile.LoadUint32(&o.BPCR.Reg) & 0x7ff
}

// LTDC.AWCR: Active Width Configuration Register
func (o *LTDC_Type) SetAWCR_AAW(value uint32) {
	volatile.StoreUint32(&o.AWCR.Reg, volatile.LoadUint32(&o.AWCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetAWCR_AAW() uint32 {
	return (volatile.LoadUint32(&o.AWCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetAWCR_AAH(value uint32) {
	volatile.StoreUint32(&o.AWCR.Reg, volatile.LoadUint32(&o.AWCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetAWCR_AAH() uint32 {
	return volatile.LoadUint32(&o.AWCR.Reg) & 0x7ff
}

// LTDC.TWCR: Total Width Configuration Register
func (o *LTDC_Type) SetTWCR_TOTALW(value uint32) {
	volatile.StoreUint32(&o.TWCR.Reg, volatile.LoadUint32(&o.TWCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetTWCR_TOTALW() uint32 {
	return (volatile.LoadUint32(&o.TWCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetTWCR_TOTALH(value uint32) {
	volatile.StoreUint32(&o.TWCR.Reg, volatile.LoadUint32(&o.TWCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetTWCR_TOTALH() uint32 {
	return volatile.LoadUint32(&o.TWCR.Reg) & 0x7ff
}

// LTDC.GCR: Global Control Register
func (o *LTDC_Type) SetGCR_HSPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x80000000)|value<<31)
}
func (o *LTDC_Type) GetGCR_HSPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x80000000) >> 31
}
func (o *LTDC_Type) SetGCR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x40000000)|value<<30)
}
func (o *LTDC_Type) GetGCR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x40000000) >> 30
}
func (o *LTDC_Type) SetGCR_DEPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x20000000)|value<<29)
}
func (o *LTDC_Type) GetGCR_DEPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x20000000) >> 29
}
func (o *LTDC_Type) SetGCR_PCPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x10000000)|value<<28)
}
func (o *LTDC_Type) GetGCR_PCPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x10000000) >> 28
}
func (o *LTDC_Type) SetGCR_DEN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x10000)|value<<16)
}
func (o *LTDC_Type) GetGCR_DEN() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x10000) >> 16
}
func (o *LTDC_Type) SetGCR_DRW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x7000)|value<<12)
}
func (o *LTDC_Type) GetGCR_DRW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x7000) >> 12
}
func (o *LTDC_Type) SetGCR_DGW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x700)|value<<8)
}
func (o *LTDC_Type) GetGCR_DGW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x700) >> 8
}
func (o *LTDC_Type) SetGCR_DBW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x70)|value<<4)
}
func (o *LTDC_Type) GetGCR_DBW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x70) >> 4
}
func (o *LTDC_Type) SetGCR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetGCR_LTDCEN() uint32 {
	return volatile.LoadUint32(&o.GCR.Reg) & 0x1
}

// LTDC.SRCR: Shadow Reload Configuration Register
func (o *LTDC_Type) SetSRCR_VBR(value uint32) {
	volatile.StoreUint32(&o.SRCR.Reg, volatile.LoadUint32(&o.SRCR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetSRCR_VBR() uint32 {
	return (volatile.LoadUint32(&o.SRCR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetSRCR_IMR(value uint32) {
	volatile.StoreUint32(&o.SRCR.Reg, volatile.LoadUint32(&o.SRCR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetSRCR_IMR() uint32 {
	return volatile.LoadUint32(&o.SRCR.Reg) & 0x1
}

// LTDC.BCCR: Background Color Configuration Register
func (o *LTDC_Type) SetBCCR_BCBLUE(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff)|value)
}
func (o *LTDC_Type) GetBCCR_BCBLUE() uint32 {
	return volatile.LoadUint32(&o.BCCR.Reg) & 0xff
}
func (o *LTDC_Type) SetBCCR_BCGREEN(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_Type) GetBCCR_BCGREEN() uint32 {
	return (volatile.LoadUint32(&o.BCCR.Reg) & 0xff00) >> 8
}
func (o *LTDC_Type) SetBCCR_BCRED(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_Type) GetBCCR_BCRED() uint32 {
	return (volatile.LoadUint32(&o.BCCR.Reg) & 0xff0000) >> 16
}

// LTDC.IER: Interrupt Enable Register
func (o *LTDC_Type) SetIER_RRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetIER_RRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetIER_TERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetIER_TERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetIER_FUIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetIER_FUIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetIER_LIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetIER_LIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LTDC.ISR: Interrupt Status Register
func (o *LTDC_Type) SetISR_RRIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetISR_RRIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetISR_TERRIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetISR_TERRIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetISR_FUIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetISR_FUIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetISR_LIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetISR_LIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LTDC.ICR: Interrupt Clear Register
func (o *LTDC_Type) SetICR_CRRIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetICR_CRRIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetICR_CTERRIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetICR_CTERRIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetICR_CFUIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetICR_CFUIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetICR_CLIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetICR_CLIF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LTDC.LIPCR: Line Interrupt Position Configuration Register
func (o *LTDC_Type) SetLIPCR_LIPOS(value uint32) {
	volatile.StoreUint32(&o.LIPCR.Reg, volatile.LoadUint32(&o.LIPCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetLIPCR_LIPOS() uint32 {
	return volatile.LoadUint32(&o.LIPCR.Reg) & 0x7ff
}

// LTDC.CPSR: Current Position Status Register
func (o *LTDC_Type) SetCPSR_CXPOS(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *LTDC_Type) GetCPSR_CXPOS() uint32 {
	return (volatile.LoadUint32(&o.CPSR.Reg) & 0xffff0000) >> 16
}
func (o *LTDC_Type) SetCPSR_CYPOS(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffff)|value)
}
func (o *LTDC_Type) GetCPSR_CYPOS() uint32 {
	return volatile.LoadUint32(&o.CPSR.Reg) & 0xffff
}

// LTDC.CDSR: Current Display Status Register
func (o *LTDC_Type) SetCDSR_HSYNCS(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetCDSR_HSYNCS() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetCDSR_VSYNCS(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetCDSR_VSYNCS() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetCDSR_HDES(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetCDSR_HDES() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetCDSR_VDES(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetCDSR_VDES() uint32 {
	return volatile.LoadUint32(&o.CDSR.Reg) & 0x1
}

type LTDC_LAYER_Type struct {
	CR     volatile.Register32 // 0x84
	WHPCR  volatile.Register32 // 0x88
	WVPCR  volatile.Register32 // 0x8C
	CKCR   volatile.Register32 // 0x90
	PFCR   volatile.Register32 // 0x94
	CACR   volatile.Register32 // 0x98
	DCCR   volatile.Register32 // 0x9C
	BFCR   volatile.Register32 // 0xA0
	_      [8]byte
	CFBAR  volatile.Register32 // 0xAC
	CFBLR  volatile.Register32 // 0xB0
	CFBLNR volatile.Register32 // 0xB4
	_      [12]byte
	CLUTWR volatile.Register32 // 0xC4
	_      [60]byte
}

// LTDC_LAYER.CR: Layerx Control Register
func (o *LTDC_LAYER_Type) SetCR_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *LTDC_LAYER_Type) GetCR_CLUTEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *LTDC_LAYER_Type) SetCR_COLKEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_LAYER_Type) GetCR_COLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LTDC_LAYER_Type) SetCR_LEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LTDC_LAYER_Type) GetCR_LEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// LTDC_LAYER.WHPCR: Layerx Window Horizontal Position Configuration Register
func (o *LTDC_LAYER_Type) SetWHPCR_WHSPPOS(value uint32) {
	volatile.StoreUint32(&o.WHPCR.Reg, volatile.LoadUint32(&o.WHPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetWHPCR_WHSPPOS() uint32 {
	return (volatile.LoadUint32(&o.WHPCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetWHPCR_WHSTPOS(value uint32) {
	volatile.StoreUint32(&o.WHPCR.Reg, volatile.LoadUint32(&o.WHPCR.Reg)&^(0xfff)|value)
}
func (o *LTDC_LAYER_Type) GetWHPCR_WHSTPOS() uint32 {
	return volatile.LoadUint32(&o.WHPCR.Reg) & 0xfff
}

// LTDC_LAYER.WVPCR: Layerx Window Vertical Position Configuration Register
func (o *LTDC_LAYER_Type) SetWVPCR_WVSPPOS(value uint32) {
	volatile.StoreUint32(&o.WVPCR.Reg, volatile.LoadUint32(&o.WVPCR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetWVPCR_WVSPPOS() uint32 {
	return (volatile.LoadUint32(&o.WVPCR.Reg) & 0x7ff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetWVPCR_WVSTPOS(value uint32) {
	volatile.StoreUint32(&o.WVPCR.Reg, volatile.LoadUint32(&o.WVPCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_LAYER_Type) GetWVPCR_WVSTPOS() uint32 {
	return volatile.LoadUint32(&o.WVPCR.Reg) & 0x7ff
}

// LTDC_LAYER.CKCR: Layerx Color Keying Configuration Register
func (o *LTDC_LAYER_Type) SetCKCR_CKRED(value uint32) {
	volatile.StoreUint32(&o.CKCR.Reg, volatile.LoadUint32(&o.CKCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetCKCR_CKRED() uint32 {
	return (volatile.LoadUint32(&o.CKCR.Reg) & 0xff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetCKCR_CKGREEN(value uint32) {
	volatile.StoreUint32(&o.CKCR.Reg, volatile.LoadUint32(&o.CKCR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_LAYER_Type) GetCKCR_CKGREEN() uint32 {
	return (volatile.LoadUint32(&o.CKCR.Reg) & 0xff00) >> 8
}
func (o *LTDC_LAYER_Type) SetCKCR_CKBLUE(value uint32) {
	volatile.StoreUint32(&o.CKCR.Reg, volatile.LoadUint32(&o.CKCR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetCKCR_CKBLUE() uint32 {
	return volatile.LoadUint32(&o.CKCR.Reg) & 0xff
}

// LTDC_LAYER.PFCR: Layerx Pixel Format Configuration Register
func (o *LTDC_LAYER_Type) SetPFCR_PF(value uint32) {
	volatile.StoreUint32(&o.PFCR.Reg, volatile.LoadUint32(&o.PFCR.Reg)&^(0x7)|value)
}
func (o *LTDC_LAYER_Type) GetPFCR_PF() uint32 {
	return volatile.LoadUint32(&o.PFCR.Reg) & 0x7
}

// LTDC_LAYER.CACR: Layerx Constant Alpha Configuration Register
func (o *LTDC_LAYER_Type) SetCACR_CONSTA(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetCACR_CONSTA() uint32 {
	return volatile.LoadUint32(&o.CACR.Reg) & 0xff
}

// LTDC_LAYER.DCCR: Layerx Default Color Configuration Register
func (o *LTDC_LAYER_Type) SetDCCR_DCALPHA(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCALPHA() uint32 {
	return (volatile.LoadUint32(&o.DCCR.Reg) & 0xff000000) >> 24
}
func (o *LTDC_LAYER_Type) SetDCCR_DCRED(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCRED() uint32 {
	return (volatile.LoadUint32(&o.DCCR.Reg) & 0xff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetDCCR_DCGREEN(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCGREEN() uint32 {
	return (volatile.LoadUint32(&o.DCCR.Reg) & 0xff00) >> 8
}
func (o *LTDC_LAYER_Type) SetDCCR_DCBLUE(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCBLUE() uint32 {
	return volatile.LoadUint32(&o.DCCR.Reg) & 0xff
}

// LTDC_LAYER.BFCR: Layerx Blending Factors Configuration Register
func (o *LTDC_LAYER_Type) SetBFCR_BF1(value uint32) {
	volatile.StoreUint32(&o.BFCR.Reg, volatile.LoadUint32(&o.BFCR.Reg)&^(0x700)|value<<8)
}
func (o *LTDC_LAYER_Type) GetBFCR_BF1() uint32 {
	return (volatile.LoadUint32(&o.BFCR.Reg) & 0x700) >> 8
}
func (o *LTDC_LAYER_Type) SetBFCR_BF2(value uint32) {
	volatile.StoreUint32(&o.BFCR.Reg, volatile.LoadUint32(&o.BFCR.Reg)&^(0x7)|value)
}
func (o *LTDC_LAYER_Type) GetBFCR_BF2() uint32 {
	return volatile.LoadUint32(&o.BFCR.Reg) & 0x7
}

// LTDC_LAYER.CFBAR: Layerx Color Frame Buffer Address Register
func (o *LTDC_LAYER_Type) SetCFBAR(value uint32) {
	volatile.StoreUint32(&o.CFBAR.Reg, value)
}
func (o *LTDC_LAYER_Type) GetCFBAR() uint32 {
	return volatile.LoadUint32(&o.CFBAR.Reg)
}

// LTDC_LAYER.CFBLR: Layerx Color Frame Buffer Length Register
func (o *LTDC_LAYER_Type) SetCFBLR_CFBP(value uint32) {
	volatile.StoreUint32(&o.CFBLR.Reg, volatile.LoadUint32(&o.CFBLR.Reg)&^(0x1fff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetCFBLR_CFBP() uint32 {
	return (volatile.LoadUint32(&o.CFBLR.Reg) & 0x1fff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetCFBLR_CFBLL(value uint32) {
	volatile.StoreUint32(&o.CFBLR.Reg, volatile.LoadUint32(&o.CFBLR.Reg)&^(0x1fff)|value)
}
func (o *LTDC_LAYER_Type) GetCFBLR_CFBLL() uint32 {
	return volatile.LoadUint32(&o.CFBLR.Reg) & 0x1fff
}

// LTDC_LAYER.CFBLNR: Layerx ColorFrame Buffer Line Number Register
func (o *LTDC_LAYER_Type) SetCFBLNR_CFBLNBR(value uint32) {
	volatile.StoreUint32(&o.CFBLNR.Reg, volatile.LoadUint32(&o.CFBLNR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_LAYER_Type) GetCFBLNR_CFBLNBR() uint32 {
	return volatile.LoadUint32(&o.CFBLNR.Reg) & 0x7ff
}

// LTDC_LAYER.CLUTWR: Layerx CLUT Write Register
func (o *LTDC_LAYER_Type) SetCLUTWR_CLUTADD(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff000000)|value<<24)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_CLUTADD() uint32 {
	return (volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff000000) >> 24
}
func (o *LTDC_LAYER_Type) SetCLUTWR_RED(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_RED() uint32 {
	return (volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetCLUTWR_GREEN(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff00) >> 8
}
func (o *LTDC_LAYER_Type) SetCLUTWR_BLUE(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_BLUE() uint32 {
	return volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff
}

// Management data input/output slave
type MDIOS_Type struct {
	CR      volatile.Register32 // 0x0
	WRFR    volatile.Register32 // 0x4
	CWRFR   volatile.Register32 // 0x8
	RDFR    volatile.Register32 // 0xC
	CRDFR   volatile.Register32 // 0x10
	SR      volatile.Register32 // 0x14
	CLRFR   volatile.Register32 // 0x18
	DINR0   volatile.Register32 // 0x1C
	DINR1   volatile.Register32 // 0x20
	DINR2   volatile.Register32 // 0x24
	DINR3   volatile.Register32 // 0x28
	DINR4   volatile.Register32 // 0x2C
	DINR5   volatile.Register32 // 0x30
	DINR6   volatile.Register32 // 0x34
	DINR7   volatile.Register32 // 0x38
	DINR8   volatile.Register32 // 0x3C
	DINR9   volatile.Register32 // 0x40
	DINR10  volatile.Register32 // 0x44
	DINR11  volatile.Register32 // 0x48
	DINR12  volatile.Register32 // 0x4C
	DINR13  volatile.Register32 // 0x50
	DINR14  volatile.Register32 // 0x54
	DINR15  volatile.Register32 // 0x58
	DINR16  volatile.Register32 // 0x5C
	DINR17  volatile.Register32 // 0x60
	DINR18  volatile.Register32 // 0x64
	DINR19  volatile.Register32 // 0x68
	DINR20  volatile.Register32 // 0x6C
	DINR21  volatile.Register32 // 0x70
	DINR22  volatile.Register32 // 0x74
	DINR23  volatile.Register32 // 0x78
	DINR24  volatile.Register32 // 0x7C
	DINR25  volatile.Register32 // 0x80
	DINR26  volatile.Register32 // 0x84
	DINR27  volatile.Register32 // 0x88
	DINR28  volatile.Register32 // 0x8C
	DINR29  volatile.Register32 // 0x90
	DINR30  volatile.Register32 // 0x94
	DINR31  volatile.Register32 // 0x98
	DOUTR0  volatile.Register32 // 0x9C
	DOUTR1  volatile.Register32 // 0xA0
	DOUTR2  volatile.Register32 // 0xA4
	DOUTR3  volatile.Register32 // 0xA8
	DOUTR4  volatile.Register32 // 0xAC
	DOUTR5  volatile.Register32 // 0xB0
	DOUTR6  volatile.Register32 // 0xB4
	DOUTR7  volatile.Register32 // 0xB8
	DOUTR8  volatile.Register32 // 0xBC
	DOUTR9  volatile.Register32 // 0xC0
	DOUTR10 volatile.Register32 // 0xC4
	DOUTR11 volatile.Register32 // 0xC8
	DOUTR12 volatile.Register32 // 0xCC
	DOUTR13 volatile.Register32 // 0xD0
	DOUTR14 volatile.Register32 // 0xD4
	DOUTR15 volatile.Register32 // 0xD8
	DOUTR16 volatile.Register32 // 0xDC
	DOUTR17 volatile.Register32 // 0xE0
	DOUTR18 volatile.Register32 // 0xE4
	DOUTR19 volatile.Register32 // 0xE8
	DOUTR20 volatile.Register32 // 0xEC
	DOUTR21 volatile.Register32 // 0xF0
	DOUTR22 volatile.Register32 // 0xF4
	DOUTR23 volatile.Register32 // 0xF8
	DOUTR24 volatile.Register32 // 0xFC
	DOUTR25 volatile.Register32 // 0x100
	DOUTR26 volatile.Register32 // 0x104
	DOUTR27 volatile.Register32 // 0x108
	DOUTR28 volatile.Register32 // 0x10C
	DOUTR29 volatile.Register32 // 0x110
	DOUTR30 volatile.Register32 // 0x114
	DOUTR31 volatile.Register32 // 0x118
}

// MDIOS.CR: MDIOS configuration register
func (o *MDIOS_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *MDIOS_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *MDIOS_Type) SetCR_WRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *MDIOS_Type) GetCR_WRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *MDIOS_Type) SetCR_RDIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *MDIOS_Type) GetCR_RDIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *MDIOS_Type) SetCR_EIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *MDIOS_Type) GetCR_EIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *MDIOS_Type) SetCR_DPC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *MDIOS_Type) GetCR_DPC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *MDIOS_Type) SetCR_PORT_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1f00)|value<<8)
}
func (o *MDIOS_Type) GetCR_PORT_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1f00) >> 8
}

// MDIOS.WRFR: MDIOS write flag register
func (o *MDIOS_Type) SetWRFR(value uint32) {
	volatile.StoreUint32(&o.WRFR.Reg, value)
}
func (o *MDIOS_Type) GetWRFR() uint32 {
	return volatile.LoadUint32(&o.WRFR.Reg)
}

// MDIOS.CWRFR: MDIOS clear write flag register
func (o *MDIOS_Type) SetCWRFR(value uint32) {
	volatile.StoreUint32(&o.CWRFR.Reg, value)
}
func (o *MDIOS_Type) GetCWRFR() uint32 {
	return volatile.LoadUint32(&o.CWRFR.Reg)
}

// MDIOS.RDFR: MDIOS read flag register
func (o *MDIOS_Type) SetRDFR(value uint32) {
	volatile.StoreUint32(&o.RDFR.Reg, value)
}
func (o *MDIOS_Type) GetRDFR() uint32 {
	return volatile.LoadUint32(&o.RDFR.Reg)
}

// MDIOS.CRDFR: MDIOS clear read flag register
func (o *MDIOS_Type) SetCRDFR(value uint32) {
	volatile.StoreUint32(&o.CRDFR.Reg, value)
}
func (o *MDIOS_Type) GetCRDFR() uint32 {
	return volatile.LoadUint32(&o.CRDFR.Reg)
}

// MDIOS.SR: MDIOS status register
func (o *MDIOS_Type) SetSR_PERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *MDIOS_Type) GetSR_PERF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *MDIOS_Type) SetSR_SERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *MDIOS_Type) GetSR_SERF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *MDIOS_Type) SetSR_TERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *MDIOS_Type) GetSR_TERF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}

// MDIOS.CLRFR: MDIOS clear flag register
func (o *MDIOS_Type) SetCLRFR_CPERF(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x1)|value)
}
func (o *MDIOS_Type) GetCLRFR_CPERF() uint32 {
	return volatile.LoadUint32(&o.CLRFR.Reg) & 0x1
}
func (o *MDIOS_Type) SetCLRFR_CSERF(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x2)|value<<1)
}
func (o *MDIOS_Type) GetCLRFR_CSERF() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x2) >> 1
}
func (o *MDIOS_Type) SetCLRFR_CTERF(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x4)|value<<2)
}
func (o *MDIOS_Type) GetCLRFR_CTERF() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x4) >> 2
}

// MDIOS.DINR0: MDIOS input data register 0
func (o *MDIOS_Type) SetDINR0_DIN0(value uint32) {
	volatile.StoreUint32(&o.DINR0.Reg, volatile.LoadUint32(&o.DINR0.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR0_DIN0() uint32 {
	return volatile.LoadUint32(&o.DINR0.Reg) & 0xffff
}

// MDIOS.DINR1: MDIOS input data register 1
func (o *MDIOS_Type) SetDINR1_DIN1(value uint32) {
	volatile.StoreUint32(&o.DINR1.Reg, volatile.LoadUint32(&o.DINR1.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR1_DIN1() uint32 {
	return volatile.LoadUint32(&o.DINR1.Reg) & 0xffff
}

// MDIOS.DINR2: MDIOS input data register 2
func (o *MDIOS_Type) SetDINR2_DIN2(value uint32) {
	volatile.StoreUint32(&o.DINR2.Reg, volatile.LoadUint32(&o.DINR2.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR2_DIN2() uint32 {
	return volatile.LoadUint32(&o.DINR2.Reg) & 0xffff
}

// MDIOS.DINR3: MDIOS input data register 3
func (o *MDIOS_Type) SetDINR3_DIN3(value uint32) {
	volatile.StoreUint32(&o.DINR3.Reg, volatile.LoadUint32(&o.DINR3.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR3_DIN3() uint32 {
	return volatile.LoadUint32(&o.DINR3.Reg) & 0xffff
}

// MDIOS.DINR4: MDIOS input data register 4
func (o *MDIOS_Type) SetDINR4_DIN4(value uint32) {
	volatile.StoreUint32(&o.DINR4.Reg, volatile.LoadUint32(&o.DINR4.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR4_DIN4() uint32 {
	return volatile.LoadUint32(&o.DINR4.Reg) & 0xffff
}

// MDIOS.DINR5: MDIOS input data register 5
func (o *MDIOS_Type) SetDINR5_DIN5(value uint32) {
	volatile.StoreUint32(&o.DINR5.Reg, volatile.LoadUint32(&o.DINR5.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR5_DIN5() uint32 {
	return volatile.LoadUint32(&o.DINR5.Reg) & 0xffff
}

// MDIOS.DINR6: MDIOS input data register 6
func (o *MDIOS_Type) SetDINR6_DIN6(value uint32) {
	volatile.StoreUint32(&o.DINR6.Reg, volatile.LoadUint32(&o.DINR6.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR6_DIN6() uint32 {
	return volatile.LoadUint32(&o.DINR6.Reg) & 0xffff
}

// MDIOS.DINR7: MDIOS input data register 7
func (o *MDIOS_Type) SetDINR7_DIN7(value uint32) {
	volatile.StoreUint32(&o.DINR7.Reg, volatile.LoadUint32(&o.DINR7.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR7_DIN7() uint32 {
	return volatile.LoadUint32(&o.DINR7.Reg) & 0xffff
}

// MDIOS.DINR8: MDIOS input data register 8
func (o *MDIOS_Type) SetDINR8_DIN8(value uint32) {
	volatile.StoreUint32(&o.DINR8.Reg, volatile.LoadUint32(&o.DINR8.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR8_DIN8() uint32 {
	return volatile.LoadUint32(&o.DINR8.Reg) & 0xffff
}

// MDIOS.DINR9: MDIOS input data register 9
func (o *MDIOS_Type) SetDINR9_DIN9(value uint32) {
	volatile.StoreUint32(&o.DINR9.Reg, volatile.LoadUint32(&o.DINR9.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR9_DIN9() uint32 {
	return volatile.LoadUint32(&o.DINR9.Reg) & 0xffff
}

// MDIOS.DINR10: MDIOS input data register 10
func (o *MDIOS_Type) SetDINR10_DIN10(value uint32) {
	volatile.StoreUint32(&o.DINR10.Reg, volatile.LoadUint32(&o.DINR10.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR10_DIN10() uint32 {
	return volatile.LoadUint32(&o.DINR10.Reg) & 0xffff
}

// MDIOS.DINR11: MDIOS input data register 11
func (o *MDIOS_Type) SetDINR11_DIN11(value uint32) {
	volatile.StoreUint32(&o.DINR11.Reg, volatile.LoadUint32(&o.DINR11.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR11_DIN11() uint32 {
	return volatile.LoadUint32(&o.DINR11.Reg) & 0xffff
}

// MDIOS.DINR12: MDIOS input data register 12
func (o *MDIOS_Type) SetDINR12_DIN12(value uint32) {
	volatile.StoreUint32(&o.DINR12.Reg, volatile.LoadUint32(&o.DINR12.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR12_DIN12() uint32 {
	return volatile.LoadUint32(&o.DINR12.Reg) & 0xffff
}

// MDIOS.DINR13: MDIOS input data register 13
func (o *MDIOS_Type) SetDINR13_DIN13(value uint32) {
	volatile.StoreUint32(&o.DINR13.Reg, volatile.LoadUint32(&o.DINR13.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR13_DIN13() uint32 {
	return volatile.LoadUint32(&o.DINR13.Reg) & 0xffff
}

// MDIOS.DINR14: MDIOS input data register 14
func (o *MDIOS_Type) SetDINR14_DIN14(value uint32) {
	volatile.StoreUint32(&o.DINR14.Reg, volatile.LoadUint32(&o.DINR14.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR14_DIN14() uint32 {
	return volatile.LoadUint32(&o.DINR14.Reg) & 0xffff
}

// MDIOS.DINR15: MDIOS input data register 15
func (o *MDIOS_Type) SetDINR15_DIN15(value uint32) {
	volatile.StoreUint32(&o.DINR15.Reg, volatile.LoadUint32(&o.DINR15.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR15_DIN15() uint32 {
	return volatile.LoadUint32(&o.DINR15.Reg) & 0xffff
}

// MDIOS.DINR16: MDIOS input data register 16
func (o *MDIOS_Type) SetDINR16_DIN16(value uint32) {
	volatile.StoreUint32(&o.DINR16.Reg, volatile.LoadUint32(&o.DINR16.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR16_DIN16() uint32 {
	return volatile.LoadUint32(&o.DINR16.Reg) & 0xffff
}

// MDIOS.DINR17: MDIOS input data register 17
func (o *MDIOS_Type) SetDINR17_DIN17(value uint32) {
	volatile.StoreUint32(&o.DINR17.Reg, volatile.LoadUint32(&o.DINR17.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR17_DIN17() uint32 {
	return volatile.LoadUint32(&o.DINR17.Reg) & 0xffff
}

// MDIOS.DINR18: MDIOS input data register 18
func (o *MDIOS_Type) SetDINR18_DIN18(value uint32) {
	volatile.StoreUint32(&o.DINR18.Reg, volatile.LoadUint32(&o.DINR18.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR18_DIN18() uint32 {
	return volatile.LoadUint32(&o.DINR18.Reg) & 0xffff
}

// MDIOS.DINR19: MDIOS input data register 19
func (o *MDIOS_Type) SetDINR19_DIN19(value uint32) {
	volatile.StoreUint32(&o.DINR19.Reg, volatile.LoadUint32(&o.DINR19.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR19_DIN19() uint32 {
	return volatile.LoadUint32(&o.DINR19.Reg) & 0xffff
}

// MDIOS.DINR20: MDIOS input data register 20
func (o *MDIOS_Type) SetDINR20_DIN20(value uint32) {
	volatile.StoreUint32(&o.DINR20.Reg, volatile.LoadUint32(&o.DINR20.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR20_DIN20() uint32 {
	return volatile.LoadUint32(&o.DINR20.Reg) & 0xffff
}

// MDIOS.DINR21: MDIOS input data register 21
func (o *MDIOS_Type) SetDINR21_DIN21(value uint32) {
	volatile.StoreUint32(&o.DINR21.Reg, volatile.LoadUint32(&o.DINR21.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR21_DIN21() uint32 {
	return volatile.LoadUint32(&o.DINR21.Reg) & 0xffff
}

// MDIOS.DINR22: MDIOS input data register 22
func (o *MDIOS_Type) SetDINR22_DIN22(value uint32) {
	volatile.StoreUint32(&o.DINR22.Reg, volatile.LoadUint32(&o.DINR22.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR22_DIN22() uint32 {
	return volatile.LoadUint32(&o.DINR22.Reg) & 0xffff
}

// MDIOS.DINR23: MDIOS input data register 23
func (o *MDIOS_Type) SetDINR23_DIN23(value uint32) {
	volatile.StoreUint32(&o.DINR23.Reg, volatile.LoadUint32(&o.DINR23.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR23_DIN23() uint32 {
	return volatile.LoadUint32(&o.DINR23.Reg) & 0xffff
}

// MDIOS.DINR24: MDIOS input data register 24
func (o *MDIOS_Type) SetDINR24_DIN24(value uint32) {
	volatile.StoreUint32(&o.DINR24.Reg, volatile.LoadUint32(&o.DINR24.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR24_DIN24() uint32 {
	return volatile.LoadUint32(&o.DINR24.Reg) & 0xffff
}

// MDIOS.DINR25: MDIOS input data register 25
func (o *MDIOS_Type) SetDINR25_DIN25(value uint32) {
	volatile.StoreUint32(&o.DINR25.Reg, volatile.LoadUint32(&o.DINR25.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR25_DIN25() uint32 {
	return volatile.LoadUint32(&o.DINR25.Reg) & 0xffff
}

// MDIOS.DINR26: MDIOS input data register 26
func (o *MDIOS_Type) SetDINR26_DIN26(value uint32) {
	volatile.StoreUint32(&o.DINR26.Reg, volatile.LoadUint32(&o.DINR26.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR26_DIN26() uint32 {
	return volatile.LoadUint32(&o.DINR26.Reg) & 0xffff
}

// MDIOS.DINR27: MDIOS input data register 27
func (o *MDIOS_Type) SetDINR27_DIN27(value uint32) {
	volatile.StoreUint32(&o.DINR27.Reg, volatile.LoadUint32(&o.DINR27.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR27_DIN27() uint32 {
	return volatile.LoadUint32(&o.DINR27.Reg) & 0xffff
}

// MDIOS.DINR28: MDIOS input data register 28
func (o *MDIOS_Type) SetDINR28_DIN28(value uint32) {
	volatile.StoreUint32(&o.DINR28.Reg, volatile.LoadUint32(&o.DINR28.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR28_DIN28() uint32 {
	return volatile.LoadUint32(&o.DINR28.Reg) & 0xffff
}

// MDIOS.DINR29: MDIOS input data register 29
func (o *MDIOS_Type) SetDINR29_DIN29(value uint32) {
	volatile.StoreUint32(&o.DINR29.Reg, volatile.LoadUint32(&o.DINR29.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR29_DIN29() uint32 {
	return volatile.LoadUint32(&o.DINR29.Reg) & 0xffff
}

// MDIOS.DINR30: MDIOS input data register 30
func (o *MDIOS_Type) SetDINR30_DIN30(value uint32) {
	volatile.StoreUint32(&o.DINR30.Reg, volatile.LoadUint32(&o.DINR30.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR30_DIN30() uint32 {
	return volatile.LoadUint32(&o.DINR30.Reg) & 0xffff
}

// MDIOS.DINR31: MDIOS input data register 31
func (o *MDIOS_Type) SetDINR31_DIN31(value uint32) {
	volatile.StoreUint32(&o.DINR31.Reg, volatile.LoadUint32(&o.DINR31.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR31_DIN31() uint32 {
	return volatile.LoadUint32(&o.DINR31.Reg) & 0xffff
}

// MDIOS.DOUTR0: MDIOS output data register 0
func (o *MDIOS_Type) SetDOUTR0_DOUT0(value uint32) {
	volatile.StoreUint32(&o.DOUTR0.Reg, volatile.LoadUint32(&o.DOUTR0.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR0_DOUT0() uint32 {
	return volatile.LoadUint32(&o.DOUTR0.Reg) & 0xffff
}

// MDIOS.DOUTR1: MDIOS output data register 1
func (o *MDIOS_Type) SetDOUTR1_DOUT1(value uint32) {
	volatile.StoreUint32(&o.DOUTR1.Reg, volatile.LoadUint32(&o.DOUTR1.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR1_DOUT1() uint32 {
	return volatile.LoadUint32(&o.DOUTR1.Reg) & 0xffff
}

// MDIOS.DOUTR2: MDIOS output data register 2
func (o *MDIOS_Type) SetDOUTR2_DOUT2(value uint32) {
	volatile.StoreUint32(&o.DOUTR2.Reg, volatile.LoadUint32(&o.DOUTR2.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR2_DOUT2() uint32 {
	return volatile.LoadUint32(&o.DOUTR2.Reg) & 0xffff
}

// MDIOS.DOUTR3: MDIOS output data register 3
func (o *MDIOS_Type) SetDOUTR3_DOUT3(value uint32) {
	volatile.StoreUint32(&o.DOUTR3.Reg, volatile.LoadUint32(&o.DOUTR3.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR3_DOUT3() uint32 {
	return volatile.LoadUint32(&o.DOUTR3.Reg) & 0xffff
}

// MDIOS.DOUTR4: MDIOS output data register 4
func (o *MDIOS_Type) SetDOUTR4_DOUT4(value uint32) {
	volatile.StoreUint32(&o.DOUTR4.Reg, volatile.LoadUint32(&o.DOUTR4.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR4_DOUT4() uint32 {
	return volatile.LoadUint32(&o.DOUTR4.Reg) & 0xffff
}

// MDIOS.DOUTR5: MDIOS output data register 5
func (o *MDIOS_Type) SetDOUTR5_DOUT5(value uint32) {
	volatile.StoreUint32(&o.DOUTR5.Reg, volatile.LoadUint32(&o.DOUTR5.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR5_DOUT5() uint32 {
	return volatile.LoadUint32(&o.DOUTR5.Reg) & 0xffff
}

// MDIOS.DOUTR6: MDIOS output data register 6
func (o *MDIOS_Type) SetDOUTR6_DOUT6(value uint32) {
	volatile.StoreUint32(&o.DOUTR6.Reg, volatile.LoadUint32(&o.DOUTR6.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR6_DOUT6() uint32 {
	return volatile.LoadUint32(&o.DOUTR6.Reg) & 0xffff
}

// MDIOS.DOUTR7: MDIOS output data register 7
func (o *MDIOS_Type) SetDOUTR7_DOUT7(value uint32) {
	volatile.StoreUint32(&o.DOUTR7.Reg, volatile.LoadUint32(&o.DOUTR7.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR7_DOUT7() uint32 {
	return volatile.LoadUint32(&o.DOUTR7.Reg) & 0xffff
}

// MDIOS.DOUTR8: MDIOS output data register 8
func (o *MDIOS_Type) SetDOUTR8_DOUT8(value uint32) {
	volatile.StoreUint32(&o.DOUTR8.Reg, volatile.LoadUint32(&o.DOUTR8.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR8_DOUT8() uint32 {
	return volatile.LoadUint32(&o.DOUTR8.Reg) & 0xffff
}

// MDIOS.DOUTR9: MDIOS output data register 9
func (o *MDIOS_Type) SetDOUTR9_DOUT9(value uint32) {
	volatile.StoreUint32(&o.DOUTR9.Reg, volatile.LoadUint32(&o.DOUTR9.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR9_DOUT9() uint32 {
	return volatile.LoadUint32(&o.DOUTR9.Reg) & 0xffff
}

// MDIOS.DOUTR10: MDIOS output data register 10
func (o *MDIOS_Type) SetDOUTR10_DOUT10(value uint32) {
	volatile.StoreUint32(&o.DOUTR10.Reg, volatile.LoadUint32(&o.DOUTR10.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR10_DOUT10() uint32 {
	return volatile.LoadUint32(&o.DOUTR10.Reg) & 0xffff
}

// MDIOS.DOUTR11: MDIOS output data register 11
func (o *MDIOS_Type) SetDOUTR11_DOUT11(value uint32) {
	volatile.StoreUint32(&o.DOUTR11.Reg, volatile.LoadUint32(&o.DOUTR11.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR11_DOUT11() uint32 {
	return volatile.LoadUint32(&o.DOUTR11.Reg) & 0xffff
}

// MDIOS.DOUTR12: MDIOS output data register 12
func (o *MDIOS_Type) SetDOUTR12_DOUT12(value uint32) {
	volatile.StoreUint32(&o.DOUTR12.Reg, volatile.LoadUint32(&o.DOUTR12.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR12_DOUT12() uint32 {
	return volatile.LoadUint32(&o.DOUTR12.Reg) & 0xffff
}

// MDIOS.DOUTR13: MDIOS output data register 13
func (o *MDIOS_Type) SetDOUTR13_DOUT13(value uint32) {
	volatile.StoreUint32(&o.DOUTR13.Reg, volatile.LoadUint32(&o.DOUTR13.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR13_DOUT13() uint32 {
	return volatile.LoadUint32(&o.DOUTR13.Reg) & 0xffff
}

// MDIOS.DOUTR14: MDIOS output data register 14
func (o *MDIOS_Type) SetDOUTR14_DOUT14(value uint32) {
	volatile.StoreUint32(&o.DOUTR14.Reg, volatile.LoadUint32(&o.DOUTR14.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR14_DOUT14() uint32 {
	return volatile.LoadUint32(&o.DOUTR14.Reg) & 0xffff
}

// MDIOS.DOUTR15: MDIOS output data register 15
func (o *MDIOS_Type) SetDOUTR15_DOUT15(value uint32) {
	volatile.StoreUint32(&o.DOUTR15.Reg, volatile.LoadUint32(&o.DOUTR15.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR15_DOUT15() uint32 {
	return volatile.LoadUint32(&o.DOUTR15.Reg) & 0xffff
}

// MDIOS.DOUTR16: MDIOS output data register 16
func (o *MDIOS_Type) SetDOUTR16_DOUT16(value uint32) {
	volatile.StoreUint32(&o.DOUTR16.Reg, volatile.LoadUint32(&o.DOUTR16.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR16_DOUT16() uint32 {
	return volatile.LoadUint32(&o.DOUTR16.Reg) & 0xffff
}

// MDIOS.DOUTR17: MDIOS output data register 17
func (o *MDIOS_Type) SetDOUTR17_DOUT17(value uint32) {
	volatile.StoreUint32(&o.DOUTR17.Reg, volatile.LoadUint32(&o.DOUTR17.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR17_DOUT17() uint32 {
	return volatile.LoadUint32(&o.DOUTR17.Reg) & 0xffff
}

// MDIOS.DOUTR18: MDIOS output data register 18
func (o *MDIOS_Type) SetDOUTR18_DOUT18(value uint32) {
	volatile.StoreUint32(&o.DOUTR18.Reg, volatile.LoadUint32(&o.DOUTR18.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR18_DOUT18() uint32 {
	return volatile.LoadUint32(&o.DOUTR18.Reg) & 0xffff
}

// MDIOS.DOUTR19: MDIOS output data register 19
func (o *MDIOS_Type) SetDOUTR19_DOUT19(value uint32) {
	volatile.StoreUint32(&o.DOUTR19.Reg, volatile.LoadUint32(&o.DOUTR19.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR19_DOUT19() uint32 {
	return volatile.LoadUint32(&o.DOUTR19.Reg) & 0xffff
}

// MDIOS.DOUTR20: MDIOS output data register 20
func (o *MDIOS_Type) SetDOUTR20_DOUT20(value uint32) {
	volatile.StoreUint32(&o.DOUTR20.Reg, volatile.LoadUint32(&o.DOUTR20.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR20_DOUT20() uint32 {
	return volatile.LoadUint32(&o.DOUTR20.Reg) & 0xffff
}

// MDIOS.DOUTR21: MDIOS output data register 21
func (o *MDIOS_Type) SetDOUTR21_DOUT21(value uint32) {
	volatile.StoreUint32(&o.DOUTR21.Reg, volatile.LoadUint32(&o.DOUTR21.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR21_DOUT21() uint32 {
	return volatile.LoadUint32(&o.DOUTR21.Reg) & 0xffff
}

// MDIOS.DOUTR22: MDIOS output data register 22
func (o *MDIOS_Type) SetDOUTR22_DOUT22(value uint32) {
	volatile.StoreUint32(&o.DOUTR22.Reg, volatile.LoadUint32(&o.DOUTR22.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR22_DOUT22() uint32 {
	return volatile.LoadUint32(&o.DOUTR22.Reg) & 0xffff
}

// MDIOS.DOUTR23: MDIOS output data register 23
func (o *MDIOS_Type) SetDOUTR23_DOUT23(value uint32) {
	volatile.StoreUint32(&o.DOUTR23.Reg, volatile.LoadUint32(&o.DOUTR23.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR23_DOUT23() uint32 {
	return volatile.LoadUint32(&o.DOUTR23.Reg) & 0xffff
}

// MDIOS.DOUTR24: MDIOS output data register 24
func (o *MDIOS_Type) SetDOUTR24_DOUT24(value uint32) {
	volatile.StoreUint32(&o.DOUTR24.Reg, volatile.LoadUint32(&o.DOUTR24.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR24_DOUT24() uint32 {
	return volatile.LoadUint32(&o.DOUTR24.Reg) & 0xffff
}

// MDIOS.DOUTR25: MDIOS output data register 25
func (o *MDIOS_Type) SetDOUTR25_DOUT25(value uint32) {
	volatile.StoreUint32(&o.DOUTR25.Reg, volatile.LoadUint32(&o.DOUTR25.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR25_DOUT25() uint32 {
	return volatile.LoadUint32(&o.DOUTR25.Reg) & 0xffff
}

// MDIOS.DOUTR26: MDIOS output data register 26
func (o *MDIOS_Type) SetDOUTR26_DOUT26(value uint32) {
	volatile.StoreUint32(&o.DOUTR26.Reg, volatile.LoadUint32(&o.DOUTR26.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR26_DOUT26() uint32 {
	return volatile.LoadUint32(&o.DOUTR26.Reg) & 0xffff
}

// MDIOS.DOUTR27: MDIOS output data register 27
func (o *MDIOS_Type) SetDOUTR27_DOUT27(value uint32) {
	volatile.StoreUint32(&o.DOUTR27.Reg, volatile.LoadUint32(&o.DOUTR27.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR27_DOUT27() uint32 {
	return volatile.LoadUint32(&o.DOUTR27.Reg) & 0xffff
}

// MDIOS.DOUTR28: MDIOS output data register 28
func (o *MDIOS_Type) SetDOUTR28_DOUT28(value uint32) {
	volatile.StoreUint32(&o.DOUTR28.Reg, volatile.LoadUint32(&o.DOUTR28.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR28_DOUT28() uint32 {
	return volatile.LoadUint32(&o.DOUTR28.Reg) & 0xffff
}

// MDIOS.DOUTR29: MDIOS output data register 29
func (o *MDIOS_Type) SetDOUTR29_DOUT29(value uint32) {
	volatile.StoreUint32(&o.DOUTR29.Reg, volatile.LoadUint32(&o.DOUTR29.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR29_DOUT29() uint32 {
	return volatile.LoadUint32(&o.DOUTR29.Reg) & 0xffff
}

// MDIOS.DOUTR30: MDIOS output data register 30
func (o *MDIOS_Type) SetDOUTR30_DOUT30(value uint32) {
	volatile.StoreUint32(&o.DOUTR30.Reg, volatile.LoadUint32(&o.DOUTR30.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR30_DOUT30() uint32 {
	return volatile.LoadUint32(&o.DOUTR30.Reg) & 0xffff
}

// MDIOS.DOUTR31: MDIOS output data register 31
func (o *MDIOS_Type) SetDOUTR31_DOUT31(value uint32) {
	volatile.StoreUint32(&o.DOUTR31.Reg, volatile.LoadUint32(&o.DOUTR31.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR31_DOUT31() uint32 {
	return volatile.LoadUint32(&o.DOUTR31.Reg) & 0xffff
}

// MDMA
type MDMA_Type struct {
	GISR0 volatile.Register32 // 0x0
	_     [60]byte
	CH    [16]MDMA_CH_Type // 0x40
}

// MDMA.GISR0: MDMA Global Interrupt/Status Register
func (o *MDMA_Type) SetGISR0_GIF0(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x1)|value)
}
func (o *MDMA_Type) GetGISR0_GIF0() uint32 {
	return volatile.LoadUint32(&o.GISR0.Reg) & 0x1
}
func (o *MDMA_Type) SetGISR0_GIF1(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x2)|value<<1)
}
func (o *MDMA_Type) GetGISR0_GIF1() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x2) >> 1
}
func (o *MDMA_Type) SetGISR0_GIF2(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x4)|value<<2)
}
func (o *MDMA_Type) GetGISR0_GIF2() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x4) >> 2
}
func (o *MDMA_Type) SetGISR0_GIF3(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x8)|value<<3)
}
func (o *MDMA_Type) GetGISR0_GIF3() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x8) >> 3
}
func (o *MDMA_Type) SetGISR0_GIF4(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x10)|value<<4)
}
func (o *MDMA_Type) GetGISR0_GIF4() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x10) >> 4
}
func (o *MDMA_Type) SetGISR0_GIF5(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x20)|value<<5)
}
func (o *MDMA_Type) GetGISR0_GIF5() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x20) >> 5
}
func (o *MDMA_Type) SetGISR0_GIF6(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x40)|value<<6)
}
func (o *MDMA_Type) GetGISR0_GIF6() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x40) >> 6
}
func (o *MDMA_Type) SetGISR0_GIF7(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x80)|value<<7)
}
func (o *MDMA_Type) GetGISR0_GIF7() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x80) >> 7
}
func (o *MDMA_Type) SetGISR0_GIF8(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x100)|value<<8)
}
func (o *MDMA_Type) GetGISR0_GIF8() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x100) >> 8
}
func (o *MDMA_Type) SetGISR0_GIF9(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x200)|value<<9)
}
func (o *MDMA_Type) GetGISR0_GIF9() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x200) >> 9
}
func (o *MDMA_Type) SetGISR0_GIF10(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x400)|value<<10)
}
func (o *MDMA_Type) GetGISR0_GIF10() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x400) >> 10
}
func (o *MDMA_Type) SetGISR0_GIF11(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x800)|value<<11)
}
func (o *MDMA_Type) GetGISR0_GIF11() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x800) >> 11
}
func (o *MDMA_Type) SetGISR0_GIF12(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x1000)|value<<12)
}
func (o *MDMA_Type) GetGISR0_GIF12() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x1000) >> 12
}
func (o *MDMA_Type) SetGISR0_GIF13(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x2000)|value<<13)
}
func (o *MDMA_Type) GetGISR0_GIF13() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x2000) >> 13
}
func (o *MDMA_Type) SetGISR0_GIF14(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x4000)|value<<14)
}
func (o *MDMA_Type) GetGISR0_GIF14() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x4000) >> 14
}
func (o *MDMA_Type) SetGISR0_GIF15(value uint32) {
	volatile.StoreUint32(&o.GISR0.Reg, volatile.LoadUint32(&o.GISR0.Reg)&^(0x8000)|value<<15)
}
func (o *MDMA_Type) GetGISR0_GIF15() uint32 {
	return (volatile.LoadUint32(&o.GISR0.Reg) & 0x8000) >> 15
}

type MDMA_CH_Type struct {
	ISR   volatile.Register32 // 0x40
	IFCR  volatile.Register32 // 0x44
	ESR   volatile.Register32 // 0x48
	CR    volatile.Register32 // 0x4C
	TCR   volatile.Register32 // 0x50
	BNDTR volatile.Register32 // 0x54
	SAR   volatile.Register32 // 0x58
	DAR   volatile.Register32 // 0x5C
	BRUR  volatile.Register32 // 0x60
	LAR   volatile.Register32 // 0x64
	TBR   volatile.Register32 // 0x68
	_     [4]byte
	MAR   volatile.Register32 // 0x70
	MDR   volatile.Register32 // 0x74
	_     [8]byte
}

// MDMA_CH.ISR: MDMA channel x interrupt/status register
func (o *MDMA_CH_Type) SetISR_TEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *MDMA_CH_Type) GetISR_TEIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *MDMA_CH_Type) SetISR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *MDMA_CH_Type) GetISR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *MDMA_CH_Type) SetISR_BRTIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *MDMA_CH_Type) GetISR_BRTIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *MDMA_CH_Type) SetISR_BTIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *MDMA_CH_Type) GetISR_BTIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *MDMA_CH_Type) SetISR_TCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *MDMA_CH_Type) GetISR_TCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *MDMA_CH_Type) SetISR_CRQA(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *MDMA_CH_Type) GetISR_CRQA() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}

// MDMA_CH.IFCR: MDMA channel x interrupt flag clear register
func (o *MDMA_CH_Type) SetIFCR_CTEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *MDMA_CH_Type) GetIFCR_CTEIF() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}
func (o *MDMA_CH_Type) SetIFCR_CCTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *MDMA_CH_Type) GetIFCR_CCTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *MDMA_CH_Type) SetIFCR_CBRTIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *MDMA_CH_Type) GetIFCR_CBRTIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *MDMA_CH_Type) SetIFCR_CBTIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *MDMA_CH_Type) GetIFCR_CBTIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *MDMA_CH_Type) SetIFCR_CLTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *MDMA_CH_Type) GetIFCR_CLTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}

// MDMA_CH.ESR: MDMA Channel x error status register
func (o *MDMA_CH_Type) SetESR_TEA(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x7f)|value)
}
func (o *MDMA_CH_Type) GetESR_TEA() uint32 {
	return volatile.LoadUint32(&o.ESR.Reg) & 0x7f
}
func (o *MDMA_CH_Type) SetESR_TED(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80)|value<<7)
}
func (o *MDMA_CH_Type) GetESR_TED() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80) >> 7
}
func (o *MDMA_CH_Type) SetESR_TELD(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100)|value<<8)
}
func (o *MDMA_CH_Type) GetESR_TELD() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100) >> 8
}
func (o *MDMA_CH_Type) SetESR_TEMD(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200)|value<<9)
}
func (o *MDMA_CH_Type) GetESR_TEMD() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200) >> 9
}
func (o *MDMA_CH_Type) SetESR_ASE(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400)|value<<10)
}
func (o *MDMA_CH_Type) GetESR_ASE() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400) >> 10
}
func (o *MDMA_CH_Type) SetESR_BSE(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800)|value<<11)
}
func (o *MDMA_CH_Type) GetESR_BSE() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800) >> 11
}

// MDMA_CH.CR: This register is used to control the concerned channel.
func (o *MDMA_CH_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *MDMA_CH_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *MDMA_CH_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *MDMA_CH_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *MDMA_CH_Type) SetCR_CTCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *MDMA_CH_Type) GetCR_CTCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *MDMA_CH_Type) SetCR_BRTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *MDMA_CH_Type) GetCR_BRTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *MDMA_CH_Type) SetCR_BTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *MDMA_CH_Type) GetCR_BTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *MDMA_CH_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *MDMA_CH_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *MDMA_CH_Type) SetCR_PL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *MDMA_CH_Type) GetCR_PL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *MDMA_CH_Type) SetCR_BEX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *MDMA_CH_Type) GetCR_BEX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *MDMA_CH_Type) SetCR_HEX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *MDMA_CH_Type) GetCR_HEX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *MDMA_CH_Type) SetCR_WEX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *MDMA_CH_Type) GetCR_WEX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *MDMA_CH_Type) SetCR_SWRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *MDMA_CH_Type) GetCR_SWRQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}

// MDMA_CH.TCR: This register is used to configure the concerned channel.
func (o *MDMA_CH_Type) SetTCR_SINC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x3)|value)
}
func (o *MDMA_CH_Type) GetTCR_SINC() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x3
}
func (o *MDMA_CH_Type) SetTCR_DINC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xc)|value<<2)
}
func (o *MDMA_CH_Type) GetTCR_DINC() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xc) >> 2
}
func (o *MDMA_CH_Type) SetTCR_SSIZE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x30)|value<<4)
}
func (o *MDMA_CH_Type) GetTCR_SSIZE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x30) >> 4
}
func (o *MDMA_CH_Type) SetTCR_DSIZE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xc0)|value<<6)
}
func (o *MDMA_CH_Type) GetTCR_DSIZE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xc0) >> 6
}
func (o *MDMA_CH_Type) SetTCR_SINCOS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x300)|value<<8)
}
func (o *MDMA_CH_Type) GetTCR_SINCOS() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x300) >> 8
}
func (o *MDMA_CH_Type) SetTCR_DINCOS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xc00)|value<<10)
}
func (o *MDMA_CH_Type) GetTCR_DINCOS() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xc00) >> 10
}
func (o *MDMA_CH_Type) SetTCR_SBURST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x7000)|value<<12)
}
func (o *MDMA_CH_Type) GetTCR_SBURST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x7000) >> 12
}
func (o *MDMA_CH_Type) SetTCR_DBURST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x38000)|value<<15)
}
func (o *MDMA_CH_Type) GetTCR_DBURST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x38000) >> 15
}
func (o *MDMA_CH_Type) SetTCR_TLEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1fc0000)|value<<18)
}
func (o *MDMA_CH_Type) GetTCR_TLEN() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x1fc0000) >> 18
}
func (o *MDMA_CH_Type) SetTCR_PKE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2000000)|value<<25)
}
func (o *MDMA_CH_Type) GetTCR_PKE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2000000) >> 25
}
func (o *MDMA_CH_Type) SetTCR_PAM(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xc000000)|value<<26)
}
func (o *MDMA_CH_Type) GetTCR_PAM() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xc000000) >> 26
}
func (o *MDMA_CH_Type) SetTCR_TRGM(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x30000000)|value<<28)
}
func (o *MDMA_CH_Type) GetTCR_TRGM() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x30000000) >> 28
}
func (o *MDMA_CH_Type) SetTCR_SWRM(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x40000000)|value<<30)
}
func (o *MDMA_CH_Type) GetTCR_SWRM() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x40000000) >> 30
}
func (o *MDMA_CH_Type) SetTCR_BWM(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x80000000)|value<<31)
}
func (o *MDMA_CH_Type) GetTCR_BWM() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x80000000) >> 31
}

// MDMA_CH.BNDTR: MDMA Channel x block number of data register
func (o *MDMA_CH_Type) SetBNDTR_BNDT(value uint32) {
	volatile.StoreUint32(&o.BNDTR.Reg, volatile.LoadUint32(&o.BNDTR.Reg)&^(0x1ffff)|value)
}
func (o *MDMA_CH_Type) GetBNDTR_BNDT() uint32 {
	return volatile.LoadUint32(&o.BNDTR.Reg) & 0x1ffff
}
func (o *MDMA_CH_Type) SetBNDTR_BRSUM(value uint32) {
	volatile.StoreUint32(&o.BNDTR.Reg, volatile.LoadUint32(&o.BNDTR.Reg)&^(0x40000)|value<<18)
}
func (o *MDMA_CH_Type) GetBNDTR_BRSUM() uint32 {
	return (volatile.LoadUint32(&o.BNDTR.Reg) & 0x40000) >> 18
}
func (o *MDMA_CH_Type) SetBNDTR_BRDUM(value uint32) {
	volatile.StoreUint32(&o.BNDTR.Reg, volatile.LoadUint32(&o.BNDTR.Reg)&^(0x80000)|value<<19)
}
func (o *MDMA_CH_Type) GetBNDTR_BRDUM() uint32 {
	return (volatile.LoadUint32(&o.BNDTR.Reg) & 0x80000) >> 19
}
func (o *MDMA_CH_Type) SetBNDTR_BRC(value uint32) {
	volatile.StoreUint32(&o.BNDTR.Reg, volatile.LoadUint32(&o.BNDTR.Reg)&^(0xfff00000)|value<<20)
}
func (o *MDMA_CH_Type) GetBNDTR_BRC() uint32 {
	return (volatile.LoadUint32(&o.BNDTR.Reg) & 0xfff00000) >> 20
}

// MDMA_CH.SAR: MDMA channel x source address register
func (o *MDMA_CH_Type) SetSAR(value uint32) {
	volatile.StoreUint32(&o.SAR.Reg, value)
}
func (o *MDMA_CH_Type) GetSAR() uint32 {
	return volatile.LoadUint32(&o.SAR.Reg)
}

// MDMA_CH.DAR: MDMA channel x destination address register
func (o *MDMA_CH_Type) SetDAR(value uint32) {
	volatile.StoreUint32(&o.DAR.Reg, value)
}
func (o *MDMA_CH_Type) GetDAR() uint32 {
	return volatile.LoadUint32(&o.DAR.Reg)
}

// MDMA_CH.BRUR: MDMA channel x Block Repeat address Update register
func (o *MDMA_CH_Type) SetBRUR_SUV(value uint32) {
	volatile.StoreUint32(&o.BRUR.Reg, volatile.LoadUint32(&o.BRUR.Reg)&^(0xffff)|value)
}
func (o *MDMA_CH_Type) GetBRUR_SUV() uint32 {
	return volatile.LoadUint32(&o.BRUR.Reg) & 0xffff
}
func (o *MDMA_CH_Type) SetBRUR_DUV(value uint32) {
	volatile.StoreUint32(&o.BRUR.Reg, volatile.LoadUint32(&o.BRUR.Reg)&^(0xffff0000)|value<<16)
}
func (o *MDMA_CH_Type) GetBRUR_DUV() uint32 {
	return (volatile.LoadUint32(&o.BRUR.Reg) & 0xffff0000) >> 16
}

// MDMA_CH.LAR: MDMA channel x Link Address register
func (o *MDMA_CH_Type) SetLAR(value uint32) {
	volatile.StoreUint32(&o.LAR.Reg, value)
}
func (o *MDMA_CH_Type) GetLAR() uint32 {
	return volatile.LoadUint32(&o.LAR.Reg)
}

// MDMA_CH.TBR: MDMA channel x Trigger and Bus selection Register
func (o *MDMA_CH_Type) SetTBR_TSEL(value uint32) {
	volatile.StoreUint32(&o.TBR.Reg, volatile.LoadUint32(&o.TBR.Reg)&^(0x3f)|value)
}
func (o *MDMA_CH_Type) GetTBR_TSEL() uint32 {
	return volatile.LoadUint32(&o.TBR.Reg) & 0x3f
}
func (o *MDMA_CH_Type) SetTBR_SBUS(value uint32) {
	volatile.StoreUint32(&o.TBR.Reg, volatile.LoadUint32(&o.TBR.Reg)&^(0x10000)|value<<16)
}
func (o *MDMA_CH_Type) GetTBR_SBUS() uint32 {
	return (volatile.LoadUint32(&o.TBR.Reg) & 0x10000) >> 16
}
func (o *MDMA_CH_Type) SetTBR_DBUS(value uint32) {
	volatile.StoreUint32(&o.TBR.Reg, volatile.LoadUint32(&o.TBR.Reg)&^(0x20000)|value<<17)
}
func (o *MDMA_CH_Type) GetTBR_DBUS() uint32 {
	return (volatile.LoadUint32(&o.TBR.Reg) & 0x20000) >> 17
}

// MDMA_CH.MAR: MDMA channel x Mask address register
func (o *MDMA_CH_Type) SetMAR(value uint32) {
	volatile.StoreUint32(&o.MAR.Reg, value)
}
func (o *MDMA_CH_Type) GetMAR() uint32 {
	return volatile.LoadUint32(&o.MAR.Reg)
}

// MDMA_CH.MDR: MDMA channel x Mask Data register
func (o *MDMA_CH_Type) SetMDR(value uint32) {
	volatile.StoreUint32(&o.MDR.Reg, value)
}
func (o *MDMA_CH_Type) GetMDR() uint32 {
	return volatile.LoadUint32(&o.MDR.Reg)
}

// Memory protection unit
type MPU_Type struct {
	TYPER volatile.Register32 // 0x0
	CTRL  volatile.Register32 // 0x4
	RNR   volatile.Register32 // 0x8
	RBAR  volatile.Register32 // 0xC
	RASR  volatile.Register32 // 0x10
}

// MPU.TYPER: MPU type register
func (o *MPU_Type) SetTYPER_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPER_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPER.Reg) & 0x1
}
func (o *MPU_Type) SetTYPER_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPER_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPER_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPER_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU control register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU region number register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU region base address register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU region attribute and size register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x3e)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x3e) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER0 volatile.Register32 // 0x0
	ISER1 volatile.Register32 // 0x4
	ISER2 volatile.Register32 // 0x8
	ISER3 volatile.Register32 // 0xC
	_     [112]byte
	ICER0 volatile.Register32 // 0x80
	ICER1 volatile.Register32 // 0x84
	ICER2 volatile.Register32 // 0x88
	ICER3 volatile.Register32 // 0x8C
	_     [112]byte
	ISPR0 volatile.Register32 // 0x100
	ISPR1 volatile.Register32 // 0x104
	ISPR2 volatile.Register32 // 0x108
	ISPR3 volatile.Register32 // 0x10C
	_     [112]byte
	ICPR0 volatile.Register32 // 0x180
	ICPR1 volatile.Register32 // 0x184
	ICPR2 volatile.Register32 // 0x188
	_     [52]byte
	ICPR3 volatile.Register32 // 0x1C0
	_     [60]byte
	IABR0 volatile.Register32 // 0x200
	IABR1 volatile.Register32 // 0x204
	IABR2 volatile.Register32 // 0x208
	IABR3 volatile.Register32 // 0x20C
	_     [240]byte
	IPR0  volatile.Register32 // 0x300
	IPR1  volatile.Register32 // 0x304
	IPR2  volatile.Register32 // 0x308
	IPR3  volatile.Register32 // 0x30C
	IPR4  volatile.Register32 // 0x310
	IPR5  volatile.Register32 // 0x314
	IPR6  volatile.Register32 // 0x318
	IPR7  volatile.Register32 // 0x31C
	IPR8  volatile.Register32 // 0x320
	IPR9  volatile.Register32 // 0x324
	IPR10 volatile.Register32 // 0x328
	IPR11 volatile.Register32 // 0x32C
	IPR12 volatile.Register32 // 0x330
	IPR13 volatile.Register32 // 0x334
	IPR14 volatile.Register32 // 0x338
	IPR15 volatile.Register32 // 0x33C
	IPR16 volatile.Register32 // 0x340
	IPR17 volatile.Register32 // 0x344
	IPR18 volatile.Register32 // 0x348
	IPR19 volatile.Register32 // 0x34C
	IPR20 volatile.Register32 // 0x350
	IPR21 volatile.Register32 // 0x354
	IPR22 volatile.Register32 // 0x358
	IPR23 volatile.Register32 // 0x35C
	IPR24 volatile.Register32 // 0x360
	IPR25 volatile.Register32 // 0x364
	IPR26 volatile.Register32 // 0x368
	IPR27 volatile.Register32 // 0x36C
	IPR28 volatile.Register32 // 0x370
	IPR29 volatile.Register32 // 0x374
	IPR30 volatile.Register32 // 0x378
	IPR31 volatile.Register32 // 0x37C
	IPR32 volatile.Register32 // 0x380
	IPR33 volatile.Register32 // 0x384
	IPR34 volatile.Register32 // 0x388
	IPR35 volatile.Register32 // 0x38C
	IPR36 volatile.Register32 // 0x390
	IPR37 volatile.Register32 // 0x394
	IPR38 volatile.Register32 // 0x398
}

// NVIC.ISER0: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER0(value uint32) {
	volatile.StoreUint32(&o.ISER0.Reg, value)
}
func (o *NVIC_Type) GetISER0() uint32 {
	return volatile.LoadUint32(&o.ISER0.Reg)
}

// NVIC.ISER1: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER1(value uint32) {
	volatile.StoreUint32(&o.ISER1.Reg, value)
}
func (o *NVIC_Type) GetISER1() uint32 {
	return volatile.LoadUint32(&o.ISER1.Reg)
}

// NVIC.ISER2: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER2(value uint32) {
	volatile.StoreUint32(&o.ISER2.Reg, value)
}
func (o *NVIC_Type) GetISER2() uint32 {
	return volatile.LoadUint32(&o.ISER2.Reg)
}

// NVIC.ICER0: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER0(value uint32) {
	volatile.StoreUint32(&o.ICER0.Reg, value)
}
func (o *NVIC_Type) GetICER0() uint32 {
	return volatile.LoadUint32(&o.ICER0.Reg)
}

// NVIC.ICER1: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER1(value uint32) {
	volatile.StoreUint32(&o.ICER1.Reg, value)
}
func (o *NVIC_Type) GetICER1() uint32 {
	return volatile.LoadUint32(&o.ICER1.Reg)
}

// NVIC.ICER2: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER2(value uint32) {
	volatile.StoreUint32(&o.ICER2.Reg, value)
}
func (o *NVIC_Type) GetICER2() uint32 {
	return volatile.LoadUint32(&o.ICER2.Reg)
}

// NVIC.ISPR0: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR0(value uint32) {
	volatile.StoreUint32(&o.ISPR0.Reg, value)
}
func (o *NVIC_Type) GetISPR0() uint32 {
	return volatile.LoadUint32(&o.ISPR0.Reg)
}

// NVIC.ISPR1: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR1(value uint32) {
	volatile.StoreUint32(&o.ISPR1.Reg, value)
}
func (o *NVIC_Type) GetISPR1() uint32 {
	return volatile.LoadUint32(&o.ISPR1.Reg)
}

// NVIC.ISPR2: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR2(value uint32) {
	volatile.StoreUint32(&o.ISPR2.Reg, value)
}
func (o *NVIC_Type) GetISPR2() uint32 {
	return volatile.LoadUint32(&o.ISPR2.Reg)
}

// NVIC.ICPR0: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR0(value uint32) {
	volatile.StoreUint32(&o.ICPR0.Reg, value)
}
func (o *NVIC_Type) GetICPR0() uint32 {
	return volatile.LoadUint32(&o.ICPR0.Reg)
}

// NVIC.ICPR1: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR1(value uint32) {
	volatile.StoreUint32(&o.ICPR1.Reg, value)
}
func (o *NVIC_Type) GetICPR1() uint32 {
	return volatile.LoadUint32(&o.ICPR1.Reg)
}

// NVIC.ICPR2: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR2(value uint32) {
	volatile.StoreUint32(&o.ICPR2.Reg, value)
}
func (o *NVIC_Type) GetICPR2() uint32 {
	return volatile.LoadUint32(&o.ICPR2.Reg)
}

// NVIC.IABR0: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR0(value uint32) {
	volatile.StoreUint32(&o.IABR0.Reg, value)
}
func (o *NVIC_Type) GetIABR0() uint32 {
	return volatile.LoadUint32(&o.IABR0.Reg)
}

// NVIC.IABR1: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR1(value uint32) {
	volatile.StoreUint32(&o.IABR1.Reg, value)
}
func (o *NVIC_Type) GetIABR1() uint32 {
	return volatile.LoadUint32(&o.IABR1.Reg)
}

// NVIC.IABR2: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR2(value uint32) {
	volatile.StoreUint32(&o.IABR2.Reg, value)
}
func (o *NVIC_Type) GetIABR2() uint32 {
	return volatile.LoadUint32(&o.IABR2.Reg)
}

// NVIC.IPR0: Interrupt Priority Register
func (o *NVIC_Type) SetIPR0_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR0_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR0_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR0_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR0_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR0_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR0_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR0_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff000000) >> 24
}

// NVIC.IPR1: Interrupt Priority Register
func (o *NVIC_Type) SetIPR1_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR1_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR1_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR1_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR1_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR1_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR1_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR1_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff000000) >> 24
}

// NVIC.IPR2: Interrupt Priority Register
func (o *NVIC_Type) SetIPR2_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR2_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR2_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR2_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR2_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR2_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR2_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR2_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff000000) >> 24
}

// NVIC.IPR3: Interrupt Priority Register
func (o *NVIC_Type) SetIPR3_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR3_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR3_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR3_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR3_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR3_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR3_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR3_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff000000) >> 24
}

// NVIC.IPR4: Interrupt Priority Register
func (o *NVIC_Type) SetIPR4_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR4_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR4.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR4_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR4_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR4_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR4_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR4_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR4_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff000000) >> 24
}

// NVIC.IPR5: Interrupt Priority Register
func (o *NVIC_Type) SetIPR5_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR5_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR5.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR5_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR5_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR5_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR5_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR5_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR5_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff000000) >> 24
}

// NVIC.IPR6: Interrupt Priority Register
func (o *NVIC_Type) SetIPR6_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR6_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR6.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR6_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR6_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR6_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR6_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR6_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR6_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff000000) >> 24
}

// NVIC.IPR7: Interrupt Priority Register
func (o *NVIC_Type) SetIPR7_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR7_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR7.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR7_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR7_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR7_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR7_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR7_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR7_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff000000) >> 24
}

// NVIC.IPR8: Interrupt Priority Register
func (o *NVIC_Type) SetIPR8_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR8_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR8.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR8_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR8_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR8_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR8_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR8_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR8_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff000000) >> 24
}

// NVIC.IPR9: Interrupt Priority Register
func (o *NVIC_Type) SetIPR9_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR9_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR9.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR9_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR9_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR9_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR9_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR9_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR9_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff000000) >> 24
}

// NVIC.IPR10: Interrupt Priority Register
func (o *NVIC_Type) SetIPR10_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR10_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR10.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR10_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR10_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR10_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR10_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR10_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR10_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff000000) >> 24
}

// NVIC.IPR11: Interrupt Priority Register
func (o *NVIC_Type) SetIPR11_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR11_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR11.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR11_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR11_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR11_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR11_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR11_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR11_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff000000) >> 24
}

// NVIC.IPR12: Interrupt Priority Register
func (o *NVIC_Type) SetIPR12_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR12_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR12.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR12_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR12_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR12_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR12_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR12_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR12_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff000000) >> 24
}

// NVIC.IPR13: Interrupt Priority Register
func (o *NVIC_Type) SetIPR13_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR13_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR13.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR13_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR13_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR13_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR13_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR13_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR13_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff000000) >> 24
}

// NVIC.IPR14: Interrupt Priority Register
func (o *NVIC_Type) SetIPR14_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR14_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR14.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR14_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR14_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR14_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR14_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR14_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR14_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff000000) >> 24
}

// NVIC.IPR15: Interrupt Priority Register
func (o *NVIC_Type) SetIPR15_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR15_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR15.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR15_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR15_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR15_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR15_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR15_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR15_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff000000) >> 24
}

// NVIC.IPR16: Interrupt Priority Register
func (o *NVIC_Type) SetIPR16_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR16_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR16.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR16_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR16_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR16_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR16_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR16_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR16_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff000000) >> 24
}

// NVIC.IPR17: Interrupt Priority Register
func (o *NVIC_Type) SetIPR17_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR17_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR17.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR17_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR17_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR17_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR17_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR17_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR17_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff000000) >> 24
}

// NVIC.IPR18: Interrupt Priority Register
func (o *NVIC_Type) SetIPR18_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR18_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR18.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR18_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR18_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR18_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR18_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR18_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR18_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff000000) >> 24
}

// NVIC.IPR19: Interrupt Priority Register
func (o *NVIC_Type) SetIPR19_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR19_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR19.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR19_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR19_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR19_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR19_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR19_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR19_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff000000) >> 24
}

// NVIC.IPR20: Interrupt Priority Register
func (o *NVIC_Type) SetIPR20_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR20_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR20.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR20_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR20_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR20_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR20_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR20_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR20_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff000000) >> 24
}

// NVIC.IPR21: Interrupt Priority Register
func (o *NVIC_Type) SetIPR21_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR21.Reg, volatile.LoadUint32(&o.IPR21.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR21_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR21.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR21_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR21.Reg, volatile.LoadUint32(&o.IPR21.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR21_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR21.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR21_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR21.Reg, volatile.LoadUint32(&o.IPR21.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR21_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR21.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR21_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR21.Reg, volatile.LoadUint32(&o.IPR21.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR21_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR21.Reg) & 0xff000000) >> 24
}

// NVIC.IPR22: Interrupt Priority Register
func (o *NVIC_Type) SetIPR22_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR22.Reg, volatile.LoadUint32(&o.IPR22.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR22_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR22.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR22_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR22.Reg, volatile.LoadUint32(&o.IPR22.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR22_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR22.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR22_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR22.Reg, volatile.LoadUint32(&o.IPR22.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR22_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR22.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR22_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR22.Reg, volatile.LoadUint32(&o.IPR22.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR22_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR22.Reg) & 0xff000000) >> 24
}

// NVIC.IPR23: Interrupt Priority Register
func (o *NVIC_Type) SetIPR23_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR23.Reg, volatile.LoadUint32(&o.IPR23.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR23_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR23.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR23_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR23.Reg, volatile.LoadUint32(&o.IPR23.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR23_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR23.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR23_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR23.Reg, volatile.LoadUint32(&o.IPR23.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR23_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR23.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR23_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR23.Reg, volatile.LoadUint32(&o.IPR23.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR23_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR23.Reg) & 0xff000000) >> 24
}

// NVIC.IPR24: Interrupt Priority Register
func (o *NVIC_Type) SetIPR24_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR24.Reg, volatile.LoadUint32(&o.IPR24.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR24_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR24.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR24_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR24.Reg, volatile.LoadUint32(&o.IPR24.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR24_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR24.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR24_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR24.Reg, volatile.LoadUint32(&o.IPR24.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR24_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR24.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR24_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR24.Reg, volatile.LoadUint32(&o.IPR24.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR24_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR24.Reg) & 0xff000000) >> 24
}

// NVIC.IPR25: Interrupt Priority Register
func (o *NVIC_Type) SetIPR25_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR25.Reg, volatile.LoadUint32(&o.IPR25.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR25_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR25.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR25_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR25.Reg, volatile.LoadUint32(&o.IPR25.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR25_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR25.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR25_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR25.Reg, volatile.LoadUint32(&o.IPR25.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR25_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR25.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR25_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR25.Reg, volatile.LoadUint32(&o.IPR25.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR25_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR25.Reg) & 0xff000000) >> 24
}

// NVIC.IPR26: Interrupt Priority Register
func (o *NVIC_Type) SetIPR26_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR26.Reg, volatile.LoadUint32(&o.IPR26.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR26_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR26.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR26_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR26.Reg, volatile.LoadUint32(&o.IPR26.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR26_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR26.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR26_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR26.Reg, volatile.LoadUint32(&o.IPR26.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR26_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR26.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR26_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR26.Reg, volatile.LoadUint32(&o.IPR26.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR26_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR26.Reg) & 0xff000000) >> 24
}

// NVIC.IPR27: Interrupt Priority Register
func (o *NVIC_Type) SetIPR27_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR27.Reg, volatile.LoadUint32(&o.IPR27.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR27_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR27.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR27_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR27.Reg, volatile.LoadUint32(&o.IPR27.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR27_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR27.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR27_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR27.Reg, volatile.LoadUint32(&o.IPR27.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR27_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR27.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR27_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR27.Reg, volatile.LoadUint32(&o.IPR27.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR27_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR27.Reg) & 0xff000000) >> 24
}

// NVIC.IPR28: Interrupt Priority Register
func (o *NVIC_Type) SetIPR28_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR28.Reg, volatile.LoadUint32(&o.IPR28.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR28_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR28.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR28_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR28.Reg, volatile.LoadUint32(&o.IPR28.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR28_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR28.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR28_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR28.Reg, volatile.LoadUint32(&o.IPR28.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR28_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR28.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR28_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR28.Reg, volatile.LoadUint32(&o.IPR28.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR28_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR28.Reg) & 0xff000000) >> 24
}

// NVIC.IPR29: Interrupt Priority Register
func (o *NVIC_Type) SetIPR29_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR29.Reg, volatile.LoadUint32(&o.IPR29.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR29_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR29.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR29_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR29.Reg, volatile.LoadUint32(&o.IPR29.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR29_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR29.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR29_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR29.Reg, volatile.LoadUint32(&o.IPR29.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR29_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR29.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR29_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR29.Reg, volatile.LoadUint32(&o.IPR29.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR29_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR29.Reg) & 0xff000000) >> 24
}

// NVIC.IPR30: Interrupt Priority Register
func (o *NVIC_Type) SetIPR30_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR30.Reg, volatile.LoadUint32(&o.IPR30.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR30_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR30.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR30_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR30.Reg, volatile.LoadUint32(&o.IPR30.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR30_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR30.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR30_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR30.Reg, volatile.LoadUint32(&o.IPR30.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR30_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR30.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR30_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR30.Reg, volatile.LoadUint32(&o.IPR30.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR30_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR30.Reg) & 0xff000000) >> 24
}

// NVIC.IPR31: Interrupt Priority Register
func (o *NVIC_Type) SetIPR31_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR31.Reg, volatile.LoadUint32(&o.IPR31.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR31_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR31.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR31_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR31.Reg, volatile.LoadUint32(&o.IPR31.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR31_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR31.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR31_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR31.Reg, volatile.LoadUint32(&o.IPR31.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR31_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR31.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR31_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR31.Reg, volatile.LoadUint32(&o.IPR31.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR31_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR31.Reg) & 0xff000000) >> 24
}

// NVIC.IPR32: Interrupt Priority Register
func (o *NVIC_Type) SetIPR32_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR32.Reg, volatile.LoadUint32(&o.IPR32.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR32_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR32.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR32_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR32.Reg, volatile.LoadUint32(&o.IPR32.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR32_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR32.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR32_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR32.Reg, volatile.LoadUint32(&o.IPR32.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR32_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR32.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR32_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR32.Reg, volatile.LoadUint32(&o.IPR32.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR32_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR32.Reg) & 0xff000000) >> 24
}

// NVIC.IPR33: Interrupt Priority Register
func (o *NVIC_Type) SetIPR33_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR33.Reg, volatile.LoadUint32(&o.IPR33.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR33_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR33.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR33_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR33.Reg, volatile.LoadUint32(&o.IPR33.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR33_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR33.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR33_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR33.Reg, volatile.LoadUint32(&o.IPR33.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR33_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR33.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR33_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR33.Reg, volatile.LoadUint32(&o.IPR33.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR33_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR33.Reg) & 0xff000000) >> 24
}

// NVIC.IPR34: Interrupt Priority Register
func (o *NVIC_Type) SetIPR34_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR34.Reg, volatile.LoadUint32(&o.IPR34.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR34_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR34.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR34_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR34.Reg, volatile.LoadUint32(&o.IPR34.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR34_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR34.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR34_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR34.Reg, volatile.LoadUint32(&o.IPR34.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR34_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR34.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR34_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR34.Reg, volatile.LoadUint32(&o.IPR34.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR34_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR34.Reg) & 0xff000000) >> 24
}

// NVIC.IPR35: Interrupt Priority Register
func (o *NVIC_Type) SetIPR35_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR35.Reg, volatile.LoadUint32(&o.IPR35.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR35_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR35.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR35_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR35.Reg, volatile.LoadUint32(&o.IPR35.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR35_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR35.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR35_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR35.Reg, volatile.LoadUint32(&o.IPR35.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR35_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR35.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR35_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR35.Reg, volatile.LoadUint32(&o.IPR35.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR35_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR35.Reg) & 0xff000000) >> 24
}

// NVIC.IPR36: Interrupt Priority Register
func (o *NVIC_Type) SetIPR36_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR36.Reg, volatile.LoadUint32(&o.IPR36.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR36_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR36.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR36_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR36.Reg, volatile.LoadUint32(&o.IPR36.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR36_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR36.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR36_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR36.Reg, volatile.LoadUint32(&o.IPR36.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR36_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR36.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR36_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR36.Reg, volatile.LoadUint32(&o.IPR36.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR36_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR36.Reg) & 0xff000000) >> 24
}

// NVIC.IPR37: Interrupt Priority Register
func (o *NVIC_Type) SetIPR37_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR37.Reg, volatile.LoadUint32(&o.IPR37.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR37_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR37.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR37_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR37.Reg, volatile.LoadUint32(&o.IPR37.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR37_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR37.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR37_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR37.Reg, volatile.LoadUint32(&o.IPR37.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR37_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR37.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR37_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR37.Reg, volatile.LoadUint32(&o.IPR37.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR37_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR37.Reg) & 0xff000000) >> 24
}

// NVIC.IPR38: Interrupt Priority Register
func (o *NVIC_Type) SetIPR38_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR38.Reg, volatile.LoadUint32(&o.IPR38.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR38_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR38.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR38_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR38.Reg, volatile.LoadUint32(&o.IPR38.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR38_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR38.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR38_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR38.Reg, volatile.LoadUint32(&o.IPR38.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR38_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR38.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR38_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR38.Reg, volatile.LoadUint32(&o.IPR38.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR38_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR38.Reg) & 0xff000000) >> 24
}

// OctoSPI
type OctoSPI_Type struct {
	CR    volatile.Register32 // 0x0
	_     [4]byte
	DCR1  volatile.Register32 // 0x8
	DCR2  volatile.Register32 // 0xC
	DCR3  volatile.Register32 // 0x10
	DCR4  volatile.Register32 // 0x14
	_     [8]byte
	SR    volatile.Register32 // 0x20
	FCR   volatile.Register32 // 0x24
	_     [24]byte
	DLR   volatile.Register32 // 0x40
	_     [4]byte
	AR    volatile.Register32 // 0x48
	_     [4]byte
	DR    volatile.Register32 // 0x50
	_     [44]byte
	PSMKR volatile.Register32 // 0x80
	_     [4]byte
	PSMAR volatile.Register32 // 0x88
	_     [4]byte
	PIR   volatile.Register32 // 0x90
	_     [108]byte
	CCR   volatile.Register32 // 0x100
	_     [4]byte
	TCR   volatile.Register32 // 0x108
	_     [4]byte
	IR    volatile.Register32 // 0x110
	_     [12]byte
	ABR   volatile.Register32 // 0x120
	_     [12]byte
	LPTR  volatile.Register32 // 0x130
	_     [12]byte
	WPCCR volatile.Register32 // 0x140
	_     [4]byte
	WPTCR volatile.Register32 // 0x148
	_     [4]byte
	WPIR  volatile.Register32 // 0x150
	_     [12]byte
	WPABR volatile.Register32 // 0x160
	_     [28]byte
	WCCR  volatile.Register32 // 0x180
	_     [4]byte
	WTCR  volatile.Register32 // 0x188
	_     [4]byte
	WIR   volatile.Register32 // 0x190
	_     [12]byte
	WABR  volatile.Register32 // 0x1A0
	_     [92]byte
	HLCR  volatile.Register32 // 0x200
}

// OctoSPI.CR: control register
func (o *OctoSPI_Type) SetCR_FMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000000)|value<<28)
}
func (o *OctoSPI_Type) GetCR_FMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000000) >> 28
}
func (o *OctoSPI_Type) SetCR_PMM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *OctoSPI_Type) GetCR_PMM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *OctoSPI_Type) SetCR_APMS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *OctoSPI_Type) GetCR_APMS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *OctoSPI_Type) SetCR_TOIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *OctoSPI_Type) GetCR_TOIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *OctoSPI_Type) SetCR_SMIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetCR_SMIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetCR_FTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *OctoSPI_Type) GetCR_FTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *OctoSPI_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *OctoSPI_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *OctoSPI_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *OctoSPI_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *OctoSPI_Type) SetCR_FTHRES(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1f00)|value<<8)
}
func (o *OctoSPI_Type) GetCR_FTHRES() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1f00) >> 8
}
func (o *OctoSPI_Type) SetCR_FSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *OctoSPI_Type) GetCR_FSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *OctoSPI_Type) SetCR_DQM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *OctoSPI_Type) GetCR_DQM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *OctoSPI_Type) SetCR_TCEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetCR_TCEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetCR_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *OctoSPI_Type) GetCR_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *OctoSPI_Type) SetCR_ABORT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetCR_ABORT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// OctoSPI.DCR1: device configuration register
func (o *OctoSPI_Type) SetDCR1_CKMODE(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetDCR1_CKMODE() uint32 {
	return volatile.LoadUint32(&o.DCR1.Reg) & 0x1
}
func (o *OctoSPI_Type) SetDCR1_FRCK(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetDCR1_FRCK() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetDCR1_CSHT(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x3f00)|value<<8)
}
func (o *OctoSPI_Type) GetDCR1_CSHT() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x3f00) >> 8
}
func (o *OctoSPI_Type) SetDCR1_DEVSIZE(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *OctoSPI_Type) GetDCR1_DEVSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x1f0000) >> 16
}
func (o *OctoSPI_Type) SetDCR1_MTYP(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x7000000)|value<<24)
}
func (o *OctoSPI_Type) GetDCR1_MTYP() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x7000000) >> 24
}
func (o *OctoSPI_Type) SetDCR1_DLYBYP(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetDCR1_DLYBYP() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x8) >> 3
}

// OctoSPI.DCR2: device configuration register 2
func (o *OctoSPI_Type) SetDCR2_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.DCR2.Reg, volatile.LoadUint32(&o.DCR2.Reg)&^(0xff)|value)
}
func (o *OctoSPI_Type) GetDCR2_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.DCR2.Reg) & 0xff
}
func (o *OctoSPI_Type) SetDCR2_WRAPSIZE(value uint32) {
	volatile.StoreUint32(&o.DCR2.Reg, volatile.LoadUint32(&o.DCR2.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetDCR2_WRAPSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCR2.Reg) & 0x70000) >> 16
}

// OctoSPI.DCR3: device configuration register 3
func (o *OctoSPI_Type) SetDCR3_MAXTRAN(value uint32) {
	volatile.StoreUint32(&o.DCR3.Reg, volatile.LoadUint32(&o.DCR3.Reg)&^(0xff)|value)
}
func (o *OctoSPI_Type) GetDCR3_MAXTRAN() uint32 {
	return volatile.LoadUint32(&o.DCR3.Reg) & 0xff
}
func (o *OctoSPI_Type) SetDCR3_CSBOUND(value uint32) {
	volatile.StoreUint32(&o.DCR3.Reg, volatile.LoadUint32(&o.DCR3.Reg)&^(0x1f0000)|value<<16)
}
func (o *OctoSPI_Type) GetDCR3_CSBOUND() uint32 {
	return (volatile.LoadUint32(&o.DCR3.Reg) & 0x1f0000) >> 16
}

// OctoSPI.DCR4: DCR4
func (o *OctoSPI_Type) SetDCR4(value uint32) {
	volatile.StoreUint32(&o.DCR4.Reg, value)
}
func (o *OctoSPI_Type) GetDCR4() uint32 {
	return volatile.LoadUint32(&o.DCR4.Reg)
}

// OctoSPI.SR: status register
func (o *OctoSPI_Type) SetSR_TEF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetSR_TEF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *OctoSPI_Type) SetSR_TCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetSR_SMF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetSR_SMF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetSR_TOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *OctoSPI_Type) GetSR_TOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *OctoSPI_Type) SetSR_FTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *OctoSPI_Type) GetSR_FTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *OctoSPI_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *OctoSPI_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *OctoSPI_Type) SetSR_FLEVEL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x3f00)|value<<8)
}
func (o *OctoSPI_Type) GetSR_FLEVEL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x3f00) >> 8
}

// OctoSPI.FCR: flag clear register
func (o *OctoSPI_Type) SetFCR_CTEF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetFCR_CTEF() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0x1
}
func (o *OctoSPI_Type) SetFCR_CTCF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetFCR_CTCF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetFCR_CSMF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetFCR_CSMF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetFCR_CTOF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x10)|value<<4)
}
func (o *OctoSPI_Type) GetFCR_CTOF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x10) >> 4
}

// OctoSPI.DLR: data length register
func (o *OctoSPI_Type) SetDLR(value uint32) {
	volatile.StoreUint32(&o.DLR.Reg, value)
}
func (o *OctoSPI_Type) GetDLR() uint32 {
	return volatile.LoadUint32(&o.DLR.Reg)
}

// OctoSPI.AR: address register
func (o *OctoSPI_Type) SetAR(value uint32) {
	volatile.StoreUint32(&o.AR.Reg, value)
}
func (o *OctoSPI_Type) GetAR() uint32 {
	return volatile.LoadUint32(&o.AR.Reg)
}

// OctoSPI.DR: data register
func (o *OctoSPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *OctoSPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// OctoSPI.PSMKR: polling status mask register
func (o *OctoSPI_Type) SetPSMKR(value uint32) {
	volatile.StoreUint32(&o.PSMKR.Reg, value)
}
func (o *OctoSPI_Type) GetPSMKR() uint32 {
	return volatile.LoadUint32(&o.PSMKR.Reg)
}

// OctoSPI.PSMAR: polling status match register
func (o *OctoSPI_Type) SetPSMAR(value uint32) {
	volatile.StoreUint32(&o.PSMAR.Reg, value)
}
func (o *OctoSPI_Type) GetPSMAR() uint32 {
	return volatile.LoadUint32(&o.PSMAR.Reg)
}

// OctoSPI.PIR: OCTOSPI polling interval register
func (o *OctoSPI_Type) SetPIR_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0xffff)|value)
}
func (o *OctoSPI_Type) GetPIR_INTERVAL() uint32 {
	return volatile.LoadUint32(&o.PIR.Reg) & 0xffff
}

// OctoSPI.CCR: polling interval register
func (o *OctoSPI_Type) SetCCR_IMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x7)|value)
}
func (o *OctoSPI_Type) GetCCR_IMODE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x7
}
func (o *OctoSPI_Type) SetCCR_IDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetCCR_IDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetCCR_ISIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x30)|value<<4)
}
func (o *OctoSPI_Type) GetCCR_ISIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x30) >> 4
}
func (o *OctoSPI_Type) SetCCR_ADMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x700)|value<<8)
}
func (o *OctoSPI_Type) GetCCR_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x700) >> 8
}
func (o *OctoSPI_Type) SetCCR_ADDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x800)|value<<11)
}
func (o *OctoSPI_Type) GetCCR_ADDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x800) >> 11
}
func (o *OctoSPI_Type) SetCCR_ADSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3000)|value<<12)
}
func (o *OctoSPI_Type) GetCCR_ADSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x3000) >> 12
}
func (o *OctoSPI_Type) SetCCR_ABMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetCCR_ABMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x70000) >> 16
}
func (o *OctoSPI_Type) SetCCR_ABDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetCCR_ABDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetCCR_ABSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x300000)|value<<20)
}
func (o *OctoSPI_Type) GetCCR_ABSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x300000) >> 20
}
func (o *OctoSPI_Type) SetCCR_DMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x7000000)|value<<24)
}
func (o *OctoSPI_Type) GetCCR_DMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x7000000) >> 24
}
func (o *OctoSPI_Type) SetCCR_DDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8000000)|value<<27)
}
func (o *OctoSPI_Type) GetCCR_DDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8000000) >> 27
}
func (o *OctoSPI_Type) SetCCR_DQSE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20000000)|value<<29)
}
func (o *OctoSPI_Type) GetCCR_DQSE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20000000) >> 29
}
func (o *OctoSPI_Type) SetCCR_SIOO(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80000000)|value<<31)
}
func (o *OctoSPI_Type) GetCCR_SIOO() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80000000) >> 31
}

// OctoSPI.TCR: communication configuration register
func (o *OctoSPI_Type) SetTCR_DCYC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1f)|value)
}
func (o *OctoSPI_Type) GetTCR_DCYC() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1f
}
func (o *OctoSPI_Type) SetTCR_DHQC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10000000)|value<<28)
}
func (o *OctoSPI_Type) GetTCR_DHQC() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10000000) >> 28
}
func (o *OctoSPI_Type) SetTCR_SSHIFT(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x40000000)|value<<30)
}
func (o *OctoSPI_Type) GetTCR_SSHIFT() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x40000000) >> 30
}

// OctoSPI.IR: timing configuration register
func (o *OctoSPI_Type) SetIR(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, value)
}
func (o *OctoSPI_Type) GetIR() uint32 {
	return volatile.LoadUint32(&o.IR.Reg)
}

// OctoSPI.ABR: instruction register
func (o *OctoSPI_Type) SetABR(value uint32) {
	volatile.StoreUint32(&o.ABR.Reg, value)
}
func (o *OctoSPI_Type) GetABR() uint32 {
	return volatile.LoadUint32(&o.ABR.Reg)
}

// OctoSPI.LPTR: alternate bytes register
func (o *OctoSPI_Type) SetLPTR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPTR.Reg, volatile.LoadUint32(&o.LPTR.Reg)&^(0xffff)|value)
}
func (o *OctoSPI_Type) GetLPTR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.LPTR.Reg) & 0xffff
}

// OctoSPI.WPCCR: low-power timeout register
func (o *OctoSPI_Type) SetWPCCR_IMODE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x7)|value)
}
func (o *OctoSPI_Type) GetWPCCR_IMODE() uint32 {
	return volatile.LoadUint32(&o.WPCCR.Reg) & 0x7
}
func (o *OctoSPI_Type) SetWPCCR_IDTR(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetWPCCR_IDTR() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetWPCCR_ISIZE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x30)|value<<4)
}
func (o *OctoSPI_Type) GetWPCCR_ISIZE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x30) >> 4
}
func (o *OctoSPI_Type) SetWPCCR_ADMODE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x700)|value<<8)
}
func (o *OctoSPI_Type) GetWPCCR_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x700) >> 8
}
func (o *OctoSPI_Type) SetWPCCR_ADDTR(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x800)|value<<11)
}
func (o *OctoSPI_Type) GetWPCCR_ADDTR() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x800) >> 11
}
func (o *OctoSPI_Type) SetWPCCR_ADSIZE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x3000)|value<<12)
}
func (o *OctoSPI_Type) GetWPCCR_ADSIZE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x3000) >> 12
}
func (o *OctoSPI_Type) SetWPCCR_ABMODE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetWPCCR_ABMODE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x70000) >> 16
}
func (o *OctoSPI_Type) SetWPCCR_ABDTR(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetWPCCR_ABDTR() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetWPCCR_ABSIZE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x300000)|value<<20)
}
func (o *OctoSPI_Type) GetWPCCR_ABSIZE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x300000) >> 20
}
func (o *OctoSPI_Type) SetWPCCR_DMODE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x7000000)|value<<24)
}
func (o *OctoSPI_Type) GetWPCCR_DMODE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x7000000) >> 24
}
func (o *OctoSPI_Type) SetWPCCR_DDTR(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x8000000)|value<<27)
}
func (o *OctoSPI_Type) GetWPCCR_DDTR() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x8000000) >> 27
}
func (o *OctoSPI_Type) SetWPCCR_DQSE(value uint32) {
	volatile.StoreUint32(&o.WPCCR.Reg, volatile.LoadUint32(&o.WPCCR.Reg)&^(0x20000000)|value<<29)
}
func (o *OctoSPI_Type) GetWPCCR_DQSE() uint32 {
	return (volatile.LoadUint32(&o.WPCCR.Reg) & 0x20000000) >> 29
}

// OctoSPI.WPTCR: wrap timing configuration register
func (o *OctoSPI_Type) SetWPTCR_DCYC(value uint32) {
	volatile.StoreUint32(&o.WPTCR.Reg, volatile.LoadUint32(&o.WPTCR.Reg)&^(0x1f)|value)
}
func (o *OctoSPI_Type) GetWPTCR_DCYC() uint32 {
	return volatile.LoadUint32(&o.WPTCR.Reg) & 0x1f
}
func (o *OctoSPI_Type) SetWPTCR_DHQC(value uint32) {
	volatile.StoreUint32(&o.WPTCR.Reg, volatile.LoadUint32(&o.WPTCR.Reg)&^(0x10000000)|value<<28)
}
func (o *OctoSPI_Type) GetWPTCR_DHQC() uint32 {
	return (volatile.LoadUint32(&o.WPTCR.Reg) & 0x10000000) >> 28
}
func (o *OctoSPI_Type) SetWPTCR_SSHIFT(value uint32) {
	volatile.StoreUint32(&o.WPTCR.Reg, volatile.LoadUint32(&o.WPTCR.Reg)&^(0x40000000)|value<<30)
}
func (o *OctoSPI_Type) GetWPTCR_SSHIFT() uint32 {
	return (volatile.LoadUint32(&o.WPTCR.Reg) & 0x40000000) >> 30
}

// OctoSPI.WPIR: wrap instruction register
func (o *OctoSPI_Type) SetWPIR(value uint32) {
	volatile.StoreUint32(&o.WPIR.Reg, value)
}
func (o *OctoSPI_Type) GetWPIR() uint32 {
	return volatile.LoadUint32(&o.WPIR.Reg)
}

// OctoSPI.WPABR: wrap alternate bytes register
func (o *OctoSPI_Type) SetWPABR(value uint32) {
	volatile.StoreUint32(&o.WPABR.Reg, value)
}
func (o *OctoSPI_Type) GetWPABR() uint32 {
	return volatile.LoadUint32(&o.WPABR.Reg)
}

// OctoSPI.WCCR: write communication configuration register
func (o *OctoSPI_Type) SetWCCR_IMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x3)|value)
}
func (o *OctoSPI_Type) GetWCCR_IMODE() uint32 {
	return volatile.LoadUint32(&o.WCCR.Reg) & 0x3
}
func (o *OctoSPI_Type) SetWCCR_IDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x4)|value<<2)
}
func (o *OctoSPI_Type) GetWCCR_IDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x4) >> 2
}
func (o *OctoSPI_Type) SetWCCR_ISIZE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetWCCR_ISIZE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetWCCR_ADMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x700)|value<<8)
}
func (o *OctoSPI_Type) GetWCCR_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x700) >> 8
}
func (o *OctoSPI_Type) SetWCCR_ADDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x800)|value<<11)
}
func (o *OctoSPI_Type) GetWCCR_ADDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x800) >> 11
}
func (o *OctoSPI_Type) SetWCCR_ADSIZE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x3000)|value<<12)
}
func (o *OctoSPI_Type) GetWCCR_ADSIZE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x3000) >> 12
}
func (o *OctoSPI_Type) SetWCCR_ABMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetWCCR_ABMODE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x70000) >> 16
}
func (o *OctoSPI_Type) SetWCCR_ABDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetWCCR_ABDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetWCCR_ABSIZE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x300000)|value<<20)
}
func (o *OctoSPI_Type) GetWCCR_ABSIZE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x300000) >> 20
}
func (o *OctoSPI_Type) SetWCCR_DMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x7000000)|value<<24)
}
func (o *OctoSPI_Type) GetWCCR_DMODE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x7000000) >> 24
}
func (o *OctoSPI_Type) SetWCCR_DDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x8000000)|value<<27)
}
func (o *OctoSPI_Type) GetWCCR_DDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x8000000) >> 27
}
func (o *OctoSPI_Type) SetWCCR_DQSE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x20000000)|value<<29)
}
func (o *OctoSPI_Type) GetWCCR_DQSE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x20000000) >> 29
}

// OctoSPI.WTCR: write timing configuration register
func (o *OctoSPI_Type) SetWTCR_DCYC(value uint32) {
	volatile.StoreUint32(&o.WTCR.Reg, volatile.LoadUint32(&o.WTCR.Reg)&^(0x1f)|value)
}
func (o *OctoSPI_Type) GetWTCR_DCYC() uint32 {
	return volatile.LoadUint32(&o.WTCR.Reg) & 0x1f
}

// OctoSPI.WIR: instruction register
func (o *OctoSPI_Type) SetWIR(value uint32) {
	volatile.StoreUint32(&o.WIR.Reg, value)
}
func (o *OctoSPI_Type) GetWIR() uint32 {
	return volatile.LoadUint32(&o.WIR.Reg)
}

// OctoSPI.WABR: write alternate bytes register
func (o *OctoSPI_Type) SetWABR(value uint32) {
	volatile.StoreUint32(&o.WABR.Reg, value)
}
func (o *OctoSPI_Type) GetWABR() uint32 {
	return volatile.LoadUint32(&o.WABR.Reg)
}

// OctoSPI.HLCR: HyperBusTM latency configuration register
func (o *OctoSPI_Type) SetHLCR_LM(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetHLCR_LM() uint32 {
	return volatile.LoadUint32(&o.HLCR.Reg) & 0x1
}
func (o *OctoSPI_Type) SetHLCR_WZL(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetHLCR_WZL() uint32 {
	return (volatile.LoadUint32(&o.HLCR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetHLCR_TACC(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0xff00)|value<<8)
}
func (o *OctoSPI_Type) GetHLCR_TACC() uint32 {
	return (volatile.LoadUint32(&o.HLCR.Reg) & 0xff00) >> 8
}
func (o *OctoSPI_Type) SetHLCR_TRWR(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0xff0000)|value<<16)
}
func (o *OctoSPI_Type) GetHLCR_TRWR() uint32 {
	return (volatile.LoadUint32(&o.HLCR.Reg) & 0xff0000) >> 16
}

// Operational amplifiers
type OPAMP_Type struct {
	OPAMP1_CSR   volatile.Register32 // 0x0
	OPAMP1_OTR   volatile.Register32 // 0x4
	OPAMP1_HSOTR volatile.Register32 // 0x8
	_            [4]byte
	OPAMP2_CSR   volatile.Register32 // 0x10
	OPAMP2_OTR   volatile.Register32 // 0x14
	OPAMP2_HSOTR volatile.Register32 // 0x18
}

// OPAMP.OPAMP1_CSR: OPAMP1 control/status register
func (o *OPAMP_Type) SetOPAMP1_CSR_OPAEN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_OPAEN() uint32 {
	return volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x1
}
func (o *OPAMP_Type) SetOPAMP1_CSR_FORCE_VP(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_FORCE_VP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetOPAMP1_CSR_VP_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0xc)|value<<2)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_VP_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0xc) >> 2
}
func (o *OPAMP_Type) SetOPAMP1_CSR_VM_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x60)|value<<5)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_VM_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x60) >> 5
}
func (o *OPAMP_Type) SetOPAMP1_CSR_OPAHSM(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x100)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_OPAHSM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x100) >> 8
}
func (o *OPAMP_Type) SetOPAMP1_CSR_CALON(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x800)|value<<11)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_CALON() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x800) >> 11
}
func (o *OPAMP_Type) SetOPAMP1_CSR_CALSEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x3000)|value<<12)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_CALSEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x3000) >> 12
}
func (o *OPAMP_Type) SetOPAMP1_CSR_PGA_GAIN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x3c000)|value<<14)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_PGA_GAIN() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x3c000) >> 14
}
func (o *OPAMP_Type) SetOPAMP1_CSR_USERTRIM(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x40000)|value<<18)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_USERTRIM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x40000) >> 18
}
func (o *OPAMP_Type) SetOPAMP1_CSR_TSTREF(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x20000000)|value<<29)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_TSTREF() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x20000000) >> 29
}
func (o *OPAMP_Type) SetOPAMP1_CSR_CALOUT(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_CALOUT() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x40000000) >> 30
}

// OPAMP.OPAMP1_OTR: OPAMP1 offset trimming register in normal mode
func (o *OPAMP_Type) SetOPAMP1_OTR_TRIMOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_OTR.Reg, volatile.LoadUint32(&o.OPAMP1_OTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP1_OTR_TRIMOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP1_OTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP1_OTR_TRIMOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_OTR.Reg, volatile.LoadUint32(&o.OPAMP1_OTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP1_OTR_TRIMOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_OTR.Reg) & 0x1f00) >> 8
}

// OPAMP.OPAMP1_HSOTR: OPAMP1 offset trimming register in low-power mode
func (o *OPAMP_Type) SetOPAMP1_HSOTR_TRIMLPOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_HSOTR.Reg, volatile.LoadUint32(&o.OPAMP1_HSOTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP1_HSOTR_TRIMLPOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP1_HSOTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP1_HSOTR_TRIMLPOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_HSOTR.Reg, volatile.LoadUint32(&o.OPAMP1_HSOTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP1_HSOTR_TRIMLPOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_HSOTR.Reg) & 0x1f00) >> 8
}

// OPAMP.OPAMP2_CSR: OPAMP2 control/status register
func (o *OPAMP_Type) SetOPAMP2_CSR_OPAEN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_OPAEN() uint32 {
	return volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x1
}
func (o *OPAMP_Type) SetOPAMP2_CSR_FORCE_VP(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_FORCE_VP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetOPAMP2_CSR_VM_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x60)|value<<5)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_VM_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x60) >> 5
}
func (o *OPAMP_Type) SetOPAMP2_CSR_OPAHSM(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x100)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_OPAHSM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x100) >> 8
}
func (o *OPAMP_Type) SetOPAMP2_CSR_CALON(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x800)|value<<11)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_CALON() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x800) >> 11
}
func (o *OPAMP_Type) SetOPAMP2_CSR_CALSEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x3000)|value<<12)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_CALSEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x3000) >> 12
}
func (o *OPAMP_Type) SetOPAMP2_CSR_PGA_GAIN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x3c000)|value<<14)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_PGA_GAIN() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x3c000) >> 14
}
func (o *OPAMP_Type) SetOPAMP2_CSR_USERTRIM(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x40000)|value<<18)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_USERTRIM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x40000) >> 18
}
func (o *OPAMP_Type) SetOPAMP2_CSR_TSTREF(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x20000000)|value<<29)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_TSTREF() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x20000000) >> 29
}
func (o *OPAMP_Type) SetOPAMP2_CSR_CALOUT(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_CALOUT() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x40000000) >> 30
}

// OPAMP.OPAMP2_OTR: OPAMP2 offset trimming register in normal mode
func (o *OPAMP_Type) SetOPAMP2_OTR_TRIMOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_OTR.Reg, volatile.LoadUint32(&o.OPAMP2_OTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP2_OTR_TRIMOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP2_OTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP2_OTR_TRIMOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_OTR.Reg, volatile.LoadUint32(&o.OPAMP2_OTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP2_OTR_TRIMOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_OTR.Reg) & 0x1f00) >> 8
}

// OPAMP.OPAMP2_HSOTR: OPAMP2 offset trimming register in low-power mode
func (o *OPAMP_Type) SetOPAMP2_HSOTR_TRIMLPOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_HSOTR.Reg, volatile.LoadUint32(&o.OPAMP2_HSOTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP2_HSOTR_TRIMLPOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP2_HSOTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP2_HSOTR_TRIMLPOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_HSOTR.Reg, volatile.LoadUint32(&o.OPAMP2_HSOTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP2_HSOTR_TRIMLPOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_HSOTR.Reg) & 0x1f00) >> 8
}

// USB 1 on the go high speed
type USB_OTG_HS_Type struct {
	DCFG        volatile.Register32 // 0x0
	DCTL        volatile.Register32 // 0x4
	DSTS        volatile.Register32 // 0x8
	_           [4]byte
	DIEPMSK     volatile.Register32 // 0x10
	DOEPMSK     volatile.Register32 // 0x14
	DAINT       volatile.Register32 // 0x18
	DAINTMSK    volatile.Register32 // 0x1C
	_           [8]byte
	DVBUSDIS    volatile.Register32 // 0x28
	DVBUSPULSE  volatile.Register32 // 0x2C
	DTHRCTL     volatile.Register32 // 0x30
	DIEPEMPMSK  volatile.Register32 // 0x34
	DEACHINT    volatile.Register32 // 0x38
	DEACHINTMSK volatile.Register32 // 0x3C
	_           [192]byte
	DIEPCTL0    volatile.Register32 // 0x100
	_           [4]byte
	DIEPINT0    volatile.Register32 // 0x108
	_           [4]byte
	DIEPTSIZ0   volatile.Register32 // 0x110
	DIEPDMA1    volatile.Register32 // 0x114
	DTXFSTS0    volatile.Register32 // 0x118
	_           [4]byte
	DIEPCTL1    volatile.Register32 // 0x120
	_           [4]byte
	DIEPINT1    volatile.Register32 // 0x128
	_           [4]byte
	DIEPTSIZ1   volatile.Register32 // 0x130
	DIEPDMA2    volatile.Register32 // 0x134
	DTXFSTS1    volatile.Register32 // 0x138
	_           [4]byte
	DIEPCTL2    volatile.Register32 // 0x140
	_           [4]byte
	DIEPINT2    volatile.Register32 // 0x148
	_           [4]byte
	DIEPTSIZ2   volatile.Register32 // 0x150
	DIEPDMA3    volatile.Register32 // 0x154
	DTXFSTS2    volatile.Register32 // 0x158
	_           [4]byte
	DIEPCTL3    volatile.Register32 // 0x160
	_           [4]byte
	DIEPINT3    volatile.Register32 // 0x168
	_           [4]byte
	DIEPTSIZ3   volatile.Register32 // 0x170
	DIEPDMA4    volatile.Register32 // 0x174
	DTXFSTS3    volatile.Register32 // 0x178
	_           [4]byte
	DIEPCTL4    volatile.Register32 // 0x180
	_           [4]byte
	DIEPINT4    volatile.Register32 // 0x188
	_           [4]byte
	DIEPTSIZ4   volatile.Register32 // 0x190
	DIEPDMA5    volatile.Register32 // 0x194
	DTXFSTS4    volatile.Register32 // 0x198
	_           [4]byte
	DIEPCTL5    volatile.Register32 // 0x1A0
	DTXFSTS6    volatile.Register32 // 0x1A4
	DIEPINT5    volatile.Register32 // 0x1A8
	DTXFSTS7    volatile.Register32 // 0x1AC
	DIEPTSIZ5   volatile.Register32 // 0x1B0
	_           [4]byte
	DTXFSTS5    volatile.Register32 // 0x1B8
	_           [4]byte
	DIEPCTL6    volatile.Register32 // 0x1C0
	_           [4]byte
	DIEPINT6    volatile.Register32 // 0x1C8
	_           [20]byte
	DIEPCTL7    volatile.Register32 // 0x1E0
	_           [4]byte
	DIEPINT7    volatile.Register32 // 0x1E8
	_           [276]byte
	DOEPCTL0    volatile.Register32 // 0x300
	_           [4]byte
	DOEPINT0    volatile.Register32 // 0x308
	_           [4]byte
	DOEPTSIZ0   volatile.Register32 // 0x310
	_           [12]byte
	DOEPCTL1    volatile.Register32 // 0x320
	_           [4]byte
	DOEPINT1    volatile.Register32 // 0x328
	_           [4]byte
	DOEPTSIZ1   volatile.Register32 // 0x330
	_           [12]byte
	DOEPCTL2    volatile.Register32 // 0x340
	_           [4]byte
	DOEPINT2    volatile.Register32 // 0x348
	_           [4]byte
	DOEPTSIZ2   volatile.Register32 // 0x350
	_           [12]byte
	DOEPCTL3    volatile.Register32 // 0x360
	_           [4]byte
	DOEPINT3    volatile.Register32 // 0x368
	_           [4]byte
	DOEPTSIZ3   volatile.Register32 // 0x370
	_           [12]byte
	DOEPCTL4    volatile.Register32 // 0x380
	_           [4]byte
	DOEPINT4    volatile.Register32 // 0x388
	_           [4]byte
	DOEPTSIZ4   volatile.Register32 // 0x390
	_           [12]byte
	DOEPCTL5    volatile.Register32 // 0x3A0
	_           [4]byte
	DOEPINT5    volatile.Register32 // 0x3A8
	_           [4]byte
	DOEPTSIZ5   volatile.Register32 // 0x3B0
	_           [12]byte
	DOEPCTL6    volatile.Register32 // 0x3C0
	_           [4]byte
	DOEPINT6    volatile.Register32 // 0x3C8
	_           [4]byte
	DOEPTSIZ6   volatile.Register32 // 0x3D0
	_           [12]byte
	DOEPCTL7    volatile.Register32 // 0x3E0
	_           [4]byte
	DOEPINT7    volatile.Register32 // 0x3E8
	_           [4]byte
	DOEPTSIZ7   volatile.Register32 // 0x3F0
}

// USB_OTG_HS.DCFG: OTG_HS device configuration register
func (o *USB_OTG_HS_Type) SetDCFG_DSPD(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x3)|value)
}
func (o *USB_OTG_HS_Type) GetDCFG_DSPD() uint32 {
	return volatile.LoadUint32(&o.DCFG.Reg) & 0x3
}
func (o *USB_OTG_HS_Type) SetDCFG_NZLSOHSK(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetDCFG_NZLSOHSK() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetDCFG_DAD(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x7f0)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDCFG_DAD() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x7f0) >> 4
}
func (o *USB_OTG_HS_Type) SetDCFG_PFIVL(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x1800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDCFG_PFIVL() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x1800) >> 11
}
func (o *USB_OTG_HS_Type) SetDCFG_PERSCHIVL(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x3000000)|value<<24)
}
func (o *USB_OTG_HS_Type) GetDCFG_PERSCHIVL() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x3000000) >> 24
}

// USB_OTG_HS.DCTL: OTG_HS device control register
func (o *USB_OTG_HS_Type) SetDCTL_RWUSIG(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDCTL_RWUSIG() uint32 {
	return volatile.LoadUint32(&o.DCTL.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDCTL_SDIS(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDCTL_SDIS() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDCTL_GINSTS(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetDCTL_GINSTS() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetDCTL_GONSTS(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDCTL_GONSTS() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDCTL_TCTL(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x70)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDCTL_TCTL() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x70) >> 4
}
func (o *USB_OTG_HS_Type) SetDCTL_SGINAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDCTL_SGINAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDCTL_CGINAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDCTL_CGINAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDCTL_SGONAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDCTL_SGONAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDCTL_CGONAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_HS_Type) GetDCTL_CGONAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x400) >> 10
}
func (o *USB_OTG_HS_Type) SetDCTL_POPRGDNE(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDCTL_POPRGDNE() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x800) >> 11
}

// USB_OTG_HS.DSTS: OTG_HS device status register
func (o *USB_OTG_HS_Type) SetDSTS_SUSPSTS(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDSTS_SUSPSTS() uint32 {
	return volatile.LoadUint32(&o.DSTS.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDSTS_ENUMSPD(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x6)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDSTS_ENUMSPD() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0x6) >> 1
}
func (o *USB_OTG_HS_Type) SetDSTS_EERR(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDSTS_EERR() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDSTS_FNSOF(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x3fff00)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDSTS_FNSOF() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0x3fff00) >> 8
}

// USB_OTG_HS.DIEPMSK: OTG_HS device IN endpoint common interrupt mask register
func (o *USB_OTG_HS_Type) SetDIEPMSK_XFRCM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_XFRCM() uint32 {
	return volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_EPDM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_EPDM() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_TOM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_TOM() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_ITTXFEMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_ITTXFEMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_INEPNMM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_INEPNMM() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x20) >> 5
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_INEPNEM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_INEPNEM() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_TXFURM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_TXFURM() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPMSK_BIM(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPMSK_BIM() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x200) >> 9
}

// USB_OTG_HS.DOEPMSK: OTG_HS device OUT endpoint common interrupt mask register
func (o *USB_OTG_HS_Type) SetDOEPMSK_XFRCM(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_XFRCM() uint32 {
	return volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPMSK_EPDM(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_EPDM() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPMSK_STUPM(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_STUPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPMSK_OTEPDM(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_OTEPDM() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPMSK_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPMSK_OPEM(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_OPEM() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDOEPMSK_BOIM(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDOEPMSK_BOIM() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x200) >> 9
}

// USB_OTG_HS.DAINT: OTG_HS device all endpoints interrupt register
func (o *USB_OTG_HS_Type) SetDAINT_IEPINT(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDAINT_IEPINT() uint32 {
	return volatile.LoadUint32(&o.DAINT.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetDAINT_OEPINT(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDAINT_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.DAINTMSK: OTG_HS all endpoints interrupt mask register
func (o *USB_OTG_HS_Type) SetDAINTMSK_IEPM(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDAINTMSK_IEPM() uint32 {
	return volatile.LoadUint32(&o.DAINTMSK.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetDAINTMSK_OEPM(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDAINTMSK_OEPM() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.DVBUSDIS: OTG_HS device VBUS discharge time register
func (o *USB_OTG_HS_Type) SetDVBUSDIS_VBUSDT(value uint32) {
	volatile.StoreUint32(&o.DVBUSDIS.Reg, volatile.LoadUint32(&o.DVBUSDIS.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDVBUSDIS_VBUSDT() uint32 {
	return volatile.LoadUint32(&o.DVBUSDIS.Reg) & 0xffff
}

// USB_OTG_HS.DVBUSPULSE: OTG_HS device VBUS pulsing time register
func (o *USB_OTG_HS_Type) SetDVBUSPULSE_DVBUSP(value uint32) {
	volatile.StoreUint32(&o.DVBUSPULSE.Reg, volatile.LoadUint32(&o.DVBUSPULSE.Reg)&^(0xfff)|value)
}
func (o *USB_OTG_HS_Type) GetDVBUSPULSE_DVBUSP() uint32 {
	return volatile.LoadUint32(&o.DVBUSPULSE.Reg) & 0xfff
}

// USB_OTG_HS.DTHRCTL: OTG_HS Device threshold control register
func (o *USB_OTG_HS_Type) SetDTHRCTL_NONISOTHREN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDTHRCTL_NONISOTHREN() uint32 {
	return volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDTHRCTL_ISOTHREN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDTHRCTL_ISOTHREN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDTHRCTL_TXTHRLEN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x7fc)|value<<2)
}
func (o *USB_OTG_HS_Type) GetDTHRCTL_TXTHRLEN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x7fc) >> 2
}
func (o *USB_OTG_HS_Type) SetDTHRCTL_RXTHREN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDTHRCTL_RXTHREN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDTHRCTL_RXTHRLEN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x3fe0000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDTHRCTL_RXTHRLEN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x3fe0000) >> 17
}
func (o *USB_OTG_HS_Type) SetDTHRCTL_ARPEN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDTHRCTL_ARPEN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x8000000) >> 27
}

// USB_OTG_HS.DIEPEMPMSK: OTG_HS device IN endpoint FIFO empty interrupt mask register
func (o *USB_OTG_HS_Type) SetDIEPEMPMSK_INEPTXFEM(value uint32) {
	volatile.StoreUint32(&o.DIEPEMPMSK.Reg, volatile.LoadUint32(&o.DIEPEMPMSK.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPEMPMSK_INEPTXFEM() uint32 {
	return volatile.LoadUint32(&o.DIEPEMPMSK.Reg) & 0xffff
}

// USB_OTG_HS.DEACHINT: OTG_HS device each endpoint interrupt register
func (o *USB_OTG_HS_Type) SetDEACHINT_IEP1INT(value uint32) {
	volatile.StoreUint32(&o.DEACHINT.Reg, volatile.LoadUint32(&o.DEACHINT.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDEACHINT_IEP1INT() uint32 {
	return (volatile.LoadUint32(&o.DEACHINT.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDEACHINT_OEP1INT(value uint32) {
	volatile.StoreUint32(&o.DEACHINT.Reg, volatile.LoadUint32(&o.DEACHINT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDEACHINT_OEP1INT() uint32 {
	return (volatile.LoadUint32(&o.DEACHINT.Reg) & 0x20000) >> 17
}

// USB_OTG_HS.DEACHINTMSK: OTG_HS device each endpoint interrupt register mask
func (o *USB_OTG_HS_Type) SetDEACHINTMSK_IEP1INTM(value uint32) {
	volatile.StoreUint32(&o.DEACHINTMSK.Reg, volatile.LoadUint32(&o.DEACHINTMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDEACHINTMSK_IEP1INTM() uint32 {
	return (volatile.LoadUint32(&o.DEACHINTMSK.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDEACHINTMSK_OEP1INTM(value uint32) {
	volatile.StoreUint32(&o.DEACHINTMSK.Reg, volatile.LoadUint32(&o.DEACHINTMSK.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDEACHINTMSK_OEP1INTM() uint32 {
	return (volatile.LoadUint32(&o.DEACHINTMSK.Reg) & 0x20000) >> 17
}

// USB_OTG_HS.DIEPCTL0: OTG device endpoint-0 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL0_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL0_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL0_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT0: OTG device endpoint-0 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT0_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT0_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT0_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DIEPTSIZ0: OTG_HS device IN endpoint 0 transfer size register
func (o *USB_OTG_HS_Type) SetDIEPTSIZ0_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ0.Reg, volatile.LoadUint32(&o.DIEPTSIZ0.Reg)&^(0x7f)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ0_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ0.Reg) & 0x7f
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ0_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ0.Reg, volatile.LoadUint32(&o.DIEPTSIZ0.Reg)&^(0x180000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ0_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ0.Reg) & 0x180000) >> 19
}

// USB_OTG_HS.DIEPDMA1: OTG_HS device endpoint-1 DMA address register
func (o *USB_OTG_HS_Type) SetDIEPDMA1(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA1.Reg, value)
}
func (o *USB_OTG_HS_Type) GetDIEPDMA1() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA1.Reg)
}

// USB_OTG_HS.DTXFSTS0: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS0_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS0.Reg, volatile.LoadUint32(&o.DTXFSTS0.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS0_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS0.Reg) & 0xffff
}

// USB_OTG_HS.DIEPCTL1: OTG device endpoint-1 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL1_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL1_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL1_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT1: OTG device endpoint-1 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT1_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT1_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT1_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DIEPTSIZ1: OTG_HS device endpoint transfer size register
func (o *USB_OTG_HS_Type) SetDIEPTSIZ1_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ1.Reg, volatile.LoadUint32(&o.DIEPTSIZ1.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ1_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ1.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ1_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ1.Reg, volatile.LoadUint32(&o.DIEPTSIZ1.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ1_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ1.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ1_MCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ1.Reg, volatile.LoadUint32(&o.DIEPTSIZ1.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ1_MCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ1.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DIEPDMA2: OTG_HS device endpoint-2 DMA address register
func (o *USB_OTG_HS_Type) SetDIEPDMA2(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA2.Reg, value)
}
func (o *USB_OTG_HS_Type) GetDIEPDMA2() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA2.Reg)
}

// USB_OTG_HS.DTXFSTS1: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS1_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS1.Reg, volatile.LoadUint32(&o.DTXFSTS1.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS1_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS1.Reg) & 0xffff
}

// USB_OTG_HS.DIEPCTL2: OTG device endpoint-2 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL2_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL2_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL2_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT2: OTG device endpoint-2 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT2_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT2_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT2_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DIEPTSIZ2: OTG_HS device endpoint transfer size register
func (o *USB_OTG_HS_Type) SetDIEPTSIZ2_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ2.Reg, volatile.LoadUint32(&o.DIEPTSIZ2.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ2_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ2.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ2_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ2.Reg, volatile.LoadUint32(&o.DIEPTSIZ2.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ2_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ2.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ2_MCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ2.Reg, volatile.LoadUint32(&o.DIEPTSIZ2.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ2_MCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ2.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DIEPDMA3: OTG_HS device endpoint-3 DMA address register
func (o *USB_OTG_HS_Type) SetDIEPDMA3(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA3.Reg, value)
}
func (o *USB_OTG_HS_Type) GetDIEPDMA3() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA3.Reg)
}

// USB_OTG_HS.DTXFSTS2: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS2_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS2.Reg, volatile.LoadUint32(&o.DTXFSTS2.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS2_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS2.Reg) & 0xffff
}

// USB_OTG_HS.DIEPCTL3: OTG device endpoint-3 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL3_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL3_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL3_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT3: OTG device endpoint-3 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT3_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT3_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT3_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DIEPTSIZ3: OTG_HS device endpoint transfer size register
func (o *USB_OTG_HS_Type) SetDIEPTSIZ3_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ3.Reg, volatile.LoadUint32(&o.DIEPTSIZ3.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ3_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ3.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ3_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ3.Reg, volatile.LoadUint32(&o.DIEPTSIZ3.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ3_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ3.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ3_MCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ3.Reg, volatile.LoadUint32(&o.DIEPTSIZ3.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ3_MCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ3.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DIEPDMA4: OTG_HS device endpoint-4 DMA address register
func (o *USB_OTG_HS_Type) SetDIEPDMA4(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA4.Reg, value)
}
func (o *USB_OTG_HS_Type) GetDIEPDMA4() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA4.Reg)
}

// USB_OTG_HS.DTXFSTS3: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS3_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS3.Reg, volatile.LoadUint32(&o.DTXFSTS3.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS3_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS3.Reg) & 0xffff
}

// USB_OTG_HS.DIEPCTL4: OTG device endpoint-4 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL4_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL4_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL4_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT4: OTG device endpoint-4 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT4_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT4_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT4_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DIEPTSIZ4: OTG_HS device endpoint transfer size register
func (o *USB_OTG_HS_Type) SetDIEPTSIZ4_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ4.Reg, volatile.LoadUint32(&o.DIEPTSIZ4.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ4_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ4.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ4_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ4.Reg, volatile.LoadUint32(&o.DIEPTSIZ4.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ4_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ4.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ4_MCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ4.Reg, volatile.LoadUint32(&o.DIEPTSIZ4.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ4_MCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ4.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DIEPDMA5: OTG_HS device endpoint-5 DMA address register
func (o *USB_OTG_HS_Type) SetDIEPDMA5(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA5.Reg, value)
}
func (o *USB_OTG_HS_Type) GetDIEPDMA5() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA5.Reg)
}

// USB_OTG_HS.DTXFSTS4: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS4_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS4.Reg, volatile.LoadUint32(&o.DTXFSTS4.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS4_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS4.Reg) & 0xffff
}

// USB_OTG_HS.DIEPCTL5: OTG device endpoint-5 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL5_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL5_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL5_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DTXFSTS6: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS6_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS6.Reg, volatile.LoadUint32(&o.DTXFSTS6.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS6_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS6.Reg) & 0xffff
}

// USB_OTG_HS.DIEPINT5: OTG device endpoint-5 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT5_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT5_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT5_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DTXFSTS7: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS7_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS7.Reg, volatile.LoadUint32(&o.DTXFSTS7.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS7_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS7.Reg) & 0xffff
}

// USB_OTG_HS.DIEPTSIZ5: OTG_HS device endpoint transfer size register
func (o *USB_OTG_HS_Type) SetDIEPTSIZ5_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ5.Reg, volatile.LoadUint32(&o.DIEPTSIZ5.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ5_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ5.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ5_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ5.Reg, volatile.LoadUint32(&o.DIEPTSIZ5.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ5_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ5.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDIEPTSIZ5_MCNT(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ5.Reg, volatile.LoadUint32(&o.DIEPTSIZ5.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPTSIZ5_MCNT() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ5.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DTXFSTS5: OTG_HS device IN endpoint transmit FIFO status register
func (o *USB_OTG_HS_Type) SetDTXFSTS5_INEPTFSAV(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS5.Reg, volatile.LoadUint32(&o.DTXFSTS5.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetDTXFSTS5_INEPTFSAV() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS5.Reg) & 0xffff
}

// USB_OTG_HS.DIEPCTL6: OTG device endpoint-6 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL6_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL6_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL6_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT6: OTG device endpoint-6 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT6_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT6_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT6_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DIEPCTL7: OTG device endpoint-7 control register
func (o *USB_OTG_HS_Type) SetDIEPCTL7_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_Stall(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_Stall() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x3c00000) >> 22
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_CNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_SNAK(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDIEPCTL7_EPENA(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL7.Reg, volatile.LoadUint32(&o.DIEPCTL7.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDIEPCTL7_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL7.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DIEPINT7: OTG device endpoint-7 interrupt register
func (o *USB_OTG_HS_Type) SetDIEPINT7_XFRC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_XFRC() uint32 {
	return volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_TOC(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_TOC() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_ITTXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_ITTXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_INEPNE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_INEPNE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_TXFE(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_TXFE() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_TXFIFOUDRN(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_TXFIFOUDRN() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_BNA(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_BNA() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_PKTDRPSTS(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_PKTDRPSTS() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_BERR(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_BERR() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetDIEPINT7_NAK(value uint32) {
	volatile.StoreUint32(&o.DIEPINT7.Reg, volatile.LoadUint32(&o.DIEPINT7.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetDIEPINT7_NAK() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT7.Reg) & 0x2000) >> 13
}

// USB_OTG_HS.DOEPCTL0: OTG_HS device control OUT endpoint 0 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL0_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x3)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x3
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL0_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL0_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT0: OTG_HS device endpoint-0 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT0_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT0_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT0_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT0_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT0_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT0_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT0_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT0_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT0_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT0_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT0_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT0_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ0: OTG_HS device endpoint-0 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ0_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ0.Reg, volatile.LoadUint32(&o.DOEPTSIZ0.Reg)&^(0x7f)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ0_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ0.Reg) & 0x7f
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ0_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ0.Reg, volatile.LoadUint32(&o.DOEPTSIZ0.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ0_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ0.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ0_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ0.Reg, volatile.LoadUint32(&o.DOEPTSIZ0.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ0_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ0.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL1: OTG device endpoint-1 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL1_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL1_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL1_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT1: OTG_HS device endpoint-1 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT1_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT1_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT1_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT1_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT1_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT1_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT1_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT1_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT1_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT1_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT1_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT1_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ1: OTG_HS device endpoint-1 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ1_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ1.Reg, volatile.LoadUint32(&o.DOEPTSIZ1.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ1_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ1.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ1_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ1.Reg, volatile.LoadUint32(&o.DOEPTSIZ1.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ1_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ1.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ1_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ1.Reg, volatile.LoadUint32(&o.DOEPTSIZ1.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ1_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ1.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL2: OTG device endpoint-2 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL2_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL2_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL2_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT2: OTG_HS device endpoint-2 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT2_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT2_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT2_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT2_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT2_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT2_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT2_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT2_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT2_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT2_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT2_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT2_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ2: OTG_HS device endpoint-2 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ2_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ2.Reg, volatile.LoadUint32(&o.DOEPTSIZ2.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ2_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ2.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ2_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ2.Reg, volatile.LoadUint32(&o.DOEPTSIZ2.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ2_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ2.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ2_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ2.Reg, volatile.LoadUint32(&o.DOEPTSIZ2.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ2_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ2.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL3: OTG device endpoint-3 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL3_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL3_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL3_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT3: OTG_HS device endpoint-3 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT3_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT3_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT3_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT3_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT3_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT3_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT3_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT3_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT3_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT3_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT3_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT3_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ3: OTG_HS device endpoint-3 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ3_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ3.Reg, volatile.LoadUint32(&o.DOEPTSIZ3.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ3_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ3.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ3_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ3.Reg, volatile.LoadUint32(&o.DOEPTSIZ3.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ3_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ3.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ3_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ3.Reg, volatile.LoadUint32(&o.DOEPTSIZ3.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ3_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ3.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL4: OTG device endpoint-4 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL4_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL4_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL4_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT4: OTG_HS device endpoint-4 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT4_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT4_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT4_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT4_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT4_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT4_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT4_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT4_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT4_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT4_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT4_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT4_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ4: OTG_HS device endpoint-4 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ4_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ4.Reg, volatile.LoadUint32(&o.DOEPTSIZ4.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ4_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ4.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ4_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ4.Reg, volatile.LoadUint32(&o.DOEPTSIZ4.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ4_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ4.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ4_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ4.Reg, volatile.LoadUint32(&o.DOEPTSIZ4.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ4_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ4.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL5: OTG device endpoint-5 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL5_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL5_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL5_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT5: OTG_HS device endpoint-5 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT5_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT5_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT5_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT5_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT5_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT5_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT5_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT5_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT5_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT5_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT5_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT5_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ5: OTG_HS device endpoint-5 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ5_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ5.Reg, volatile.LoadUint32(&o.DOEPTSIZ5.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ5_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ5.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ5_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ5.Reg, volatile.LoadUint32(&o.DOEPTSIZ5.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ5_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ5.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ5_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ5.Reg, volatile.LoadUint32(&o.DOEPTSIZ5.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ5_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ5.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL6: OTG device endpoint-6 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL6_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL6_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL6_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT6: OTG_HS device endpoint-6 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT6_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT6_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT6_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT6_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT6_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT6_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT6_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT6_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT6_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT6_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT6_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT6_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ6: OTG_HS device endpoint-6 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ6_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ6.Reg, volatile.LoadUint32(&o.DOEPTSIZ6.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ6_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ6.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ6_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ6.Reg, volatile.LoadUint32(&o.DOEPTSIZ6.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ6_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ6.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ6_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ6.Reg, volatile.LoadUint32(&o.DOEPTSIZ6.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ6_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ6.Reg) & 0x60000000) >> 29
}

// USB_OTG_HS.DOEPCTL7: OTG device endpoint-7 control register
func (o *USB_OTG_HS_Type) SetDOEPCTL7_MPSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x7ff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_MPSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x7ff
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_USBAEP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_USBAEP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_EONUM_DPID(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_EONUM_DPID() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_NAKSTS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_NAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_EPTYP(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_EPTYP() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0xc0000) >> 18
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_SNPM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_SNPM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_Stall(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_Stall() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_CNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_CNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_SNAK(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_SNAK() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_SD0PID_SEVNFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_SD0PID_SEVNFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_SODDFRM(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_SODDFRM() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_EPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_EPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetDOEPCTL7_EPENA(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL7.Reg, volatile.LoadUint32(&o.DOEPCTL7.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetDOEPCTL7_EPENA() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL7.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.DOEPINT7: OTG_HS device endpoint-7 interrupt register
func (o *USB_OTG_HS_Type) SetDOEPINT7_XFRC(value uint32) {
	volatile.StoreUint32(&o.DOEPINT7.Reg, volatile.LoadUint32(&o.DOEPINT7.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPINT7_XFRC() uint32 {
	return volatile.LoadUint32(&o.DOEPINT7.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetDOEPINT7_EPDISD(value uint32) {
	volatile.StoreUint32(&o.DOEPINT7.Reg, volatile.LoadUint32(&o.DOEPINT7.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetDOEPINT7_EPDISD() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT7.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetDOEPINT7_STUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT7.Reg, volatile.LoadUint32(&o.DOEPINT7.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetDOEPINT7_STUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT7.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetDOEPINT7_OTEPDIS(value uint32) {
	volatile.StoreUint32(&o.DOEPINT7.Reg, volatile.LoadUint32(&o.DOEPINT7.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetDOEPINT7_OTEPDIS() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT7.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetDOEPINT7_B2BSTUP(value uint32) {
	volatile.StoreUint32(&o.DOEPINT7.Reg, volatile.LoadUint32(&o.DOEPINT7.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetDOEPINT7_B2BSTUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT7.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetDOEPINT7_NYET(value uint32) {
	volatile.StoreUint32(&o.DOEPINT7.Reg, volatile.LoadUint32(&o.DOEPINT7.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetDOEPINT7_NYET() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT7.Reg) & 0x4000) >> 14
}

// USB_OTG_HS.DOEPTSIZ7: OTG_HS device endpoint-7 transfer size register
func (o *USB_OTG_HS_Type) SetDOEPTSIZ7_XFRSIZ(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ7.Reg, volatile.LoadUint32(&o.DOEPTSIZ7.Reg)&^(0x7ffff)|value)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ7_XFRSIZ() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ7.Reg) & 0x7ffff
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ7_PKTCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ7.Reg, volatile.LoadUint32(&o.DOEPTSIZ7.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ7_PKTCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ7.Reg) & 0x1ff80000) >> 19
}
func (o *USB_OTG_HS_Type) SetDOEPTSIZ7_RXDPID_STUPCNT(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ7.Reg, volatile.LoadUint32(&o.DOEPTSIZ7.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetDOEPTSIZ7_RXDPID_STUPCNT() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ7.Reg) & 0x60000000) >> 29
}

// OctoSPI IO Manager
type OctoSPII_O_Manager_Type struct {
	CR   volatile.Register32 // 0x0
	P1CR volatile.Register32 // 0x4
	P2CR volatile.Register32 // 0x8
}

// OctoSPII_O_Manager.CR: OctoSPI IO Manager Control Register
func (o *OctoSPII_O_Manager_Type) SetCR_MUXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *OctoSPII_O_Manager_Type) GetCR_MUXEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *OctoSPII_O_Manager_Type) SetCR_REQ2ACK_TIME(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff0000)|value<<16)
}
func (o *OctoSPII_O_Manager_Type) GetCR_REQ2ACK_TIME() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff0000) >> 16
}

// OctoSPII_O_Manager.P1CR: OctoSPI IO Manager Port 1 configuration register
func (o *OctoSPII_O_Manager_Type) SetP1CR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x1)|value)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.P1CR.Reg) & 0x1
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x2) >> 1
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_DQSEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x10)|value<<4)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_DQSEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x10) >> 4
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_DQSSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x20)|value<<5)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_DQSSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x20) >> 5
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_NCSEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x100)|value<<8)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_NCSEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x100) >> 8
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_NCSSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x200)|value<<9)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_NCSSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x200) >> 9
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_IOLEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x10000)|value<<16)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_IOLEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x10000) >> 16
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_IOLSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x60000)|value<<17)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_IOLSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x60000) >> 17
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_IOHEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x1000000)|value<<24)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_IOHEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x1000000) >> 24
}
func (o *OctoSPII_O_Manager_Type) SetP1CR_IOHSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x6000000)|value<<25)
}
func (o *OctoSPII_O_Manager_Type) GetP1CR_IOHSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x6000000) >> 25
}

// OctoSPII_O_Manager.P2CR: OctoSPI IO Manager Port 2 configuration register
func (o *OctoSPII_O_Manager_Type) SetP2CR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x1)|value)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.P2CR.Reg) & 0x1
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x2) >> 1
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_DQSEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x10)|value<<4)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_DQSEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x10) >> 4
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_DQSSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x20)|value<<5)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_DQSSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x20) >> 5
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_NCSEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x100)|value<<8)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_NCSEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x100) >> 8
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_NCSSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x200)|value<<9)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_NCSSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x200) >> 9
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_IOLEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x10000)|value<<16)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_IOLEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x10000) >> 16
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_IOLSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x60000)|value<<17)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_IOLSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x60000) >> 17
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_IOHEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x1000000)|value<<24)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_IOHEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x1000000) >> 24
}
func (o *OctoSPII_O_Manager_Type) SetP2CR_IOHSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x6000000)|value<<25)
}
func (o *OctoSPII_O_Manager_Type) GetP2CR_IOHSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x6000000) >> 25
}

// Processor features
type PF_Type struct {
	CLIDR  volatile.Register32 // 0x0
	CTR    volatile.Register32 // 0x4
	CCSIDR volatile.Register32 // 0x8
}

// PF.CLIDR: Cache Level ID register
func (o *PF_Type) SetCLIDR_CL1(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7)|value)
}
func (o *PF_Type) GetCLIDR_CL1() uint32 {
	return volatile.LoadUint32(&o.CLIDR.Reg) & 0x7
}
func (o *PF_Type) SetCLIDR_CL2(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38)|value<<3)
}
func (o *PF_Type) GetCLIDR_CL2() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38) >> 3
}
func (o *PF_Type) SetCLIDR_CL3(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x1c0)|value<<6)
}
func (o *PF_Type) GetCLIDR_CL3() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x1c0) >> 6
}
func (o *PF_Type) SetCLIDR_CL4(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0xe00)|value<<9)
}
func (o *PF_Type) GetCLIDR_CL4() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0xe00) >> 9
}
func (o *PF_Type) SetCLIDR_CL5(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000)|value<<12)
}
func (o *PF_Type) GetCLIDR_CL5() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000) >> 12
}
func (o *PF_Type) SetCLIDR_CL6(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000)|value<<15)
}
func (o *PF_Type) GetCLIDR_CL6() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000) >> 15
}
func (o *PF_Type) SetCLIDR_CL7(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x1c0000)|value<<18)
}
func (o *PF_Type) GetCLIDR_CL7() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x1c0000) >> 18
}
func (o *PF_Type) SetCLIDR_LoUIS(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0xe00000)|value<<21)
}
func (o *PF_Type) GetCLIDR_LoUIS() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0xe00000) >> 21
}
func (o *PF_Type) SetCLIDR_LoC(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000000)|value<<24)
}
func (o *PF_Type) GetCLIDR_LoC() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000000) >> 24
}
func (o *PF_Type) SetCLIDR_LoU(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000000)|value<<27)
}
func (o *PF_Type) GetCLIDR_LoU() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000000) >> 27
}

// PF.CTR: Cache Type register
func (o *PF_Type) SetCTR__IMINLINE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf)|value)
}
func (o *PF_Type) GetCTR__IMINLINE() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0xf
}
func (o *PF_Type) SetCTR_DMinLine(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf0000)|value<<16)
}
func (o *PF_Type) GetCTR_DMinLine() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf0000) >> 16
}
func (o *PF_Type) SetCTR_ERG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf00000)|value<<20)
}
func (o *PF_Type) GetCTR_ERG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf00000) >> 20
}
func (o *PF_Type) SetCTR_CWG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf000000)|value<<24)
}
func (o *PF_Type) GetCTR_CWG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf000000) >> 24
}
func (o *PF_Type) SetCTR_Format(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xe0000000)|value<<29)
}
func (o *PF_Type) GetCTR_Format() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xe0000000) >> 29
}

// PF.CCSIDR: Cache Size ID register
func (o *PF_Type) SetCCSIDR_LineSize(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x7)|value)
}
func (o *PF_Type) GetCCSIDR_LineSize() uint32 {
	return volatile.LoadUint32(&o.CCSIDR.Reg) & 0x7
}
func (o *PF_Type) SetCCSIDR_Associativity(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x1ff8)|value<<3)
}
func (o *PF_Type) GetCCSIDR_Associativity() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x1ff8) >> 3
}
func (o *PF_Type) SetCCSIDR_NumSets(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0xfffe000)|value<<13)
}
func (o *PF_Type) GetCCSIDR_NumSets() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0xfffe000) >> 13
}
func (o *PF_Type) SetCCSIDR_WA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PF_Type) GetCCSIDR_WA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x10000000) >> 28
}
func (o *PF_Type) SetCCSIDR_RA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PF_Type) GetCCSIDR_RA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x20000000) >> 29
}
func (o *PF_Type) SetCCSIDR_WB(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PF_Type) GetCCSIDR_WB() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x40000000) >> 30
}
func (o *PF_Type) SetCCSIDR_WT(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PF_Type) GetCCSIDR_WT() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x80000000) >> 31
}

// PWR
type PWR_Type struct {
	CR1     volatile.Register32 // 0x0
	CSR1    volatile.Register32 // 0x4
	CR2     volatile.Register32 // 0x8
	CR3     volatile.Register32 // 0xC
	CPUCR   volatile.Register32 // 0x10
	_       [4]byte
	D3CR    volatile.Register32 // 0x18
	_       [4]byte
	WKUPCR  volatile.Register32 // 0x20
	WKUPFR  volatile.Register32 // 0x24
	WKUPEPR volatile.Register32 // 0x28
}

// PWR.CR1: PWR control register 1
func (o *PWR_Type) SetCR1_LPDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR1_LPDS() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *PWR_Type) SetCR1_PVDE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR1_PVDE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR1_PLS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xe0)|value<<5)
}
func (o *PWR_Type) GetCR1_PLS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xe0) >> 5
}
func (o *PWR_Type) SetCR1_DBP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR1_DBP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR1_FLPS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR1_FLPS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR1_SVOS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc000)|value<<14)
}
func (o *PWR_Type) GetCR1_SVOS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc000) >> 14
}
func (o *PWR_Type) SetCR1_AVDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWR_Type) GetCR1_AVDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *PWR_Type) SetCR1_ALS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x60000)|value<<17)
}
func (o *PWR_Type) GetCR1_ALS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x60000) >> 17
}

// PWR.CSR1: PWR control status register 1
func (o *PWR_Type) SetCSR1_PVDO(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCSR1_PVDO() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCSR1_ACTVOSRDY(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetCSR1_ACTVOSRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetCSR1_ACTVOS(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0xc000)|value<<14)
}
func (o *PWR_Type) GetCSR1_ACTVOS() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0xc000) >> 14
}
func (o *PWR_Type) SetCSR1_AVDO(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWR_Type) GetCSR1_AVDO() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x10000) >> 16
}

// PWR.CR2: This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
func (o *PWR_Type) SetCR2_BREN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR2_BREN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *PWR_Type) SetCR2_MONEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR2_MONEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR2_BRRDY(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWR_Type) GetCR2_BRRDY() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *PWR_Type) SetCR2_VBATL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWR_Type) GetCR2_VBATL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100000) >> 20
}
func (o *PWR_Type) SetCR2_VBATH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWR_Type) GetCR2_VBATH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200000) >> 21
}
func (o *PWR_Type) SetCR2_TEMPL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWR_Type) GetCR2_TEMPL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400000) >> 22
}
func (o *PWR_Type) SetCR2_TEMPH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWR_Type) GetCR2_TEMPH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800000) >> 23
}

// PWR.CR3: Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
func (o *PWR_Type) SetCR3_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR3_BYPASS() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}
func (o *PWR_Type) SetCR3_LDOEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR3_LDOEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR3_SDEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCR3_SDEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCR3_VBE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR3_VBE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR3_VBRS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR3_VBRS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR3_USB33DEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PWR_Type) GetCR3_USB33DEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000000) >> 24
}
func (o *PWR_Type) SetCR3_USBREGEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000000)|value<<25)
}
func (o *PWR_Type) GetCR3_USBREGEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000000) >> 25
}
func (o *PWR_Type) SetCR3_USB33RDY(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000000)|value<<26)
}
func (o *PWR_Type) GetCR3_USB33RDY() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000000) >> 26
}
func (o *PWR_Type) SetCR3_SDEXTHP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR3_SDEXTHP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR3_SDLEVEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x30)|value<<4)
}
func (o *PWR_Type) GetCR3_SDLEVEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x30) >> 4
}
func (o *PWR_Type) SetCR3_SDEXTRDY(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10000)|value<<16)
}
func (o *PWR_Type) GetCR3_SDEXTRDY() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10000) >> 16
}

// PWR.CPUCR: This register allows controlling CPU1 power.
func (o *PWR_Type) SetCPUCR_PDDS_D1(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCPUCR_PDDS_D1() uint32 {
	return volatile.LoadUint32(&o.CPUCR.Reg) & 0x1
}
func (o *PWR_Type) SetCPUCR_PDDS_D2(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCPUCR_PDDS_D2() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCPUCR_PDDS_D3(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCPUCR_PDDS_D3() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCPUCR_STOPF(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCPUCR_STOPF() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCPUCR_SBF(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetCPUCR_SBF() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetCPUCR_SBF_D1(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetCPUCR_SBF_D1() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetCPUCR_SBF_D2(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCPUCR_SBF_D2() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCPUCR_CSSF(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCPUCR_CSSF() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCPUCR_RUN_D3(value uint32) {
	volatile.StoreUint32(&o.CPUCR.Reg, volatile.LoadUint32(&o.CPUCR.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetCPUCR_RUN_D3() uint32 {
	return (volatile.LoadUint32(&o.CPUCR.Reg) & 0x800) >> 11
}

// PWR.D3CR: This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
func (o *PWR_Type) SetD3CR_VOSRDY(value uint32) {
	volatile.StoreUint32(&o.D3CR.Reg, volatile.LoadUint32(&o.D3CR.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetD3CR_VOSRDY() uint32 {
	return (volatile.LoadUint32(&o.D3CR.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetD3CR_VOS(value uint32) {
	volatile.StoreUint32(&o.D3CR.Reg, volatile.LoadUint32(&o.D3CR.Reg)&^(0xc000)|value<<14)
}
func (o *PWR_Type) GetD3CR_VOS() uint32 {
	return (volatile.LoadUint32(&o.D3CR.Reg) & 0xc000) >> 14
}

// PWR.WKUPCR: reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
func (o *PWR_Type) SetWKUPCR_WKUPC1(value uint32) {
	volatile.StoreUint32(&o.WKUPCR.Reg, volatile.LoadUint32(&o.WKUPCR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetWKUPCR_WKUPC1() uint32 {
	return volatile.LoadUint32(&o.WKUPCR.Reg) & 0x1
}
func (o *PWR_Type) SetWKUPCR_WKUPC2(value uint32) {
	volatile.StoreUint32(&o.WKUPCR.Reg, volatile.LoadUint32(&o.WKUPCR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetWKUPCR_WKUPC2() uint32 {
	return (volatile.LoadUint32(&o.WKUPCR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetWKUPCR_WKUPC4(value uint32) {
	volatile.StoreUint32(&o.WKUPCR.Reg, volatile.LoadUint32(&o.WKUPCR.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetWKUPCR_WKUPC4() uint32 {
	return (volatile.LoadUint32(&o.WKUPCR.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetWKUPCR_WKUPC6(value uint32) {
	volatile.StoreUint32(&o.WKUPCR.Reg, volatile.LoadUint32(&o.WKUPCR.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetWKUPCR_WKUPC6() uint32 {
	return (volatile.LoadUint32(&o.WKUPCR.Reg) & 0x20) >> 5
}

// PWR.WKUPFR: reset only by system reset, not reset by wakeup from Standby mode
func (o *PWR_Type) SetWKUPFR_WKUPF1(value uint32) {
	volatile.StoreUint32(&o.WKUPFR.Reg, volatile.LoadUint32(&o.WKUPFR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetWKUPFR_WKUPF1() uint32 {
	return volatile.LoadUint32(&o.WKUPFR.Reg) & 0x1
}
func (o *PWR_Type) SetWKUPFR_WKUPF2(value uint32) {
	volatile.StoreUint32(&o.WKUPFR.Reg, volatile.LoadUint32(&o.WKUPFR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetWKUPFR_WKUPF2() uint32 {
	return (volatile.LoadUint32(&o.WKUPFR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetWKUPFR_WKUPF4(value uint32) {
	volatile.StoreUint32(&o.WKUPFR.Reg, volatile.LoadUint32(&o.WKUPFR.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetWKUPFR_WKUPF4() uint32 {
	return (volatile.LoadUint32(&o.WKUPFR.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetWKUPFR_WKUPF6(value uint32) {
	volatile.StoreUint32(&o.WKUPFR.Reg, volatile.LoadUint32(&o.WKUPFR.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetWKUPFR_WKUPF6() uint32 {
	return (volatile.LoadUint32(&o.WKUPFR.Reg) & 0x20) >> 5
}

// PWR.WKUPEPR: Reset only by system reset, not reset by wakeup from Standby mode
func (o *PWR_Type) SetWKUPEPR_WKUPEN1(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetWKUPEPR_WKUPEN1() uint32 {
	return volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x1
}
func (o *PWR_Type) SetWKUPEPR_WKUPEN2(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetWKUPEPR_WKUPEN2() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetWKUPEPR_WKUPEN3(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetWKUPEPR_WKUPEN3() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetWKUPEPR_WKUPEN4(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetWKUPEPR_WKUPEN4() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetWKUPEPR_WKUPEN5(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetWKUPEPR_WKUPEN5() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetWKUPEPR_WKUPEN6(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetWKUPEPR_WKUPEN6() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetWKUPEPR_WKUPP1(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetWKUPEPR_WKUPP1() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetWKUPEPR_WKUPP2(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetWKUPEPR_WKUPP2() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetWKUPEPR_WKUPP3(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetWKUPEPR_WKUPP3() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetWKUPEPR_WKUPP4(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetWKUPEPR_WKUPP4() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetWKUPEPR_WKUPP5(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetWKUPEPR_WKUPP5() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetWKUPEPR_WKUPP6(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetWKUPEPR_WKUPP6() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetWKUPEPR_WKUPPUPD1(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x30000)|value<<16)
}
func (o *PWR_Type) GetWKUPEPR_WKUPPUPD1() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x30000) >> 16
}
func (o *PWR_Type) SetWKUPEPR_WKUPPUPD2(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0xc0000)|value<<18)
}
func (o *PWR_Type) GetWKUPEPR_WKUPPUPD2() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0xc0000) >> 18
}
func (o *PWR_Type) SetWKUPEPR_WKUPPUPD3(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x300000)|value<<20)
}
func (o *PWR_Type) GetWKUPEPR_WKUPPUPD3() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x300000) >> 20
}
func (o *PWR_Type) SetWKUPEPR_WKUPPUPD4(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0xc00000)|value<<22)
}
func (o *PWR_Type) GetWKUPEPR_WKUPPUPD4() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0xc00000) >> 22
}
func (o *PWR_Type) SetWKUPEPR_WKUPPUPD5(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0x3000000)|value<<24)
}
func (o *PWR_Type) GetWKUPEPR_WKUPPUPD5() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0x3000000) >> 24
}
func (o *PWR_Type) SetWKUPEPR_WKUPPUPD6(value uint32) {
	volatile.StoreUint32(&o.WKUPEPR.Reg, volatile.LoadUint32(&o.WKUPEPR.Reg)&^(0xc000000)|value<<26)
}
func (o *PWR_Type) GetWKUPEPR_WKUPPUPD6() uint32 {
	return (volatile.LoadUint32(&o.WKUPEPR.Reg) & 0xc000000) >> 26
}

// ECC controller is associated to each RAM area
type RAMECC_Type struct {
	IER    volatile.Register32 // 0x0
	_      [28]byte
	M1CR   volatile.Register32 // 0x20
	M1SR   volatile.Register32 // 0x24
	M1FAR  volatile.Register32 // 0x28
	M1FDRL volatile.Register32 // 0x2C
	M1FDRH volatile.Register32 // 0x30
	M1FECR volatile.Register32 // 0x34
	_      [8]byte
	M2CR   volatile.Register32 // 0x40
	M2SR   volatile.Register32 // 0x44
	M2FAR  volatile.Register32 // 0x48
	M2FDRL volatile.Register32 // 0x4C
	M2FDRH volatile.Register32 // 0x50
	_      [4]byte
	M2FECR volatile.Register32 // 0x58
	_      [4]byte
	M3CR   volatile.Register32 // 0x60
	M3SR   volatile.Register32 // 0x64
	M3FAR  volatile.Register32 // 0x68
	M3FDRL volatile.Register32 // 0x6C
	M3FDRH volatile.Register32 // 0x70
	_      [8]byte
	M3FECR volatile.Register32 // 0x7C
	M4CR   volatile.Register32 // 0x80
	M4SR   volatile.Register32 // 0x84
	M4FAR  volatile.Register32 // 0x88
	M4FDRL volatile.Register32 // 0x8C
	M4FDRH volatile.Register32 // 0x90
	_      [12]byte
	M5CR   volatile.Register32 // 0xA0
	M5SR   volatile.Register32 // 0xA4
	M5FAR  volatile.Register32 // 0xA8
	M5FDRL volatile.Register32 // 0xAC
	M5FDRH volatile.Register32 // 0xB0
	M5FECR volatile.Register32 // 0xB4
}

// RAMECC.IER: RAMECC interrupt enable register
func (o *RAMECC_Type) SetIER_GIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetIER_GIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *RAMECC_Type) SetIER_GECCSEIE_(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetIER_GECCSEIE_() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *RAMECC_Type) SetIER_GECCDEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetIER_GECCDEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *RAMECC_Type) SetIER_GECCDEBWIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *RAMECC_Type) GetIER_GECCDEBWIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}

// RAMECC.M1CR: RAMECC monitor x configuration register
func (o *RAMECC_Type) SetM1CR_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.M1CR.Reg, volatile.LoadUint32(&o.M1CR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM1CR_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.M1CR.Reg) & 0x4) >> 2
}
func (o *RAMECC_Type) SetM1CR_ECCDEIE(value uint32) {
	volatile.StoreUint32(&o.M1CR.Reg, volatile.LoadUint32(&o.M1CR.Reg)&^(0x8)|value<<3)
}
func (o *RAMECC_Type) GetM1CR_ECCDEIE() uint32 {
	return (volatile.LoadUint32(&o.M1CR.Reg) & 0x8) >> 3
}
func (o *RAMECC_Type) SetM1CR_ECCDEBWIE(value uint32) {
	volatile.StoreUint32(&o.M1CR.Reg, volatile.LoadUint32(&o.M1CR.Reg)&^(0x10)|value<<4)
}
func (o *RAMECC_Type) GetM1CR_ECCDEBWIE() uint32 {
	return (volatile.LoadUint32(&o.M1CR.Reg) & 0x10) >> 4
}
func (o *RAMECC_Type) SetM1CR_ECCELEN(value uint32) {
	volatile.StoreUint32(&o.M1CR.Reg, volatile.LoadUint32(&o.M1CR.Reg)&^(0x20)|value<<5)
}
func (o *RAMECC_Type) GetM1CR_ECCELEN() uint32 {
	return (volatile.LoadUint32(&o.M1CR.Reg) & 0x20) >> 5
}

// RAMECC.M1SR: RAMECC monitor x status register
func (o *RAMECC_Type) SetM1SR_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.M1SR.Reg, volatile.LoadUint32(&o.M1SR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM1SR_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.M1SR.Reg) & 0x4) >> 2
}
func (o *RAMECC_Type) SetM1SR_ECCDEIE(value uint32) {
	volatile.StoreUint32(&o.M1SR.Reg, volatile.LoadUint32(&o.M1SR.Reg)&^(0x8)|value<<3)
}
func (o *RAMECC_Type) GetM1SR_ECCDEIE() uint32 {
	return (volatile.LoadUint32(&o.M1SR.Reg) & 0x8) >> 3
}
func (o *RAMECC_Type) SetM1SR_ECCDEBWIE(value uint32) {
	volatile.StoreUint32(&o.M1SR.Reg, volatile.LoadUint32(&o.M1SR.Reg)&^(0x10)|value<<4)
}
func (o *RAMECC_Type) GetM1SR_ECCDEBWIE() uint32 {
	return (volatile.LoadUint32(&o.M1SR.Reg) & 0x10) >> 4
}
func (o *RAMECC_Type) SetM1SR_ECCELEN(value uint32) {
	volatile.StoreUint32(&o.M1SR.Reg, volatile.LoadUint32(&o.M1SR.Reg)&^(0x20)|value<<5)
}
func (o *RAMECC_Type) GetM1SR_ECCELEN() uint32 {
	return (volatile.LoadUint32(&o.M1SR.Reg) & 0x20) >> 5
}

// RAMECC.M1FAR: RAMECC monitor x failing address register
func (o *RAMECC_Type) SetM1FAR_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.M1FAR.Reg, volatile.LoadUint32(&o.M1FAR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM1FAR_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.M1FAR.Reg) & 0x4) >> 2
}
func (o *RAMECC_Type) SetM1FAR_ECCDEIE(value uint32) {
	volatile.StoreUint32(&o.M1FAR.Reg, volatile.LoadUint32(&o.M1FAR.Reg)&^(0x8)|value<<3)
}
func (o *RAMECC_Type) GetM1FAR_ECCDEIE() uint32 {
	return (volatile.LoadUint32(&o.M1FAR.Reg) & 0x8) >> 3
}
func (o *RAMECC_Type) SetM1FAR_ECCDEBWIE(value uint32) {
	volatile.StoreUint32(&o.M1FAR.Reg, volatile.LoadUint32(&o.M1FAR.Reg)&^(0x10)|value<<4)
}
func (o *RAMECC_Type) GetM1FAR_ECCDEBWIE() uint32 {
	return (volatile.LoadUint32(&o.M1FAR.Reg) & 0x10) >> 4
}
func (o *RAMECC_Type) SetM1FAR_ECCELEN(value uint32) {
	volatile.StoreUint32(&o.M1FAR.Reg, volatile.LoadUint32(&o.M1FAR.Reg)&^(0x20)|value<<5)
}
func (o *RAMECC_Type) GetM1FAR_ECCELEN() uint32 {
	return (volatile.LoadUint32(&o.M1FAR.Reg) & 0x20) >> 5
}

// RAMECC.M1FDRL: RAMECC monitor x failing data low register
func (o *RAMECC_Type) SetM1FDRL_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.M1FDRL.Reg, volatile.LoadUint32(&o.M1FDRL.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM1FDRL_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.M1FDRL.Reg) & 0x4) >> 2
}
func (o *RAMECC_Type) SetM1FDRL_ECCDEIE(value uint32) {
	volatile.StoreUint32(&o.M1FDRL.Reg, volatile.LoadUint32(&o.M1FDRL.Reg)&^(0x8)|value<<3)
}
func (o *RAMECC_Type) GetM1FDRL_ECCDEIE() uint32 {
	return (volatile.LoadUint32(&o.M1FDRL.Reg) & 0x8) >> 3
}
func (o *RAMECC_Type) SetM1FDRL_ECCDEBWIE(value uint32) {
	volatile.StoreUint32(&o.M1FDRL.Reg, volatile.LoadUint32(&o.M1FDRL.Reg)&^(0x10)|value<<4)
}
func (o *RAMECC_Type) GetM1FDRL_ECCDEBWIE() uint32 {
	return (volatile.LoadUint32(&o.M1FDRL.Reg) & 0x10) >> 4
}
func (o *RAMECC_Type) SetM1FDRL_ECCELEN(value uint32) {
	volatile.StoreUint32(&o.M1FDRL.Reg, volatile.LoadUint32(&o.M1FDRL.Reg)&^(0x20)|value<<5)
}
func (o *RAMECC_Type) GetM1FDRL_ECCELEN() uint32 {
	return (volatile.LoadUint32(&o.M1FDRL.Reg) & 0x20) >> 5
}

// RAMECC.M1FDRH: RAMECC monitor x failing data high register
func (o *RAMECC_Type) SetM1FDRH_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.M1FDRH.Reg, volatile.LoadUint32(&o.M1FDRH.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM1FDRH_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.M1FDRH.Reg) & 0x4) >> 2
}
func (o *RAMECC_Type) SetM1FDRH_ECCDEIE(value uint32) {
	volatile.StoreUint32(&o.M1FDRH.Reg, volatile.LoadUint32(&o.M1FDRH.Reg)&^(0x8)|value<<3)
}
func (o *RAMECC_Type) GetM1FDRH_ECCDEIE() uint32 {
	return (volatile.LoadUint32(&o.M1FDRH.Reg) & 0x8) >> 3
}
func (o *RAMECC_Type) SetM1FDRH_ECCDEBWIE(value uint32) {
	volatile.StoreUint32(&o.M1FDRH.Reg, volatile.LoadUint32(&o.M1FDRH.Reg)&^(0x10)|value<<4)
}
func (o *RAMECC_Type) GetM1FDRH_ECCDEBWIE() uint32 {
	return (volatile.LoadUint32(&o.M1FDRH.Reg) & 0x10) >> 4
}
func (o *RAMECC_Type) SetM1FDRH_ECCELEN(value uint32) {
	volatile.StoreUint32(&o.M1FDRH.Reg, volatile.LoadUint32(&o.M1FDRH.Reg)&^(0x20)|value<<5)
}
func (o *RAMECC_Type) GetM1FDRH_ECCELEN() uint32 {
	return (volatile.LoadUint32(&o.M1FDRH.Reg) & 0x20) >> 5
}

// RAMECC.M1FECR: RAMECC monitor x failing ECC error code register
func (o *RAMECC_Type) SetM1FECR_SEDCF(value uint32) {
	volatile.StoreUint32(&o.M1FECR.Reg, volatile.LoadUint32(&o.M1FECR.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetM1FECR_SEDCF() uint32 {
	return volatile.LoadUint32(&o.M1FECR.Reg) & 0x1
}
func (o *RAMECC_Type) SetM1FECR_DEDF(value uint32) {
	volatile.StoreUint32(&o.M1FECR.Reg, volatile.LoadUint32(&o.M1FECR.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetM1FECR_DEDF() uint32 {
	return (volatile.LoadUint32(&o.M1FECR.Reg) & 0x2) >> 1
}
func (o *RAMECC_Type) SetM1FECR_DEBWDF(value uint32) {
	volatile.StoreUint32(&o.M1FECR.Reg, volatile.LoadUint32(&o.M1FECR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM1FECR_DEBWDF() uint32 {
	return (volatile.LoadUint32(&o.M1FECR.Reg) & 0x4) >> 2
}

// RAMECC.M2CR: RAMECC monitor x configuration register
func (o *RAMECC_Type) SetM2CR_SEDCF(value uint32) {
	volatile.StoreUint32(&o.M2CR.Reg, volatile.LoadUint32(&o.M2CR.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetM2CR_SEDCF() uint32 {
	return volatile.LoadUint32(&o.M2CR.Reg) & 0x1
}
func (o *RAMECC_Type) SetM2CR_DEDF(value uint32) {
	volatile.StoreUint32(&o.M2CR.Reg, volatile.LoadUint32(&o.M2CR.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetM2CR_DEDF() uint32 {
	return (volatile.LoadUint32(&o.M2CR.Reg) & 0x2) >> 1
}
func (o *RAMECC_Type) SetM2CR_DEBWDF(value uint32) {
	volatile.StoreUint32(&o.M2CR.Reg, volatile.LoadUint32(&o.M2CR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM2CR_DEBWDF() uint32 {
	return (volatile.LoadUint32(&o.M2CR.Reg) & 0x4) >> 2
}

// RAMECC.M2SR: RAMECC monitor x status register
func (o *RAMECC_Type) SetM2SR_SEDCF(value uint32) {
	volatile.StoreUint32(&o.M2SR.Reg, volatile.LoadUint32(&o.M2SR.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetM2SR_SEDCF() uint32 {
	return volatile.LoadUint32(&o.M2SR.Reg) & 0x1
}
func (o *RAMECC_Type) SetM2SR_DEDF(value uint32) {
	volatile.StoreUint32(&o.M2SR.Reg, volatile.LoadUint32(&o.M2SR.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetM2SR_DEDF() uint32 {
	return (volatile.LoadUint32(&o.M2SR.Reg) & 0x2) >> 1
}
func (o *RAMECC_Type) SetM2SR_DEBWDF(value uint32) {
	volatile.StoreUint32(&o.M2SR.Reg, volatile.LoadUint32(&o.M2SR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM2SR_DEBWDF() uint32 {
	return (volatile.LoadUint32(&o.M2SR.Reg) & 0x4) >> 2
}

// RAMECC.M2FAR: RAMECC monitor x failing address register
func (o *RAMECC_Type) SetM2FAR_SEDCF(value uint32) {
	volatile.StoreUint32(&o.M2FAR.Reg, volatile.LoadUint32(&o.M2FAR.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetM2FAR_SEDCF() uint32 {
	return volatile.LoadUint32(&o.M2FAR.Reg) & 0x1
}
func (o *RAMECC_Type) SetM2FAR_DEDF(value uint32) {
	volatile.StoreUint32(&o.M2FAR.Reg, volatile.LoadUint32(&o.M2FAR.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetM2FAR_DEDF() uint32 {
	return (volatile.LoadUint32(&o.M2FAR.Reg) & 0x2) >> 1
}
func (o *RAMECC_Type) SetM2FAR_DEBWDF(value uint32) {
	volatile.StoreUint32(&o.M2FAR.Reg, volatile.LoadUint32(&o.M2FAR.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM2FAR_DEBWDF() uint32 {
	return (volatile.LoadUint32(&o.M2FAR.Reg) & 0x4) >> 2
}

// RAMECC.M2FDRL: RAMECC monitor x failing data low register
func (o *RAMECC_Type) SetM2FDRL_SEDCF(value uint32) {
	volatile.StoreUint32(&o.M2FDRL.Reg, volatile.LoadUint32(&o.M2FDRL.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetM2FDRL_SEDCF() uint32 {
	return volatile.LoadUint32(&o.M2FDRL.Reg) & 0x1
}
func (o *RAMECC_Type) SetM2FDRL_DEDF(value uint32) {
	volatile.StoreUint32(&o.M2FDRL.Reg, volatile.LoadUint32(&o.M2FDRL.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetM2FDRL_DEDF() uint32 {
	return (volatile.LoadUint32(&o.M2FDRL.Reg) & 0x2) >> 1
}
func (o *RAMECC_Type) SetM2FDRL_DEBWDF(value uint32) {
	volatile.StoreUint32(&o.M2FDRL.Reg, volatile.LoadUint32(&o.M2FDRL.Reg)&^(0x4)|value<<2)
}
func (o *RAMECC_Type) GetM2FDRL_DEBWDF() uint32 {
	return (volatile.LoadUint32(&o.M2FDRL.Reg) & 0x4) >> 2
}

// RAMECC.M2FDRH: RAMECC monitor x failing data high register
func (o *RAMECC_Type) SetM2FDRH(value uint32) {
	volatile.StoreUint32(&o.M2FDRH.Reg, value)
}
func (o *RAMECC_Type) GetM2FDRH() uint32 {
	return volatile.LoadUint32(&o.M2FDRH.Reg)
}

// RAMECC.M2FECR: RAMECC monitor x failing ECC error code register
func (o *RAMECC_Type) SetM2FECR(value uint32) {
	volatile.StoreUint32(&o.M2FECR.Reg, value)
}
func (o *RAMECC_Type) GetM2FECR() uint32 {
	return volatile.LoadUint32(&o.M2FECR.Reg)
}

// RAMECC.M3CR: RAMECC monitor x configuration register
func (o *RAMECC_Type) SetM3CR(value uint32) {
	volatile.StoreUint32(&o.M3CR.Reg, value)
}
func (o *RAMECC_Type) GetM3CR() uint32 {
	return volatile.LoadUint32(&o.M3CR.Reg)
}

// RAMECC.M3SR: RAMECC monitor x status register
func (o *RAMECC_Type) SetM3SR(value uint32) {
	volatile.StoreUint32(&o.M3SR.Reg, value)
}
func (o *RAMECC_Type) GetM3SR() uint32 {
	return volatile.LoadUint32(&o.M3SR.Reg)
}

// RAMECC.M3FAR: RAMECC monitor x failing address register
func (o *RAMECC_Type) SetM3FAR(value uint32) {
	volatile.StoreUint32(&o.M3FAR.Reg, value)
}
func (o *RAMECC_Type) GetM3FAR() uint32 {
	return volatile.LoadUint32(&o.M3FAR.Reg)
}

// RAMECC.M3FDRL: RAMECC monitor x failing data low register
func (o *RAMECC_Type) SetM3FDRL(value uint32) {
	volatile.StoreUint32(&o.M3FDRL.Reg, value)
}
func (o *RAMECC_Type) GetM3FDRL() uint32 {
	return volatile.LoadUint32(&o.M3FDRL.Reg)
}

// RAMECC.M3FDRH: RAMECC monitor x failing data high register
func (o *RAMECC_Type) SetM3FDRH(value uint32) {
	volatile.StoreUint32(&o.M3FDRH.Reg, value)
}
func (o *RAMECC_Type) GetM3FDRH() uint32 {
	return volatile.LoadUint32(&o.M3FDRH.Reg)
}

// RAMECC.M3FECR: RAMECC monitor x failing ECC error code register
func (o *RAMECC_Type) SetM3FECR(value uint32) {
	volatile.StoreUint32(&o.M3FECR.Reg, value)
}
func (o *RAMECC_Type) GetM3FECR() uint32 {
	return volatile.LoadUint32(&o.M3FECR.Reg)
}

// RAMECC.M4CR: RAMECC monitor x configuration register
func (o *RAMECC_Type) SetM4CR(value uint32) {
	volatile.StoreUint32(&o.M4CR.Reg, value)
}
func (o *RAMECC_Type) GetM4CR() uint32 {
	return volatile.LoadUint32(&o.M4CR.Reg)
}

// RAMECC.M4SR: RAMECC monitor x status register
func (o *RAMECC_Type) SetM4SR(value uint32) {
	volatile.StoreUint32(&o.M4SR.Reg, value)
}
func (o *RAMECC_Type) GetM4SR() uint32 {
	return volatile.LoadUint32(&o.M4SR.Reg)
}

// RAMECC.M4FAR: RAMECC monitor x failing address register
func (o *RAMECC_Type) SetM4FAR(value uint32) {
	volatile.StoreUint32(&o.M4FAR.Reg, value)
}
func (o *RAMECC_Type) GetM4FAR() uint32 {
	return volatile.LoadUint32(&o.M4FAR.Reg)
}

// RAMECC.M4FDRL: RAMECC monitor x failing data low register
func (o *RAMECC_Type) SetM4FDRL(value uint32) {
	volatile.StoreUint32(&o.M4FDRL.Reg, value)
}
func (o *RAMECC_Type) GetM4FDRL() uint32 {
	return volatile.LoadUint32(&o.M4FDRL.Reg)
}

// RAMECC.M4FDRH: RAMECC monitor x failing data high register
func (o *RAMECC_Type) SetM4FDRH(value uint32) {
	volatile.StoreUint32(&o.M4FDRH.Reg, value)
}
func (o *RAMECC_Type) GetM4FDRH() uint32 {
	return volatile.LoadUint32(&o.M4FDRH.Reg)
}

// RAMECC.M5CR: RAMECC monitor x configuration register
func (o *RAMECC_Type) SetM5CR(value uint32) {
	volatile.StoreUint32(&o.M5CR.Reg, value)
}
func (o *RAMECC_Type) GetM5CR() uint32 {
	return volatile.LoadUint32(&o.M5CR.Reg)
}

// RAMECC.M5SR: RAMECC monitor x status register
func (o *RAMECC_Type) SetM5SR(value uint32) {
	volatile.StoreUint32(&o.M5SR.Reg, value)
}
func (o *RAMECC_Type) GetM5SR() uint32 {
	return volatile.LoadUint32(&o.M5SR.Reg)
}

// RAMECC.M5FAR: RAMECC monitor x failing address register
func (o *RAMECC_Type) SetM5FAR(value uint32) {
	volatile.StoreUint32(&o.M5FAR.Reg, value)
}
func (o *RAMECC_Type) GetM5FAR() uint32 {
	return volatile.LoadUint32(&o.M5FAR.Reg)
}

// RAMECC.M5FDRL: RAMECC monitor x failing data low register
func (o *RAMECC_Type) SetM5FDRL(value uint32) {
	volatile.StoreUint32(&o.M5FDRL.Reg, value)
}
func (o *RAMECC_Type) GetM5FDRL() uint32 {
	return volatile.LoadUint32(&o.M5FDRL.Reg)
}

// RAMECC.M5FDRH: RAMECC monitor x failing data high register
func (o *RAMECC_Type) SetM5FDRH(value uint32) {
	volatile.StoreUint32(&o.M5FDRH.Reg, value)
}
func (o *RAMECC_Type) GetM5FDRH() uint32 {
	return volatile.LoadUint32(&o.M5FDRH.Reg)
}

// RAMECC.M5FECR: RAMECC monitor x failing ECC error code register
func (o *RAMECC_Type) SetM5FECR(value uint32) {
	volatile.StoreUint32(&o.M5FECR.Reg, value)
}
func (o *RAMECC_Type) GetM5FECR() uint32 {
	return volatile.LoadUint32(&o.M5FECR.Reg)
}

// Reset and clock control
type RCC_Type struct {
	CR            volatile.Register32 // 0x0
	HSICFGR       volatile.Register32 // 0x4
	CRRCR         volatile.Register32 // 0x8
	CSICFGR       volatile.Register32 // 0xC
	CFGR          volatile.Register32 // 0x10
	_             [4]byte
	D1CFGR        volatile.Register32 // 0x18
	D2CFGR        volatile.Register32 // 0x1C
	D3CFGR        volatile.Register32 // 0x20
	_             [4]byte
	PLLCKSELR     volatile.Register32 // 0x28
	PLLCFGR       volatile.Register32 // 0x2C
	PLL1DIVR      volatile.Register32 // 0x30
	PLL1FRACR     volatile.Register32 // 0x34
	PLL2DIVR      volatile.Register32 // 0x38
	PLL2FRACR     volatile.Register32 // 0x3C
	PLL3DIVR      volatile.Register32 // 0x40
	PLL3FRACR     volatile.Register32 // 0x44
	_             [4]byte
	D1CCIPR       volatile.Register32 // 0x4C
	D2CCIP1R      volatile.Register32 // 0x50
	D2CCIP2R      volatile.Register32 // 0x54
	D3CCIPR       volatile.Register32 // 0x58
	_             [4]byte
	CIER          volatile.Register32 // 0x60
	CIFR          volatile.Register32 // 0x64
	CICR          volatile.Register32 // 0x68
	_             [4]byte
	BDCR          volatile.Register32 // 0x70
	CSR           volatile.Register32 // 0x74
	_             [4]byte
	AHB3RSTR      volatile.Register32 // 0x7C
	AHB1RSTR      volatile.Register32 // 0x80
	AHB2RSTR      volatile.Register32 // 0x84
	AHB4RSTR      volatile.Register32 // 0x88
	APB3RSTR      volatile.Register32 // 0x8C
	APB1LRSTR     volatile.Register32 // 0x90
	APB1HRSTR     volatile.Register32 // 0x94
	APB2RSTR      volatile.Register32 // 0x98
	APB4RSTR      volatile.Register32 // 0x9C
	GCR           volatile.Register32 // 0xA0
	_             [4]byte
	D3AMR         volatile.Register32 // 0xA8
	_             [36]byte
	RSR           volatile.Register32 // 0xD0
	AHB3ENR       volatile.Register32 // 0xD4
	AHB1ENR       volatile.Register32 // 0xD8
	AHB2ENR       volatile.Register32 // 0xDC
	AHB4ENR       volatile.Register32 // 0xE0
	APB3ENR       volatile.Register32 // 0xE4
	APB1LENR      volatile.Register32 // 0xE8
	APB1HENR      volatile.Register32 // 0xEC
	APB2ENR       volatile.Register32 // 0xF0
	APB4ENR       volatile.Register32 // 0xF4
	_             [4]byte
	AHB3LPENR     volatile.Register32 // 0xFC
	AHB1LPENR     volatile.Register32 // 0x100
	AHB2LPENR     volatile.Register32 // 0x104
	AHB4LPENR     volatile.Register32 // 0x108
	APB3LPENR     volatile.Register32 // 0x10C
	APB1LLPENR    volatile.Register32 // 0x110
	APB1HLPENR    volatile.Register32 // 0x114
	APB2LPENR     volatile.Register32 // 0x118
	APB4LPENR     volatile.Register32 // 0x11C
	_             [16]byte
	C1_RSR        volatile.Register32 // 0x130
	C1_AHB3ENR    volatile.Register32 // 0x134
	C1_AHB1ENR    volatile.Register32 // 0x138
	C1_AHB2ENR    volatile.Register32 // 0x13C
	C1_AHB4ENR    volatile.Register32 // 0x140
	C1_APB3ENR    volatile.Register32 // 0x144
	C1_APB1LENR   volatile.Register32 // 0x148
	C1_APB1HENR   volatile.Register32 // 0x14C
	C1_APB2ENR    volatile.Register32 // 0x150
	C1_APB4ENR    volatile.Register32 // 0x154
	_             [4]byte
	C1_AHB3LPENR  volatile.Register32 // 0x15C
	C1_AHB1LPENR  volatile.Register32 // 0x160
	C1_AHB2LPENR  volatile.Register32 // 0x164
	C1_AHB4LPENR  volatile.Register32 // 0x168
	C1_APB3LPENR  volatile.Register32 // 0x16C
	C1_APB1LLPENR volatile.Register32 // 0x170
	C1_APB1HLPENR volatile.Register32 // 0x174
	C1_APB2LPENR  volatile.Register32 // 0x178
	C1_APB4LPENR  volatile.Register32 // 0x17C
}

// RCC.CR: clock control register
func (o *RCC_Type) SetCR_HSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCR_HSION() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RCC_Type) SetCR_HSIKERON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCR_HSIKERON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCR_HSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCR_HSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCR_HSIDIV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetCR_HSIDIV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetCR_HSIDIVF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCR_HSIDIVF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCR_CSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCR_CSION() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCR_CSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCR_CSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCR_CSIKERON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCR_CSIKERON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCR_HSI48ON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetCR_HSI48ON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetCR_HSI48RDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetCR_HSI48RDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetCR_D1CKRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetCR_D1CKRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetCR_D2CKRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetCR_D2CKRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetCR_HSEON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCR_HSEON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCR_HSERDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCR_HSERDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCR_HSEBYP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCR_HSEBYP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCR_HSECSSON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCR_HSECSSON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCR_PLL1ON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCR_PLL1ON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCR_PLL1RDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCR_PLL1RDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCR_PLL2ON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCR_PLL2ON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCR_PLL2RDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCR_PLL2RDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCR_PLL3ON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCR_PLL3ON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetCR_PLL3RDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCR_PLL3RDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}

// RCC.HSICFGR: RCC HSI configuration register
func (o *RCC_Type) SetHSICFGR_HSITRIM(value uint32) {
	volatile.StoreUint32(&o.HSICFGR.Reg, volatile.LoadUint32(&o.HSICFGR.Reg)&^(0x7f000000)|value<<24)
}
func (o *RCC_Type) GetHSICFGR_HSITRIM() uint32 {
	return (volatile.LoadUint32(&o.HSICFGR.Reg) & 0x7f000000) >> 24
}
func (o *RCC_Type) SetHSICFGR_HSICAL(value uint32) {
	volatile.StoreUint32(&o.HSICFGR.Reg, volatile.LoadUint32(&o.HSICFGR.Reg)&^(0xfff)|value)
}
func (o *RCC_Type) GetHSICFGR_HSICAL() uint32 {
	return volatile.LoadUint32(&o.HSICFGR.Reg) & 0xfff
}

// RCC.CRRCR: RCC Clock Recovery RC Register
func (o *RCC_Type) SetCRRCR_HSI48CAL(value uint32) {
	volatile.StoreUint32(&o.CRRCR.Reg, volatile.LoadUint32(&o.CRRCR.Reg)&^(0x3ff)|value)
}
func (o *RCC_Type) GetCRRCR_HSI48CAL() uint32 {
	return volatile.LoadUint32(&o.CRRCR.Reg) & 0x3ff
}

// RCC.CSICFGR: RCC CSI configuration register
func (o *RCC_Type) SetCSICFGR_CSITRIM(value uint32) {
	volatile.StoreUint32(&o.CSICFGR.Reg, volatile.LoadUint32(&o.CSICFGR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RCC_Type) GetCSICFGR_CSITRIM() uint32 {
	return (volatile.LoadUint32(&o.CSICFGR.Reg) & 0x3f000000) >> 24
}
func (o *RCC_Type) SetCSICFGR_CSICAL(value uint32) {
	volatile.StoreUint32(&o.CSICFGR.Reg, volatile.LoadUint32(&o.CSICFGR.Reg)&^(0x3ff)|value)
}
func (o *RCC_Type) GetCSICFGR_CSICAL() uint32 {
	return volatile.LoadUint32(&o.CSICFGR.Reg) & 0x3ff
}

// RCC.CFGR: RCC Clock Configuration Register
func (o *RCC_Type) SetCFGR_SW(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7)|value)
}
func (o *RCC_Type) GetCFGR_SW() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x7
}
func (o *RCC_Type) SetCFGR_SWS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x38)|value<<3)
}
func (o *RCC_Type) GetCFGR_SWS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x38) >> 3
}
func (o *RCC_Type) SetCFGR_STOPWUCK(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCFGR_STOPWUCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCFGR_STOPKERWUCK(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCFGR_STOPKERWUCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCFGR_RTCPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3f00)|value<<8)
}
func (o *RCC_Type) GetCFGR_RTCPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x3f00) >> 8
}
func (o *RCC_Type) SetCFGR_HRTIMSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetCFGR_HRTIMSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetCFGR_TIMPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetCFGR_TIMPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetCFGR_MCO1PRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3c0000)|value<<18)
}
func (o *RCC_Type) GetCFGR_MCO1PRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x3c0000) >> 18
}
func (o *RCC_Type) SetCFGR_MCO1(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1c00000)|value<<22)
}
func (o *RCC_Type) GetCFGR_MCO1() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1c00000) >> 22
}
func (o *RCC_Type) SetCFGR_MCO2PRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1e000000)|value<<25)
}
func (o *RCC_Type) GetCFGR_MCO2PRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1e000000) >> 25
}
func (o *RCC_Type) SetCFGR_MCO2(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe0000000)|value<<29)
}
func (o *RCC_Type) GetCFGR_MCO2() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe0000000) >> 29
}

// RCC.D1CFGR: RCC Domain 1 Clock Configuration Register
func (o *RCC_Type) SetD1CFGR_HPRE(value uint32) {
	volatile.StoreUint32(&o.D1CFGR.Reg, volatile.LoadUint32(&o.D1CFGR.Reg)&^(0xf)|value)
}
func (o *RCC_Type) GetD1CFGR_HPRE() uint32 {
	return volatile.LoadUint32(&o.D1CFGR.Reg) & 0xf
}
func (o *RCC_Type) SetD1CFGR_D1PPRE(value uint32) {
	volatile.StoreUint32(&o.D1CFGR.Reg, volatile.LoadUint32(&o.D1CFGR.Reg)&^(0x70)|value<<4)
}
func (o *RCC_Type) GetD1CFGR_D1PPRE() uint32 {
	return (volatile.LoadUint32(&o.D1CFGR.Reg) & 0x70) >> 4
}
func (o *RCC_Type) SetD1CFGR_D1CPRE(value uint32) {
	volatile.StoreUint32(&o.D1CFGR.Reg, volatile.LoadUint32(&o.D1CFGR.Reg)&^(0xf00)|value<<8)
}
func (o *RCC_Type) GetD1CFGR_D1CPRE() uint32 {
	return (volatile.LoadUint32(&o.D1CFGR.Reg) & 0xf00) >> 8
}

// RCC.D2CFGR: RCC Domain 2 Clock Configuration Register
func (o *RCC_Type) SetD2CFGR_D2PPRE1(value uint32) {
	volatile.StoreUint32(&o.D2CFGR.Reg, volatile.LoadUint32(&o.D2CFGR.Reg)&^(0x70)|value<<4)
}
func (o *RCC_Type) GetD2CFGR_D2PPRE1() uint32 {
	return (volatile.LoadUint32(&o.D2CFGR.Reg) & 0x70) >> 4
}
func (o *RCC_Type) SetD2CFGR_D2PPRE2(value uint32) {
	volatile.StoreUint32(&o.D2CFGR.Reg, volatile.LoadUint32(&o.D2CFGR.Reg)&^(0x700)|value<<8)
}
func (o *RCC_Type) GetD2CFGR_D2PPRE2() uint32 {
	return (volatile.LoadUint32(&o.D2CFGR.Reg) & 0x700) >> 8
}

// RCC.D3CFGR: RCC Domain 3 Clock Configuration Register
func (o *RCC_Type) SetD3CFGR_D3PPRE(value uint32) {
	volatile.StoreUint32(&o.D3CFGR.Reg, volatile.LoadUint32(&o.D3CFGR.Reg)&^(0x70)|value<<4)
}
func (o *RCC_Type) GetD3CFGR_D3PPRE() uint32 {
	return (volatile.LoadUint32(&o.D3CFGR.Reg) & 0x70) >> 4
}

// RCC.PLLCKSELR: RCC PLLs Clock Source Selection Register
func (o *RCC_Type) SetPLLCKSELR_PLLSRC(value uint32) {
	volatile.StoreUint32(&o.PLLCKSELR.Reg, volatile.LoadUint32(&o.PLLCKSELR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetPLLCKSELR_PLLSRC() uint32 {
	return volatile.LoadUint32(&o.PLLCKSELR.Reg) & 0x3
}
func (o *RCC_Type) SetPLLCKSELR_DIVM1(value uint32) {
	volatile.StoreUint32(&o.PLLCKSELR.Reg, volatile.LoadUint32(&o.PLLCKSELR.Reg)&^(0x3f0)|value<<4)
}
func (o *RCC_Type) GetPLLCKSELR_DIVM1() uint32 {
	return (volatile.LoadUint32(&o.PLLCKSELR.Reg) & 0x3f0) >> 4
}
func (o *RCC_Type) SetPLLCKSELR_DIVM2(value uint32) {
	volatile.StoreUint32(&o.PLLCKSELR.Reg, volatile.LoadUint32(&o.PLLCKSELR.Reg)&^(0x3f000)|value<<12)
}
func (o *RCC_Type) GetPLLCKSELR_DIVM2() uint32 {
	return (volatile.LoadUint32(&o.PLLCKSELR.Reg) & 0x3f000) >> 12
}
func (o *RCC_Type) SetPLLCKSELR_DIVM3(value uint32) {
	volatile.StoreUint32(&o.PLLCKSELR.Reg, volatile.LoadUint32(&o.PLLCKSELR.Reg)&^(0x3f00000)|value<<20)
}
func (o *RCC_Type) GetPLLCKSELR_DIVM3() uint32 {
	return (volatile.LoadUint32(&o.PLLCKSELR.Reg) & 0x3f00000) >> 20
}

// RCC.PLLCFGR: RCC PLLs Configuration Register
func (o *RCC_Type) SetPLLCFGR_PLL1FRACEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetPLLCFGR_PLL1FRACEN() uint32 {
	return volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x1
}
func (o *RCC_Type) SetPLLCFGR_PLL1VCOSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetPLLCFGR_PLL1VCOSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetPLLCFGR_PLL1RGE(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetPLLCFGR_PLL1RGE() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetPLLCFGR_PLL2FRACEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetPLLCFGR_PLL2FRACEN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetPLLCFGR_PLL2VCOSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetPLLCFGR_PLL2VCOSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetPLLCFGR_PLL2RGE(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xc0)|value<<6)
}
func (o *RCC_Type) GetPLLCFGR_PLL2RGE() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xc0) >> 6
}
func (o *RCC_Type) SetPLLCFGR_PLL3FRACEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetPLLCFGR_PLL3FRACEN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetPLLCFGR_PLL3VCOSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetPLLCFGR_PLL3VCOSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetPLLCFGR_PLL3RGE(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xc00)|value<<10)
}
func (o *RCC_Type) GetPLLCFGR_PLL3RGE() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xc00) >> 10
}
func (o *RCC_Type) SetPLLCFGR_DIVP1EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetPLLCFGR_DIVP1EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetPLLCFGR_DIVQ1EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetPLLCFGR_DIVQ1EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetPLLCFGR_DIVR1EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetPLLCFGR_DIVR1EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetPLLCFGR_DIVP2EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetPLLCFGR_DIVP2EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetPLLCFGR_DIVQ2EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetPLLCFGR_DIVQ2EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetPLLCFGR_DIVR2EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetPLLCFGR_DIVR2EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetPLLCFGR_DIVP3EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetPLLCFGR_DIVP3EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetPLLCFGR_DIVQ3EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetPLLCFGR_DIVQ3EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetPLLCFGR_DIVR3EN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetPLLCFGR_DIVR3EN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x1000000) >> 24
}

// RCC.PLL1DIVR: RCC PLL1 Dividers Configuration Register
func (o *RCC_Type) SetPLL1DIVR_DIVN1(value uint32) {
	volatile.StoreUint32(&o.PLL1DIVR.Reg, volatile.LoadUint32(&o.PLL1DIVR.Reg)&^(0x1ff)|value)
}
func (o *RCC_Type) GetPLL1DIVR_DIVN1() uint32 {
	return volatile.LoadUint32(&o.PLL1DIVR.Reg) & 0x1ff
}
func (o *RCC_Type) SetPLL1DIVR_DIVP1(value uint32) {
	volatile.StoreUint32(&o.PLL1DIVR.Reg, volatile.LoadUint32(&o.PLL1DIVR.Reg)&^(0xfe00)|value<<9)
}
func (o *RCC_Type) GetPLL1DIVR_DIVP1() uint32 {
	return (volatile.LoadUint32(&o.PLL1DIVR.Reg) & 0xfe00) >> 9
}
func (o *RCC_Type) SetPLL1DIVR_DIVQ1(value uint32) {
	volatile.StoreUint32(&o.PLL1DIVR.Reg, volatile.LoadUint32(&o.PLL1DIVR.Reg)&^(0x7f0000)|value<<16)
}
func (o *RCC_Type) GetPLL1DIVR_DIVQ1() uint32 {
	return (volatile.LoadUint32(&o.PLL1DIVR.Reg) & 0x7f0000) >> 16
}
func (o *RCC_Type) SetPLL1DIVR_DIVR1(value uint32) {
	volatile.StoreUint32(&o.PLL1DIVR.Reg, volatile.LoadUint32(&o.PLL1DIVR.Reg)&^(0x7f000000)|value<<24)
}
func (o *RCC_Type) GetPLL1DIVR_DIVR1() uint32 {
	return (volatile.LoadUint32(&o.PLL1DIVR.Reg) & 0x7f000000) >> 24
}

// RCC.PLL1FRACR: RCC PLL1 Fractional Divider Register
func (o *RCC_Type) SetPLL1FRACR_FRACN1(value uint32) {
	volatile.StoreUint32(&o.PLL1FRACR.Reg, volatile.LoadUint32(&o.PLL1FRACR.Reg)&^(0xfff8)|value<<3)
}
func (o *RCC_Type) GetPLL1FRACR_FRACN1() uint32 {
	return (volatile.LoadUint32(&o.PLL1FRACR.Reg) & 0xfff8) >> 3
}

// RCC.PLL2DIVR: RCC PLL2 Dividers Configuration Register
func (o *RCC_Type) SetPLL2DIVR_DIVN2(value uint32) {
	volatile.StoreUint32(&o.PLL2DIVR.Reg, volatile.LoadUint32(&o.PLL2DIVR.Reg)&^(0x1ff)|value)
}
func (o *RCC_Type) GetPLL2DIVR_DIVN2() uint32 {
	return volatile.LoadUint32(&o.PLL2DIVR.Reg) & 0x1ff
}
func (o *RCC_Type) SetPLL2DIVR_DIVP2(value uint32) {
	volatile.StoreUint32(&o.PLL2DIVR.Reg, volatile.LoadUint32(&o.PLL2DIVR.Reg)&^(0xfe00)|value<<9)
}
func (o *RCC_Type) GetPLL2DIVR_DIVP2() uint32 {
	return (volatile.LoadUint32(&o.PLL2DIVR.Reg) & 0xfe00) >> 9
}
func (o *RCC_Type) SetPLL2DIVR_DIVQ2(value uint32) {
	volatile.StoreUint32(&o.PLL2DIVR.Reg, volatile.LoadUint32(&o.PLL2DIVR.Reg)&^(0x7f0000)|value<<16)
}
func (o *RCC_Type) GetPLL2DIVR_DIVQ2() uint32 {
	return (volatile.LoadUint32(&o.PLL2DIVR.Reg) & 0x7f0000) >> 16
}
func (o *RCC_Type) SetPLL2DIVR_DIVR2(value uint32) {
	volatile.StoreUint32(&o.PLL2DIVR.Reg, volatile.LoadUint32(&o.PLL2DIVR.Reg)&^(0x7f000000)|value<<24)
}
func (o *RCC_Type) GetPLL2DIVR_DIVR2() uint32 {
	return (volatile.LoadUint32(&o.PLL2DIVR.Reg) & 0x7f000000) >> 24
}

// RCC.PLL2FRACR: RCC PLL2 Fractional Divider Register
func (o *RCC_Type) SetPLL2FRACR_FRACN2(value uint32) {
	volatile.StoreUint32(&o.PLL2FRACR.Reg, volatile.LoadUint32(&o.PLL2FRACR.Reg)&^(0xfff8)|value<<3)
}
func (o *RCC_Type) GetPLL2FRACR_FRACN2() uint32 {
	return (volatile.LoadUint32(&o.PLL2FRACR.Reg) & 0xfff8) >> 3
}

// RCC.PLL3DIVR: RCC PLL3 Dividers Configuration Register
func (o *RCC_Type) SetPLL3DIVR_DIVN3(value uint32) {
	volatile.StoreUint32(&o.PLL3DIVR.Reg, volatile.LoadUint32(&o.PLL3DIVR.Reg)&^(0x1ff)|value)
}
func (o *RCC_Type) GetPLL3DIVR_DIVN3() uint32 {
	return volatile.LoadUint32(&o.PLL3DIVR.Reg) & 0x1ff
}
func (o *RCC_Type) SetPLL3DIVR_DIVP3(value uint32) {
	volatile.StoreUint32(&o.PLL3DIVR.Reg, volatile.LoadUint32(&o.PLL3DIVR.Reg)&^(0xfe00)|value<<9)
}
func (o *RCC_Type) GetPLL3DIVR_DIVP3() uint32 {
	return (volatile.LoadUint32(&o.PLL3DIVR.Reg) & 0xfe00) >> 9
}
func (o *RCC_Type) SetPLL3DIVR_DIVQ3(value uint32) {
	volatile.StoreUint32(&o.PLL3DIVR.Reg, volatile.LoadUint32(&o.PLL3DIVR.Reg)&^(0x7f0000)|value<<16)
}
func (o *RCC_Type) GetPLL3DIVR_DIVQ3() uint32 {
	return (volatile.LoadUint32(&o.PLL3DIVR.Reg) & 0x7f0000) >> 16
}
func (o *RCC_Type) SetPLL3DIVR_DIVR3(value uint32) {
	volatile.StoreUint32(&o.PLL3DIVR.Reg, volatile.LoadUint32(&o.PLL3DIVR.Reg)&^(0x7f000000)|value<<24)
}
func (o *RCC_Type) GetPLL3DIVR_DIVR3() uint32 {
	return (volatile.LoadUint32(&o.PLL3DIVR.Reg) & 0x7f000000) >> 24
}

// RCC.PLL3FRACR: RCC PLL3 Fractional Divider Register
func (o *RCC_Type) SetPLL3FRACR_FRACN3(value uint32) {
	volatile.StoreUint32(&o.PLL3FRACR.Reg, volatile.LoadUint32(&o.PLL3FRACR.Reg)&^(0xfff8)|value<<3)
}
func (o *RCC_Type) GetPLL3FRACR_FRACN3() uint32 {
	return (volatile.LoadUint32(&o.PLL3FRACR.Reg) & 0xfff8) >> 3
}

// RCC.D1CCIPR: RCC Domain 1 Kernel Clock Configuration Register
func (o *RCC_Type) SetD1CCIPR_FMCSEL(value uint32) {
	volatile.StoreUint32(&o.D1CCIPR.Reg, volatile.LoadUint32(&o.D1CCIPR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetD1CCIPR_FMCSEL() uint32 {
	return volatile.LoadUint32(&o.D1CCIPR.Reg) & 0x3
}
func (o *RCC_Type) SetD1CCIPR_OCTOSPISEL(value uint32) {
	volatile.StoreUint32(&o.D1CCIPR.Reg, volatile.LoadUint32(&o.D1CCIPR.Reg)&^(0x30)|value<<4)
}
func (o *RCC_Type) GetD1CCIPR_OCTOSPISEL() uint32 {
	return (volatile.LoadUint32(&o.D1CCIPR.Reg) & 0x30) >> 4
}
func (o *RCC_Type) SetD1CCIPR_SDMMCSEL(value uint32) {
	volatile.StoreUint32(&o.D1CCIPR.Reg, volatile.LoadUint32(&o.D1CCIPR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetD1CCIPR_SDMMCSEL() uint32 {
	return (volatile.LoadUint32(&o.D1CCIPR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetD1CCIPR_CKPERSEL(value uint32) {
	volatile.StoreUint32(&o.D1CCIPR.Reg, volatile.LoadUint32(&o.D1CCIPR.Reg)&^(0x30000000)|value<<28)
}
func (o *RCC_Type) GetD1CCIPR_CKPERSEL() uint32 {
	return (volatile.LoadUint32(&o.D1CCIPR.Reg) & 0x30000000) >> 28
}

// RCC.D2CCIP1R: RCC Domain 2 Kernel Clock Configuration Register
func (o *RCC_Type) SetD2CCIP1R_SAI1SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x7)|value)
}
func (o *RCC_Type) GetD2CCIP1R_SAI1SEL() uint32 {
	return volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x7
}
func (o *RCC_Type) SetD2CCIP1R_SPI123SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x7000)|value<<12)
}
func (o *RCC_Type) GetD2CCIP1R_SPI123SEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x7000) >> 12
}
func (o *RCC_Type) SetD2CCIP1R_SPI45SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x70000)|value<<16)
}
func (o *RCC_Type) GetD2CCIP1R_SPI45SEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x70000) >> 16
}
func (o *RCC_Type) SetD2CCIP1R_SPDIFSEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetD2CCIP1R_SPDIFSEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetD2CCIP1R_DFSDM1SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetD2CCIP1R_DFSDM1SEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetD2CCIP1R_FDCANSEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x30000000)|value<<28)
}
func (o *RCC_Type) GetD2CCIP1R_FDCANSEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x30000000) >> 28
}
func (o *RCC_Type) SetD2CCIP1R_SWPMISEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP1R.Reg, volatile.LoadUint32(&o.D2CCIP1R.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetD2CCIP1R_SWPMISEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP1R.Reg) & 0x80000000) >> 31
}

// RCC.D2CCIP2R: RCC Domain 2 Kernel Clock Configuration Register
func (o *RCC_Type) SetD2CCIP2R_USART234578SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0x7)|value)
}
func (o *RCC_Type) GetD2CCIP2R_USART234578SEL() uint32 {
	return volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0x7
}
func (o *RCC_Type) SetD2CCIP2R_USART16910SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0x38)|value<<3)
}
func (o *RCC_Type) GetD2CCIP2R_USART16910SEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0x38) >> 3
}
func (o *RCC_Type) SetD2CCIP2R_RNGSEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetD2CCIP2R_RNGSEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetD2CCIP2R_I2C1235SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0x3000)|value<<12)
}
func (o *RCC_Type) GetD2CCIP2R_I2C1235SEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0x3000) >> 12
}
func (o *RCC_Type) SetD2CCIP2R_USBSEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetD2CCIP2R_USBSEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetD2CCIP2R_CECSEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0xc00000)|value<<22)
}
func (o *RCC_Type) GetD2CCIP2R_CECSEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0xc00000) >> 22
}
func (o *RCC_Type) SetD2CCIP2R_LPTIM1SEL(value uint32) {
	volatile.StoreUint32(&o.D2CCIP2R.Reg, volatile.LoadUint32(&o.D2CCIP2R.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetD2CCIP2R_LPTIM1SEL() uint32 {
	return (volatile.LoadUint32(&o.D2CCIP2R.Reg) & 0x70000000) >> 28
}

// RCC.D3CCIPR: RCC Domain 3 Kernel Clock Configuration Register
func (o *RCC_Type) SetD3CCIPR_LPUART1SEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0x7)|value)
}
func (o *RCC_Type) GetD3CCIPR_LPUART1SEL() uint32 {
	return volatile.LoadUint32(&o.D3CCIPR.Reg) & 0x7
}
func (o *RCC_Type) SetD3CCIPR_I2C4SEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetD3CCIPR_I2C4SEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetD3CCIPR_LPTIM2SEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0x1c00)|value<<10)
}
func (o *RCC_Type) GetD3CCIPR_LPTIM2SEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0x1c00) >> 10
}
func (o *RCC_Type) SetD3CCIPR_LPTIM345SEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0xe000)|value<<13)
}
func (o *RCC_Type) GetD3CCIPR_LPTIM345SEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0xe000) >> 13
}
func (o *RCC_Type) SetD3CCIPR_ADCSEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetD3CCIPR_ADCSEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetD3CCIPR_SAI4ASEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0xe00000)|value<<21)
}
func (o *RCC_Type) GetD3CCIPR_SAI4ASEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0xe00000) >> 21
}
func (o *RCC_Type) SetD3CCIPR_SAI4BSEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0x7000000)|value<<24)
}
func (o *RCC_Type) GetD3CCIPR_SAI4BSEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0x7000000) >> 24
}
func (o *RCC_Type) SetD3CCIPR_SPI6SEL(value uint32) {
	volatile.StoreUint32(&o.D3CCIPR.Reg, volatile.LoadUint32(&o.D3CCIPR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetD3CCIPR_SPI6SEL() uint32 {
	return (volatile.LoadUint32(&o.D3CCIPR.Reg) & 0x70000000) >> 28
}

// RCC.CIER: RCC Clock Source Interrupt Enable Register
func (o *RCC_Type) SetCIER_LSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIER_LSIRDYIE() uint32 {
	return volatile.LoadUint32(&o.CIER.Reg) & 0x1
}
func (o *RCC_Type) SetCIER_LSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIER_LSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIER_HSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIER_HSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIER_HSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIER_HSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIER_CSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIER_CSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIER_HSI48RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIER_HSI48RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIER_PLL1RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCIER_PLL1RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCIER_PLL2RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCIER_PLL2RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCIER_PLL3RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCIER_PLL3RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCIER_LSECSSIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIER_LSECSSIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x200) >> 9
}

// RCC.CIFR: RCC Clock Source Interrupt Flag Register
func (o *RCC_Type) SetCIFR_LSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIFR_LSIRDYF() uint32 {
	return volatile.LoadUint32(&o.CIFR.Reg) & 0x1
}
func (o *RCC_Type) SetCIFR_LSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIFR_LSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIFR_HSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIFR_HSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIFR_HSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIFR_HSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIFR_CSIRDY(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIFR_CSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIFR_HSI48RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIFR_HSI48RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIFR_PLL1RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCIFR_PLL1RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCIFR_PLL2RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCIFR_PLL2RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCIFR_PLL3RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCIFR_PLL3RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCIFR_LSECSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIFR_LSECSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCIFR_HSECSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCIFR_HSECSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x400) >> 10
}

// RCC.CICR: RCC Clock Source Interrupt Clear Register
func (o *RCC_Type) SetCICR_LSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCICR_LSIRDYC() uint32 {
	return volatile.LoadUint32(&o.CICR.Reg) & 0x1
}
func (o *RCC_Type) SetCICR_LSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCICR_LSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCICR_HSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCICR_HSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCICR_HSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCICR_HSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCICR_HSE_ready_Interrupt_Clear(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCICR_HSE_ready_Interrupt_Clear() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCICR_HSI48RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCICR_HSI48RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCICR_PLL1RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCICR_PLL1RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCICR_PLL2RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCICR_PLL2RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCICR_PLL3RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCICR_PLL3RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCICR_LSECSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCICR_LSECSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCICR_HSECSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCICR_HSECSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x400) >> 10
}

// RCC.BDCR: RCC Backup Domain Control Register
func (o *RCC_Type) SetBDCR_LSEON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetBDCR_LSEON() uint32 {
	return volatile.LoadUint32(&o.BDCR.Reg) & 0x1
}
func (o *RCC_Type) SetBDCR_LSERDY(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetBDCR_LSERDY() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetBDCR_LSEBYP(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetBDCR_LSEBYP() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetBDCR_LSEDRV(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetBDCR_LSEDRV() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetBDCR_LSECSSON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetBDCR_LSECSSON() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetBDCR_LSECSSD(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetBDCR_LSECSSD() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetBDCR_RTCSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetBDCR_RTCSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetBDCR_RTCEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetBDCR_RTCEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetBDCR_BDRST(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetBDCR_BDRST() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x10000) >> 16
}

// RCC.CSR: RCC Clock Control and Status Register
func (o *RCC_Type) SetCSR_LSION(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCSR_LSION() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *RCC_Type) SetCSR_LSIRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCSR_LSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}

// RCC.AHB3RSTR: RCC AHB3 Reset Register
func (o *RCC_Type) SetAHB3RSTR_MDMARST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3RSTR_MDMARST() uint32 {
	return volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3RSTR_DMA2DRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB3RSTR_DMA2DRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB3RSTR_FMCRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB3RSTR_FMCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB3RSTR_SDMMC1RST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB3RSTR_SDMMC1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB3RSTR_CPURST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAHB3RSTR_CPURST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAHB3RSTR_OCTOSPI1RST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAHB3RSTR_OCTOSPI1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAHB3RSTR_OCTOSPI2RST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB3RSTR_OCTOSPI2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB3RSTR_IOMNGRRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB3RSTR_IOMNGRRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB3RSTR_OTFD1RST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB3RSTR_OTFD1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAHB3RSTR_OTFD2RST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB3RSTR_OTFD2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x800000) >> 23
}

// RCC.AHB1RSTR: RCC AHB1 Peripheral Reset Register
func (o *RCC_Type) SetAHB1RSTR_DMA1RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1RSTR_DMA1RST() uint32 {
	return volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1RSTR_DMA2RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1RSTR_DMA2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1RSTR_ADC12RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB1RSTR_ADC12RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB1RSTR_ETH1MACRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAHB1RSTR_ETH1MACRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAHB1RSTR_USB1OTGRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB1RSTR_USB1OTGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x2000000) >> 25
}

// RCC.AHB2RSTR: RCC AHB2 Peripheral Reset Register
func (o *RCC_Type) SetAHB2RSTR_CAMITFRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2RSTR_CAMITFRST() uint32 {
	return volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2RSTR_CRYPTRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2RSTR_CRYPTRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2RSTR_HASHRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2RSTR_HASHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2RSTR_RNGRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2RSTR_RNGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2RSTR_SDMMC2RST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB2RSTR_SDMMC2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB2RSTR_FMACRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB2RSTR_FMACRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB2RSTR_CORDICRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB2RSTR_CORDICRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x20000) >> 17
}

// RCC.AHB4RSTR: RCC AHB4 Peripheral Reset Register
func (o *RCC_Type) SetAHB4RSTR_GPIOARST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOARST() uint32 {
	return volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB4RSTR_GPIOBRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOBRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB4RSTR_GPIOCRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB4RSTR_GPIODRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB4RSTR_GPIODRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB4RSTR_GPIOERST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOERST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB4RSTR_GPIOFRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOFRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB4RSTR_GPIOGRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB4RSTR_GPIOHRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB4RSTR_GPIOIRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOIRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB4RSTR_GPIOJRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOJRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB4RSTR_GPIOKRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB4RSTR_GPIOKRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB4RSTR_CRCRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB4RSTR_CRCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB4RSTR_BDMARST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB4RSTR_BDMARST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB4RSTR_ADC3RST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAHB4RSTR_ADC3RST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAHB4RSTR_HSEMRST(value uint32) {
	volatile.StoreUint32(&o.AHB4RSTR.Reg, volatile.LoadUint32(&o.AHB4RSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB4RSTR_HSEMRST() uint32 {
	return (volatile.LoadUint32(&o.AHB4RSTR.Reg) & 0x2000000) >> 25
}

// RCC.APB3RSTR: RCC APB3 Peripheral Reset Register
func (o *RCC_Type) SetAPB3RSTR_LTDCRST(value uint32) {
	volatile.StoreUint32(&o.APB3RSTR.Reg, volatile.LoadUint32(&o.APB3RSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB3RSTR_LTDCRST() uint32 {
	return (volatile.LoadUint32(&o.APB3RSTR.Reg) & 0x8) >> 3
}

// RCC.APB1LRSTR: RCC APB1 Peripheral Reset Register
func (o *RCC_Type) SetAPB1LRSTR_TIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM2RST() uint32 {
	return volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1LRSTR_TIM3RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1LRSTR_TIM4RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1LRSTR_TIM5RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1LRSTR_TIM6RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM6RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1LRSTR_TIM7RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM7RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1LRSTR_TIM12RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM12RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1LRSTR_TIM13RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM13RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB1LRSTR_TIM14RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1LRSTR_TIM14RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1LRSTR_LPTIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB1LRSTR_LPTIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB1LRSTR_SPI2RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1LRSTR_SPI2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1LRSTR_SPI3RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1LRSTR_SPI3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1LRSTR_SPDIFRXRST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB1LRSTR_SPDIFRXRST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB1LRSTR_USART2RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1LRSTR_USART2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1LRSTR_USART3RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1LRSTR_USART3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1LRSTR_UART4RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1LRSTR_UART4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1LRSTR_UART5RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1LRSTR_UART5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1LRSTR_I2C1RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1LRSTR_I2C1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1LRSTR_I2C2RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1LRSTR_I2C2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1LRSTR_I2C3RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1LRSTR_I2C3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1LRSTR_CECRST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB1LRSTR_CECRST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB1LRSTR_DAC12RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1LRSTR_DAC12RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1LRSTR_UART7RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1LRSTR_UART7RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1LRSTR_UART8RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1LRSTR_UART8RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1LRSTR_I2C5RST(value uint32) {
	volatile.StoreUint32(&o.APB1LRSTR.Reg, volatile.LoadUint32(&o.APB1LRSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1LRSTR_I2C5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1LRSTR.Reg) & 0x2000000) >> 25
}

// RCC.APB1HRSTR: RCC APB1 Peripheral Reset Register
func (o *RCC_Type) SetAPB1HRSTR_CRSRST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1HRSTR_CRSRST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1HRSTR_SWPMIRST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1HRSTR_SWPMIRST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1HRSTR_OPAMPRST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1HRSTR_OPAMPRST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1HRSTR_MDIOSRST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1HRSTR_MDIOSRST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1HRSTR_FDCANRST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1HRSTR_FDCANRST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1HRSTR_TIM23RST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1HRSTR_TIM23RST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1HRSTR_TIM24RST(value uint32) {
	volatile.StoreUint32(&o.APB1HRSTR.Reg, volatile.LoadUint32(&o.APB1HRSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1HRSTR_TIM24RST() uint32 {
	return (volatile.LoadUint32(&o.APB1HRSTR.Reg) & 0x2000000) >> 25
}

// RCC.APB2RSTR: RCC APB2 Peripheral Reset Register
func (o *RCC_Type) SetAPB2RSTR_TIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2RSTR_TIM1RST() uint32 {
	return volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2RSTR_TIM8RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB2RSTR_TIM8RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB2RSTR_USART1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2RSTR_USART1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2RSTR_USART6RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2RSTR_USART6RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2RSTR_SPI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2RSTR_SPI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2RSTR_SPI4RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2RSTR_SPI4RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2RSTR_TIM15RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2RSTR_TIM15RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2RSTR_TIM16RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2RSTR_TIM16RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2RSTR_TIM17RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2RSTR_TIM17RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2RSTR_SPI5RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB2RSTR_SPI5RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB2RSTR_SAI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2RSTR_SAI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2RSTR_SAI2RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB2RSTR_SAI2RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB2RSTR_SAI3RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB2RSTR_SAI3RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB2RSTR_DFSDM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB2RSTR_DFSDM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x10000000) >> 28
}

// RCC.APB4RSTR: RCC APB4 Peripheral Reset Register
func (o *RCC_Type) SetAPB4RSTR_SYSCFGRST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB4RSTR_SYSCFGRST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB4RSTR_LPUART1RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB4RSTR_LPUART1RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB4RSTR_SPI6RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB4RSTR_SPI6RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB4RSTR_I2C4RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB4RSTR_I2C4RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB4RSTR_LPTIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB4RSTR_LPTIM2RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB4RSTR_LPTIM3RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB4RSTR_LPTIM3RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB4RSTR_LPTIM4RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB4RSTR_LPTIM4RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB4RSTR_LPTIM5RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB4RSTR_LPTIM5RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB4RSTR_COMP12RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB4RSTR_COMP12RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB4RSTR_VREFRST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB4RSTR_VREFRST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB4RSTR_SAI4RST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB4RSTR_SAI4RST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB4RSTR_DTSRST(value uint32) {
	volatile.StoreUint32(&o.APB4RSTR.Reg, volatile.LoadUint32(&o.APB4RSTR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB4RSTR_DTSRST() uint32 {
	return (volatile.LoadUint32(&o.APB4RSTR.Reg) & 0x4000000) >> 26
}

// RCC.GCR: RCC Global Control Register
func (o *RCC_Type) SetGCR_WW1RSC(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetGCR_WW1RSC() uint32 {
	return volatile.LoadUint32(&o.GCR.Reg) & 0x1
}

// RCC.D3AMR: RCC D3 Autonomous mode Register
func (o *RCC_Type) SetD3AMR_BDMAAMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetD3AMR_BDMAAMEN() uint32 {
	return volatile.LoadUint32(&o.D3AMR.Reg) & 0x1
}
func (o *RCC_Type) SetD3AMR_LPUART1AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetD3AMR_LPUART1AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetD3AMR_SPI6AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetD3AMR_SPI6AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetD3AMR_I2C4AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetD3AMR_I2C4AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetD3AMR_LPTIM2AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetD3AMR_LPTIM2AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetD3AMR_LPTIM3AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetD3AMR_LPTIM3AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetD3AMR_LPTIM4AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetD3AMR_LPTIM4AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetD3AMR_LPTIM5AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetD3AMR_LPTIM5AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetD3AMR_COMP12AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetD3AMR_COMP12AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetD3AMR_VREFAMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetD3AMR_VREFAMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetD3AMR_RTCAMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetD3AMR_RTCAMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetD3AMR_CRCAMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetD3AMR_CRCAMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetD3AMR_SAI4AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetD3AMR_SAI4AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetD3AMR_ADC3AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetD3AMR_ADC3AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetD3AMR_BKPSRAMAMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetD3AMR_BKPSRAMAMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetD3AMR_SRAM4AMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetD3AMR_SRAM4AMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetD3AMR_DTSAMEN(value uint32) {
	volatile.StoreUint32(&o.D3AMR.Reg, volatile.LoadUint32(&o.D3AMR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetD3AMR_DTSAMEN() uint32 {
	return (volatile.LoadUint32(&o.D3AMR.Reg) & 0x4000000) >> 26
}

// RCC.RSR: RCC Reset Status Register
func (o *RCC_Type) SetRSR_RMVF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetRSR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetRSR_CPURSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetRSR_CPURSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetRSR_D1RSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetRSR_D1RSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetRSR_D2RSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetRSR_D2RSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetRSR_BORRSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetRSR_BORRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetRSR_PINRSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetRSR_PINRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetRSR_PORRSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetRSR_PORRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetRSR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetRSR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetRSR_IWDG1RSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetRSR_IWDG1RSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetRSR_WWDG1RSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetRSR_WWDG1RSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetRSR_LPWRRSTF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetRSR_LPWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x40000000) >> 30
}

// RCC.AHB3ENR: RCC AHB3 Clock Register
func (o *RCC_Type) SetAHB3ENR_MDMAEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3ENR_MDMAEN() uint32 {
	return volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3ENR_DMA2DEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB3ENR_DMA2DEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB3ENR_FMCEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB3ENR_FMCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB3ENR_SDMMC1EN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB3ENR_SDMMC1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB3ENR_OCTOSPI1EN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAHB3ENR_OCTOSPI1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAHB3ENR_OCTOSPI2EN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB3ENR_OCTOSPI2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB3ENR_IOMNGREN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB3ENR_IOMNGREN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB3ENR_OTFD1EN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB3ENR_OTFD1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAHB3ENR_OTFD2EN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB3ENR_OTFD2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x800000) >> 23
}

// RCC.AHB1ENR: RCC AHB1 Clock Register
func (o *RCC_Type) SetAHB1ENR_DMA1EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1ENR_DMA1EN() uint32 {
	return volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1ENR_DMA2EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1ENR_DMA2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1ENR_ADC12EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB1ENR_ADC12EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB1ENR_ETH1MACEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAHB1ENR_ETH1MACEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAHB1ENR_ETH1TXEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB1ENR_ETH1TXEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB1ENR_ETH1RXEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB1ENR_ETH1RXEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB1ENR_USB1OTGEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB1ENR_USB1OTGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB1ENR_USB1ULPIEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAHB1ENR_USB1ULPIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x4000000) >> 26
}

// RCC.AHB2ENR: RCC AHB2 Clock Register
func (o *RCC_Type) SetAHB2ENR_DCMIEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2ENR_DCMIEN() uint32 {
	return volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2ENR_CRYPTEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2ENR_CRYPTEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2ENR_HASHEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2ENR_HASHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2ENR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2ENR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2ENR_SDMMC2EN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB2ENR_SDMMC2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB2ENR_SRAM1EN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB2ENR_SRAM1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAHB2ENR_SRAM2EN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAHB2ENR_SRAM2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAHB2ENR_FMACEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB2ENR_FMACEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB2ENR_CORDICEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB2ENR_CORDICEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x20000) >> 17
}

// RCC.AHB4ENR: RCC AHB4 Clock Register
func (o *RCC_Type) SetAHB4ENR_GPIOAEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB4ENR_GPIOAEN() uint32 {
	return volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB4ENR_GPIOBEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB4ENR_GPIOBEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB4ENR_GPIOCEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB4ENR_GPIOCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB4ENR_GPIODEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB4ENR_GPIODEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB4ENR_GPIOEEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB4ENR_GPIOEEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB4ENR_GPIOFEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB4ENR_GPIOFEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB4ENR_GPIOGEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB4ENR_GPIOGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB4ENR_GPIOHEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB4ENR_GPIOHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB4ENR_GPIOIEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB4ENR_GPIOIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB4ENR_GPIOJEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB4ENR_GPIOJEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB4ENR_GPIOKEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB4ENR_GPIOKEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB4ENR_CRCEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB4ENR_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB4ENR_BDMAEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB4ENR_BDMAEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB4ENR_ADC3EN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAHB4ENR_ADC3EN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAHB4ENR_HSEMEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB4ENR_HSEMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB4ENR_BKPRAMEN(value uint32) {
	volatile.StoreUint32(&o.AHB4ENR.Reg, volatile.LoadUint32(&o.AHB4ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAHB4ENR_BKPRAMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4ENR.Reg) & 0x10000000) >> 28
}

// RCC.APB3ENR: RCC APB3 Clock Register
func (o *RCC_Type) SetAPB3ENR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.APB3ENR.Reg, volatile.LoadUint32(&o.APB3ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB3ENR_LTDCEN() uint32 {
	return (volatile.LoadUint32(&o.APB3ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB3ENR_WWDG1EN(value uint32) {
	volatile.StoreUint32(&o.APB3ENR.Reg, volatile.LoadUint32(&o.APB3ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB3ENR_WWDG1EN() uint32 {
	return (volatile.LoadUint32(&o.APB3ENR.Reg) & 0x40) >> 6
}

// RCC.APB1LENR: RCC APB1 Clock Register
func (o *RCC_Type) SetAPB1LENR_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1LENR_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.APB1LENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1LENR_TIM3EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1LENR_TIM3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1LENR_TIM4EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1LENR_TIM4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1LENR_TIM5EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1LENR_TIM5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1LENR_TIM6EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1LENR_TIM6EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1LENR_TIM7EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1LENR_TIM7EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1LENR_TIM12EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1LENR_TIM12EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1LENR_TIM13EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB1LENR_TIM13EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB1LENR_TIM14EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1LENR_TIM14EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1LENR_LPTIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB1LENR_LPTIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB1LENR_SPI2EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1LENR_SPI2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1LENR_SPI3EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1LENR_SPI3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1LENR_SPDIFRXEN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB1LENR_SPDIFRXEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB1LENR_USART2EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1LENR_USART2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1LENR_USART3EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1LENR_USART3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1LENR_UART4EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1LENR_UART4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1LENR_UART5EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1LENR_UART5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1LENR_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1LENR_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1LENR_I2C2EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1LENR_I2C2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1LENR_I2C3EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1LENR_I2C3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1LENR_CECEN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB1LENR_CECEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB1LENR_DAC12EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1LENR_DAC12EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1LENR_UART7EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1LENR_UART7EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1LENR_UART8EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1LENR_UART8EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1LENR_I2C5EN(value uint32) {
	volatile.StoreUint32(&o.APB1LENR.Reg, volatile.LoadUint32(&o.APB1LENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1LENR_I2C5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1LENR.Reg) & 0x2000000) >> 25
}

// RCC.APB1HENR: RCC APB1 Clock Register
func (o *RCC_Type) SetAPB1HENR_CRSEN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1HENR_CRSEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1HENR_SWPMIEN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1HENR_SWPMIEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1HENR_OPAMPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1HENR_OPAMPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1HENR_MDIOSEN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1HENR_MDIOSEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1HENR_FDCANEN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1HENR_FDCANEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1HENR_TIM23EN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1HENR_TIM23EN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1HENR_TIM24EN(value uint32) {
	volatile.StoreUint32(&o.APB1HENR.Reg, volatile.LoadUint32(&o.APB1HENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1HENR_TIM24EN() uint32 {
	return (volatile.LoadUint32(&o.APB1HENR.Reg) & 0x2000000) >> 25
}

// RCC.APB2ENR: RCC APB2 Clock Register
func (o *RCC_Type) SetAPB2ENR_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2ENR_TIM1EN() uint32 {
	return volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2ENR_TIM8EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB2ENR_TIM8EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB2ENR_USART1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2ENR_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2ENR_USART6EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2ENR_USART6EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2ENR_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2ENR_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2ENR_SPI4EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2ENR_SPI4EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2ENR_TIM16EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2ENR_TIM16EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2ENR_TIM15EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2ENR_TIM15EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2ENR_TIM17EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2ENR_TIM17EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2ENR_SPI5EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB2ENR_SPI5EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB2ENR_SAI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2ENR_SAI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2ENR_SAI2EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB2ENR_SAI2EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB2ENR_SAI3EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB2ENR_SAI3EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB2ENR_DFSDM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB2ENR_DFSDM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x10000000) >> 28
}

// RCC.APB4ENR: RCC APB4 Clock Register
func (o *RCC_Type) SetAPB4ENR_SYSCFGEN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB4ENR_SYSCFGEN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB4ENR_LPUART1EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB4ENR_LPUART1EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB4ENR_SPI6EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB4ENR_SPI6EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB4ENR_I2C4EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB4ENR_I2C4EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB4ENR_LPTIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB4ENR_LPTIM2EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB4ENR_LPTIM3EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB4ENR_LPTIM3EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB4ENR_LPTIM4EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB4ENR_LPTIM4EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB4ENR_LPTIM5EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB4ENR_LPTIM5EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB4ENR_COMP12EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB4ENR_COMP12EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB4ENR_VREFEN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB4ENR_VREFEN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB4ENR_RTCAPBEN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB4ENR_RTCAPBEN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB4ENR_SAI4EN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB4ENR_SAI4EN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB4ENR_DTSEN(value uint32) {
	volatile.StoreUint32(&o.APB4ENR.Reg, volatile.LoadUint32(&o.APB4ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB4ENR_DTSEN() uint32 {
	return (volatile.LoadUint32(&o.APB4ENR.Reg) & 0x4000000) >> 26
}

// RCC.AHB3LPENR: RCC AHB3 Sleep Clock Register
func (o *RCC_Type) SetAHB3LPENR_MDMALPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3LPENR_MDMALPEN() uint32 {
	return volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3LPENR_DMA2DLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB3LPENR_DMA2DLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB3LPENR_FLITFLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB3LPENR_FLITFLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB3LPENR_FMCLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB3LPENR_FMCLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB3LPENR_SDMMC1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB3LPENR_SDMMC1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB3LPENR_D1DTCM1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAHB3LPENR_D1DTCM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAHB3LPENR_DTCM2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB3LPENR_DTCM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAHB3LPENR_ITCMLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAHB3LPENR_ITCMLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAHB3LPENR_AXISRAMLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAHB3LPENR_AXISRAMLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAHB3LPENR_OCTOSPI1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAHB3LPENR_OCTOSPI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAHB3LPENR_OCTOSPI2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB3LPENR_OCTOSPI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB3LPENR_IOMNGRLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB3LPENR_IOMNGRLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB3LPENR_OTFD1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB3LPENR_OTFD1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAHB3LPENR_OTFD2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB3LPENR_OTFD2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x800000) >> 23
}

// RCC.AHB1LPENR: RCC AHB1 Sleep Clock Register
func (o *RCC_Type) SetAHB1LPENR_DMA1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1LPENR_DMA1LPEN() uint32 {
	return volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1LPENR_DMA2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1LPENR_DMA2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1LPENR_ADC12LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB1LPENR_ADC12LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB1LPENR_ETH1MACLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAHB1LPENR_ETH1MACLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAHB1LPENR_ETH1TXLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB1LPENR_ETH1TXLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB1LPENR_ETH1RXLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB1LPENR_ETH1RXLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB1LPENR_USB1OTGLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB1LPENR_USB1OTGLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB1LPENR_USB1ULPILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAHB1LPENR_USB1ULPILPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x4000000) >> 26
}

// RCC.AHB2LPENR: RCC AHB2 Sleep Clock Register
func (o *RCC_Type) SetAHB2LPENR_DCMILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2LPENR_DCMILPEN() uint32 {
	return volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2LPENR_CRYPTLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2LPENR_CRYPTLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2LPENR_HASHLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2LPENR_HASHLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2LPENR_SDMMC2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB2LPENR_SDMMC2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB2LPENR_RNGLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2LPENR_RNGLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2LPENR_SRAM1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB2LPENR_SRAM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAHB2LPENR_SRAM2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAHB2LPENR_SRAM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAHB2LPENR_FMACLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB2LPENR_FMACLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB2LPENR_CORDICLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB2LPENR_CORDICLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x20000) >> 17
}

// RCC.AHB4LPENR: RCC AHB4 Sleep Clock Register
func (o *RCC_Type) SetAHB4LPENR_GPIOALPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOALPEN() uint32 {
	return volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB4LPENR_GPIOBLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOBLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB4LPENR_GPIOCLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOCLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB4LPENR_GPIODLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB4LPENR_GPIODLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB4LPENR_GPIOELPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOELPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB4LPENR_GPIOFLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOFLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB4LPENR_GPIOGLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOGLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB4LPENR_GPIOHLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOHLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB4LPENR_GPIOILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOILPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB4LPENR_GPIOJLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOJLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB4LPENR_GPIOKLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB4LPENR_GPIOKLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB4LPENR_CRCLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB4LPENR_CRCLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB4LPENR_BDMALPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB4LPENR_BDMALPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB4LPENR_ADC3LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAHB4LPENR_ADC3LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAHB4LPENR_BKPRAMLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAHB4LPENR_BKPRAMLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAHB4LPENR_SRAM4LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB4LPENR.Reg, volatile.LoadUint32(&o.AHB4LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB4LPENR_SRAM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB4LPENR.Reg) & 0x20000000) >> 29
}

// RCC.APB3LPENR: RCC APB3 Sleep Clock Register
func (o *RCC_Type) SetAPB3LPENR_LTDCLPEN(value uint32) {
	volatile.StoreUint32(&o.APB3LPENR.Reg, volatile.LoadUint32(&o.APB3LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB3LPENR_LTDCLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB3LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB3LPENR_WWDG1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB3LPENR.Reg, volatile.LoadUint32(&o.APB3LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB3LPENR_WWDG1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB3LPENR.Reg) & 0x40) >> 6
}

// RCC.APB1LLPENR: RCC APB1 Low Sleep Clock Register
func (o *RCC_Type) SetAPB1LLPENR_TIM2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM2LPEN() uint32 {
	return volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1LLPENR_TIM3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1LLPENR_TIM4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1LLPENR_TIM5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1LLPENR_TIM6LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM6LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1LLPENR_TIM7LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM7LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1LLPENR_TIM12LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM12LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1LLPENR_TIM13LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM13LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB1LLPENR_TIM14LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1LLPENR_TIM14LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1LLPENR_LPTIM1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB1LLPENR_LPTIM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB1LLPENR_SPI2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1LLPENR_SPI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1LLPENR_SPI3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1LLPENR_SPI3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1LLPENR_SPDIFRXLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB1LLPENR_SPDIFRXLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB1LLPENR_USART2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1LLPENR_USART2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1LLPENR_USART3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1LLPENR_USART3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1LLPENR_UART4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1LLPENR_UART4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1LLPENR_UART5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1LLPENR_UART5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1LLPENR_I2C1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1LLPENR_I2C1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1LLPENR_I2C2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1LLPENR_I2C2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1LLPENR_I2C3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1LLPENR_I2C3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1LLPENR_CECLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB1LLPENR_CECLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB1LLPENR_DAC12LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1LLPENR_DAC12LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1LLPENR_UART7LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1LLPENR_UART7LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1LLPENR_UART8LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1LLPENR_UART8LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1LLPENR_I2C5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LLPENR.Reg, volatile.LoadUint32(&o.APB1LLPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1LLPENR_I2C5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LLPENR.Reg) & 0x2000000) >> 25
}

// RCC.APB1HLPENR: RCC APB1 High Sleep Clock Register
func (o *RCC_Type) SetAPB1HLPENR_CRSLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1HLPENR_CRSLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1HLPENR_SWPMILPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1HLPENR_SWPMILPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1HLPENR_OPAMPLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1HLPENR_OPAMPLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1HLPENR_MDIOSLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1HLPENR_MDIOSLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1HLPENR_FDCANLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1HLPENR_FDCANLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1HLPENR_TIM23LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1HLPENR_TIM23LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1HLPENR_TIM24LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1HLPENR.Reg, volatile.LoadUint32(&o.APB1HLPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1HLPENR_TIM24LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1HLPENR.Reg) & 0x2000000) >> 25
}

// RCC.APB2LPENR: RCC APB2 Sleep Clock Register
func (o *RCC_Type) SetAPB2LPENR_TIM1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2LPENR_TIM1LPEN() uint32 {
	return volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2LPENR_TIM8LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB2LPENR_TIM8LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB2LPENR_USART1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2LPENR_USART1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2LPENR_USART6LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2LPENR_USART6LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2LPENR_SPI1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2LPENR_SPI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2LPENR_SPI4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2LPENR_SPI4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2LPENR_TIM15LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2LPENR_TIM15LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2LPENR_TIM16LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2LPENR_TIM16LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2LPENR_TIM17LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2LPENR_TIM17LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2LPENR_SPI5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB2LPENR_SPI5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB2LPENR_SAI1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2LPENR_SAI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2LPENR_SAI2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB2LPENR_SAI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB2LPENR_SAI3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB2LPENR_SAI3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB2LPENR_DFSDM1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB2LPENR_DFSDM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x10000000) >> 28
}

// RCC.APB4LPENR: RCC APB4 Sleep Clock Register
func (o *RCC_Type) SetAPB4LPENR_SYSCFGLPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB4LPENR_SYSCFGLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB4LPENR_LPUART1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB4LPENR_LPUART1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB4LPENR_SPI6LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB4LPENR_SPI6LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB4LPENR_I2C4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB4LPENR_I2C4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB4LPENR_LPTIM2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB4LPENR_LPTIM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB4LPENR_LPTIM3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB4LPENR_LPTIM3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB4LPENR_LPTIM4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB4LPENR_LPTIM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB4LPENR_LPTIM5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB4LPENR_LPTIM5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB4LPENR_COMP12LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB4LPENR_COMP12LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB4LPENR_VREFLPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB4LPENR_VREFLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB4LPENR_RTCAPBLPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB4LPENR_RTCAPBLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB4LPENR_SAI4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB4LPENR_SAI4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB4LPENR_DTSLPEN(value uint32) {
	volatile.StoreUint32(&o.APB4LPENR.Reg, volatile.LoadUint32(&o.APB4LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB4LPENR_DTSLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB4LPENR.Reg) & 0x4000000) >> 26
}

// RCC.C1_RSR: RCC Reset Status Register
func (o *RCC_Type) SetC1_RSR_RMVF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_RSR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_RSR_CPURSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_RSR_CPURSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_RSR_D1RSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetC1_RSR_D1RSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetC1_RSR_D2RSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetC1_RSR_D2RSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetC1_RSR_BORRSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_RSR_BORRSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_RSR_PINRSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetC1_RSR_PINRSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetC1_RSR_PORRSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetC1_RSR_PORRSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetC1_RSR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetC1_RSR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetC1_RSR_IWDG1RSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetC1_RSR_IWDG1RSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetC1_RSR_WWDG1RSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_RSR_WWDG1RSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetC1_RSR_LPWRRSTF(value uint32) {
	volatile.StoreUint32(&o.C1_RSR.Reg, volatile.LoadUint32(&o.C1_RSR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetC1_RSR_LPWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.C1_RSR.Reg) & 0x40000000) >> 30
}

// RCC.C1_AHB3ENR: RCC AHB3 Clock Register
func (o *RCC_Type) SetC1_AHB3ENR_MDMAEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3ENR.Reg, volatile.LoadUint32(&o.C1_AHB3ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB3ENR_MDMAEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB3ENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB3ENR_DMA2DEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3ENR.Reg, volatile.LoadUint32(&o.C1_AHB3ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_AHB3ENR_DMA2DEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_AHB3ENR_JPGDECEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3ENR.Reg, volatile.LoadUint32(&o.C1_AHB3ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB3ENR_JPGDECEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB3ENR_FMCEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3ENR.Reg, volatile.LoadUint32(&o.C1_AHB3ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetC1_AHB3ENR_FMCEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetC1_AHB3ENR_QSPIEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3ENR.Reg, volatile.LoadUint32(&o.C1_AHB3ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetC1_AHB3ENR_QSPIEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetC1_AHB3ENR_SDMMC1EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3ENR.Reg, volatile.LoadUint32(&o.C1_AHB3ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_AHB3ENR_SDMMC1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3ENR.Reg) & 0x10000) >> 16
}

// RCC.C1_AHB1ENR: RCC AHB1 Clock Register
func (o *RCC_Type) SetC1_AHB1ENR_DMA1EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB1ENR_DMA1EN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB1ENR_DMA2EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_AHB1ENR_DMA2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_AHB1ENR_ADC12EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB1ENR_ADC12EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB1ENR_ETH1MACEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetC1_AHB1ENR_ETH1MACEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetC1_AHB1ENR_ETH1TXEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_AHB1ENR_ETH1TXEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_AHB1ENR_ETH1RXEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_AHB1ENR_ETH1RXEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_AHB1ENR_USB1OTGEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetC1_AHB1ENR_USB1OTGEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetC1_AHB1ENR_USB1ULPIEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetC1_AHB1ENR_USB1ULPIEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetC1_AHB1ENR_USB2OTGEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetC1_AHB1ENR_USB2OTGEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetC1_AHB1ENR_USB2ULPIEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1ENR.Reg, volatile.LoadUint32(&o.C1_AHB1ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_AHB1ENR_USB2ULPIEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1ENR.Reg) & 0x10000000) >> 28
}

// RCC.C1_AHB2ENR: RCC AHB2 Clock Register
func (o *RCC_Type) SetC1_AHB2ENR_DCMIEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB2ENR_DCMIEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB2ENR_CRYPTEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_AHB2ENR_CRYPTEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_AHB2ENR_HASHEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB2ENR_HASHEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB2ENR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_AHB2ENR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetC1_AHB2ENR_SDMMC2EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_AHB2ENR_SDMMC2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_AHB2ENR_SRAM1EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_AHB2ENR_SRAM1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetC1_AHB2ENR_SRAM2EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetC1_AHB2ENR_SRAM2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetC1_AHB2ENR_SRAM3EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2ENR.Reg, volatile.LoadUint32(&o.C1_AHB2ENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetC1_AHB2ENR_SRAM3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2ENR.Reg) & 0x80000000) >> 31
}

// RCC.C1_AHB4ENR: RCC AHB4 Clock Register
func (o *RCC_Type) SetC1_AHB4ENR_GPIOAEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOAEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOBEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOBEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOCEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOCEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIODEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIODEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOEEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOEEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOFEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOFEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOGEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOGEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOHEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOHEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOIEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOIEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOJEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOJEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_AHB4ENR_GPIOKEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetC1_AHB4ENR_GPIOKEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetC1_AHB4ENR_CRCEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetC1_AHB4ENR_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetC1_AHB4ENR_BDMAEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_AHB4ENR_BDMAEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_AHB4ENR_ADC3EN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetC1_AHB4ENR_ADC3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetC1_AHB4ENR_HSEMEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetC1_AHB4ENR_HSEMEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetC1_AHB4ENR_BKPRAMEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4ENR.Reg, volatile.LoadUint32(&o.C1_AHB4ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_AHB4ENR_BKPRAMEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4ENR.Reg) & 0x10000000) >> 28
}

// RCC.C1_APB3ENR: RCC APB3 Clock Register
func (o *RCC_Type) SetC1_APB3ENR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB3ENR.Reg, volatile.LoadUint32(&o.C1_APB3ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_APB3ENR_LTDCEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB3ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_APB3ENR_WWDG1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB3ENR.Reg, volatile.LoadUint32(&o.C1_APB3ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_APB3ENR_WWDG1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB3ENR.Reg) & 0x40) >> 6
}

// RCC.C1_APB1LENR: RCC APB1 Clock Register
func (o *RCC_Type) SetC1_APB1LENR_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_APB1LENR_TIM3EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB1LENR_TIM4EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM4EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetC1_APB1LENR_TIM5EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM5EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_APB1LENR_TIM6EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM6EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_APB1LENR_TIM7EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM7EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB1LENR_TIM12EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM12EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetC1_APB1LENR_TIM13EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM13EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetC1_APB1LENR_TIM14EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_APB1LENR_TIM14EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetC1_APB1LENR_LPTIM1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_APB1LENR_LPTIM1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_APB1LENR_SPI2EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetC1_APB1LENR_SPI2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetC1_APB1LENR_SPI3EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetC1_APB1LENR_SPI3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetC1_APB1LENR_SPDIFRXEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_APB1LENR_SPDIFRXEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_APB1LENR_USART2EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_APB1LENR_USART2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_APB1LENR_USART3EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetC1_APB1LENR_USART3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetC1_APB1LENR_UART4EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetC1_APB1LENR_UART4EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetC1_APB1LENR_UART5EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetC1_APB1LENR_UART5EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetC1_APB1LENR_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_APB1LENR_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_APB1LENR_I2C2EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetC1_APB1LENR_I2C2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetC1_APB1LENR_I2C3EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetC1_APB1LENR_I2C3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetC1_APB1LENR_CECEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetC1_APB1LENR_CECEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetC1_APB1LENR_DAC12EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_APB1LENR_DAC12EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetC1_APB1LENR_UART7EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetC1_APB1LENR_UART7EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetC1_APB1LENR_UART8EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LENR.Reg, volatile.LoadUint32(&o.C1_APB1LENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetC1_APB1LENR_UART8EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LENR.Reg) & 0x80000000) >> 31
}

// RCC.C1_APB1HENR: RCC APB1 Clock Register
func (o *RCC_Type) SetC1_APB1HENR_CRSEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HENR.Reg, volatile.LoadUint32(&o.C1_APB1HENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB1HENR_CRSEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB1HENR_SWPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HENR.Reg, volatile.LoadUint32(&o.C1_APB1HENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetC1_APB1HENR_SWPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetC1_APB1HENR_OPAMPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HENR.Reg, volatile.LoadUint32(&o.C1_APB1HENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_APB1HENR_OPAMPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_APB1HENR_MDIOSEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HENR.Reg, volatile.LoadUint32(&o.C1_APB1HENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB1HENR_MDIOSEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB1HENR_FDCANEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HENR.Reg, volatile.LoadUint32(&o.C1_APB1HENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_APB1HENR_FDCANEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HENR.Reg) & 0x100) >> 8
}

// RCC.C1_APB2ENR: RCC APB2 Clock Register
func (o *RCC_Type) SetC1_APB2ENR_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_APB2ENR_TIM1EN() uint32 {
	return volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_APB2ENR_TIM8EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB2ENR_TIM8EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB2ENR_USART1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_APB2ENR_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_APB2ENR_USART6EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB2ENR_USART6EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB2ENR_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetC1_APB2ENR_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetC1_APB2ENR_SPI4EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetC1_APB2ENR_SPI4EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetC1_APB2ENR_TIM16EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_APB2ENR_TIM16EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_APB2ENR_TIM15EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_APB2ENR_TIM15EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_APB2ENR_TIM17EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetC1_APB2ENR_TIM17EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetC1_APB2ENR_SPI5EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetC1_APB2ENR_SPI5EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetC1_APB2ENR_SAI1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetC1_APB2ENR_SAI1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetC1_APB2ENR_SAI2EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetC1_APB2ENR_SAI2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetC1_APB2ENR_SAI3EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetC1_APB2ENR_SAI3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetC1_APB2ENR_DFSDM1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_APB2ENR_DFSDM1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetC1_APB2ENR_HRTIMEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2ENR.Reg, volatile.LoadUint32(&o.C1_APB2ENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_APB2ENR_HRTIMEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2ENR.Reg) & 0x20000000) >> 29
}

// RCC.C1_APB4ENR: RCC APB4 Clock Register
func (o *RCC_Type) SetC1_APB4ENR_SYSCFGEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB4ENR_SYSCFGEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB4ENR_LPUART1EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_APB4ENR_LPUART1EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_APB4ENR_SPI6EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB4ENR_SPI6EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB4ENR_I2C4EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetC1_APB4ENR_I2C4EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetC1_APB4ENR_LPTIM2EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_APB4ENR_LPTIM2EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_APB4ENR_LPTIM3EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetC1_APB4ENR_LPTIM3EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetC1_APB4ENR_LPTIM4EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetC1_APB4ENR_LPTIM4EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetC1_APB4ENR_LPTIM5EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetC1_APB4ENR_LPTIM5EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetC1_APB4ENR_COMP12EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetC1_APB4ENR_COMP12EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetC1_APB4ENR_VREFEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetC1_APB4ENR_VREFEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetC1_APB4ENR_RTCAPBEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_APB4ENR_RTCAPBEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_APB4ENR_SAI4EN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4ENR.Reg, volatile.LoadUint32(&o.C1_APB4ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_APB4ENR_SAI4EN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4ENR.Reg) & 0x200000) >> 21
}

// RCC.C1_AHB3LPENR: RCC AHB3 Sleep Clock Register
func (o *RCC_Type) SetC1_AHB3LPENR_MDMALPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB3LPENR_MDMALPEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB3LPENR_DMA2DLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_AHB3LPENR_DMA2DLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_AHB3LPENR_FLASHPREN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_AHB3LPENR_FLASHPREN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetC1_AHB3LPENR_FMCLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetC1_AHB3LPENR_FMCLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetC1_AHB3LPENR_SDMMC1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_AHB3LPENR_SDMMC1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_AHB3LPENR_D1DTCM1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_AHB3LPENR_D1DTCM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetC1_AHB3LPENR_DTCM2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_AHB3LPENR_DTCM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetC1_AHB3LPENR_ITCMLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetC1_AHB3LPENR_ITCMLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetC1_AHB3LPENR_AXISRAMLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetC1_AHB3LPENR_AXISRAMLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetC1_AHB3LPENR_OCTOSPI1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetC1_AHB3LPENR_OCTOSPI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetC1_AHB3LPENR_OCTOSPI2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetC1_AHB3LPENR_OCTOSPI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetC1_AHB3LPENR_IOMNGRLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_AHB3LPENR_IOMNGRLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_AHB3LPENR_OTFD1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetC1_AHB3LPENR_OTFD1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetC1_AHB3LPENR_OTFD2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB3LPENR.Reg, volatile.LoadUint32(&o.C1_AHB3LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetC1_AHB3LPENR_OTFD2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB3LPENR.Reg) & 0x800000) >> 23
}

// RCC.C1_AHB1LPENR: RCC AHB1 Sleep Clock Register
func (o *RCC_Type) SetC1_AHB1LPENR_DMA1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB1LPENR_DMA1LPEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB1LPENR_DMA2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_AHB1LPENR_DMA2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_AHB1LPENR_ADC12LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB1LPENR_ADC12LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB1LPENR_ETH1MACLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetC1_AHB1LPENR_ETH1MACLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetC1_AHB1LPENR_ETH1TXLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_AHB1LPENR_ETH1TXLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_AHB1LPENR_ETH1RXLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_AHB1LPENR_ETH1RXLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_AHB1LPENR_USB1OTGLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetC1_AHB1LPENR_USB1OTGLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetC1_AHB1LPENR_USB1ULPILPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB1LPENR.Reg, volatile.LoadUint32(&o.C1_AHB1LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetC1_AHB1LPENR_USB1ULPILPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB1LPENR.Reg) & 0x4000000) >> 26
}

// RCC.C1_AHB2LPENR: RCC AHB2 Sleep Clock Register
func (o *RCC_Type) SetC1_AHB2LPENR_DCMILPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB2LPENR_DCMILPEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB2LPENR_CRYPTLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_AHB2LPENR_CRYPTLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_AHB2LPENR_HASHLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB2LPENR_HASHLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB2LPENR_SDMMC2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_AHB2LPENR_SDMMC2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_AHB2LPENR_RNGLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_AHB2LPENR_RNGLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetC1_AHB2LPENR_SRAM1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_AHB2LPENR_SRAM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetC1_AHB2LPENR_SRAM2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetC1_AHB2LPENR_SRAM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetC1_AHB2LPENR_FMACLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_AHB2LPENR_FMACLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_AHB2LPENR_CORDICLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB2LPENR.Reg, volatile.LoadUint32(&o.C1_AHB2LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_AHB2LPENR_CORDICLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB2LPENR.Reg) & 0x20000) >> 17
}

// RCC.C1_AHB4LPENR: RCC AHB4 Sleep Clock Register
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOALPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOALPEN() uint32 {
	return volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOBLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOBLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOCLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOCLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIODLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIODLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOELPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOELPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOFLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOFLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOGLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOGLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOHLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOHLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOILPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOILPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOJLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOJLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_AHB4LPENR_GPIOKLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetC1_AHB4LPENR_GPIOKLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetC1_AHB4LPENR_CRCLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetC1_AHB4LPENR_CRCLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetC1_AHB4LPENR_BDMALPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_AHB4LPENR_BDMALPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_AHB4LPENR_ADC3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetC1_AHB4LPENR_ADC3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetC1_AHB4LPENR_BKPRAMLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_AHB4LPENR_BKPRAMLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetC1_AHB4LPENR_SRAM4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_AHB4LPENR.Reg, volatile.LoadUint32(&o.C1_AHB4LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_AHB4LPENR_SRAM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_AHB4LPENR.Reg) & 0x20000000) >> 29
}

// RCC.C1_APB3LPENR: RCC APB3 Sleep Clock Register
func (o *RCC_Type) SetC1_APB3LPENR_LTDCLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB3LPENR.Reg, volatile.LoadUint32(&o.C1_APB3LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_APB3LPENR_LTDCLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB3LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_APB3LPENR_WWDG1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB3LPENR.Reg, volatile.LoadUint32(&o.C1_APB3LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_APB3LPENR_WWDG1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB3LPENR.Reg) & 0x40) >> 6
}

// RCC.C1_APB1LLPENR: RCC APB1 Low Sleep Clock Register
func (o *RCC_Type) SetC1_APB1LLPENR_TIM2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM2LPEN() uint32 {
	return volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM5LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM5LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM6LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM6LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM7LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM7LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM12LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM12LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM13LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM13LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetC1_APB1LLPENR_TIM14LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_APB1LLPENR_TIM14LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetC1_APB1LLPENR_LPTIM1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_APB1LLPENR_LPTIM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_APB1LLPENR_SPI2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetC1_APB1LLPENR_SPI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetC1_APB1LLPENR_SPI3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetC1_APB1LLPENR_SPI3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetC1_APB1LLPENR_SPDIFRXLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_APB1LLPENR_SPDIFRXLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_APB1LLPENR_USART2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_APB1LLPENR_USART2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_APB1LLPENR_USART3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetC1_APB1LLPENR_USART3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetC1_APB1LLPENR_UART4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetC1_APB1LLPENR_UART4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetC1_APB1LLPENR_UART5LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetC1_APB1LLPENR_UART5LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetC1_APB1LLPENR_I2C1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_APB1LLPENR_I2C1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_APB1LLPENR_I2C2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetC1_APB1LLPENR_I2C2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetC1_APB1LLPENR_I2C3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetC1_APB1LLPENR_I2C3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetC1_APB1LLPENR_CECLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetC1_APB1LLPENR_CECLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetC1_APB1LLPENR_DAC12LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetC1_APB1LLPENR_DAC12LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetC1_APB1LLPENR_UART7LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetC1_APB1LLPENR_UART7LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetC1_APB1LLPENR_UART8LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetC1_APB1LLPENR_UART8LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetC1_APB1LLPENR_I2C5LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1LLPENR.Reg, volatile.LoadUint32(&o.C1_APB1LLPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetC1_APB1LLPENR_I2C5LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1LLPENR.Reg) & 0x2000000) >> 25
}

// RCC.C1_APB1HLPENR: RCC APB1 High Sleep Clock Register
func (o *RCC_Type) SetC1_APB1HLPENR_CRSLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB1HLPENR_CRSLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB1HLPENR_SWPMILPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetC1_APB1HLPENR_SWPMILPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetC1_APB1HLPENR_OPAMPLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_APB1HLPENR_OPAMPLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_APB1HLPENR_MDIOSLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB1HLPENR_MDIOSLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB1HLPENR_FDCANLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetC1_APB1HLPENR_FDCANLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetC1_APB1HLPENR_TIM23LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetC1_APB1HLPENR_TIM23LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetC1_APB1HLPENR_TIM24LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB1HLPENR.Reg, volatile.LoadUint32(&o.C1_APB1HLPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetC1_APB1HLPENR_TIM24LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB1HLPENR.Reg) & 0x2000000) >> 25
}

// RCC.C1_APB2LPENR: RCC APB2 Sleep Clock Register
func (o *RCC_Type) SetC1_APB2LPENR_TIM1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetC1_APB2LPENR_TIM1LPEN() uint32 {
	return volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetC1_APB2LPENR_TIM8LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB2LPENR_TIM8LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB2LPENR_USART1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetC1_APB2LPENR_USART1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetC1_APB2LPENR_USART6LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB2LPENR_USART6LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB2LPENR_SPI1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetC1_APB2LPENR_SPI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetC1_APB2LPENR_SPI4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetC1_APB2LPENR_SPI4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetC1_APB2LPENR_TIM15LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_APB2LPENR_TIM15LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_APB2LPENR_TIM16LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetC1_APB2LPENR_TIM16LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetC1_APB2LPENR_TIM17LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetC1_APB2LPENR_TIM17LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetC1_APB2LPENR_SPI5LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetC1_APB2LPENR_SPI5LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetC1_APB2LPENR_SAI1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetC1_APB2LPENR_SAI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetC1_APB2LPENR_SAI2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetC1_APB2LPENR_SAI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetC1_APB2LPENR_SAI3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetC1_APB2LPENR_SAI3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetC1_APB2LPENR_DFSDM1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB2LPENR.Reg, volatile.LoadUint32(&o.C1_APB2LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetC1_APB2LPENR_DFSDM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB2LPENR.Reg) & 0x10000000) >> 28
}

// RCC.C1_APB4LPENR: RCC APB4 Sleep Clock Register
func (o *RCC_Type) SetC1_APB4LPENR_SYSCFGLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetC1_APB4LPENR_SYSCFGLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetC1_APB4LPENR_LPUART1LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetC1_APB4LPENR_LPUART1LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetC1_APB4LPENR_SPI6LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetC1_APB4LPENR_SPI6LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetC1_APB4LPENR_I2C4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetC1_APB4LPENR_I2C4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetC1_APB4LPENR_LPTIM2LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetC1_APB4LPENR_LPTIM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetC1_APB4LPENR_LPTIM3LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetC1_APB4LPENR_LPTIM3LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetC1_APB4LPENR_LPTIM4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetC1_APB4LPENR_LPTIM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetC1_APB4LPENR_LPTIM5LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetC1_APB4LPENR_LPTIM5LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetC1_APB4LPENR_COMP12LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetC1_APB4LPENR_COMP12LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetC1_APB4LPENR_VREFLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetC1_APB4LPENR_VREFLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetC1_APB4LPENR_RTCAPBLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetC1_APB4LPENR_RTCAPBLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetC1_APB4LPENR_SAI4LPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetC1_APB4LPENR_SAI4LPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetC1_APB4LPENR_DTSLPEN(value uint32) {
	volatile.StoreUint32(&o.C1_APB4LPENR.Reg, volatile.LoadUint32(&o.C1_APB4LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetC1_APB4LPENR_DTSLPEN() uint32 {
	return (volatile.LoadUint32(&o.C1_APB4LPENR.Reg) & 0x4000000) >> 26
}

// RNG
type RNG_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	DR volatile.Register32 // 0x8
}

// RNG.CR: RNG control register
func (o *RNG_Type) SetCR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetCR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetCR_IE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetCR_IE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetCR_CED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RNG_Type) GetCR_CED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}

// RNG.SR: RNG status register
func (o *RNG_Type) SetSR_DRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSR_DRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RNG_Type) SetSR_CECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetSR_CECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetSR_SECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetSR_SECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetSR_CEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RNG_Type) GetSR_CEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *RNG_Type) SetSR_SEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *RNG_Type) GetSR_SEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}

// RNG.DR: The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.
func (o *RNG_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *RNG_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// RTC
type RTC_Type struct {
	TR       volatile.Register32 // 0x0
	DR       volatile.Register32 // 0x4
	CR       volatile.Register32 // 0x8
	ISR      volatile.Register32 // 0xC
	PRER     volatile.Register32 // 0x10
	WUTR     volatile.Register32 // 0x14
	_        [4]byte
	ALRMAR   volatile.Register32 // 0x1C
	ALRMBR   volatile.Register32 // 0x20
	WPR      volatile.Register32 // 0x24
	SSR      volatile.Register32 // 0x28
	SHIFTR   volatile.Register32 // 0x2C
	TSTR     volatile.Register32 // 0x30
	TSDR     volatile.Register32 // 0x34
	TSSSR    volatile.Register32 // 0x38
	CALR     volatile.Register32 // 0x3C
	TAMPCR   volatile.Register32 // 0x40
	ALRMASSR volatile.Register32 // 0x44
	ALRMBSSR volatile.Register32 // 0x48
	OR       volatile.Register32 // 0x4C
	BKP0R    volatile.Register32 // 0x50
	BKP1R    volatile.Register32 // 0x54
	BKP2R    volatile.Register32 // 0x58
	BKP3R    volatile.Register32 // 0x5C
	BKP4R    volatile.Register32 // 0x60
	BKP5R    volatile.Register32 // 0x64
	BKP6R    volatile.Register32 // 0x68
	BKP7R    volatile.Register32 // 0x6C
	BKP8R    volatile.Register32 // 0x70
	BKP9R    volatile.Register32 // 0x74
	BKP10R   volatile.Register32 // 0x78
	BKP11R   volatile.Register32 // 0x7C
	BKP12R   volatile.Register32 // 0x80
	BKP13R   volatile.Register32 // 0x84
	BKP14R   volatile.Register32 // 0x88
	BKP15R   volatile.Register32 // 0x8C
	BKP16R   volatile.Register32 // 0x90
	BKP17R   volatile.Register32 // 0x94
	BKP18R   volatile.Register32 // 0x98
	BKP19R   volatile.Register32 // 0x9C
	BKP20R   volatile.Register32 // 0xA0
	BKP21R   volatile.Register32 // 0xA4
	BKP22R   volatile.Register32 // 0xA8
	BKP23R   volatile.Register32 // 0xAC
	BKP24R   volatile.Register32 // 0xB0
	BKP25R   volatile.Register32 // 0xB4
	BKP26R   volatile.Register32 // 0xB8
	BKP27R   volatile.Register32 // 0xBC
	BKP28R   volatile.Register32 // 0xC0
	BKP29R   volatile.Register32 // 0xC4
	BKP30R   volatile.Register32 // 0xC8
	BKP31R   volatile.Register32 // 0xCC
}

// RTC.TR: The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetTR_SU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTR_SU() uint32 {
	return volatile.LoadUint32(&o.TR.Reg) & 0xf
}
func (o *RTC_Type) SetTR_ST(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTR_HU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTR_HT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTR_PM(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x400000) >> 22
}

// RTC.DR: The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetDR_DU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetDR_DU() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xf
}
func (o *RTC_Type) SetDR_DT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetDR_DT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetDR_MU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetDR_MU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetDR_MT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetDR_MT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetDR_WDU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetDR_YU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetDR_YU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetDR_YT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00000)|value<<20)
}
func (o *RTC_Type) GetDR_YT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00000) >> 20
}

// RTC.CR: RTC control register
func (o *RTC_Type) SetCR_WUCKSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetCR_WUCKSEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7
}
func (o *RTC_Type) SetCR_TSEDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_TSEDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_REFCKON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_REFCKON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_BYPSHAD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCR_BYPSHAD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCR_FMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCR_FMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCR_ALRAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_ALRAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_ALRBE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_ALRBE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_WUTE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_WUTE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_TSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_TSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_ALRAIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_ALRAIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_ALRBIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_ALRBIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCR_WUTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCR_WUTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCR_TSIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCR_TSIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCR_ADD1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetCR_ADD1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetCR_SUB1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCR_SUB1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetCR_BKP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetCR_BKP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetCR_COSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetCR_COSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetCR_POL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetCR_POL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetCR_OSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_Type) GetCR_OSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *RTC_Type) SetCR_COE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCR_COE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCR_ITSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetCR_ITSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// RTC.ISR: This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetISR_ALRAWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetISR_ALRAWF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *RTC_Type) SetISR_ALRBWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetISR_ALRBWF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetISR_WUTWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetISR_WUTWF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetISR_SHPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetISR_SHPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetISR_INITS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetISR_INITS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetISR_RSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetISR_RSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetISR_INITF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetISR_INITF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetISR_INIT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetISR_INIT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetISR_ALRAF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetISR_ALRAF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetISR_ALRBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetISR_ALRBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetISR_WUTF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetISR_WUTF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetISR_TSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetISR_TSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetISR_TSOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetISR_TSOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetISR_TAMP1F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetISR_TAMP1F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetISR_TAMP2F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetISR_TAMP2F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetISR_TAMP3F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetISR_TAMP3F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetISR_RECALPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetISR_RECALPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetISR_ITSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetISR_ITSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}

// RTC.PRER: This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetPRER_PREDIV_S(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetPRER_PREDIV_S() uint32 {
	return volatile.LoadUint32(&o.PRER.Reg) & 0x7fff
}
func (o *RTC_Type) SetPRER_PREDIV_A(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7f0000)|value<<16)
}
func (o *RTC_Type) GetPRER_PREDIV_A() uint32 {
	return (volatile.LoadUint32(&o.PRER.Reg) & 0x7f0000) >> 16
}

// RTC.WUTR: This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetWUTR_WUT(value uint32) {
	volatile.StoreUint32(&o.WUTR.Reg, volatile.LoadUint32(&o.WUTR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetWUTR_WUT() uint32 {
	return volatile.LoadUint32(&o.WUTR.Reg) & 0xffff
}

// RTC.ALRMAR: This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetALRMAR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMAR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf
}
func (o *RTC_Type) SetALRMAR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMAR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMAR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMAR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMAR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMAR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMAR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMAR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMAR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMAR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMAR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMAR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMAR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMAR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMAR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMAR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMAR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMAR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMAR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMAR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMAR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMAR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMAR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMAR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMAR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMAR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80000000) >> 31
}

// RTC.ALRMBR: This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetALRMBR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMBR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf
}
func (o *RTC_Type) SetALRMBR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMBR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMBR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMBR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMBR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMBR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMBR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMBR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMBR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMBR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMBR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMBR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMBR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMBR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMBR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMBR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMBR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMBR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMBR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMBR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMBR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMBR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMBR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMBR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80000000) >> 31
}

// RTC.WPR: RTC write protection register
func (o *RTC_Type) SetWPR_KEY(value uint32) {
	volatile.StoreUint32(&o.WPR.Reg, volatile.LoadUint32(&o.WPR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetWPR_KEY() uint32 {
	return volatile.LoadUint32(&o.WPR.Reg) & 0xff
}

// RTC.SSR: RTC sub second register
func (o *RTC_Type) SetSSR_SS(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetSSR_SS() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0xffff
}

// RTC.SHIFTR: This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetSHIFTR_SUBFS(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetSHIFTR_SUBFS() uint32 {
	return volatile.LoadUint32(&o.SHIFTR.Reg) & 0x7fff
}
func (o *RTC_Type) SetSHIFTR_ADD1S(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSHIFTR_ADD1S() uint32 {
	return (volatile.LoadUint32(&o.SHIFTR.Reg) & 0x80000000) >> 31
}

// RTC.TSTR: The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
func (o *RTC_Type) SetTSTR_SU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSTR_SU() uint32 {
	return volatile.LoadUint32(&o.TSTR.Reg) & 0xf
}
func (o *RTC_Type) SetTSTR_ST(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTSTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTSTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTSTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTSTR_HU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTSTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTSTR_HT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTSTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTSTR_PM(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTSTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x400000) >> 22
}

// RTC.TSDR: The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
func (o *RTC_Type) SetTSDR_DU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSDR_DU() uint32 {
	return volatile.LoadUint32(&o.TSDR.Reg) & 0xf
}
func (o *RTC_Type) SetTSDR_DT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetTSDR_DT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetTSDR_MU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSDR_MU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSDR_MT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetTSDR_MT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetTSDR_WDU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetTSDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xe000) >> 13
}

// RTC.TSSSR: The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
func (o *RTC_Type) SetTSSSR_SS(value uint32) {
	volatile.StoreUint32(&o.TSSSR.Reg, volatile.LoadUint32(&o.TSSSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetTSSSR_SS() uint32 {
	return volatile.LoadUint32(&o.TSSSR.Reg) & 0xffff
}

// RTC.CALR: This register is write protected. The write access procedure is described in RTC register write protection on page9.
func (o *RTC_Type) SetCALR_CALM(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetCALR_CALM() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x1ff
}
func (o *RTC_Type) SetCALR_CALW16(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCALR_CALW16() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCALR_CALW8(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCALR_CALW8() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCALR_CALP(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCALR_CALP() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x8000) >> 15
}

// RTC.TAMPCR: RTC tamper and alternate function configuration register
func (o *RTC_Type) SetTAMPCR_TAMP1E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTAMPCR_TAMP1E() uint32 {
	return volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1
}
func (o *RTC_Type) SetTAMPCR_TAMP1TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetTAMPCR_TAMP1TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetTAMPCR_TAMPIE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetTAMPCR_TAMPIE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetTAMPCR_TAMP2E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetTAMPCR_TAMP2E() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetTAMPCR_TAMP2TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetTAMPCR_TAMP2TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetTAMPCR_TAMP3E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetTAMPCR_TAMP3E() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetTAMPCR_TAMP3TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetTAMPCR_TAMP3TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetTAMPCR_TAMPTS(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetTAMPCR_TAMPTS() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetTAMPCR_TAMPFREQ(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x700)|value<<8)
}
func (o *RTC_Type) GetTAMPCR_TAMPFREQ() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x700) >> 8
}
func (o *RTC_Type) SetTAMPCR_TAMPFLT(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1800)|value<<11)
}
func (o *RTC_Type) GetTAMPCR_TAMPFLT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1800) >> 11
}
func (o *RTC_Type) SetTAMPCR_TAMPPRCH(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x6000)|value<<13)
}
func (o *RTC_Type) GetTAMPCR_TAMPPRCH() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x6000) >> 13
}
func (o *RTC_Type) SetTAMPCR_TAMPPUDIS(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetTAMPCR_TAMPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetTAMPCR_TAMP1IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetTAMPCR_TAMP1IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetTAMPCR_TAMP1NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetTAMPCR_TAMP1NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetTAMPCR_TAMP1MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetTAMPCR_TAMP1MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetTAMPCR_TAMP2IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetTAMPCR_TAMP2IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetTAMPCR_TAMP2NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetTAMPCR_TAMP2NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetTAMPCR_TAMP2MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_Type) GetTAMPCR_TAMP2MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x200000) >> 21
}
func (o *RTC_Type) SetTAMPCR_TAMP3IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTAMPCR_TAMP3IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTAMPCR_TAMP3NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetTAMPCR_TAMP3NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetTAMPCR_TAMP3MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetTAMPCR_TAMP3MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1000000) >> 24
}

// RTC.ALRMASSR: This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
func (o *RTC_Type) SetALRMASSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMASSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x7fff
}
func (o *RTC_Type) SetALRMASSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMASSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMASSR.Reg) & 0xf000000) >> 24
}

// RTC.ALRMBSSR: This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
func (o *RTC_Type) SetALRMBSSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMBSSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x7fff
}
func (o *RTC_Type) SetALRMBSSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBSSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0xf000000) >> 24
}

// RTC.OR: RTC option register
func (o *RTC_Type) SetOR_RTC_ALARM_TYPE(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetOR_RTC_ALARM_TYPE() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x1
}
func (o *RTC_Type) SetOR_RTC_OUT_RMP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetOR_RTC_OUT_RMP() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0x2) >> 1
}

// RTC.BKP0R: RTC backup registers
func (o *RTC_Type) SetBKP0R(value uint32) {
	volatile.StoreUint32(&o.BKP0R.Reg, value)
}
func (o *RTC_Type) GetBKP0R() uint32 {
	return volatile.LoadUint32(&o.BKP0R.Reg)
}

// RTC.BKP1R: RTC backup registers
func (o *RTC_Type) SetBKP1R(value uint32) {
	volatile.StoreUint32(&o.BKP1R.Reg, value)
}
func (o *RTC_Type) GetBKP1R() uint32 {
	return volatile.LoadUint32(&o.BKP1R.Reg)
}

// RTC.BKP2R: RTC backup registers
func (o *RTC_Type) SetBKP2R(value uint32) {
	volatile.StoreUint32(&o.BKP2R.Reg, value)
}
func (o *RTC_Type) GetBKP2R() uint32 {
	return volatile.LoadUint32(&o.BKP2R.Reg)
}

// RTC.BKP3R: RTC backup registers
func (o *RTC_Type) SetBKP3R(value uint32) {
	volatile.StoreUint32(&o.BKP3R.Reg, value)
}
func (o *RTC_Type) GetBKP3R() uint32 {
	return volatile.LoadUint32(&o.BKP3R.Reg)
}

// RTC.BKP4R: RTC backup registers
func (o *RTC_Type) SetBKP4R(value uint32) {
	volatile.StoreUint32(&o.BKP4R.Reg, value)
}
func (o *RTC_Type) GetBKP4R() uint32 {
	return volatile.LoadUint32(&o.BKP4R.Reg)
}

// RTC.BKP5R: RTC backup registers
func (o *RTC_Type) SetBKP5R(value uint32) {
	volatile.StoreUint32(&o.BKP5R.Reg, value)
}
func (o *RTC_Type) GetBKP5R() uint32 {
	return volatile.LoadUint32(&o.BKP5R.Reg)
}

// RTC.BKP6R: RTC backup registers
func (o *RTC_Type) SetBKP6R(value uint32) {
	volatile.StoreUint32(&o.BKP6R.Reg, value)
}
func (o *RTC_Type) GetBKP6R() uint32 {
	return volatile.LoadUint32(&o.BKP6R.Reg)
}

// RTC.BKP7R: RTC backup registers
func (o *RTC_Type) SetBKP7R(value uint32) {
	volatile.StoreUint32(&o.BKP7R.Reg, value)
}
func (o *RTC_Type) GetBKP7R() uint32 {
	return volatile.LoadUint32(&o.BKP7R.Reg)
}

// RTC.BKP8R: RTC backup registers
func (o *RTC_Type) SetBKP8R(value uint32) {
	volatile.StoreUint32(&o.BKP8R.Reg, value)
}
func (o *RTC_Type) GetBKP8R() uint32 {
	return volatile.LoadUint32(&o.BKP8R.Reg)
}

// RTC.BKP9R: RTC backup registers
func (o *RTC_Type) SetBKP9R(value uint32) {
	volatile.StoreUint32(&o.BKP9R.Reg, value)
}
func (o *RTC_Type) GetBKP9R() uint32 {
	return volatile.LoadUint32(&o.BKP9R.Reg)
}

// RTC.BKP10R: RTC backup registers
func (o *RTC_Type) SetBKP10R(value uint32) {
	volatile.StoreUint32(&o.BKP10R.Reg, value)
}
func (o *RTC_Type) GetBKP10R() uint32 {
	return volatile.LoadUint32(&o.BKP10R.Reg)
}

// RTC.BKP11R: RTC backup registers
func (o *RTC_Type) SetBKP11R(value uint32) {
	volatile.StoreUint32(&o.BKP11R.Reg, value)
}
func (o *RTC_Type) GetBKP11R() uint32 {
	return volatile.LoadUint32(&o.BKP11R.Reg)
}

// RTC.BKP12R: RTC backup registers
func (o *RTC_Type) SetBKP12R(value uint32) {
	volatile.StoreUint32(&o.BKP12R.Reg, value)
}
func (o *RTC_Type) GetBKP12R() uint32 {
	return volatile.LoadUint32(&o.BKP12R.Reg)
}

// RTC.BKP13R: RTC backup registers
func (o *RTC_Type) SetBKP13R(value uint32) {
	volatile.StoreUint32(&o.BKP13R.Reg, value)
}
func (o *RTC_Type) GetBKP13R() uint32 {
	return volatile.LoadUint32(&o.BKP13R.Reg)
}

// RTC.BKP14R: RTC backup registers
func (o *RTC_Type) SetBKP14R(value uint32) {
	volatile.StoreUint32(&o.BKP14R.Reg, value)
}
func (o *RTC_Type) GetBKP14R() uint32 {
	return volatile.LoadUint32(&o.BKP14R.Reg)
}

// RTC.BKP15R: RTC backup registers
func (o *RTC_Type) SetBKP15R(value uint32) {
	volatile.StoreUint32(&o.BKP15R.Reg, value)
}
func (o *RTC_Type) GetBKP15R() uint32 {
	return volatile.LoadUint32(&o.BKP15R.Reg)
}

// RTC.BKP16R: RTC backup registers
func (o *RTC_Type) SetBKP16R(value uint32) {
	volatile.StoreUint32(&o.BKP16R.Reg, value)
}
func (o *RTC_Type) GetBKP16R() uint32 {
	return volatile.LoadUint32(&o.BKP16R.Reg)
}

// RTC.BKP17R: RTC backup registers
func (o *RTC_Type) SetBKP17R(value uint32) {
	volatile.StoreUint32(&o.BKP17R.Reg, value)
}
func (o *RTC_Type) GetBKP17R() uint32 {
	return volatile.LoadUint32(&o.BKP17R.Reg)
}

// RTC.BKP18R: RTC backup registers
func (o *RTC_Type) SetBKP18R(value uint32) {
	volatile.StoreUint32(&o.BKP18R.Reg, value)
}
func (o *RTC_Type) GetBKP18R() uint32 {
	return volatile.LoadUint32(&o.BKP18R.Reg)
}

// RTC.BKP19R: RTC backup registers
func (o *RTC_Type) SetBKP19R(value uint32) {
	volatile.StoreUint32(&o.BKP19R.Reg, value)
}
func (o *RTC_Type) GetBKP19R() uint32 {
	return volatile.LoadUint32(&o.BKP19R.Reg)
}

// RTC.BKP20R: RTC backup registers
func (o *RTC_Type) SetBKP20R(value uint32) {
	volatile.StoreUint32(&o.BKP20R.Reg, value)
}
func (o *RTC_Type) GetBKP20R() uint32 {
	return volatile.LoadUint32(&o.BKP20R.Reg)
}

// RTC.BKP21R: RTC backup registers
func (o *RTC_Type) SetBKP21R(value uint32) {
	volatile.StoreUint32(&o.BKP21R.Reg, value)
}
func (o *RTC_Type) GetBKP21R() uint32 {
	return volatile.LoadUint32(&o.BKP21R.Reg)
}

// RTC.BKP22R: RTC backup registers
func (o *RTC_Type) SetBKP22R(value uint32) {
	volatile.StoreUint32(&o.BKP22R.Reg, value)
}
func (o *RTC_Type) GetBKP22R() uint32 {
	return volatile.LoadUint32(&o.BKP22R.Reg)
}

// RTC.BKP23R: RTC backup registers
func (o *RTC_Type) SetBKP23R(value uint32) {
	volatile.StoreUint32(&o.BKP23R.Reg, value)
}
func (o *RTC_Type) GetBKP23R() uint32 {
	return volatile.LoadUint32(&o.BKP23R.Reg)
}

// RTC.BKP24R: RTC backup registers
func (o *RTC_Type) SetBKP24R(value uint32) {
	volatile.StoreUint32(&o.BKP24R.Reg, value)
}
func (o *RTC_Type) GetBKP24R() uint32 {
	return volatile.LoadUint32(&o.BKP24R.Reg)
}

// RTC.BKP25R: RTC backup registers
func (o *RTC_Type) SetBKP25R(value uint32) {
	volatile.StoreUint32(&o.BKP25R.Reg, value)
}
func (o *RTC_Type) GetBKP25R() uint32 {
	return volatile.LoadUint32(&o.BKP25R.Reg)
}

// RTC.BKP26R: RTC backup registers
func (o *RTC_Type) SetBKP26R(value uint32) {
	volatile.StoreUint32(&o.BKP26R.Reg, value)
}
func (o *RTC_Type) GetBKP26R() uint32 {
	return volatile.LoadUint32(&o.BKP26R.Reg)
}

// RTC.BKP27R: RTC backup registers
func (o *RTC_Type) SetBKP27R(value uint32) {
	volatile.StoreUint32(&o.BKP27R.Reg, value)
}
func (o *RTC_Type) GetBKP27R() uint32 {
	return volatile.LoadUint32(&o.BKP27R.Reg)
}

// RTC.BKP28R: RTC backup registers
func (o *RTC_Type) SetBKP28R(value uint32) {
	volatile.StoreUint32(&o.BKP28R.Reg, value)
}
func (o *RTC_Type) GetBKP28R() uint32 {
	return volatile.LoadUint32(&o.BKP28R.Reg)
}

// RTC.BKP29R: RTC backup registers
func (o *RTC_Type) SetBKP29R(value uint32) {
	volatile.StoreUint32(&o.BKP29R.Reg, value)
}
func (o *RTC_Type) GetBKP29R() uint32 {
	return volatile.LoadUint32(&o.BKP29R.Reg)
}

// RTC.BKP30R: RTC backup registers
func (o *RTC_Type) SetBKP30R(value uint32) {
	volatile.StoreUint32(&o.BKP30R.Reg, value)
}
func (o *RTC_Type) GetBKP30R() uint32 {
	return volatile.LoadUint32(&o.BKP30R.Reg)
}

// RTC.BKP31R: RTC backup registers
func (o *RTC_Type) SetBKP31R(value uint32) {
	volatile.StoreUint32(&o.BKP31R.Reg, value)
}
func (o *RTC_Type) GetBKP31R() uint32 {
	return volatile.LoadUint32(&o.BKP31R.Reg)
}

// SAI
type SAI_Type struct {
	GCR    volatile.Register32 // 0x0
	CH     [2]SAI_CH_Type      // 0x4
	PDMCR  volatile.Register32 // 0x44
	PDMDLY volatile.Register32 // 0x48
}

// SAI.GCR: Global configuration register
func (o *SAI_Type) SetGCR_SYNCOUT(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x30)|value<<4)
}
func (o *SAI_Type) GetGCR_SYNCOUT() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x30) >> 4
}
func (o *SAI_Type) SetGCR_SYNCIN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x3)|value)
}
func (o *SAI_Type) GetGCR_SYNCIN() uint32 {
	return volatile.LoadUint32(&o.GCR.Reg) & 0x3
}

// SAI.PDMCR: PDM control register
func (o *SAI_Type) SetPDMCR_PDMEN(value uint32) {
	volatile.StoreUint32(&o.PDMCR.Reg, volatile.LoadUint32(&o.PDMCR.Reg)&^(0x1)|value)
}
func (o *SAI_Type) GetPDMCR_PDMEN() uint32 {
	return volatile.LoadUint32(&o.PDMCR.Reg) & 0x1
}
func (o *SAI_Type) SetPDMCR_MICNBR(value uint32) {
	volatile.StoreUint32(&o.PDMCR.Reg, volatile.LoadUint32(&o.PDMCR.Reg)&^(0x30)|value<<4)
}
func (o *SAI_Type) GetPDMCR_MICNBR() uint32 {
	return (volatile.LoadUint32(&o.PDMCR.Reg) & 0x30) >> 4
}
func (o *SAI_Type) SetPDMCR_CKEN1(value uint32) {
	volatile.StoreUint32(&o.PDMCR.Reg, volatile.LoadUint32(&o.PDMCR.Reg)&^(0x100)|value<<8)
}
func (o *SAI_Type) GetPDMCR_CKEN1() uint32 {
	return (volatile.LoadUint32(&o.PDMCR.Reg) & 0x100) >> 8
}
func (o *SAI_Type) SetPDMCR_CKEN2(value uint32) {
	volatile.StoreUint32(&o.PDMCR.Reg, volatile.LoadUint32(&o.PDMCR.Reg)&^(0x200)|value<<9)
}
func (o *SAI_Type) GetPDMCR_CKEN2() uint32 {
	return (volatile.LoadUint32(&o.PDMCR.Reg) & 0x200) >> 9
}
func (o *SAI_Type) SetPDMCR_CKEN3(value uint32) {
	volatile.StoreUint32(&o.PDMCR.Reg, volatile.LoadUint32(&o.PDMCR.Reg)&^(0x400)|value<<10)
}
func (o *SAI_Type) GetPDMCR_CKEN3() uint32 {
	return (volatile.LoadUint32(&o.PDMCR.Reg) & 0x400) >> 10
}
func (o *SAI_Type) SetPDMCR_CKEN4(value uint32) {
	volatile.StoreUint32(&o.PDMCR.Reg, volatile.LoadUint32(&o.PDMCR.Reg)&^(0x800)|value<<11)
}
func (o *SAI_Type) GetPDMCR_CKEN4() uint32 {
	return (volatile.LoadUint32(&o.PDMCR.Reg) & 0x800) >> 11
}

// SAI.PDMDLY: PDM delay register
func (o *SAI_Type) SetPDMDLY_DLYM1L(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x7)|value)
}
func (o *SAI_Type) GetPDMDLY_DLYM1L() uint32 {
	return volatile.LoadUint32(&o.PDMDLY.Reg) & 0x7
}
func (o *SAI_Type) SetPDMDLY_DLYM1R(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x70)|value<<4)
}
func (o *SAI_Type) GetPDMDLY_DLYM1R() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x70) >> 4
}
func (o *SAI_Type) SetPDMDLY_DLYM2L(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x700)|value<<8)
}
func (o *SAI_Type) GetPDMDLY_DLYM2L() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x700) >> 8
}
func (o *SAI_Type) SetPDMDLY_DLYM2R(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x7000)|value<<12)
}
func (o *SAI_Type) GetPDMDLY_DLYM2R() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x7000) >> 12
}
func (o *SAI_Type) SetPDMDLY_DLYM3L(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x70000)|value<<16)
}
func (o *SAI_Type) GetPDMDLY_DLYM3L() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x70000) >> 16
}
func (o *SAI_Type) SetPDMDLY_DLYM3R(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x700000)|value<<20)
}
func (o *SAI_Type) GetPDMDLY_DLYM3R() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x700000) >> 20
}
func (o *SAI_Type) SetPDMDLY_DLYM4L(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x7000000)|value<<24)
}
func (o *SAI_Type) GetPDMDLY_DLYM4L() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x7000000) >> 24
}
func (o *SAI_Type) SetPDMDLY_DLYM4R(value uint32) {
	volatile.StoreUint32(&o.PDMDLY.Reg, volatile.LoadUint32(&o.PDMDLY.Reg)&^(0x70000000)|value<<28)
}
func (o *SAI_Type) GetPDMDLY_DLYM4R() uint32 {
	return (volatile.LoadUint32(&o.PDMDLY.Reg) & 0x70000000) >> 28
}

type SAI_CH_Type struct {
	CR1   volatile.Register32 // 0x4
	CR2   volatile.Register32 // 0x8
	FRCR  volatile.Register32 // 0xC
	SLOTR volatile.Register32 // 0x10
	IM    volatile.Register32 // 0x14
	SR    volatile.Register32 // 0x18
	CLRFR volatile.Register32 // 0x1C
	DR    volatile.Register32 // 0x20
}

// SAI_CH.CR1: Configuration register 1
func (o *SAI_CH_Type) SetCR1_MODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3)|value)
}
func (o *SAI_CH_Type) GetCR1_MODE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x3
}
func (o *SAI_CH_Type) SetCR1_PRTCFG(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc)|value<<2)
}
func (o *SAI_CH_Type) GetCR1_PRTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc) >> 2
}
func (o *SAI_CH_Type) SetCR1_DS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xe0)|value<<5)
}
func (o *SAI_CH_Type) GetCR1_DS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xe0) >> 5
}
func (o *SAI_CH_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SAI_CH_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SAI_CH_Type) SetCR1_CKSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SAI_CH_Type) GetCR1_CKSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SAI_CH_Type) SetCR1_SYNCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc00)|value<<10)
}
func (o *SAI_CH_Type) GetCR1_SYNCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc00) >> 10
}
func (o *SAI_CH_Type) SetCR1_MONO(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SAI_CH_Type) GetCR1_MONO() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SAI_CH_Type) SetCR1_OUTDRIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SAI_CH_Type) GetCR1_OUTDRIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SAI_CH_Type) SetCR1_SAIEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *SAI_CH_Type) GetCR1_SAIEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *SAI_CH_Type) SetCR1_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *SAI_CH_Type) GetCR1_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *SAI_CH_Type) SetCR1_MCKDIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3f00000)|value<<20)
}
func (o *SAI_CH_Type) GetCR1_MCKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3f00000) >> 20
}
func (o *SAI_CH_Type) SetCR1_OSR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000000)|value<<26)
}
func (o *SAI_CH_Type) GetCR1_OSR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000000) >> 26
}
func (o *SAI_CH_Type) SetCR1_NODIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *SAI_CH_Type) GetCR1_NODIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *SAI_CH_Type) SetCR1_MCKEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000000)|value<<27)
}
func (o *SAI_CH_Type) GetCR1_MCKEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000000) >> 27
}

// SAI_CH.CR2: Configuration register 2
func (o *SAI_CH_Type) SetCR2_FTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x7)|value)
}
func (o *SAI_CH_Type) GetCR2_FTH() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x7
}
func (o *SAI_CH_Type) SetCR2_FFLUSH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetCR2_FFLUSH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetCR2_TRIS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetCR2_TRIS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetCR2_MUTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetCR2_MUTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetCR2_MUTEVAL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetCR2_MUTEVAL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetCR2_MUTECNT(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1f80)|value<<7)
}
func (o *SAI_CH_Type) GetCR2_MUTECNT() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1f80) >> 7
}
func (o *SAI_CH_Type) SetCR2_CPL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SAI_CH_Type) GetCR2_CPL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SAI_CH_Type) SetCR2_COMP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xc000)|value<<14)
}
func (o *SAI_CH_Type) GetCR2_COMP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xc000) >> 14
}

// SAI_CH.FRCR: This register has no meaning in AC97 and SPDIF audio protocol
func (o *SAI_CH_Type) SetFRCR_FRL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0xff)|value)
}
func (o *SAI_CH_Type) GetFRCR_FRL() uint32 {
	return volatile.LoadUint32(&o.FRCR.Reg) & 0xff
}
func (o *SAI_CH_Type) SetFRCR_FSALL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x7f00)|value<<8)
}
func (o *SAI_CH_Type) GetFRCR_FSALL() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x7f00) >> 8
}
func (o *SAI_CH_Type) SetFRCR_FSDEF(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x10000)|value<<16)
}
func (o *SAI_CH_Type) GetFRCR_FSDEF() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x10000) >> 16
}
func (o *SAI_CH_Type) SetFRCR_FSPOL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x20000)|value<<17)
}
func (o *SAI_CH_Type) GetFRCR_FSPOL() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x20000) >> 17
}
func (o *SAI_CH_Type) SetFRCR_FSOFF(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x40000)|value<<18)
}
func (o *SAI_CH_Type) GetFRCR_FSOFF() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x40000) >> 18
}

// SAI_CH.SLOTR: This register has no meaning in AC97 and SPDIF audio protocol
func (o *SAI_CH_Type) SetSLOTR_FBOFF(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0x1f)|value)
}
func (o *SAI_CH_Type) GetSLOTR_FBOFF() uint32 {
	return volatile.LoadUint32(&o.SLOTR.Reg) & 0x1f
}
func (o *SAI_CH_Type) SetSLOTR_SLOTSZ(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xc0)|value<<6)
}
func (o *SAI_CH_Type) GetSLOTR_SLOTSZ() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xc0) >> 6
}
func (o *SAI_CH_Type) SetSLOTR_NBSLOT(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xf00)|value<<8)
}
func (o *SAI_CH_Type) GetSLOTR_NBSLOT() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xf00) >> 8
}
func (o *SAI_CH_Type) SetSLOTR_SLOTEN(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SAI_CH_Type) GetSLOTR_SLOTEN() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xffff0000) >> 16
}

// SAI_CH.IM: Interrupt mask register 2
func (o *SAI_CH_Type) SetIM_OVRUDRIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetIM_OVRUDRIE() uint32 {
	return volatile.LoadUint32(&o.IM.Reg) & 0x1
}
func (o *SAI_CH_Type) SetIM_MUTEDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetIM_MUTEDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetIM_WCKCFGIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetIM_WCKCFGIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetIM_FREQIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetIM_FREQIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetIM_CNRDYIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetIM_CNRDYIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetIM_AFSDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetIM_AFSDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetIM_LFSDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetIM_LFSDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x40) >> 6
}

// SAI_CH.SR: Status register
func (o *SAI_CH_Type) SetSR_OVRUDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetSR_OVRUDR() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SAI_CH_Type) SetSR_MUTEDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetSR_MUTEDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetSR_WCKCFG(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetSR_WCKCFG() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetSR_FREQ(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetSR_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetSR_CNRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetSR_CNRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetSR_AFSDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetSR_AFSDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetSR_LFSDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetSR_LFSDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetSR_FLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x70000)|value<<16)
}
func (o *SAI_CH_Type) GetSR_FLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x70000) >> 16
}

// SAI_CH.CLRFR: Clear flag register
func (o *SAI_CH_Type) SetCLRFR_COVRUDR(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetCLRFR_COVRUDR() uint32 {
	return volatile.LoadUint32(&o.CLRFR.Reg) & 0x1
}
func (o *SAI_CH_Type) SetCLRFR_CMUTEDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetCLRFR_CMUTEDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetCLRFR_CWCKCFG(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetCLRFR_CWCKCFG() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetCLRFR_CCNRDY(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetCLRFR_CCNRDY() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetCLRFR_CAFSDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetCLRFR_CAFSDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetCLRFR_CLFSDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetCLRFR_CLFSDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x40) >> 6
}

// SAI_CH.DR: Data register
func (o *SAI_CH_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *SAI_CH_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// System control block
type SCB_Type struct {
	CPUID                volatile.Register32 // 0x0
	ICSR                 volatile.Register32 // 0x4
	VTOR                 volatile.Register32 // 0x8
	AIRCR                volatile.Register32 // 0xC
	SCR                  volatile.Register32 // 0x10
	CCR                  volatile.Register32 // 0x14
	SHPR1                volatile.Register32 // 0x18
	SHPR2                volatile.Register32 // 0x1C
	SHPR3                volatile.Register32 // 0x20
	SHCSR                volatile.Register32 // 0x24
	CFSR_UFSR_BFSR_MMFSR volatile.Register32 // 0x28
	HFSR                 volatile.Register32 // 0x2C
	_                    [4]byte
	MMFAR                volatile.Register32 // 0x34
	BFAR                 volatile.Register32 // 0x38
}

// SCB.CPUID: CPUID base register
func (o *SCB_Type) SetCPUID_Revision(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCPUID_Revision() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SCB_Type) SetCPUID_PartNo(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SCB_Type) GetCPUID_PartNo() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SCB_Type) SetCPUID_Constant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCPUID_Constant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCPUID_Variant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCPUID_Variant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCPUID_Implementer(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetCPUID_Implementer() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SCB.ICSR: Interrupt control and state register
func (o *SCB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SCB_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x7f000)|value<<12)
}
func (o *SCB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x7f000) >> 12
}
func (o *SCB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SCB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SCB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SCB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SCB.VTOR: Vector table offset register
func (o *SCB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0x3ffffe00)|value<<9)
}
func (o *SCB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0x3ffffe00) >> 9
}

// SCB.AIRCR: Application interrupt and reset control register
func (o *SCB_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SCB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SCB_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SCB_Type) SetAIRCR_ENDIANESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetAIRCR_ENDIANESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetAIRCR_VECTKEYSTAT(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCB_Type) GetAIRCR_VECTKEYSTAT() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SCB.SCR: System control register
func (o *SCB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetSCR_SEVEONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetSCR_SEVEONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SCB.CCR: Configuration and control register
func (o *SCB_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SCB_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCCR_UNALIGN__TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCCR_UNALIGN__TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCCR_DC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCCR_DC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCCR_IC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCCR_IC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCCR_BP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCCR_BP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40000) >> 18
}

// SCB.SHPR1: System handler priority registers
func (o *SCB_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SCB_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SCB_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SCB_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SCB_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SCB.SHPR2: System handler priority registers
func (o *SCB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SCB.SHPR3: System handler priority registers
func (o *SCB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SCB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SCB.SHCSR: System handler control and state register
func (o *SCB_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SCB_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SCB_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SCB.CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IACCVIOL() uint32 {
	return volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_DACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_DACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x20)|value<<5)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x20) >> 5
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x40000) >> 18
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x80000) >> 19
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1000000) >> 24
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2000000) >> 25
}

// SCB.HFSR: Hard fault status register
func (o *SCB_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetHFSR_DEBUG_VT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetHFSR_DEBUG_VT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SCB.MMFAR: Memory management fault address register
func (o *SCB_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SCB_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SCB.BFAR: Bus fault address register
func (o *SCB_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SCB_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SDMMC1
type SDMMC_Type struct {
	POWER      volatile.Register32 // 0x0
	CLKCR      volatile.Register32 // 0x4
	ARGR       volatile.Register32 // 0x8
	CMDR       volatile.Register32 // 0xC
	RESPCMDR   volatile.Register32 // 0x10
	RESP1R     volatile.Register32 // 0x14
	RESP2R     volatile.Register32 // 0x18
	RESP3R     volatile.Register32 // 0x1C
	RESP4R     volatile.Register32 // 0x20
	DTIMER     volatile.Register32 // 0x24
	DLENR      volatile.Register32 // 0x28
	DCTRL      volatile.Register32 // 0x2C
	DCNTR      volatile.Register32 // 0x30
	STAR       volatile.Register32 // 0x34
	ICR        volatile.Register32 // 0x38
	MASKR      volatile.Register32 // 0x3C
	ACKTIMER   volatile.Register32 // 0x40
	_          [12]byte
	IDMACTRLR  volatile.Register32 // 0x50
	IDMABSIZER volatile.Register32 // 0x54
	IDMABASE0R volatile.Register32 // 0x58
	IDMABASE1R volatile.Register32 // 0x5C
	_          [32]byte
	FIFOR      volatile.Register32 // 0x80
}

// SDMMC.POWER: SDMMC power control register
func (o *SDMMC_Type) SetPOWER_PWRCTRL(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x3)|value)
}
func (o *SDMMC_Type) GetPOWER_PWRCTRL() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x3
}
func (o *SDMMC_Type) SetPOWER_VSWITCH(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetPOWER_VSWITCH() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetPOWER_VSWITCHEN(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetPOWER_VSWITCHEN() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetPOWER_DIRPOL(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetPOWER_DIRPOL() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x10) >> 4
}

// SDMMC.CLKCR: The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
func (o *SDMMC_Type) SetCLKCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x3ff)|value)
}
func (o *SDMMC_Type) GetCLKCR_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKCR.Reg) & 0x3ff
}
func (o *SDMMC_Type) SetCLKCR_PWRSAV(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetCLKCR_PWRSAV() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetCLKCR_WIDBUS(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0xc000)|value<<14)
}
func (o *SDMMC_Type) GetCLKCR_WIDBUS() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0xc000) >> 14
}
func (o *SDMMC_Type) SetCLKCR_NEGEDGE(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetCLKCR_NEGEDGE() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetCLKCR_HWFC_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetCLKCR_HWFC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetCLKCR_DDR(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetCLKCR_DDR() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetCLKCR_BUSSPEED(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x80000)|value<<19)
}
func (o *SDMMC_Type) GetCLKCR_BUSSPEED() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x80000) >> 19
}
func (o *SDMMC_Type) SetCLKCR_SELCLKRX(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x300000)|value<<20)
}
func (o *SDMMC_Type) GetCLKCR_SELCLKRX() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x300000) >> 20
}

// SDMMC.ARGR: The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
func (o *SDMMC_Type) SetARGR(value uint32) {
	volatile.StoreUint32(&o.ARGR.Reg, value)
}
func (o *SDMMC_Type) GetARGR() uint32 {
	return volatile.LoadUint32(&o.ARGR.Reg)
}

// SDMMC.CMDR: The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
func (o *SDMMC_Type) SetCMDR_CMDINDEX(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetCMDR_CMDINDEX() uint32 {
	return volatile.LoadUint32(&o.CMDR.Reg) & 0x3f
}
func (o *SDMMC_Type) SetCMDR_CMDTRANS(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetCMDR_CMDTRANS() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetCMDR_CMDSTOP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetCMDR_CMDSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetCMDR_WAITRESP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x300)|value<<8)
}
func (o *SDMMC_Type) GetCMDR_WAITRESP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x300) >> 8
}
func (o *SDMMC_Type) SetCMDR_WAITINT(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCMDR_WAITINT() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCMDR_WAITPEND(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetCMDR_WAITPEND() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetCMDR_CPSMEN(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetCMDR_CPSMEN() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetCMDR_DTHOLD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetCMDR_DTHOLD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetCMDR_BOOTMODE(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetCMDR_BOOTMODE() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetCMDR_BOOTEN(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetCMDR_BOOTEN() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetCMDR_CMDSUSPEND(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetCMDR_CMDSUSPEND() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x10000) >> 16
}

// SDMMC.RESPCMDR: SDMMC command response register
func (o *SDMMC_Type) SetRESPCMDR_RESPCMD(value uint32) {
	volatile.StoreUint32(&o.RESPCMDR.Reg, volatile.LoadUint32(&o.RESPCMDR.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetRESPCMDR_RESPCMD() uint32 {
	return volatile.LoadUint32(&o.RESPCMDR.Reg) & 0x3f
}

// SDMMC.RESP1R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
func (o *SDMMC_Type) SetRESP1R(value uint32) {
	volatile.StoreUint32(&o.RESP1R.Reg, value)
}
func (o *SDMMC_Type) GetRESP1R() uint32 {
	return volatile.LoadUint32(&o.RESP1R.Reg)
}

// SDMMC.RESP2R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
func (o *SDMMC_Type) SetRESP2R(value uint32) {
	volatile.StoreUint32(&o.RESP2R.Reg, value)
}
func (o *SDMMC_Type) GetRESP2R() uint32 {
	return volatile.LoadUint32(&o.RESP2R.Reg)
}

// SDMMC.RESP3R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
func (o *SDMMC_Type) SetRESP3R(value uint32) {
	volatile.StoreUint32(&o.RESP3R.Reg, value)
}
func (o *SDMMC_Type) GetRESP3R() uint32 {
	return volatile.LoadUint32(&o.RESP3R.Reg)
}

// SDMMC.RESP4R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
func (o *SDMMC_Type) SetRESP4R(value uint32) {
	volatile.StoreUint32(&o.RESP4R.Reg, value)
}
func (o *SDMMC_Type) GetRESP4R() uint32 {
	return volatile.LoadUint32(&o.RESP4R.Reg)
}

// SDMMC.DTIMER: The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
func (o *SDMMC_Type) SetDTIMER(value uint32) {
	volatile.StoreUint32(&o.DTIMER.Reg, value)
}
func (o *SDMMC_Type) GetDTIMER() uint32 {
	return volatile.LoadUint32(&o.DTIMER.Reg)
}

// SDMMC.DLENR: The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
func (o *SDMMC_Type) SetDLENR_DATALENGTH(value uint32) {
	volatile.StoreUint32(&o.DLENR.Reg, volatile.LoadUint32(&o.DLENR.Reg)&^(0x1ffffff)|value)
}
func (o *SDMMC_Type) GetDLENR_DATALENGTH() uint32 {
	return volatile.LoadUint32(&o.DLENR.Reg) & 0x1ffffff
}

// SDMMC.DCTRL: The SDMMC_DCTRL register control the data path state machine (DPSM).
func (o *SDMMC_Type) SetDCTRL_DTEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetDCTRL_DTEN() uint32 {
	return volatile.LoadUint32(&o.DCTRL.Reg) & 0x1
}
func (o *SDMMC_Type) SetDCTRL_DTDIR(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetDCTRL_DTDIR() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetDCTRL_DTMODE(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0xc)|value<<2)
}
func (o *SDMMC_Type) GetDCTRL_DTMODE() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0xc) >> 2
}
func (o *SDMMC_Type) SetDCTRL_DBLOCKSIZE(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0xf0)|value<<4)
}
func (o *SDMMC_Type) GetDCTRL_DBLOCKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0xf0) >> 4
}
func (o *SDMMC_Type) SetDCTRL_RWSTART(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetDCTRL_RWSTART() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetDCTRL_RWSTOP(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetDCTRL_RWSTOP() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetDCTRL_RWMOD(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetDCTRL_RWMOD() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetDCTRL_SDIOEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetDCTRL_SDIOEN() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetDCTRL_BOOTACKEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetDCTRL_BOOTACKEN() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetDCTRL_FIFORST(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetDCTRL_FIFORST() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x2000) >> 13
}

// SDMMC.DCNTR: The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
func (o *SDMMC_Type) SetDCNTR_DATACOUNT(value uint32) {
	volatile.StoreUint32(&o.DCNTR.Reg, volatile.LoadUint32(&o.DCNTR.Reg)&^(0x1ffffff)|value)
}
func (o *SDMMC_Type) GetDCNTR_DATACOUNT() uint32 {
	return volatile.LoadUint32(&o.DCNTR.Reg) & 0x1ffffff
}

// SDMMC.STAR: The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
func (o *SDMMC_Type) SetSTAR_CCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetSTAR_CCRCFAIL() uint32 {
	return volatile.LoadUint32(&o.STAR.Reg) & 0x1
}
func (o *SDMMC_Type) SetSTAR_DCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetSTAR_DCRCFAIL() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetSTAR_CTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetSTAR_CTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetSTAR_DTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetSTAR_DTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetSTAR_TXUNDERR(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetSTAR_TXUNDERR() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetSTAR_RXOVERR(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetSTAR_RXOVERR() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetSTAR_CMDREND(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetSTAR_CMDREND() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetSTAR_CMDSENT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetSTAR_CMDSENT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetSTAR_DATAEND(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetSTAR_DATAEND() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetSTAR_DHOLD(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetSTAR_DHOLD() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetSTAR_DBCKEND(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetSTAR_DBCKEND() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetSTAR_DABORT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetSTAR_DABORT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetSTAR_DPSMACT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetSTAR_DPSMACT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetSTAR_CPSMACT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetSTAR_CPSMACT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetSTAR_TXFIFOHE(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetSTAR_TXFIFOHE() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetSTAR_RXFIFOHF(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetSTAR_RXFIFOHF() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetSTAR_TXFIFOF(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetSTAR_TXFIFOF() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetSTAR_RXFIFOF(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetSTAR_RXFIFOF() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetSTAR_TXFIFOE(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetSTAR_TXFIFOE() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetSTAR_RXFIFOE(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x80000)|value<<19)
}
func (o *SDMMC_Type) GetSTAR_RXFIFOE() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x80000) >> 19
}
func (o *SDMMC_Type) SetSTAR_BUSYD0(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x100000)|value<<20)
}
func (o *SDMMC_Type) GetSTAR_BUSYD0() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x100000) >> 20
}
func (o *SDMMC_Type) SetSTAR_BUSYD0END(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetSTAR_BUSYD0END() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetSTAR_SDIOIT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetSTAR_SDIOIT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetSTAR_ACKFAIL(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x800000)|value<<23)
}
func (o *SDMMC_Type) GetSTAR_ACKFAIL() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x800000) >> 23
}
func (o *SDMMC_Type) SetSTAR_ACKTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x1000000)|value<<24)
}
func (o *SDMMC_Type) GetSTAR_ACKTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x1000000) >> 24
}
func (o *SDMMC_Type) SetSTAR_VSWEND(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x2000000)|value<<25)
}
func (o *SDMMC_Type) GetSTAR_VSWEND() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x2000000) >> 25
}
func (o *SDMMC_Type) SetSTAR_CKSTOP(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x4000000)|value<<26)
}
func (o *SDMMC_Type) GetSTAR_CKSTOP() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x4000000) >> 26
}
func (o *SDMMC_Type) SetSTAR_IDMATE(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x8000000)|value<<27)
}
func (o *SDMMC_Type) GetSTAR_IDMATE() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x8000000) >> 27
}
func (o *SDMMC_Type) SetSTAR_IDMABTC(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x10000000)|value<<28)
}
func (o *SDMMC_Type) GetSTAR_IDMABTC() uint32 {
	return (volatile.LoadUint32(&o.STAR.Reg) & 0x10000000) >> 28
}

// SDMMC.ICR: The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
func (o *SDMMC_Type) SetICR_CCRCFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetICR_CCRCFAILC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *SDMMC_Type) SetICR_DCRCFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetICR_DCRCFAILC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetICR_CTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetICR_CTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetICR_DTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetICR_DTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetICR_TXUNDERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetICR_TXUNDERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetICR_RXOVERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetICR_RXOVERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetICR_CMDRENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetICR_CMDRENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetICR_CMDSENTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetICR_CMDSENTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetICR_DATAENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetICR_DATAENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetICR_DHOLDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetICR_DHOLDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetICR_DBCKENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetICR_DBCKENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetICR_DABORTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetICR_DABORTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetICR_BUSYD0ENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetICR_BUSYD0ENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetICR_SDIOITC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetICR_SDIOITC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetICR_ACKFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800000)|value<<23)
}
func (o *SDMMC_Type) GetICR_ACKFAILC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800000) >> 23
}
func (o *SDMMC_Type) SetICR_ACKTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000000)|value<<24)
}
func (o *SDMMC_Type) GetICR_ACKTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000000) >> 24
}
func (o *SDMMC_Type) SetICR_VSWENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000000)|value<<25)
}
func (o *SDMMC_Type) GetICR_VSWENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000000) >> 25
}
func (o *SDMMC_Type) SetICR_CKSTOPC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4000000)|value<<26)
}
func (o *SDMMC_Type) GetICR_CKSTOPC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4000000) >> 26
}
func (o *SDMMC_Type) SetICR_IDMATEC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8000000)|value<<27)
}
func (o *SDMMC_Type) GetICR_IDMATEC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8000000) >> 27
}
func (o *SDMMC_Type) SetICR_IDMABTCC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10000000)|value<<28)
}
func (o *SDMMC_Type) GetICR_IDMABTCC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10000000) >> 28
}

// SDMMC.MASKR: The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
func (o *SDMMC_Type) SetMASKR_CCRCFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetMASKR_CCRCFAILIE() uint32 {
	return volatile.LoadUint32(&o.MASKR.Reg) & 0x1
}
func (o *SDMMC_Type) SetMASKR_DCRCFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetMASKR_DCRCFAILIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetMASKR_CTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetMASKR_CTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetMASKR_DTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetMASKR_DTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetMASKR_TXUNDERRIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetMASKR_TXUNDERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetMASKR_RXOVERRIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetMASKR_RXOVERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetMASKR_CMDRENDIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetMASKR_CMDRENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetMASKR_CMDSENTIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetMASKR_CMDSENTIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetMASKR_DATAENDIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetMASKR_DATAENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetMASKR_DHOLDIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetMASKR_DHOLDIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetMASKR_DBCKENDIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetMASKR_DBCKENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetMASKR_DABORTIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetMASKR_DABORTIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetMASKR_TXFIFOHEIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetMASKR_TXFIFOHEIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetMASKR_RXFIFOHFIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetMASKR_RXFIFOHFIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetMASKR_RXFIFOFIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetMASKR_RXFIFOFIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetMASKR_TXFIFOEIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetMASKR_TXFIFOEIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetMASKR_BUSYD0ENDIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetMASKR_BUSYD0ENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetMASKR_SDIOITIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetMASKR_SDIOITIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetMASKR_ACKFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x800000)|value<<23)
}
func (o *SDMMC_Type) GetMASKR_ACKFAILIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x800000) >> 23
}
func (o *SDMMC_Type) SetMASKR_ACKTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x1000000)|value<<24)
}
func (o *SDMMC_Type) GetMASKR_ACKTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x1000000) >> 24
}
func (o *SDMMC_Type) SetMASKR_VSWENDIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x2000000)|value<<25)
}
func (o *SDMMC_Type) GetMASKR_VSWENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x2000000) >> 25
}
func (o *SDMMC_Type) SetMASKR_CKSTOPIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x4000000)|value<<26)
}
func (o *SDMMC_Type) GetMASKR_CKSTOPIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x4000000) >> 26
}
func (o *SDMMC_Type) SetMASKR_IDMABTCIE(value uint32) {
	volatile.StoreUint32(&o.MASKR.Reg, volatile.LoadUint32(&o.MASKR.Reg)&^(0x10000000)|value<<28)
}
func (o *SDMMC_Type) GetMASKR_IDMABTCIE() uint32 {
	return (volatile.LoadUint32(&o.MASKR.Reg) & 0x10000000) >> 28
}

// SDMMC.ACKTIMER: The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
func (o *SDMMC_Type) SetACKTIMER_ACKTIME(value uint32) {
	volatile.StoreUint32(&o.ACKTIMER.Reg, volatile.LoadUint32(&o.ACKTIMER.Reg)&^(0x1ffffff)|value)
}
func (o *SDMMC_Type) GetACKTIMER_ACKTIME() uint32 {
	return volatile.LoadUint32(&o.ACKTIMER.Reg) & 0x1ffffff
}

// SDMMC.IDMACTRLR: The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
func (o *SDMMC_Type) SetIDMACTRLR_IDMAEN(value uint32) {
	volatile.StoreUint32(&o.IDMACTRLR.Reg, volatile.LoadUint32(&o.IDMACTRLR.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetIDMACTRLR_IDMAEN() uint32 {
	return volatile.LoadUint32(&o.IDMACTRLR.Reg) & 0x1
}
func (o *SDMMC_Type) SetIDMACTRLR_IDMABMODE(value uint32) {
	volatile.StoreUint32(&o.IDMACTRLR.Reg, volatile.LoadUint32(&o.IDMACTRLR.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetIDMACTRLR_IDMABMODE() uint32 {
	return (volatile.LoadUint32(&o.IDMACTRLR.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetIDMACTRLR_IDMABACT(value uint32) {
	volatile.StoreUint32(&o.IDMACTRLR.Reg, volatile.LoadUint32(&o.IDMACTRLR.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetIDMACTRLR_IDMABACT() uint32 {
	return (volatile.LoadUint32(&o.IDMACTRLR.Reg) & 0x4) >> 2
}

// SDMMC.IDMABSIZER: The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
func (o *SDMMC_Type) SetIDMABSIZER_IDMABNDT(value uint32) {
	volatile.StoreUint32(&o.IDMABSIZER.Reg, volatile.LoadUint32(&o.IDMABSIZER.Reg)&^(0x1fe0)|value<<5)
}
func (o *SDMMC_Type) GetIDMABSIZER_IDMABNDT() uint32 {
	return (volatile.LoadUint32(&o.IDMABSIZER.Reg) & 0x1fe0) >> 5
}

// SDMMC.IDMABASE0R: The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
func (o *SDMMC_Type) SetIDMABASE0R(value uint32) {
	volatile.StoreUint32(&o.IDMABASE0R.Reg, value)
}
func (o *SDMMC_Type) GetIDMABASE0R() uint32 {
	return volatile.LoadUint32(&o.IDMABASE0R.Reg)
}

// SDMMC.IDMABASE1R: The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
func (o *SDMMC_Type) SetIDMABASE1R(value uint32) {
	volatile.StoreUint32(&o.IDMABASE1R.Reg, value)
}
func (o *SDMMC_Type) GetIDMABASE1R() uint32 {
	return volatile.LoadUint32(&o.IDMABASE1R.Reg)
}

// SDMMC.FIFOR: The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
func (o *SDMMC_Type) SetFIFOR(value uint32) {
	volatile.StoreUint32(&o.FIFOR.Reg, value)
}
func (o *SDMMC_Type) GetFIFOR() uint32 {
	return volatile.LoadUint32(&o.FIFOR.Reg)
}

// Receiver Interface
type SPDIFRX_Type struct {
	CR      volatile.Register32 // 0x0
	IMR     volatile.Register32 // 0x4
	SR      volatile.Register32 // 0x8
	IFCR    volatile.Register32 // 0xC
	FMT0_DR volatile.Register32 // 0x10
	CSR     volatile.Register32 // 0x14
	DIR     volatile.Register32 // 0x18
}

// SPDIFRX.CR: Control register
func (o *SPDIFRX_Type) SetCR_SPDIFRXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *SPDIFRX_Type) GetCR_SPDIFRXEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *SPDIFRX_Type) SetCR_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIFRX_Type) GetCR_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SPDIFRX_Type) SetCR_RXSTEO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIFRX_Type) GetCR_RXSTEO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SPDIFRX_Type) SetCR_DRFMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30)|value<<4)
}
func (o *SPDIFRX_Type) GetCR_DRFMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30) >> 4
}
func (o *SPDIFRX_Type) SetCR_PMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *SPDIFRX_Type) GetCR_PMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *SPDIFRX_Type) SetCR_VMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *SPDIFRX_Type) GetCR_VMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *SPDIFRX_Type) SetCR_CUMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SPDIFRX_Type) GetCR_CUMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *SPDIFRX_Type) SetCR_PTMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *SPDIFRX_Type) GetCR_PTMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *SPDIFRX_Type) SetCR_CBDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *SPDIFRX_Type) GetCR_CBDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *SPDIFRX_Type) SetCR_CHSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *SPDIFRX_Type) GetCR_CHSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *SPDIFRX_Type) SetCR_NBTR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3000)|value<<12)
}
func (o *SPDIFRX_Type) GetCR_NBTR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3000) >> 12
}
func (o *SPDIFRX_Type) SetCR_WFA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *SPDIFRX_Type) GetCR_WFA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *SPDIFRX_Type) SetCR_INSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70000)|value<<16)
}
func (o *SPDIFRX_Type) GetCR_INSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70000) >> 16
}
func (o *SPDIFRX_Type) SetCR_CKSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *SPDIFRX_Type) GetCR_CKSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *SPDIFRX_Type) SetCR_CKSBKPEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *SPDIFRX_Type) GetCR_CKSBKPEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}

// SPDIFRX.IMR: Interrupt mask register
func (o *SPDIFRX_Type) SetIMR_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SPDIFRX_Type) GetIMR_RXNEIE() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SPDIFRX_Type) SetIMR_CSRNEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SPDIFRX_Type) GetIMR_CSRNEIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SPDIFRX_Type) SetIMR_PERRIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIFRX_Type) GetIMR_PERRIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SPDIFRX_Type) SetIMR_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIFRX_Type) GetIMR_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *SPDIFRX_Type) SetIMR_SBLKIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SPDIFRX_Type) GetIMR_SBLKIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SPDIFRX_Type) SetIMR_SYNCDIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIFRX_Type) GetIMR_SYNCDIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SPDIFRX_Type) SetIMR_IFEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *SPDIFRX_Type) GetIMR_IFEIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}

// SPDIFRX.SR: Status register
func (o *SPDIFRX_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPDIFRX_Type) GetSR_RXNE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPDIFRX_Type) SetSR_CSRNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPDIFRX_Type) GetSR_CSRNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPDIFRX_Type) SetSR_PERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIFRX_Type) GetSR_PERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPDIFRX_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIFRX_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPDIFRX_Type) SetSR_SBD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPDIFRX_Type) GetSR_SBD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPDIFRX_Type) SetSR_SYNCD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIFRX_Type) GetSR_SYNCD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPDIFRX_Type) SetSR_FERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPDIFRX_Type) GetSR_FERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPDIFRX_Type) SetSR_SERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPDIFRX_Type) GetSR_SERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPDIFRX_Type) SetSR_TERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPDIFRX_Type) GetSR_TERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPDIFRX_Type) SetSR_WIDTH5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x7fff0000)|value<<16)
}
func (o *SPDIFRX_Type) GetSR_WIDTH5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x7fff0000) >> 16
}

// SPDIFRX.IFCR: Interrupt Flag Clear register
func (o *SPDIFRX_Type) SetIFCR_PERRCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIFRX_Type) GetIFCR_PERRCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *SPDIFRX_Type) SetIFCR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIFRX_Type) GetIFCR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *SPDIFRX_Type) SetIFCR_SBDCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *SPDIFRX_Type) GetIFCR_SBDCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *SPDIFRX_Type) SetIFCR_SYNCDCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIFRX_Type) GetIFCR_SYNCDCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}

// SPDIFRX.FMT0_DR: Data input register
func (o *SPDIFRX_Type) SetFMT0_DR_DR(value uint32) {
	volatile.StoreUint32(&o.FMT0_DR.Reg, volatile.LoadUint32(&o.FMT0_DR.Reg)&^(0xffffff)|value)
}
func (o *SPDIFRX_Type) GetFMT0_DR_DR() uint32 {
	return volatile.LoadUint32(&o.FMT0_DR.Reg) & 0xffffff
}
func (o *SPDIFRX_Type) SetFMT0_DR_PE(value uint32) {
	volatile.StoreUint32(&o.FMT0_DR.Reg, volatile.LoadUint32(&o.FMT0_DR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPDIFRX_Type) GetFMT0_DR_PE() uint32 {
	return (volatile.LoadUint32(&o.FMT0_DR.Reg) & 0x1000000) >> 24
}
func (o *SPDIFRX_Type) SetFMT0_DR_V(value uint32) {
	volatile.StoreUint32(&o.FMT0_DR.Reg, volatile.LoadUint32(&o.FMT0_DR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPDIFRX_Type) GetFMT0_DR_V() uint32 {
	return (volatile.LoadUint32(&o.FMT0_DR.Reg) & 0x2000000) >> 25
}
func (o *SPDIFRX_Type) SetFMT0_DR_U(value uint32) {
	volatile.StoreUint32(&o.FMT0_DR.Reg, volatile.LoadUint32(&o.FMT0_DR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPDIFRX_Type) GetFMT0_DR_U() uint32 {
	return (volatile.LoadUint32(&o.FMT0_DR.Reg) & 0x4000000) >> 26
}
func (o *SPDIFRX_Type) SetFMT0_DR_C(value uint32) {
	volatile.StoreUint32(&o.FMT0_DR.Reg, volatile.LoadUint32(&o.FMT0_DR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPDIFRX_Type) GetFMT0_DR_C() uint32 {
	return (volatile.LoadUint32(&o.FMT0_DR.Reg) & 0x8000000) >> 27
}
func (o *SPDIFRX_Type) SetFMT0_DR_PT(value uint32) {
	volatile.StoreUint32(&o.FMT0_DR.Reg, volatile.LoadUint32(&o.FMT0_DR.Reg)&^(0x30000000)|value<<28)
}
func (o *SPDIFRX_Type) GetFMT0_DR_PT() uint32 {
	return (volatile.LoadUint32(&o.FMT0_DR.Reg) & 0x30000000) >> 28
}

// SPDIFRX.CSR: Channel Status register
func (o *SPDIFRX_Type) SetCSR_USR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0xffff)|value)
}
func (o *SPDIFRX_Type) GetCSR_USR() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0xffff
}
func (o *SPDIFRX_Type) SetCSR_CS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0xff0000)|value<<16)
}
func (o *SPDIFRX_Type) GetCSR_CS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0xff0000) >> 16
}
func (o *SPDIFRX_Type) SetCSR_SOB(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPDIFRX_Type) GetCSR_SOB() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}

// SPDIFRX.DIR: Debug Information register
func (o *SPDIFRX_Type) SetDIR_THI(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1fff)|value)
}
func (o *SPDIFRX_Type) GetDIR_THI() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1fff
}
func (o *SPDIFRX_Type) SetDIR_TLO(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1fff0000)|value<<16)
}
func (o *SPDIFRX_Type) GetDIR_TLO() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1fff0000) >> 16
}

// Serial peripheral interface
type SPI_Type struct {
	CR1     volatile.Register32 // 0x0
	CR2     volatile.Register32 // 0x4
	CFG1    volatile.Register32 // 0x8
	CFG2    volatile.Register32 // 0xC
	IER     volatile.Register32 // 0x10
	SR      volatile.Register32 // 0x14
	IFCR    volatile.Register32 // 0x18
	_       [4]byte
	TXDR    volatile.Register32 // 0x20
	_       [12]byte
	RXDR    volatile.Register32 // 0x30
	_       [12]byte
	CRCPOLY volatile.Register32 // 0x40
	TXCRC   volatile.Register32 // 0x44
	RXCRC   volatile.Register32 // 0x48
	UDRDR   volatile.Register32 // 0x4C
	I2SCFGR volatile.Register32 // 0x50
}

// SPI.CR1: control register 1
func (o *SPI_Type) SetCR1_IOLOCK(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetCR1_IOLOCK() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetCR1_TCRCINI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCR1_TCRCINI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCR1_RCRCINI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR1_RCRCINI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCR1_CRC33_17(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR1_CRC33_17() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR1_SSI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR1_SSI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR1_HDDIR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCR1_HDDIR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetCR1_CSUSP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCR1_CSUSP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCR1_CSTART(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCR1_CSTART() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCR1_MASRX(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCR1_MASRX() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCR1_SPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR1_SPE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// SPI.CR2: control register 2
func (o *SPI_Type) SetCR2_TSER(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetCR2_TSER() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xffff0000) >> 16
}
func (o *SPI_Type) SetCR2_TSIZE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetCR2_TSIZE() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0xffff
}

// SPI.CFG1: configuration register 1
func (o *SPI_Type) SetCFG1_MBR(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x70000000)|value<<28)
}
func (o *SPI_Type) GetCFG1_MBR() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x70000000) >> 28
}
func (o *SPI_Type) SetCFG1_CRCEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetCFG1_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetCFG1_CRCSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1f0000)|value<<16)
}
func (o *SPI_Type) GetCFG1_CRCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1f0000) >> 16
}
func (o *SPI_Type) SetCFG1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCFG1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCFG1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCFG1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCFG1_UDRDET(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1800)|value<<11)
}
func (o *SPI_Type) GetCFG1_UDRDET() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1800) >> 11
}
func (o *SPI_Type) SetCFG1_UDRCFG(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x600)|value<<9)
}
func (o *SPI_Type) GetCFG1_UDRCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x600) >> 9
}
func (o *SPI_Type) SetCFG1_FTHLV(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1e0)|value<<5)
}
func (o *SPI_Type) GetCFG1_FTHLV() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1e0) >> 5
}
func (o *SPI_Type) SetCFG1_DSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1f)|value)
}
func (o *SPI_Type) GetCFG1_DSIZE() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0x1f
}

// SPI.CFG2: configuration register 2
func (o *SPI_Type) SetCFG2_AFCNTR(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetCFG2_AFCNTR() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x80000000) >> 31
}
func (o *SPI_Type) SetCFG2_SSOM(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetCFG2_SSOM() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetCFG2_SSOE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI_Type) GetCFG2_SSOE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x20000000) >> 29
}
func (o *SPI_Type) SetCFG2_SSIOP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetCFG2_SSIOP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetCFG2_SSM(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetCFG2_SSM() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetCFG2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetCFG2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetCFG2_CPHA(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCFG2_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetCFG2_LSBFRST(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x800000)|value<<23)
}
func (o *SPI_Type) GetCFG2_LSBFRST() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x800000) >> 23
}
func (o *SPI_Type) SetCFG2_MASTER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetCFG2_MASTER() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetCFG2_SP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x380000)|value<<19)
}
func (o *SPI_Type) GetCFG2_SP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x380000) >> 19
}
func (o *SPI_Type) SetCFG2_COMM(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x60000)|value<<17)
}
func (o *SPI_Type) GetCFG2_COMM() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x60000) >> 17
}
func (o *SPI_Type) SetCFG2_IOSWP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCFG2_IOSWP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCFG2_MIDI(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCFG2_MIDI() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCFG2_MSSI(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetCFG2_MSSI() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0xf
}

// SPI.IER: Interrupt Enable Register
func (o *SPI_Type) SetIER_TSERFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIER_TSERFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetIER_MODFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIER_MODFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIER_TIFREIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIER_TIFREIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIER_CRCEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetIER_CRCEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetIER_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetIER_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetIER_UDRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetIER_UDRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetIER_TXTFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetIER_TXTFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetIER_EOTIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIER_EOTIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIER_DXPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIER_DXPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIER_TXPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIER_TXPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIER_RXPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIER_RXPIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_CTSIZE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetSR_CTSIZE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xffff0000) >> 16
}
func (o *SPI_Type) SetSR_RXWNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetSR_RXWNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetSR_RXPLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x6000)|value<<13)
}
func (o *SPI_Type) GetSR_RXPLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x6000) >> 13
}
func (o *SPI_Type) SetSR_TXC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetSR_TXC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetSR_SUSP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetSR_SUSP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetSR_TSERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetSR_TSERF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetSR_TIFRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_TIFRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_CRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSR_CRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSR_UDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSR_UDR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSR_TXTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_TXTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_EOT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_EOT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_DXP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_DXP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_TXP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TXP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_RXP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RXP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// SPI.IFCR: Interrupt/Status Flags Clear Register
func (o *SPI_Type) SetIFCR_SUSPC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetIFCR_SUSPC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetIFCR_TSERFC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIFCR_TSERFC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetIFCR_MODFC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIFCR_MODFC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIFCR_TIFREC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIFCR_TIFREC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIFCR_CRCEC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetIFCR_CRCEC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetIFCR_OVRC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetIFCR_OVRC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetIFCR_UDRC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetIFCR_UDRC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetIFCR_TXTFC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetIFCR_TXTFC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetIFCR_EOTC(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIFCR_EOTC() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}

// SPI.TXDR: Transmit Data Register
func (o *SPI_Type) SetTXDR(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, value)
}
func (o *SPI_Type) GetTXDR() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg)
}

// SPI.RXDR: Receive Data Register
func (o *SPI_Type) SetRXDR(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, value)
}
func (o *SPI_Type) GetRXDR() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg)
}

// SPI.CRCPOLY: Polynomial Register
func (o *SPI_Type) SetCRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPOLY.Reg, value)
}
func (o *SPI_Type) GetCRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPOLY.Reg)
}

// SPI.TXCRC: Transmitter CRC Register
func (o *SPI_Type) SetTXCRC(value uint32) {
	volatile.StoreUint32(&o.TXCRC.Reg, value)
}
func (o *SPI_Type) GetTXCRC() uint32 {
	return volatile.LoadUint32(&o.TXCRC.Reg)
}

// SPI.RXCRC: Receiver CRC Register
func (o *SPI_Type) SetRXCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRC.Reg, value)
}
func (o *SPI_Type) GetRXCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRC.Reg)
}

// SPI.UDRDR: Underrun Data Register
func (o *SPI_Type) SetUDRDR(value uint32) {
	volatile.StoreUint32(&o.UDRDR.Reg, value)
}
func (o *SPI_Type) GetUDRDR() uint32 {
	return volatile.LoadUint32(&o.UDRDR.Reg)
}

// SPI.I2SCFGR: configuration register
func (o *SPI_Type) SetI2SCFGR_MCKOE(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetI2SCFGR_MCKOE() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetI2SCFGR_ODD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetI2SCFGR_ODD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetI2SCFGR_I2SDIV(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI_Type) GetI2SCFGR_I2SDIV() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0xff0000) >> 16
}
func (o *SPI_Type) SetI2SCFGR_DATFMT(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetI2SCFGR_DATFMT() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetI2SCFGR_WSINV(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetI2SCFGR_WSINV() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetI2SCFGR_FIXCH(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetI2SCFGR_FIXCH() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetI2SCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetI2SCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetI2SCFGR_CHLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetI2SCFGR_CHLEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetI2SCFGR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetI2SCFGR_DATLEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetI2SCFGR_PCMSYNC(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetI2SCFGR_PCMSYNC() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetI2SCFGR_I2SSTD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetI2SCFGR_I2SSTD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetI2SCFGR_I2SCFG(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0xe)|value<<1)
}
func (o *SPI_Type) GetI2SCFGR_I2SCFG() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0xe) >> 1
}
func (o *SPI_Type) SetI2SCFGR_I2SMOD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetI2SCFGR_I2SMOD() uint32 {
	return volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1
}

// SysTick timer
type STK_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// STK.CSR: SysTick control and status register
func (o *STK_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *STK_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *STK_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *STK_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *STK_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *STK_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *STK_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *STK_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// STK.RVR: SysTick reload value register
func (o *STK_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// STK.CVR: SysTick current value register
func (o *STK_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// STK.CALIB: SysTick calibration value register
func (o *STK_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *STK_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *STK_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *STK_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *STK_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// Single Wire Protocol Master Interface
type SWPMI_Type struct {
	CR  volatile.Register32 // 0x0
	BRR volatile.Register32 // 0x4
	_   [4]byte
	ISR volatile.Register32 // 0xC
	ICR volatile.Register32 // 0x10
	IER volatile.Register32 // 0x14
	RFL volatile.Register32 // 0x18
	TDR volatile.Register32 // 0x1C
	RDR volatile.Register32 // 0x20
	OR  volatile.Register32 // 0x24
}

// SWPMI.CR: SWPMI Configuration/Control register
func (o *SWPMI_Type) SetCR_RXDMA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetCR_RXDMA() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SWPMI_Type) SetCR_TXDMA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetCR_TXDMA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetCR_RXMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetCR_RXMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetCR_TXMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetCR_TXMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetCR_LPBK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetCR_LPBK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetCR_SWPACT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *SWPMI_Type) GetCR_SWPACT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *SWPMI_Type) SetCR_DEACT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *SWPMI_Type) GetCR_DEACT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *SWPMI_Type) SetCR_SWPTEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *SWPMI_Type) GetCR_SWPTEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}

// SWPMI.BRR: SWPMI Bitrate register
func (o *SWPMI_Type) SetBRR_BR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xff)|value)
}
func (o *SWPMI_Type) GetBRR_BR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xff
}

// SWPMI.ISR: SWPMI Interrupt and Status register
func (o *SWPMI_Type) SetISR_RXBFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetISR_RXBFF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *SWPMI_Type) SetISR_TXBEF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetISR_TXBEF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetISR_RXBERF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetISR_RXBERF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetISR_RXOVRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetISR_RXOVRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetISR_TXUNRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetISR_TXUNRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *SWPMI_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *SWPMI_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *SWPMI_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *SWPMI_Type) SetISR_TCF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *SWPMI_Type) GetISR_TCF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *SWPMI_Type) SetISR_SRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *SWPMI_Type) GetISR_SRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *SWPMI_Type) SetISR_SUSP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *SWPMI_Type) GetISR_SUSP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *SWPMI_Type) SetISR_DEACTF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *SWPMI_Type) GetISR_DEACTF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *SWPMI_Type) SetISR_RDYF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *SWPMI_Type) GetISR_RDYF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}

// SWPMI.ICR: SWPMI Interrupt Flag Clear register
func (o *SWPMI_Type) SetICR_CRXBFF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetICR_CRXBFF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *SWPMI_Type) SetICR_CTXBEF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetICR_CTXBEF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetICR_CRXBERF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetICR_CRXBERF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetICR_CRXOVRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetICR_CRXOVRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetICR_CTXUNRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetICR_CTXUNRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetICR_CTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *SWPMI_Type) GetICR_CTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *SWPMI_Type) SetICR_CSRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *SWPMI_Type) GetICR_CSRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *SWPMI_Type) SetICR_CRDYF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *SWPMI_Type) GetICR_CRDYF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}

// SWPMI.IER: SWPMI Interrupt Enable register
func (o *SWPMI_Type) SetIER_RXBFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetIER_RXBFIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SWPMI_Type) SetIER_TXBEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetIER_TXBEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetIER_RXBERIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetIER_RXBERIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetIER_RXOVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetIER_RXOVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetIER_TXUNRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetIER_TXUNRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetIER_RIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SWPMI_Type) GetIER_RIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SWPMI_Type) SetIER_TIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *SWPMI_Type) GetIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *SWPMI_Type) SetIER_TCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *SWPMI_Type) GetIER_TCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *SWPMI_Type) SetIER_SRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SWPMI_Type) GetIER_SRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SWPMI_Type) SetIER_RDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *SWPMI_Type) GetIER_RDYIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// SWPMI.RFL: SWPMI Receive Frame Length register
func (o *SWPMI_Type) SetRFL(value uint32) {
	volatile.StoreUint32(&o.RFL.Reg, volatile.LoadUint32(&o.RFL.Reg)&^(0x1f)|value)
}
func (o *SWPMI_Type) GetRFL() uint32 {
	return volatile.LoadUint32(&o.RFL.Reg) & 0x1f
}

// SWPMI.TDR: SWPMI Transmit data register
func (o *SWPMI_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, value)
}
func (o *SWPMI_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg)
}

// SWPMI.RDR: SWPMI Receive data register
func (o *SWPMI_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, value)
}
func (o *SWPMI_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg)
}

// SWPMI.OR: SWPMI Option register
func (o *SWPMI_Type) SetOR_SWP_TBYP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetOR_SWP_TBYP() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x1
}
func (o *SWPMI_Type) SetOR_SWP_CLASS(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetOR_SWP_CLASS() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0x2) >> 1
}

// System configuration controller
type SYSCFG_Type struct {
	_       [4]byte
	PMCR    volatile.Register32 // 0x4
	EXTICR1 volatile.Register32 // 0x8
	EXTICR2 volatile.Register32 // 0xC
	EXTICR3 volatile.Register32 // 0x10
	EXTICR4 volatile.Register32 // 0x14
	CFGR    volatile.Register32 // 0x18
	_       [4]byte
	CCCSR   volatile.Register32 // 0x20
	CCVR    volatile.Register32 // 0x24
	CCCR    volatile.Register32 // 0x28
	_       [4]byte
	ADC2ALT volatile.Register32 // 0x30
	_       [240]byte
	PKGR    volatile.Register32 // 0x124
	_       [472]byte
	UR0     volatile.Register32 // 0x300
	_       [4]byte
	UR2     volatile.Register32 // 0x308
	UR3     volatile.Register32 // 0x30C
	UR4     volatile.Register32 // 0x310
	UR5     volatile.Register32 // 0x314
	UR6     volatile.Register32 // 0x318
	UR7     volatile.Register32 // 0x31C
	_       [12]byte
	UR11    volatile.Register32 // 0x32C
	UR12    volatile.Register32 // 0x330
	UR13    volatile.Register32 // 0x334
	UR14    volatile.Register32 // 0x338
	UR15    volatile.Register32 // 0x33C
	UR16    volatile.Register32 // 0x340
	UR17    volatile.Register32 // 0x344
	UR18    volatile.Register32 // 0x348
}

// SYSCFG.PMCR: peripheral mode configuration register
func (o *SYSCFG_Type) SetPMCR_I2C1FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetPMCR_I2C1FMP() uint32 {
	return volatile.LoadUint32(&o.PMCR.Reg) & 0x1
}
func (o *SYSCFG_Type) SetPMCR_I2C2FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetPMCR_I2C2FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetPMCR_I2C3FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetPMCR_I2C3FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetPMCR_I2C4FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetPMCR_I2C4FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetPMCR_PB6FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetPMCR_PB6FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetPMCR_PB7FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetPMCR_PB7FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetPMCR_PB8FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetPMCR_PB8FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetPMCR_PB9FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetPMCR_PB9FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetPMCR_BOOSTE(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetPMCR_BOOSTE() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetPMCR_EPIS(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0xe00000)|value<<21)
}
func (o *SYSCFG_Type) GetPMCR_EPIS() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0xe00000) >> 21
}
func (o *SYSCFG_Type) SetPMCR_PA0SO(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCFG_Type) GetPMCR_PA0SO() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x1000000) >> 24
}
func (o *SYSCFG_Type) SetPMCR_PA1SO(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCFG_Type) GetPMCR_PA1SO() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x2000000) >> 25
}
func (o *SYSCFG_Type) SetPMCR_PC2SO(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCFG_Type) GetPMCR_PC2SO() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x4000000) >> 26
}
func (o *SYSCFG_Type) SetPMCR_PC3SO(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCFG_Type) GetPMCR_PC3SO() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x8000000) >> 27
}
func (o *SYSCFG_Type) SetPMCR_BOOSTVDDSEL(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x200)|value<<9)
}
func (o *SYSCFG_Type) GetPMCR_BOOSTVDDSEL() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x200) >> 9
}
func (o *SYSCFG_Type) SetPMCR_I2C5FMP(value uint32) {
	volatile.StoreUint32(&o.PMCR.Reg, volatile.LoadUint32(&o.PMCR.Reg)&^(0x400)|value<<10)
}
func (o *SYSCFG_Type) GetPMCR_I2C5FMP() uint32 {
	return (volatile.LoadUint32(&o.PMCR.Reg) & 0x400) >> 10
}

// SYSCFG.EXTICR1: external interrupt configuration register 1
func (o *SYSCFG_Type) SetEXTICR1_EXTI3(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI3() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI2(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI2() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI1(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI1() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI0(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI0() uint32 {
	return volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf
}

// SYSCFG.EXTICR2: external interrupt configuration register 2
func (o *SYSCFG_Type) SetEXTICR2_EXTI7(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI7() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI6(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI6() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI5(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI5() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI4(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI4() uint32 {
	return volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf
}

// SYSCFG.EXTICR3: external interrupt configuration register 3
func (o *SYSCFG_Type) SetEXTICR3_EXTI11(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI11() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI10(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI10() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI9(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI9() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI8(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI8() uint32 {
	return volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf
}

// SYSCFG.EXTICR4: external interrupt configuration register 4
func (o *SYSCFG_Type) SetEXTICR4_EXTI15(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI14(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI14() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI13(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI13() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI12(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI12() uint32 {
	return volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf
}

// SYSCFG.CFGR: Timer break lockup register
func (o *SYSCFG_Type) SetCFGR_PVDL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetCFGR_PVDL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetCFGR_FLASHL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetCFGR_FLASHL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetCFGR_CM7L(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetCFGR_CM7L() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetCFGR_BKRAML(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetCFGR_BKRAML() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetCFGR_SRAM4L(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200)|value<<9)
}
func (o *SYSCFG_Type) GetCFGR_SRAM4L() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200) >> 9
}
func (o *SYSCFG_Type) SetCFGR_SRAM2L(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800)|value<<11)
}
func (o *SYSCFG_Type) GetCFGR_SRAM2L() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800) >> 11
}
func (o *SYSCFG_Type) SetCFGR_SRAM1L(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCFG_Type) GetCFGR_SRAM1L() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000) >> 12
}
func (o *SYSCFG_Type) SetCFGR_DTCML(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCFG_Type) GetCFGR_DTCML() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x2000) >> 13
}
func (o *SYSCFG_Type) SetCFGR_ITCML(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCFG_Type) GetCFGR_ITCML() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x4000) >> 14
}
func (o *SYSCFG_Type) SetCFGR_AXIRAML(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCFG_Type) GetCFGR_AXIRAML() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8000) >> 15
}

// SYSCFG.CCCSR: compensation cell control/status register
func (o *SYSCFG_Type) SetCCCSR_EN(value uint32) {
	volatile.StoreUint32(&o.CCCSR.Reg, volatile.LoadUint32(&o.CCCSR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetCCCSR_EN() uint32 {
	return volatile.LoadUint32(&o.CCCSR.Reg) & 0x1
}
func (o *SYSCFG_Type) SetCCCSR_CS(value uint32) {
	volatile.StoreUint32(&o.CCCSR.Reg, volatile.LoadUint32(&o.CCCSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetCCCSR_CS() uint32 {
	return (volatile.LoadUint32(&o.CCCSR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetCCCSR_READY(value uint32) {
	volatile.StoreUint32(&o.CCCSR.Reg, volatile.LoadUint32(&o.CCCSR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCCCSR_READY() uint32 {
	return (volatile.LoadUint32(&o.CCCSR.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetCCCSR_HSLV(value uint32) {
	volatile.StoreUint32(&o.CCCSR.Reg, volatile.LoadUint32(&o.CCCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetCCCSR_HSLV() uint32 {
	return (volatile.LoadUint32(&o.CCCSR.Reg) & 0x10000) >> 16
}

// SYSCFG.CCVR: SYSCFG compensation cell value register
func (o *SYSCFG_Type) SetCCVR_NCV(value uint32) {
	volatile.StoreUint32(&o.CCVR.Reg, volatile.LoadUint32(&o.CCVR.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetCCVR_NCV() uint32 {
	return volatile.LoadUint32(&o.CCVR.Reg) & 0xf
}
func (o *SYSCFG_Type) SetCCVR_PCV(value uint32) {
	volatile.StoreUint32(&o.CCVR.Reg, volatile.LoadUint32(&o.CCVR.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetCCVR_PCV() uint32 {
	return (volatile.LoadUint32(&o.CCVR.Reg) & 0xf0) >> 4
}

// SYSCFG.CCCR: SYSCFG compensation cell code register
func (o *SYSCFG_Type) SetCCCR_NCC(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetCCCR_NCC() uint32 {
	return volatile.LoadUint32(&o.CCCR.Reg) & 0xf
}
func (o *SYSCFG_Type) SetCCCR_PCC(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetCCCR_PCC() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0xf0) >> 4
}

// SYSCFG.ADC2ALT: ADC2 internal input alternate connection
func (o *SYSCFG_Type) SetADC2ALT_ADC2_ROUT1(value uint32) {
	volatile.StoreUint32(&o.ADC2ALT.Reg, volatile.LoadUint32(&o.ADC2ALT.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetADC2ALT_ADC2_ROUT1() uint32 {
	return (volatile.LoadUint32(&o.ADC2ALT.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetADC2ALT_ADC2_ROUT0(value uint32) {
	volatile.StoreUint32(&o.ADC2ALT.Reg, volatile.LoadUint32(&o.ADC2ALT.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetADC2ALT_ADC2_ROUT0() uint32 {
	return volatile.LoadUint32(&o.ADC2ALT.Reg) & 0x1
}

// SYSCFG.PKGR: SYSCFG package register
func (o *SYSCFG_Type) SetPKGR_PKG(value uint32) {
	volatile.StoreUint32(&o.PKGR.Reg, volatile.LoadUint32(&o.PKGR.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetPKGR_PKG() uint32 {
	return volatile.LoadUint32(&o.PKGR.Reg) & 0xf
}

// SYSCFG.UR0: SYSCFG user register 0
func (o *SYSCFG_Type) SetUR0_RDP(value uint32) {
	volatile.StoreUint32(&o.UR0.Reg, volatile.LoadUint32(&o.UR0.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSCFG_Type) GetUR0_RDP() uint32 {
	return (volatile.LoadUint32(&o.UR0.Reg) & 0xff0000) >> 16
}

// SYSCFG.UR2: SYSCFG user register 2
func (o *SYSCFG_Type) SetUR2_BORH(value uint32) {
	volatile.StoreUint32(&o.UR2.Reg, volatile.LoadUint32(&o.UR2.Reg)&^(0x3)|value)
}
func (o *SYSCFG_Type) GetUR2_BORH() uint32 {
	return volatile.LoadUint32(&o.UR2.Reg) & 0x3
}
func (o *SYSCFG_Type) SetUR2_BOOT_ADD0(value uint32) {
	volatile.StoreUint32(&o.UR2.Reg, volatile.LoadUint32(&o.UR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCFG_Type) GetUR2_BOOT_ADD0() uint32 {
	return (volatile.LoadUint32(&o.UR2.Reg) & 0xffff0000) >> 16
}

// SYSCFG.UR3: SYSCFG user register 3
func (o *SYSCFG_Type) SetUR3_BOOT_ADD1(value uint32) {
	volatile.StoreUint32(&o.UR3.Reg, volatile.LoadUint32(&o.UR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCFG_Type) GetUR3_BOOT_ADD1() uint32 {
	return (volatile.LoadUint32(&o.UR3.Reg) & 0xffff0000) >> 16
}

// SYSCFG.UR4: SYSCFG user register 4
func (o *SYSCFG_Type) SetUR4_MEPAD_1(value uint32) {
	volatile.StoreUint32(&o.UR4.Reg, volatile.LoadUint32(&o.UR4.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetUR4_MEPAD_1() uint32 {
	return (volatile.LoadUint32(&o.UR4.Reg) & 0x10000) >> 16
}

// SYSCFG.UR5: SYSCFG user register 5
func (o *SYSCFG_Type) SetUR5_MESAD_1(value uint32) {
	volatile.StoreUint32(&o.UR5.Reg, volatile.LoadUint32(&o.UR5.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetUR5_MESAD_1() uint32 {
	return volatile.LoadUint32(&o.UR5.Reg) & 0x1
}
func (o *SYSCFG_Type) SetUR5_WRPN_1(value uint32) {
	volatile.StoreUint32(&o.UR5.Reg, volatile.LoadUint32(&o.UR5.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSCFG_Type) GetUR5_WRPN_1() uint32 {
	return (volatile.LoadUint32(&o.UR5.Reg) & 0xff0000) >> 16
}

// SYSCFG.UR6: SYSCFG user register 6
func (o *SYSCFG_Type) SetUR6_PA_BEG_1(value uint32) {
	volatile.StoreUint32(&o.UR6.Reg, volatile.LoadUint32(&o.UR6.Reg)&^(0xfff)|value)
}
func (o *SYSCFG_Type) GetUR6_PA_BEG_1() uint32 {
	return volatile.LoadUint32(&o.UR6.Reg) & 0xfff
}
func (o *SYSCFG_Type) SetUR6_PA_END_1(value uint32) {
	volatile.StoreUint32(&o.UR6.Reg, volatile.LoadUint32(&o.UR6.Reg)&^(0xfff0000)|value<<16)
}
func (o *SYSCFG_Type) GetUR6_PA_END_1() uint32 {
	return (volatile.LoadUint32(&o.UR6.Reg) & 0xfff0000) >> 16
}

// SYSCFG.UR7: SYSCFG user register 7
func (o *SYSCFG_Type) SetUR7_SA_BEG_1(value uint32) {
	volatile.StoreUint32(&o.UR7.Reg, volatile.LoadUint32(&o.UR7.Reg)&^(0xfff)|value)
}
func (o *SYSCFG_Type) GetUR7_SA_BEG_1() uint32 {
	return volatile.LoadUint32(&o.UR7.Reg) & 0xfff
}
func (o *SYSCFG_Type) SetUR7_SA_END_1(value uint32) {
	volatile.StoreUint32(&o.UR7.Reg, volatile.LoadUint32(&o.UR7.Reg)&^(0xfff0000)|value<<16)
}
func (o *SYSCFG_Type) GetUR7_SA_END_1() uint32 {
	return (volatile.LoadUint32(&o.UR7.Reg) & 0xfff0000) >> 16
}

// SYSCFG.UR11: SYSCFG user register 11
func (o *SYSCFG_Type) SetUR11_IWDG1M(value uint32) {
	volatile.StoreUint32(&o.UR11.Reg, volatile.LoadUint32(&o.UR11.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetUR11_IWDG1M() uint32 {
	return (volatile.LoadUint32(&o.UR11.Reg) & 0x10000) >> 16
}

// SYSCFG.UR12: SYSCFG user register 12
func (o *SYSCFG_Type) SetUR12_SECURE(value uint32) {
	volatile.StoreUint32(&o.UR12.Reg, volatile.LoadUint32(&o.UR12.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetUR12_SECURE() uint32 {
	return (volatile.LoadUint32(&o.UR12.Reg) & 0x10000) >> 16
}

// SYSCFG.UR13: SYSCFG user register 13
func (o *SYSCFG_Type) SetUR13_SDRS(value uint32) {
	volatile.StoreUint32(&o.UR13.Reg, volatile.LoadUint32(&o.UR13.Reg)&^(0x3)|value)
}
func (o *SYSCFG_Type) GetUR13_SDRS() uint32 {
	return volatile.LoadUint32(&o.UR13.Reg) & 0x3
}
func (o *SYSCFG_Type) SetUR13_D1SBRST(value uint32) {
	volatile.StoreUint32(&o.UR13.Reg, volatile.LoadUint32(&o.UR13.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetUR13_D1SBRST() uint32 {
	return (volatile.LoadUint32(&o.UR13.Reg) & 0x10000) >> 16
}

// SYSCFG.UR14: SYSCFG user register 14
func (o *SYSCFG_Type) SetUR14_D1STPRST(value uint32) {
	volatile.StoreUint32(&o.UR14.Reg, volatile.LoadUint32(&o.UR14.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetUR14_D1STPRST() uint32 {
	return volatile.LoadUint32(&o.UR14.Reg) & 0x1
}

// SYSCFG.UR15: SYSCFG user register 15
func (o *SYSCFG_Type) SetUR15_FZIWDGSTB(value uint32) {
	volatile.StoreUint32(&o.UR15.Reg, volatile.LoadUint32(&o.UR15.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetUR15_FZIWDGSTB() uint32 {
	return (volatile.LoadUint32(&o.UR15.Reg) & 0x10000) >> 16
}

// SYSCFG.UR16: SYSCFG user register 16
func (o *SYSCFG_Type) SetUR16_FZIWDGSTP(value uint32) {
	volatile.StoreUint32(&o.UR16.Reg, volatile.LoadUint32(&o.UR16.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetUR16_FZIWDGSTP() uint32 {
	return volatile.LoadUint32(&o.UR16.Reg) & 0x1
}
func (o *SYSCFG_Type) SetUR16_PKP(value uint32) {
	volatile.StoreUint32(&o.UR16.Reg, volatile.LoadUint32(&o.UR16.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetUR16_PKP() uint32 {
	return (volatile.LoadUint32(&o.UR16.Reg) & 0x10000) >> 16
}

// SYSCFG.UR17: SYSCFG user register 17
func (o *SYSCFG_Type) SetUR17_IO_HSLV(value uint32) {
	volatile.StoreUint32(&o.UR17.Reg, volatile.LoadUint32(&o.UR17.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetUR17_IO_HSLV() uint32 {
	return volatile.LoadUint32(&o.UR17.Reg) & 0x1
}
func (o *SYSCFG_Type) SetUR17_TCM_AXI_SHARED_CFG(value uint32) {
	volatile.StoreUint32(&o.UR17.Reg, volatile.LoadUint32(&o.UR17.Reg)&^(0x30000)|value<<16)
}
func (o *SYSCFG_Type) GetUR17_TCM_AXI_SHARED_CFG() uint32 {
	return (volatile.LoadUint32(&o.UR17.Reg) & 0x30000) >> 16
}

// SYSCFG.UR18: SYSCFG user register 18
func (o *SYSCFG_Type) SetUR18_CPU_FREQ_BOOST(value uint32) {
	volatile.StoreUint32(&o.UR18.Reg, volatile.LoadUint32(&o.UR18.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetUR18_CPU_FREQ_BOOST() uint32 {
	return volatile.LoadUint32(&o.UR18.Reg) & 0x1
}

// Advanced-timers
type TIM_Type struct {
	CR1          volatile.Register32 // 0x0
	CR2          volatile.Register32 // 0x4
	SMCR         volatile.Register32 // 0x8
	DIER         volatile.Register32 // 0xC
	SR           volatile.Register32 // 0x10
	EGR          volatile.Register32 // 0x14
	CCMR1_Output volatile.Register32 // 0x18
	CCMR2_Output volatile.Register32 // 0x1C
	CCER         volatile.Register32 // 0x20
	CNT          volatile.Register32 // 0x24
	PSC          volatile.Register32 // 0x28
	ARR          volatile.Register32 // 0x2C
	RCR          volatile.Register32 // 0x30
	CCR1         volatile.Register32 // 0x34
	CCR2         volatile.Register32 // 0x38
	CCR3         volatile.Register32 // 0x3C
	CCR4         volatile.Register32 // 0x40
	BDTR         volatile.Register32 // 0x44
	DCR          volatile.Register32 // 0x48
	DMAR         volatile.Register32 // 0x4C
	_            [4]byte
	CCMR3_Output volatile.Register32 // 0x54
	CCR5         volatile.Register32 // 0x58
	CRR6         volatile.Register32 // 0x5C
	AF1          volatile.Register32 // 0x60
	AF2          volatile.Register32 // 0x64
	TISEL        volatile.Register32 // 0x68
}

// TIM.CR1: control register 1
func (o *TIM_Type) SetCR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *TIM_Type) SetCR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCR1_URS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCR1_CMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x60)|value<<5)
}
func (o *TIM_Type) GetCR1_CMS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x60) >> 5
}
func (o *TIM_Type) SetCR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCR1_UIFREMAP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR1_UIFREMAP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}

// TIM.CR2: control register 2
func (o *TIM_Type) SetCR2_MMS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00000)|value<<20)
}
func (o *TIM_Type) GetCR2_MMS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00000) >> 20
}
func (o *TIM_Type) SetCR2_OIS6(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *TIM_Type) GetCR2_OIS6() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *TIM_Type) SetCR2_OIS5(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCR2_OIS5() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCR2_OIS4(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetCR2_OIS4() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetCR2_OIS3N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCR2_OIS3N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCR2_OIS3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCR2_OIS3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCR2_OIS2N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR2_OIS2N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCR2_OIS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCR2_OIS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCR2_OIS1N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCR2_OIS1N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCR2_OIS1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCR2_OIS1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCR2_TI1S(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR2_TI1S() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR2_MMS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCR2_MMS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR2_CCUS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR2_CCUS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR2_CCPC(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR2_CCPC() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// TIM.SMCR: slave mode control register
func (o *TIM_Type) SetSMCR_SMS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x7)|value)
}
func (o *TIM_Type) GetSMCR_SMS() uint32 {
	return volatile.LoadUint32(&o.SMCR.Reg) & 0x7
}
func (o *TIM_Type) SetSMCR_TS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetSMCR_TS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetSMCR_MSM(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSMCR_MSM() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSMCR_ETF(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetSMCR_ETF() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetSMCR_ETPS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x3000)|value<<12)
}
func (o *TIM_Type) GetSMCR_ETPS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x3000) >> 12
}
func (o *TIM_Type) SetSMCR_ECE(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetSMCR_ECE() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetSMCR_ETP(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetSMCR_ETP() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetSMCR_SMS_3(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetSMCR_SMS_3() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetSMCR_TS_4_3(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x300000)|value<<20)
}
func (o *TIM_Type) GetSMCR_TS_4_3() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x300000) >> 20
}

// TIM.DIER: DMA/Interrupt enable register
func (o *TIM_Type) SetDIER_TDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetDIER_TDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetDIER_COMDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetDIER_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetDIER_CC4DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetDIER_CC4DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetDIER_CC3DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetDIER_CC3DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetDIER_CC2DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetDIER_CC2DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetDIER_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetDIER_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetDIER_UDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetDIER_UDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetDIER_TIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetDIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetDIER_CC4IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetDIER_CC4IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetDIER_CC3IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetDIER_CC3IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetDIER_CC2IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetDIER_CC2IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetDIER_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetDIER_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetDIER_UIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetDIER_UIE() uint32 {
	return volatile.LoadUint32(&o.DIER.Reg) & 0x1
}
func (o *TIM_Type) SetDIER_BIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetDIER_BIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetDIER_COMIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetDIER_COMIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x20) >> 5
}

// TIM.SR: status register
func (o *TIM_Type) SetSR_CC6IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *TIM_Type) GetSR_CC6IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *TIM_Type) SetSR_CC5IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetSR_CC5IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetSR_SBIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetSR_SBIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetSR_CC4OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetSR_CC4OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetSR_CC3OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetSR_CC3OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetSR_CC2OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetSR_CC2OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetSR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetSR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetSR_B2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetSR_B2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetSR_BIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSR_BIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetSR_TIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetSR_COMIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetSR_COMIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetSR_CC4IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetSR_CC4IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetSR_CC3IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetSR_CC3IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetSR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetSR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetSR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetSR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetSR_UIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetSR_UIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// TIM.EGR: event generation register
func (o *TIM_Type) SetEGR_UG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetEGR_UG() uint32 {
	return volatile.LoadUint32(&o.EGR.Reg) & 0x1
}
func (o *TIM_Type) SetEGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetEGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetEGR_CC2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetEGR_CC2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetEGR_CC3G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetEGR_CC3G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetEGR_CC4G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetEGR_CC4G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetEGR_COMG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetEGR_COMG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetEGR_TG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetEGR_TG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetEGR_BG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetEGR_BG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetEGR_B2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetEGR_B2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x100) >> 8
}

// TIM.CCMR1_Output: capture/compare mode register 1 (output mode)
func (o *TIM_Type) SetCCMR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x3
}
func (o *TIM_Type) SetCCMR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR1_Output_OC1CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR1_Output_OC1CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR1_Output_CC2S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR1_Output_CC2S() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR1_Output_OC2FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR1_Output_OC2FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR1_Output_OC2PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR1_Output_OC2PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR1_Output_OC2M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR1_Output_OC2CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR1_Output_OC2CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR1_Output_OC1M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR1_Output_OC2M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCMR2_Output: capture/compare mode register 2 (output mode)
func (o *TIM_Type) SetCCMR2_Output_CC3S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR2_Output_CC3S() uint32 {
	return volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x3
}
func (o *TIM_Type) SetCCMR2_Output_OC3FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR2_Output_OC3FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR2_Output_OC3PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR2_Output_OC3PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR2_Output_OC3M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR2_Output_OC3CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR2_Output_OC3CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR2_Output_CC4S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR2_Output_CC4S() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR2_Output_OC4FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR2_Output_OC4FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR2_Output_OC4PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR2_Output_OC4PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR2_Output_OC4M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR2_Output_OC4CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR2_Output_OC4CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR2_Output_OC3M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR2_Output_OC4M_4(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M_4() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCER: capture/compare enable register
func (o *TIM_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}
func (o *TIM_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCCER_CC1NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCER_CC1NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCER_CC2E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCCER_CC2E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCCER_CC2P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetCCER_CC2P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetCCER_CC2NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetCCER_CC2NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetCCER_CC2NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCER_CC2NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCER_CC3E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCCER_CC3E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCCER_CC3P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCCER_CC3P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCCER_CC3NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCER_CC3NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCER_CC3NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCER_CC3NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCER_CC4E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCCER_CC4E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCCER_CC4P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCCER_CC4P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCCER_CC4NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCER_CC4NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCER_CC5E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCER_CC5E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCER_CC5P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20000)|value<<17)
}
func (o *TIM_Type) GetCCER_CC5P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20000) >> 17
}
func (o *TIM_Type) SetCCER_CC6E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100000)|value<<20)
}
func (o *TIM_Type) GetCCER_CC6E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100000) >> 20
}
func (o *TIM_Type) SetCCER_CC6P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200000)|value<<21)
}
func (o *TIM_Type) GetCCER_CC6P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200000) >> 21
}

// TIM.CNT: counter
func (o *TIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}
func (o *TIM_Type) SetCNT_UIFCPY(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCNT_UIFCPY() uint32 {
	return (volatile.LoadUint32(&o.CNT.Reg) & 0x80000000) >> 31
}

// TIM.PSC: prescaler
func (o *TIM_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIM.ARR: auto-reload register
func (o *TIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// TIM.RCR: repetition counter register
func (o *TIM_Type) SetRCR_REP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetRCR_REP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xff
}

// TIM.CCR1: capture/compare register
func (o *TIM_Type) SetCCR1_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR1_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0xffff
}

// TIM.CCR2: capture/compare register
func (o *TIM_Type) SetCCR2_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR2_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0xffff
}

// TIM.CCR3: capture/compare register
func (o *TIM_Type) SetCCR3_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR3_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg) & 0xffff
}

// TIM.CCR4: capture/compare register
func (o *TIM_Type) SetCCR4_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR4_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg) & 0xffff
}

// TIM.BDTR: break and dead-time register
func (o *TIM_Type) SetBDTR_DTG(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetBDTR_DTG() uint32 {
	return volatile.LoadUint32(&o.BDTR.Reg) & 0xff
}
func (o *TIM_Type) SetBDTR_LOCK(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetBDTR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetBDTR_OSSI(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetBDTR_OSSI() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetBDTR_OSSR(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetBDTR_OSSR() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetBDTR_BKE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetBDTR_BKE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetBDTR_BKP(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetBDTR_BKP() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetBDTR_AOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetBDTR_AOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetBDTR_MOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetBDTR_MOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetBDTR_BKF(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf0000)|value<<16)
}
func (o *TIM_Type) GetBDTR_BKF() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf0000) >> 16
}
func (o *TIM_Type) SetBDTR_BK2F(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf00000)|value<<20)
}
func (o *TIM_Type) GetBDTR_BK2F() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf00000) >> 20
}
func (o *TIM_Type) SetBDTR_BK2E(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetBDTR_BK2E() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetBDTR_BK2P(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000000)|value<<25)
}
func (o *TIM_Type) GetBDTR_BK2P() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000000) >> 25
}

// TIM.DCR: DMA control register
func (o *TIM_Type) SetDCR_DBL(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIM_Type) GetDCR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f00) >> 8
}
func (o *TIM_Type) SetDCR_DBA(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f)|value)
}
func (o *TIM_Type) GetDCR_DBA() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1f
}

// TIM.DMAR: DMA address for full transfer
func (o *TIM_Type) SetDMAR_DMAB(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, volatile.LoadUint32(&o.DMAR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetDMAR_DMAB() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg) & 0xffff
}

// TIM.CCMR3_Output: capture/compare mode register 3 (output mode)
func (o *TIM_Type) SetCCMR3_Output_OC5FE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR3_Output_OC5FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR3_Output_OC5PE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR3_Output_OC5PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR3_Output_OC5M(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR3_Output_OC5M() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR3_Output_OC5CE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR3_Output_OC5CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR3_Output_OC6FE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR3_Output_OC6FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR3_Output_OC6PE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR3_Output_OC6PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR3_Output_OC6M(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR3_Output_OC6M() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR3_Output_OC6CE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR3_Output_OC6CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR3_Output_OC5M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR3_Output_OC5M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR3_Output_OC6M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR3_Output_OC6M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCR5: capture/compare register
func (o *TIM_Type) SetCCR5_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR5_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR5.Reg) & 0xffff
}
func (o *TIM_Type) SetCCR5_GC5C1(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x20000000)|value<<29)
}
func (o *TIM_Type) GetCCR5_GC5C1() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x20000000) >> 29
}
func (o *TIM_Type) SetCCR5_GC5C2(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x40000000)|value<<30)
}
func (o *TIM_Type) GetCCR5_GC5C2() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x40000000) >> 30
}
func (o *TIM_Type) SetCCR5_GC5C3(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCCR5_GC5C3() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x80000000) >> 31
}

// TIM.CRR6: capture/compare register 6
func (o *TIM_Type) SetCRR6_CCR6(value uint32) {
	volatile.StoreUint32(&o.CRR6.Reg, volatile.LoadUint32(&o.CRR6.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCRR6_CCR6() uint32 {
	return volatile.LoadUint32(&o.CRR6.Reg) & 0xffff
}

// TIM.AF1: TIM1 alternate function option register 1
func (o *TIM_Type) SetAF1_BKINE(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF1_BKINE() uint32 {
	return volatile.LoadUint32(&o.AF1.Reg) & 0x1
}
func (o *TIM_Type) SetAF1_BKCMP1E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetAF1_BKCMP1E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetAF1_BKCMP2E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetAF1_BKCMP2E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetAF1_BKDF1BK0E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetAF1_BKDF1BK0E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetAF1_BKINP(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF1_BKINP() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetAF1_BKCMP1P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetAF1_BKCMP1P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetAF1_BKCMP2P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetAF1_BKCMP2P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetAF1_ETRSEL(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x3c000)|value<<14)
}
func (o *TIM_Type) GetAF1_ETRSEL() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x3c000) >> 14
}

// TIM.AF2: TIM1 Alternate function odfsdm1_breakster 2
func (o *TIM_Type) SetAF2_BK2INE(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF2_BK2INE() uint32 {
	return volatile.LoadUint32(&o.AF2.Reg) & 0x1
}
func (o *TIM_Type) SetAF2_BK2CMP1E(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetAF2_BK2CMP1E() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetAF2_BK2CMP2E(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetAF2_BK2CMP2E() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetAF2_BK2DF1BK1E(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetAF2_BK2DF1BK1E() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetAF2_BK2INP(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF2_BK2INP() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetAF2_BK2CMP1P(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetAF2_BK2CMP1P() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetAF2_BK2CMP2P(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetAF2_BK2CMP2P() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x800) >> 11
}

// TIM.TISEL: TIM1 timer input selection register
func (o *TIM_Type) SetTISEL_TI1SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf)|value)
}
func (o *TIM_Type) GetTISEL_TI1SEL() uint32 {
	return volatile.LoadUint32(&o.TISEL.Reg) & 0xf
}
func (o *TIM_Type) SetTISEL_TI2SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetTISEL_TI2SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetTISEL_TI3SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf0000)|value<<16)
}
func (o *TIM_Type) GetTISEL_TI3SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf0000) >> 16
}
func (o *TIM_Type) SetTISEL_TI4SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf000000)|value<<24)
}
func (o *TIM_Type) GetTISEL_TI4SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf000000) >> 24
}

// General purpose timers
type TIMs_Type struct {
	CR1          volatile.Register32 // 0x0
	CR2          volatile.Register32 // 0x4
	SMCR         volatile.Register32 // 0x8
	DIER         volatile.Register32 // 0xC
	SR           volatile.Register32 // 0x10
	EGR          volatile.Register32 // 0x14
	CCMR1_Output volatile.Register32 // 0x18
	_            [4]byte
	CCER         volatile.Register32 // 0x20
	CNT          volatile.Register32 // 0x24
	PSC          volatile.Register32 // 0x28
	ARR          volatile.Register32 // 0x2C
	RCR          volatile.Register32 // 0x30
	CCR1         volatile.Register32 // 0x34
	CCR2         volatile.Register32 // 0x38
	_            [8]byte
	BDTR         volatile.Register32 // 0x44
	DCR          volatile.Register32 // 0x48
	DMAR         volatile.Register32 // 0x4C
	_            [16]byte
	AF1          volatile.Register32 // 0x60
	_            [4]byte
	TISEL        volatile.Register32 // 0x68
}

// TIMs.CR1: control register 1
func (o *TIMs_Type) SetCR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetCR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *TIMs_Type) SetCR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TIMs_Type) GetCR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TIMs_Type) SetCR1_URS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetCR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetCR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *TIMs_Type) GetCR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *TIMs_Type) SetCR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetCR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetCR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x300)|value<<8)
}
func (o *TIMs_Type) GetCR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x300) >> 8
}
func (o *TIMs_Type) SetCR1_UIFREMAP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *TIMs_Type) GetCR1_UIFREMAP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}

// TIMs.CR2: control register 2
func (o *TIMs_Type) SetCR2_CCPC(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetCR2_CCPC() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *TIMs_Type) SetCR2_CCUS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetCR2_CCUS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetCR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *TIMs_Type) GetCR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *TIMs_Type) SetCR2_MMS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x70)|value<<4)
}
func (o *TIMs_Type) GetCR2_MMS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x70) >> 4
}
func (o *TIMs_Type) SetCR2_TI1S(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetCR2_TI1S() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetCR2_OIS1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *TIMs_Type) GetCR2_OIS1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *TIMs_Type) SetCR2_OIS1N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *TIMs_Type) GetCR2_OIS1N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *TIMs_Type) SetCR2_OIS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *TIMs_Type) GetCR2_OIS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}

// TIMs.SMCR: slave mode control register
func (o *TIMs_Type) SetSMCR_SMS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x7)|value)
}
func (o *TIMs_Type) GetSMCR_SMS() uint32 {
	return volatile.LoadUint32(&o.SMCR.Reg) & 0x7
}
func (o *TIMs_Type) SetSMCR_TS_2_0(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x70)|value<<4)
}
func (o *TIMs_Type) GetSMCR_TS_2_0() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x70) >> 4
}
func (o *TIMs_Type) SetSMCR_MSM(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetSMCR_MSM() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetSMCR_SMS_3(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x10000)|value<<16)
}
func (o *TIMs_Type) GetSMCR_SMS_3() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x10000) >> 16
}
func (o *TIMs_Type) SetSMCR_TS_4_3(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x300000)|value<<20)
}
func (o *TIMs_Type) GetSMCR_TS_4_3() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x300000) >> 20
}

// TIMs.DIER: DMA/Interrupt enable register
func (o *TIMs_Type) SetDIER_UIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetDIER_UIE() uint32 {
	return volatile.LoadUint32(&o.DIER.Reg) & 0x1
}
func (o *TIMs_Type) SetDIER_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2)|value<<1)
}
func (o *TIMs_Type) GetDIER_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2) >> 1
}
func (o *TIMs_Type) SetDIER_CC2IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetDIER_CC2IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetDIER_COMIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x20)|value<<5)
}
func (o *TIMs_Type) GetDIER_COMIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x20) >> 5
}
func (o *TIMs_Type) SetDIER_TIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x40)|value<<6)
}
func (o *TIMs_Type) GetDIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x40) >> 6
}
func (o *TIMs_Type) SetDIER_BIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetDIER_BIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetDIER_UDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x100)|value<<8)
}
func (o *TIMs_Type) GetDIER_UDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x100) >> 8
}
func (o *TIMs_Type) SetDIER_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x200)|value<<9)
}
func (o *TIMs_Type) GetDIER_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x200) >> 9
}
func (o *TIMs_Type) SetDIER_CC2DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x400)|value<<10)
}
func (o *TIMs_Type) GetDIER_CC2DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x400) >> 10
}
func (o *TIMs_Type) SetDIER_COMDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2000)|value<<13)
}
func (o *TIMs_Type) GetDIER_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2000) >> 13
}
func (o *TIMs_Type) SetDIER_TDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4000)|value<<14)
}
func (o *TIMs_Type) GetDIER_TDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4000) >> 14
}

// TIMs.SR: status register
func (o *TIMs_Type) SetSR_CC2OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TIMs_Type) GetSR_CC2OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TIMs_Type) SetSR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TIMs_Type) GetSR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TIMs_Type) SetSR_BIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetSR_BIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TIMs_Type) GetSR_TIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TIMs_Type) SetSR_COMIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TIMs_Type) GetSR_COMIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TIMs_Type) SetSR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetSR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetSR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TIMs_Type) GetSR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TIMs_Type) SetSR_UIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetSR_UIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// TIMs.EGR: event generation register
func (o *TIMs_Type) SetEGR_BG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetEGR_BG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetEGR_TG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x40)|value<<6)
}
func (o *TIMs_Type) GetEGR_TG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x40) >> 6
}
func (o *TIMs_Type) SetEGR_COMG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x20)|value<<5)
}
func (o *TIMs_Type) GetEGR_COMG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x20) >> 5
}
func (o *TIMs_Type) SetEGR_CC2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetEGR_CC2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetEGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x2)|value<<1)
}
func (o *TIMs_Type) GetEGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x2) >> 1
}
func (o *TIMs_Type) SetEGR_UG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetEGR_UG() uint32 {
	return volatile.LoadUint32(&o.EGR.Reg) & 0x1
}

// TIMs.CCMR1_Output: capture/compare mode register (output mode)
func (o *TIMs_Type) SetCCMR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x3)|value)
}
func (o *TIMs_Type) GetCCMR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x3
}
func (o *TIMs_Type) SetCCMR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetCCMR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetCCMR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIMs_Type) GetCCMR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8) >> 3
}
func (o *TIMs_Type) SetCCMR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIMs_Type) GetCCMR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x70) >> 4
}
func (o *TIMs_Type) SetCCMR1_Output_CC2S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIMs_Type) GetCCMR1_Output_CC2S() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x300) >> 8
}
func (o *TIMs_Type) SetCCMR1_Output_OC2FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIMs_Type) GetCCMR1_Output_OC2FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x400) >> 10
}
func (o *TIMs_Type) SetCCMR1_Output_OC2PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIMs_Type) GetCCMR1_Output_OC2PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x800) >> 11
}
func (o *TIMs_Type) SetCCMR1_Output_OC2M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIMs_Type) GetCCMR1_Output_OC2M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x7000) >> 12
}
func (o *TIMs_Type) SetCCMR1_Output_OC1M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIMs_Type) GetCCMR1_Output_OC1M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x10000) >> 16
}
func (o *TIMs_Type) SetCCMR1_Output_OC2M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIMs_Type) GetCCMR1_Output_OC2M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x1000000) >> 24
}

// TIMs.CCER: capture/compare enable register
func (o *TIMs_Type) SetCCER_CC2NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x80)|value<<7)
}
func (o *TIMs_Type) GetCCER_CC2NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x80) >> 7
}
func (o *TIMs_Type) SetCCER_CC2P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20)|value<<5)
}
func (o *TIMs_Type) GetCCER_CC2P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20) >> 5
}
func (o *TIMs_Type) SetCCER_CC2E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10)|value<<4)
}
func (o *TIMs_Type) GetCCER_CC2E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10) >> 4
}
func (o *TIMs_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIMs_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIMs_Type) SetCCER_CC1NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetCCER_CC1NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIMs_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIMs_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}

// TIMs.CNT: counter
func (o *TIMs_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TIMs_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}
func (o *TIMs_Type) SetCNT_UIFCPY(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMs_Type) GetCNT_UIFCPY() uint32 {
	return (volatile.LoadUint32(&o.CNT.Reg) & 0x80000000) >> 31
}

// TIMs.PSC: prescaler
func (o *TIMs_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIMs_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIMs.ARR: auto-reload register
func (o *TIMs_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *TIMs_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// TIMs.RCR: repetition counter register
func (o *TIMs_Type) SetRCR_REP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xff)|value)
}
func (o *TIMs_Type) GetRCR_REP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xff
}

// TIMs.CCR1: capture/compare register
func (o *TIMs_Type) SetCCR1_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xffff)|value)
}
func (o *TIMs_Type) GetCCR1_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0xffff
}

// TIMs.CCR2: capture/compare register
func (o *TIMs_Type) SetCCR2_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xffff)|value)
}
func (o *TIMs_Type) GetCCR2_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0xffff
}

// TIMs.BDTR: break and dead-time register
func (o *TIMs_Type) SetBDTR_MOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000)|value<<15)
}
func (o *TIMs_Type) GetBDTR_MOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000) >> 15
}
func (o *TIMs_Type) SetBDTR_AOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000)|value<<14)
}
func (o *TIMs_Type) GetBDTR_AOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000) >> 14
}
func (o *TIMs_Type) SetBDTR_BKP(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000)|value<<13)
}
func (o *TIMs_Type) GetBDTR_BKP() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000) >> 13
}
func (o *TIMs_Type) SetBDTR_BKE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000)|value<<12)
}
func (o *TIMs_Type) GetBDTR_BKE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000) >> 12
}
func (o *TIMs_Type) SetBDTR_OSSR(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x800)|value<<11)
}
func (o *TIMs_Type) GetBDTR_OSSR() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x800) >> 11
}
func (o *TIMs_Type) SetBDTR_OSSI(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x400)|value<<10)
}
func (o *TIMs_Type) GetBDTR_OSSI() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x400) >> 10
}
func (o *TIMs_Type) SetBDTR_LOCK(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x300)|value<<8)
}
func (o *TIMs_Type) GetBDTR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x300) >> 8
}
func (o *TIMs_Type) SetBDTR_DTG(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xff)|value)
}
func (o *TIMs_Type) GetBDTR_DTG() uint32 {
	return volatile.LoadUint32(&o.BDTR.Reg) & 0xff
}
func (o *TIMs_Type) SetBDTR_BKF(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf0000)|value<<16)
}
func (o *TIMs_Type) GetBDTR_BKF() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf0000) >> 16
}

// TIMs.DCR: DMA control register
func (o *TIMs_Type) SetDCR_DBL(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIMs_Type) GetDCR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f00) >> 8
}
func (o *TIMs_Type) SetDCR_DBA(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f)|value)
}
func (o *TIMs_Type) GetDCR_DBA() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1f
}

// TIMs.DMAR: DMA address for full transfer
func (o *TIMs_Type) SetDMAR_DMAB(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, volatile.LoadUint32(&o.DMAR.Reg)&^(0xffff)|value)
}
func (o *TIMs_Type) GetDMAR_DMAB() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg) & 0xffff
}

// TIMs.AF1: TIM15 alternate fdfsdm1_breakon register 1
func (o *TIMs_Type) SetAF1_BKINE(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x1)|value)
}
func (o *TIMs_Type) GetAF1_BKINE() uint32 {
	return volatile.LoadUint32(&o.AF1.Reg) & 0x1
}
func (o *TIMs_Type) SetAF1_BKCMP1E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x2)|value<<1)
}
func (o *TIMs_Type) GetAF1_BKCMP1E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x2) >> 1
}
func (o *TIMs_Type) SetAF1_BKCMP2E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x4)|value<<2)
}
func (o *TIMs_Type) GetAF1_BKCMP2E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x4) >> 2
}
func (o *TIMs_Type) SetAF1_BKDF1BK0E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x100)|value<<8)
}
func (o *TIMs_Type) GetAF1_BKDF1BK0E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x100) >> 8
}
func (o *TIMs_Type) SetAF1_BKINP(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x200)|value<<9)
}
func (o *TIMs_Type) GetAF1_BKINP() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x200) >> 9
}
func (o *TIMs_Type) SetAF1_BKCMP1P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x400)|value<<10)
}
func (o *TIMs_Type) GetAF1_BKCMP1P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x400) >> 10
}
func (o *TIMs_Type) SetAF1_BKCMP2P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x800)|value<<11)
}
func (o *TIMs_Type) GetAF1_BKCMP2P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x800) >> 11
}

// TIMs.TISEL: TIM15 input selection register
func (o *TIMs_Type) SetTISEL_TI1SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf)|value)
}
func (o *TIMs_Type) GetTISEL_TI1SEL() uint32 {
	return volatile.LoadUint32(&o.TISEL.Reg) & 0xf
}
func (o *TIMs_Type) SetTISEL_TI2SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf00)|value<<8)
}
func (o *TIMs_Type) GetTISEL_TI2SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf00) >> 8
}

// Universal synchronous asynchronous receiver transmitter
type USART_Type struct {
	CR1   volatile.Register32 // 0x0
	CR2   volatile.Register32 // 0x4
	CR3   volatile.Register32 // 0x8
	BRR   volatile.Register32 // 0xC
	GTPR  volatile.Register32 // 0x10
	RTOR  volatile.Register32 // 0x14
	RQR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	ICR   volatile.Register32 // 0x20
	RDR   volatile.Register32 // 0x24
	TDR   volatile.Register32 // 0x28
	PRESC volatile.Register32 // 0x2C
}

// USART.CR1: Control register 1
func (o *USART_Type) SetCR1_RXFFIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetCR1_RXFFIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000000) >> 31
}
func (o *USART_Type) SetCR1_TXFEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetCR1_TXFEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetCR1_FIFOEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetCR1_FIFOEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetCR1_M1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR1_M1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR1_EOBIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetCR1_EOBIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetCR1_RTOIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetCR1_RTOIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetCR1_OVER8(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR1_OVER8() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR1_CMIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR1_CMIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR1_MME(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR1_MME() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR1_M0(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR1_M0() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR1_TE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR1_RE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR1_UESM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR1_UESM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR1_UE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR1_UE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *USART_Type) SetCR1_DEAT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3e00000)|value<<21)
}
func (o *USART_Type) GetCR1_DEAT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3e00000) >> 21
}
func (o *USART_Type) SetCR1_DEDT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *USART_Type) GetCR1_DEDT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1f0000) >> 16
}

// USART.CR2: Control register 2
func (o *USART_Type) SetCR2_RTOEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR2_RTOEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR2_ABREN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetCR2_ABREN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetCR2_MSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR2_MSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCR2_DATAINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR2_DATAINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR2_TXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetCR2_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetCR2_RXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetCR2_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetCR2_SWAP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR2_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR2_LINEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR2_LINEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR2_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR2_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR2_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR2_LBCL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR2_LBCL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR2_LBDIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR2_LBDIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR2_LBDL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR2_LBDL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR2_ADDM7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR2_ADDM7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR2_DIS_NSS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR2_DIS_NSS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR2_SLVEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR2_SLVEN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *USART_Type) SetCR2_ABRMOD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x600000)|value<<21)
}
func (o *USART_Type) GetCR2_ABRMOD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x600000) >> 21
}
func (o *USART_Type) SetCR2_ADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetCR2_ADD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff000000) >> 24
}

// USART.CR3: Control register 3
func (o *USART_Type) SetCR3_TXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000000)|value<<29)
}
func (o *USART_Type) GetCR3_TXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000000) >> 29
}
func (o *USART_Type) SetCR3_RXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR3_RXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR3_RXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe000000)|value<<25)
}
func (o *USART_Type) GetCR3_RXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe000000) >> 25
}
func (o *USART_Type) SetCR3_TCBGTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetCR3_TCBGTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000000) >> 24
}
func (o *USART_Type) SetCR3_TXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR3_TXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR3_WUFIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetCR3_WUFIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetCR3_WUS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x300000)|value<<20)
}
func (o *USART_Type) GetCR3_WUS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x300000) >> 20
}
func (o *USART_Type) SetCR3_SCARCNT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000)|value<<17)
}
func (o *USART_Type) GetCR3_SCARCNT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000) >> 17
}
func (o *USART_Type) SetCR3_DEP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR3_DEP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR3_DEM(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR3_DEM() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR3_DDRE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR3_DDRE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR3_OVRDIS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR3_OVRDIS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR3_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR3_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR3_SCEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR3_SCEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR3_NACK(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR3_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR3_IRLP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR3_IRLP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR3_IREN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR3_IREN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// USART.BRR: Baud rate register
func (o *USART_Type) SetBRR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xffff
}

// USART.GTPR: Guard time and prescaler register
func (o *USART_Type) SetGTPR_GT(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetGTPR_GT() uint32 {
	return (volatile.LoadUint32(&o.GTPR.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetGTPR_PSC(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetGTPR_PSC() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg) & 0xff
}

// USART.RTOR: Receiver timeout register
func (o *USART_Type) SetRTOR_BLEN(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetRTOR_BLEN() uint32 {
	return (volatile.LoadUint32(&o.RTOR.Reg) & 0xff000000) >> 24
}
func (o *USART_Type) SetRTOR_RTO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetRTOR_RTO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffffff
}

// USART.RQR: Request register
func (o *USART_Type) SetRQR_TXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetRQR_TXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetRQR_RXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetRQR_RXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetRQR_MMRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetRQR_MMRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetRQR_SBKRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetRQR_SBKRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetRQR_ABRRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetRQR_ABRRQ() uint32 {
	return volatile.LoadUint32(&o.RQR.Reg) & 0x1
}

// USART.ISR: Interrupt & status register
func (o *USART_Type) SetISR_TXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetISR_TXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetISR_RXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetISR_RXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetISR_TCBGT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *USART_Type) GetISR_TCBGT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *USART_Type) SetISR_RXFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetISR_RXFF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *USART_Type) SetISR_TXFE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetISR_TXFE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetISR_REACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetISR_REACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetISR_TEACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetISR_TEACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetISR_WUF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetISR_WUF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetISR_RWU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetISR_RWU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetISR_SBKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetISR_SBKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetISR_CMF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetISR_CMF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetISR_ABRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetISR_ABRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetISR_ABRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetISR_ABRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetISR_UDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetISR_UDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetISR_EOBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetISR_EOBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetISR_RTOF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetISR_RTOF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetISR_CTS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetISR_CTS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetISR_CTSIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetISR_CTSIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetISR_LBDF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetISR_LBDF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetISR_IDLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetISR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetISR_ORE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetISR_ORE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetISR_NF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetISR_NF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetISR_FE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetISR_FE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetISR_PE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetISR_PE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// USART.ICR: Interrupt flag clear register
func (o *USART_Type) SetICR_WUCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetICR_WUCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetICR_CMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetICR_CMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetICR_UDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetICR_UDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetICR_EOBCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetICR_EOBCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetICR_RTOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetICR_RTOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetICR_CTSCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetICR_CTSCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetICR_LBDCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetICR_LBDCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetICR_TCBGTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetICR_TCBGTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetICR_TCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetICR_TCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetICR_TXFECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetICR_TXFECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetICR_IDLECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetICR_IDLECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetICR_ORECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetICR_ORECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetICR_NCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetICR_NCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetICR_FECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetICR_FECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetICR_PECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetICR_PECF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// USART.RDR: Receive data register
func (o *USART_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0x1ff
}

// USART.TDR: Transmit data register
func (o *USART_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0x1ff
}

// USART.PRESC: USART prescaler register
func (o *USART_Type) SetPRESC_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESC.Reg, volatile.LoadUint32(&o.PRESC.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetPRESC_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESC.Reg) & 0xf
}

// VREFBUF
type VREFBUF_Type struct {
	CSR volatile.Register32 // 0x0
	CCR volatile.Register32 // 0x4
}

// VREFBUF.CSR: VREFBUF control and status register
func (o *VREFBUF_Type) SetCSR_ENVR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *VREFBUF_Type) GetCSR_ENVR() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *VREFBUF_Type) SetCSR_HIZ(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *VREFBUF_Type) GetCSR_HIZ() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *VREFBUF_Type) SetCSR_VRR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *VREFBUF_Type) GetCSR_VRR() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *VREFBUF_Type) SetCSR_VRS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x70)|value<<4)
}
func (o *VREFBUF_Type) GetCSR_VRS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x70) >> 4
}

// VREFBUF.CCR: VREFBUF calibration control register
func (o *VREFBUF_Type) SetCCR_TRIM(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3f)|value)
}
func (o *VREFBUF_Type) GetCCR_TRIM() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x3f
}

// WWDG
type WWDG_Type struct {
	CR  volatile.Register32 // 0x0
	CFR volatile.Register32 // 0x4
	SR  volatile.Register32 // 0x8
}

// WWDG.CR: Control register
func (o *WWDG_Type) SetCR_T(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCR_T() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCR_WDGA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *WWDG_Type) GetCR_WDGA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// WWDG.CFR: Configuration register
func (o *WWDG_Type) SetCFR_W(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCFR_W() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCFR_EWI(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *WWDG_Type) GetCFR_EWI() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *WWDG_Type) SetCFR_WDGTB(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x3800)|value<<11)
}
func (o *WWDG_Type) GetCFR_WDGTB() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x3800) >> 11
}

// WWDG.SR: Status register
func (o *WWDG_Type) SetSR_EWIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *WWDG_Type) GetSR_EWIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Basic Direct Memory Access
type BDMA_Type struct {
	ISR  volatile.Register32 // 0x0
	IFCR volatile.Register32 // 0x4
	CH   [8]BDMA_CH_Type     // 0x8
}

// BDMA.ISR: Interrupt status register
func (o *BDMA_Type) SetISR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *BDMA_Type) GetISR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}
func (o *BDMA_Type) SetISR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *BDMA_Type) GetISR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *BDMA_Type) SetISR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *BDMA_Type) GetISR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *BDMA_Type) SetISR_GIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *BDMA_Type) GetISR_GIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}
func (o *BDMA_Type) SetISR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *BDMA_Type) GetISR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *BDMA_Type) SetISR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *BDMA_Type) GetISR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *BDMA_Type) SetISR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *BDMA_Type) GetISR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *BDMA_Type) SetISR_GIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *BDMA_Type) GetISR_GIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *BDMA_Type) SetISR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *BDMA_Type) GetISR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *BDMA_Type) SetISR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *BDMA_Type) GetISR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *BDMA_Type) SetISR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *BDMA_Type) GetISR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *BDMA_Type) SetISR_GIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *BDMA_Type) GetISR_GIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *BDMA_Type) SetISR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *BDMA_Type) GetISR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *BDMA_Type) SetISR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *BDMA_Type) GetISR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *BDMA_Type) SetISR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *BDMA_Type) GetISR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *BDMA_Type) SetISR_GIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *BDMA_Type) GetISR_GIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *BDMA_Type) SetISR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *BDMA_Type) GetISR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *BDMA_Type) SetISR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *BDMA_Type) GetISR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *BDMA_Type) SetISR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *BDMA_Type) GetISR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *BDMA_Type) SetISR_GIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *BDMA_Type) GetISR_GIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *BDMA_Type) SetISR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *BDMA_Type) GetISR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *BDMA_Type) SetISR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *BDMA_Type) GetISR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *BDMA_Type) SetISR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *BDMA_Type) GetISR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *BDMA_Type) SetISR_GIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *BDMA_Type) GetISR_GIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *BDMA_Type) SetISR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *BDMA_Type) GetISR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *BDMA_Type) SetISR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *BDMA_Type) GetISR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *BDMA_Type) SetISR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *BDMA_Type) GetISR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *BDMA_Type) SetISR_GIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *BDMA_Type) GetISR_GIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *BDMA_Type) SetISR_TEIF0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *BDMA_Type) GetISR_TEIF0() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *BDMA_Type) SetISR_HTIF0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *BDMA_Type) GetISR_HTIF0() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *BDMA_Type) SetISR_TCIF0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *BDMA_Type) GetISR_TCIF0() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *BDMA_Type) SetISR_GIF0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *BDMA_Type) GetISR_GIF0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// BDMA.IFCR: Interrupt flag clear register
func (o *BDMA_Type) SetIFCR_CTEIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80000000)|value<<31)
}
func (o *BDMA_Type) GetIFCR_CTEIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80000000) >> 31
}
func (o *BDMA_Type) SetIFCR_CHTIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40000000)|value<<30)
}
func (o *BDMA_Type) GetIFCR_CHTIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40000000) >> 30
}
func (o *BDMA_Type) SetIFCR_CTCIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20000000)|value<<29)
}
func (o *BDMA_Type) GetIFCR_CTCIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20000000) >> 29
}
func (o *BDMA_Type) SetIFCR_CGIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10000000)|value<<28)
}
func (o *BDMA_Type) GetIFCR_CGIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10000000) >> 28
}
func (o *BDMA_Type) SetIFCR_CTEIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *BDMA_Type) GetIFCR_CTEIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000000) >> 27
}
func (o *BDMA_Type) SetIFCR_CHTIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *BDMA_Type) GetIFCR_CHTIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000000) >> 26
}
func (o *BDMA_Type) SetIFCR_CTCIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *BDMA_Type) GetIFCR_CTCIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000000) >> 25
}
func (o *BDMA_Type) SetIFCR_CGIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *BDMA_Type) GetIFCR_CGIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000000) >> 24
}
func (o *BDMA_Type) SetIFCR_CTEIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800000)|value<<23)
}
func (o *BDMA_Type) GetIFCR_CTEIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800000) >> 23
}
func (o *BDMA_Type) SetIFCR_CHTIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400000)|value<<22)
}
func (o *BDMA_Type) GetIFCR_CHTIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400000) >> 22
}
func (o *BDMA_Type) SetIFCR_CTCIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200000)|value<<21)
}
func (o *BDMA_Type) GetIFCR_CTCIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200000) >> 21
}
func (o *BDMA_Type) SetIFCR_CGIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100000)|value<<20)
}
func (o *BDMA_Type) GetIFCR_CGIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100000) >> 20
}
func (o *BDMA_Type) SetIFCR_CTEIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80000)|value<<19)
}
func (o *BDMA_Type) GetIFCR_CTEIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80000) >> 19
}
func (o *BDMA_Type) SetIFCR_CHTIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40000)|value<<18)
}
func (o *BDMA_Type) GetIFCR_CHTIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40000) >> 18
}
func (o *BDMA_Type) SetIFCR_CTCIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20000)|value<<17)
}
func (o *BDMA_Type) GetIFCR_CTCIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20000) >> 17
}
func (o *BDMA_Type) SetIFCR_CGIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10000)|value<<16)
}
func (o *BDMA_Type) GetIFCR_CGIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10000) >> 16
}
func (o *BDMA_Type) SetIFCR_CTEIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000)|value<<15)
}
func (o *BDMA_Type) GetIFCR_CTEIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000) >> 15
}
func (o *BDMA_Type) SetIFCR_CHTIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000)|value<<14)
}
func (o *BDMA_Type) GetIFCR_CHTIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000) >> 14
}
func (o *BDMA_Type) SetIFCR_CTCIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000)|value<<13)
}
func (o *BDMA_Type) GetIFCR_CTCIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000) >> 13
}
func (o *BDMA_Type) SetIFCR_CGIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000)|value<<12)
}
func (o *BDMA_Type) GetIFCR_CGIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000) >> 12
}
func (o *BDMA_Type) SetIFCR_CTEIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800)|value<<11)
}
func (o *BDMA_Type) GetIFCR_CTEIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800) >> 11
}
func (o *BDMA_Type) SetIFCR_CHTIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400)|value<<10)
}
func (o *BDMA_Type) GetIFCR_CHTIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400) >> 10
}
func (o *BDMA_Type) SetIFCR_CTCIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200)|value<<9)
}
func (o *BDMA_Type) GetIFCR_CTCIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200) >> 9
}
func (o *BDMA_Type) SetIFCR_CGIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100)|value<<8)
}
func (o *BDMA_Type) GetIFCR_CGIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100) >> 8
}
func (o *BDMA_Type) SetIFCR_CTEIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80)|value<<7)
}
func (o *BDMA_Type) GetIFCR_CTEIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80) >> 7
}
func (o *BDMA_Type) SetIFCR_CHTIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40)|value<<6)
}
func (o *BDMA_Type) GetIFCR_CHTIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40) >> 6
}
func (o *BDMA_Type) SetIFCR_CTCIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *BDMA_Type) GetIFCR_CTCIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *BDMA_Type) SetIFCR_CGIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *BDMA_Type) GetIFCR_CGIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *BDMA_Type) SetIFCR_CTEIF0(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *BDMA_Type) GetIFCR_CTEIF0() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *BDMA_Type) SetIFCR_CHTIF0(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *BDMA_Type) GetIFCR_CHTIF0() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *BDMA_Type) SetIFCR_CTCIF0(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *BDMA_Type) GetIFCR_CTCIF0() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *BDMA_Type) SetIFCR_CGIF0(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *BDMA_Type) GetIFCR_CGIF0() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}

type BDMA_CH_Type struct {
	CR   volatile.Register32 // 0x8
	NDTR volatile.Register32 // 0xC
	PAR  volatile.Register32 // 0x10
	M0AR volatile.Register32 // 0x14
	M1AR volatile.Register32 // 0x18
}

// BDMA_CH.CR: Channel x configuration register
func (o *BDMA_CH_Type) SetCR_CT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *BDMA_CH_Type) GetCR_CT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *BDMA_CH_Type) SetCR_DBM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *BDMA_CH_Type) GetCR_DBM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *BDMA_CH_Type) SetCR_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *BDMA_CH_Type) GetCR_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *BDMA_CH_Type) SetCR_PL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3000)|value<<12)
}
func (o *BDMA_CH_Type) GetCR_PL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3000) >> 12
}
func (o *BDMA_CH_Type) SetCR_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *BDMA_CH_Type) GetCR_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *BDMA_CH_Type) SetCR_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *BDMA_CH_Type) GetCR_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *BDMA_CH_Type) SetCR_MINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *BDMA_CH_Type) GetCR_MINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *BDMA_CH_Type) SetCR_PINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *BDMA_CH_Type) GetCR_PINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *BDMA_CH_Type) SetCR_CIRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *BDMA_CH_Type) GetCR_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *BDMA_CH_Type) SetCR_DIR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *BDMA_CH_Type) GetCR_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *BDMA_CH_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *BDMA_CH_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *BDMA_CH_Type) SetCR_HTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *BDMA_CH_Type) GetCR_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *BDMA_CH_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *BDMA_CH_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *BDMA_CH_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *BDMA_CH_Type) GetCR_EN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}

// BDMA_CH.NDTR: Channel x number of data to transfer register
func (o *BDMA_CH_Type) SetNDTR_NDT(value uint32) {
	volatile.StoreUint32(&o.NDTR.Reg, volatile.LoadUint32(&o.NDTR.Reg)&^(0xffff)|value)
}
func (o *BDMA_CH_Type) GetNDTR_NDT() uint32 {
	return volatile.LoadUint32(&o.NDTR.Reg) & 0xffff
}

// BDMA_CH.PAR: Channel x peripheral address register
func (o *BDMA_CH_Type) SetPAR(value uint32) {
	volatile.StoreUint32(&o.PAR.Reg, value)
}
func (o *BDMA_CH_Type) GetPAR() uint32 {
	return volatile.LoadUint32(&o.PAR.Reg)
}

// BDMA_CH.M0AR: Channel x memory 0 address register
func (o *BDMA_CH_Type) SetM0AR(value uint32) {
	volatile.StoreUint32(&o.M0AR.Reg, value)
}
func (o *BDMA_CH_Type) GetM0AR() uint32 {
	return volatile.LoadUint32(&o.M0AR.Reg)
}

// BDMA_CH.M1AR: Channel x memory 1 address register
func (o *BDMA_CH_Type) SetM1AR(value uint32) {
	volatile.StoreUint32(&o.M1AR.Reg, value)
}
func (o *BDMA_CH_Type) GetM1AR() uint32 {
	return volatile.LoadUint32(&o.M1AR.Reg)
}

// Ethernet DMA
type Ethernet_DMA_Type struct {
	DMAMR      volatile.Register32 // 0x0
	DMASBMR    volatile.Register32 // 0x4
	DMAISR     volatile.Register32 // 0x8
	DMADSR     volatile.Register32 // 0xC
	_          [240]byte
	DMACCR     volatile.Register32 // 0x100
	DMACTxCR   volatile.Register32 // 0x104
	DMACRxCR   volatile.Register32 // 0x108
	_          [8]byte
	DMACTxDLAR volatile.Register32 // 0x114
	_          [4]byte
	DMACRxDLAR volatile.Register32 // 0x11C
	DMACTxDTPR volatile.Register32 // 0x120
	_          [4]byte
	DMACRxDTPR volatile.Register32 // 0x128
	DMACTxRLR  volatile.Register32 // 0x12C
	DMACRxRLR  volatile.Register32 // 0x130
	DMACIER    volatile.Register32 // 0x134
	DMACRxIWTR volatile.Register32 // 0x138
	_          [8]byte
	DMACCATxDR volatile.Register32 // 0x144
	_          [4]byte
	DMACCARxDR volatile.Register32 // 0x14C
	_          [4]byte
	DMACCATxBR volatile.Register32 // 0x154
	_          [4]byte
	DMACCARxBR volatile.Register32 // 0x15C
	DMACSR     volatile.Register32 // 0x160
	_          [8]byte
	DMACMFCR   volatile.Register32 // 0x16C
}

// Ethernet_DMA.DMAMR: DMA mode register
func (o *Ethernet_DMA_Type) SetDMAMR_INTM(value uint32) {
	volatile.StoreUint32(&o.DMAMR.Reg, volatile.LoadUint32(&o.DMAMR.Reg)&^(0x30000)|value<<16)
}
func (o *Ethernet_DMA_Type) GetDMAMR_INTM() uint32 {
	return (volatile.LoadUint32(&o.DMAMR.Reg) & 0x30000) >> 16
}
func (o *Ethernet_DMA_Type) SetDMAMR_PR(value uint32) {
	volatile.StoreUint32(&o.DMAMR.Reg, volatile.LoadUint32(&o.DMAMR.Reg)&^(0x7000)|value<<12)
}
func (o *Ethernet_DMA_Type) GetDMAMR_PR() uint32 {
	return (volatile.LoadUint32(&o.DMAMR.Reg) & 0x7000) >> 12
}
func (o *Ethernet_DMA_Type) SetDMAMR_TXPR(value uint32) {
	volatile.StoreUint32(&o.DMAMR.Reg, volatile.LoadUint32(&o.DMAMR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_DMA_Type) GetDMAMR_TXPR() uint32 {
	return (volatile.LoadUint32(&o.DMAMR.Reg) & 0x800) >> 11
}
func (o *Ethernet_DMA_Type) SetDMAMR_DA(value uint32) {
	volatile.StoreUint32(&o.DMAMR.Reg, volatile.LoadUint32(&o.DMAMR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_DMA_Type) GetDMAMR_DA() uint32 {
	return (volatile.LoadUint32(&o.DMAMR.Reg) & 0x2) >> 1
}
func (o *Ethernet_DMA_Type) SetDMAMR_SWR(value uint32) {
	volatile.StoreUint32(&o.DMAMR.Reg, volatile.LoadUint32(&o.DMAMR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMAMR_SWR() uint32 {
	return volatile.LoadUint32(&o.DMAMR.Reg) & 0x1
}

// Ethernet_DMA.DMASBMR: System bus mode register
func (o *Ethernet_DMA_Type) SetDMASBMR_RB(value uint32) {
	volatile.StoreUint32(&o.DMASBMR.Reg, volatile.LoadUint32(&o.DMASBMR.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_DMA_Type) GetDMASBMR_RB() uint32 {
	return (volatile.LoadUint32(&o.DMASBMR.Reg) & 0x8000) >> 15
}
func (o *Ethernet_DMA_Type) SetDMASBMR_MB(value uint32) {
	volatile.StoreUint32(&o.DMASBMR.Reg, volatile.LoadUint32(&o.DMASBMR.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_DMA_Type) GetDMASBMR_MB() uint32 {
	return (volatile.LoadUint32(&o.DMASBMR.Reg) & 0x4000) >> 14
}
func (o *Ethernet_DMA_Type) SetDMASBMR_AAL(value uint32) {
	volatile.StoreUint32(&o.DMASBMR.Reg, volatile.LoadUint32(&o.DMASBMR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_DMA_Type) GetDMASBMR_AAL() uint32 {
	return (volatile.LoadUint32(&o.DMASBMR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_DMA_Type) SetDMASBMR_FB(value uint32) {
	volatile.StoreUint32(&o.DMASBMR.Reg, volatile.LoadUint32(&o.DMASBMR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMASBMR_FB() uint32 {
	return volatile.LoadUint32(&o.DMASBMR.Reg) & 0x1
}

// Ethernet_DMA.DMAISR: Interrupt status register
func (o *Ethernet_DMA_Type) SetDMAISR_MACIS(value uint32) {
	volatile.StoreUint32(&o.DMAISR.Reg, volatile.LoadUint32(&o.DMAISR.Reg)&^(0x20000)|value<<17)
}
func (o *Ethernet_DMA_Type) GetDMAISR_MACIS() uint32 {
	return (volatile.LoadUint32(&o.DMAISR.Reg) & 0x20000) >> 17
}
func (o *Ethernet_DMA_Type) SetDMAISR_MTLIS(value uint32) {
	volatile.StoreUint32(&o.DMAISR.Reg, volatile.LoadUint32(&o.DMAISR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_DMA_Type) GetDMAISR_MTLIS() uint32 {
	return (volatile.LoadUint32(&o.DMAISR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_DMA_Type) SetDMAISR_DC0IS(value uint32) {
	volatile.StoreUint32(&o.DMAISR.Reg, volatile.LoadUint32(&o.DMAISR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMAISR_DC0IS() uint32 {
	return volatile.LoadUint32(&o.DMAISR.Reg) & 0x1
}

// Ethernet_DMA.DMADSR: Debug status register
func (o *Ethernet_DMA_Type) SetDMADSR_TPS0(value uint32) {
	volatile.StoreUint32(&o.DMADSR.Reg, volatile.LoadUint32(&o.DMADSR.Reg)&^(0xf000)|value<<12)
}
func (o *Ethernet_DMA_Type) GetDMADSR_TPS0() uint32 {
	return (volatile.LoadUint32(&o.DMADSR.Reg) & 0xf000) >> 12
}
func (o *Ethernet_DMA_Type) SetDMADSR_RPS0(value uint32) {
	volatile.StoreUint32(&o.DMADSR.Reg, volatile.LoadUint32(&o.DMADSR.Reg)&^(0xf00)|value<<8)
}
func (o *Ethernet_DMA_Type) GetDMADSR_RPS0() uint32 {
	return (volatile.LoadUint32(&o.DMADSR.Reg) & 0xf00) >> 8
}
func (o *Ethernet_DMA_Type) SetDMADSR_AXWHSTS(value uint32) {
	volatile.StoreUint32(&o.DMADSR.Reg, volatile.LoadUint32(&o.DMADSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMADSR_AXWHSTS() uint32 {
	return volatile.LoadUint32(&o.DMADSR.Reg) & 0x1
}

// Ethernet_DMA.DMACCR: Channel control register
func (o *Ethernet_DMA_Type) SetDMACCR_DSL(value uint32) {
	volatile.StoreUint32(&o.DMACCR.Reg, volatile.LoadUint32(&o.DMACCR.Reg)&^(0x1c0000)|value<<18)
}
func (o *Ethernet_DMA_Type) GetDMACCR_DSL() uint32 {
	return (volatile.LoadUint32(&o.DMACCR.Reg) & 0x1c0000) >> 18
}
func (o *Ethernet_DMA_Type) SetDMACCR_PBLX8(value uint32) {
	volatile.StoreUint32(&o.DMACCR.Reg, volatile.LoadUint32(&o.DMACCR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_DMA_Type) GetDMACCR_PBLX8() uint32 {
	return (volatile.LoadUint32(&o.DMACCR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_DMA_Type) SetDMACCR_MSS(value uint32) {
	volatile.StoreUint32(&o.DMACCR.Reg, volatile.LoadUint32(&o.DMACCR.Reg)&^(0x3fff)|value)
}
func (o *Ethernet_DMA_Type) GetDMACCR_MSS() uint32 {
	return volatile.LoadUint32(&o.DMACCR.Reg) & 0x3fff
}

// Ethernet_DMA.DMACTxCR: Channel transmit control register
func (o *Ethernet_DMA_Type) SetDMACTxCR_TXPBL(value uint32) {
	volatile.StoreUint32(&o.DMACTxCR.Reg, volatile.LoadUint32(&o.DMACTxCR.Reg)&^(0x3f0000)|value<<16)
}
func (o *Ethernet_DMA_Type) GetDMACTxCR_TXPBL() uint32 {
	return (volatile.LoadUint32(&o.DMACTxCR.Reg) & 0x3f0000) >> 16
}
func (o *Ethernet_DMA_Type) SetDMACTxCR_TSE(value uint32) {
	volatile.StoreUint32(&o.DMACTxCR.Reg, volatile.LoadUint32(&o.DMACTxCR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_DMA_Type) GetDMACTxCR_TSE() uint32 {
	return (volatile.LoadUint32(&o.DMACTxCR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_DMA_Type) SetDMACTxCR_OSF(value uint32) {
	volatile.StoreUint32(&o.DMACTxCR.Reg, volatile.LoadUint32(&o.DMACTxCR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_DMA_Type) GetDMACTxCR_OSF() uint32 {
	return (volatile.LoadUint32(&o.DMACTxCR.Reg) & 0x10) >> 4
}
func (o *Ethernet_DMA_Type) SetDMACTxCR_ST(value uint32) {
	volatile.StoreUint32(&o.DMACTxCR.Reg, volatile.LoadUint32(&o.DMACTxCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMACTxCR_ST() uint32 {
	return volatile.LoadUint32(&o.DMACTxCR.Reg) & 0x1
}

// Ethernet_DMA.DMACRxCR: Channel receive control register
func (o *Ethernet_DMA_Type) SetDMACRxCR_RPF(value uint32) {
	volatile.StoreUint32(&o.DMACRxCR.Reg, volatile.LoadUint32(&o.DMACRxCR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_DMA_Type) GetDMACRxCR_RPF() uint32 {
	return (volatile.LoadUint32(&o.DMACRxCR.Reg) & 0x80000000) >> 31
}
func (o *Ethernet_DMA_Type) SetDMACRxCR_RXPBL(value uint32) {
	volatile.StoreUint32(&o.DMACRxCR.Reg, volatile.LoadUint32(&o.DMACRxCR.Reg)&^(0x3f0000)|value<<16)
}
func (o *Ethernet_DMA_Type) GetDMACRxCR_RXPBL() uint32 {
	return (volatile.LoadUint32(&o.DMACRxCR.Reg) & 0x3f0000) >> 16
}
func (o *Ethernet_DMA_Type) SetDMACRxCR_RBSZ(value uint32) {
	volatile.StoreUint32(&o.DMACRxCR.Reg, volatile.LoadUint32(&o.DMACRxCR.Reg)&^(0x7ffe)|value<<1)
}
func (o *Ethernet_DMA_Type) GetDMACRxCR_RBSZ() uint32 {
	return (volatile.LoadUint32(&o.DMACRxCR.Reg) & 0x7ffe) >> 1
}
func (o *Ethernet_DMA_Type) SetDMACRxCR_SR(value uint32) {
	volatile.StoreUint32(&o.DMACRxCR.Reg, volatile.LoadUint32(&o.DMACRxCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMACRxCR_SR() uint32 {
	return volatile.LoadUint32(&o.DMACRxCR.Reg) & 0x1
}

// Ethernet_DMA.DMACTxDLAR: Channel Tx descriptor list address register
func (o *Ethernet_DMA_Type) SetDMACTxDLAR_TDESLA(value uint32) {
	volatile.StoreUint32(&o.DMACTxDLAR.Reg, volatile.LoadUint32(&o.DMACTxDLAR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *Ethernet_DMA_Type) GetDMACTxDLAR_TDESLA() uint32 {
	return (volatile.LoadUint32(&o.DMACTxDLAR.Reg) & 0xfffffffc) >> 2
}

// Ethernet_DMA.DMACRxDLAR: Channel Rx descriptor list address register
func (o *Ethernet_DMA_Type) SetDMACRxDLAR_RDESLA(value uint32) {
	volatile.StoreUint32(&o.DMACRxDLAR.Reg, volatile.LoadUint32(&o.DMACRxDLAR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *Ethernet_DMA_Type) GetDMACRxDLAR_RDESLA() uint32 {
	return (volatile.LoadUint32(&o.DMACRxDLAR.Reg) & 0xfffffffc) >> 2
}

// Ethernet_DMA.DMACTxDTPR: Channel Tx descriptor tail pointer register
func (o *Ethernet_DMA_Type) SetDMACTxDTPR_TDT(value uint32) {
	volatile.StoreUint32(&o.DMACTxDTPR.Reg, volatile.LoadUint32(&o.DMACTxDTPR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *Ethernet_DMA_Type) GetDMACTxDTPR_TDT() uint32 {
	return (volatile.LoadUint32(&o.DMACTxDTPR.Reg) & 0xfffffffc) >> 2
}

// Ethernet_DMA.DMACRxDTPR: Channel Rx descriptor tail pointer register
func (o *Ethernet_DMA_Type) SetDMACRxDTPR_RDT(value uint32) {
	volatile.StoreUint32(&o.DMACRxDTPR.Reg, volatile.LoadUint32(&o.DMACRxDTPR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *Ethernet_DMA_Type) GetDMACRxDTPR_RDT() uint32 {
	return (volatile.LoadUint32(&o.DMACRxDTPR.Reg) & 0xfffffffc) >> 2
}

// Ethernet_DMA.DMACTxRLR: Channel Tx descriptor ring length register
func (o *Ethernet_DMA_Type) SetDMACTxRLR_TDRL(value uint32) {
	volatile.StoreUint32(&o.DMACTxRLR.Reg, volatile.LoadUint32(&o.DMACTxRLR.Reg)&^(0x3ff)|value)
}
func (o *Ethernet_DMA_Type) GetDMACTxRLR_TDRL() uint32 {
	return volatile.LoadUint32(&o.DMACTxRLR.Reg) & 0x3ff
}

// Ethernet_DMA.DMACRxRLR: Channel Rx descriptor ring length register
func (o *Ethernet_DMA_Type) SetDMACRxRLR_RDRL(value uint32) {
	volatile.StoreUint32(&o.DMACRxRLR.Reg, volatile.LoadUint32(&o.DMACRxRLR.Reg)&^(0x3ff)|value)
}
func (o *Ethernet_DMA_Type) GetDMACRxRLR_RDRL() uint32 {
	return volatile.LoadUint32(&o.DMACRxRLR.Reg) & 0x3ff
}

// Ethernet_DMA.DMACIER: Channel interrupt enable register
func (o *Ethernet_DMA_Type) SetDMACIER_NIE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_DMA_Type) GetDMACIER_NIE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x8000) >> 15
}
func (o *Ethernet_DMA_Type) SetDMACIER_AIE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_DMA_Type) GetDMACIER_AIE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x4000) >> 14
}
func (o *Ethernet_DMA_Type) SetDMACIER_CDEE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_DMA_Type) GetDMACIER_CDEE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x2000) >> 13
}
func (o *Ethernet_DMA_Type) SetDMACIER_FBEE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_DMA_Type) GetDMACIER_FBEE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x1000) >> 12
}
func (o *Ethernet_DMA_Type) SetDMACIER_ERIE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_DMA_Type) GetDMACIER_ERIE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x800) >> 11
}
func (o *Ethernet_DMA_Type) SetDMACIER_ETIE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_DMA_Type) GetDMACIER_ETIE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x400) >> 10
}
func (o *Ethernet_DMA_Type) SetDMACIER_RWTE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_DMA_Type) GetDMACIER_RWTE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x200) >> 9
}
func (o *Ethernet_DMA_Type) SetDMACIER_RSE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_DMA_Type) GetDMACIER_RSE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x100) >> 8
}
func (o *Ethernet_DMA_Type) SetDMACIER_RBUE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_DMA_Type) GetDMACIER_RBUE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x80) >> 7
}
func (o *Ethernet_DMA_Type) SetDMACIER_RIE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_DMA_Type) GetDMACIER_RIE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x40) >> 6
}
func (o *Ethernet_DMA_Type) SetDMACIER_TBUE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_DMA_Type) GetDMACIER_TBUE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x4) >> 2
}
func (o *Ethernet_DMA_Type) SetDMACIER_TXSE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_DMA_Type) GetDMACIER_TXSE() uint32 {
	return (volatile.LoadUint32(&o.DMACIER.Reg) & 0x2) >> 1
}
func (o *Ethernet_DMA_Type) SetDMACIER_TIE(value uint32) {
	volatile.StoreUint32(&o.DMACIER.Reg, volatile.LoadUint32(&o.DMACIER.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMACIER_TIE() uint32 {
	return volatile.LoadUint32(&o.DMACIER.Reg) & 0x1
}

// Ethernet_DMA.DMACRxIWTR: Channel Rx interrupt watchdog timer register
func (o *Ethernet_DMA_Type) SetDMACRxIWTR_RWT(value uint32) {
	volatile.StoreUint32(&o.DMACRxIWTR.Reg, volatile.LoadUint32(&o.DMACRxIWTR.Reg)&^(0xff)|value)
}
func (o *Ethernet_DMA_Type) GetDMACRxIWTR_RWT() uint32 {
	return volatile.LoadUint32(&o.DMACRxIWTR.Reg) & 0xff
}

// Ethernet_DMA.DMACCATxDR: Channel current application transmit descriptor register
func (o *Ethernet_DMA_Type) SetDMACCATxDR(value uint32) {
	volatile.StoreUint32(&o.DMACCATxDR.Reg, value)
}
func (o *Ethernet_DMA_Type) GetDMACCATxDR() uint32 {
	return volatile.LoadUint32(&o.DMACCATxDR.Reg)
}

// Ethernet_DMA.DMACCARxDR: Channel current application receive descriptor register
func (o *Ethernet_DMA_Type) SetDMACCARxDR(value uint32) {
	volatile.StoreUint32(&o.DMACCARxDR.Reg, value)
}
func (o *Ethernet_DMA_Type) GetDMACCARxDR() uint32 {
	return volatile.LoadUint32(&o.DMACCARxDR.Reg)
}

// Ethernet_DMA.DMACCATxBR: Channel current application transmit buffer register
func (o *Ethernet_DMA_Type) SetDMACCATxBR(value uint32) {
	volatile.StoreUint32(&o.DMACCATxBR.Reg, value)
}
func (o *Ethernet_DMA_Type) GetDMACCATxBR() uint32 {
	return volatile.LoadUint32(&o.DMACCATxBR.Reg)
}

// Ethernet_DMA.DMACCARxBR: Channel current application receive buffer register
func (o *Ethernet_DMA_Type) SetDMACCARxBR(value uint32) {
	volatile.StoreUint32(&o.DMACCARxBR.Reg, value)
}
func (o *Ethernet_DMA_Type) GetDMACCARxBR() uint32 {
	return volatile.LoadUint32(&o.DMACCARxBR.Reg)
}

// Ethernet_DMA.DMACSR: Channel status register
func (o *Ethernet_DMA_Type) SetDMACSR_REB(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x380000)|value<<19)
}
func (o *Ethernet_DMA_Type) GetDMACSR_REB() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x380000) >> 19
}
func (o *Ethernet_DMA_Type) SetDMACSR_TEB(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x70000)|value<<16)
}
func (o *Ethernet_DMA_Type) GetDMACSR_TEB() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x70000) >> 16
}
func (o *Ethernet_DMA_Type) SetDMACSR_NIS(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_DMA_Type) GetDMACSR_NIS() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x8000) >> 15
}
func (o *Ethernet_DMA_Type) SetDMACSR_AIS(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_DMA_Type) GetDMACSR_AIS() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x4000) >> 14
}
func (o *Ethernet_DMA_Type) SetDMACSR_CDE(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_DMA_Type) GetDMACSR_CDE() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x2000) >> 13
}
func (o *Ethernet_DMA_Type) SetDMACSR_FBE(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_DMA_Type) GetDMACSR_FBE() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_DMA_Type) SetDMACSR_ERI(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_DMA_Type) GetDMACSR_ERI() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x800) >> 11
}
func (o *Ethernet_DMA_Type) SetDMACSR_ETI(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_DMA_Type) GetDMACSR_ETI() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x400) >> 10
}
func (o *Ethernet_DMA_Type) SetDMACSR_RWT(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_DMA_Type) GetDMACSR_RWT() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x200) >> 9
}
func (o *Ethernet_DMA_Type) SetDMACSR_RPS(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_DMA_Type) GetDMACSR_RPS() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x100) >> 8
}
func (o *Ethernet_DMA_Type) SetDMACSR_RBU(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_DMA_Type) GetDMACSR_RBU() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x80) >> 7
}
func (o *Ethernet_DMA_Type) SetDMACSR_RI(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_DMA_Type) GetDMACSR_RI() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x40) >> 6
}
func (o *Ethernet_DMA_Type) SetDMACSR_TBU(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_DMA_Type) GetDMACSR_TBU() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x4) >> 2
}
func (o *Ethernet_DMA_Type) SetDMACSR_TPS(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_DMA_Type) GetDMACSR_TPS() uint32 {
	return (volatile.LoadUint32(&o.DMACSR.Reg) & 0x2) >> 1
}
func (o *Ethernet_DMA_Type) SetDMACSR_TI(value uint32) {
	volatile.StoreUint32(&o.DMACSR.Reg, volatile.LoadUint32(&o.DMACSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_DMA_Type) GetDMACSR_TI() uint32 {
	return volatile.LoadUint32(&o.DMACSR.Reg) & 0x1
}

// Ethernet_DMA.DMACMFCR: Channel missed frame count register
func (o *Ethernet_DMA_Type) SetDMACMFCR_MFCO(value uint32) {
	volatile.StoreUint32(&o.DMACMFCR.Reg, volatile.LoadUint32(&o.DMACMFCR.Reg)&^(0x8000)|value<<15)
}
func (o *Ethernet_DMA_Type) GetDMACMFCR_MFCO() uint32 {
	return (volatile.LoadUint32(&o.DMACMFCR.Reg) & 0x8000) >> 15
}
func (o *Ethernet_DMA_Type) SetDMACMFCR_MFC(value uint32) {
	volatile.StoreUint32(&o.DMACMFCR.Reg, volatile.LoadUint32(&o.DMACMFCR.Reg)&^(0x7ff)|value)
}
func (o *Ethernet_DMA_Type) GetDMACMFCR_MFC() uint32 {
	return volatile.LoadUint32(&o.DMACMFCR.Reg) & 0x7ff
}

// Ethernet MTL
type Ethernet_MTL_Type struct {
	MTLOMR      volatile.Register32 // 0x0
	_           [28]byte
	MTLISR      volatile.Register32 // 0x20
	_           [220]byte
	MTLTxQOMR   volatile.Register32 // 0x100
	MTLTxQUR    volatile.Register32 // 0x104
	MTLTxQDR    volatile.Register32 // 0x108
	_           [32]byte
	MTLQICSR    volatile.Register32 // 0x12C
	MTLRxQOMR   volatile.Register32 // 0x130
	MTLRxQMPOCR volatile.Register32 // 0x134
	MTLRxQDR    volatile.Register32 // 0x138
}

// Ethernet_MTL.MTLOMR: Operating mode Register
func (o *Ethernet_MTL_Type) SetMTLOMR_CNTCLR(value uint32) {
	volatile.StoreUint32(&o.MTLOMR.Reg, volatile.LoadUint32(&o.MTLOMR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_MTL_Type) GetMTLOMR_CNTCLR() uint32 {
	return (volatile.LoadUint32(&o.MTLOMR.Reg) & 0x200) >> 9
}
func (o *Ethernet_MTL_Type) SetMTLOMR_CNTPRST(value uint32) {
	volatile.StoreUint32(&o.MTLOMR.Reg, volatile.LoadUint32(&o.MTLOMR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_MTL_Type) GetMTLOMR_CNTPRST() uint32 {
	return (volatile.LoadUint32(&o.MTLOMR.Reg) & 0x100) >> 8
}
func (o *Ethernet_MTL_Type) SetMTLOMR_DTXSTS(value uint32) {
	volatile.StoreUint32(&o.MTLOMR.Reg, volatile.LoadUint32(&o.MTLOMR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_MTL_Type) GetMTLOMR_DTXSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLOMR.Reg) & 0x2) >> 1
}

// Ethernet_MTL.MTLISR: Interrupt status Register
func (o *Ethernet_MTL_Type) SetMTLISR_Q0IS(value uint32) {
	volatile.StoreUint32(&o.MTLISR.Reg, volatile.LoadUint32(&o.MTLISR.Reg)&^(0x1)|value)
}
func (o *Ethernet_MTL_Type) GetMTLISR_Q0IS() uint32 {
	return volatile.LoadUint32(&o.MTLISR.Reg) & 0x1
}

// Ethernet_MTL.MTLTxQOMR: Tx queue operating mode Register
func (o *Ethernet_MTL_Type) SetMTLTxQOMR_TQS(value uint32) {
	volatile.StoreUint32(&o.MTLTxQOMR.Reg, volatile.LoadUint32(&o.MTLTxQOMR.Reg)&^(0x1ff0000)|value<<16)
}
func (o *Ethernet_MTL_Type) GetMTLTxQOMR_TQS() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQOMR.Reg) & 0x1ff0000) >> 16
}
func (o *Ethernet_MTL_Type) SetMTLTxQOMR_TTC(value uint32) {
	volatile.StoreUint32(&o.MTLTxQOMR.Reg, volatile.LoadUint32(&o.MTLTxQOMR.Reg)&^(0x70)|value<<4)
}
func (o *Ethernet_MTL_Type) GetMTLTxQOMR_TTC() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQOMR.Reg) & 0x70) >> 4
}
func (o *Ethernet_MTL_Type) SetMTLTxQOMR_TXQEN(value uint32) {
	volatile.StoreUint32(&o.MTLTxQOMR.Reg, volatile.LoadUint32(&o.MTLTxQOMR.Reg)&^(0xc)|value<<2)
}
func (o *Ethernet_MTL_Type) GetMTLTxQOMR_TXQEN() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQOMR.Reg) & 0xc) >> 2
}
func (o *Ethernet_MTL_Type) SetMTLTxQOMR_TSF(value uint32) {
	volatile.StoreUint32(&o.MTLTxQOMR.Reg, volatile.LoadUint32(&o.MTLTxQOMR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_MTL_Type) GetMTLTxQOMR_TSF() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQOMR.Reg) & 0x2) >> 1
}
func (o *Ethernet_MTL_Type) SetMTLTxQOMR_FTQ(value uint32) {
	volatile.StoreUint32(&o.MTLTxQOMR.Reg, volatile.LoadUint32(&o.MTLTxQOMR.Reg)&^(0x1)|value)
}
func (o *Ethernet_MTL_Type) GetMTLTxQOMR_FTQ() uint32 {
	return volatile.LoadUint32(&o.MTLTxQOMR.Reg) & 0x1
}

// Ethernet_MTL.MTLTxQUR: Tx queue underflow register
func (o *Ethernet_MTL_Type) SetMTLTxQUR_UFCNTOVF(value uint32) {
	volatile.StoreUint32(&o.MTLTxQUR.Reg, volatile.LoadUint32(&o.MTLTxQUR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_MTL_Type) GetMTLTxQUR_UFCNTOVF() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQUR.Reg) & 0x800) >> 11
}
func (o *Ethernet_MTL_Type) SetMTLTxQUR_UFFRMCNT(value uint32) {
	volatile.StoreUint32(&o.MTLTxQUR.Reg, volatile.LoadUint32(&o.MTLTxQUR.Reg)&^(0x7ff)|value)
}
func (o *Ethernet_MTL_Type) GetMTLTxQUR_UFFRMCNT() uint32 {
	return volatile.LoadUint32(&o.MTLTxQUR.Reg) & 0x7ff
}

// Ethernet_MTL.MTLTxQDR: Tx queue debug Register
func (o *Ethernet_MTL_Type) SetMTLTxQDR_STXSTSF(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x700000)|value<<20)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_STXSTSF() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x700000) >> 20
}
func (o *Ethernet_MTL_Type) SetMTLTxQDR_PTXQ(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x70000)|value<<16)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_PTXQ() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x70000) >> 16
}
func (o *Ethernet_MTL_Type) SetMTLTxQDR_TXSTSFSTS(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_TXSTSFSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x20) >> 5
}
func (o *Ethernet_MTL_Type) SetMTLTxQDR_TXQSTS(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_TXQSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x10) >> 4
}
func (o *Ethernet_MTL_Type) SetMTLTxQDR_TWCSTS(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_TWCSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x8) >> 3
}
func (o *Ethernet_MTL_Type) SetMTLTxQDR_TRCSTS(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x6)|value<<1)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_TRCSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x6) >> 1
}
func (o *Ethernet_MTL_Type) SetMTLTxQDR_TXQPAUSED(value uint32) {
	volatile.StoreUint32(&o.MTLTxQDR.Reg, volatile.LoadUint32(&o.MTLTxQDR.Reg)&^(0x1)|value)
}
func (o *Ethernet_MTL_Type) GetMTLTxQDR_TXQPAUSED() uint32 {
	return volatile.LoadUint32(&o.MTLTxQDR.Reg) & 0x1
}

// Ethernet_MTL.MTLQICSR: Queue interrupt control status Register
func (o *Ethernet_MTL_Type) SetMTLQICSR_RXOIE(value uint32) {
	volatile.StoreUint32(&o.MTLQICSR.Reg, volatile.LoadUint32(&o.MTLQICSR.Reg)&^(0x1000000)|value<<24)
}
func (o *Ethernet_MTL_Type) GetMTLQICSR_RXOIE() uint32 {
	return (volatile.LoadUint32(&o.MTLQICSR.Reg) & 0x1000000) >> 24
}
func (o *Ethernet_MTL_Type) SetMTLQICSR_RXOVFIS(value uint32) {
	volatile.StoreUint32(&o.MTLQICSR.Reg, volatile.LoadUint32(&o.MTLQICSR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_MTL_Type) GetMTLQICSR_RXOVFIS() uint32 {
	return (volatile.LoadUint32(&o.MTLQICSR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_MTL_Type) SetMTLQICSR_TXUIE(value uint32) {
	volatile.StoreUint32(&o.MTLQICSR.Reg, volatile.LoadUint32(&o.MTLQICSR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_MTL_Type) GetMTLQICSR_TXUIE() uint32 {
	return (volatile.LoadUint32(&o.MTLQICSR.Reg) & 0x100) >> 8
}
func (o *Ethernet_MTL_Type) SetMTLQICSR_TXUNFIS(value uint32) {
	volatile.StoreUint32(&o.MTLQICSR.Reg, volatile.LoadUint32(&o.MTLQICSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_MTL_Type) GetMTLQICSR_TXUNFIS() uint32 {
	return volatile.LoadUint32(&o.MTLQICSR.Reg) & 0x1
}

// Ethernet_MTL.MTLRxQOMR: Rx queue operating mode register
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_RQS(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x700000)|value<<20)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_RQS() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x700000) >> 20
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_RFD(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x1c000)|value<<14)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_RFD() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x1c000) >> 14
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_RFA(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x700)|value<<8)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_RFA() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x700) >> 8
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_EHFC(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_EHFC() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x80) >> 7
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_DIS_TCP_EF(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_DIS_TCP_EF() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x40) >> 6
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_RSF(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_RSF() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x20) >> 5
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_FEP(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_FEP() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x10) >> 4
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_FUP(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_FUP() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x8) >> 3
}
func (o *Ethernet_MTL_Type) SetMTLRxQOMR_RTC(value uint32) {
	volatile.StoreUint32(&o.MTLRxQOMR.Reg, volatile.LoadUint32(&o.MTLRxQOMR.Reg)&^(0x3)|value)
}
func (o *Ethernet_MTL_Type) GetMTLRxQOMR_RTC() uint32 {
	return volatile.LoadUint32(&o.MTLRxQOMR.Reg) & 0x3
}

// Ethernet_MTL.MTLRxQMPOCR: Rx queue missed packet and overflow counter register
func (o *Ethernet_MTL_Type) SetMTLRxQMPOCR_MISCNTOVF(value uint32) {
	volatile.StoreUint32(&o.MTLRxQMPOCR.Reg, volatile.LoadUint32(&o.MTLRxQMPOCR.Reg)&^(0x8000000)|value<<27)
}
func (o *Ethernet_MTL_Type) GetMTLRxQMPOCR_MISCNTOVF() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQMPOCR.Reg) & 0x8000000) >> 27
}
func (o *Ethernet_MTL_Type) SetMTLRxQMPOCR_MISPKTCNT(value uint32) {
	volatile.StoreUint32(&o.MTLRxQMPOCR.Reg, volatile.LoadUint32(&o.MTLRxQMPOCR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *Ethernet_MTL_Type) GetMTLRxQMPOCR_MISPKTCNT() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQMPOCR.Reg) & 0x7ff0000) >> 16
}
func (o *Ethernet_MTL_Type) SetMTLRxQMPOCR_OVFCNTOVF(value uint32) {
	volatile.StoreUint32(&o.MTLRxQMPOCR.Reg, volatile.LoadUint32(&o.MTLRxQMPOCR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_MTL_Type) GetMTLRxQMPOCR_OVFCNTOVF() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQMPOCR.Reg) & 0x800) >> 11
}
func (o *Ethernet_MTL_Type) SetMTLRxQMPOCR_OVFPKTCNT(value uint32) {
	volatile.StoreUint32(&o.MTLRxQMPOCR.Reg, volatile.LoadUint32(&o.MTLRxQMPOCR.Reg)&^(0x7ff)|value)
}
func (o *Ethernet_MTL_Type) GetMTLRxQMPOCR_OVFPKTCNT() uint32 {
	return volatile.LoadUint32(&o.MTLRxQMPOCR.Reg) & 0x7ff
}

// Ethernet_MTL.MTLRxQDR: Rx queue debug register
func (o *Ethernet_MTL_Type) SetMTLRxQDR_PRXQ(value uint32) {
	volatile.StoreUint32(&o.MTLRxQDR.Reg, volatile.LoadUint32(&o.MTLRxQDR.Reg)&^(0x3fff0000)|value<<16)
}
func (o *Ethernet_MTL_Type) GetMTLRxQDR_PRXQ() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQDR.Reg) & 0x3fff0000) >> 16
}
func (o *Ethernet_MTL_Type) SetMTLRxQDR_RXQSTS(value uint32) {
	volatile.StoreUint32(&o.MTLRxQDR.Reg, volatile.LoadUint32(&o.MTLRxQDR.Reg)&^(0x30)|value<<4)
}
func (o *Ethernet_MTL_Type) GetMTLRxQDR_RXQSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQDR.Reg) & 0x30) >> 4
}
func (o *Ethernet_MTL_Type) SetMTLRxQDR_RRCSTS(value uint32) {
	volatile.StoreUint32(&o.MTLRxQDR.Reg, volatile.LoadUint32(&o.MTLRxQDR.Reg)&^(0x6)|value<<1)
}
func (o *Ethernet_MTL_Type) GetMTLRxQDR_RRCSTS() uint32 {
	return (volatile.LoadUint32(&o.MTLRxQDR.Reg) & 0x6) >> 1
}
func (o *Ethernet_MTL_Type) SetMTLRxQDR_RWCSTS(value uint32) {
	volatile.StoreUint32(&o.MTLRxQDR.Reg, volatile.LoadUint32(&o.MTLRxQDR.Reg)&^(0x1)|value)
}
func (o *Ethernet_MTL_Type) GetMTLRxQDR_RWCSTS() uint32 {
	return volatile.LoadUint32(&o.MTLRxQDR.Reg) & 0x1
}

// Constants for AC: Access control
const (
	// ITCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
	// Position of EN field.
	AC_ITCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	AC_ITCMCR_EN_Msk = 0x1
	// Bit EN.
	AC_ITCMCR_EN = 0x1
	// Position of RMW field.
	AC_ITCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	AC_ITCMCR_RMW_Msk = 0x2
	// Bit RMW.
	AC_ITCMCR_RMW = 0x2
	// Position of RETEN field.
	AC_ITCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	AC_ITCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	AC_ITCMCR_RETEN = 0x4
	// Position of SZ field.
	AC_ITCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	AC_ITCMCR_SZ_Msk = 0x78

	// DTCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
	// Position of EN field.
	AC_DTCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	AC_DTCMCR_EN_Msk = 0x1
	// Bit EN.
	AC_DTCMCR_EN = 0x1
	// Position of RMW field.
	AC_DTCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	AC_DTCMCR_RMW_Msk = 0x2
	// Bit RMW.
	AC_DTCMCR_RMW = 0x2
	// Position of RETEN field.
	AC_DTCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	AC_DTCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	AC_DTCMCR_RETEN = 0x4
	// Position of SZ field.
	AC_DTCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	AC_DTCMCR_SZ_Msk = 0x78

	// AHBPCR: AHBP Control register
	// Position of EN field.
	AC_AHBPCR_EN_Pos = 0x0
	// Bit mask of EN field.
	AC_AHBPCR_EN_Msk = 0x1
	// Bit EN.
	AC_AHBPCR_EN = 0x1
	// Position of SZ field.
	AC_AHBPCR_SZ_Pos = 0x1
	// Bit mask of SZ field.
	AC_AHBPCR_SZ_Msk = 0xe

	// CACR: Auxiliary Cache Control register
	// Position of SIWT field.
	AC_CACR_SIWT_Pos = 0x0
	// Bit mask of SIWT field.
	AC_CACR_SIWT_Msk = 0x1
	// Bit SIWT.
	AC_CACR_SIWT = 0x1
	// Position of ECCEN field.
	AC_CACR_ECCEN_Pos = 0x1
	// Bit mask of ECCEN field.
	AC_CACR_ECCEN_Msk = 0x2
	// Bit ECCEN.
	AC_CACR_ECCEN = 0x2
	// Position of FORCEWT field.
	AC_CACR_FORCEWT_Pos = 0x2
	// Bit mask of FORCEWT field.
	AC_CACR_FORCEWT_Msk = 0x4
	// Bit FORCEWT.
	AC_CACR_FORCEWT = 0x4

	// AHBSCR: AHB Slave Control register
	// Position of CTL field.
	AC_AHBSCR_CTL_Pos = 0x0
	// Bit mask of CTL field.
	AC_AHBSCR_CTL_Msk = 0x3
	// Position of TPRI field.
	AC_AHBSCR_TPRI_Pos = 0x2
	// Bit mask of TPRI field.
	AC_AHBSCR_TPRI_Msk = 0x7fc
	// Position of INITCOUNT field.
	AC_AHBSCR_INITCOUNT_Pos = 0xb
	// Bit mask of INITCOUNT field.
	AC_AHBSCR_INITCOUNT_Msk = 0xf800

	// ABFSR: Auxiliary Bus Fault Status register
	// Position of ITCM field.
	AC_ABFSR_ITCM_Pos = 0x0
	// Bit mask of ITCM field.
	AC_ABFSR_ITCM_Msk = 0x1
	// Bit ITCM.
	AC_ABFSR_ITCM = 0x1
	// Position of DTCM field.
	AC_ABFSR_DTCM_Pos = 0x1
	// Bit mask of DTCM field.
	AC_ABFSR_DTCM_Msk = 0x2
	// Bit DTCM.
	AC_ABFSR_DTCM = 0x2
	// Position of AHBP field.
	AC_ABFSR_AHBP_Pos = 0x2
	// Bit mask of AHBP field.
	AC_ABFSR_AHBP_Msk = 0x4
	// Bit AHBP.
	AC_ABFSR_AHBP = 0x4
	// Position of AXIM field.
	AC_ABFSR_AXIM_Pos = 0x3
	// Bit mask of AXIM field.
	AC_ABFSR_AXIM_Msk = 0x8
	// Bit AXIM.
	AC_ABFSR_AXIM = 0x8
	// Position of EPPB field.
	AC_ABFSR_EPPB_Pos = 0x4
	// Bit mask of EPPB field.
	AC_ABFSR_EPPB_Msk = 0x10
	// Bit EPPB.
	AC_ABFSR_EPPB = 0x10
	// Position of AXIMTYPE field.
	AC_ABFSR_AXIMTYPE_Pos = 0x8
	// Bit mask of AXIMTYPE field.
	AC_ABFSR_AXIMTYPE_Msk = 0x300
)

// Constants for ADC1: Analog to Digital Converter
const (
	// ISR: ADC interrupt and status register
	// Position of JQOVF field.
	ADC_ISR_JQOVF_Pos = 0xa
	// Bit mask of JQOVF field.
	ADC_ISR_JQOVF_Msk = 0x400
	// Bit JQOVF.
	ADC_ISR_JQOVF = 0x400
	// No injected context queue overflow has occurred
	ADC_ISR_JQOVF_NoOverflow = 0x0
	// Injected context queue overflow has occurred
	ADC_ISR_JQOVF_Overflow = 0x1
	// Clear injected context queue overflow flag
	ADC_ISR_JQOVF_Clear = 0x1
	// Position of AWD3 field.
	ADC_ISR_AWD3_Pos = 0x9
	// Bit mask of AWD3 field.
	ADC_ISR_AWD3_Msk = 0x200
	// Bit AWD3.
	ADC_ISR_AWD3 = 0x200
	// No analog watchdog event occurred
	ADC_ISR_AWD3_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_ISR_AWD3_Event = 0x1
	// Clear analog watchdog event occurred flag
	ADC_ISR_AWD3_Clear = 0x1
	// Position of AWD2 field.
	ADC_ISR_AWD2_Pos = 0x8
	// Bit mask of AWD2 field.
	ADC_ISR_AWD2_Msk = 0x100
	// Bit AWD2.
	ADC_ISR_AWD2 = 0x100
	// No analog watchdog event occurred
	ADC_ISR_AWD2_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_ISR_AWD2_Event = 0x1
	// Clear analog watchdog event occurred flag
	ADC_ISR_AWD2_Clear = 0x1
	// Position of AWD1 field.
	ADC_ISR_AWD1_Pos = 0x7
	// Bit mask of AWD1 field.
	ADC_ISR_AWD1_Msk = 0x80
	// Bit AWD1.
	ADC_ISR_AWD1 = 0x80
	// No analog watchdog event occurred
	ADC_ISR_AWD1_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_ISR_AWD1_Event = 0x1
	// Clear analog watchdog event occurred flag
	ADC_ISR_AWD1_Clear = 0x1
	// Position of JEOS field.
	ADC_ISR_JEOS_Pos = 0x6
	// Bit mask of JEOS field.
	ADC_ISR_JEOS_Msk = 0x40
	// Bit JEOS.
	ADC_ISR_JEOS = 0x40
	// Injected sequence is not complete
	ADC_ISR_JEOS_NotComplete = 0x0
	// Injected sequence complete
	ADC_ISR_JEOS_Complete = 0x1
	// Clear Injected sequence complete flag
	ADC_ISR_JEOS_Clear = 0x1
	// Position of JEOC field.
	ADC_ISR_JEOC_Pos = 0x5
	// Bit mask of JEOC field.
	ADC_ISR_JEOC_Msk = 0x20
	// Bit JEOC.
	ADC_ISR_JEOC = 0x20
	// Injected conversion is not complete
	ADC_ISR_JEOC_NotComplete = 0x0
	// Injected conversion complete
	ADC_ISR_JEOC_Complete = 0x1
	// Clear injected conversion complete flag
	ADC_ISR_JEOC_Clear = 0x1
	// Position of OVR field.
	ADC_ISR_OVR_Pos = 0x4
	// Bit mask of OVR field.
	ADC_ISR_OVR_Msk = 0x10
	// Bit OVR.
	ADC_ISR_OVR = 0x10
	// No overrun occurred
	ADC_ISR_OVR_NoOverrun = 0x0
	// Overrun occurred
	ADC_ISR_OVR_Overrun = 0x1
	// Clear overrun occurred flag
	ADC_ISR_OVR_Clear = 0x1
	// Position of EOS field.
	ADC_ISR_EOS_Pos = 0x3
	// Bit mask of EOS field.
	ADC_ISR_EOS_Msk = 0x8
	// Bit EOS.
	ADC_ISR_EOS = 0x8
	// Regular sequence is not complete
	ADC_ISR_EOS_NotComplete = 0x0
	// Regular sequence complete
	ADC_ISR_EOS_Complete = 0x1
	// Clear regular sequence complete flag
	ADC_ISR_EOS_Clear = 0x1
	// Position of EOC field.
	ADC_ISR_EOC_Pos = 0x2
	// Bit mask of EOC field.
	ADC_ISR_EOC_Msk = 0x4
	// Bit EOC.
	ADC_ISR_EOC = 0x4
	// Regular conversion is not complete
	ADC_ISR_EOC_NotComplete = 0x0
	// Regular conversion complete
	ADC_ISR_EOC_Complete = 0x1
	// Clear regular conversion complete flag
	ADC_ISR_EOC_Clear = 0x1
	// Position of EOSMP field.
	ADC_ISR_EOSMP_Pos = 0x1
	// Bit mask of EOSMP field.
	ADC_ISR_EOSMP_Msk = 0x2
	// Bit EOSMP.
	ADC_ISR_EOSMP = 0x2
	// End of sampling phase no yet reached
	ADC_ISR_EOSMP_NotEnded = 0x0
	// End of sampling phase reached
	ADC_ISR_EOSMP_Ended = 0x1
	// Clear end of sampling phase reached flag
	ADC_ISR_EOSMP_Clear = 0x1
	// Position of ADRDY field.
	ADC_ISR_ADRDY_Pos = 0x0
	// Bit mask of ADRDY field.
	ADC_ISR_ADRDY_Msk = 0x1
	// Bit ADRDY.
	ADC_ISR_ADRDY = 0x1
	// ADC is not ready to start conversion
	ADC_ISR_ADRDY_NotReady = 0x0
	// ADC is ready to start conversion
	ADC_ISR_ADRDY_Ready = 0x1
	// Clear ADC is ready to start conversion flag
	ADC_ISR_ADRDY_Clear = 0x1

	// IER: ADC interrupt enable register
	// Position of JQOVFIE field.
	ADC_IER_JQOVFIE_Pos = 0xa
	// Bit mask of JQOVFIE field.
	ADC_IER_JQOVFIE_Msk = 0x400
	// Bit JQOVFIE.
	ADC_IER_JQOVFIE = 0x400
	// Injected context queue overflow interrupt disabled
	ADC_IER_JQOVFIE_Disabled = 0x0
	// Injected context queue overflow interrupt enabled
	ADC_IER_JQOVFIE_Enabled = 0x1
	// Position of AWD3IE field.
	ADC_IER_AWD3IE_Pos = 0x9
	// Bit mask of AWD3IE field.
	ADC_IER_AWD3IE_Msk = 0x200
	// Bit AWD3IE.
	ADC_IER_AWD3IE = 0x200
	// Analog watchdog interrupt disabled
	ADC_IER_AWD3IE_Disabled = 0x0
	// Analog watchdog interrupt enabled
	ADC_IER_AWD3IE_Enabled = 0x1
	// Position of AWD2IE field.
	ADC_IER_AWD2IE_Pos = 0x8
	// Bit mask of AWD2IE field.
	ADC_IER_AWD2IE_Msk = 0x100
	// Bit AWD2IE.
	ADC_IER_AWD2IE = 0x100
	// Analog watchdog interrupt disabled
	ADC_IER_AWD2IE_Disabled = 0x0
	// Analog watchdog interrupt enabled
	ADC_IER_AWD2IE_Enabled = 0x1
	// Position of AWD1IE field.
	ADC_IER_AWD1IE_Pos = 0x7
	// Bit mask of AWD1IE field.
	ADC_IER_AWD1IE_Msk = 0x80
	// Bit AWD1IE.
	ADC_IER_AWD1IE = 0x80
	// Analog watchdog interrupt disabled
	ADC_IER_AWD1IE_Disabled = 0x0
	// Analog watchdog interrupt enabled
	ADC_IER_AWD1IE_Enabled = 0x1
	// Position of JEOSIE field.
	ADC_IER_JEOSIE_Pos = 0x6
	// Bit mask of JEOSIE field.
	ADC_IER_JEOSIE_Msk = 0x40
	// Bit JEOSIE.
	ADC_IER_JEOSIE = 0x40
	// End of injected sequence interrupt disabled
	ADC_IER_JEOSIE_Disabled = 0x0
	// End of injected sequence interrupt enabled
	ADC_IER_JEOSIE_Enabled = 0x1
	// Position of JEOCIE field.
	ADC_IER_JEOCIE_Pos = 0x5
	// Bit mask of JEOCIE field.
	ADC_IER_JEOCIE_Msk = 0x20
	// Bit JEOCIE.
	ADC_IER_JEOCIE = 0x20
	// End of injected conversion interrupt disabled
	ADC_IER_JEOCIE_Disabled = 0x0
	// End of injected conversion interrupt enabled
	ADC_IER_JEOCIE_Enabled = 0x1
	// Position of OVRIE field.
	ADC_IER_OVRIE_Pos = 0x4
	// Bit mask of OVRIE field.
	ADC_IER_OVRIE_Msk = 0x10
	// Bit OVRIE.
	ADC_IER_OVRIE = 0x10
	// Overrun interrupt disabled
	ADC_IER_OVRIE_Disabled = 0x0
	// Overrun interrupt enabled
	ADC_IER_OVRIE_Enabled = 0x1
	// Position of EOSIE field.
	ADC_IER_EOSIE_Pos = 0x3
	// Bit mask of EOSIE field.
	ADC_IER_EOSIE_Msk = 0x8
	// Bit EOSIE.
	ADC_IER_EOSIE = 0x8
	// End of regular sequence interrupt disabled
	ADC_IER_EOSIE_Disabled = 0x0
	// End of regular sequence interrupt enabled
	ADC_IER_EOSIE_Enabled = 0x1
	// Position of EOCIE field.
	ADC_IER_EOCIE_Pos = 0x2
	// Bit mask of EOCIE field.
	ADC_IER_EOCIE_Msk = 0x4
	// Bit EOCIE.
	ADC_IER_EOCIE = 0x4
	// End of regular conversion interrupt disabled
	ADC_IER_EOCIE_Disabled = 0x0
	// End of regular conversion interrupt enabled
	ADC_IER_EOCIE_Enabled = 0x1
	// Position of EOSMPIE field.
	ADC_IER_EOSMPIE_Pos = 0x1
	// Bit mask of EOSMPIE field.
	ADC_IER_EOSMPIE_Msk = 0x2
	// Bit EOSMPIE.
	ADC_IER_EOSMPIE = 0x2
	// End of regular conversion sampling phase interrupt disabled
	ADC_IER_EOSMPIE_Disabled = 0x0
	// End of regular conversion sampling phase interrupt enabled
	ADC_IER_EOSMPIE_Enabled = 0x1
	// Position of ADRDYIE field.
	ADC_IER_ADRDYIE_Pos = 0x0
	// Bit mask of ADRDYIE field.
	ADC_IER_ADRDYIE_Msk = 0x1
	// Bit ADRDYIE.
	ADC_IER_ADRDYIE = 0x1
	// ADC ready interrupt disabled
	ADC_IER_ADRDYIE_Disabled = 0x0
	// ADC ready interrupt enabled
	ADC_IER_ADRDYIE_Enabled = 0x1

	// CR: ADC control register
	// Position of ADCAL field.
	ADC_CR_ADCAL_Pos = 0x1f
	// Bit mask of ADCAL field.
	ADC_CR_ADCAL_Msk = 0x80000000
	// Bit ADCAL.
	ADC_CR_ADCAL = 0x80000000
	// Calibration complete
	ADC_CR_ADCAL_Complete = 0x0
	// Start the calibration of the ADC
	ADC_CR_ADCAL_Calibration = 0x1
	// Position of ADCALDIF field.
	ADC_CR_ADCALDIF_Pos = 0x1e
	// Bit mask of ADCALDIF field.
	ADC_CR_ADCALDIF_Msk = 0x40000000
	// Bit ADCALDIF.
	ADC_CR_ADCALDIF = 0x40000000
	// Calibration for single-ended mode
	ADC_CR_ADCALDIF_SingleEnded = 0x0
	// Calibration for differential mode
	ADC_CR_ADCALDIF_Differential = 0x1
	// Position of DEEPPWD field.
	ADC_CR_DEEPPWD_Pos = 0x1d
	// Bit mask of DEEPPWD field.
	ADC_CR_DEEPPWD_Msk = 0x20000000
	// Bit DEEPPWD.
	ADC_CR_DEEPPWD = 0x20000000
	// ADC not in deep power down
	ADC_CR_DEEPPWD_PowerUp = 0x0
	// ADC in deep power down
	ADC_CR_DEEPPWD_PowerDown = 0x1
	// Position of ADVREGEN field.
	ADC_CR_ADVREGEN_Pos = 0x1c
	// Bit mask of ADVREGEN field.
	ADC_CR_ADVREGEN_Msk = 0x10000000
	// Bit ADVREGEN.
	ADC_CR_ADVREGEN = 0x10000000
	// ADC voltage regulator disabled
	ADC_CR_ADVREGEN_Disabled = 0x0
	// ADC voltage regulator enabled
	ADC_CR_ADVREGEN_Enabled = 0x1
	// Position of LINCALRDYW6 field.
	ADC_CR_LINCALRDYW6_Pos = 0x1b
	// Bit mask of LINCALRDYW6 field.
	ADC_CR_LINCALRDYW6_Msk = 0x8000000
	// Bit LINCALRDYW6.
	ADC_CR_LINCALRDYW6 = 0x8000000
	// LINCALFACT Word Read
	ADC_CR_LINCALRDYW6_Reset = 0x0
	// LINCALFACT Word Write
	ADC_CR_LINCALRDYW6_Set = 0x1
	// Position of LINCALRDYW5 field.
	ADC_CR_LINCALRDYW5_Pos = 0x1a
	// Bit mask of LINCALRDYW5 field.
	ADC_CR_LINCALRDYW5_Msk = 0x4000000
	// Bit LINCALRDYW5.
	ADC_CR_LINCALRDYW5 = 0x4000000
	// LINCALFACT Word Read
	ADC_CR_LINCALRDYW5_Reset = 0x0
	// LINCALFACT Word Write
	ADC_CR_LINCALRDYW5_Set = 0x1
	// Position of LINCALRDYW4 field.
	ADC_CR_LINCALRDYW4_Pos = 0x19
	// Bit mask of LINCALRDYW4 field.
	ADC_CR_LINCALRDYW4_Msk = 0x2000000
	// Bit LINCALRDYW4.
	ADC_CR_LINCALRDYW4 = 0x2000000
	// LINCALFACT Word Read
	ADC_CR_LINCALRDYW4_Reset = 0x0
	// LINCALFACT Word Write
	ADC_CR_LINCALRDYW4_Set = 0x1
	// Position of LINCALRDYW3 field.
	ADC_CR_LINCALRDYW3_Pos = 0x18
	// Bit mask of LINCALRDYW3 field.
	ADC_CR_LINCALRDYW3_Msk = 0x1000000
	// Bit LINCALRDYW3.
	ADC_CR_LINCALRDYW3 = 0x1000000
	// LINCALFACT Word Read
	ADC_CR_LINCALRDYW3_Reset = 0x0
	// LINCALFACT Word Write
	ADC_CR_LINCALRDYW3_Set = 0x1
	// Position of LINCALRDYW2 field.
	ADC_CR_LINCALRDYW2_Pos = 0x17
	// Bit mask of LINCALRDYW2 field.
	ADC_CR_LINCALRDYW2_Msk = 0x800000
	// Bit LINCALRDYW2.
	ADC_CR_LINCALRDYW2 = 0x800000
	// LINCALFACT Word Read
	ADC_CR_LINCALRDYW2_Reset = 0x0
	// LINCALFACT Word Write
	ADC_CR_LINCALRDYW2_Set = 0x1
	// Position of LINCALRDYW1 field.
	ADC_CR_LINCALRDYW1_Pos = 0x16
	// Bit mask of LINCALRDYW1 field.
	ADC_CR_LINCALRDYW1_Msk = 0x400000
	// Bit LINCALRDYW1.
	ADC_CR_LINCALRDYW1 = 0x400000
	// LINCALFACT Word Read
	ADC_CR_LINCALRDYW1_Reset = 0x0
	// LINCALFACT Word Write
	ADC_CR_LINCALRDYW1_Set = 0x1
	// Position of ADCALLIN field.
	ADC_CR_ADCALLIN_Pos = 0x10
	// Bit mask of ADCALLIN field.
	ADC_CR_ADCALLIN_Msk = 0x10000
	// Bit ADCALLIN.
	ADC_CR_ADCALLIN = 0x10000
	// ADC calibration without linearaity calibration
	ADC_CR_ADCALLIN_NoLinearity = 0x0
	// ADC calibration with linearaity calibration
	ADC_CR_ADCALLIN_Linearity = 0x1
	// Position of BOOST field.
	ADC_CR_BOOST_Pos = 0x8
	// Bit mask of BOOST field.
	ADC_CR_BOOST_Msk = 0x300
	// Boost mode used when ADC clock  6.25 MHz
	ADC_CR_BOOST_LT6_25 = 0x0
	// Boost mode used when 6.25 MHz < ADC clock  12.5 MHz
	ADC_CR_BOOST_LT12_5 = 0x1
	// Boost mode used when 12.5 MHz < ADC clock  25.0 MHz
	ADC_CR_BOOST_LT25 = 0x2
	// Boost mode used when 25.0 MHz < ADC clock  50.0 MHz
	ADC_CR_BOOST_LT50 = 0x3
	// Position of JADSTP field.
	ADC_CR_JADSTP_Pos = 0x5
	// Bit mask of JADSTP field.
	ADC_CR_JADSTP_Msk = 0x20
	// Bit JADSTP.
	ADC_CR_JADSTP = 0x20
	// Stop conversion of channel
	ADC_CR_JADSTP_Stop = 0x1
	// Position of ADSTP field.
	ADC_CR_ADSTP_Pos = 0x4
	// Bit mask of ADSTP field.
	ADC_CR_ADSTP_Msk = 0x10
	// Bit ADSTP.
	ADC_CR_ADSTP = 0x10
	// Stop conversion of channel
	ADC_CR_ADSTP_Stop = 0x1
	// Position of JADSTART field.
	ADC_CR_JADSTART_Pos = 0x3
	// Bit mask of JADSTART field.
	ADC_CR_JADSTART_Msk = 0x8
	// Bit JADSTART.
	ADC_CR_JADSTART = 0x8
	// Starts conversion of channel
	ADC_CR_JADSTART_Start = 0x1
	// Position of ADSTART field.
	ADC_CR_ADSTART_Pos = 0x2
	// Bit mask of ADSTART field.
	ADC_CR_ADSTART_Msk = 0x4
	// Bit ADSTART.
	ADC_CR_ADSTART = 0x4
	// Starts conversion of channel
	ADC_CR_ADSTART_Start = 0x1
	// Position of ADDIS field.
	ADC_CR_ADDIS_Pos = 0x1
	// Bit mask of ADDIS field.
	ADC_CR_ADDIS_Msk = 0x2
	// Bit ADDIS.
	ADC_CR_ADDIS = 0x2
	// Disable ADC conversion and go to power down mode
	ADC_CR_ADDIS_Disable = 0x0
	// Position of ADEN field.
	ADC_CR_ADEN_Pos = 0x0
	// Bit mask of ADEN field.
	ADC_CR_ADEN_Msk = 0x1
	// Bit ADEN.
	ADC_CR_ADEN = 0x1
	// Enable ADC
	ADC_CR_ADEN_Enable = 0x1

	// CFGR: ADC configuration register 1
	// Position of JQDIS field.
	ADC_CFGR_JQDIS_Pos = 0x1f
	// Bit mask of JQDIS field.
	ADC_CFGR_JQDIS_Msk = 0x80000000
	// Bit JQDIS.
	ADC_CFGR_JQDIS = 0x80000000
	// Injected Queue enabled
	ADC_CFGR_JQDIS_Enabled = 0x0
	// Injected Queue disabled
	ADC_CFGR_JQDIS_Disabled = 0x1
	// Position of AWD1CH field.
	ADC_CFGR_AWD1CH_Pos = 0x1a
	// Bit mask of AWD1CH field.
	ADC_CFGR_AWD1CH_Msk = 0x7c000000
	// Position of JAUTO field.
	ADC_CFGR_JAUTO_Pos = 0x19
	// Bit mask of JAUTO field.
	ADC_CFGR_JAUTO_Msk = 0x2000000
	// Bit JAUTO.
	ADC_CFGR_JAUTO = 0x2000000
	// Automatic injected group conversion disabled
	ADC_CFGR_JAUTO_Disabled = 0x0
	// Automatic injected group conversion enabled
	ADC_CFGR_JAUTO_Enabled = 0x1
	// Position of JAWD1EN field.
	ADC_CFGR_JAWD1EN_Pos = 0x18
	// Bit mask of JAWD1EN field.
	ADC_CFGR_JAWD1EN_Msk = 0x1000000
	// Bit JAWD1EN.
	ADC_CFGR_JAWD1EN = 0x1000000
	// Analog watchdog 1 disabled on injected channels
	ADC_CFGR_JAWD1EN_Disabled = 0x0
	// Analog watchdog 1 enabled on injected channels
	ADC_CFGR_JAWD1EN_Enabled = 0x1
	// Position of AWD1EN field.
	ADC_CFGR_AWD1EN_Pos = 0x17
	// Bit mask of AWD1EN field.
	ADC_CFGR_AWD1EN_Msk = 0x800000
	// Bit AWD1EN.
	ADC_CFGR_AWD1EN = 0x800000
	// Analog watchdog 1 disabled on regular channels
	ADC_CFGR_AWD1EN_Disabled = 0x0
	// Analog watchdog 1 enabled on regular channels
	ADC_CFGR_AWD1EN_Enabled = 0x1
	// Position of AWD1SGL field.
	ADC_CFGR_AWD1SGL_Pos = 0x16
	// Bit mask of AWD1SGL field.
	ADC_CFGR_AWD1SGL_Msk = 0x400000
	// Bit AWD1SGL.
	ADC_CFGR_AWD1SGL = 0x400000
	// Analog watchdog 1 enabled on all channels
	ADC_CFGR_AWD1SGL_All = 0x0
	// Analog watchdog 1 enabled on single channel selected in AWD1CH
	ADC_CFGR_AWD1SGL_Single = 0x1
	// Position of JQM field.
	ADC_CFGR_JQM_Pos = 0x15
	// Bit mask of JQM field.
	ADC_CFGR_JQM_Msk = 0x200000
	// Bit JQM.
	ADC_CFGR_JQM = 0x200000
	// JSQR Mode 0: Queue maintains the last written configuration into JSQR
	ADC_CFGR_JQM_Mode0 = 0x0
	// JSQR Mode 1: An empty queue disables software and hardware triggers of the injected sequence
	ADC_CFGR_JQM_Mode1 = 0x1
	// Position of JDISCEN field.
	ADC_CFGR_JDISCEN_Pos = 0x14
	// Bit mask of JDISCEN field.
	ADC_CFGR_JDISCEN_Msk = 0x100000
	// Bit JDISCEN.
	ADC_CFGR_JDISCEN = 0x100000
	// Discontinuous mode on injected channels disabled
	ADC_CFGR_JDISCEN_Disabled = 0x0
	// Discontinuous mode on injected channels enabled
	ADC_CFGR_JDISCEN_Enabled = 0x1
	// Position of DISCNUM field.
	ADC_CFGR_DISCNUM_Pos = 0x11
	// Bit mask of DISCNUM field.
	ADC_CFGR_DISCNUM_Msk = 0xe0000
	// Position of DISCEN field.
	ADC_CFGR_DISCEN_Pos = 0x10
	// Bit mask of DISCEN field.
	ADC_CFGR_DISCEN_Msk = 0x10000
	// Bit DISCEN.
	ADC_CFGR_DISCEN = 0x10000
	// Discontinuous mode on regular channels disabled
	ADC_CFGR_DISCEN_Disabled = 0x0
	// Discontinuous mode on regular channels enabled
	ADC_CFGR_DISCEN_Enabled = 0x1
	// Position of AUTDLY field.
	ADC_CFGR_AUTDLY_Pos = 0xe
	// Bit mask of AUTDLY field.
	ADC_CFGR_AUTDLY_Msk = 0x4000
	// Bit AUTDLY.
	ADC_CFGR_AUTDLY = 0x4000
	// Auto delayed conversion mode off
	ADC_CFGR_AUTDLY_Off = 0x0
	// Auto delayed conversion mode on
	ADC_CFGR_AUTDLY_On = 0x1
	// Position of CONT field.
	ADC_CFGR_CONT_Pos = 0xd
	// Bit mask of CONT field.
	ADC_CFGR_CONT_Msk = 0x2000
	// Bit CONT.
	ADC_CFGR_CONT = 0x2000
	// Single conversion mode
	ADC_CFGR_CONT_Single = 0x0
	// Continuous conversion mode
	ADC_CFGR_CONT_Continuous = 0x1
	// Position of OVRMOD field.
	ADC_CFGR_OVRMOD_Pos = 0xc
	// Bit mask of OVRMOD field.
	ADC_CFGR_OVRMOD_Msk = 0x1000
	// Bit OVRMOD.
	ADC_CFGR_OVRMOD = 0x1000
	// Preserve DR register when an overrun is detected
	ADC_CFGR_OVRMOD_Preserve = 0x0
	// Overwrite DR register when an overrun is detected
	ADC_CFGR_OVRMOD_Overwrite = 0x1
	// Position of EXTEN field.
	ADC_CFGR_EXTEN_Pos = 0xa
	// Bit mask of EXTEN field.
	ADC_CFGR_EXTEN_Msk = 0xc00
	// Trigger detection disabled
	ADC_CFGR_EXTEN_Disabled = 0x0
	// Trigger detection on the rising edge
	ADC_CFGR_EXTEN_RisingEdge = 0x1
	// Trigger detection on the falling edge
	ADC_CFGR_EXTEN_FallingEdge = 0x2
	// Trigger detection on both the rising and falling edges
	ADC_CFGR_EXTEN_BothEdges = 0x3
	// Position of EXTSEL field.
	ADC_CFGR_EXTSEL_Pos = 0x5
	// Bit mask of EXTSEL field.
	ADC_CFGR_EXTSEL_Msk = 0x3e0
	// Timer 4 CC4 event
	ADC_CFGR_EXTSEL_TIM4_CC4 = 0x5
	// Timer 8 TRGO event
	ADC_CFGR_EXTSEL_TIM8_TRGO = 0x7
	// Timer 8 TRGO2 event
	ADC_CFGR_EXTSEL_TIM8_TRGO2 = 0x8
	// Timer 4 TRGO event
	ADC_CFGR_EXTSEL_TIM4_TRGO = 0xc
	// HRTIM1_ADCTRG1 event
	ADC_CFGR_EXTSEL_HRTIM1_ADCTRG1 = 0x10
	// HRTIM1_ADCTRG3 event
	ADC_CFGR_EXTSEL_HRTIM1_ADCTRG3 = 0x11
	// LPTIM1_OUT event
	ADC_CFGR_EXTSEL_LPTIM1_OUT = 0x12
	// LPTIM2_OUT event
	ADC_CFGR_EXTSEL_LPTIM2_OUT = 0x13
	// LPTIM3_OUT event
	ADC_CFGR_EXTSEL_LPTIM3_OUT = 0x14
	// Timer 1 CC1 event
	ADC_CFGR_EXTSEL_TIM1_CC1 = 0x0
	// Timer 1 CC2 event
	ADC_CFGR_EXTSEL_TIM1_CC2 = 0x1
	// Timer 1 CC3 event
	ADC_CFGR_EXTSEL_TIM1_CC3 = 0x2
	// Timer 2 CC2 event
	ADC_CFGR_EXTSEL_TIM2_CC2 = 0x3
	// Timer 3 TRGO event
	ADC_CFGR_EXTSEL_TIM3_TRGO = 0x4
	// EXTI line 11
	ADC_CFGR_EXTSEL_EXTI11 = 0x6
	// Timer 1 TRGO event
	ADC_CFGR_EXTSEL_TIM1_TRGO = 0x9
	// Timer 1 TRGO2 event
	ADC_CFGR_EXTSEL_TIM1_TRGO2 = 0xa
	// Timer 2 TRGO event
	ADC_CFGR_EXTSEL_TIM2_TRGO = 0xb
	// Timer 6 TRGO event
	ADC_CFGR_EXTSEL_TIM6_TRGO = 0xd
	// Timer 15 TRGO event
	ADC_CFGR_EXTSEL_TIM15_TRGO = 0xe
	// Timer 3 CC4 event
	ADC_CFGR_EXTSEL_TIM3_CC4 = 0xf
	// Position of RES field.
	ADC_CFGR_RES_Pos = 0x2
	// Bit mask of RES field.
	ADC_CFGR_RES_Msk = 0x1c
	// 16-bit resolution
	ADC_CFGR_RES_SixteenBit = 0x0
	// 14-bit resolution in legacy mode (not optimized power consumption)
	ADC_CFGR_RES_FourteenBit = 0x1
	// 12-bit resolution in legacy mode (not optimized power consumption)
	ADC_CFGR_RES_TwelveBit = 0x2
	// 10-bit resolution
	ADC_CFGR_RES_TenBit = 0x3
	// 14-bit resolution
	ADC_CFGR_RES_FourteenBitV = 0x5
	// 12-bit resolution
	ADC_CFGR_RES_TwelveBitV = 0x6
	// 8-bit resolution
	ADC_CFGR_RES_EightBit = 0x7
	// Position of DMNGT field.
	ADC_CFGR_DMNGT_Pos = 0x0
	// Bit mask of DMNGT field.
	ADC_CFGR_DMNGT_Msk = 0x3
	// Store output data in DR only
	ADC_CFGR_DMNGT_DR = 0x0
	// DMA One Shot Mode selected
	ADC_CFGR_DMNGT_DMA_OneShot = 0x1
	// DFSDM mode selected
	ADC_CFGR_DMNGT_DFSDM = 0x2
	// DMA Circular Mode selected
	ADC_CFGR_DMNGT_DMA_Circular = 0x3

	// CFGR2: ADC configuration register 2
	// Position of ROVSE field.
	ADC_CFGR2_ROVSE_Pos = 0x0
	// Bit mask of ROVSE field.
	ADC_CFGR2_ROVSE_Msk = 0x1
	// Bit ROVSE.
	ADC_CFGR2_ROVSE = 0x1
	// Regular oversampling disabled
	ADC_CFGR2_ROVSE_Disabled = 0x0
	// Regular oversampling enabled
	ADC_CFGR2_ROVSE_Enabled = 0x1
	// Position of JOVSE field.
	ADC_CFGR2_JOVSE_Pos = 0x1
	// Bit mask of JOVSE field.
	ADC_CFGR2_JOVSE_Msk = 0x2
	// Bit JOVSE.
	ADC_CFGR2_JOVSE = 0x2
	// Injected oversampling disabled
	ADC_CFGR2_JOVSE_Disabled = 0x0
	// Injected oversampling enabled
	ADC_CFGR2_JOVSE_Enabled = 0x1
	// Position of OVSS field.
	ADC_CFGR2_OVSS_Pos = 0x5
	// Bit mask of OVSS field.
	ADC_CFGR2_OVSS_Msk = 0x1e0
	// Position of TROVS field.
	ADC_CFGR2_TROVS_Pos = 0x9
	// Bit mask of TROVS field.
	ADC_CFGR2_TROVS_Msk = 0x200
	// Bit TROVS.
	ADC_CFGR2_TROVS = 0x200
	// All oversampled conversions for a channel are run following a trigger
	ADC_CFGR2_TROVS_Automatic = 0x0
	// Each oversampled conversion for a channel needs a new trigger
	ADC_CFGR2_TROVS_Triggered = 0x1
	// Position of ROVSM field.
	ADC_CFGR2_ROVSM_Pos = 0xa
	// Bit mask of ROVSM field.
	ADC_CFGR2_ROVSM_Msk = 0x400
	// Bit ROVSM.
	ADC_CFGR2_ROVSM = 0x400
	// Oversampling is temporary stopped and continued after injection sequence
	ADC_CFGR2_ROVSM_Continued = 0x0
	// Oversampling is aborted and resumed from start after injection sequence
	ADC_CFGR2_ROVSM_Resumed = 0x1
	// Position of RSHIFT1 field.
	ADC_CFGR2_RSHIFT1_Pos = 0xb
	// Bit mask of RSHIFT1 field.
	ADC_CFGR2_RSHIFT1_Msk = 0x800
	// Bit RSHIFT1.
	ADC_CFGR2_RSHIFT1 = 0x800
	// Right-shifting disabled
	ADC_CFGR2_RSHIFT1_Disabled = 0x0
	// Data is right-shifted 1-bit
	ADC_CFGR2_RSHIFT1_Enabled = 0x1
	// Position of RSHIFT2 field.
	ADC_CFGR2_RSHIFT2_Pos = 0xc
	// Bit mask of RSHIFT2 field.
	ADC_CFGR2_RSHIFT2_Msk = 0x1000
	// Bit RSHIFT2.
	ADC_CFGR2_RSHIFT2 = 0x1000
	// Right-shifting disabled
	ADC_CFGR2_RSHIFT2_Disabled = 0x0
	// Data is right-shifted 1-bit
	ADC_CFGR2_RSHIFT2_Enabled = 0x1
	// Position of RSHIFT3 field.
	ADC_CFGR2_RSHIFT3_Pos = 0xd
	// Bit mask of RSHIFT3 field.
	ADC_CFGR2_RSHIFT3_Msk = 0x2000
	// Bit RSHIFT3.
	ADC_CFGR2_RSHIFT3 = 0x2000
	// Right-shifting disabled
	ADC_CFGR2_RSHIFT3_Disabled = 0x0
	// Data is right-shifted 1-bit
	ADC_CFGR2_RSHIFT3_Enabled = 0x1
	// Position of RSHIFT4 field.
	ADC_CFGR2_RSHIFT4_Pos = 0xe
	// Bit mask of RSHIFT4 field.
	ADC_CFGR2_RSHIFT4_Msk = 0x4000
	// Bit RSHIFT4.
	ADC_CFGR2_RSHIFT4 = 0x4000
	// Right-shifting disabled
	ADC_CFGR2_RSHIFT4_Disabled = 0x0
	// Data is right-shifted 1-bit
	ADC_CFGR2_RSHIFT4_Enabled = 0x1
	// Position of OSVR field.
	ADC_CFGR2_OSVR_Pos = 0x10
	// Bit mask of OSVR field.
	ADC_CFGR2_OSVR_Msk = 0x3ff0000
	// Position of LSHIFT field.
	ADC_CFGR2_LSHIFT_Pos = 0x1c
	// Bit mask of LSHIFT field.
	ADC_CFGR2_LSHIFT_Msk = 0xf0000000

	// SMPR1: ADC sampling time register 1
	// Position of SMP9 field.
	ADC_SMPR1_SMP9_Pos = 0x1b
	// Bit mask of SMP9 field.
	ADC_SMPR1_SMP9_Msk = 0x38000000
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP9_Cycles810_5 = 0x7
	// Position of SMP8 field.
	ADC_SMPR1_SMP8_Pos = 0x18
	// Bit mask of SMP8 field.
	ADC_SMPR1_SMP8_Msk = 0x7000000
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP8_Cycles810_5 = 0x7
	// Position of SMP7 field.
	ADC_SMPR1_SMP7_Pos = 0x15
	// Bit mask of SMP7 field.
	ADC_SMPR1_SMP7_Msk = 0xe00000
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP7_Cycles810_5 = 0x7
	// Position of SMP6 field.
	ADC_SMPR1_SMP6_Pos = 0x12
	// Bit mask of SMP6 field.
	ADC_SMPR1_SMP6_Msk = 0x1c0000
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP6_Cycles810_5 = 0x7
	// Position of SMP5 field.
	ADC_SMPR1_SMP5_Pos = 0xf
	// Bit mask of SMP5 field.
	ADC_SMPR1_SMP5_Msk = 0x38000
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP5_Cycles810_5 = 0x7
	// Position of SMP4 field.
	ADC_SMPR1_SMP4_Pos = 0xc
	// Bit mask of SMP4 field.
	ADC_SMPR1_SMP4_Msk = 0x7000
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP4_Cycles810_5 = 0x7
	// Position of SMP3 field.
	ADC_SMPR1_SMP3_Pos = 0x9
	// Bit mask of SMP3 field.
	ADC_SMPR1_SMP3_Msk = 0xe00
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP3_Cycles810_5 = 0x7
	// Position of SMP2 field.
	ADC_SMPR1_SMP2_Pos = 0x6
	// Bit mask of SMP2 field.
	ADC_SMPR1_SMP2_Msk = 0x1c0
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP2_Cycles810_5 = 0x7
	// Position of SMP1 field.
	ADC_SMPR1_SMP1_Pos = 0x3
	// Bit mask of SMP1 field.
	ADC_SMPR1_SMP1_Msk = 0x38
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP1_Cycles810_5 = 0x7
	// Position of SMP0 field.
	ADC_SMPR1_SMP0_Pos = 0x0
	// Bit mask of SMP0 field.
	ADC_SMPR1_SMP0_Msk = 0x7
	// 1.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR1_SMP0_Cycles810_5 = 0x7

	// SMPR2: ADC sampling time register 2
	// Position of SMP19 field.
	ADC_SMPR2_SMP19_Pos = 0x1b
	// Bit mask of SMP19 field.
	ADC_SMPR2_SMP19_Msk = 0x38000000
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP19_Cycles810_5 = 0x7
	// Position of SMP18 field.
	ADC_SMPR2_SMP18_Pos = 0x18
	// Bit mask of SMP18 field.
	ADC_SMPR2_SMP18_Msk = 0x7000000
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP18_Cycles810_5 = 0x7
	// Position of SMP17 field.
	ADC_SMPR2_SMP17_Pos = 0x15
	// Bit mask of SMP17 field.
	ADC_SMPR2_SMP17_Msk = 0xe00000
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP17_Cycles810_5 = 0x7
	// Position of SMP16 field.
	ADC_SMPR2_SMP16_Pos = 0x12
	// Bit mask of SMP16 field.
	ADC_SMPR2_SMP16_Msk = 0x1c0000
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP16_Cycles810_5 = 0x7
	// Position of SMP15 field.
	ADC_SMPR2_SMP15_Pos = 0xf
	// Bit mask of SMP15 field.
	ADC_SMPR2_SMP15_Msk = 0x38000
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP15_Cycles810_5 = 0x7
	// Position of SMP14 field.
	ADC_SMPR2_SMP14_Pos = 0xc
	// Bit mask of SMP14 field.
	ADC_SMPR2_SMP14_Msk = 0x7000
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP14_Cycles810_5 = 0x7
	// Position of SMP13 field.
	ADC_SMPR2_SMP13_Pos = 0x9
	// Bit mask of SMP13 field.
	ADC_SMPR2_SMP13_Msk = 0xe00
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP13_Cycles810_5 = 0x7
	// Position of SMP12 field.
	ADC_SMPR2_SMP12_Pos = 0x6
	// Bit mask of SMP12 field.
	ADC_SMPR2_SMP12_Msk = 0x1c0
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP12_Cycles810_5 = 0x7
	// Position of SMP11 field.
	ADC_SMPR2_SMP11_Pos = 0x3
	// Bit mask of SMP11 field.
	ADC_SMPR2_SMP11_Msk = 0x38
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP11_Cycles810_5 = 0x7
	// Position of SMP10 field.
	ADC_SMPR2_SMP10_Pos = 0x0
	// Bit mask of SMP10 field.
	ADC_SMPR2_SMP10_Msk = 0x7
	// 1.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles1_5 = 0x0
	// 2.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles2_5 = 0x1
	// 8.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles8_5 = 0x2
	// 16.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles16_5 = 0x3
	// 32.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles32_5 = 0x4
	// 64.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles64_5 = 0x5
	// 387.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles387_5 = 0x6
	// 810.5 ADC clock cycles
	ADC_SMPR2_SMP10_Cycles810_5 = 0x7

	// PCSEL: ADC pre channel selection register
	// Position of PCSEL field.
	ADC_PCSEL_PCSEL_Pos = 0x0
	// Bit mask of PCSEL field.
	ADC_PCSEL_PCSEL_Msk = 0xfffff
	// Input channel x is not pre-selected
	ADC_PCSEL_PCSEL_NotPreselected = 0x0
	// Pre-select input channel x
	ADC_PCSEL_PCSEL_Preselected = 0x1

	// LTR1: ADC analog watchdog 1 threshold register
	// Position of LTR1 field.
	ADC_LTR1_LTR1_Pos = 0x0
	// Bit mask of LTR1 field.
	ADC_LTR1_LTR1_Msk = 0x3ffffff

	// HTR1: ADC analog watchdog 2 threshold register
	// Position of HTR1 field.
	ADC_HTR1_HTR1_Pos = 0x0
	// Bit mask of HTR1 field.
	ADC_HTR1_HTR1_Msk = 0x3ffffff

	// SQR1: ADC group regular sequencer ranks register 1
	// Position of SQ4 field.
	ADC_SQR1_SQ4_Pos = 0x18
	// Bit mask of SQ4 field.
	ADC_SQR1_SQ4_Msk = 0x1f000000
	// Position of SQ3 field.
	ADC_SQR1_SQ3_Pos = 0x12
	// Bit mask of SQ3 field.
	ADC_SQR1_SQ3_Msk = 0x7c0000
	// Position of SQ2 field.
	ADC_SQR1_SQ2_Pos = 0xc
	// Bit mask of SQ2 field.
	ADC_SQR1_SQ2_Msk = 0x1f000
	// Position of SQ1 field.
	ADC_SQR1_SQ1_Pos = 0x6
	// Bit mask of SQ1 field.
	ADC_SQR1_SQ1_Msk = 0x7c0
	// Position of L field.
	ADC_SQR1_L_Pos = 0x0
	// Bit mask of L field.
	ADC_SQR1_L_Msk = 0xf

	// SQR2: ADC group regular sequencer ranks register 2
	// Position of SQ9 field.
	ADC_SQR2_SQ9_Pos = 0x18
	// Bit mask of SQ9 field.
	ADC_SQR2_SQ9_Msk = 0x1f000000
	// Position of SQ8 field.
	ADC_SQR2_SQ8_Pos = 0x12
	// Bit mask of SQ8 field.
	ADC_SQR2_SQ8_Msk = 0x7c0000
	// Position of SQ7 field.
	ADC_SQR2_SQ7_Pos = 0xc
	// Bit mask of SQ7 field.
	ADC_SQR2_SQ7_Msk = 0x1f000
	// Position of SQ6 field.
	ADC_SQR2_SQ6_Pos = 0x6
	// Bit mask of SQ6 field.
	ADC_SQR2_SQ6_Msk = 0x7c0
	// Position of SQ5 field.
	ADC_SQR2_SQ5_Pos = 0x0
	// Bit mask of SQ5 field.
	ADC_SQR2_SQ5_Msk = 0x1f

	// SQR3: ADC group regular sequencer ranks register 3
	// Position of SQ14 field.
	ADC_SQR3_SQ14_Pos = 0x18
	// Bit mask of SQ14 field.
	ADC_SQR3_SQ14_Msk = 0x1f000000
	// Position of SQ13 field.
	ADC_SQR3_SQ13_Pos = 0x12
	// Bit mask of SQ13 field.
	ADC_SQR3_SQ13_Msk = 0x7c0000
	// Position of SQ12 field.
	ADC_SQR3_SQ12_Pos = 0xc
	// Bit mask of SQ12 field.
	ADC_SQR3_SQ12_Msk = 0x1f000
	// Position of SQ11 field.
	ADC_SQR3_SQ11_Pos = 0x6
	// Bit mask of SQ11 field.
	ADC_SQR3_SQ11_Msk = 0x7c0
	// Position of SQ10 field.
	ADC_SQR3_SQ10_Pos = 0x0
	// Bit mask of SQ10 field.
	ADC_SQR3_SQ10_Msk = 0x1f

	// SQR4: ADC group regular sequencer ranks register 4
	// Position of SQ16 field.
	ADC_SQR4_SQ16_Pos = 0x6
	// Bit mask of SQ16 field.
	ADC_SQR4_SQ16_Msk = 0x7c0
	// Position of SQ15 field.
	ADC_SQR4_SQ15_Pos = 0x0
	// Bit mask of SQ15 field.
	ADC_SQR4_SQ15_Msk = 0x1f

	// DR: ADC group regular conversion data register
	// Position of RDATA field.
	ADC_DR_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	ADC_DR_RDATA_Msk = 0xffff

	// JSQR: ADC group injected sequencer register
	// Position of JSQ4 field.
	ADC_JSQR_JSQ4_Pos = 0x1b
	// Bit mask of JSQ4 field.
	ADC_JSQR_JSQ4_Msk = 0xf8000000
	// Position of JSQ3 field.
	ADC_JSQR_JSQ3_Pos = 0x15
	// Bit mask of JSQ3 field.
	ADC_JSQR_JSQ3_Msk = 0x3e00000
	// Position of JSQ2 field.
	ADC_JSQR_JSQ2_Pos = 0xf
	// Bit mask of JSQ2 field.
	ADC_JSQR_JSQ2_Msk = 0xf8000
	// Position of JSQ1 field.
	ADC_JSQR_JSQ1_Pos = 0x9
	// Bit mask of JSQ1 field.
	ADC_JSQR_JSQ1_Msk = 0x3e00
	// Position of JEXTEN field.
	ADC_JSQR_JEXTEN_Pos = 0x7
	// Bit mask of JEXTEN field.
	ADC_JSQR_JEXTEN_Msk = 0x180
	// Trigger detection disabled
	ADC_JSQR_JEXTEN_Disabled = 0x0
	// Trigger detection on the rising edge
	ADC_JSQR_JEXTEN_RisingEdge = 0x1
	// Trigger detection on the falling edge
	ADC_JSQR_JEXTEN_FallingEdge = 0x2
	// Trigger detection on both the rising and falling edges
	ADC_JSQR_JEXTEN_BothEdges = 0x3
	// Position of JEXTSEL field.
	ADC_JSQR_JEXTSEL_Pos = 0x2
	// Bit mask of JEXTSEL field.
	ADC_JSQR_JEXTSEL_Msk = 0x7c
	// Timer 4 TRGO event
	ADC_JSQR_JEXTSEL_TIM4_TRGO = 0x5
	// Timer 8 CC4 event
	ADC_JSQR_JEXTSEL_TIM8_CC4 = 0x7
	// Timer 8 TRGO event
	ADC_JSQR_JEXTSEL_TIM8_TRGO = 0x9
	// Timer 8 TRGO2 event
	ADC_JSQR_JEXTSEL_TIM8_TRGO2 = 0xa
	// HRTIM1_ADCTRG2 event
	ADC_JSQR_JEXTSEL_HRTIM1_ADCTRG2 = 0x10
	// HRTIM1_ADCTRG4 event
	ADC_JSQR_JEXTSEL_HRTIM1_ADCTRG4 = 0x11
	// LPTIM1_OUT event
	ADC_JSQR_JEXTSEL_LPTIM1_OUT = 0x12
	// LPTIM2_OUT event
	ADC_JSQR_JEXTSEL_LPTIM2_OUT = 0x13
	// LPTIM3_OUT event
	ADC_JSQR_JEXTSEL_LPTIM3_OUT = 0x14
	// Timer 1 TRGO event
	ADC_JSQR_JEXTSEL_TIM1_TRGO = 0x0
	// Timer 1 CC4 event
	ADC_JSQR_JEXTSEL_TIM1_CC4 = 0x1
	// Timer 2 TRGO event
	ADC_JSQR_JEXTSEL_TIM2_TRGO = 0x2
	// Timer 2 CC1 event
	ADC_JSQR_JEXTSEL_TIM2_CC1 = 0x3
	// Timer 3 CC4 event
	ADC_JSQR_JEXTSEL_TIM3_CC4 = 0x4
	// EXTI line 15
	ADC_JSQR_JEXTSEL_EXTI15 = 0x6
	// Timer 1 TRGO2 event
	ADC_JSQR_JEXTSEL_TIM1_TRGO2 = 0x8
	// Timer 3 CC3 event
	ADC_JSQR_JEXTSEL_TIM3_CC3 = 0xb
	// Timer 3 TRGO event
	ADC_JSQR_JEXTSEL_TIM3_TRGO = 0xc
	// Timer 3 CC1 event
	ADC_JSQR_JEXTSEL_TIM3_CC1 = 0xd
	// Timer 6 TRGO event
	ADC_JSQR_JEXTSEL_TIM6_TRGO = 0xe
	// Timer 15 TRGO event
	ADC_JSQR_JEXTSEL_TIM15_TRGO = 0xf
	// Position of JL field.
	ADC_JSQR_JL_Pos = 0x0
	// Bit mask of JL field.
	ADC_JSQR_JL_Msk = 0x3

	// OFR1: ADC offset number 1 register
	// Position of SSATE field.
	ADC_OFR1_SSATE_Pos = 0x1f
	// Bit mask of SSATE field.
	ADC_OFR1_SSATE_Msk = 0x80000000
	// Bit SSATE.
	ADC_OFR1_SSATE = 0x80000000
	// Offset is subtracted maintaining data integrity and extending result size (9-bit and 17-bit signed format)
	ADC_OFR1_SSATE_Disabled = 0x0
	// Offset is subtracted and result is saturated to maintain result size
	ADC_OFR1_SSATE_Enabled = 0x1
	// Position of OFFSET1_CH field.
	ADC_OFR1_OFFSET1_CH_Pos = 0x1a
	// Bit mask of OFFSET1_CH field.
	ADC_OFR1_OFFSET1_CH_Msk = 0x7c000000
	// Position of OFFSET1 field.
	ADC_OFR1_OFFSET1_Pos = 0x0
	// Bit mask of OFFSET1 field.
	ADC_OFR1_OFFSET1_Msk = 0x3ffffff

	// OFR2: ADC offset number 2 register
	// Position of SSATE field.
	ADC_OFR2_SSATE_Pos = 0x1f
	// Bit mask of SSATE field.
	ADC_OFR2_SSATE_Msk = 0x80000000
	// Bit SSATE.
	ADC_OFR2_SSATE = 0x80000000
	// Offset is subtracted maintaining data integrity and extending result size (9-bit and 17-bit signed format)
	ADC_OFR2_SSATE_Disabled = 0x0
	// Offset is subtracted and result is saturated to maintain result size
	ADC_OFR2_SSATE_Enabled = 0x1
	// Position of OFFSET2_CH field.
	ADC_OFR2_OFFSET2_CH_Pos = 0x1a
	// Bit mask of OFFSET2_CH field.
	ADC_OFR2_OFFSET2_CH_Msk = 0x7c000000
	// Position of OFFSET2 field.
	ADC_OFR2_OFFSET2_Pos = 0x0
	// Bit mask of OFFSET2 field.
	ADC_OFR2_OFFSET2_Msk = 0x3ffffff

	// OFR3: ADC offset number 3 register
	// Position of SSATE field.
	ADC_OFR3_SSATE_Pos = 0x1f
	// Bit mask of SSATE field.
	ADC_OFR3_SSATE_Msk = 0x80000000
	// Bit SSATE.
	ADC_OFR3_SSATE = 0x80000000
	// Offset is subtracted maintaining data integrity and extending result size (9-bit and 17-bit signed format)
	ADC_OFR3_SSATE_Disabled = 0x0
	// Offset is subtracted and result is saturated to maintain result size
	ADC_OFR3_SSATE_Enabled = 0x1
	// Position of OFFSET3_CH field.
	ADC_OFR3_OFFSET3_CH_Pos = 0x1a
	// Bit mask of OFFSET3_CH field.
	ADC_OFR3_OFFSET3_CH_Msk = 0x7c000000
	// Position of OFFSET3 field.
	ADC_OFR3_OFFSET3_Pos = 0x0
	// Bit mask of OFFSET3 field.
	ADC_OFR3_OFFSET3_Msk = 0x3ffffff

	// OFR4: ADC offset number 4 register
	// Position of SSATE field.
	ADC_OFR4_SSATE_Pos = 0x1f
	// Bit mask of SSATE field.
	ADC_OFR4_SSATE_Msk = 0x80000000
	// Bit SSATE.
	ADC_OFR4_SSATE = 0x80000000
	// Offset is subtracted maintaining data integrity and extending result size (9-bit and 17-bit signed format)
	ADC_OFR4_SSATE_Disabled = 0x0
	// Offset is subtracted and result is saturated to maintain result size
	ADC_OFR4_SSATE_Enabled = 0x1
	// Position of OFFSET4_CH field.
	ADC_OFR4_OFFSET4_CH_Pos = 0x1a
	// Bit mask of OFFSET4_CH field.
	ADC_OFR4_OFFSET4_CH_Msk = 0x7c000000
	// Position of OFFSET4 field.
	ADC_OFR4_OFFSET4_Pos = 0x0
	// Bit mask of OFFSET4 field.
	ADC_OFR4_OFFSET4_Msk = 0x3ffffff

	// JDR1: ADC group injected sequencer rank 1 register
	// Position of JDATA1 field.
	ADC_JDR1_JDATA1_Pos = 0x0
	// Bit mask of JDATA1 field.
	ADC_JDR1_JDATA1_Msk = 0xffffffff

	// JDR2: ADC group injected sequencer rank 2 register
	// Position of JDATA2 field.
	ADC_JDR2_JDATA2_Pos = 0x0
	// Bit mask of JDATA2 field.
	ADC_JDR2_JDATA2_Msk = 0xffffffff

	// JDR3: ADC group injected sequencer rank 3 register
	// Position of JDATA3 field.
	ADC_JDR3_JDATA3_Pos = 0x0
	// Bit mask of JDATA3 field.
	ADC_JDR3_JDATA3_Msk = 0xffffffff

	// JDR4: ADC group injected sequencer rank 4 register
	// Position of JDATA4 field.
	ADC_JDR4_JDATA4_Pos = 0x0
	// Bit mask of JDATA4 field.
	ADC_JDR4_JDATA4_Msk = 0xffffffff

	// AWD2CR: ADC analog watchdog 2 configuration register
	// Position of AWD2CH0 field.
	ADC_AWD2CR_AWD2CH0_Pos = 0x0
	// Bit mask of AWD2CH0 field.
	ADC_AWD2CR_AWD2CH0_Msk = 0x1
	// Bit AWD2CH0.
	ADC_AWD2CR_AWD2CH0 = 0x1
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH0_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH0_Monitored = 0x1
	// Position of AWD2CH1 field.
	ADC_AWD2CR_AWD2CH1_Pos = 0x1
	// Bit mask of AWD2CH1 field.
	ADC_AWD2CR_AWD2CH1_Msk = 0x2
	// Bit AWD2CH1.
	ADC_AWD2CR_AWD2CH1 = 0x2
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH1_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH1_Monitored = 0x1
	// Position of AWD2CH2 field.
	ADC_AWD2CR_AWD2CH2_Pos = 0x2
	// Bit mask of AWD2CH2 field.
	ADC_AWD2CR_AWD2CH2_Msk = 0x4
	// Bit AWD2CH2.
	ADC_AWD2CR_AWD2CH2 = 0x4
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH2_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH2_Monitored = 0x1
	// Position of AWD2CH3 field.
	ADC_AWD2CR_AWD2CH3_Pos = 0x3
	// Bit mask of AWD2CH3 field.
	ADC_AWD2CR_AWD2CH3_Msk = 0x8
	// Bit AWD2CH3.
	ADC_AWD2CR_AWD2CH3 = 0x8
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH3_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH3_Monitored = 0x1
	// Position of AWD2CH4 field.
	ADC_AWD2CR_AWD2CH4_Pos = 0x4
	// Bit mask of AWD2CH4 field.
	ADC_AWD2CR_AWD2CH4_Msk = 0x10
	// Bit AWD2CH4.
	ADC_AWD2CR_AWD2CH4 = 0x10
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH4_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH4_Monitored = 0x1
	// Position of AWD2CH5 field.
	ADC_AWD2CR_AWD2CH5_Pos = 0x5
	// Bit mask of AWD2CH5 field.
	ADC_AWD2CR_AWD2CH5_Msk = 0x20
	// Bit AWD2CH5.
	ADC_AWD2CR_AWD2CH5 = 0x20
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH5_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH5_Monitored = 0x1
	// Position of AWD2CH6 field.
	ADC_AWD2CR_AWD2CH6_Pos = 0x6
	// Bit mask of AWD2CH6 field.
	ADC_AWD2CR_AWD2CH6_Msk = 0x40
	// Bit AWD2CH6.
	ADC_AWD2CR_AWD2CH6 = 0x40
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH6_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH6_Monitored = 0x1
	// Position of AWD2CH7 field.
	ADC_AWD2CR_AWD2CH7_Pos = 0x7
	// Bit mask of AWD2CH7 field.
	ADC_AWD2CR_AWD2CH7_Msk = 0x80
	// Bit AWD2CH7.
	ADC_AWD2CR_AWD2CH7 = 0x80
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH7_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH7_Monitored = 0x1
	// Position of AWD2CH8 field.
	ADC_AWD2CR_AWD2CH8_Pos = 0x8
	// Bit mask of AWD2CH8 field.
	ADC_AWD2CR_AWD2CH8_Msk = 0x100
	// Bit AWD2CH8.
	ADC_AWD2CR_AWD2CH8 = 0x100
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH8_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH8_Monitored = 0x1
	// Position of AWD2CH9 field.
	ADC_AWD2CR_AWD2CH9_Pos = 0x9
	// Bit mask of AWD2CH9 field.
	ADC_AWD2CR_AWD2CH9_Msk = 0x200
	// Bit AWD2CH9.
	ADC_AWD2CR_AWD2CH9 = 0x200
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH9_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH9_Monitored = 0x1
	// Position of AWD2CH10 field.
	ADC_AWD2CR_AWD2CH10_Pos = 0xa
	// Bit mask of AWD2CH10 field.
	ADC_AWD2CR_AWD2CH10_Msk = 0x400
	// Bit AWD2CH10.
	ADC_AWD2CR_AWD2CH10 = 0x400
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH10_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH10_Monitored = 0x1
	// Position of AWD2CH11 field.
	ADC_AWD2CR_AWD2CH11_Pos = 0xb
	// Bit mask of AWD2CH11 field.
	ADC_AWD2CR_AWD2CH11_Msk = 0x800
	// Bit AWD2CH11.
	ADC_AWD2CR_AWD2CH11 = 0x800
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH11_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH11_Monitored = 0x1
	// Position of AWD2CH12 field.
	ADC_AWD2CR_AWD2CH12_Pos = 0xc
	// Bit mask of AWD2CH12 field.
	ADC_AWD2CR_AWD2CH12_Msk = 0x1000
	// Bit AWD2CH12.
	ADC_AWD2CR_AWD2CH12 = 0x1000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH12_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH12_Monitored = 0x1
	// Position of AWD2CH13 field.
	ADC_AWD2CR_AWD2CH13_Pos = 0xd
	// Bit mask of AWD2CH13 field.
	ADC_AWD2CR_AWD2CH13_Msk = 0x2000
	// Bit AWD2CH13.
	ADC_AWD2CR_AWD2CH13 = 0x2000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH13_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH13_Monitored = 0x1
	// Position of AWD2CH14 field.
	ADC_AWD2CR_AWD2CH14_Pos = 0xe
	// Bit mask of AWD2CH14 field.
	ADC_AWD2CR_AWD2CH14_Msk = 0x4000
	// Bit AWD2CH14.
	ADC_AWD2CR_AWD2CH14 = 0x4000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH14_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH14_Monitored = 0x1
	// Position of AWD2CH15 field.
	ADC_AWD2CR_AWD2CH15_Pos = 0xf
	// Bit mask of AWD2CH15 field.
	ADC_AWD2CR_AWD2CH15_Msk = 0x8000
	// Bit AWD2CH15.
	ADC_AWD2CR_AWD2CH15 = 0x8000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH15_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH15_Monitored = 0x1
	// Position of AWD2CH16 field.
	ADC_AWD2CR_AWD2CH16_Pos = 0x10
	// Bit mask of AWD2CH16 field.
	ADC_AWD2CR_AWD2CH16_Msk = 0x10000
	// Bit AWD2CH16.
	ADC_AWD2CR_AWD2CH16 = 0x10000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH16_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH16_Monitored = 0x1
	// Position of AWD2CH17 field.
	ADC_AWD2CR_AWD2CH17_Pos = 0x11
	// Bit mask of AWD2CH17 field.
	ADC_AWD2CR_AWD2CH17_Msk = 0x20000
	// Bit AWD2CH17.
	ADC_AWD2CR_AWD2CH17 = 0x20000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH17_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH17_Monitored = 0x1
	// Position of AWD2CH18 field.
	ADC_AWD2CR_AWD2CH18_Pos = 0x12
	// Bit mask of AWD2CH18 field.
	ADC_AWD2CR_AWD2CH18_Msk = 0x40000
	// Bit AWD2CH18.
	ADC_AWD2CR_AWD2CH18 = 0x40000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH18_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH18_Monitored = 0x1
	// Position of AWD2CH19 field.
	ADC_AWD2CR_AWD2CH19_Pos = 0x13
	// Bit mask of AWD2CH19 field.
	ADC_AWD2CR_AWD2CH19_Msk = 0x80000
	// Bit AWD2CH19.
	ADC_AWD2CR_AWD2CH19 = 0x80000
	// Input channel not monitored by AWDx
	ADC_AWD2CR_AWD2CH19_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD2CR_AWD2CH19_Monitored = 0x1

	// AWD3CR: ADC analog watchdog 3 configuration register
	// Position of AWD3CH0 field.
	ADC_AWD3CR_AWD3CH0_Pos = 0x1
	// Bit mask of AWD3CH0 field.
	ADC_AWD3CR_AWD3CH0_Msk = 0x2
	// Bit AWD3CH0.
	ADC_AWD3CR_AWD3CH0 = 0x2
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH0_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH0_Monitored = 0x1
	// Position of AWD3CH1 field.
	ADC_AWD3CR_AWD3CH1_Pos = 0x2
	// Bit mask of AWD3CH1 field.
	ADC_AWD3CR_AWD3CH1_Msk = 0x4
	// Bit AWD3CH1.
	ADC_AWD3CR_AWD3CH1 = 0x4
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH1_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH1_Monitored = 0x1
	// Position of AWD3CH2 field.
	ADC_AWD3CR_AWD3CH2_Pos = 0x3
	// Bit mask of AWD3CH2 field.
	ADC_AWD3CR_AWD3CH2_Msk = 0x8
	// Bit AWD3CH2.
	ADC_AWD3CR_AWD3CH2 = 0x8
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH2_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH2_Monitored = 0x1
	// Position of AWD3CH3 field.
	ADC_AWD3CR_AWD3CH3_Pos = 0x4
	// Bit mask of AWD3CH3 field.
	ADC_AWD3CR_AWD3CH3_Msk = 0x10
	// Bit AWD3CH3.
	ADC_AWD3CR_AWD3CH3 = 0x10
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH3_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH3_Monitored = 0x1
	// Position of AWD3CH4 field.
	ADC_AWD3CR_AWD3CH4_Pos = 0x5
	// Bit mask of AWD3CH4 field.
	ADC_AWD3CR_AWD3CH4_Msk = 0x20
	// Bit AWD3CH4.
	ADC_AWD3CR_AWD3CH4 = 0x20
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH4_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH4_Monitored = 0x1
	// Position of AWD3CH5 field.
	ADC_AWD3CR_AWD3CH5_Pos = 0x6
	// Bit mask of AWD3CH5 field.
	ADC_AWD3CR_AWD3CH5_Msk = 0x40
	// Bit AWD3CH5.
	ADC_AWD3CR_AWD3CH5 = 0x40
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH5_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH5_Monitored = 0x1
	// Position of AWD3CH6 field.
	ADC_AWD3CR_AWD3CH6_Pos = 0x7
	// Bit mask of AWD3CH6 field.
	ADC_AWD3CR_AWD3CH6_Msk = 0x80
	// Bit AWD3CH6.
	ADC_AWD3CR_AWD3CH6 = 0x80
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH6_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH6_Monitored = 0x1
	// Position of AWD3CH7 field.
	ADC_AWD3CR_AWD3CH7_Pos = 0x8
	// Bit mask of AWD3CH7 field.
	ADC_AWD3CR_AWD3CH7_Msk = 0x100
	// Bit AWD3CH7.
	ADC_AWD3CR_AWD3CH7 = 0x100
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH7_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH7_Monitored = 0x1
	// Position of AWD3CH8 field.
	ADC_AWD3CR_AWD3CH8_Pos = 0x9
	// Bit mask of AWD3CH8 field.
	ADC_AWD3CR_AWD3CH8_Msk = 0x200
	// Bit AWD3CH8.
	ADC_AWD3CR_AWD3CH8 = 0x200
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH8_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH8_Monitored = 0x1
	// Position of AWD3CH9 field.
	ADC_AWD3CR_AWD3CH9_Pos = 0xa
	// Bit mask of AWD3CH9 field.
	ADC_AWD3CR_AWD3CH9_Msk = 0x400
	// Bit AWD3CH9.
	ADC_AWD3CR_AWD3CH9 = 0x400
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH9_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH9_Monitored = 0x1
	// Position of AWD3CH10 field.
	ADC_AWD3CR_AWD3CH10_Pos = 0xb
	// Bit mask of AWD3CH10 field.
	ADC_AWD3CR_AWD3CH10_Msk = 0x800
	// Bit AWD3CH10.
	ADC_AWD3CR_AWD3CH10 = 0x800
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH10_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH10_Monitored = 0x1
	// Position of AWD3CH11 field.
	ADC_AWD3CR_AWD3CH11_Pos = 0xc
	// Bit mask of AWD3CH11 field.
	ADC_AWD3CR_AWD3CH11_Msk = 0x1000
	// Bit AWD3CH11.
	ADC_AWD3CR_AWD3CH11 = 0x1000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH11_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH11_Monitored = 0x1
	// Position of AWD3CH12 field.
	ADC_AWD3CR_AWD3CH12_Pos = 0xd
	// Bit mask of AWD3CH12 field.
	ADC_AWD3CR_AWD3CH12_Msk = 0x2000
	// Bit AWD3CH12.
	ADC_AWD3CR_AWD3CH12 = 0x2000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH12_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH12_Monitored = 0x1
	// Position of AWD3CH13 field.
	ADC_AWD3CR_AWD3CH13_Pos = 0xe
	// Bit mask of AWD3CH13 field.
	ADC_AWD3CR_AWD3CH13_Msk = 0x4000
	// Bit AWD3CH13.
	ADC_AWD3CR_AWD3CH13 = 0x4000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH13_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH13_Monitored = 0x1
	// Position of AWD3CH14 field.
	ADC_AWD3CR_AWD3CH14_Pos = 0xf
	// Bit mask of AWD3CH14 field.
	ADC_AWD3CR_AWD3CH14_Msk = 0x8000
	// Bit AWD3CH14.
	ADC_AWD3CR_AWD3CH14 = 0x8000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH14_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH14_Monitored = 0x1
	// Position of AWD3CH15 field.
	ADC_AWD3CR_AWD3CH15_Pos = 0x10
	// Bit mask of AWD3CH15 field.
	ADC_AWD3CR_AWD3CH15_Msk = 0x10000
	// Bit AWD3CH15.
	ADC_AWD3CR_AWD3CH15 = 0x10000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH15_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH15_Monitored = 0x1
	// Position of AWD3CH16 field.
	ADC_AWD3CR_AWD3CH16_Pos = 0x11
	// Bit mask of AWD3CH16 field.
	ADC_AWD3CR_AWD3CH16_Msk = 0x20000
	// Bit AWD3CH16.
	ADC_AWD3CR_AWD3CH16 = 0x20000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH16_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH16_Monitored = 0x1
	// Position of AWD3CH17 field.
	ADC_AWD3CR_AWD3CH17_Pos = 0x12
	// Bit mask of AWD3CH17 field.
	ADC_AWD3CR_AWD3CH17_Msk = 0x40000
	// Bit AWD3CH17.
	ADC_AWD3CR_AWD3CH17 = 0x40000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH17_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH17_Monitored = 0x1
	// Position of AWD3CH18 field.
	ADC_AWD3CR_AWD3CH18_Pos = 0x13
	// Bit mask of AWD3CH18 field.
	ADC_AWD3CR_AWD3CH18_Msk = 0x80000
	// Bit AWD3CH18.
	ADC_AWD3CR_AWD3CH18 = 0x80000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH18_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH18_Monitored = 0x1
	// Position of AWD3CH19 field.
	ADC_AWD3CR_AWD3CH19_Pos = 0x14
	// Bit mask of AWD3CH19 field.
	ADC_AWD3CR_AWD3CH19_Msk = 0x100000
	// Bit AWD3CH19.
	ADC_AWD3CR_AWD3CH19 = 0x100000
	// Input channel not monitored by AWDx
	ADC_AWD3CR_AWD3CH19_NotMonitored = 0x0
	// Input channel monitored by AWDx
	ADC_AWD3CR_AWD3CH19_Monitored = 0x1

	// LTR2: ADC watchdog lower threshold register 2
	// Position of LTR2 field.
	ADC_LTR2_LTR2_Pos = 0x0
	// Bit mask of LTR2 field.
	ADC_LTR2_LTR2_Msk = 0x3ffffff

	// HTR2: ADC watchdog higher threshold register 2
	// Position of HTR2 field.
	ADC_HTR2_HTR2_Pos = 0x0
	// Bit mask of HTR2 field.
	ADC_HTR2_HTR2_Msk = 0x3ffffff

	// LTR3: ADC watchdog lower threshold register 3
	// Position of LTR3 field.
	ADC_LTR3_LTR3_Pos = 0x0
	// Bit mask of LTR3 field.
	ADC_LTR3_LTR3_Msk = 0x3ffffff

	// HTR3: ADC watchdog higher threshold register 3
	// Position of HTR3 field.
	ADC_HTR3_HTR3_Pos = 0x0
	// Bit mask of HTR3 field.
	ADC_HTR3_HTR3_Msk = 0x3ffffff

	// DIFSEL: ADC channel differential or single-ended mode selection register
	// Position of DIFSEL0 field.
	ADC_DIFSEL_DIFSEL0_Pos = 0x0
	// Bit mask of DIFSEL0 field.
	ADC_DIFSEL_DIFSEL0_Msk = 0x1
	// Bit DIFSEL0.
	ADC_DIFSEL_DIFSEL0 = 0x1
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL0_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL0_Differential = 0x1
	// Position of DIFSEL1 field.
	ADC_DIFSEL_DIFSEL1_Pos = 0x1
	// Bit mask of DIFSEL1 field.
	ADC_DIFSEL_DIFSEL1_Msk = 0x2
	// Bit DIFSEL1.
	ADC_DIFSEL_DIFSEL1 = 0x2
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL1_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL1_Differential = 0x1
	// Position of DIFSEL2 field.
	ADC_DIFSEL_DIFSEL2_Pos = 0x2
	// Bit mask of DIFSEL2 field.
	ADC_DIFSEL_DIFSEL2_Msk = 0x4
	// Bit DIFSEL2.
	ADC_DIFSEL_DIFSEL2 = 0x4
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL2_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL2_Differential = 0x1
	// Position of DIFSEL3 field.
	ADC_DIFSEL_DIFSEL3_Pos = 0x3
	// Bit mask of DIFSEL3 field.
	ADC_DIFSEL_DIFSEL3_Msk = 0x8
	// Bit DIFSEL3.
	ADC_DIFSEL_DIFSEL3 = 0x8
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL3_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL3_Differential = 0x1
	// Position of DIFSEL4 field.
	ADC_DIFSEL_DIFSEL4_Pos = 0x4
	// Bit mask of DIFSEL4 field.
	ADC_DIFSEL_DIFSEL4_Msk = 0x10
	// Bit DIFSEL4.
	ADC_DIFSEL_DIFSEL4 = 0x10
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL4_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL4_Differential = 0x1
	// Position of DIFSEL5 field.
	ADC_DIFSEL_DIFSEL5_Pos = 0x5
	// Bit mask of DIFSEL5 field.
	ADC_DIFSEL_DIFSEL5_Msk = 0x20
	// Bit DIFSEL5.
	ADC_DIFSEL_DIFSEL5 = 0x20
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL5_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL5_Differential = 0x1
	// Position of DIFSEL6 field.
	ADC_DIFSEL_DIFSEL6_Pos = 0x6
	// Bit mask of DIFSEL6 field.
	ADC_DIFSEL_DIFSEL6_Msk = 0x40
	// Bit DIFSEL6.
	ADC_DIFSEL_DIFSEL6 = 0x40
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL6_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL6_Differential = 0x1
	// Position of DIFSEL7 field.
	ADC_DIFSEL_DIFSEL7_Pos = 0x7
	// Bit mask of DIFSEL7 field.
	ADC_DIFSEL_DIFSEL7_Msk = 0x80
	// Bit DIFSEL7.
	ADC_DIFSEL_DIFSEL7 = 0x80
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL7_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL7_Differential = 0x1
	// Position of DIFSEL8 field.
	ADC_DIFSEL_DIFSEL8_Pos = 0x8
	// Bit mask of DIFSEL8 field.
	ADC_DIFSEL_DIFSEL8_Msk = 0x100
	// Bit DIFSEL8.
	ADC_DIFSEL_DIFSEL8 = 0x100
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL8_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL8_Differential = 0x1
	// Position of DIFSEL9 field.
	ADC_DIFSEL_DIFSEL9_Pos = 0x9
	// Bit mask of DIFSEL9 field.
	ADC_DIFSEL_DIFSEL9_Msk = 0x200
	// Bit DIFSEL9.
	ADC_DIFSEL_DIFSEL9 = 0x200
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL9_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL9_Differential = 0x1
	// Position of DIFSEL10 field.
	ADC_DIFSEL_DIFSEL10_Pos = 0xa
	// Bit mask of DIFSEL10 field.
	ADC_DIFSEL_DIFSEL10_Msk = 0x400
	// Bit DIFSEL10.
	ADC_DIFSEL_DIFSEL10 = 0x400
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL10_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL10_Differential = 0x1
	// Position of DIFSEL11 field.
	ADC_DIFSEL_DIFSEL11_Pos = 0xb
	// Bit mask of DIFSEL11 field.
	ADC_DIFSEL_DIFSEL11_Msk = 0x800
	// Bit DIFSEL11.
	ADC_DIFSEL_DIFSEL11 = 0x800
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL11_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL11_Differential = 0x1
	// Position of DIFSEL12 field.
	ADC_DIFSEL_DIFSEL12_Pos = 0xc
	// Bit mask of DIFSEL12 field.
	ADC_DIFSEL_DIFSEL12_Msk = 0x1000
	// Bit DIFSEL12.
	ADC_DIFSEL_DIFSEL12 = 0x1000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL12_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL12_Differential = 0x1
	// Position of DIFSEL13 field.
	ADC_DIFSEL_DIFSEL13_Pos = 0xd
	// Bit mask of DIFSEL13 field.
	ADC_DIFSEL_DIFSEL13_Msk = 0x2000
	// Bit DIFSEL13.
	ADC_DIFSEL_DIFSEL13 = 0x2000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL13_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL13_Differential = 0x1
	// Position of DIFSEL14 field.
	ADC_DIFSEL_DIFSEL14_Pos = 0xe
	// Bit mask of DIFSEL14 field.
	ADC_DIFSEL_DIFSEL14_Msk = 0x4000
	// Bit DIFSEL14.
	ADC_DIFSEL_DIFSEL14 = 0x4000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL14_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL14_Differential = 0x1
	// Position of DIFSEL15 field.
	ADC_DIFSEL_DIFSEL15_Pos = 0xf
	// Bit mask of DIFSEL15 field.
	ADC_DIFSEL_DIFSEL15_Msk = 0x8000
	// Bit DIFSEL15.
	ADC_DIFSEL_DIFSEL15 = 0x8000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL15_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL15_Differential = 0x1
	// Position of DIFSEL16 field.
	ADC_DIFSEL_DIFSEL16_Pos = 0x10
	// Bit mask of DIFSEL16 field.
	ADC_DIFSEL_DIFSEL16_Msk = 0x10000
	// Bit DIFSEL16.
	ADC_DIFSEL_DIFSEL16 = 0x10000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL16_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL16_Differential = 0x1
	// Position of DIFSEL17 field.
	ADC_DIFSEL_DIFSEL17_Pos = 0x11
	// Bit mask of DIFSEL17 field.
	ADC_DIFSEL_DIFSEL17_Msk = 0x20000
	// Bit DIFSEL17.
	ADC_DIFSEL_DIFSEL17 = 0x20000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL17_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL17_Differential = 0x1
	// Position of DIFSEL18 field.
	ADC_DIFSEL_DIFSEL18_Pos = 0x12
	// Bit mask of DIFSEL18 field.
	ADC_DIFSEL_DIFSEL18_Msk = 0x40000
	// Bit DIFSEL18.
	ADC_DIFSEL_DIFSEL18 = 0x40000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL18_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL18_Differential = 0x1
	// Position of DIFSEL19 field.
	ADC_DIFSEL_DIFSEL19_Pos = 0x13
	// Bit mask of DIFSEL19 field.
	ADC_DIFSEL_DIFSEL19_Msk = 0x80000
	// Bit DIFSEL19.
	ADC_DIFSEL_DIFSEL19 = 0x80000
	// Input channel is configured in single-ended mode
	ADC_DIFSEL_DIFSEL19_SingleEnded = 0x0
	// Input channel is configured in differential mode
	ADC_DIFSEL_DIFSEL19_Differential = 0x1

	// CALFACT: ADC calibration factors register
	// Position of CALFACT_D field.
	ADC_CALFACT_CALFACT_D_Pos = 0x10
	// Bit mask of CALFACT_D field.
	ADC_CALFACT_CALFACT_D_Msk = 0x7ff0000
	// Position of CALFACT_S field.
	ADC_CALFACT_CALFACT_S_Pos = 0x0
	// Bit mask of CALFACT_S field.
	ADC_CALFACT_CALFACT_S_Msk = 0x7ff

	// CALFACT2: ADC Calibration Factor register 2
	// Position of LINCALFACT field.
	ADC_CALFACT2_LINCALFACT_Pos = 0x0
	// Bit mask of LINCALFACT field.
	ADC_CALFACT2_LINCALFACT_Msk = 0x3fffffff
)

// Constants for AXI: AXI interconnect registers
const (
	// PERIPH_ID_4: AXI interconnect - peripheral ID4 register
	// Position of JEP106CON field.
	AXI_PERIPH_ID_4_JEP106CON_Pos = 0x0
	// Bit mask of JEP106CON field.
	AXI_PERIPH_ID_4_JEP106CON_Msk = 0xf
	// Position of KCOUNT4 field.
	AXI_PERIPH_ID_4_KCOUNT4_Pos = 0x4
	// Bit mask of KCOUNT4 field.
	AXI_PERIPH_ID_4_KCOUNT4_Msk = 0xf0

	// PERIPH_ID_0: AXI interconnect - peripheral ID0 register
	// Position of PARTNUM field.
	AXI_PERIPH_ID_0_PARTNUM_Pos = 0x0
	// Bit mask of PARTNUM field.
	AXI_PERIPH_ID_0_PARTNUM_Msk = 0xff

	// PERIPH_ID_1: AXI interconnect - peripheral ID1 register
	// Position of PARTNUM field.
	AXI_PERIPH_ID_1_PARTNUM_Pos = 0x0
	// Bit mask of PARTNUM field.
	AXI_PERIPH_ID_1_PARTNUM_Msk = 0xf
	// Position of JEP106I field.
	AXI_PERIPH_ID_1_JEP106I_Pos = 0x4
	// Bit mask of JEP106I field.
	AXI_PERIPH_ID_1_JEP106I_Msk = 0xf0

	// PERIPH_ID_2: AXI interconnect - peripheral ID2 register
	// Position of JEP106ID field.
	AXI_PERIPH_ID_2_JEP106ID_Pos = 0x0
	// Bit mask of JEP106ID field.
	AXI_PERIPH_ID_2_JEP106ID_Msk = 0x7
	// Position of JEDEC field.
	AXI_PERIPH_ID_2_JEDEC_Pos = 0x3
	// Bit mask of JEDEC field.
	AXI_PERIPH_ID_2_JEDEC_Msk = 0x8
	// Bit JEDEC.
	AXI_PERIPH_ID_2_JEDEC = 0x8
	// Position of REVISION field.
	AXI_PERIPH_ID_2_REVISION_Pos = 0x4
	// Bit mask of REVISION field.
	AXI_PERIPH_ID_2_REVISION_Msk = 0xf0

	// PERIPH_ID_3: AXI interconnect - peripheral ID3 register
	// Position of CUST_MOD_NUM field.
	AXI_PERIPH_ID_3_CUST_MOD_NUM_Pos = 0x0
	// Bit mask of CUST_MOD_NUM field.
	AXI_PERIPH_ID_3_CUST_MOD_NUM_Msk = 0xf
	// Position of REV_AND field.
	AXI_PERIPH_ID_3_REV_AND_Pos = 0x4
	// Bit mask of REV_AND field.
	AXI_PERIPH_ID_3_REV_AND_Msk = 0xf0

	// COMP_ID_0: AXI interconnect - component ID0 register
	// Position of PREAMBLE field.
	AXI_COMP_ID_0_PREAMBLE_Pos = 0x0
	// Bit mask of PREAMBLE field.
	AXI_COMP_ID_0_PREAMBLE_Msk = 0xff

	// COMP_ID_1: AXI interconnect - component ID1 register
	// Position of PREAMBLE field.
	AXI_COMP_ID_1_PREAMBLE_Pos = 0x0
	// Bit mask of PREAMBLE field.
	AXI_COMP_ID_1_PREAMBLE_Msk = 0xf
	// Position of CLASS field.
	AXI_COMP_ID_1_CLASS_Pos = 0x4
	// Bit mask of CLASS field.
	AXI_COMP_ID_1_CLASS_Msk = 0xf0

	// COMP_ID_2: AXI interconnect - component ID2 register
	// Position of PREAMBLE field.
	AXI_COMP_ID_2_PREAMBLE_Pos = 0x0
	// Bit mask of PREAMBLE field.
	AXI_COMP_ID_2_PREAMBLE_Msk = 0xff

	// COMP_ID_3: AXI interconnect - component ID3 register
	// Position of PREAMBLE field.
	AXI_COMP_ID_3_PREAMBLE_Pos = 0x0
	// Bit mask of PREAMBLE field.
	AXI_COMP_ID_3_PREAMBLE_Msk = 0xff

	// TARG1_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG1_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
	// Position of BYPASS_MERGE field.
	AXI_TARG1_FN_MOD2_BYPASS_MERGE_Pos = 0x0
	// Bit mask of BYPASS_MERGE field.
	AXI_TARG1_FN_MOD2_BYPASS_MERGE_Msk = 0x1
	// Bit BYPASS_MERGE.
	AXI_TARG1_FN_MOD2_BYPASS_MERGE = 0x1

	// TARG1_FN_MOD_LB: AXI interconnect - TARG x long burst functionality modification
	// Position of FN_MOD_LB field.
	AXI_TARG1_FN_MOD_LB_FN_MOD_LB_Pos = 0x0
	// Bit mask of FN_MOD_LB field.
	AXI_TARG1_FN_MOD_LB_FN_MOD_LB_Msk = 0x1
	// Bit FN_MOD_LB.
	AXI_TARG1_FN_MOD_LB_FN_MOD_LB = 0x1

	// TARG1_FN_MOD: AXI interconnect - TARG x long burst functionality modification
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG1_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG1_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG1_FN_MOD_WRITE_ISS_OVERRIDE = 0x2

	// TARG2_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG2_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
	// Position of BYPASS_MERGE field.
	AXI_TARG2_FN_MOD2_BYPASS_MERGE_Pos = 0x0
	// Bit mask of BYPASS_MERGE field.
	AXI_TARG2_FN_MOD2_BYPASS_MERGE_Msk = 0x1
	// Bit BYPASS_MERGE.
	AXI_TARG2_FN_MOD2_BYPASS_MERGE = 0x1

	// TARG2_FN_MOD_LB: AXI interconnect - TARG x long burst functionality modification
	// Position of FN_MOD_LB field.
	AXI_TARG2_FN_MOD_LB_FN_MOD_LB_Pos = 0x0
	// Bit mask of FN_MOD_LB field.
	AXI_TARG2_FN_MOD_LB_FN_MOD_LB_Msk = 0x1
	// Bit FN_MOD_LB.
	AXI_TARG2_FN_MOD_LB_FN_MOD_LB = 0x1

	// TARG2_FN_MOD: AXI interconnect - TARG x long burst functionality modification
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG2_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG2_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG2_FN_MOD_WRITE_ISS_OVERRIDE = 0x2

	// TARG3_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG4_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG5_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG6_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG7_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2

	// TARG7_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
	// Position of BYPASS_MERGE field.
	AXI_TARG7_FN_MOD2_BYPASS_MERGE_Pos = 0x0
	// Bit mask of BYPASS_MERGE field.
	AXI_TARG7_FN_MOD2_BYPASS_MERGE_Msk = 0x1
	// Bit BYPASS_MERGE.
	AXI_TARG7_FN_MOD2_BYPASS_MERGE = 0x1

	// TARG7_FN_MOD: AXI interconnect - TARG x long burst functionality modification
	// Position of READ_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_TARG7_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_TARG7_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_TARG7_FN_MOD_WRITE_ISS_OVERRIDE = 0x2

	// INI1_FN_MOD2: AXI interconnect - INI x functionality modification 2 register
	// Position of BYPASS_MERGE field.
	AXI_INI1_FN_MOD2_BYPASS_MERGE_Pos = 0x0
	// Bit mask of BYPASS_MERGE field.
	AXI_INI1_FN_MOD2_BYPASS_MERGE_Msk = 0x1
	// Bit BYPASS_MERGE.
	AXI_INI1_FN_MOD2_BYPASS_MERGE = 0x1

	// INI1_FN_MOD_AHB: AXI interconnect - INI x AHB functionality modification register
	// Position of RD_INC_OVERRIDE field.
	AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE_Pos = 0x0
	// Bit mask of RD_INC_OVERRIDE field.
	AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE_Msk = 0x1
	// Bit RD_INC_OVERRIDE.
	AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE = 0x1
	// Position of WR_INC_OVERRIDE field.
	AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE_Pos = 0x1
	// Bit mask of WR_INC_OVERRIDE field.
	AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE_Msk = 0x2
	// Bit WR_INC_OVERRIDE.
	AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE = 0x2

	// INI1_READ_QOS: AXI interconnect - INI x read QoS register
	// Position of AR_QOS field.
	AXI_INI1_READ_QOS_AR_QOS_Pos = 0x0
	// Bit mask of AR_QOS field.
	AXI_INI1_READ_QOS_AR_QOS_Msk = 0xf

	// INI1_WRITE_QOS: AXI interconnect - INI x write QoS register
	// Position of AW_QOS field.
	AXI_INI1_WRITE_QOS_AW_QOS_Pos = 0x0
	// Bit mask of AW_QOS field.
	AXI_INI1_WRITE_QOS_AW_QOS_Msk = 0xf

	// INI1_FN_MOD: AXI interconnect - INI x issuing functionality modification register
	// Position of READ_ISS_OVERRIDE field.
	AXI_INI1_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_INI1_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_INI1_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Normal ASIB read issuing capability
	AXI_INI1_FN_MOD_READ_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB read issuing capability to 1
	AXI_INI1_FN_MOD_READ_ISS_OVERRIDE_Force1 = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE = 0x2
	// Normal ASIB write issuing capability
	AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB write issuing capability to 1
	AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE_Force1 = 0x1

	// INI2_READ_QOS: AXI interconnect - INI x read QoS register
	// Position of AR_QOS field.
	AXI_INI2_READ_QOS_AR_QOS_Pos = 0x0
	// Bit mask of AR_QOS field.
	AXI_INI2_READ_QOS_AR_QOS_Msk = 0xf

	// INI2_WRITE_QOS: AXI interconnect - INI x write QoS register
	// Position of AW_QOS field.
	AXI_INI2_WRITE_QOS_AW_QOS_Pos = 0x0
	// Bit mask of AW_QOS field.
	AXI_INI2_WRITE_QOS_AW_QOS_Msk = 0xf

	// INI2_FN_MOD: AXI interconnect - INI x issuing functionality modification register
	// Position of READ_ISS_OVERRIDE field.
	AXI_INI2_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_INI2_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_INI2_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Normal ASIB read issuing capability
	AXI_INI2_FN_MOD_READ_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB read issuing capability to 1
	AXI_INI2_FN_MOD_READ_ISS_OVERRIDE_Force1 = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE = 0x2
	// Normal ASIB write issuing capability
	AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB write issuing capability to 1
	AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE_Force1 = 0x1

	// INI3_FN_MOD2: AXI interconnect - INI x functionality modification 2 register
	// Position of BYPASS_MERGE field.
	AXI_INI3_FN_MOD2_BYPASS_MERGE_Pos = 0x0
	// Bit mask of BYPASS_MERGE field.
	AXI_INI3_FN_MOD2_BYPASS_MERGE_Msk = 0x1
	// Bit BYPASS_MERGE.
	AXI_INI3_FN_MOD2_BYPASS_MERGE = 0x1

	// INI3_FN_MOD_AHB: AXI interconnect - INI x AHB functionality modification register
	// Position of RD_INC_OVERRIDE field.
	AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE_Pos = 0x0
	// Bit mask of RD_INC_OVERRIDE field.
	AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE_Msk = 0x1
	// Bit RD_INC_OVERRIDE.
	AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE = 0x1
	// Position of WR_INC_OVERRIDE field.
	AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE_Pos = 0x1
	// Bit mask of WR_INC_OVERRIDE field.
	AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE_Msk = 0x2
	// Bit WR_INC_OVERRIDE.
	AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE = 0x2

	// INI3_READ_QOS: AXI interconnect - INI x read QoS register
	// Position of AR_QOS field.
	AXI_INI3_READ_QOS_AR_QOS_Pos = 0x0
	// Bit mask of AR_QOS field.
	AXI_INI3_READ_QOS_AR_QOS_Msk = 0xf

	// INI3_WRITE_QOS: AXI interconnect - INI x write QoS register
	// Position of AW_QOS field.
	AXI_INI3_WRITE_QOS_AW_QOS_Pos = 0x0
	// Bit mask of AW_QOS field.
	AXI_INI3_WRITE_QOS_AW_QOS_Msk = 0xf

	// INI3_FN_MOD: AXI interconnect - INI x issuing functionality modification register
	// Position of READ_ISS_OVERRIDE field.
	AXI_INI3_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_INI3_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_INI3_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Normal ASIB read issuing capability
	AXI_INI3_FN_MOD_READ_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB read issuing capability to 1
	AXI_INI3_FN_MOD_READ_ISS_OVERRIDE_Force1 = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE = 0x2
	// Normal ASIB write issuing capability
	AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB write issuing capability to 1
	AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE_Force1 = 0x1

	// INI4_READ_QOS: AXI interconnect - INI x read QoS register
	// Position of AR_QOS field.
	AXI_INI4_READ_QOS_AR_QOS_Pos = 0x0
	// Bit mask of AR_QOS field.
	AXI_INI4_READ_QOS_AR_QOS_Msk = 0xf

	// INI4_WRITE_QOS: AXI interconnect - INI x write QoS register
	// Position of AW_QOS field.
	AXI_INI4_WRITE_QOS_AW_QOS_Pos = 0x0
	// Bit mask of AW_QOS field.
	AXI_INI4_WRITE_QOS_AW_QOS_Msk = 0xf

	// INI4_FN_MOD: AXI interconnect - INI x issuing functionality modification register
	// Position of READ_ISS_OVERRIDE field.
	AXI_INI4_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_INI4_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_INI4_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Normal ASIB read issuing capability
	AXI_INI4_FN_MOD_READ_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB read issuing capability to 1
	AXI_INI4_FN_MOD_READ_ISS_OVERRIDE_Force1 = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE = 0x2
	// Normal ASIB write issuing capability
	AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB write issuing capability to 1
	AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE_Force1 = 0x1

	// INI5_READ_QOS: AXI interconnect - INI x read QoS register
	// Position of AR_QOS field.
	AXI_INI5_READ_QOS_AR_QOS_Pos = 0x0
	// Bit mask of AR_QOS field.
	AXI_INI5_READ_QOS_AR_QOS_Msk = 0xf

	// INI5_WRITE_QOS: AXI interconnect - INI x write QoS register
	// Position of AW_QOS field.
	AXI_INI5_WRITE_QOS_AW_QOS_Pos = 0x0
	// Bit mask of AW_QOS field.
	AXI_INI5_WRITE_QOS_AW_QOS_Msk = 0xf

	// INI5_FN_MOD: AXI interconnect - INI x issuing functionality modification register
	// Position of READ_ISS_OVERRIDE field.
	AXI_INI5_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_INI5_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_INI5_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Normal ASIB read issuing capability
	AXI_INI5_FN_MOD_READ_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB read issuing capability to 1
	AXI_INI5_FN_MOD_READ_ISS_OVERRIDE_Force1 = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE = 0x2
	// Normal ASIB write issuing capability
	AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB write issuing capability to 1
	AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE_Force1 = 0x1

	// INI6_READ_QOS: AXI interconnect - INI x read QoS register
	// Position of AR_QOS field.
	AXI_INI6_READ_QOS_AR_QOS_Pos = 0x0
	// Bit mask of AR_QOS field.
	AXI_INI6_READ_QOS_AR_QOS_Msk = 0xf

	// INI6_WRITE_QOS: AXI interconnect - INI x write QoS register
	// Position of AW_QOS field.
	AXI_INI6_WRITE_QOS_AW_QOS_Pos = 0x0
	// Bit mask of AW_QOS field.
	AXI_INI6_WRITE_QOS_AW_QOS_Msk = 0xf

	// INI6_FN_MOD: AXI interconnect - INI x issuing functionality modification register
	// Position of READ_ISS_OVERRIDE field.
	AXI_INI6_FN_MOD_READ_ISS_OVERRIDE_Pos = 0x0
	// Bit mask of READ_ISS_OVERRIDE field.
	AXI_INI6_FN_MOD_READ_ISS_OVERRIDE_Msk = 0x1
	// Bit READ_ISS_OVERRIDE.
	AXI_INI6_FN_MOD_READ_ISS_OVERRIDE = 0x1
	// Normal ASIB read issuing capability
	AXI_INI6_FN_MOD_READ_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB read issuing capability to 1
	AXI_INI6_FN_MOD_READ_ISS_OVERRIDE_Force1 = 0x1
	// Position of WRITE_ISS_OVERRIDE field.
	AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE_Pos = 0x1
	// Bit mask of WRITE_ISS_OVERRIDE field.
	AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE_Msk = 0x2
	// Bit WRITE_ISS_OVERRIDE.
	AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE = 0x2
	// Normal ASIB write issuing capability
	AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE_Normal = 0x0
	// Force ASIB write issuing capability to 1
	AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE_Force1 = 0x1
)

// Constants for CAN_CCU: CCU registers
const (
	// CREL: Clock Calibration Unit Core Release Register
	// Position of DAY field.
	FDCAN_CREL_DAY_Pos = 0x0
	// Bit mask of DAY field.
	FDCAN_CREL_DAY_Msk = 0xff
	// Position of MON field.
	FDCAN_CREL_MON_Pos = 0x8
	// Bit mask of MON field.
	FDCAN_CREL_MON_Msk = 0xff00
	// Position of YEAR field.
	FDCAN_CREL_YEAR_Pos = 0x10
	// Bit mask of YEAR field.
	FDCAN_CREL_YEAR_Msk = 0xf0000
	// Position of SUBSTEP field.
	FDCAN_CREL_SUBSTEP_Pos = 0x14
	// Bit mask of SUBSTEP field.
	FDCAN_CREL_SUBSTEP_Msk = 0xf00000
	// Position of STEP field.
	FDCAN_CREL_STEP_Pos = 0x18
	// Bit mask of STEP field.
	FDCAN_CREL_STEP_Msk = 0xf000000
	// Position of REL field.
	FDCAN_CREL_REL_Pos = 0x1c
	// Bit mask of REL field.
	FDCAN_CREL_REL_Msk = 0xf0000000

	// CCFG: Calibration Configuration Register
	// Position of TQBT field.
	FDCAN_CCFG_TQBT_Pos = 0x0
	// Bit mask of TQBT field.
	FDCAN_CCFG_TQBT_Msk = 0x1f
	// Position of BCC field.
	FDCAN_CCFG_BCC_Pos = 0x6
	// Bit mask of BCC field.
	FDCAN_CCFG_BCC_Msk = 0x40
	// Bit BCC.
	FDCAN_CCFG_BCC = 0x40
	// Position of CFL field.
	FDCAN_CCFG_CFL_Pos = 0x7
	// Bit mask of CFL field.
	FDCAN_CCFG_CFL_Msk = 0x80
	// Bit CFL.
	FDCAN_CCFG_CFL = 0x80
	// Position of OCPM field.
	FDCAN_CCFG_OCPM_Pos = 0x8
	// Bit mask of OCPM field.
	FDCAN_CCFG_OCPM_Msk = 0xff00
	// Position of CDIV field.
	FDCAN_CCFG_CDIV_Pos = 0x10
	// Bit mask of CDIV field.
	FDCAN_CCFG_CDIV_Msk = 0xf0000
	// Position of SWR field.
	FDCAN_CCFG_SWR_Pos = 0x1f
	// Bit mask of SWR field.
	FDCAN_CCFG_SWR_Msk = 0x80000000
	// Bit SWR.
	FDCAN_CCFG_SWR = 0x80000000

	// CSTAT: Calibration Status Register
	// Position of OCPC field.
	FDCAN_CSTAT_OCPC_Pos = 0x0
	// Bit mask of OCPC field.
	FDCAN_CSTAT_OCPC_Msk = 0x3ffff
	// Position of TQC field.
	FDCAN_CSTAT_TQC_Pos = 0x12
	// Bit mask of TQC field.
	FDCAN_CSTAT_TQC_Msk = 0x1ffc0000
	// Position of CALS field.
	FDCAN_CSTAT_CALS_Pos = 0x1e
	// Bit mask of CALS field.
	FDCAN_CSTAT_CALS_Msk = 0xc0000000

	// CWD: Calibration Watchdog Register
	// Position of WDC field.
	FDCAN_CWD_WDC_Pos = 0x0
	// Bit mask of WDC field.
	FDCAN_CWD_WDC_Msk = 0xffff
	// Position of WDV field.
	FDCAN_CWD_WDV_Pos = 0x10
	// Bit mask of WDV field.
	FDCAN_CWD_WDV_Msk = 0xffff0000

	// IR: Clock Calibration Unit Interrupt Register
	// Position of CWE field.
	FDCAN_IR_CWE_Pos = 0x0
	// Bit mask of CWE field.
	FDCAN_IR_CWE_Msk = 0x1
	// Bit CWE.
	FDCAN_IR_CWE = 0x1
	// Position of CSC field.
	FDCAN_IR_CSC_Pos = 0x1
	// Bit mask of CSC field.
	FDCAN_IR_CSC_Msk = 0x2
	// Bit CSC.
	FDCAN_IR_CSC = 0x2

	// IE: Clock Calibration Unit Interrupt Enable Register
	// Position of CWEE field.
	FDCAN_IE_CWEE_Pos = 0x0
	// Bit mask of CWEE field.
	FDCAN_IE_CWEE_Msk = 0x1
	// Bit CWEE.
	FDCAN_IE_CWEE = 0x1
	// Position of CSCE field.
	FDCAN_IE_CSCE_Pos = 0x1
	// Bit mask of CSCE field.
	FDCAN_IE_CSCE_Msk = 0x2
	// Bit CSCE.
	FDCAN_IE_CSCE = 0x2
)

// Constants for CEC: CEC
const (
	// CR: CEC control register
	// Position of CECEN field.
	CEC_CR_CECEN_Pos = 0x0
	// Bit mask of CECEN field.
	CEC_CR_CECEN_Msk = 0x1
	// Bit CECEN.
	CEC_CR_CECEN = 0x1
	// Position of TXSOM field.
	CEC_CR_TXSOM_Pos = 0x1
	// Bit mask of TXSOM field.
	CEC_CR_TXSOM_Msk = 0x2
	// Bit TXSOM.
	CEC_CR_TXSOM = 0x2
	// Position of TXEOM field.
	CEC_CR_TXEOM_Pos = 0x2
	// Bit mask of TXEOM field.
	CEC_CR_TXEOM_Msk = 0x4
	// Bit TXEOM.
	CEC_CR_TXEOM = 0x4

	// CFGR: This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
	// Position of SFT field.
	CEC_CFGR_SFT_Pos = 0x0
	// Bit mask of SFT field.
	CEC_CFGR_SFT_Msk = 0x7
	// Position of RXTOL field.
	CEC_CFGR_RXTOL_Pos = 0x3
	// Bit mask of RXTOL field.
	CEC_CFGR_RXTOL_Msk = 0x8
	// Bit RXTOL.
	CEC_CFGR_RXTOL = 0x8
	// Position of BRESTP field.
	CEC_CFGR_BRESTP_Pos = 0x4
	// Bit mask of BRESTP field.
	CEC_CFGR_BRESTP_Msk = 0x10
	// Bit BRESTP.
	CEC_CFGR_BRESTP = 0x10
	// Position of BREGEN field.
	CEC_CFGR_BREGEN_Pos = 0x5
	// Bit mask of BREGEN field.
	CEC_CFGR_BREGEN_Msk = 0x20
	// Bit BREGEN.
	CEC_CFGR_BREGEN = 0x20
	// Position of LBPEGEN field.
	CEC_CFGR_LBPEGEN_Pos = 0x6
	// Bit mask of LBPEGEN field.
	CEC_CFGR_LBPEGEN_Msk = 0x40
	// Bit LBPEGEN.
	CEC_CFGR_LBPEGEN = 0x40
	// Position of BRDNOGEN field.
	CEC_CFGR_BRDNOGEN_Pos = 0x7
	// Bit mask of BRDNOGEN field.
	CEC_CFGR_BRDNOGEN_Msk = 0x80
	// Bit BRDNOGEN.
	CEC_CFGR_BRDNOGEN = 0x80
	// Position of SFTOPT field.
	CEC_CFGR_SFTOPT_Pos = 0x8
	// Bit mask of SFTOPT field.
	CEC_CFGR_SFTOPT_Msk = 0x100
	// Bit SFTOPT.
	CEC_CFGR_SFTOPT = 0x100
	// Position of OAR field.
	CEC_CFGR_OAR_Pos = 0x10
	// Bit mask of OAR field.
	CEC_CFGR_OAR_Msk = 0x7fff0000
	// Position of LSTN field.
	CEC_CFGR_LSTN_Pos = 0x1f
	// Bit mask of LSTN field.
	CEC_CFGR_LSTN_Msk = 0x80000000
	// Bit LSTN.
	CEC_CFGR_LSTN = 0x80000000

	// TXDR: CEC Tx data register
	// Position of TXD field.
	CEC_TXDR_TXD_Pos = 0x0
	// Bit mask of TXD field.
	CEC_TXDR_TXD_Msk = 0xff

	// RXDR: CEC Rx Data Register
	// Position of RXD field.
	CEC_RXDR_RXD_Pos = 0x0
	// Bit mask of RXD field.
	CEC_RXDR_RXD_Msk = 0xff

	// ISR: CEC Interrupt and Status Register
	// Position of RXBR field.
	CEC_ISR_RXBR_Pos = 0x0
	// Bit mask of RXBR field.
	CEC_ISR_RXBR_Msk = 0x1
	// Bit RXBR.
	CEC_ISR_RXBR = 0x1
	// Position of RXEND field.
	CEC_ISR_RXEND_Pos = 0x1
	// Bit mask of RXEND field.
	CEC_ISR_RXEND_Msk = 0x2
	// Bit RXEND.
	CEC_ISR_RXEND = 0x2
	// Position of RXOVR field.
	CEC_ISR_RXOVR_Pos = 0x2
	// Bit mask of RXOVR field.
	CEC_ISR_RXOVR_Msk = 0x4
	// Bit RXOVR.
	CEC_ISR_RXOVR = 0x4
	// Position of BRE field.
	CEC_ISR_BRE_Pos = 0x3
	// Bit mask of BRE field.
	CEC_ISR_BRE_Msk = 0x8
	// Bit BRE.
	CEC_ISR_BRE = 0x8
	// Position of SBPE field.
	CEC_ISR_SBPE_Pos = 0x4
	// Bit mask of SBPE field.
	CEC_ISR_SBPE_Msk = 0x10
	// Bit SBPE.
	CEC_ISR_SBPE = 0x10
	// Position of LBPE field.
	CEC_ISR_LBPE_Pos = 0x5
	// Bit mask of LBPE field.
	CEC_ISR_LBPE_Msk = 0x20
	// Bit LBPE.
	CEC_ISR_LBPE = 0x20
	// Position of RXACKE field.
	CEC_ISR_RXACKE_Pos = 0x6
	// Bit mask of RXACKE field.
	CEC_ISR_RXACKE_Msk = 0x40
	// Bit RXACKE.
	CEC_ISR_RXACKE = 0x40
	// Position of ARBLST field.
	CEC_ISR_ARBLST_Pos = 0x7
	// Bit mask of ARBLST field.
	CEC_ISR_ARBLST_Msk = 0x80
	// Bit ARBLST.
	CEC_ISR_ARBLST = 0x80
	// Position of TXBR field.
	CEC_ISR_TXBR_Pos = 0x8
	// Bit mask of TXBR field.
	CEC_ISR_TXBR_Msk = 0x100
	// Bit TXBR.
	CEC_ISR_TXBR = 0x100
	// Position of TXEND field.
	CEC_ISR_TXEND_Pos = 0x9
	// Bit mask of TXEND field.
	CEC_ISR_TXEND_Msk = 0x200
	// Bit TXEND.
	CEC_ISR_TXEND = 0x200
	// Position of TXUDR field.
	CEC_ISR_TXUDR_Pos = 0xa
	// Bit mask of TXUDR field.
	CEC_ISR_TXUDR_Msk = 0x400
	// Bit TXUDR.
	CEC_ISR_TXUDR = 0x400
	// Position of TXERR field.
	CEC_ISR_TXERR_Pos = 0xb
	// Bit mask of TXERR field.
	CEC_ISR_TXERR_Msk = 0x800
	// Bit TXERR.
	CEC_ISR_TXERR = 0x800
	// Position of TXACKE field.
	CEC_ISR_TXACKE_Pos = 0xc
	// Bit mask of TXACKE field.
	CEC_ISR_TXACKE_Msk = 0x1000
	// Bit TXACKE.
	CEC_ISR_TXACKE = 0x1000

	// IER: CEC interrupt enable register
	// Position of RXBRIE field.
	CEC_IER_RXBRIE_Pos = 0x0
	// Bit mask of RXBRIE field.
	CEC_IER_RXBRIE_Msk = 0x1
	// Bit RXBRIE.
	CEC_IER_RXBRIE = 0x1
	// Position of RXENDIE field.
	CEC_IER_RXENDIE_Pos = 0x1
	// Bit mask of RXENDIE field.
	CEC_IER_RXENDIE_Msk = 0x2
	// Bit RXENDIE.
	CEC_IER_RXENDIE = 0x2
	// Position of RXOVRIE field.
	CEC_IER_RXOVRIE_Pos = 0x2
	// Bit mask of RXOVRIE field.
	CEC_IER_RXOVRIE_Msk = 0x4
	// Bit RXOVRIE.
	CEC_IER_RXOVRIE = 0x4
	// Position of BREIE field.
	CEC_IER_BREIE_Pos = 0x3
	// Bit mask of BREIE field.
	CEC_IER_BREIE_Msk = 0x8
	// Bit BREIE.
	CEC_IER_BREIE = 0x8
	// Position of SBPEIE field.
	CEC_IER_SBPEIE_Pos = 0x4
	// Bit mask of SBPEIE field.
	CEC_IER_SBPEIE_Msk = 0x10
	// Bit SBPEIE.
	CEC_IER_SBPEIE = 0x10
	// Position of LBPEIE field.
	CEC_IER_LBPEIE_Pos = 0x5
	// Bit mask of LBPEIE field.
	CEC_IER_LBPEIE_Msk = 0x20
	// Bit LBPEIE.
	CEC_IER_LBPEIE = 0x20
	// Position of RXACKIE field.
	CEC_IER_RXACKIE_Pos = 0x6
	// Bit mask of RXACKIE field.
	CEC_IER_RXACKIE_Msk = 0x40
	// Bit RXACKIE.
	CEC_IER_RXACKIE = 0x40
	// Position of ARBLSTIE field.
	CEC_IER_ARBLSTIE_Pos = 0x7
	// Bit mask of ARBLSTIE field.
	CEC_IER_ARBLSTIE_Msk = 0x80
	// Bit ARBLSTIE.
	CEC_IER_ARBLSTIE = 0x80
	// Position of TXBRIE field.
	CEC_IER_TXBRIE_Pos = 0x8
	// Bit mask of TXBRIE field.
	CEC_IER_TXBRIE_Msk = 0x100
	// Bit TXBRIE.
	CEC_IER_TXBRIE = 0x100
	// Position of TXENDIE field.
	CEC_IER_TXENDIE_Pos = 0x9
	// Bit mask of TXENDIE field.
	CEC_IER_TXENDIE_Msk = 0x200
	// Bit TXENDIE.
	CEC_IER_TXENDIE = 0x200
	// Position of TXUDRIE field.
	CEC_IER_TXUDRIE_Pos = 0xa
	// Bit mask of TXUDRIE field.
	CEC_IER_TXUDRIE_Msk = 0x400
	// Bit TXUDRIE.
	CEC_IER_TXUDRIE = 0x400
	// Position of TXERRIE field.
	CEC_IER_TXERRIE_Pos = 0xb
	// Bit mask of TXERRIE field.
	CEC_IER_TXERRIE_Msk = 0x800
	// Bit TXERRIE.
	CEC_IER_TXERRIE = 0x800
	// Position of TXACKIE field.
	CEC_IER_TXACKIE_Pos = 0xc
	// Bit mask of TXACKIE field.
	CEC_IER_TXACKIE_Msk = 0x1000
	// Bit TXACKIE.
	CEC_IER_TXACKIE = 0x1000
)

// Constants for COMP1: COMP1
const (
	// SR: Comparator status register
	// Position of C1VAL field.
	COMP1_SR_C1VAL_Pos = 0x0
	// Bit mask of C1VAL field.
	COMP1_SR_C1VAL_Msk = 0x1
	// Bit C1VAL.
	COMP1_SR_C1VAL = 0x1
	// Position of C2VAL field.
	COMP1_SR_C2VAL_Pos = 0x1
	// Bit mask of C2VAL field.
	COMP1_SR_C2VAL_Msk = 0x2
	// Bit C2VAL.
	COMP1_SR_C2VAL = 0x2
	// Position of C1IF field.
	COMP1_SR_C1IF_Pos = 0x10
	// Bit mask of C1IF field.
	COMP1_SR_C1IF_Msk = 0x10000
	// Bit C1IF.
	COMP1_SR_C1IF = 0x10000
	// Position of C2IF field.
	COMP1_SR_C2IF_Pos = 0x11
	// Bit mask of C2IF field.
	COMP1_SR_C2IF_Msk = 0x20000
	// Bit C2IF.
	COMP1_SR_C2IF = 0x20000

	// ICFR: Comparator interrupt clear flag register
	// Position of CC1IF field.
	COMP1_ICFR_CC1IF_Pos = 0x10
	// Bit mask of CC1IF field.
	COMP1_ICFR_CC1IF_Msk = 0x10000
	// Bit CC1IF.
	COMP1_ICFR_CC1IF = 0x10000
	// Position of CC2IF field.
	COMP1_ICFR_CC2IF_Pos = 0x11
	// Bit mask of CC2IF field.
	COMP1_ICFR_CC2IF_Msk = 0x20000
	// Bit CC2IF.
	COMP1_ICFR_CC2IF = 0x20000

	// OR: Comparator option register
	// Position of AFOP field.
	COMP1_OR_AFOP_Pos = 0x0
	// Bit mask of AFOP field.
	COMP1_OR_AFOP_Msk = 0x7ff
	// Position of OR field.
	COMP1_OR_OR_Pos = 0xb
	// Bit mask of OR field.
	COMP1_OR_OR_Msk = 0xfffff800

	// CFGR1: Comparator configuration register 1
	// Position of EN field.
	COMP1_CFGR1_EN_Pos = 0x0
	// Bit mask of EN field.
	COMP1_CFGR1_EN_Msk = 0x1
	// Bit EN.
	COMP1_CFGR1_EN = 0x1
	// Position of BRGEN field.
	COMP1_CFGR1_BRGEN_Pos = 0x1
	// Bit mask of BRGEN field.
	COMP1_CFGR1_BRGEN_Msk = 0x2
	// Bit BRGEN.
	COMP1_CFGR1_BRGEN = 0x2
	// Position of SCALEN field.
	COMP1_CFGR1_SCALEN_Pos = 0x2
	// Bit mask of SCALEN field.
	COMP1_CFGR1_SCALEN_Msk = 0x4
	// Bit SCALEN.
	COMP1_CFGR1_SCALEN = 0x4
	// Position of POLARITY field.
	COMP1_CFGR1_POLARITY_Pos = 0x3
	// Bit mask of POLARITY field.
	COMP1_CFGR1_POLARITY_Msk = 0x8
	// Bit POLARITY.
	COMP1_CFGR1_POLARITY = 0x8
	// Position of ITEN field.
	COMP1_CFGR1_ITEN_Pos = 0x6
	// Bit mask of ITEN field.
	COMP1_CFGR1_ITEN_Msk = 0x40
	// Bit ITEN.
	COMP1_CFGR1_ITEN = 0x40
	// Position of HYST field.
	COMP1_CFGR1_HYST_Pos = 0x8
	// Bit mask of HYST field.
	COMP1_CFGR1_HYST_Msk = 0x300
	// Position of PWRMODE field.
	COMP1_CFGR1_PWRMODE_Pos = 0xc
	// Bit mask of PWRMODE field.
	COMP1_CFGR1_PWRMODE_Msk = 0x3000
	// Position of INMSEL field.
	COMP1_CFGR1_INMSEL_Pos = 0x10
	// Bit mask of INMSEL field.
	COMP1_CFGR1_INMSEL_Msk = 0x70000
	// Position of INPSEL field.
	COMP1_CFGR1_INPSEL_Pos = 0x14
	// Bit mask of INPSEL field.
	COMP1_CFGR1_INPSEL_Msk = 0x100000
	// Bit INPSEL.
	COMP1_CFGR1_INPSEL = 0x100000
	// Position of BLANKING field.
	COMP1_CFGR1_BLANKING_Pos = 0x18
	// Bit mask of BLANKING field.
	COMP1_CFGR1_BLANKING_Msk = 0xf000000
	// Position of LOCK field.
	COMP1_CFGR1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	COMP1_CFGR1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	COMP1_CFGR1_LOCK = 0x80000000

	// CFGR2: Comparator configuration register 2
	// Position of EN field.
	COMP1_CFGR2_EN_Pos = 0x0
	// Bit mask of EN field.
	COMP1_CFGR2_EN_Msk = 0x1
	// Bit EN.
	COMP1_CFGR2_EN = 0x1
	// Position of BRGEN field.
	COMP1_CFGR2_BRGEN_Pos = 0x1
	// Bit mask of BRGEN field.
	COMP1_CFGR2_BRGEN_Msk = 0x2
	// Bit BRGEN.
	COMP1_CFGR2_BRGEN = 0x2
	// Position of SCALEN field.
	COMP1_CFGR2_SCALEN_Pos = 0x2
	// Bit mask of SCALEN field.
	COMP1_CFGR2_SCALEN_Msk = 0x4
	// Bit SCALEN.
	COMP1_CFGR2_SCALEN = 0x4
	// Position of POLARITY field.
	COMP1_CFGR2_POLARITY_Pos = 0x3
	// Bit mask of POLARITY field.
	COMP1_CFGR2_POLARITY_Msk = 0x8
	// Bit POLARITY.
	COMP1_CFGR2_POLARITY = 0x8
	// Position of WINMODE field.
	COMP1_CFGR2_WINMODE_Pos = 0x4
	// Bit mask of WINMODE field.
	COMP1_CFGR2_WINMODE_Msk = 0x10
	// Bit WINMODE.
	COMP1_CFGR2_WINMODE = 0x10
	// Position of ITEN field.
	COMP1_CFGR2_ITEN_Pos = 0x6
	// Bit mask of ITEN field.
	COMP1_CFGR2_ITEN_Msk = 0x40
	// Bit ITEN.
	COMP1_CFGR2_ITEN = 0x40
	// Position of HYST field.
	COMP1_CFGR2_HYST_Pos = 0x8
	// Bit mask of HYST field.
	COMP1_CFGR2_HYST_Msk = 0x300
	// Position of PWRMODE field.
	COMP1_CFGR2_PWRMODE_Pos = 0xc
	// Bit mask of PWRMODE field.
	COMP1_CFGR2_PWRMODE_Msk = 0x3000
	// Position of INMSEL field.
	COMP1_CFGR2_INMSEL_Pos = 0x10
	// Bit mask of INMSEL field.
	COMP1_CFGR2_INMSEL_Msk = 0x70000
	// Position of INPSEL field.
	COMP1_CFGR2_INPSEL_Pos = 0x14
	// Bit mask of INPSEL field.
	COMP1_CFGR2_INPSEL_Msk = 0x100000
	// Bit INPSEL.
	COMP1_CFGR2_INPSEL = 0x100000
	// Position of BLANKING field.
	COMP1_CFGR2_BLANKING_Pos = 0x18
	// Bit mask of BLANKING field.
	COMP1_CFGR2_BLANKING_Msk = 0xf000000
	// Position of LOCK field.
	COMP1_CFGR2_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	COMP1_CFGR2_LOCK_Msk = 0x80000000
	// Bit LOCK.
	COMP1_CFGR2_LOCK = 0x80000000
)

// Constants for CRC: Cryptographic processor
const (
	// DR: Data register
	// Position of DR field.
	CRC_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	CRC_DR_DR_Msk = 0xffffffff

	// DR8: Data register - byte sized
	// Position of DR8 field.
	CRC_DR8_DR8_Pos = 0x0
	// Bit mask of DR8 field.
	CRC_DR8_DR8_Msk = 0xff

	// DR16: Data register - half-word sized
	// Position of DR16 field.
	CRC_DR16_DR16_Pos = 0x0
	// Bit mask of DR16 field.
	CRC_DR16_DR16_Msk = 0xffff

	// IDR: Independent Data register
	// Position of IDR field.
	CRC_IDR_IDR_Pos = 0x0
	// Bit mask of IDR field.
	CRC_IDR_IDR_Msk = 0xffffffff

	// CR: Control register
	// Position of RESET field.
	CRC_CR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	CRC_CR_RESET_Msk = 0x1
	// Bit RESET.
	CRC_CR_RESET = 0x1
	// Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
	CRC_CR_RESET_Reset = 0x1
	// Position of POLYSIZE field.
	CRC_CR_POLYSIZE_Pos = 0x3
	// Bit mask of POLYSIZE field.
	CRC_CR_POLYSIZE_Msk = 0x18
	// 32-bit polynomial
	CRC_CR_POLYSIZE_Polysize32 = 0x0
	// 16-bit polynomial
	CRC_CR_POLYSIZE_Polysize16 = 0x1
	// 8-bit polynomial
	CRC_CR_POLYSIZE_Polysize8 = 0x2
	// 7-bit polynomial
	CRC_CR_POLYSIZE_Polysize7 = 0x3
	// Position of REV_IN field.
	CRC_CR_REV_IN_Pos = 0x5
	// Bit mask of REV_IN field.
	CRC_CR_REV_IN_Msk = 0x60
	// Bit order not affected
	CRC_CR_REV_IN_Normal = 0x0
	// Bit reversal done by byte
	CRC_CR_REV_IN_Byte = 0x1
	// Bit reversal done by half-word
	CRC_CR_REV_IN_HalfWord = 0x2
	// Bit reversal done by word
	CRC_CR_REV_IN_Word = 0x3
	// Position of REV_OUT field.
	CRC_CR_REV_OUT_Pos = 0x7
	// Bit mask of REV_OUT field.
	CRC_CR_REV_OUT_Msk = 0x80
	// Bit REV_OUT.
	CRC_CR_REV_OUT = 0x80
	// Bit order not affected
	CRC_CR_REV_OUT_Normal = 0x0
	// Bit reversed output
	CRC_CR_REV_OUT_Reversed = 0x1

	// INIT: Initial CRC value
	// Position of INIT field.
	CRC_INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	CRC_INIT_INIT_Msk = 0xffffffff

	// POL: CRC polynomial
	// Position of POL field.
	CRC_POL_POL_Pos = 0x0
	// Bit mask of POL field.
	CRC_POL_POL_Msk = 0xffffffff
)

// Constants for CRS: Clock Recovery System
const (
	// CR: CRS control register
	// Position of SYNCOKIE field.
	CRS_CR_SYNCOKIE_Pos = 0x0
	// Bit mask of SYNCOKIE field.
	CRS_CR_SYNCOKIE_Msk = 0x1
	// Bit SYNCOKIE.
	CRS_CR_SYNCOKIE = 0x1
	// Position of SYNCWARNIE field.
	CRS_CR_SYNCWARNIE_Pos = 0x1
	// Bit mask of SYNCWARNIE field.
	CRS_CR_SYNCWARNIE_Msk = 0x2
	// Bit SYNCWARNIE.
	CRS_CR_SYNCWARNIE = 0x2
	// Position of ERRIE field.
	CRS_CR_ERRIE_Pos = 0x2
	// Bit mask of ERRIE field.
	CRS_CR_ERRIE_Msk = 0x4
	// Bit ERRIE.
	CRS_CR_ERRIE = 0x4
	// Position of ESYNCIE field.
	CRS_CR_ESYNCIE_Pos = 0x3
	// Bit mask of ESYNCIE field.
	CRS_CR_ESYNCIE_Msk = 0x8
	// Bit ESYNCIE.
	CRS_CR_ESYNCIE = 0x8
	// Position of CEN field.
	CRS_CR_CEN_Pos = 0x5
	// Bit mask of CEN field.
	CRS_CR_CEN_Msk = 0x20
	// Bit CEN.
	CRS_CR_CEN = 0x20
	// Position of AUTOTRIMEN field.
	CRS_CR_AUTOTRIMEN_Pos = 0x6
	// Bit mask of AUTOTRIMEN field.
	CRS_CR_AUTOTRIMEN_Msk = 0x40
	// Bit AUTOTRIMEN.
	CRS_CR_AUTOTRIMEN = 0x40
	// Position of SWSYNC field.
	CRS_CR_SWSYNC_Pos = 0x7
	// Bit mask of SWSYNC field.
	CRS_CR_SWSYNC_Msk = 0x80
	// Bit SWSYNC.
	CRS_CR_SWSYNC = 0x80
	// Position of TRIM field.
	CRS_CR_TRIM_Pos = 0x8
	// Bit mask of TRIM field.
	CRS_CR_TRIM_Msk = 0x3f00

	// CFGR: This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
	// Position of RELOAD field.
	CRS_CFGR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	CRS_CFGR_RELOAD_Msk = 0xffff
	// Position of FELIM field.
	CRS_CFGR_FELIM_Pos = 0x10
	// Bit mask of FELIM field.
	CRS_CFGR_FELIM_Msk = 0xff0000
	// Position of SYNCDIV field.
	CRS_CFGR_SYNCDIV_Pos = 0x18
	// Bit mask of SYNCDIV field.
	CRS_CFGR_SYNCDIV_Msk = 0x7000000
	// Position of SYNCSRC field.
	CRS_CFGR_SYNCSRC_Pos = 0x1c
	// Bit mask of SYNCSRC field.
	CRS_CFGR_SYNCSRC_Msk = 0x30000000
	// Position of SYNCPOL field.
	CRS_CFGR_SYNCPOL_Pos = 0x1f
	// Bit mask of SYNCPOL field.
	CRS_CFGR_SYNCPOL_Msk = 0x80000000
	// Bit SYNCPOL.
	CRS_CFGR_SYNCPOL = 0x80000000

	// ISR: CRS interrupt and status register
	// Position of SYNCOKF field.
	CRS_ISR_SYNCOKF_Pos = 0x0
	// Bit mask of SYNCOKF field.
	CRS_ISR_SYNCOKF_Msk = 0x1
	// Bit SYNCOKF.
	CRS_ISR_SYNCOKF = 0x1
	// Position of SYNCWARNF field.
	CRS_ISR_SYNCWARNF_Pos = 0x1
	// Bit mask of SYNCWARNF field.
	CRS_ISR_SYNCWARNF_Msk = 0x2
	// Bit SYNCWARNF.
	CRS_ISR_SYNCWARNF = 0x2
	// Position of ERRF field.
	CRS_ISR_ERRF_Pos = 0x2
	// Bit mask of ERRF field.
	CRS_ISR_ERRF_Msk = 0x4
	// Bit ERRF.
	CRS_ISR_ERRF = 0x4
	// Position of ESYNCF field.
	CRS_ISR_ESYNCF_Pos = 0x3
	// Bit mask of ESYNCF field.
	CRS_ISR_ESYNCF_Msk = 0x8
	// Bit ESYNCF.
	CRS_ISR_ESYNCF = 0x8
	// Position of SYNCERR field.
	CRS_ISR_SYNCERR_Pos = 0x8
	// Bit mask of SYNCERR field.
	CRS_ISR_SYNCERR_Msk = 0x100
	// Bit SYNCERR.
	CRS_ISR_SYNCERR = 0x100
	// Position of SYNCMISS field.
	CRS_ISR_SYNCMISS_Pos = 0x9
	// Bit mask of SYNCMISS field.
	CRS_ISR_SYNCMISS_Msk = 0x200
	// Bit SYNCMISS.
	CRS_ISR_SYNCMISS = 0x200
	// Position of TRIMOVF field.
	CRS_ISR_TRIMOVF_Pos = 0xa
	// Bit mask of TRIMOVF field.
	CRS_ISR_TRIMOVF_Msk = 0x400
	// Bit TRIMOVF.
	CRS_ISR_TRIMOVF = 0x400
	// Position of FEDIR field.
	CRS_ISR_FEDIR_Pos = 0xf
	// Bit mask of FEDIR field.
	CRS_ISR_FEDIR_Msk = 0x8000
	// Bit FEDIR.
	CRS_ISR_FEDIR = 0x8000
	// Position of FECAP field.
	CRS_ISR_FECAP_Pos = 0x10
	// Bit mask of FECAP field.
	CRS_ISR_FECAP_Msk = 0xffff0000

	// ICR: CRS interrupt flag clear register
	// Position of SYNCOKC field.
	CRS_ICR_SYNCOKC_Pos = 0x0
	// Bit mask of SYNCOKC field.
	CRS_ICR_SYNCOKC_Msk = 0x1
	// Bit SYNCOKC.
	CRS_ICR_SYNCOKC = 0x1
	// Position of SYNCWARNC field.
	CRS_ICR_SYNCWARNC_Pos = 0x1
	// Bit mask of SYNCWARNC field.
	CRS_ICR_SYNCWARNC_Msk = 0x2
	// Bit SYNCWARNC.
	CRS_ICR_SYNCWARNC = 0x2
	// Position of ERRC field.
	CRS_ICR_ERRC_Pos = 0x2
	// Bit mask of ERRC field.
	CRS_ICR_ERRC_Msk = 0x4
	// Bit ERRC.
	CRS_ICR_ERRC = 0x4
	// Position of ESYNCC field.
	CRS_ICR_ESYNCC_Pos = 0x3
	// Bit mask of ESYNCC field.
	CRS_ICR_ESYNCC_Msk = 0x8
	// Bit ESYNCC.
	CRS_ICR_ESYNCC = 0x8
)

// Constants for CRYP: Cryptographic processor
const (
	// CR: control register
	// Position of ALGODIR field.
	CRYP_CR_ALGODIR_Pos = 0x2
	// Bit mask of ALGODIR field.
	CRYP_CR_ALGODIR_Msk = 0x4
	// Bit ALGODIR.
	CRYP_CR_ALGODIR = 0x4
	// Position of ALGOMODE0 field.
	CRYP_CR_ALGOMODE0_Pos = 0x3
	// Bit mask of ALGOMODE0 field.
	CRYP_CR_ALGOMODE0_Msk = 0x38
	// Position of DATATYPE field.
	CRYP_CR_DATATYPE_Pos = 0x6
	// Bit mask of DATATYPE field.
	CRYP_CR_DATATYPE_Msk = 0xc0
	// Position of KEYSIZE field.
	CRYP_CR_KEYSIZE_Pos = 0x8
	// Bit mask of KEYSIZE field.
	CRYP_CR_KEYSIZE_Msk = 0x300
	// Position of FFLUSH field.
	CRYP_CR_FFLUSH_Pos = 0xe
	// Bit mask of FFLUSH field.
	CRYP_CR_FFLUSH_Msk = 0x4000
	// Bit FFLUSH.
	CRYP_CR_FFLUSH = 0x4000
	// Position of CRYPEN field.
	CRYP_CR_CRYPEN_Pos = 0xf
	// Bit mask of CRYPEN field.
	CRYP_CR_CRYPEN_Msk = 0x8000
	// Bit CRYPEN.
	CRYP_CR_CRYPEN = 0x8000
	// Position of GCM_CCMPH field.
	CRYP_CR_GCM_CCMPH_Pos = 0x10
	// Bit mask of GCM_CCMPH field.
	CRYP_CR_GCM_CCMPH_Msk = 0x30000
	// Position of ALGOMODE3 field.
	CRYP_CR_ALGOMODE3_Pos = 0x13
	// Bit mask of ALGOMODE3 field.
	CRYP_CR_ALGOMODE3_Msk = 0x80000
	// Bit ALGOMODE3.
	CRYP_CR_ALGOMODE3 = 0x80000

	// SR: status register
	// Position of BUSY field.
	CRYP_SR_BUSY_Pos = 0x4
	// Bit mask of BUSY field.
	CRYP_SR_BUSY_Msk = 0x10
	// Bit BUSY.
	CRYP_SR_BUSY = 0x10
	// Position of OFFU field.
	CRYP_SR_OFFU_Pos = 0x3
	// Bit mask of OFFU field.
	CRYP_SR_OFFU_Msk = 0x8
	// Bit OFFU.
	CRYP_SR_OFFU = 0x8
	// Position of OFNE field.
	CRYP_SR_OFNE_Pos = 0x2
	// Bit mask of OFNE field.
	CRYP_SR_OFNE_Msk = 0x4
	// Bit OFNE.
	CRYP_SR_OFNE = 0x4
	// Position of IFNF field.
	CRYP_SR_IFNF_Pos = 0x1
	// Bit mask of IFNF field.
	CRYP_SR_IFNF_Msk = 0x2
	// Bit IFNF.
	CRYP_SR_IFNF = 0x2
	// Position of IFEM field.
	CRYP_SR_IFEM_Pos = 0x0
	// Bit mask of IFEM field.
	CRYP_SR_IFEM_Msk = 0x1
	// Bit IFEM.
	CRYP_SR_IFEM = 0x1

	// DIN: data input register
	// Position of DATAIN field.
	CRYP_DIN_DATAIN_Pos = 0x0
	// Bit mask of DATAIN field.
	CRYP_DIN_DATAIN_Msk = 0xffffffff

	// DOUT: data output register
	// Position of DATAOUT field.
	CRYP_DOUT_DATAOUT_Pos = 0x0
	// Bit mask of DATAOUT field.
	CRYP_DOUT_DATAOUT_Msk = 0xffffffff

	// DMACR: DMA control register
	// Position of DOEN field.
	CRYP_DMACR_DOEN_Pos = 0x1
	// Bit mask of DOEN field.
	CRYP_DMACR_DOEN_Msk = 0x2
	// Bit DOEN.
	CRYP_DMACR_DOEN = 0x2
	// Position of DIEN field.
	CRYP_DMACR_DIEN_Pos = 0x0
	// Bit mask of DIEN field.
	CRYP_DMACR_DIEN_Msk = 0x1
	// Bit DIEN.
	CRYP_DMACR_DIEN = 0x1

	// IMSCR: interrupt mask set/clear register
	// Position of OUTIM field.
	CRYP_IMSCR_OUTIM_Pos = 0x1
	// Bit mask of OUTIM field.
	CRYP_IMSCR_OUTIM_Msk = 0x2
	// Bit OUTIM.
	CRYP_IMSCR_OUTIM = 0x2
	// Position of INIM field.
	CRYP_IMSCR_INIM_Pos = 0x0
	// Bit mask of INIM field.
	CRYP_IMSCR_INIM_Msk = 0x1
	// Bit INIM.
	CRYP_IMSCR_INIM = 0x1

	// RISR: raw interrupt status register
	// Position of OUTRIS field.
	CRYP_RISR_OUTRIS_Pos = 0x1
	// Bit mask of OUTRIS field.
	CRYP_RISR_OUTRIS_Msk = 0x2
	// Bit OUTRIS.
	CRYP_RISR_OUTRIS = 0x2
	// Position of INRIS field.
	CRYP_RISR_INRIS_Pos = 0x0
	// Bit mask of INRIS field.
	CRYP_RISR_INRIS_Msk = 0x1
	// Bit INRIS.
	CRYP_RISR_INRIS = 0x1

	// MISR: masked interrupt status register
	// Position of OUTMIS field.
	CRYP_MISR_OUTMIS_Pos = 0x1
	// Bit mask of OUTMIS field.
	CRYP_MISR_OUTMIS_Msk = 0x2
	// Bit OUTMIS.
	CRYP_MISR_OUTMIS = 0x2
	// Position of INMIS field.
	CRYP_MISR_INMIS_Pos = 0x0
	// Bit mask of INMIS field.
	CRYP_MISR_INMIS_Msk = 0x1
	// Bit INMIS.
	CRYP_MISR_INMIS = 0x1

	// K0LR: key registers
	// Position of K2 field.
	CRYP_K0LR_K2_Pos = 0x0
	// Bit mask of K2 field.
	CRYP_K0LR_K2_Msk = 0xffffffff

	// K0RR: key registers
	// Position of K field.
	CRYP_K0RR_K_Pos = 0x0
	// Bit mask of K field.
	CRYP_K0RR_K_Msk = 0xffffffff

	// K1LR: key registers
	// Position of K1 field.
	CRYP_K1LR_K1_Pos = 0x0
	// Bit mask of K1 field.
	CRYP_K1LR_K1_Msk = 0xffffffff

	// K1RR: key registers
	// Position of K1 field.
	CRYP_K1RR_K1_Pos = 0x0
	// Bit mask of K1 field.
	CRYP_K1RR_K1_Msk = 0xffffffff

	// K2LR: key registers
	// Position of B121 field.
	CRYP_K2LR_B121_Pos = 0x19
	// Bit mask of B121 field.
	CRYP_K2LR_B121_Msk = 0x2000000
	// Bit B121.
	CRYP_K2LR_B121 = 0x2000000
	// Position of K field.
	CRYP_K2LR_K_Pos = 0x0
	// Bit mask of K field.
	CRYP_K2LR_K_Msk = 0x7fffffff

	// K2RR: key registers
	// Position of K field.
	CRYP_K2RR_K_Pos = 0x0
	// Bit mask of K field.
	CRYP_K2RR_K_Msk = 0xffffffff

	// K3LR: key registers
	// Position of K field.
	CRYP_K3LR_K_Pos = 0x0
	// Bit mask of K field.
	CRYP_K3LR_K_Msk = 0xffffffff

	// K3RR: key registers
	// Position of K field.
	CRYP_K3RR_K_Pos = 0x0
	// Bit mask of K field.
	CRYP_K3RR_K_Msk = 0xffffffff

	// IV0LR: Initialization vector register 0L
	// Position of IV field.
	CRYP_IV0LR_IV_Pos = 0x0
	// Bit mask of IV field.
	CRYP_IV0LR_IV_Msk = 0xffffffff

	// IV0RR: initialization vector register 0R
	// Position of IV field.
	CRYP_IV0RR_IV_Pos = 0x0
	// Bit mask of IV field.
	CRYP_IV0RR_IV_Msk = 0xffffffff

	// IV1LR: Initialization vector register 1L
	// Position of IV field.
	CRYP_IV1LR_IV_Pos = 0x0
	// Bit mask of IV field.
	CRYP_IV1LR_IV_Msk = 0xffffffff

	// IV1RR: Initialization vector register 1R
	// Position of IV field.
	CRYP_IV1RR_IV_Pos = 0x0
	// Bit mask of IV field.
	CRYP_IV1RR_IV_Msk = 0xffffffff

	// CSGCMCCM0R: context swap register
	// Position of CSGCMCCM0R field.
	CRYP_CSGCMCCM0R_CSGCMCCM0R_Pos = 0x0
	// Bit mask of CSGCMCCM0R field.
	CRYP_CSGCMCCM0R_CSGCMCCM0R_Msk = 0xffffffff

	// CSGCMCCM1R: context swap register
	// Position of CSGCMCCM1R field.
	CRYP_CSGCMCCM1R_CSGCMCCM1R_Pos = 0x0
	// Bit mask of CSGCMCCM1R field.
	CRYP_CSGCMCCM1R_CSGCMCCM1R_Msk = 0xffffffff

	// CSGCMCCM2R: context swap register
	// Position of CSGCMCCM2R field.
	CRYP_CSGCMCCM2R_CSGCMCCM2R_Pos = 0x0
	// Bit mask of CSGCMCCM2R field.
	CRYP_CSGCMCCM2R_CSGCMCCM2R_Msk = 0xffffffff

	// CSGCMCCM3R: context swap register
	// Position of CSGCMCCM3R field.
	CRYP_CSGCMCCM3R_CSGCMCCM3R_Pos = 0x0
	// Bit mask of CSGCMCCM3R field.
	CRYP_CSGCMCCM3R_CSGCMCCM3R_Msk = 0xffffffff

	// CSGCMCCM4R: context swap register
	// Position of CSGCMCCM4R field.
	CRYP_CSGCMCCM4R_CSGCMCCM4R_Pos = 0x0
	// Bit mask of CSGCMCCM4R field.
	CRYP_CSGCMCCM4R_CSGCMCCM4R_Msk = 0xffffffff

	// CSGCMCCM5R: context swap register
	// Position of CSGCMCCM5R field.
	CRYP_CSGCMCCM5R_CSGCMCCM5R_Pos = 0x0
	// Bit mask of CSGCMCCM5R field.
	CRYP_CSGCMCCM5R_CSGCMCCM5R_Msk = 0xffffffff

	// CSGCMCCM6R: context swap register
	// Position of CSGCMCCM6R field.
	CRYP_CSGCMCCM6R_CSGCMCCM6R_Pos = 0x0
	// Bit mask of CSGCMCCM6R field.
	CRYP_CSGCMCCM6R_CSGCMCCM6R_Msk = 0xffffffff

	// CSGCMCCM7R: context swap register
	// Position of CSGCMCCM7R field.
	CRYP_CSGCMCCM7R_CSGCMCCM7R_Pos = 0x0
	// Bit mask of CSGCMCCM7R field.
	CRYP_CSGCMCCM7R_CSGCMCCM7R_Msk = 0xffffffff

	// CSGCM0R: context swap register
	// Position of CSGCM0R field.
	CRYP_CSGCM0R_CSGCM0R_Pos = 0x0
	// Bit mask of CSGCM0R field.
	CRYP_CSGCM0R_CSGCM0R_Msk = 0xffffffff

	// CSGCM1R: context swap register
	// Position of CSGCM1R field.
	CRYP_CSGCM1R_CSGCM1R_Pos = 0x0
	// Bit mask of CSGCM1R field.
	CRYP_CSGCM1R_CSGCM1R_Msk = 0xffffffff

	// CSGCM2R: context swap register
	// Position of CSGCM2R field.
	CRYP_CSGCM2R_CSGCM2R_Pos = 0x0
	// Bit mask of CSGCM2R field.
	CRYP_CSGCM2R_CSGCM2R_Msk = 0xffffffff

	// CSGCM3R: context swap register
	// Position of CSGCM3R field.
	CRYP_CSGCM3R_CSGCM3R_Pos = 0x0
	// Bit mask of CSGCM3R field.
	CRYP_CSGCM3R_CSGCM3R_Msk = 0xffffffff

	// CSGCM4R: context swap register
	// Position of CSGCM4R field.
	CRYP_CSGCM4R_CSGCM4R_Pos = 0x0
	// Bit mask of CSGCM4R field.
	CRYP_CSGCM4R_CSGCM4R_Msk = 0xffffffff

	// CSGCM5R: context swap register
	// Position of CSGCM5R field.
	CRYP_CSGCM5R_CSGCM5R_Pos = 0x0
	// Bit mask of CSGCM5R field.
	CRYP_CSGCM5R_CSGCM5R_Msk = 0xffffffff

	// CSGCM6R: context swap register
	// Position of CSGCM6R field.
	CRYP_CSGCM6R_CSGCM6R_Pos = 0x0
	// Bit mask of CSGCM6R field.
	CRYP_CSGCM6R_CSGCM6R_Msk = 0xffffffff

	// CSGCM7R: context swap register
	// Position of CSGCM7R field.
	CRYP_CSGCM7R_CSGCM7R_Pos = 0x0
	// Bit mask of CSGCM7R field.
	CRYP_CSGCM7R_CSGCM7R_Msk = 0xffffffff
)

// Constants for DAC: DAC
const (
	// CR: DAC control register
	// Position of EN1 field.
	DAC_CR_EN1_Pos = 0x0
	// Bit mask of EN1 field.
	DAC_CR_EN1_Msk = 0x1
	// Bit EN1.
	DAC_CR_EN1 = 0x1
	// Position of TEN1 field.
	DAC_CR_TEN1_Pos = 0x1
	// Bit mask of TEN1 field.
	DAC_CR_TEN1_Msk = 0x2
	// Bit TEN1.
	DAC_CR_TEN1 = 0x2
	// Position of TSEL1 field.
	DAC_CR_TSEL1_Pos = 0x2
	// Bit mask of TSEL1 field.
	DAC_CR_TSEL1_Msk = 0x1c
	// Position of WAVE1 field.
	DAC_CR_WAVE1_Pos = 0x6
	// Bit mask of WAVE1 field.
	DAC_CR_WAVE1_Msk = 0xc0
	// Position of MAMP1 field.
	DAC_CR_MAMP1_Pos = 0x8
	// Bit mask of MAMP1 field.
	DAC_CR_MAMP1_Msk = 0xf00
	// Position of DMAEN1 field.
	DAC_CR_DMAEN1_Pos = 0xc
	// Bit mask of DMAEN1 field.
	DAC_CR_DMAEN1_Msk = 0x1000
	// Bit DMAEN1.
	DAC_CR_DMAEN1 = 0x1000
	// Position of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Pos = 0xd
	// Bit mask of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Msk = 0x2000
	// Bit DMAUDRIE1.
	DAC_CR_DMAUDRIE1 = 0x2000
	// Position of CEN1 field.
	DAC_CR_CEN1_Pos = 0xe
	// Bit mask of CEN1 field.
	DAC_CR_CEN1_Msk = 0x4000
	// Bit CEN1.
	DAC_CR_CEN1 = 0x4000
	// Position of EN2 field.
	DAC_CR_EN2_Pos = 0x10
	// Bit mask of EN2 field.
	DAC_CR_EN2_Msk = 0x10000
	// Bit EN2.
	DAC_CR_EN2 = 0x10000
	// Position of TEN2 field.
	DAC_CR_TEN2_Pos = 0x11
	// Bit mask of TEN2 field.
	DAC_CR_TEN2_Msk = 0x20000
	// Bit TEN2.
	DAC_CR_TEN2 = 0x20000
	// Position of TSEL2 field.
	DAC_CR_TSEL2_Pos = 0x12
	// Bit mask of TSEL2 field.
	DAC_CR_TSEL2_Msk = 0x1c0000
	// Position of WAVE2 field.
	DAC_CR_WAVE2_Pos = 0x16
	// Bit mask of WAVE2 field.
	DAC_CR_WAVE2_Msk = 0xc00000
	// Position of MAMP2 field.
	DAC_CR_MAMP2_Pos = 0x18
	// Bit mask of MAMP2 field.
	DAC_CR_MAMP2_Msk = 0xf000000
	// Position of DMAEN2 field.
	DAC_CR_DMAEN2_Pos = 0x1c
	// Bit mask of DMAEN2 field.
	DAC_CR_DMAEN2_Msk = 0x10000000
	// Bit DMAEN2.
	DAC_CR_DMAEN2 = 0x10000000
	// Position of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Pos = 0x1d
	// Bit mask of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Msk = 0x20000000
	// Bit DMAUDRIE2.
	DAC_CR_DMAUDRIE2 = 0x20000000
	// Position of CEN2 field.
	DAC_CR_CEN2_Pos = 0x1e
	// Bit mask of CEN2 field.
	DAC_CR_CEN2_Msk = 0x40000000
	// Bit CEN2.
	DAC_CR_CEN2 = 0x40000000

	// SWTRGR: DAC software trigger register
	// Position of SWTRIG1 field.
	DAC_SWTRGR_SWTRIG1_Pos = 0x0
	// Bit mask of SWTRIG1 field.
	DAC_SWTRGR_SWTRIG1_Msk = 0x1
	// Bit SWTRIG1.
	DAC_SWTRGR_SWTRIG1 = 0x1
	// Position of SWTRIG2 field.
	DAC_SWTRGR_SWTRIG2_Pos = 0x1
	// Bit mask of SWTRIG2 field.
	DAC_SWTRGR_SWTRIG2_Msk = 0x2
	// Bit SWTRIG2.
	DAC_SWTRGR_SWTRIG2 = 0x2

	// DHR12R1: DAC channel1 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Msk = 0xfff

	// DHR12L1: DAC channel1 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Msk = 0xfff0

	// DHR8R1: DAC channel1 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Msk = 0xff

	// DHR12R2: DAC channel2 12-bit right aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Msk = 0xfff

	// DHR12L2: DAC channel2 12-bit left aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Pos = 0x4
	// Bit mask of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Msk = 0xfff0

	// DHR8R2: DAC channel2 8-bit right-aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Msk = 0xff

	// DHR12RD: Dual DAC 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Msk = 0xfff
	// Position of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Pos = 0x10
	// Bit mask of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Msk = 0xfff0000

	// DHR12LD: DUAL DAC 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Msk = 0xfff0
	// Position of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Pos = 0x14
	// Bit mask of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Msk = 0xfff00000

	// DHR8RD: DUAL DAC 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Msk = 0xff
	// Position of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Pos = 0x8
	// Bit mask of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Msk = 0xff00

	// DOR1: DAC channel1 data output register
	// Position of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Pos = 0x0
	// Bit mask of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Msk = 0xfff

	// DOR2: DAC channel2 data output register
	// Position of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Pos = 0x0
	// Bit mask of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Msk = 0xfff

	// SR: DAC status register
	// Position of DMAUDR1 field.
	DAC_SR_DMAUDR1_Pos = 0xd
	// Bit mask of DMAUDR1 field.
	DAC_SR_DMAUDR1_Msk = 0x2000
	// Bit DMAUDR1.
	DAC_SR_DMAUDR1 = 0x2000
	// Position of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Pos = 0xe
	// Bit mask of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Msk = 0x4000
	// Bit CAL_FLAG1.
	DAC_SR_CAL_FLAG1 = 0x4000
	// Position of BWST1 field.
	DAC_SR_BWST1_Pos = 0xf
	// Bit mask of BWST1 field.
	DAC_SR_BWST1_Msk = 0x8000
	// Bit BWST1.
	DAC_SR_BWST1 = 0x8000
	// Position of DMAUDR2 field.
	DAC_SR_DMAUDR2_Pos = 0x1d
	// Bit mask of DMAUDR2 field.
	DAC_SR_DMAUDR2_Msk = 0x20000000
	// Bit DMAUDR2.
	DAC_SR_DMAUDR2 = 0x20000000
	// Position of CAL_FLAG2 field.
	DAC_SR_CAL_FLAG2_Pos = 0x1e
	// Bit mask of CAL_FLAG2 field.
	DAC_SR_CAL_FLAG2_Msk = 0x40000000
	// Bit CAL_FLAG2.
	DAC_SR_CAL_FLAG2 = 0x40000000
	// Position of BWST2 field.
	DAC_SR_BWST2_Pos = 0x1f
	// Bit mask of BWST2 field.
	DAC_SR_BWST2_Msk = 0x80000000
	// Bit BWST2.
	DAC_SR_BWST2 = 0x80000000

	// CCR: DAC calibration control register
	// Position of OTRIM1 field.
	DAC_CCR_OTRIM1_Pos = 0x0
	// Bit mask of OTRIM1 field.
	DAC_CCR_OTRIM1_Msk = 0x1f
	// Position of OTRIM2 field.
	DAC_CCR_OTRIM2_Pos = 0x10
	// Bit mask of OTRIM2 field.
	DAC_CCR_OTRIM2_Msk = 0x1f0000

	// MCR: DAC mode control register
	// Position of MODE1 field.
	DAC_MCR_MODE1_Pos = 0x0
	// Bit mask of MODE1 field.
	DAC_MCR_MODE1_Msk = 0x7
	// Position of MODE2 field.
	DAC_MCR_MODE2_Pos = 0x10
	// Bit mask of MODE2 field.
	DAC_MCR_MODE2_Msk = 0x70000

	// SHSR1: DAC Sample and Hold sample time register 1
	// Position of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Pos = 0x0
	// Bit mask of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Msk = 0x3ff

	// SHSR2: DAC Sample and Hold sample time register 2
	// Position of TSAMPLE2 field.
	DAC_SHSR2_TSAMPLE2_Pos = 0x0
	// Bit mask of TSAMPLE2 field.
	DAC_SHSR2_TSAMPLE2_Msk = 0x3ff

	// SHHR: DAC Sample and Hold hold time register
	// Position of THOLD1 field.
	DAC_SHHR_THOLD1_Pos = 0x0
	// Bit mask of THOLD1 field.
	DAC_SHHR_THOLD1_Msk = 0x3ff
	// Position of THOLD2 field.
	DAC_SHHR_THOLD2_Pos = 0x10
	// Bit mask of THOLD2 field.
	DAC_SHHR_THOLD2_Msk = 0x3ff0000

	// SHRR: DAC Sample and Hold refresh time register
	// Position of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Pos = 0x0
	// Bit mask of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Msk = 0xff
	// Position of TREFRESH2 field.
	DAC_SHRR_TREFRESH2_Pos = 0x10
	// Bit mask of TREFRESH2 field.
	DAC_SHRR_TREFRESH2_Msk = 0xff0000
)

// Constants for DBGMCU: Microcontroller Debug Unit
const (
	// IDC: DBGMCU Identity Code Register
	// Position of DEV_ID field.
	DBGMCU_IDC_DEV_ID_Pos = 0x0
	// Bit mask of DEV_ID field.
	DBGMCU_IDC_DEV_ID_Msk = 0xfff
	// Position of REV_ID field.
	DBGMCU_IDC_REV_ID_Pos = 0x10
	// Bit mask of REV_ID field.
	DBGMCU_IDC_REV_ID_Msk = 0xffff0000

	// CR: DBGMCU Configuration Register
	// Position of DBGSLPD1 field.
	DBGMCU_CR_DBGSLPD1_Pos = 0x0
	// Bit mask of DBGSLPD1 field.
	DBGMCU_CR_DBGSLPD1_Msk = 0x1
	// Bit DBGSLPD1.
	DBGMCU_CR_DBGSLPD1 = 0x1
	// Position of DBGSTPD1 field.
	DBGMCU_CR_DBGSTPD1_Pos = 0x1
	// Bit mask of DBGSTPD1 field.
	DBGMCU_CR_DBGSTPD1_Msk = 0x2
	// Bit DBGSTPD1.
	DBGMCU_CR_DBGSTPD1 = 0x2
	// Position of DBGSTBD1 field.
	DBGMCU_CR_DBGSTBD1_Pos = 0x2
	// Bit mask of DBGSTBD1 field.
	DBGMCU_CR_DBGSTBD1_Msk = 0x4
	// Bit DBGSTBD1.
	DBGMCU_CR_DBGSTBD1 = 0x4
	// Position of DBGSLPD2 field.
	DBGMCU_CR_DBGSLPD2_Pos = 0x3
	// Bit mask of DBGSLPD2 field.
	DBGMCU_CR_DBGSLPD2_Msk = 0x8
	// Bit DBGSLPD2.
	DBGMCU_CR_DBGSLPD2 = 0x8
	// Position of DBGSTPD2 field.
	DBGMCU_CR_DBGSTPD2_Pos = 0x4
	// Bit mask of DBGSTPD2 field.
	DBGMCU_CR_DBGSTPD2_Msk = 0x10
	// Bit DBGSTPD2.
	DBGMCU_CR_DBGSTPD2 = 0x10
	// Position of DBGSTBD2 field.
	DBGMCU_CR_DBGSTBD2_Pos = 0x5
	// Bit mask of DBGSTBD2 field.
	DBGMCU_CR_DBGSTBD2_Msk = 0x20
	// Bit DBGSTBD2.
	DBGMCU_CR_DBGSTBD2 = 0x20
	// Position of DBGSTPD3 field.
	DBGMCU_CR_DBGSTPD3_Pos = 0x7
	// Bit mask of DBGSTPD3 field.
	DBGMCU_CR_DBGSTPD3_Msk = 0x80
	// Bit DBGSTPD3.
	DBGMCU_CR_DBGSTPD3 = 0x80
	// Position of DBGSTBD3 field.
	DBGMCU_CR_DBGSTBD3_Pos = 0x8
	// Bit mask of DBGSTBD3 field.
	DBGMCU_CR_DBGSTBD3_Msk = 0x100
	// Bit DBGSTBD3.
	DBGMCU_CR_DBGSTBD3 = 0x100
	// Position of TRACECLKEN field.
	DBGMCU_CR_TRACECLKEN_Pos = 0x14
	// Bit mask of TRACECLKEN field.
	DBGMCU_CR_TRACECLKEN_Msk = 0x100000
	// Bit TRACECLKEN.
	DBGMCU_CR_TRACECLKEN = 0x100000
	// Position of D1DBGCKEN field.
	DBGMCU_CR_D1DBGCKEN_Pos = 0x15
	// Bit mask of D1DBGCKEN field.
	DBGMCU_CR_D1DBGCKEN_Msk = 0x200000
	// Bit D1DBGCKEN.
	DBGMCU_CR_D1DBGCKEN = 0x200000
	// Position of D3DBGCKEN field.
	DBGMCU_CR_D3DBGCKEN_Pos = 0x16
	// Bit mask of D3DBGCKEN field.
	DBGMCU_CR_D3DBGCKEN_Msk = 0x400000
	// Bit D3DBGCKEN.
	DBGMCU_CR_D3DBGCKEN = 0x400000
	// Position of TRGOEN field.
	DBGMCU_CR_TRGOEN_Pos = 0x1c
	// Bit mask of TRGOEN field.
	DBGMCU_CR_TRGOEN_Msk = 0x10000000
	// Bit TRGOEN.
	DBGMCU_CR_TRGOEN = 0x10000000

	// APB3FZ1: DBGMCU APB3 peripheral freeze register CPU1
	// Position of WWDG1 field.
	DBGMCU_APB3FZ1_WWDG1_Pos = 0x6
	// Bit mask of WWDG1 field.
	DBGMCU_APB3FZ1_WWDG1_Msk = 0x40
	// Bit WWDG1.
	DBGMCU_APB3FZ1_WWDG1 = 0x40

	// APB3FZ2: DBGMCU APB3 peripheral freeze register CPU2
	// Position of WWDG1 field.
	DBGMCU_APB3FZ2_WWDG1_Pos = 0x6
	// Bit mask of WWDG1 field.
	DBGMCU_APB3FZ2_WWDG1_Msk = 0x40
	// Bit WWDG1.
	DBGMCU_APB3FZ2_WWDG1 = 0x40

	// APB1LFZ1: DBGMCU APB1L peripheral freeze register
	// Position of DBG_TIM2 field.
	DBGMCU_APB1LFZ1_DBG_TIM2_Pos = 0x0
	// Bit mask of DBG_TIM2 field.
	DBGMCU_APB1LFZ1_DBG_TIM2_Msk = 0x1
	// Bit DBG_TIM2.
	DBGMCU_APB1LFZ1_DBG_TIM2 = 0x1
	// Position of DBG_TIM3 field.
	DBGMCU_APB1LFZ1_DBG_TIM3_Pos = 0x1
	// Bit mask of DBG_TIM3 field.
	DBGMCU_APB1LFZ1_DBG_TIM3_Msk = 0x2
	// Bit DBG_TIM3.
	DBGMCU_APB1LFZ1_DBG_TIM3 = 0x2
	// Position of DBG_TIM4 field.
	DBGMCU_APB1LFZ1_DBG_TIM4_Pos = 0x2
	// Bit mask of DBG_TIM4 field.
	DBGMCU_APB1LFZ1_DBG_TIM4_Msk = 0x4
	// Bit DBG_TIM4.
	DBGMCU_APB1LFZ1_DBG_TIM4 = 0x4
	// Position of DBG_TIM5 field.
	DBGMCU_APB1LFZ1_DBG_TIM5_Pos = 0x3
	// Bit mask of DBG_TIM5 field.
	DBGMCU_APB1LFZ1_DBG_TIM5_Msk = 0x8
	// Bit DBG_TIM5.
	DBGMCU_APB1LFZ1_DBG_TIM5 = 0x8
	// Position of DBG_TIM6 field.
	DBGMCU_APB1LFZ1_DBG_TIM6_Pos = 0x4
	// Bit mask of DBG_TIM6 field.
	DBGMCU_APB1LFZ1_DBG_TIM6_Msk = 0x10
	// Bit DBG_TIM6.
	DBGMCU_APB1LFZ1_DBG_TIM6 = 0x10
	// Position of DBG_TIM7 field.
	DBGMCU_APB1LFZ1_DBG_TIM7_Pos = 0x5
	// Bit mask of DBG_TIM7 field.
	DBGMCU_APB1LFZ1_DBG_TIM7_Msk = 0x20
	// Bit DBG_TIM7.
	DBGMCU_APB1LFZ1_DBG_TIM7 = 0x20
	// Position of DBG_TIM12 field.
	DBGMCU_APB1LFZ1_DBG_TIM12_Pos = 0x6
	// Bit mask of DBG_TIM12 field.
	DBGMCU_APB1LFZ1_DBG_TIM12_Msk = 0x40
	// Bit DBG_TIM12.
	DBGMCU_APB1LFZ1_DBG_TIM12 = 0x40
	// Position of DBG_TIM13 field.
	DBGMCU_APB1LFZ1_DBG_TIM13_Pos = 0x7
	// Bit mask of DBG_TIM13 field.
	DBGMCU_APB1LFZ1_DBG_TIM13_Msk = 0x80
	// Bit DBG_TIM13.
	DBGMCU_APB1LFZ1_DBG_TIM13 = 0x80
	// Position of DBG_TIM14 field.
	DBGMCU_APB1LFZ1_DBG_TIM14_Pos = 0x8
	// Bit mask of DBG_TIM14 field.
	DBGMCU_APB1LFZ1_DBG_TIM14_Msk = 0x100
	// Bit DBG_TIM14.
	DBGMCU_APB1LFZ1_DBG_TIM14 = 0x100
	// Position of DBG_LPTIM1 field.
	DBGMCU_APB1LFZ1_DBG_LPTIM1_Pos = 0x9
	// Bit mask of DBG_LPTIM1 field.
	DBGMCU_APB1LFZ1_DBG_LPTIM1_Msk = 0x200
	// Bit DBG_LPTIM1.
	DBGMCU_APB1LFZ1_DBG_LPTIM1 = 0x200
	// Position of DBG_WWDG2 field.
	DBGMCU_APB1LFZ1_DBG_WWDG2_Pos = 0xb
	// Bit mask of DBG_WWDG2 field.
	DBGMCU_APB1LFZ1_DBG_WWDG2_Msk = 0x800
	// Bit DBG_WWDG2.
	DBGMCU_APB1LFZ1_DBG_WWDG2 = 0x800
	// Position of DBG_I2C1 field.
	DBGMCU_APB1LFZ1_DBG_I2C1_Pos = 0x15
	// Bit mask of DBG_I2C1 field.
	DBGMCU_APB1LFZ1_DBG_I2C1_Msk = 0x200000
	// Bit DBG_I2C1.
	DBGMCU_APB1LFZ1_DBG_I2C1 = 0x200000
	// Position of DBG_I2C2 field.
	DBGMCU_APB1LFZ1_DBG_I2C2_Pos = 0x16
	// Bit mask of DBG_I2C2 field.
	DBGMCU_APB1LFZ1_DBG_I2C2_Msk = 0x400000
	// Bit DBG_I2C2.
	DBGMCU_APB1LFZ1_DBG_I2C2 = 0x400000
	// Position of DBG_I2C3 field.
	DBGMCU_APB1LFZ1_DBG_I2C3_Pos = 0x17
	// Bit mask of DBG_I2C3 field.
	DBGMCU_APB1LFZ1_DBG_I2C3_Msk = 0x800000
	// Bit DBG_I2C3.
	DBGMCU_APB1LFZ1_DBG_I2C3 = 0x800000

	// APB1LFZ2: DBGMCU APB1L peripheral freeze register CPU2
	// Position of DBG_TIM2 field.
	DBGMCU_APB1LFZ2_DBG_TIM2_Pos = 0x0
	// Bit mask of DBG_TIM2 field.
	DBGMCU_APB1LFZ2_DBG_TIM2_Msk = 0x1
	// Bit DBG_TIM2.
	DBGMCU_APB1LFZ2_DBG_TIM2 = 0x1
	// Position of DBG_TIM3 field.
	DBGMCU_APB1LFZ2_DBG_TIM3_Pos = 0x1
	// Bit mask of DBG_TIM3 field.
	DBGMCU_APB1LFZ2_DBG_TIM3_Msk = 0x2
	// Bit DBG_TIM3.
	DBGMCU_APB1LFZ2_DBG_TIM3 = 0x2
	// Position of DBG_TIM4 field.
	DBGMCU_APB1LFZ2_DBG_TIM4_Pos = 0x2
	// Bit mask of DBG_TIM4 field.
	DBGMCU_APB1LFZ2_DBG_TIM4_Msk = 0x4
	// Bit DBG_TIM4.
	DBGMCU_APB1LFZ2_DBG_TIM4 = 0x4
	// Position of DBG_TIM5 field.
	DBGMCU_APB1LFZ2_DBG_TIM5_Pos = 0x3
	// Bit mask of DBG_TIM5 field.
	DBGMCU_APB1LFZ2_DBG_TIM5_Msk = 0x8
	// Bit DBG_TIM5.
	DBGMCU_APB1LFZ2_DBG_TIM5 = 0x8
	// Position of DBG_TIM6 field.
	DBGMCU_APB1LFZ2_DBG_TIM6_Pos = 0x4
	// Bit mask of DBG_TIM6 field.
	DBGMCU_APB1LFZ2_DBG_TIM6_Msk = 0x10
	// Bit DBG_TIM6.
	DBGMCU_APB1LFZ2_DBG_TIM6 = 0x10
	// Position of DBG_TIM7 field.
	DBGMCU_APB1LFZ2_DBG_TIM7_Pos = 0x5
	// Bit mask of DBG_TIM7 field.
	DBGMCU_APB1LFZ2_DBG_TIM7_Msk = 0x20
	// Bit DBG_TIM7.
	DBGMCU_APB1LFZ2_DBG_TIM7 = 0x20
	// Position of DBG_TIM12 field.
	DBGMCU_APB1LFZ2_DBG_TIM12_Pos = 0x6
	// Bit mask of DBG_TIM12 field.
	DBGMCU_APB1LFZ2_DBG_TIM12_Msk = 0x40
	// Bit DBG_TIM12.
	DBGMCU_APB1LFZ2_DBG_TIM12 = 0x40
	// Position of DBG_TIM13 field.
	DBGMCU_APB1LFZ2_DBG_TIM13_Pos = 0x7
	// Bit mask of DBG_TIM13 field.
	DBGMCU_APB1LFZ2_DBG_TIM13_Msk = 0x80
	// Bit DBG_TIM13.
	DBGMCU_APB1LFZ2_DBG_TIM13 = 0x80
	// Position of DBG_TIM14 field.
	DBGMCU_APB1LFZ2_DBG_TIM14_Pos = 0x8
	// Bit mask of DBG_TIM14 field.
	DBGMCU_APB1LFZ2_DBG_TIM14_Msk = 0x100
	// Bit DBG_TIM14.
	DBGMCU_APB1LFZ2_DBG_TIM14 = 0x100
	// Position of DBG_LPTIM1 field.
	DBGMCU_APB1LFZ2_DBG_LPTIM1_Pos = 0x9
	// Bit mask of DBG_LPTIM1 field.
	DBGMCU_APB1LFZ2_DBG_LPTIM1_Msk = 0x200
	// Bit DBG_LPTIM1.
	DBGMCU_APB1LFZ2_DBG_LPTIM1 = 0x200
	// Position of DBG_WWDG2 field.
	DBGMCU_APB1LFZ2_DBG_WWDG2_Pos = 0xb
	// Bit mask of DBG_WWDG2 field.
	DBGMCU_APB1LFZ2_DBG_WWDG2_Msk = 0x800
	// Bit DBG_WWDG2.
	DBGMCU_APB1LFZ2_DBG_WWDG2 = 0x800
	// Position of DBG_I2C1 field.
	DBGMCU_APB1LFZ2_DBG_I2C1_Pos = 0x15
	// Bit mask of DBG_I2C1 field.
	DBGMCU_APB1LFZ2_DBG_I2C1_Msk = 0x200000
	// Bit DBG_I2C1.
	DBGMCU_APB1LFZ2_DBG_I2C1 = 0x200000
	// Position of DBG_I2C2 field.
	DBGMCU_APB1LFZ2_DBG_I2C2_Pos = 0x16
	// Bit mask of DBG_I2C2 field.
	DBGMCU_APB1LFZ2_DBG_I2C2_Msk = 0x400000
	// Bit DBG_I2C2.
	DBGMCU_APB1LFZ2_DBG_I2C2 = 0x400000
	// Position of DBG_I2C3 field.
	DBGMCU_APB1LFZ2_DBG_I2C3_Pos = 0x17
	// Bit mask of DBG_I2C3 field.
	DBGMCU_APB1LFZ2_DBG_I2C3_Msk = 0x800000
	// Bit DBG_I2C3.
	DBGMCU_APB1LFZ2_DBG_I2C3 = 0x800000

	// APB2FZ1: DBGMCU APB2 peripheral freeze register
	// Position of DBG_TIM1 field.
	DBGMCU_APB2FZ1_DBG_TIM1_Pos = 0x0
	// Bit mask of DBG_TIM1 field.
	DBGMCU_APB2FZ1_DBG_TIM1_Msk = 0x1
	// Bit DBG_TIM1.
	DBGMCU_APB2FZ1_DBG_TIM1 = 0x1
	// Position of DBG_TIM8 field.
	DBGMCU_APB2FZ1_DBG_TIM8_Pos = 0x1
	// Bit mask of DBG_TIM8 field.
	DBGMCU_APB2FZ1_DBG_TIM8_Msk = 0x2
	// Bit DBG_TIM8.
	DBGMCU_APB2FZ1_DBG_TIM8 = 0x2
	// Position of DBG_TIM15 field.
	DBGMCU_APB2FZ1_DBG_TIM15_Pos = 0x10
	// Bit mask of DBG_TIM15 field.
	DBGMCU_APB2FZ1_DBG_TIM15_Msk = 0x10000
	// Bit DBG_TIM15.
	DBGMCU_APB2FZ1_DBG_TIM15 = 0x10000
	// Position of DBG_TIM16 field.
	DBGMCU_APB2FZ1_DBG_TIM16_Pos = 0x11
	// Bit mask of DBG_TIM16 field.
	DBGMCU_APB2FZ1_DBG_TIM16_Msk = 0x20000
	// Bit DBG_TIM16.
	DBGMCU_APB2FZ1_DBG_TIM16 = 0x20000
	// Position of DBG_TIM17 field.
	DBGMCU_APB2FZ1_DBG_TIM17_Pos = 0x12
	// Bit mask of DBG_TIM17 field.
	DBGMCU_APB2FZ1_DBG_TIM17_Msk = 0x40000
	// Bit DBG_TIM17.
	DBGMCU_APB2FZ1_DBG_TIM17 = 0x40000
	// Position of DBG_HRTIM field.
	DBGMCU_APB2FZ1_DBG_HRTIM_Pos = 0x1d
	// Bit mask of DBG_HRTIM field.
	DBGMCU_APB2FZ1_DBG_HRTIM_Msk = 0x20000000
	// Bit DBG_HRTIM.
	DBGMCU_APB2FZ1_DBG_HRTIM = 0x20000000

	// APB2FZ2: DBGMCU APB2 peripheral freeze register CPU2
	// Position of DBG_TIM1 field.
	DBGMCU_APB2FZ2_DBG_TIM1_Pos = 0x0
	// Bit mask of DBG_TIM1 field.
	DBGMCU_APB2FZ2_DBG_TIM1_Msk = 0x1
	// Bit DBG_TIM1.
	DBGMCU_APB2FZ2_DBG_TIM1 = 0x1
	// Position of DBG_TIM8 field.
	DBGMCU_APB2FZ2_DBG_TIM8_Pos = 0x1
	// Bit mask of DBG_TIM8 field.
	DBGMCU_APB2FZ2_DBG_TIM8_Msk = 0x2
	// Bit DBG_TIM8.
	DBGMCU_APB2FZ2_DBG_TIM8 = 0x2
	// Position of DBG_TIM15 field.
	DBGMCU_APB2FZ2_DBG_TIM15_Pos = 0x10
	// Bit mask of DBG_TIM15 field.
	DBGMCU_APB2FZ2_DBG_TIM15_Msk = 0x10000
	// Bit DBG_TIM15.
	DBGMCU_APB2FZ2_DBG_TIM15 = 0x10000
	// Position of DBG_TIM16 field.
	DBGMCU_APB2FZ2_DBG_TIM16_Pos = 0x11
	// Bit mask of DBG_TIM16 field.
	DBGMCU_APB2FZ2_DBG_TIM16_Msk = 0x20000
	// Bit DBG_TIM16.
	DBGMCU_APB2FZ2_DBG_TIM16 = 0x20000
	// Position of DBG_TIM17 field.
	DBGMCU_APB2FZ2_DBG_TIM17_Pos = 0x12
	// Bit mask of DBG_TIM17 field.
	DBGMCU_APB2FZ2_DBG_TIM17_Msk = 0x40000
	// Bit DBG_TIM17.
	DBGMCU_APB2FZ2_DBG_TIM17 = 0x40000
	// Position of DBG_HRTIM field.
	DBGMCU_APB2FZ2_DBG_HRTIM_Pos = 0x1d
	// Bit mask of DBG_HRTIM field.
	DBGMCU_APB2FZ2_DBG_HRTIM_Msk = 0x20000000
	// Bit DBG_HRTIM.
	DBGMCU_APB2FZ2_DBG_HRTIM = 0x20000000

	// APB4FZ1: DBGMCU APB4 peripheral freeze register
	// Position of DBG_I2C4 field.
	DBGMCU_APB4FZ1_DBG_I2C4_Pos = 0x7
	// Bit mask of DBG_I2C4 field.
	DBGMCU_APB4FZ1_DBG_I2C4_Msk = 0x80
	// Bit DBG_I2C4.
	DBGMCU_APB4FZ1_DBG_I2C4 = 0x80
	// Position of DBG_LPTIM2 field.
	DBGMCU_APB4FZ1_DBG_LPTIM2_Pos = 0x9
	// Bit mask of DBG_LPTIM2 field.
	DBGMCU_APB4FZ1_DBG_LPTIM2_Msk = 0x200
	// Bit DBG_LPTIM2.
	DBGMCU_APB4FZ1_DBG_LPTIM2 = 0x200
	// Position of DBG_LPTIM3 field.
	DBGMCU_APB4FZ1_DBG_LPTIM3_Pos = 0xa
	// Bit mask of DBG_LPTIM3 field.
	DBGMCU_APB4FZ1_DBG_LPTIM3_Msk = 0x400
	// Bit DBG_LPTIM3.
	DBGMCU_APB4FZ1_DBG_LPTIM3 = 0x400
	// Position of DBG_LPTIM4 field.
	DBGMCU_APB4FZ1_DBG_LPTIM4_Pos = 0xb
	// Bit mask of DBG_LPTIM4 field.
	DBGMCU_APB4FZ1_DBG_LPTIM4_Msk = 0x800
	// Bit DBG_LPTIM4.
	DBGMCU_APB4FZ1_DBG_LPTIM4 = 0x800
	// Position of DBG_LPTIM5 field.
	DBGMCU_APB4FZ1_DBG_LPTIM5_Pos = 0xc
	// Bit mask of DBG_LPTIM5 field.
	DBGMCU_APB4FZ1_DBG_LPTIM5_Msk = 0x1000
	// Bit DBG_LPTIM5.
	DBGMCU_APB4FZ1_DBG_LPTIM5 = 0x1000
	// Position of DBG_RTC field.
	DBGMCU_APB4FZ1_DBG_RTC_Pos = 0x10
	// Bit mask of DBG_RTC field.
	DBGMCU_APB4FZ1_DBG_RTC_Msk = 0x10000
	// Bit DBG_RTC.
	DBGMCU_APB4FZ1_DBG_RTC = 0x10000
	// Position of DBG_WDGLSD1 field.
	DBGMCU_APB4FZ1_DBG_WDGLSD1_Pos = 0x12
	// Bit mask of DBG_WDGLSD1 field.
	DBGMCU_APB4FZ1_DBG_WDGLSD1_Msk = 0x40000
	// Bit DBG_WDGLSD1.
	DBGMCU_APB4FZ1_DBG_WDGLSD1 = 0x40000
	// Position of DBG_WDGLSD2 field.
	DBGMCU_APB4FZ1_DBG_WDGLSD2_Pos = 0x13
	// Bit mask of DBG_WDGLSD2 field.
	DBGMCU_APB4FZ1_DBG_WDGLSD2_Msk = 0x80000
	// Bit DBG_WDGLSD2.
	DBGMCU_APB4FZ1_DBG_WDGLSD2 = 0x80000

	// APB4FZ2: DBGMCU APB4 peripheral freeze register CPU2
	// Position of DBG_I2C4 field.
	DBGMCU_APB4FZ2_DBG_I2C4_Pos = 0x7
	// Bit mask of DBG_I2C4 field.
	DBGMCU_APB4FZ2_DBG_I2C4_Msk = 0x80
	// Bit DBG_I2C4.
	DBGMCU_APB4FZ2_DBG_I2C4 = 0x80
	// Position of DBG_LPTIM2 field.
	DBGMCU_APB4FZ2_DBG_LPTIM2_Pos = 0x9
	// Bit mask of DBG_LPTIM2 field.
	DBGMCU_APB4FZ2_DBG_LPTIM2_Msk = 0x200
	// Bit DBG_LPTIM2.
	DBGMCU_APB4FZ2_DBG_LPTIM2 = 0x200
	// Position of DBG_LPTIM3 field.
	DBGMCU_APB4FZ2_DBG_LPTIM3_Pos = 0xa
	// Bit mask of DBG_LPTIM3 field.
	DBGMCU_APB4FZ2_DBG_LPTIM3_Msk = 0x400
	// Bit DBG_LPTIM3.
	DBGMCU_APB4FZ2_DBG_LPTIM3 = 0x400
	// Position of DBG_LPTIM4 field.
	DBGMCU_APB4FZ2_DBG_LPTIM4_Pos = 0xb
	// Bit mask of DBG_LPTIM4 field.
	DBGMCU_APB4FZ2_DBG_LPTIM4_Msk = 0x800
	// Bit DBG_LPTIM4.
	DBGMCU_APB4FZ2_DBG_LPTIM4 = 0x800
	// Position of DBG_LPTIM5 field.
	DBGMCU_APB4FZ2_DBG_LPTIM5_Pos = 0xc
	// Bit mask of DBG_LPTIM5 field.
	DBGMCU_APB4FZ2_DBG_LPTIM5_Msk = 0x1000
	// Bit DBG_LPTIM5.
	DBGMCU_APB4FZ2_DBG_LPTIM5 = 0x1000
	// Position of DBG_RTC field.
	DBGMCU_APB4FZ2_DBG_RTC_Pos = 0x10
	// Bit mask of DBG_RTC field.
	DBGMCU_APB4FZ2_DBG_RTC_Msk = 0x10000
	// Bit DBG_RTC.
	DBGMCU_APB4FZ2_DBG_RTC = 0x10000
	// Position of DBG_WDGLSD1 field.
	DBGMCU_APB4FZ2_DBG_WDGLSD1_Pos = 0x12
	// Bit mask of DBG_WDGLSD1 field.
	DBGMCU_APB4FZ2_DBG_WDGLSD1_Msk = 0x40000
	// Bit DBG_WDGLSD1.
	DBGMCU_APB4FZ2_DBG_WDGLSD1 = 0x40000
	// Position of DBG_WDGLSD2 field.
	DBGMCU_APB4FZ2_DBG_WDGLSD2_Pos = 0x13
	// Bit mask of DBG_WDGLSD2 field.
	DBGMCU_APB4FZ2_DBG_WDGLSD2_Msk = 0x80000
	// Bit DBG_WDGLSD2.
	DBGMCU_APB4FZ2_DBG_WDGLSD2 = 0x80000
)

// Constants for DCMI: Digital camera interface
const (
	// CR: control register 1
	// Position of OELS field.
	DCMI_CR_OELS_Pos = 0x14
	// Bit mask of OELS field.
	DCMI_CR_OELS_Msk = 0x100000
	// Bit OELS.
	DCMI_CR_OELS = 0x100000
	// Position of LSM field.
	DCMI_CR_LSM_Pos = 0x13
	// Bit mask of LSM field.
	DCMI_CR_LSM_Msk = 0x80000
	// Bit LSM.
	DCMI_CR_LSM = 0x80000
	// Position of OEBS field.
	DCMI_CR_OEBS_Pos = 0x12
	// Bit mask of OEBS field.
	DCMI_CR_OEBS_Msk = 0x40000
	// Bit OEBS.
	DCMI_CR_OEBS = 0x40000
	// Position of BSM field.
	DCMI_CR_BSM_Pos = 0x10
	// Bit mask of BSM field.
	DCMI_CR_BSM_Msk = 0x30000
	// Position of ENABLE field.
	DCMI_CR_ENABLE_Pos = 0xe
	// Bit mask of ENABLE field.
	DCMI_CR_ENABLE_Msk = 0x4000
	// Bit ENABLE.
	DCMI_CR_ENABLE = 0x4000
	// Position of EDM field.
	DCMI_CR_EDM_Pos = 0xa
	// Bit mask of EDM field.
	DCMI_CR_EDM_Msk = 0xc00
	// Position of FCRC field.
	DCMI_CR_FCRC_Pos = 0x8
	// Bit mask of FCRC field.
	DCMI_CR_FCRC_Msk = 0x300
	// Position of VSPOL field.
	DCMI_CR_VSPOL_Pos = 0x7
	// Bit mask of VSPOL field.
	DCMI_CR_VSPOL_Msk = 0x80
	// Bit VSPOL.
	DCMI_CR_VSPOL = 0x80
	// Position of HSPOL field.
	DCMI_CR_HSPOL_Pos = 0x6
	// Bit mask of HSPOL field.
	DCMI_CR_HSPOL_Msk = 0x40
	// Bit HSPOL.
	DCMI_CR_HSPOL = 0x40
	// Position of PCKPOL field.
	DCMI_CR_PCKPOL_Pos = 0x5
	// Bit mask of PCKPOL field.
	DCMI_CR_PCKPOL_Msk = 0x20
	// Bit PCKPOL.
	DCMI_CR_PCKPOL = 0x20
	// Position of ESS field.
	DCMI_CR_ESS_Pos = 0x4
	// Bit mask of ESS field.
	DCMI_CR_ESS_Msk = 0x10
	// Bit ESS.
	DCMI_CR_ESS = 0x10
	// Position of JPEG field.
	DCMI_CR_JPEG_Pos = 0x3
	// Bit mask of JPEG field.
	DCMI_CR_JPEG_Msk = 0x8
	// Bit JPEG.
	DCMI_CR_JPEG = 0x8
	// Position of CROP field.
	DCMI_CR_CROP_Pos = 0x2
	// Bit mask of CROP field.
	DCMI_CR_CROP_Msk = 0x4
	// Bit CROP.
	DCMI_CR_CROP = 0x4
	// Position of CM field.
	DCMI_CR_CM_Pos = 0x1
	// Bit mask of CM field.
	DCMI_CR_CM_Msk = 0x2
	// Bit CM.
	DCMI_CR_CM = 0x2
	// Position of CAPTURE field.
	DCMI_CR_CAPTURE_Pos = 0x0
	// Bit mask of CAPTURE field.
	DCMI_CR_CAPTURE_Msk = 0x1
	// Bit CAPTURE.
	DCMI_CR_CAPTURE = 0x1

	// SR: status register
	// Position of FNE field.
	DCMI_SR_FNE_Pos = 0x2
	// Bit mask of FNE field.
	DCMI_SR_FNE_Msk = 0x4
	// Bit FNE.
	DCMI_SR_FNE = 0x4
	// Position of VSYNC field.
	DCMI_SR_VSYNC_Pos = 0x1
	// Bit mask of VSYNC field.
	DCMI_SR_VSYNC_Msk = 0x2
	// Bit VSYNC.
	DCMI_SR_VSYNC = 0x2
	// Position of HSYNC field.
	DCMI_SR_HSYNC_Pos = 0x0
	// Bit mask of HSYNC field.
	DCMI_SR_HSYNC_Msk = 0x1
	// Bit HSYNC.
	DCMI_SR_HSYNC = 0x1

	// RIS: raw interrupt status register
	// Position of LINE_RIS field.
	DCMI_RIS_LINE_RIS_Pos = 0x4
	// Bit mask of LINE_RIS field.
	DCMI_RIS_LINE_RIS_Msk = 0x10
	// Bit LINE_RIS.
	DCMI_RIS_LINE_RIS = 0x10
	// Position of VSYNC_RIS field.
	DCMI_RIS_VSYNC_RIS_Pos = 0x3
	// Bit mask of VSYNC_RIS field.
	DCMI_RIS_VSYNC_RIS_Msk = 0x8
	// Bit VSYNC_RIS.
	DCMI_RIS_VSYNC_RIS = 0x8
	// Position of ERR_RIS field.
	DCMI_RIS_ERR_RIS_Pos = 0x2
	// Bit mask of ERR_RIS field.
	DCMI_RIS_ERR_RIS_Msk = 0x4
	// Bit ERR_RIS.
	DCMI_RIS_ERR_RIS = 0x4
	// Position of OVR_RIS field.
	DCMI_RIS_OVR_RIS_Pos = 0x1
	// Bit mask of OVR_RIS field.
	DCMI_RIS_OVR_RIS_Msk = 0x2
	// Bit OVR_RIS.
	DCMI_RIS_OVR_RIS = 0x2
	// Position of FRAME_RIS field.
	DCMI_RIS_FRAME_RIS_Pos = 0x0
	// Bit mask of FRAME_RIS field.
	DCMI_RIS_FRAME_RIS_Msk = 0x1
	// Bit FRAME_RIS.
	DCMI_RIS_FRAME_RIS = 0x1

	// IER: interrupt enable register
	// Position of LINE_IE field.
	DCMI_IER_LINE_IE_Pos = 0x4
	// Bit mask of LINE_IE field.
	DCMI_IER_LINE_IE_Msk = 0x10
	// Bit LINE_IE.
	DCMI_IER_LINE_IE = 0x10
	// Position of VSYNC_IE field.
	DCMI_IER_VSYNC_IE_Pos = 0x3
	// Bit mask of VSYNC_IE field.
	DCMI_IER_VSYNC_IE_Msk = 0x8
	// Bit VSYNC_IE.
	DCMI_IER_VSYNC_IE = 0x8
	// Position of ERR_IE field.
	DCMI_IER_ERR_IE_Pos = 0x2
	// Bit mask of ERR_IE field.
	DCMI_IER_ERR_IE_Msk = 0x4
	// Bit ERR_IE.
	DCMI_IER_ERR_IE = 0x4
	// Position of OVR_IE field.
	DCMI_IER_OVR_IE_Pos = 0x1
	// Bit mask of OVR_IE field.
	DCMI_IER_OVR_IE_Msk = 0x2
	// Bit OVR_IE.
	DCMI_IER_OVR_IE = 0x2
	// Position of FRAME_IE field.
	DCMI_IER_FRAME_IE_Pos = 0x0
	// Bit mask of FRAME_IE field.
	DCMI_IER_FRAME_IE_Msk = 0x1
	// Bit FRAME_IE.
	DCMI_IER_FRAME_IE = 0x1

	// MIS: masked interrupt status register
	// Position of LINE_MIS field.
	DCMI_MIS_LINE_MIS_Pos = 0x4
	// Bit mask of LINE_MIS field.
	DCMI_MIS_LINE_MIS_Msk = 0x10
	// Bit LINE_MIS.
	DCMI_MIS_LINE_MIS = 0x10
	// Position of VSYNC_MIS field.
	DCMI_MIS_VSYNC_MIS_Pos = 0x3
	// Bit mask of VSYNC_MIS field.
	DCMI_MIS_VSYNC_MIS_Msk = 0x8
	// Bit VSYNC_MIS.
	DCMI_MIS_VSYNC_MIS = 0x8
	// Position of ERR_MIS field.
	DCMI_MIS_ERR_MIS_Pos = 0x2
	// Bit mask of ERR_MIS field.
	DCMI_MIS_ERR_MIS_Msk = 0x4
	// Bit ERR_MIS.
	DCMI_MIS_ERR_MIS = 0x4
	// Position of OVR_MIS field.
	DCMI_MIS_OVR_MIS_Pos = 0x1
	// Bit mask of OVR_MIS field.
	DCMI_MIS_OVR_MIS_Msk = 0x2
	// Bit OVR_MIS.
	DCMI_MIS_OVR_MIS = 0x2
	// Position of FRAME_MIS field.
	DCMI_MIS_FRAME_MIS_Pos = 0x0
	// Bit mask of FRAME_MIS field.
	DCMI_MIS_FRAME_MIS_Msk = 0x1
	// Bit FRAME_MIS.
	DCMI_MIS_FRAME_MIS = 0x1

	// ICR: interrupt clear register
	// Position of LINE_ISC field.
	DCMI_ICR_LINE_ISC_Pos = 0x4
	// Bit mask of LINE_ISC field.
	DCMI_ICR_LINE_ISC_Msk = 0x10
	// Bit LINE_ISC.
	DCMI_ICR_LINE_ISC = 0x10
	// Position of VSYNC_ISC field.
	DCMI_ICR_VSYNC_ISC_Pos = 0x3
	// Bit mask of VSYNC_ISC field.
	DCMI_ICR_VSYNC_ISC_Msk = 0x8
	// Bit VSYNC_ISC.
	DCMI_ICR_VSYNC_ISC = 0x8
	// Position of ERR_ISC field.
	DCMI_ICR_ERR_ISC_Pos = 0x2
	// Bit mask of ERR_ISC field.
	DCMI_ICR_ERR_ISC_Msk = 0x4
	// Bit ERR_ISC.
	DCMI_ICR_ERR_ISC = 0x4
	// Position of OVR_ISC field.
	DCMI_ICR_OVR_ISC_Pos = 0x1
	// Bit mask of OVR_ISC field.
	DCMI_ICR_OVR_ISC_Msk = 0x2
	// Bit OVR_ISC.
	DCMI_ICR_OVR_ISC = 0x2
	// Position of FRAME_ISC field.
	DCMI_ICR_FRAME_ISC_Pos = 0x0
	// Bit mask of FRAME_ISC field.
	DCMI_ICR_FRAME_ISC_Msk = 0x1
	// Bit FRAME_ISC.
	DCMI_ICR_FRAME_ISC = 0x1

	// ESCR: embedded synchronization code register
	// Position of FEC field.
	DCMI_ESCR_FEC_Pos = 0x18
	// Bit mask of FEC field.
	DCMI_ESCR_FEC_Msk = 0xff000000
	// Position of LEC field.
	DCMI_ESCR_LEC_Pos = 0x10
	// Bit mask of LEC field.
	DCMI_ESCR_LEC_Msk = 0xff0000
	// Position of LSC field.
	DCMI_ESCR_LSC_Pos = 0x8
	// Bit mask of LSC field.
	DCMI_ESCR_LSC_Msk = 0xff00
	// Position of FSC field.
	DCMI_ESCR_FSC_Pos = 0x0
	// Bit mask of FSC field.
	DCMI_ESCR_FSC_Msk = 0xff

	// ESUR: embedded synchronization unmask register
	// Position of FEU field.
	DCMI_ESUR_FEU_Pos = 0x18
	// Bit mask of FEU field.
	DCMI_ESUR_FEU_Msk = 0xff000000
	// Position of LEU field.
	DCMI_ESUR_LEU_Pos = 0x10
	// Bit mask of LEU field.
	DCMI_ESUR_LEU_Msk = 0xff0000
	// Position of LSU field.
	DCMI_ESUR_LSU_Pos = 0x8
	// Bit mask of LSU field.
	DCMI_ESUR_LSU_Msk = 0xff00
	// Position of FSU field.
	DCMI_ESUR_FSU_Pos = 0x0
	// Bit mask of FSU field.
	DCMI_ESUR_FSU_Msk = 0xff

	// CWSTRT: crop window start
	// Position of VST field.
	DCMI_CWSTRT_VST_Pos = 0x10
	// Bit mask of VST field.
	DCMI_CWSTRT_VST_Msk = 0x1fff0000
	// Position of HOFFCNT field.
	DCMI_CWSTRT_HOFFCNT_Pos = 0x0
	// Bit mask of HOFFCNT field.
	DCMI_CWSTRT_HOFFCNT_Msk = 0x3fff

	// CWSIZE: crop window size
	// Position of VLINE field.
	DCMI_CWSIZE_VLINE_Pos = 0x10
	// Bit mask of VLINE field.
	DCMI_CWSIZE_VLINE_Msk = 0x3fff0000
	// Position of CAPCNT field.
	DCMI_CWSIZE_CAPCNT_Pos = 0x0
	// Bit mask of CAPCNT field.
	DCMI_CWSIZE_CAPCNT_Msk = 0x3fff

	// DR: data register
	// Position of Byte3 field.
	DCMI_DR_Byte3_Pos = 0x18
	// Bit mask of Byte3 field.
	DCMI_DR_Byte3_Msk = 0xff000000
	// Position of Byte2 field.
	DCMI_DR_Byte2_Pos = 0x10
	// Bit mask of Byte2 field.
	DCMI_DR_Byte2_Msk = 0xff0000
	// Position of Byte1 field.
	DCMI_DR_Byte1_Pos = 0x8
	// Bit mask of Byte1 field.
	DCMI_DR_Byte1_Msk = 0xff00
	// Position of Byte0 field.
	DCMI_DR_Byte0_Pos = 0x0
	// Bit mask of Byte0 field.
	DCMI_DR_Byte0_Msk = 0xff
)

// Constants for DELAY_Block_SDMMC1: DELAY_Block_SDMMC1
const (
	// CR: DLYB control register
	// Position of DEN field.
	DLYB_CR_DEN_Pos = 0x0
	// Bit mask of DEN field.
	DLYB_CR_DEN_Msk = 0x1
	// Bit DEN.
	DLYB_CR_DEN = 0x1
	// Position of SEN field.
	DLYB_CR_SEN_Pos = 0x1
	// Bit mask of SEN field.
	DLYB_CR_SEN_Msk = 0x2
	// Bit SEN.
	DLYB_CR_SEN = 0x2

	// CFGR: DLYB configuration register
	// Position of SEL field.
	DLYB_CFGR_SEL_Pos = 0x0
	// Bit mask of SEL field.
	DLYB_CFGR_SEL_Msk = 0xf
	// Position of UNIT field.
	DLYB_CFGR_UNIT_Pos = 0x8
	// Bit mask of UNIT field.
	DLYB_CFGR_UNIT_Msk = 0x7f00
	// Position of LNG field.
	DLYB_CFGR_LNG_Pos = 0x10
	// Bit mask of LNG field.
	DLYB_CFGR_LNG_Msk = 0xfff0000
	// Position of LNGF field.
	DLYB_CFGR_LNGF_Pos = 0x1f
	// Bit mask of LNGF field.
	DLYB_CFGR_LNGF_Msk = 0x80000000
	// Bit LNGF.
	DLYB_CFGR_LNGF = 0x80000000
)

// Constants for DFSDM: Digital filter for sigma delta modulators
const (
	// CH.CFGR1: channel configuration y register
	// Position of DFSDMEN field.
	DFSDM_CH_CFGR1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CH_CFGR1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CH_CFGR1_DFSDMEN = 0x80000000
	// Position of CKOUTSRC field.
	DFSDM_CH_CFGR1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CH_CFGR1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CH_CFGR1_CKOUTSRC = 0x40000000
	// Position of CKOUTDIV field.
	DFSDM_CH_CFGR1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CH_CFGR1_CKOUTDIV_Msk = 0xff0000
	// Position of DATPACK field.
	DFSDM_CH_CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH_CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH_CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH_CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH_CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH_CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH_CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH_CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH_CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH_CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH_CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH_CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH_CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH_CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH_CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH_CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH_CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH_CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH_CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH_CFGR1_SITP_Msk = 0x3

	// CH.CFGR2: channel configuration y register
	// Position of OFFSET field.
	DFSDM_CH_CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH_CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH_CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH_CFGR2_DTRBS_Msk = 0xf8

	// CH.AWSCDR: analog watchdog and short-circuit detector register
	// Position of AWFORD field.
	DFSDM_CH_AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH_AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH_AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH_AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH_AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH_AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH_AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH_AWSCDR_SCDT_Msk = 0xff

	// CH.WDATR: channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CH_WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH_WDATR_WDATA_Msk = 0xffff

	// CH.DATINR: channel data input register
	// Position of INDAT1 field.
	DFSDM_CH_DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH_DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH_DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH_DATINR_INDAT0_Msk = 0xffff

	// FLT.CR1: control register 1
	// Position of AWFSEL field.
	DFSDM_FLT_CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_FLT_CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_FLT_CR1_AWFSEL = 0x40000000
	// Position of FAST field.
	DFSDM_FLT_CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_FLT_CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_FLT_CR1_FAST = 0x20000000
	// Position of RCH field.
	DFSDM_FLT_CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_FLT_CR1_RCH_Msk = 0x7000000
	// Position of RDMAEN field.
	DFSDM_FLT_CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_FLT_CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_FLT_CR1_RDMAEN = 0x200000
	// Position of RSYNC field.
	DFSDM_FLT_CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_FLT_CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_FLT_CR1_RSYNC = 0x80000
	// Position of RCONT field.
	DFSDM_FLT_CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_FLT_CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_FLT_CR1_RCONT = 0x40000
	// Position of RSWSTART field.
	DFSDM_FLT_CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_FLT_CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_FLT_CR1_RSWSTART = 0x20000
	// Position of JEXTEN field.
	DFSDM_FLT_CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_FLT_CR1_JEXTEN_Msk = 0x6000
	// Position of JEXTSEL field.
	DFSDM_FLT_CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_FLT_CR1_JEXTSEL_Msk = 0x700
	// Position of JDMAEN field.
	DFSDM_FLT_CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_FLT_CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_FLT_CR1_JDMAEN = 0x20
	// Position of JSCAN field.
	DFSDM_FLT_CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_FLT_CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_FLT_CR1_JSCAN = 0x10
	// Position of JSYNC field.
	DFSDM_FLT_CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_FLT_CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_FLT_CR1_JSYNC = 0x8
	// Position of JSWSTART field.
	DFSDM_FLT_CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_FLT_CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_FLT_CR1_JSWSTART = 0x2
	// Position of DFEN field.
	DFSDM_FLT_CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_FLT_CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_FLT_CR1_DFEN = 0x1

	// FLT.CR2: control register 2
	// Position of AWDCH field.
	DFSDM_FLT_CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_FLT_CR2_AWDCH_Msk = 0xff0000
	// Position of EXCH field.
	DFSDM_FLT_CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_FLT_CR2_EXCH_Msk = 0xff00
	// Position of CKABIE field.
	DFSDM_FLT_CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_FLT_CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_FLT_CR2_CKABIE = 0x40
	// Position of SCDIE field.
	DFSDM_FLT_CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_FLT_CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_FLT_CR2_SCDIE = 0x20
	// Position of AWDIE field.
	DFSDM_FLT_CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_FLT_CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_FLT_CR2_AWDIE = 0x10
	// Position of ROVRIE field.
	DFSDM_FLT_CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_FLT_CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_FLT_CR2_ROVRIE = 0x8
	// Position of JOVRIE field.
	DFSDM_FLT_CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_FLT_CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_FLT_CR2_JOVRIE = 0x4
	// Position of REOCIE field.
	DFSDM_FLT_CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_FLT_CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_FLT_CR2_REOCIE = 0x2
	// Position of JEOCIE field.
	DFSDM_FLT_CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_FLT_CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_FLT_CR2_JEOCIE = 0x1

	// FLT.ISR: interrupt and status register
	// Position of SCDF field.
	DFSDM_FLT_ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_FLT_ISR_SCDF_Msk = 0xff000000
	// Position of CKABF field.
	DFSDM_FLT_ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_FLT_ISR_CKABF_Msk = 0xff0000
	// Position of RCIP field.
	DFSDM_FLT_ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_FLT_ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_FLT_ISR_RCIP = 0x4000
	// Position of JCIP field.
	DFSDM_FLT_ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_FLT_ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_FLT_ISR_JCIP = 0x2000
	// Position of AWDF field.
	DFSDM_FLT_ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_FLT_ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_FLT_ISR_AWDF = 0x10
	// Position of ROVRF field.
	DFSDM_FLT_ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_FLT_ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_FLT_ISR_ROVRF = 0x8
	// Position of JOVRF field.
	DFSDM_FLT_ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_FLT_ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_FLT_ISR_JOVRF = 0x4
	// Position of REOCF field.
	DFSDM_FLT_ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_FLT_ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_FLT_ISR_REOCF = 0x2
	// Position of JEOCF field.
	DFSDM_FLT_ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_FLT_ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_FLT_ISR_JEOCF = 0x1

	// FLT.ICR: interrupt flag clear register
	// Position of CLRSCDF field.
	DFSDM_FLT_ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_FLT_ICR_CLRSCDF_Msk = 0xff000000
	// Position of CLRCKABF field.
	DFSDM_FLT_ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_FLT_ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRROVRF field.
	DFSDM_FLT_ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_FLT_ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_FLT_ICR_CLRROVRF = 0x8
	// Position of CLRJOVRF field.
	DFSDM_FLT_ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_FLT_ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_FLT_ICR_CLRJOVRF = 0x4

	// FLT.JCHGR: injected channel group selection register
	// Position of JCHG field.
	DFSDM_FLT_JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_FLT_JCHGR_JCHG_Msk = 0xff

	// FLT.FCR: filter control register
	// Position of FORD field.
	DFSDM_FLT_FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_FLT_FCR_FORD_Msk = 0xe0000000
	// Position of FOSR field.
	DFSDM_FLT_FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_FLT_FCR_FOSR_Msk = 0x3ff0000
	// Position of IOSR field.
	DFSDM_FLT_FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_FLT_FCR_IOSR_Msk = 0xff

	// FLT.JDATAR: data register for injected group
	// Position of JDATA field.
	DFSDM_FLT_JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_FLT_JDATAR_JDATA_Msk = 0xffffff00
	// Position of JDATACH field.
	DFSDM_FLT_JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_FLT_JDATAR_JDATACH_Msk = 0x7

	// FLT.RDATAR: data register for the regular channel
	// Position of RDATA field.
	DFSDM_FLT_RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_FLT_RDATAR_RDATA_Msk = 0xffffff00
	// Position of RPEND field.
	DFSDM_FLT_RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_FLT_RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_FLT_RDATAR_RPEND = 0x10
	// Position of RDATACH field.
	DFSDM_FLT_RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_FLT_RDATAR_RDATACH_Msk = 0x7

	// FLT.AWHTR: analog watchdog high threshold register
	// Position of AWHT field.
	DFSDM_FLT_AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_FLT_AWHTR_AWHT_Msk = 0xffffff00
	// Position of BKAWH field.
	DFSDM_FLT_AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_FLT_AWHTR_BKAWH_Msk = 0xf

	// FLT.AWLTR: analog watchdog low threshold register
	// Position of AWLT field.
	DFSDM_FLT_AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_FLT_AWLTR_AWLT_Msk = 0xffffff00
	// Position of BKAWL field.
	DFSDM_FLT_AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_FLT_AWLTR_BKAWL_Msk = 0xf

	// FLT.AWSR: analog watchdog status register
	// Position of AWHTF field.
	DFSDM_FLT_AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_FLT_AWSR_AWHTF_Msk = 0xff00
	// Position of AWLTF field.
	DFSDM_FLT_AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_FLT_AWSR_AWLTF_Msk = 0xff

	// FLT.AWCFR: analog watchdog clear flag register
	// Position of CLRAWHTF field.
	DFSDM_FLT_AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_FLT_AWCFR_CLRAWHTF_Msk = 0xff00
	// Position of CLRAWLTF field.
	DFSDM_FLT_AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_FLT_AWCFR_CLRAWLTF_Msk = 0xff

	// FLT.EXMAX: Extremes detector maximum register
	// Position of EXMAX field.
	DFSDM_FLT_EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_FLT_EXMAX_EXMAX_Msk = 0xffffff00
	// Position of EXMAXCH field.
	DFSDM_FLT_EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_FLT_EXMAX_EXMAXCH_Msk = 0x7

	// FLT.EXMIN: Extremes detector minimum register
	// Position of EXMIN field.
	DFSDM_FLT_EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_FLT_EXMIN_EXMIN_Msk = 0xffffff00
	// Position of EXMINCH field.
	DFSDM_FLT_EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_FLT_EXMIN_EXMINCH_Msk = 0x7

	// FLT.FLTCNVTIMR: conversion timer register
	// Position of CNVCNT field.
	DFSDM_FLT_FLTCNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_FLT_FLTCNVTIMR_CNVCNT_Msk = 0xfffffff0
)

// Constants for DMA1: DMA controller
const (
	// LISR: low interrupt status register
	// Position of TCIF3 field.
	DMA_LISR_TCIF3_Pos = 0x1b
	// Bit mask of TCIF3 field.
	DMA_LISR_TCIF3_Msk = 0x8000000
	// Bit TCIF3.
	DMA_LISR_TCIF3 = 0x8000000
	// No transfer complete event on stream x
	DMA_LISR_TCIF3_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF3_Complete = 0x1
	// Position of HTIF3 field.
	DMA_LISR_HTIF3_Pos = 0x1a
	// Bit mask of HTIF3 field.
	DMA_LISR_HTIF3_Msk = 0x4000000
	// Bit HTIF3.
	DMA_LISR_HTIF3 = 0x4000000
	// No half transfer event on stream x
	DMA_LISR_HTIF3_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF3_Half = 0x1
	// Position of TEIF3 field.
	DMA_LISR_TEIF3_Pos = 0x19
	// Bit mask of TEIF3 field.
	DMA_LISR_TEIF3_Msk = 0x2000000
	// Bit TEIF3.
	DMA_LISR_TEIF3 = 0x2000000
	// No transfer error on stream x
	DMA_LISR_TEIF3_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF3_Error = 0x1
	// Position of DMEIF3 field.
	DMA_LISR_DMEIF3_Pos = 0x18
	// Bit mask of DMEIF3 field.
	DMA_LISR_DMEIF3_Msk = 0x1000000
	// Bit DMEIF3.
	DMA_LISR_DMEIF3 = 0x1000000
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF3_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF3_Error = 0x1
	// Position of FEIF3 field.
	DMA_LISR_FEIF3_Pos = 0x16
	// Bit mask of FEIF3 field.
	DMA_LISR_FEIF3_Msk = 0x400000
	// Bit FEIF3.
	DMA_LISR_FEIF3 = 0x400000
	// No FIFO error event on stream x
	DMA_LISR_FEIF3_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF3_Error = 0x1
	// Position of TCIF2 field.
	DMA_LISR_TCIF2_Pos = 0x15
	// Bit mask of TCIF2 field.
	DMA_LISR_TCIF2_Msk = 0x200000
	// Bit TCIF2.
	DMA_LISR_TCIF2 = 0x200000
	// No transfer complete event on stream x
	DMA_LISR_TCIF2_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF2_Complete = 0x1
	// Position of HTIF2 field.
	DMA_LISR_HTIF2_Pos = 0x14
	// Bit mask of HTIF2 field.
	DMA_LISR_HTIF2_Msk = 0x100000
	// Bit HTIF2.
	DMA_LISR_HTIF2 = 0x100000
	// No half transfer event on stream x
	DMA_LISR_HTIF2_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF2_Half = 0x1
	// Position of TEIF2 field.
	DMA_LISR_TEIF2_Pos = 0x13
	// Bit mask of TEIF2 field.
	DMA_LISR_TEIF2_Msk = 0x80000
	// Bit TEIF2.
	DMA_LISR_TEIF2 = 0x80000
	// No transfer error on stream x
	DMA_LISR_TEIF2_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF2_Error = 0x1
	// Position of DMEIF2 field.
	DMA_LISR_DMEIF2_Pos = 0x12
	// Bit mask of DMEIF2 field.
	DMA_LISR_DMEIF2_Msk = 0x40000
	// Bit DMEIF2.
	DMA_LISR_DMEIF2 = 0x40000
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF2_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF2_Error = 0x1
	// Position of FEIF2 field.
	DMA_LISR_FEIF2_Pos = 0x10
	// Bit mask of FEIF2 field.
	DMA_LISR_FEIF2_Msk = 0x10000
	// Bit FEIF2.
	DMA_LISR_FEIF2 = 0x10000
	// No FIFO error event on stream x
	DMA_LISR_FEIF2_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF2_Error = 0x1
	// Position of TCIF1 field.
	DMA_LISR_TCIF1_Pos = 0xb
	// Bit mask of TCIF1 field.
	DMA_LISR_TCIF1_Msk = 0x800
	// Bit TCIF1.
	DMA_LISR_TCIF1 = 0x800
	// No transfer complete event on stream x
	DMA_LISR_TCIF1_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF1_Complete = 0x1
	// Position of HTIF1 field.
	DMA_LISR_HTIF1_Pos = 0xa
	// Bit mask of HTIF1 field.
	DMA_LISR_HTIF1_Msk = 0x400
	// Bit HTIF1.
	DMA_LISR_HTIF1 = 0x400
	// No half transfer event on stream x
	DMA_LISR_HTIF1_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF1_Half = 0x1
	// Position of TEIF1 field.
	DMA_LISR_TEIF1_Pos = 0x9
	// Bit mask of TEIF1 field.
	DMA_LISR_TEIF1_Msk = 0x200
	// Bit TEIF1.
	DMA_LISR_TEIF1 = 0x200
	// No transfer error on stream x
	DMA_LISR_TEIF1_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF1_Error = 0x1
	// Position of DMEIF1 field.
	DMA_LISR_DMEIF1_Pos = 0x8
	// Bit mask of DMEIF1 field.
	DMA_LISR_DMEIF1_Msk = 0x100
	// Bit DMEIF1.
	DMA_LISR_DMEIF1 = 0x100
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF1_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF1_Error = 0x1
	// Position of FEIF1 field.
	DMA_LISR_FEIF1_Pos = 0x6
	// Bit mask of FEIF1 field.
	DMA_LISR_FEIF1_Msk = 0x40
	// Bit FEIF1.
	DMA_LISR_FEIF1 = 0x40
	// No FIFO error event on stream x
	DMA_LISR_FEIF1_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF1_Error = 0x1
	// Position of TCIF0 field.
	DMA_LISR_TCIF0_Pos = 0x5
	// Bit mask of TCIF0 field.
	DMA_LISR_TCIF0_Msk = 0x20
	// Bit TCIF0.
	DMA_LISR_TCIF0 = 0x20
	// No transfer complete event on stream x
	DMA_LISR_TCIF0_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF0_Complete = 0x1
	// Position of HTIF0 field.
	DMA_LISR_HTIF0_Pos = 0x4
	// Bit mask of HTIF0 field.
	DMA_LISR_HTIF0_Msk = 0x10
	// Bit HTIF0.
	DMA_LISR_HTIF0 = 0x10
	// No half transfer event on stream x
	DMA_LISR_HTIF0_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF0_Half = 0x1
	// Position of TEIF0 field.
	DMA_LISR_TEIF0_Pos = 0x3
	// Bit mask of TEIF0 field.
	DMA_LISR_TEIF0_Msk = 0x8
	// Bit TEIF0.
	DMA_LISR_TEIF0 = 0x8
	// No transfer error on stream x
	DMA_LISR_TEIF0_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF0_Error = 0x1
	// Position of DMEIF0 field.
	DMA_LISR_DMEIF0_Pos = 0x2
	// Bit mask of DMEIF0 field.
	DMA_LISR_DMEIF0_Msk = 0x4
	// Bit DMEIF0.
	DMA_LISR_DMEIF0 = 0x4
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF0_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF0_Error = 0x1
	// Position of FEIF0 field.
	DMA_LISR_FEIF0_Pos = 0x0
	// Bit mask of FEIF0 field.
	DMA_LISR_FEIF0_Msk = 0x1
	// Bit FEIF0.
	DMA_LISR_FEIF0 = 0x1
	// No FIFO error event on stream x
	DMA_LISR_FEIF0_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF0_Error = 0x1

	// HISR: high interrupt status register
	// Position of TCIF7 field.
	DMA_HISR_TCIF7_Pos = 0x1b
	// Bit mask of TCIF7 field.
	DMA_HISR_TCIF7_Msk = 0x8000000
	// Bit TCIF7.
	DMA_HISR_TCIF7 = 0x8000000
	// No transfer complete event on stream x
	DMA_HISR_TCIF7_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF7_Complete = 0x1
	// Position of HTIF7 field.
	DMA_HISR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA_HISR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA_HISR_HTIF7 = 0x4000000
	// No half transfer event on stream x
	DMA_HISR_HTIF7_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF7_Half = 0x1
	// Position of TEIF7 field.
	DMA_HISR_TEIF7_Pos = 0x19
	// Bit mask of TEIF7 field.
	DMA_HISR_TEIF7_Msk = 0x2000000
	// Bit TEIF7.
	DMA_HISR_TEIF7 = 0x2000000
	// No transfer error on stream x
	DMA_HISR_TEIF7_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF7_Error = 0x1
	// Position of DMEIF7 field.
	DMA_HISR_DMEIF7_Pos = 0x18
	// Bit mask of DMEIF7 field.
	DMA_HISR_DMEIF7_Msk = 0x1000000
	// Bit DMEIF7.
	DMA_HISR_DMEIF7 = 0x1000000
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF7_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF7_Error = 0x1
	// Position of FEIF7 field.
	DMA_HISR_FEIF7_Pos = 0x16
	// Bit mask of FEIF7 field.
	DMA_HISR_FEIF7_Msk = 0x400000
	// Bit FEIF7.
	DMA_HISR_FEIF7 = 0x400000
	// No FIFO error event on stream x
	DMA_HISR_FEIF7_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF7_Error = 0x1
	// Position of TCIF6 field.
	DMA_HISR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA_HISR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA_HISR_TCIF6 = 0x200000
	// No transfer complete event on stream x
	DMA_HISR_TCIF6_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF6_Complete = 0x1
	// Position of HTIF6 field.
	DMA_HISR_HTIF6_Pos = 0x14
	// Bit mask of HTIF6 field.
	DMA_HISR_HTIF6_Msk = 0x100000
	// Bit HTIF6.
	DMA_HISR_HTIF6 = 0x100000
	// No half transfer event on stream x
	DMA_HISR_HTIF6_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF6_Half = 0x1
	// Position of TEIF6 field.
	DMA_HISR_TEIF6_Pos = 0x13
	// Bit mask of TEIF6 field.
	DMA_HISR_TEIF6_Msk = 0x80000
	// Bit TEIF6.
	DMA_HISR_TEIF6 = 0x80000
	// No transfer error on stream x
	DMA_HISR_TEIF6_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF6_Error = 0x1
	// Position of DMEIF6 field.
	DMA_HISR_DMEIF6_Pos = 0x12
	// Bit mask of DMEIF6 field.
	DMA_HISR_DMEIF6_Msk = 0x40000
	// Bit DMEIF6.
	DMA_HISR_DMEIF6 = 0x40000
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF6_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF6_Error = 0x1
	// Position of FEIF6 field.
	DMA_HISR_FEIF6_Pos = 0x10
	// Bit mask of FEIF6 field.
	DMA_HISR_FEIF6_Msk = 0x10000
	// Bit FEIF6.
	DMA_HISR_FEIF6 = 0x10000
	// No FIFO error event on stream x
	DMA_HISR_FEIF6_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF6_Error = 0x1
	// Position of TCIF5 field.
	DMA_HISR_TCIF5_Pos = 0xb
	// Bit mask of TCIF5 field.
	DMA_HISR_TCIF5_Msk = 0x800
	// Bit TCIF5.
	DMA_HISR_TCIF5 = 0x800
	// No transfer complete event on stream x
	DMA_HISR_TCIF5_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF5_Complete = 0x1
	// Position of HTIF5 field.
	DMA_HISR_HTIF5_Pos = 0xa
	// Bit mask of HTIF5 field.
	DMA_HISR_HTIF5_Msk = 0x400
	// Bit HTIF5.
	DMA_HISR_HTIF5 = 0x400
	// No half transfer event on stream x
	DMA_HISR_HTIF5_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF5_Half = 0x1
	// Position of TEIF5 field.
	DMA_HISR_TEIF5_Pos = 0x9
	// Bit mask of TEIF5 field.
	DMA_HISR_TEIF5_Msk = 0x200
	// Bit TEIF5.
	DMA_HISR_TEIF5 = 0x200
	// No transfer error on stream x
	DMA_HISR_TEIF5_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF5_Error = 0x1
	// Position of DMEIF5 field.
	DMA_HISR_DMEIF5_Pos = 0x8
	// Bit mask of DMEIF5 field.
	DMA_HISR_DMEIF5_Msk = 0x100
	// Bit DMEIF5.
	DMA_HISR_DMEIF5 = 0x100
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF5_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF5_Error = 0x1
	// Position of FEIF5 field.
	DMA_HISR_FEIF5_Pos = 0x6
	// Bit mask of FEIF5 field.
	DMA_HISR_FEIF5_Msk = 0x40
	// Bit FEIF5.
	DMA_HISR_FEIF5 = 0x40
	// No FIFO error event on stream x
	DMA_HISR_FEIF5_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF5_Error = 0x1
	// Position of TCIF4 field.
	DMA_HISR_TCIF4_Pos = 0x5
	// Bit mask of TCIF4 field.
	DMA_HISR_TCIF4_Msk = 0x20
	// Bit TCIF4.
	DMA_HISR_TCIF4 = 0x20
	// No transfer complete event on stream x
	DMA_HISR_TCIF4_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF4_Complete = 0x1
	// Position of HTIF4 field.
	DMA_HISR_HTIF4_Pos = 0x4
	// Bit mask of HTIF4 field.
	DMA_HISR_HTIF4_Msk = 0x10
	// Bit HTIF4.
	DMA_HISR_HTIF4 = 0x10
	// No half transfer event on stream x
	DMA_HISR_HTIF4_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF4_Half = 0x1
	// Position of TEIF4 field.
	DMA_HISR_TEIF4_Pos = 0x3
	// Bit mask of TEIF4 field.
	DMA_HISR_TEIF4_Msk = 0x8
	// Bit TEIF4.
	DMA_HISR_TEIF4 = 0x8
	// No transfer error on stream x
	DMA_HISR_TEIF4_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF4_Error = 0x1
	// Position of DMEIF4 field.
	DMA_HISR_DMEIF4_Pos = 0x2
	// Bit mask of DMEIF4 field.
	DMA_HISR_DMEIF4_Msk = 0x4
	// Bit DMEIF4.
	DMA_HISR_DMEIF4 = 0x4
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF4_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF4_Error = 0x1
	// Position of FEIF4 field.
	DMA_HISR_FEIF4_Pos = 0x0
	// Bit mask of FEIF4 field.
	DMA_HISR_FEIF4_Msk = 0x1
	// Bit FEIF4.
	DMA_HISR_FEIF4 = 0x1
	// No FIFO error event on stream x
	DMA_HISR_FEIF4_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF4_Error = 0x1

	// LIFCR: low interrupt flag clear register
	// Position of CTCIF3 field.
	DMA_LIFCR_CTCIF3_Pos = 0x1b
	// Bit mask of CTCIF3 field.
	DMA_LIFCR_CTCIF3_Msk = 0x8000000
	// Bit CTCIF3.
	DMA_LIFCR_CTCIF3 = 0x8000000
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF3_Clear = 0x1
	// Position of CHTIF3 field.
	DMA_LIFCR_CHTIF3_Pos = 0x1a
	// Bit mask of CHTIF3 field.
	DMA_LIFCR_CHTIF3_Msk = 0x4000000
	// Bit CHTIF3.
	DMA_LIFCR_CHTIF3 = 0x4000000
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF3_Clear = 0x1
	// Position of CTEIF3 field.
	DMA_LIFCR_CTEIF3_Pos = 0x19
	// Bit mask of CTEIF3 field.
	DMA_LIFCR_CTEIF3_Msk = 0x2000000
	// Bit CTEIF3.
	DMA_LIFCR_CTEIF3 = 0x2000000
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF3_Clear = 0x1
	// Position of CDMEIF3 field.
	DMA_LIFCR_CDMEIF3_Pos = 0x18
	// Bit mask of CDMEIF3 field.
	DMA_LIFCR_CDMEIF3_Msk = 0x1000000
	// Bit CDMEIF3.
	DMA_LIFCR_CDMEIF3 = 0x1000000
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF3_Clear = 0x1
	// Position of CFEIF3 field.
	DMA_LIFCR_CFEIF3_Pos = 0x16
	// Bit mask of CFEIF3 field.
	DMA_LIFCR_CFEIF3_Msk = 0x400000
	// Bit CFEIF3.
	DMA_LIFCR_CFEIF3 = 0x400000
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF3_Clear = 0x1
	// Position of CTCIF2 field.
	DMA_LIFCR_CTCIF2_Pos = 0x15
	// Bit mask of CTCIF2 field.
	DMA_LIFCR_CTCIF2_Msk = 0x200000
	// Bit CTCIF2.
	DMA_LIFCR_CTCIF2 = 0x200000
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF2_Clear = 0x1
	// Position of CHTIF2 field.
	DMA_LIFCR_CHTIF2_Pos = 0x14
	// Bit mask of CHTIF2 field.
	DMA_LIFCR_CHTIF2_Msk = 0x100000
	// Bit CHTIF2.
	DMA_LIFCR_CHTIF2 = 0x100000
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF2_Clear = 0x1
	// Position of CTEIF2 field.
	DMA_LIFCR_CTEIF2_Pos = 0x13
	// Bit mask of CTEIF2 field.
	DMA_LIFCR_CTEIF2_Msk = 0x80000
	// Bit CTEIF2.
	DMA_LIFCR_CTEIF2 = 0x80000
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF2_Clear = 0x1
	// Position of CDMEIF2 field.
	DMA_LIFCR_CDMEIF2_Pos = 0x12
	// Bit mask of CDMEIF2 field.
	DMA_LIFCR_CDMEIF2_Msk = 0x40000
	// Bit CDMEIF2.
	DMA_LIFCR_CDMEIF2 = 0x40000
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF2_Clear = 0x1
	// Position of CFEIF2 field.
	DMA_LIFCR_CFEIF2_Pos = 0x10
	// Bit mask of CFEIF2 field.
	DMA_LIFCR_CFEIF2_Msk = 0x10000
	// Bit CFEIF2.
	DMA_LIFCR_CFEIF2 = 0x10000
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF2_Clear = 0x1
	// Position of CTCIF1 field.
	DMA_LIFCR_CTCIF1_Pos = 0xb
	// Bit mask of CTCIF1 field.
	DMA_LIFCR_CTCIF1_Msk = 0x800
	// Bit CTCIF1.
	DMA_LIFCR_CTCIF1 = 0x800
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF1_Clear = 0x1
	// Position of CHTIF1 field.
	DMA_LIFCR_CHTIF1_Pos = 0xa
	// Bit mask of CHTIF1 field.
	DMA_LIFCR_CHTIF1_Msk = 0x400
	// Bit CHTIF1.
	DMA_LIFCR_CHTIF1 = 0x400
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF1_Clear = 0x1
	// Position of CTEIF1 field.
	DMA_LIFCR_CTEIF1_Pos = 0x9
	// Bit mask of CTEIF1 field.
	DMA_LIFCR_CTEIF1_Msk = 0x200
	// Bit CTEIF1.
	DMA_LIFCR_CTEIF1 = 0x200
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF1_Clear = 0x1
	// Position of CDMEIF1 field.
	DMA_LIFCR_CDMEIF1_Pos = 0x8
	// Bit mask of CDMEIF1 field.
	DMA_LIFCR_CDMEIF1_Msk = 0x100
	// Bit CDMEIF1.
	DMA_LIFCR_CDMEIF1 = 0x100
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF1_Clear = 0x1
	// Position of CFEIF1 field.
	DMA_LIFCR_CFEIF1_Pos = 0x6
	// Bit mask of CFEIF1 field.
	DMA_LIFCR_CFEIF1_Msk = 0x40
	// Bit CFEIF1.
	DMA_LIFCR_CFEIF1 = 0x40
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF1_Clear = 0x1
	// Position of CTCIF0 field.
	DMA_LIFCR_CTCIF0_Pos = 0x5
	// Bit mask of CTCIF0 field.
	DMA_LIFCR_CTCIF0_Msk = 0x20
	// Bit CTCIF0.
	DMA_LIFCR_CTCIF0 = 0x20
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF0_Clear = 0x1
	// Position of CHTIF0 field.
	DMA_LIFCR_CHTIF0_Pos = 0x4
	// Bit mask of CHTIF0 field.
	DMA_LIFCR_CHTIF0_Msk = 0x10
	// Bit CHTIF0.
	DMA_LIFCR_CHTIF0 = 0x10
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF0_Clear = 0x1
	// Position of CTEIF0 field.
	DMA_LIFCR_CTEIF0_Pos = 0x3
	// Bit mask of CTEIF0 field.
	DMA_LIFCR_CTEIF0_Msk = 0x8
	// Bit CTEIF0.
	DMA_LIFCR_CTEIF0 = 0x8
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF0_Clear = 0x1
	// Position of CDMEIF0 field.
	DMA_LIFCR_CDMEIF0_Pos = 0x2
	// Bit mask of CDMEIF0 field.
	DMA_LIFCR_CDMEIF0_Msk = 0x4
	// Bit CDMEIF0.
	DMA_LIFCR_CDMEIF0 = 0x4
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF0_Clear = 0x1
	// Position of CFEIF0 field.
	DMA_LIFCR_CFEIF0_Pos = 0x0
	// Bit mask of CFEIF0 field.
	DMA_LIFCR_CFEIF0_Msk = 0x1
	// Bit CFEIF0.
	DMA_LIFCR_CFEIF0 = 0x1
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF0_Clear = 0x1
	// Position of TRBUFF field.
	DMA_LIFCR_TRBUFF_Pos = 0x14
	// Bit mask of TRBUFF field.
	DMA_LIFCR_TRBUFF_Msk = 0x100000
	// Bit TRBUFF.
	DMA_LIFCR_TRBUFF = 0x100000
	// Bufferable transfers not enabled
	DMA_LIFCR_TRBUFF_Disabled = 0x0
	// Bufferable transfers enabled
	DMA_LIFCR_TRBUFF_Enabled = 0x1

	// HIFCR: high interrupt flag clear register
	// Position of CTCIF7 field.
	DMA_HIFCR_CTCIF7_Pos = 0x1b
	// Bit mask of CTCIF7 field.
	DMA_HIFCR_CTCIF7_Msk = 0x8000000
	// Bit CTCIF7.
	DMA_HIFCR_CTCIF7 = 0x8000000
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF7_Clear = 0x1
	// Position of CHTIF7 field.
	DMA_HIFCR_CHTIF7_Pos = 0x1a
	// Bit mask of CHTIF7 field.
	DMA_HIFCR_CHTIF7_Msk = 0x4000000
	// Bit CHTIF7.
	DMA_HIFCR_CHTIF7 = 0x4000000
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF7_Clear = 0x1
	// Position of CTEIF7 field.
	DMA_HIFCR_CTEIF7_Pos = 0x19
	// Bit mask of CTEIF7 field.
	DMA_HIFCR_CTEIF7_Msk = 0x2000000
	// Bit CTEIF7.
	DMA_HIFCR_CTEIF7 = 0x2000000
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF7_Clear = 0x1
	// Position of CDMEIF7 field.
	DMA_HIFCR_CDMEIF7_Pos = 0x18
	// Bit mask of CDMEIF7 field.
	DMA_HIFCR_CDMEIF7_Msk = 0x1000000
	// Bit CDMEIF7.
	DMA_HIFCR_CDMEIF7 = 0x1000000
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF7_Clear = 0x1
	// Position of CFEIF7 field.
	DMA_HIFCR_CFEIF7_Pos = 0x16
	// Bit mask of CFEIF7 field.
	DMA_HIFCR_CFEIF7_Msk = 0x400000
	// Bit CFEIF7.
	DMA_HIFCR_CFEIF7 = 0x400000
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF7_Clear = 0x1
	// Position of CTCIF6 field.
	DMA_HIFCR_CTCIF6_Pos = 0x15
	// Bit mask of CTCIF6 field.
	DMA_HIFCR_CTCIF6_Msk = 0x200000
	// Bit CTCIF6.
	DMA_HIFCR_CTCIF6 = 0x200000
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF6_Clear = 0x1
	// Position of CHTIF6 field.
	DMA_HIFCR_CHTIF6_Pos = 0x14
	// Bit mask of CHTIF6 field.
	DMA_HIFCR_CHTIF6_Msk = 0x100000
	// Bit CHTIF6.
	DMA_HIFCR_CHTIF6 = 0x100000
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF6_Clear = 0x1
	// Position of CTEIF6 field.
	DMA_HIFCR_CTEIF6_Pos = 0x13
	// Bit mask of CTEIF6 field.
	DMA_HIFCR_CTEIF6_Msk = 0x80000
	// Bit CTEIF6.
	DMA_HIFCR_CTEIF6 = 0x80000
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF6_Clear = 0x1
	// Position of CDMEIF6 field.
	DMA_HIFCR_CDMEIF6_Pos = 0x12
	// Bit mask of CDMEIF6 field.
	DMA_HIFCR_CDMEIF6_Msk = 0x40000
	// Bit CDMEIF6.
	DMA_HIFCR_CDMEIF6 = 0x40000
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF6_Clear = 0x1
	// Position of CFEIF6 field.
	DMA_HIFCR_CFEIF6_Pos = 0x10
	// Bit mask of CFEIF6 field.
	DMA_HIFCR_CFEIF6_Msk = 0x10000
	// Bit CFEIF6.
	DMA_HIFCR_CFEIF6 = 0x10000
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF6_Clear = 0x1
	// Position of CTCIF5 field.
	DMA_HIFCR_CTCIF5_Pos = 0xb
	// Bit mask of CTCIF5 field.
	DMA_HIFCR_CTCIF5_Msk = 0x800
	// Bit CTCIF5.
	DMA_HIFCR_CTCIF5 = 0x800
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF5_Clear = 0x1
	// Position of CHTIF5 field.
	DMA_HIFCR_CHTIF5_Pos = 0xa
	// Bit mask of CHTIF5 field.
	DMA_HIFCR_CHTIF5_Msk = 0x400
	// Bit CHTIF5.
	DMA_HIFCR_CHTIF5 = 0x400
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF5_Clear = 0x1
	// Position of CTEIF5 field.
	DMA_HIFCR_CTEIF5_Pos = 0x9
	// Bit mask of CTEIF5 field.
	DMA_HIFCR_CTEIF5_Msk = 0x200
	// Bit CTEIF5.
	DMA_HIFCR_CTEIF5 = 0x200
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF5_Clear = 0x1
	// Position of CDMEIF5 field.
	DMA_HIFCR_CDMEIF5_Pos = 0x8
	// Bit mask of CDMEIF5 field.
	DMA_HIFCR_CDMEIF5_Msk = 0x100
	// Bit CDMEIF5.
	DMA_HIFCR_CDMEIF5 = 0x100
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF5_Clear = 0x1
	// Position of CFEIF5 field.
	DMA_HIFCR_CFEIF5_Pos = 0x6
	// Bit mask of CFEIF5 field.
	DMA_HIFCR_CFEIF5_Msk = 0x40
	// Bit CFEIF5.
	DMA_HIFCR_CFEIF5 = 0x40
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF5_Clear = 0x1
	// Position of CTCIF4 field.
	DMA_HIFCR_CTCIF4_Pos = 0x5
	// Bit mask of CTCIF4 field.
	DMA_HIFCR_CTCIF4_Msk = 0x20
	// Bit CTCIF4.
	DMA_HIFCR_CTCIF4 = 0x20
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF4_Clear = 0x1
	// Position of CHTIF4 field.
	DMA_HIFCR_CHTIF4_Pos = 0x4
	// Bit mask of CHTIF4 field.
	DMA_HIFCR_CHTIF4_Msk = 0x10
	// Bit CHTIF4.
	DMA_HIFCR_CHTIF4 = 0x10
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF4_Clear = 0x1
	// Position of CTEIF4 field.
	DMA_HIFCR_CTEIF4_Pos = 0x3
	// Bit mask of CTEIF4 field.
	DMA_HIFCR_CTEIF4_Msk = 0x8
	// Bit CTEIF4.
	DMA_HIFCR_CTEIF4 = 0x8
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF4_Clear = 0x1
	// Position of CDMEIF4 field.
	DMA_HIFCR_CDMEIF4_Pos = 0x2
	// Bit mask of CDMEIF4 field.
	DMA_HIFCR_CDMEIF4_Msk = 0x4
	// Bit CDMEIF4.
	DMA_HIFCR_CDMEIF4 = 0x4
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF4_Clear = 0x1
	// Position of CFEIF4 field.
	DMA_HIFCR_CFEIF4_Pos = 0x0
	// Bit mask of CFEIF4 field.
	DMA_HIFCR_CFEIF4_Msk = 0x1
	// Bit CFEIF4.
	DMA_HIFCR_CFEIF4 = 0x1
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF4_Clear = 0x1
	// Position of TRBUFF field.
	DMA_HIFCR_TRBUFF_Pos = 0x14
	// Bit mask of TRBUFF field.
	DMA_HIFCR_TRBUFF_Msk = 0x100000
	// Bit TRBUFF.
	DMA_HIFCR_TRBUFF = 0x100000
	// Bufferable transfers not enabled
	DMA_HIFCR_TRBUFF_Disabled = 0x0
	// Bufferable transfers enabled
	DMA_HIFCR_TRBUFF_Enabled = 0x1

	// ST.CR: stream x configuration register
	// Position of MBURST field.
	DMA_ST_CR_MBURST_Pos = 0x17
	// Bit mask of MBURST field.
	DMA_ST_CR_MBURST_Msk = 0x1800000
	// Single transfer
	DMA_ST_CR_MBURST_Single = 0x0
	// Incremental burst of 4 beats
	DMA_ST_CR_MBURST_INCR4 = 0x1
	// Incremental burst of 8 beats
	DMA_ST_CR_MBURST_INCR8 = 0x2
	// Incremental burst of 16 beats
	DMA_ST_CR_MBURST_INCR16 = 0x3
	// Position of PBURST field.
	DMA_ST_CR_PBURST_Pos = 0x15
	// Bit mask of PBURST field.
	DMA_ST_CR_PBURST_Msk = 0x600000
	// Single transfer
	DMA_ST_CR_PBURST_Single = 0x0
	// Incremental burst of 4 beats
	DMA_ST_CR_PBURST_INCR4 = 0x1
	// Incremental burst of 8 beats
	DMA_ST_CR_PBURST_INCR8 = 0x2
	// Incremental burst of 16 beats
	DMA_ST_CR_PBURST_INCR16 = 0x3
	// Position of CT field.
	DMA_ST_CR_CT_Pos = 0x13
	// Bit mask of CT field.
	DMA_ST_CR_CT_Msk = 0x80000
	// Bit CT.
	DMA_ST_CR_CT = 0x80000
	// The current target memory is Memory 0
	DMA_ST_CR_CT_Memory0 = 0x0
	// The current target memory is Memory 1
	DMA_ST_CR_CT_Memory1 = 0x1
	// Position of DBM field.
	DMA_ST_CR_DBM_Pos = 0x12
	// Bit mask of DBM field.
	DMA_ST_CR_DBM_Msk = 0x40000
	// Bit DBM.
	DMA_ST_CR_DBM = 0x40000
	// No buffer switching at the end of transfer
	DMA_ST_CR_DBM_Disabled = 0x0
	// Memory target switched at the end of the DMA transfer
	DMA_ST_CR_DBM_Enabled = 0x1
	// Position of PL field.
	DMA_ST_CR_PL_Pos = 0x10
	// Bit mask of PL field.
	DMA_ST_CR_PL_Msk = 0x30000
	// Low
	DMA_ST_CR_PL_Low = 0x0
	// Medium
	DMA_ST_CR_PL_Medium = 0x1
	// High
	DMA_ST_CR_PL_High = 0x2
	// Very high
	DMA_ST_CR_PL_VeryHigh = 0x3
	// Position of PINCOS field.
	DMA_ST_CR_PINCOS_Pos = 0xf
	// Bit mask of PINCOS field.
	DMA_ST_CR_PINCOS_Msk = 0x8000
	// Bit PINCOS.
	DMA_ST_CR_PINCOS = 0x8000
	// The offset size for the peripheral address calculation is linked to the PSIZE
	DMA_ST_CR_PINCOS_PSIZE = 0x0
	// The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
	DMA_ST_CR_PINCOS_Fixed4 = 0x1
	// Position of MSIZE field.
	DMA_ST_CR_MSIZE_Pos = 0xd
	// Bit mask of MSIZE field.
	DMA_ST_CR_MSIZE_Msk = 0x6000
	// Byte (8-bit)
	DMA_ST_CR_MSIZE_Bits8 = 0x0
	// Half-word (16-bit)
	DMA_ST_CR_MSIZE_Bits16 = 0x1
	// Word (32-bit)
	DMA_ST_CR_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_ST_CR_PSIZE_Pos = 0xb
	// Bit mask of PSIZE field.
	DMA_ST_CR_PSIZE_Msk = 0x1800
	// Byte (8-bit)
	DMA_ST_CR_PSIZE_Bits8 = 0x0
	// Half-word (16-bit)
	DMA_ST_CR_PSIZE_Bits16 = 0x1
	// Word (32-bit)
	DMA_ST_CR_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_ST_CR_MINC_Pos = 0xa
	// Bit mask of MINC field.
	DMA_ST_CR_MINC_Msk = 0x400
	// Bit MINC.
	DMA_ST_CR_MINC = 0x400
	// Address pointer is fixed
	DMA_ST_CR_MINC_Fixed = 0x0
	// Address pointer is incremented after each data transfer
	DMA_ST_CR_MINC_Incremented = 0x1
	// Position of PINC field.
	DMA_ST_CR_PINC_Pos = 0x9
	// Bit mask of PINC field.
	DMA_ST_CR_PINC_Msk = 0x200
	// Bit PINC.
	DMA_ST_CR_PINC = 0x200
	// Address pointer is fixed
	DMA_ST_CR_PINC_Fixed = 0x0
	// Address pointer is incremented after each data transfer
	DMA_ST_CR_PINC_Incremented = 0x1
	// Position of CIRC field.
	DMA_ST_CR_CIRC_Pos = 0x8
	// Bit mask of CIRC field.
	DMA_ST_CR_CIRC_Msk = 0x100
	// Bit CIRC.
	DMA_ST_CR_CIRC = 0x100
	// Circular mode disabled
	DMA_ST_CR_CIRC_Disabled = 0x0
	// Circular mode enabled
	DMA_ST_CR_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_ST_CR_DIR_Pos = 0x6
	// Bit mask of DIR field.
	DMA_ST_CR_DIR_Msk = 0xc0
	// Peripheral-to-memory
	DMA_ST_CR_DIR_PeripheralToMemory = 0x0
	// Memory-to-peripheral
	DMA_ST_CR_DIR_MemoryToPeripheral = 0x1
	// Memory-to-memory
	DMA_ST_CR_DIR_MemoryToMemory = 0x2
	// Position of PFCTRL field.
	DMA_ST_CR_PFCTRL_Pos = 0x5
	// Bit mask of PFCTRL field.
	DMA_ST_CR_PFCTRL_Msk = 0x20
	// Bit PFCTRL.
	DMA_ST_CR_PFCTRL = 0x20
	// The DMA is the flow controller
	DMA_ST_CR_PFCTRL_DMA = 0x0
	// The peripheral is the flow controller
	DMA_ST_CR_PFCTRL_Peripheral = 0x1
	// Position of TCIE field.
	DMA_ST_CR_TCIE_Pos = 0x4
	// Bit mask of TCIE field.
	DMA_ST_CR_TCIE_Msk = 0x10
	// Bit TCIE.
	DMA_ST_CR_TCIE = 0x10
	// TC interrupt disabled
	DMA_ST_CR_TCIE_Disabled = 0x0
	// TC interrupt enabled
	DMA_ST_CR_TCIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_ST_CR_HTIE_Pos = 0x3
	// Bit mask of HTIE field.
	DMA_ST_CR_HTIE_Msk = 0x8
	// Bit HTIE.
	DMA_ST_CR_HTIE = 0x8
	// HT interrupt disabled
	DMA_ST_CR_HTIE_Disabled = 0x0
	// HT interrupt enabled
	DMA_ST_CR_HTIE_Enabled = 0x1
	// Position of TEIE field.
	DMA_ST_CR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	DMA_ST_CR_TEIE_Msk = 0x4
	// Bit TEIE.
	DMA_ST_CR_TEIE = 0x4
	// TE interrupt disabled
	DMA_ST_CR_TEIE_Disabled = 0x0
	// TE interrupt enabled
	DMA_ST_CR_TEIE_Enabled = 0x1
	// Position of DMEIE field.
	DMA_ST_CR_DMEIE_Pos = 0x1
	// Bit mask of DMEIE field.
	DMA_ST_CR_DMEIE_Msk = 0x2
	// Bit DMEIE.
	DMA_ST_CR_DMEIE = 0x2
	// DME interrupt disabled
	DMA_ST_CR_DMEIE_Disabled = 0x0
	// DME interrupt enabled
	DMA_ST_CR_DMEIE_Enabled = 0x1
	// Position of EN field.
	DMA_ST_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_ST_CR_EN_Msk = 0x1
	// Bit EN.
	DMA_ST_CR_EN = 0x1
	// Stream disabled
	DMA_ST_CR_EN_Disabled = 0x0
	// Stream enabled
	DMA_ST_CR_EN_Enabled = 0x1
	// Position of TRBUFF field.
	DMA_ST_CR_TRBUFF_Pos = 0x14
	// Bit mask of TRBUFF field.
	DMA_ST_CR_TRBUFF_Msk = 0x100000
	// Bit TRBUFF.
	DMA_ST_CR_TRBUFF = 0x100000
	// Bufferable transfers not enabled
	DMA_ST_CR_TRBUFF_Disabled = 0x0
	// Bufferable transfers enabled
	DMA_ST_CR_TRBUFF_Enabled = 0x1

	// ST.NDTR: stream x number of data register
	// Position of NDT field.
	DMA_ST_NDTR_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_ST_NDTR_NDT_Msk = 0xffff

	// ST.PAR: stream x peripheral address register
	// Position of PA field.
	DMA_ST_PAR_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_ST_PAR_PA_Msk = 0xffffffff

	// ST.M0AR: stream x memory 0 address register
	// Position of M0A field.
	DMA_ST_M0AR_M0A_Pos = 0x0
	// Bit mask of M0A field.
	DMA_ST_M0AR_M0A_Msk = 0xffffffff

	// ST.M1AR: stream x memory 1 address register
	// Position of M1A field.
	DMA_ST_M1AR_M1A_Pos = 0x0
	// Bit mask of M1A field.
	DMA_ST_M1AR_M1A_Msk = 0xffffffff

	// ST.FCR: stream x FIFO control register
	// Position of FEIE field.
	DMA_ST_FCR_FEIE_Pos = 0x7
	// Bit mask of FEIE field.
	DMA_ST_FCR_FEIE_Msk = 0x80
	// Bit FEIE.
	DMA_ST_FCR_FEIE = 0x80
	// FE interrupt disabled
	DMA_ST_FCR_FEIE_Disabled = 0x0
	// FE interrupt enabled
	DMA_ST_FCR_FEIE_Enabled = 0x1
	// Position of FS field.
	DMA_ST_FCR_FS_Pos = 0x3
	// Bit mask of FS field.
	DMA_ST_FCR_FS_Msk = 0x38
	// 0 < fifo_level < 1/4
	DMA_ST_FCR_FS_Quarter1 = 0x0
	// 1/4 <= fifo_level < 1/2
	DMA_ST_FCR_FS_Quarter2 = 0x1
	// 1/2 <= fifo_level < 3/4
	DMA_ST_FCR_FS_Quarter3 = 0x2
	// 3/4 <= fifo_level < full
	DMA_ST_FCR_FS_Quarter4 = 0x3
	// FIFO is empty
	DMA_ST_FCR_FS_Empty = 0x4
	// FIFO is full
	DMA_ST_FCR_FS_Full = 0x5
	// Position of DMDIS field.
	DMA_ST_FCR_DMDIS_Pos = 0x2
	// Bit mask of DMDIS field.
	DMA_ST_FCR_DMDIS_Msk = 0x4
	// Bit DMDIS.
	DMA_ST_FCR_DMDIS = 0x4
	// Direct mode is enabled
	DMA_ST_FCR_DMDIS_Enabled = 0x0
	// Direct mode is disabled
	DMA_ST_FCR_DMDIS_Disabled = 0x1
	// Position of FTH field.
	DMA_ST_FCR_FTH_Pos = 0x0
	// Bit mask of FTH field.
	DMA_ST_FCR_FTH_Msk = 0x3
	// 1/4 full FIFO
	DMA_ST_FCR_FTH_Quarter = 0x0
	// 1/2 full FIFO
	DMA_ST_FCR_FTH_Half = 0x1
	// 3/4 full FIFO
	DMA_ST_FCR_FTH_ThreeQuarters = 0x2
	// Full FIFO
	DMA_ST_FCR_FTH_Full = 0x3
	// Position of TRBUFF field.
	DMA_ST_FCR_TRBUFF_Pos = 0x14
	// Bit mask of TRBUFF field.
	DMA_ST_FCR_TRBUFF_Msk = 0x100000
	// Bit TRBUFF.
	DMA_ST_FCR_TRBUFF = 0x100000
	// Bufferable transfers not enabled
	DMA_ST_FCR_TRBUFF_Disabled = 0x0
	// Bufferable transfers enabled
	DMA_ST_FCR_TRBUFF_Enabled = 0x1
)

// Constants for DMA2D: DMA2D
const (
	// CR: DMA2D control register
	// Position of START field.
	DMA2D_CR_START_Pos = 0x0
	// Bit mask of START field.
	DMA2D_CR_START_Msk = 0x1
	// Bit START.
	DMA2D_CR_START = 0x1
	// Launch the DMA2D
	DMA2D_CR_START_Start = 0x1
	// Position of SUSP field.
	DMA2D_CR_SUSP_Pos = 0x1
	// Bit mask of SUSP field.
	DMA2D_CR_SUSP_Msk = 0x2
	// Bit SUSP.
	DMA2D_CR_SUSP = 0x2
	// Transfer not suspended
	DMA2D_CR_SUSP_NotSuspended = 0x0
	// Transfer suspended
	DMA2D_CR_SUSP_Suspended = 0x1
	// Position of ABORT field.
	DMA2D_CR_ABORT_Pos = 0x2
	// Bit mask of ABORT field.
	DMA2D_CR_ABORT_Msk = 0x4
	// Bit ABORT.
	DMA2D_CR_ABORT = 0x4
	// Transfer abort requested
	DMA2D_CR_ABORT_AbortRequest = 0x1
	// Position of TEIE field.
	DMA2D_CR_TEIE_Pos = 0x8
	// Bit mask of TEIE field.
	DMA2D_CR_TEIE_Msk = 0x100
	// Bit TEIE.
	DMA2D_CR_TEIE = 0x100
	// TE interrupt disabled
	DMA2D_CR_TEIE_Disabled = 0x0
	// TE interrupt enabled
	DMA2D_CR_TEIE_Enabled = 0x1
	// Position of TCIE field.
	DMA2D_CR_TCIE_Pos = 0x9
	// Bit mask of TCIE field.
	DMA2D_CR_TCIE_Msk = 0x200
	// Bit TCIE.
	DMA2D_CR_TCIE = 0x200
	// TC interrupt disabled
	DMA2D_CR_TCIE_Disabled = 0x0
	// TC interrupt enabled
	DMA2D_CR_TCIE_Enabled = 0x1
	// Position of TWIE field.
	DMA2D_CR_TWIE_Pos = 0xa
	// Bit mask of TWIE field.
	DMA2D_CR_TWIE_Msk = 0x400
	// Bit TWIE.
	DMA2D_CR_TWIE = 0x400
	// TW interrupt disabled
	DMA2D_CR_TWIE_Disabled = 0x0
	// TW interrupt enabled
	DMA2D_CR_TWIE_Enabled = 0x1
	// Position of CAEIE field.
	DMA2D_CR_CAEIE_Pos = 0xb
	// Bit mask of CAEIE field.
	DMA2D_CR_CAEIE_Msk = 0x800
	// Bit CAEIE.
	DMA2D_CR_CAEIE = 0x800
	// CAE interrupt disabled
	DMA2D_CR_CAEIE_Disabled = 0x0
	// CAE interrupt enabled
	DMA2D_CR_CAEIE_Enabled = 0x1
	// Position of CTCIE field.
	DMA2D_CR_CTCIE_Pos = 0xc
	// Bit mask of CTCIE field.
	DMA2D_CR_CTCIE_Msk = 0x1000
	// Bit CTCIE.
	DMA2D_CR_CTCIE = 0x1000
	// CTC interrupt disabled
	DMA2D_CR_CTCIE_Disabled = 0x0
	// CTC interrupt enabled
	DMA2D_CR_CTCIE_Enabled = 0x1
	// Position of CEIE field.
	DMA2D_CR_CEIE_Pos = 0xd
	// Bit mask of CEIE field.
	DMA2D_CR_CEIE_Msk = 0x2000
	// Bit CEIE.
	DMA2D_CR_CEIE = 0x2000
	// CE interrupt disabled
	DMA2D_CR_CEIE_Disabled = 0x0
	// CE interrupt enabled
	DMA2D_CR_CEIE_Enabled = 0x1
	// Position of MODE field.
	DMA2D_CR_MODE_Pos = 0x10
	// Bit mask of MODE field.
	DMA2D_CR_MODE_Msk = 0x30000
	// Memory-to-memory (FG fetch only)
	DMA2D_CR_MODE_MemoryToMemory = 0x0
	// Memory-to-memory with PFC (FG fetch only with FG PFC active)
	DMA2D_CR_MODE_MemoryToMemoryPFC = 0x1
	// Memory-to-memory with blending (FG and BG fetch with PFC and blending)
	DMA2D_CR_MODE_MemoryToMemoryPFCBlending = 0x2
	// Register-to-memory
	DMA2D_CR_MODE_RegisterToMemory = 0x3

	// ISR: DMA2D Interrupt Status Register
	// Position of TEIF field.
	DMA2D_ISR_TEIF_Pos = 0x0
	// Bit mask of TEIF field.
	DMA2D_ISR_TEIF_Msk = 0x1
	// Bit TEIF.
	DMA2D_ISR_TEIF = 0x1
	// Position of TCIF field.
	DMA2D_ISR_TCIF_Pos = 0x1
	// Bit mask of TCIF field.
	DMA2D_ISR_TCIF_Msk = 0x2
	// Bit TCIF.
	DMA2D_ISR_TCIF = 0x2
	// Position of TWIF field.
	DMA2D_ISR_TWIF_Pos = 0x2
	// Bit mask of TWIF field.
	DMA2D_ISR_TWIF_Msk = 0x4
	// Bit TWIF.
	DMA2D_ISR_TWIF = 0x4
	// Position of CAEIF field.
	DMA2D_ISR_CAEIF_Pos = 0x3
	// Bit mask of CAEIF field.
	DMA2D_ISR_CAEIF_Msk = 0x8
	// Bit CAEIF.
	DMA2D_ISR_CAEIF = 0x8
	// Position of CTCIF field.
	DMA2D_ISR_CTCIF_Pos = 0x4
	// Bit mask of CTCIF field.
	DMA2D_ISR_CTCIF_Msk = 0x10
	// Bit CTCIF.
	DMA2D_ISR_CTCIF = 0x10
	// Position of CEIF field.
	DMA2D_ISR_CEIF_Pos = 0x5
	// Bit mask of CEIF field.
	DMA2D_ISR_CEIF_Msk = 0x20
	// Bit CEIF.
	DMA2D_ISR_CEIF = 0x20

	// IFCR: DMA2D interrupt flag clear register
	// Position of CTEIF field.
	DMA2D_IFCR_CTEIF_Pos = 0x0
	// Bit mask of CTEIF field.
	DMA2D_IFCR_CTEIF_Msk = 0x1
	// Bit CTEIF.
	DMA2D_IFCR_CTEIF = 0x1
	// Clear the TEIF flag in the ISR register
	DMA2D_IFCR_CTEIF_Clear = 0x1
	// Position of CTCIF field.
	DMA2D_IFCR_CTCIF_Pos = 0x1
	// Bit mask of CTCIF field.
	DMA2D_IFCR_CTCIF_Msk = 0x2
	// Bit CTCIF.
	DMA2D_IFCR_CTCIF = 0x2
	// Clear the TCIF flag in the ISR register
	DMA2D_IFCR_CTCIF_Clear = 0x1
	// Position of CTWIF field.
	DMA2D_IFCR_CTWIF_Pos = 0x2
	// Bit mask of CTWIF field.
	DMA2D_IFCR_CTWIF_Msk = 0x4
	// Bit CTWIF.
	DMA2D_IFCR_CTWIF = 0x4
	// Clear the TWIF flag in the ISR register
	DMA2D_IFCR_CTWIF_Clear = 0x1
	// Position of CAECIF field.
	DMA2D_IFCR_CAECIF_Pos = 0x3
	// Bit mask of CAECIF field.
	DMA2D_IFCR_CAECIF_Msk = 0x8
	// Bit CAECIF.
	DMA2D_IFCR_CAECIF = 0x8
	// Clear the CAEIF flag in the ISR register
	DMA2D_IFCR_CAECIF_Clear = 0x1
	// Position of CCTCIF field.
	DMA2D_IFCR_CCTCIF_Pos = 0x4
	// Bit mask of CCTCIF field.
	DMA2D_IFCR_CCTCIF_Msk = 0x10
	// Bit CCTCIF.
	DMA2D_IFCR_CCTCIF = 0x10
	// Clear the CTCIF flag in the ISR register
	DMA2D_IFCR_CCTCIF_Clear = 0x1
	// Position of CCEIF field.
	DMA2D_IFCR_CCEIF_Pos = 0x5
	// Bit mask of CCEIF field.
	DMA2D_IFCR_CCEIF_Msk = 0x20
	// Bit CCEIF.
	DMA2D_IFCR_CCEIF = 0x20
	// Clear the CEIF flag in the ISR register
	DMA2D_IFCR_CCEIF_Clear = 0x1

	// FGMAR: DMA2D foreground memory address register
	// Position of MA field.
	DMA2D_FGMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_FGMAR_MA_Msk = 0xffffffff

	// FGOR: DMA2D foreground offset register
	// Position of LO field.
	DMA2D_FGOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_FGOR_LO_Msk = 0xffff

	// BGMAR: DMA2D background memory address register
	// Position of MA field.
	DMA2D_BGMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_BGMAR_MA_Msk = 0xffffffff

	// BGOR: DMA2D background offset register
	// Position of LO field.
	DMA2D_BGOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_BGOR_LO_Msk = 0xffff

	// FGPFCCR: DMA2D foreground PFC control register
	// Position of CM field.
	DMA2D_FGPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_FGPFCCR_CM_Msk = 0xf
	// Color mode ARGB8888
	DMA2D_FGPFCCR_CM_ARGB8888 = 0x0
	// Color mode RGB888
	DMA2D_FGPFCCR_CM_RGB888 = 0x1
	// Color mode RGB565
	DMA2D_FGPFCCR_CM_RGB565 = 0x2
	// Color mode ARGB1555
	DMA2D_FGPFCCR_CM_ARGB1555 = 0x3
	// Color mode ARGB4444
	DMA2D_FGPFCCR_CM_ARGB4444 = 0x4
	// Color mode L8
	DMA2D_FGPFCCR_CM_L8 = 0x5
	// Color mode AL44
	DMA2D_FGPFCCR_CM_AL44 = 0x6
	// Color mode AL88
	DMA2D_FGPFCCR_CM_AL88 = 0x7
	// Color mode L4
	DMA2D_FGPFCCR_CM_L4 = 0x8
	// Color mode A8
	DMA2D_FGPFCCR_CM_A8 = 0x9
	// Color mode A4
	DMA2D_FGPFCCR_CM_A4 = 0xa
	// Color mode YCbCr
	DMA2D_FGPFCCR_CM_YCbCr = 0xb
	// Position of CCM field.
	DMA2D_FGPFCCR_CCM_Pos = 0x4
	// Bit mask of CCM field.
	DMA2D_FGPFCCR_CCM_Msk = 0x10
	// Bit CCM.
	DMA2D_FGPFCCR_CCM = 0x10
	// CLUT color format ARGB8888
	DMA2D_FGPFCCR_CCM_ARGB8888 = 0x0
	// CLUT color format RGB888
	DMA2D_FGPFCCR_CCM_RGB888 = 0x1
	// Position of START field.
	DMA2D_FGPFCCR_START_Pos = 0x5
	// Bit mask of START field.
	DMA2D_FGPFCCR_START_Msk = 0x20
	// Bit START.
	DMA2D_FGPFCCR_START = 0x20
	// Start the automatic loading of the CLUT
	DMA2D_FGPFCCR_START_Start = 0x1
	// Position of CS field.
	DMA2D_FGPFCCR_CS_Pos = 0x8
	// Bit mask of CS field.
	DMA2D_FGPFCCR_CS_Msk = 0xff00
	// Position of AM field.
	DMA2D_FGPFCCR_AM_Pos = 0x10
	// Bit mask of AM field.
	DMA2D_FGPFCCR_AM_Msk = 0x30000
	// No modification of alpha channel
	DMA2D_FGPFCCR_AM_NoModify = 0x0
	// Replace with value in ALPHA[7:0]
	DMA2D_FGPFCCR_AM_Replace = 0x1
	// Multiply with value in ALPHA[7:0]
	DMA2D_FGPFCCR_AM_Multiply = 0x2
	// Position of CSS field.
	DMA2D_FGPFCCR_CSS_Pos = 0x12
	// Bit mask of CSS field.
	DMA2D_FGPFCCR_CSS_Msk = 0xc0000
	// Position of AI field.
	DMA2D_FGPFCCR_AI_Pos = 0x14
	// Bit mask of AI field.
	DMA2D_FGPFCCR_AI_Msk = 0x100000
	// Bit AI.
	DMA2D_FGPFCCR_AI = 0x100000
	// Regular alpha
	DMA2D_FGPFCCR_AI_RegularAlpha = 0x0
	// Inverted alpha
	DMA2D_FGPFCCR_AI_InvertedAlpha = 0x1
	// Position of RBS field.
	DMA2D_FGPFCCR_RBS_Pos = 0x15
	// Bit mask of RBS field.
	DMA2D_FGPFCCR_RBS_Msk = 0x200000
	// Bit RBS.
	DMA2D_FGPFCCR_RBS = 0x200000
	// No Red Blue Swap (RGB or ARGB)
	DMA2D_FGPFCCR_RBS_Regular = 0x0
	// Red Blue Swap (BGR or ABGR)
	DMA2D_FGPFCCR_RBS_Swap = 0x1
	// Position of ALPHA field.
	DMA2D_FGPFCCR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_FGPFCCR_ALPHA_Msk = 0xff000000

	// FGCOLR: DMA2D foreground color register
	// Position of BLUE field.
	DMA2D_FGCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_FGCOLR_BLUE_Msk = 0xff
	// Position of GREEN field.
	DMA2D_FGCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_FGCOLR_GREEN_Msk = 0xff00
	// Position of RED field.
	DMA2D_FGCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_FGCOLR_RED_Msk = 0xff0000

	// BGPFCCR: DMA2D background PFC control register
	// Position of CM field.
	DMA2D_BGPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_BGPFCCR_CM_Msk = 0xf
	// Color mode ARGB8888
	DMA2D_BGPFCCR_CM_ARGB8888 = 0x0
	// Color mode RGB888
	DMA2D_BGPFCCR_CM_RGB888 = 0x1
	// Color mode RGB565
	DMA2D_BGPFCCR_CM_RGB565 = 0x2
	// Color mode ARGB1555
	DMA2D_BGPFCCR_CM_ARGB1555 = 0x3
	// Color mode ARGB4444
	DMA2D_BGPFCCR_CM_ARGB4444 = 0x4
	// Color mode L8
	DMA2D_BGPFCCR_CM_L8 = 0x5
	// Color mode AL44
	DMA2D_BGPFCCR_CM_AL44 = 0x6
	// Color mode AL88
	DMA2D_BGPFCCR_CM_AL88 = 0x7
	// Color mode L4
	DMA2D_BGPFCCR_CM_L4 = 0x8
	// Color mode A8
	DMA2D_BGPFCCR_CM_A8 = 0x9
	// Color mode A4
	DMA2D_BGPFCCR_CM_A4 = 0xa
	// Position of CCM field.
	DMA2D_BGPFCCR_CCM_Pos = 0x4
	// Bit mask of CCM field.
	DMA2D_BGPFCCR_CCM_Msk = 0x10
	// Bit CCM.
	DMA2D_BGPFCCR_CCM = 0x10
	// CLUT color format ARGB8888
	DMA2D_BGPFCCR_CCM_ARGB8888 = 0x0
	// CLUT color format RGB888
	DMA2D_BGPFCCR_CCM_RGB888 = 0x1
	// Position of START field.
	DMA2D_BGPFCCR_START_Pos = 0x5
	// Bit mask of START field.
	DMA2D_BGPFCCR_START_Msk = 0x20
	// Bit START.
	DMA2D_BGPFCCR_START = 0x20
	// Start the automatic loading of the CLUT
	DMA2D_BGPFCCR_START_Start = 0x1
	// Position of CS field.
	DMA2D_BGPFCCR_CS_Pos = 0x8
	// Bit mask of CS field.
	DMA2D_BGPFCCR_CS_Msk = 0xff00
	// Position of AM field.
	DMA2D_BGPFCCR_AM_Pos = 0x10
	// Bit mask of AM field.
	DMA2D_BGPFCCR_AM_Msk = 0x30000
	// No modification of alpha channel
	DMA2D_BGPFCCR_AM_NoModify = 0x0
	// Replace with value in ALPHA[7:0]
	DMA2D_BGPFCCR_AM_Replace = 0x1
	// Multiply with value in ALPHA[7:0]
	DMA2D_BGPFCCR_AM_Multiply = 0x2
	// Position of AI field.
	DMA2D_BGPFCCR_AI_Pos = 0x14
	// Bit mask of AI field.
	DMA2D_BGPFCCR_AI_Msk = 0x100000
	// Bit AI.
	DMA2D_BGPFCCR_AI = 0x100000
	// Regular alpha
	DMA2D_BGPFCCR_AI_RegularAlpha = 0x0
	// Inverted alpha
	DMA2D_BGPFCCR_AI_InvertedAlpha = 0x1
	// Position of RBS field.
	DMA2D_BGPFCCR_RBS_Pos = 0x15
	// Bit mask of RBS field.
	DMA2D_BGPFCCR_RBS_Msk = 0x200000
	// Bit RBS.
	DMA2D_BGPFCCR_RBS = 0x200000
	// No Red Blue Swap (RGB or ARGB)
	DMA2D_BGPFCCR_RBS_Regular = 0x0
	// Red Blue Swap (BGR or ABGR)
	DMA2D_BGPFCCR_RBS_Swap = 0x1
	// Position of ALPHA field.
	DMA2D_BGPFCCR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_BGPFCCR_ALPHA_Msk = 0xff000000

	// BGCOLR: DMA2D background color register
	// Position of BLUE field.
	DMA2D_BGCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_BGCOLR_BLUE_Msk = 0xff
	// Position of GREEN field.
	DMA2D_BGCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_BGCOLR_GREEN_Msk = 0xff00
	// Position of RED field.
	DMA2D_BGCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_BGCOLR_RED_Msk = 0xff0000

	// FGCMAR: DMA2D foreground CLUT memory address register
	// Position of MA field.
	DMA2D_FGCMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_FGCMAR_MA_Msk = 0xffffffff

	// BGCMAR: DMA2D background CLUT memory address register
	// Position of MA field.
	DMA2D_BGCMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_BGCMAR_MA_Msk = 0xffffffff

	// OPFCCR: DMA2D output PFC control register
	// Position of CM field.
	DMA2D_OPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_OPFCCR_CM_Msk = 0x7
	// ARGB8888
	DMA2D_OPFCCR_CM_ARGB8888 = 0x0
	// RGB888
	DMA2D_OPFCCR_CM_RGB888 = 0x1
	// RGB565
	DMA2D_OPFCCR_CM_RGB565 = 0x2
	// ARGB1555
	DMA2D_OPFCCR_CM_ARGB1555 = 0x3
	// ARGB4444
	DMA2D_OPFCCR_CM_ARGB4444 = 0x4
	// Position of AI field.
	DMA2D_OPFCCR_AI_Pos = 0x14
	// Bit mask of AI field.
	DMA2D_OPFCCR_AI_Msk = 0x100000
	// Bit AI.
	DMA2D_OPFCCR_AI = 0x100000
	// Regular alpha
	DMA2D_OPFCCR_AI_RegularAlpha = 0x0
	// Inverted alpha
	DMA2D_OPFCCR_AI_InvertedAlpha = 0x1
	// Position of RBS field.
	DMA2D_OPFCCR_RBS_Pos = 0x15
	// Bit mask of RBS field.
	DMA2D_OPFCCR_RBS_Msk = 0x200000
	// Bit RBS.
	DMA2D_OPFCCR_RBS = 0x200000
	// No Red Blue Swap (RGB or ARGB)
	DMA2D_OPFCCR_RBS_Regular = 0x0
	// Red Blue Swap (BGR or ABGR)
	DMA2D_OPFCCR_RBS_Swap = 0x1
	// Position of SB field.
	DMA2D_OPFCCR_SB_Pos = 0x8
	// Bit mask of SB field.
	DMA2D_OPFCCR_SB_Msk = 0x100
	// Bit SB.
	DMA2D_OPFCCR_SB = 0x100
	// Regular byte order
	DMA2D_OPFCCR_SB_Regular = 0x0
	// Bytes are swapped two by two
	DMA2D_OPFCCR_SB_SwapBytes = 0x1

	// OCOLR: DMA2D output color register
	// Position of BLUE field.
	DMA2D_OCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_OCOLR_BLUE_Msk = 0xff
	// Position of GREEN field.
	DMA2D_OCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_OCOLR_GREEN_Msk = 0xff00
	// Position of RED field.
	DMA2D_OCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_OCOLR_RED_Msk = 0xff0000
	// Position of ALPHA field.
	DMA2D_OCOLR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_OCOLR_ALPHA_Msk = 0xff000000

	// OMAR: DMA2D output memory address register
	// Position of MA field.
	DMA2D_OMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_OMAR_MA_Msk = 0xffffffff

	// OOR: DMA2D output offset register
	// Position of LO field.
	DMA2D_OOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_OOR_LO_Msk = 0xffff

	// NLR: DMA2D number of line register
	// Position of NL field.
	DMA2D_NLR_NL_Pos = 0x0
	// Bit mask of NL field.
	DMA2D_NLR_NL_Msk = 0xffff
	// Position of PL field.
	DMA2D_NLR_PL_Pos = 0x10
	// Bit mask of PL field.
	DMA2D_NLR_PL_Msk = 0x3fff0000

	// LWR: DMA2D line watermark register
	// Position of LW field.
	DMA2D_LWR_LW_Pos = 0x0
	// Bit mask of LW field.
	DMA2D_LWR_LW_Msk = 0xffff

	// AMTCR: DMA2D AXI master timer configuration register
	// Position of EN field.
	DMA2D_AMTCR_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA2D_AMTCR_EN_Msk = 0x1
	// Bit EN.
	DMA2D_AMTCR_EN = 0x1
	// Disabled AHB/AXI dead-time functionality
	DMA2D_AMTCR_EN_Disabled = 0x0
	// Enabled AHB/AXI dead-time functionality
	DMA2D_AMTCR_EN_Enabled = 0x1
	// Position of DT field.
	DMA2D_AMTCR_DT_Pos = 0x8
	// Bit mask of DT field.
	DMA2D_AMTCR_DT_Msk = 0xff00
)

// Constants for DMAMUX1: DMAMUX
const (
	// CCR0: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_CCR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_CCR_DMAREQ_ID_Msk = 0xff
	// No signal selected as request input
	DMAMUX_CCR_DMAREQ_ID_NONE = 0x0
	// Signal `dmamux1_req_gen0` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN0 = 0x1
	// Signal `dmamux1_req_gen1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN1 = 0x2
	// Signal `dmamux1_req_gen2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN2 = 0x3
	// Signal `dmamux1_req_gen3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN3 = 0x4
	// Signal `dmamux1_req_gen4` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN4 = 0x5
	// Signal `dmamux1_req_gen5` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN5 = 0x6
	// Signal `dmamux1_req_gen6` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN6 = 0x7
	// Signal `dmamux1_req_gen7` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DMAMUX1_REQ_GEN7 = 0x8
	// Signal `adc1_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_ADC1_DMA = 0x9
	// Signal `adc2_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_ADC2_DMA = 0xa
	// Signal `tim1_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_CH1 = 0xb
	// Signal `tim1_ch2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_CH2 = 0xc
	// Signal `tim1_ch3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_CH3 = 0xd
	// Signal `tim1_ch4` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_CH4 = 0xe
	// Signal `tim1_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_UP = 0xf
	// Signal `tim1_trig` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_TRIG = 0x10
	// Signal `tim1_com` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM1_COM = 0x11
	// Signal `tim2_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM2_CH1 = 0x12
	// Signal `tim2_ch2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM2_CH2 = 0x13
	// Signal `tim2_ch3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM2_CH3 = 0x14
	// Signal `tim2_ch4` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM2_CH4 = 0x15
	// Signal `tim2_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM2_UP = 0x16
	// Signal `tim3_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM3_CH1 = 0x17
	// Signal `tim3_ch2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM3_CH2 = 0x18
	// Signal `tim3_ch3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM3_CH3 = 0x19
	// Signal `tim3_ch4` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM3_CH4 = 0x1a
	// Signal `tim3_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM3_UP = 0x1b
	// Signal `tim3_trig` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM3_TRIG = 0x1c
	// Signal `tim4_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM4_CH1 = 0x1d
	// Signal `tim4_ch2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM4_CH2 = 0x1e
	// Signal `tim4_ch3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM4_CH3 = 0x1f
	// Signal `tim4_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM4_UP = 0x20
	// Signal `i2c1_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_I2C1_RX_DMA = 0x21
	// Signal `i2c1_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_I2C1_TX_DMA = 0x22
	// Signal `i2c2_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_I2C2_RX_DMA = 0x23
	// Signal `i2c2_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_I2C2_TX_DMA = 0x24
	// Signal `spi1_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI1_RX_DMA = 0x25
	// Signal `spi1_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI1_TX_DMA = 0x26
	// Signal `spi2_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI2_RX_DMA = 0x27
	// Signal `spi2_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI2_TX_DMA = 0x28
	// Signal `usart1_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART1_RX_DMA = 0x29
	// Signal `usart1_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART1_TX_DMA = 0x2a
	// Signal `usart2_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART2_RX_DMA = 0x2b
	// Signal `usart2_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART2_TX_DMA = 0x2c
	// Signal `usart3_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART3_RX_DMA = 0x2d
	// Signal `usart3_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART3_TX_DMA = 0x2e
	// Signal `tim8_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_CH1 = 0x2f
	// Signal `tim8_ch2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_CH2 = 0x30
	// Signal `tim8_ch3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_CH3 = 0x31
	// Signal `tim8_ch4` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_CH4 = 0x32
	// Signal `tim8_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_UP = 0x33
	// Signal `tim8_trig` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_TRIG = 0x34
	// Signal `tim8_com` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM8_COM = 0x35
	// Signal `tim5_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM5_CH1 = 0x37
	// Signal `tim5_ch2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM5_CH2 = 0x38
	// Signal `tim5_ch3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM5_CH3 = 0x39
	// Signal `tim5_ch4` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM5_CH4 = 0x3a
	// Signal `tim5_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM5_UP = 0x3b
	// Signal `tim5_trig` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM5_TRIG = 0x3c
	// Signal `spi3_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI3_RX_DMA = 0x3d
	// Signal `spi3_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI3_TX_DMA = 0x3e
	// Signal `uart4_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART4_RX_DMA = 0x3f
	// Signal `uart4_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART4_TX_DMA = 0x40
	// Signal `uart5_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART5_RX_DMA = 0x41
	// Signal `uart5_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART5_TX_DMA = 0x42
	// Signal `dac_ch1_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DAC_CH1_DMA = 0x43
	// Signal `dac_ch2_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DAC_CH2_DMA = 0x44
	// Signal `tim6_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM6_UP = 0x45
	// Signal `tim7_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM7_UP = 0x46
	// Signal `usart6_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART6_RX_DMA = 0x47
	// Signal `usart6_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_USART6_TX_DMA = 0x48
	// Signal `i2c3_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_I2C3_RX_DMA = 0x49
	// Signal `i2c3_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_I2C3_TX_DMA = 0x4a
	// Signal `dcmi_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DCMI_DMA = 0x4b
	// Signal `cryp_in_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_CRYP_IN_DMA = 0x4c
	// Signal `cryp_out_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_CRYP_OUT_DMA = 0x4d
	// Signal `hash_in_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HASH_IN_DMA = 0x4e
	// Signal `uart7_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART7_RX_DMA = 0x4f
	// Signal `uart7_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART7_TX_DMA = 0x50
	// Signal `uart8_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART8_RX_DMA = 0x51
	// Signal `uart8_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_UART8_TX_DMA = 0x52
	// Signal `spi4_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI4_RX_DMA = 0x53
	// Signal `spi4_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI4_TX_DMA = 0x54
	// Signal `spi5_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI5_RX_DMA = 0x55
	// Signal `spi5_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPI5_TX_DMA = 0x56
	// Signal `sai1a_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SAI1A_DMA = 0x57
	// Signal `sai1b_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SAI1B_DMA = 0x58
	// Signal `sai2a_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SAI2A_DMA = 0x59
	// Signal `sai2b_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SAI2B_DMA = 0x5a
	// Signal `swpmi_rx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SWPMI_RX_DMA = 0x5b
	// Signal `swpmi_tx_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SWPMI_TX_DMA = 0x5c
	// Signal `spdifrx_dat_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPDIFRX_DAT_DMA = 0x5d
	// Signal `spdifrx_ctrl_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SPDIFRX_CTRL_DMA = 0x5e
	// Signal `hr_req(1)` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HR_REQ1 = 0x5f
	// Signal `hr_req(2)` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HR_REQ2 = 0x60
	// Signal `hr_req(3)` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HR_REQ3 = 0x61
	// Signal `hr_req(4)` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HR_REQ4 = 0x62
	// Signal `hr_req(5)` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HR_REQ5 = 0x63
	// Signal `hr_req(6)` selected as request input
	DMAMUX_CCR_DMAREQ_ID_HR_REQ6 = 0x64
	// Signal `dfsdm1_dma0` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DFSDM1_DMA0 = 0x65
	// Signal `dfsdm1_dma1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DFSDM1_DMA1 = 0x66
	// Signal `dfsdm1_dma2` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DFSDM1_DMA2 = 0x67
	// Signal `dfsdm1_dma3` selected as request input
	DMAMUX_CCR_DMAREQ_ID_DFSDM1_DMA3 = 0x68
	// Signal `tim15_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM15_CH1 = 0x69
	// Signal `tim15_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM15_UP = 0x6a
	// Signal `tim15_trig` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM15_TRIG = 0x6b
	// Signal `tim15_com` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM15_COM = 0x6c
	// Signal `tim16_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM16_CH1 = 0x6d
	// Signal `tim16_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM16_UP = 0x6e
	// Signal `tim17_ch1` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM17_CH1 = 0x6f
	// Signal `tim17_up` selected as request input
	DMAMUX_CCR_DMAREQ_ID_TIM17_UP = 0x70
	// Signal `sai3_a_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SAI3_A_DMA = 0x71
	// Signal `sai3_b_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_SAI3_B_DMA = 0x72
	// Signal `adc3_dma` selected as request input
	DMAMUX_CCR_DMAREQ_ID_ADC3_DMA = 0x73
	// Position of SOIE field.
	DMAMUX_CCR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_CCR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_CCR_SOIE = 0x100
	// Synchronization overrun interrupt disabled
	DMAMUX_CCR_SOIE_Disabled = 0x0
	// Synchronization overrun interrupt enabled
	DMAMUX_CCR_SOIE_Enabled = 0x1
	// Position of EGE field.
	DMAMUX_CCR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_CCR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_CCR_EGE = 0x200
	// Event generation disabled
	DMAMUX_CCR_EGE_Disabled = 0x0
	// Event generation enabled
	DMAMUX_CCR_EGE_Enabled = 0x1
	// Position of SE field.
	DMAMUX_CCR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_CCR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_CCR_SE = 0x10000
	// Synchronization disabled
	DMAMUX_CCR_SE_Disabled = 0x0
	// Synchronization enabled
	DMAMUX_CCR_SE_Enabled = 0x1
	// Position of SPOL field.
	DMAMUX_CCR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_CCR_SPOL_Msk = 0x60000
	// No event, i.e. no synchronization nor detection
	DMAMUX_CCR_SPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_CCR_SPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_CCR_SPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_CCR_SPOL_BothEdges = 0x3
	// Position of NBREQ field.
	DMAMUX_CCR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_CCR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_CCR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_CCR_SYNC_ID_Msk = 0x1f000000
	// Signal `dmamux1_evt0` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_DMAMUX1_EVT0 = 0x0
	// Signal `dmamux1_evt1` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_DMAMUX1_EVT1 = 0x1
	// Signal `dmamux1_evt2` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_DMAMUX1_EVT2 = 0x2
	// Signal `lptim1_out` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_LPTIM1_OUT = 0x3
	// Signal `lptim2_out` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_LPTIM2_OUT = 0x4
	// Signal `lptim3_out` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_LPTIM3_OUT = 0x5
	// Signal `extit0` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_EXTIT0 = 0x6
	// Signal `tim12_trgo` selected as synchronization input
	DMAMUX_CCR_SYNC_ID_TIM12_TRGO = 0x7

	// CSR: DMAMUX request line multiplexer interrupt channel status register
	// Position of SOF0 field.
	DMAMUX_CSR_SOF0_Pos = 0x0
	// Bit mask of SOF0 field.
	DMAMUX_CSR_SOF0_Msk = 0x1
	// Bit SOF0.
	DMAMUX_CSR_SOF0 = 0x1
	// Position of SOF1 field.
	DMAMUX_CSR_SOF1_Pos = 0x1
	// Bit mask of SOF1 field.
	DMAMUX_CSR_SOF1_Msk = 0x2
	// Bit SOF1.
	DMAMUX_CSR_SOF1 = 0x2
	// Position of SOF2 field.
	DMAMUX_CSR_SOF2_Pos = 0x2
	// Bit mask of SOF2 field.
	DMAMUX_CSR_SOF2_Msk = 0x4
	// Bit SOF2.
	DMAMUX_CSR_SOF2 = 0x4
	// Position of SOF3 field.
	DMAMUX_CSR_SOF3_Pos = 0x3
	// Bit mask of SOF3 field.
	DMAMUX_CSR_SOF3_Msk = 0x8
	// Bit SOF3.
	DMAMUX_CSR_SOF3 = 0x8
	// Position of SOF4 field.
	DMAMUX_CSR_SOF4_Pos = 0x4
	// Bit mask of SOF4 field.
	DMAMUX_CSR_SOF4_Msk = 0x10
	// Bit SOF4.
	DMAMUX_CSR_SOF4 = 0x10
	// Position of SOF5 field.
	DMAMUX_CSR_SOF5_Pos = 0x5
	// Bit mask of SOF5 field.
	DMAMUX_CSR_SOF5_Msk = 0x20
	// Bit SOF5.
	DMAMUX_CSR_SOF5 = 0x20
	// Position of SOF6 field.
	DMAMUX_CSR_SOF6_Pos = 0x6
	// Bit mask of SOF6 field.
	DMAMUX_CSR_SOF6_Msk = 0x40
	// Bit SOF6.
	DMAMUX_CSR_SOF6 = 0x40
	// Position of SOF7 field.
	DMAMUX_CSR_SOF7_Pos = 0x7
	// Bit mask of SOF7 field.
	DMAMUX_CSR_SOF7_Msk = 0x80
	// Bit SOF7.
	DMAMUX_CSR_SOF7 = 0x80
	// Position of SOF8 field.
	DMAMUX_CSR_SOF8_Pos = 0x8
	// Bit mask of SOF8 field.
	DMAMUX_CSR_SOF8_Msk = 0x100
	// Bit SOF8.
	DMAMUX_CSR_SOF8 = 0x100
	// Position of SOF9 field.
	DMAMUX_CSR_SOF9_Pos = 0x9
	// Bit mask of SOF9 field.
	DMAMUX_CSR_SOF9_Msk = 0x200
	// Bit SOF9.
	DMAMUX_CSR_SOF9 = 0x200
	// Position of SOF10 field.
	DMAMUX_CSR_SOF10_Pos = 0xa
	// Bit mask of SOF10 field.
	DMAMUX_CSR_SOF10_Msk = 0x400
	// Bit SOF10.
	DMAMUX_CSR_SOF10 = 0x400
	// Position of SOF11 field.
	DMAMUX_CSR_SOF11_Pos = 0xb
	// Bit mask of SOF11 field.
	DMAMUX_CSR_SOF11_Msk = 0x800
	// Bit SOF11.
	DMAMUX_CSR_SOF11 = 0x800
	// Position of SOF12 field.
	DMAMUX_CSR_SOF12_Pos = 0xc
	// Bit mask of SOF12 field.
	DMAMUX_CSR_SOF12_Msk = 0x1000
	// Bit SOF12.
	DMAMUX_CSR_SOF12 = 0x1000
	// Position of SOF13 field.
	DMAMUX_CSR_SOF13_Pos = 0xd
	// Bit mask of SOF13 field.
	DMAMUX_CSR_SOF13_Msk = 0x2000
	// Bit SOF13.
	DMAMUX_CSR_SOF13 = 0x2000
	// Position of SOF14 field.
	DMAMUX_CSR_SOF14_Pos = 0xe
	// Bit mask of SOF14 field.
	DMAMUX_CSR_SOF14_Msk = 0x4000
	// Bit SOF14.
	DMAMUX_CSR_SOF14 = 0x4000
	// Position of SOF15 field.
	DMAMUX_CSR_SOF15_Pos = 0xf
	// Bit mask of SOF15 field.
	DMAMUX_CSR_SOF15_Msk = 0x8000
	// Bit SOF15.
	DMAMUX_CSR_SOF15 = 0x8000

	// CFR: DMAMUX request line multiplexer interrupt clear flag register
	// Position of CSOF0 field.
	DMAMUX_CFR_CSOF0_Pos = 0x0
	// Bit mask of CSOF0 field.
	DMAMUX_CFR_CSOF0_Msk = 0x1
	// Bit CSOF0.
	DMAMUX_CFR_CSOF0 = 0x1
	// Position of CSOF1 field.
	DMAMUX_CFR_CSOF1_Pos = 0x1
	// Bit mask of CSOF1 field.
	DMAMUX_CFR_CSOF1_Msk = 0x2
	// Bit CSOF1.
	DMAMUX_CFR_CSOF1 = 0x2
	// Position of CSOF2 field.
	DMAMUX_CFR_CSOF2_Pos = 0x2
	// Bit mask of CSOF2 field.
	DMAMUX_CFR_CSOF2_Msk = 0x4
	// Bit CSOF2.
	DMAMUX_CFR_CSOF2 = 0x4
	// Position of CSOF3 field.
	DMAMUX_CFR_CSOF3_Pos = 0x3
	// Bit mask of CSOF3 field.
	DMAMUX_CFR_CSOF3_Msk = 0x8
	// Bit CSOF3.
	DMAMUX_CFR_CSOF3 = 0x8
	// Position of CSOF4 field.
	DMAMUX_CFR_CSOF4_Pos = 0x4
	// Bit mask of CSOF4 field.
	DMAMUX_CFR_CSOF4_Msk = 0x10
	// Bit CSOF4.
	DMAMUX_CFR_CSOF4 = 0x10
	// Position of CSOF5 field.
	DMAMUX_CFR_CSOF5_Pos = 0x5
	// Bit mask of CSOF5 field.
	DMAMUX_CFR_CSOF5_Msk = 0x20
	// Bit CSOF5.
	DMAMUX_CFR_CSOF5 = 0x20
	// Position of CSOF6 field.
	DMAMUX_CFR_CSOF6_Pos = 0x6
	// Bit mask of CSOF6 field.
	DMAMUX_CFR_CSOF6_Msk = 0x40
	// Bit CSOF6.
	DMAMUX_CFR_CSOF6 = 0x40
	// Position of CSOF7 field.
	DMAMUX_CFR_CSOF7_Pos = 0x7
	// Bit mask of CSOF7 field.
	DMAMUX_CFR_CSOF7_Msk = 0x80
	// Bit CSOF7.
	DMAMUX_CFR_CSOF7 = 0x80
	// Position of CSOF8 field.
	DMAMUX_CFR_CSOF8_Pos = 0x8
	// Bit mask of CSOF8 field.
	DMAMUX_CFR_CSOF8_Msk = 0x100
	// Bit CSOF8.
	DMAMUX_CFR_CSOF8 = 0x100
	// Position of CSOF9 field.
	DMAMUX_CFR_CSOF9_Pos = 0x9
	// Bit mask of CSOF9 field.
	DMAMUX_CFR_CSOF9_Msk = 0x200
	// Bit CSOF9.
	DMAMUX_CFR_CSOF9 = 0x200
	// Position of CSOF10 field.
	DMAMUX_CFR_CSOF10_Pos = 0xa
	// Bit mask of CSOF10 field.
	DMAMUX_CFR_CSOF10_Msk = 0x400
	// Bit CSOF10.
	DMAMUX_CFR_CSOF10 = 0x400
	// Position of CSOF11 field.
	DMAMUX_CFR_CSOF11_Pos = 0xb
	// Bit mask of CSOF11 field.
	DMAMUX_CFR_CSOF11_Msk = 0x800
	// Bit CSOF11.
	DMAMUX_CFR_CSOF11 = 0x800
	// Position of CSOF12 field.
	DMAMUX_CFR_CSOF12_Pos = 0xc
	// Bit mask of CSOF12 field.
	DMAMUX_CFR_CSOF12_Msk = 0x1000
	// Bit CSOF12.
	DMAMUX_CFR_CSOF12 = 0x1000
	// Position of CSOF13 field.
	DMAMUX_CFR_CSOF13_Pos = 0xd
	// Bit mask of CSOF13 field.
	DMAMUX_CFR_CSOF13_Msk = 0x2000
	// Bit CSOF13.
	DMAMUX_CFR_CSOF13 = 0x2000
	// Position of CSOF14 field.
	DMAMUX_CFR_CSOF14_Pos = 0xe
	// Bit mask of CSOF14 field.
	DMAMUX_CFR_CSOF14_Msk = 0x4000
	// Bit CSOF14.
	DMAMUX_CFR_CSOF14 = 0x4000
	// Position of CSOF15 field.
	DMAMUX_CFR_CSOF15_Pos = 0xf
	// Bit mask of CSOF15 field.
	DMAMUX_CFR_CSOF15_Msk = 0x8000
	// Bit CSOF15.
	DMAMUX_CFR_CSOF15 = 0x8000

	// RGCR0: DMAMux - DMA request generator channel x control register
	// Position of SIG_ID field.
	DMAMUX_RGCR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RGCR_SIG_ID_Msk = 0x1f
	// Signal `dmamux1_evt0` selected as trigger input
	DMAMUX_RGCR_SIG_ID_DMAMUX1_EVT0 = 0x0
	// Signal `dmamux1_evt1` selected as trigger input
	DMAMUX_RGCR_SIG_ID_DMAMUX1_EVT1 = 0x1
	// Signal `dmamux1_evt2` selected as trigger input
	DMAMUX_RGCR_SIG_ID_DMAMUX1_EVT2 = 0x2
	// Signal `lptim1_out` selected as trigger input
	DMAMUX_RGCR_SIG_ID_LPTIM1_OUT = 0x3
	// Signal `lptim2_out` selected as trigger input
	DMAMUX_RGCR_SIG_ID_LPTIM2_OUT = 0x4
	// Signal `lptim3_out` selected as trigger input
	DMAMUX_RGCR_SIG_ID_LPTIM3_OUT = 0x5
	// Signal `extit0` selected as trigger input
	DMAMUX_RGCR_SIG_ID_EXTIT0 = 0x6
	// Signal `tim12_trgo` selected as trigger input
	DMAMUX_RGCR_SIG_ID_TIM12_TRGO = 0x7
	// Position of OIE field.
	DMAMUX_RGCR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RGCR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RGCR_OIE = 0x100
	// Trigger overrun interrupt disabled
	DMAMUX_RGCR_OIE_Disabled = 0x0
	// Trigger overrun interrupt enabled
	DMAMUX_RGCR_OIE_Enabled = 0x1
	// Position of GE field.
	DMAMUX_RGCR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RGCR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RGCR_GE = 0x10000
	// DMA request generation disabled
	DMAMUX_RGCR_GE_Disabled = 0x0
	// DMA request enabled
	DMAMUX_RGCR_GE_Enabled = 0x1
	// Position of GPOL field.
	DMAMUX_RGCR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RGCR_GPOL_Msk = 0x60000
	// No event, i.e. no detection nor generation
	DMAMUX_RGCR_GPOL_NoEdge = 0x0
	// Rising edge
	DMAMUX_RGCR_GPOL_RisingEdge = 0x1
	// Falling edge
	DMAMUX_RGCR_GPOL_FallingEdge = 0x2
	// Rising and falling edges
	DMAMUX_RGCR_GPOL_BothEdges = 0x3
	// Position of GNBREQ field.
	DMAMUX_RGCR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RGCR_GNBREQ_Msk = 0xf80000

	// RGSR: DMAMux - DMA request generator status register
	// Position of OF0 field.
	DMAMUX_RGSR_OF0_Pos = 0x0
	// Bit mask of OF0 field.
	DMAMUX_RGSR_OF0_Msk = 0x1
	// Bit OF0.
	DMAMUX_RGSR_OF0 = 0x1
	// Position of OF1 field.
	DMAMUX_RGSR_OF1_Pos = 0x1
	// Bit mask of OF1 field.
	DMAMUX_RGSR_OF1_Msk = 0x2
	// Bit OF1.
	DMAMUX_RGSR_OF1 = 0x2
	// Position of OF2 field.
	DMAMUX_RGSR_OF2_Pos = 0x2
	// Bit mask of OF2 field.
	DMAMUX_RGSR_OF2_Msk = 0x4
	// Bit OF2.
	DMAMUX_RGSR_OF2 = 0x4
	// Position of OF3 field.
	DMAMUX_RGSR_OF3_Pos = 0x3
	// Bit mask of OF3 field.
	DMAMUX_RGSR_OF3_Msk = 0x8
	// Bit OF3.
	DMAMUX_RGSR_OF3 = 0x8
	// Position of OF4 field.
	DMAMUX_RGSR_OF4_Pos = 0x4
	// Bit mask of OF4 field.
	DMAMUX_RGSR_OF4_Msk = 0x10
	// Bit OF4.
	DMAMUX_RGSR_OF4 = 0x10
	// Position of OF5 field.
	DMAMUX_RGSR_OF5_Pos = 0x5
	// Bit mask of OF5 field.
	DMAMUX_RGSR_OF5_Msk = 0x20
	// Bit OF5.
	DMAMUX_RGSR_OF5 = 0x20
	// Position of OF6 field.
	DMAMUX_RGSR_OF6_Pos = 0x6
	// Bit mask of OF6 field.
	DMAMUX_RGSR_OF6_Msk = 0x40
	// Bit OF6.
	DMAMUX_RGSR_OF6 = 0x40
	// Position of OF7 field.
	DMAMUX_RGSR_OF7_Pos = 0x7
	// Bit mask of OF7 field.
	DMAMUX_RGSR_OF7_Msk = 0x80
	// Bit OF7.
	DMAMUX_RGSR_OF7 = 0x80

	// RGCFR: DMAMux - DMA request generator clear flag register
	// Position of COF0 field.
	DMAMUX_RGCFR_COF0_Pos = 0x0
	// Bit mask of COF0 field.
	DMAMUX_RGCFR_COF0_Msk = 0x1
	// Bit COF0.
	DMAMUX_RGCFR_COF0 = 0x1
	// Position of COF1 field.
	DMAMUX_RGCFR_COF1_Pos = 0x1
	// Bit mask of COF1 field.
	DMAMUX_RGCFR_COF1_Msk = 0x2
	// Bit COF1.
	DMAMUX_RGCFR_COF1 = 0x2
	// Position of COF2 field.
	DMAMUX_RGCFR_COF2_Pos = 0x2
	// Bit mask of COF2 field.
	DMAMUX_RGCFR_COF2_Msk = 0x4
	// Bit COF2.
	DMAMUX_RGCFR_COF2 = 0x4
	// Position of COF3 field.
	DMAMUX_RGCFR_COF3_Pos = 0x3
	// Bit mask of COF3 field.
	DMAMUX_RGCFR_COF3_Msk = 0x8
	// Bit COF3.
	DMAMUX_RGCFR_COF3 = 0x8
	// Position of COF4 field.
	DMAMUX_RGCFR_COF4_Pos = 0x4
	// Bit mask of COF4 field.
	DMAMUX_RGCFR_COF4_Msk = 0x10
	// Bit COF4.
	DMAMUX_RGCFR_COF4 = 0x10
	// Position of COF5 field.
	DMAMUX_RGCFR_COF5_Pos = 0x5
	// Bit mask of COF5 field.
	DMAMUX_RGCFR_COF5_Msk = 0x20
	// Bit COF5.
	DMAMUX_RGCFR_COF5 = 0x20
	// Position of COF6 field.
	DMAMUX_RGCFR_COF6_Pos = 0x6
	// Bit mask of COF6 field.
	DMAMUX_RGCFR_COF6_Msk = 0x40
	// Bit COF6.
	DMAMUX_RGCFR_COF6 = 0x40
	// Position of COF7 field.
	DMAMUX_RGCFR_COF7_Pos = 0x7
	// Bit mask of COF7 field.
	DMAMUX_RGCFR_COF7_Msk = 0x80
	// Bit COF7.
	DMAMUX_RGCFR_COF7 = 0x80
)

// Constants for EXTI: External interrupt/event controller
const (
	// RTSR1: EXTI rising trigger selection register
	// Position of TR0 field.
	EXTI_RTSR1_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_RTSR1_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_RTSR1_TR0 = 0x1
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR0_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_RTSR1_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_RTSR1_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_RTSR1_TR1 = 0x2
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR1_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_RTSR1_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_RTSR1_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_RTSR1_TR2 = 0x4
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR2_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_RTSR1_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_RTSR1_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_RTSR1_TR3 = 0x8
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR3_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_RTSR1_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_RTSR1_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_RTSR1_TR4 = 0x10
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR4_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_RTSR1_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_RTSR1_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_RTSR1_TR5 = 0x20
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR5_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_RTSR1_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_RTSR1_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_RTSR1_TR6 = 0x40
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR6_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_RTSR1_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_RTSR1_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_RTSR1_TR7 = 0x80
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR7_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_RTSR1_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_RTSR1_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_RTSR1_TR8 = 0x100
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR8_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_RTSR1_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_RTSR1_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_RTSR1_TR9 = 0x200
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR9_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_RTSR1_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_RTSR1_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_RTSR1_TR10 = 0x400
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR10_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_RTSR1_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_RTSR1_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_RTSR1_TR11 = 0x800
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR11_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_RTSR1_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_RTSR1_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_RTSR1_TR12 = 0x1000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR12_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_RTSR1_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_RTSR1_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_RTSR1_TR13 = 0x2000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR13_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_RTSR1_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_RTSR1_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_RTSR1_TR14 = 0x4000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR14_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_RTSR1_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_RTSR1_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_RTSR1_TR15 = 0x8000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR15_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_RTSR1_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_RTSR1_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_RTSR1_TR16 = 0x10000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR16_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR16_Enabled = 0x1
	// Position of TR17 field.
	EXTI_RTSR1_TR17_Pos = 0x11
	// Bit mask of TR17 field.
	EXTI_RTSR1_TR17_Msk = 0x20000
	// Bit TR17.
	EXTI_RTSR1_TR17 = 0x20000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR17_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR17_Enabled = 0x1
	// Position of TR18 field.
	EXTI_RTSR1_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_RTSR1_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_RTSR1_TR18 = 0x40000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR18_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR18_Enabled = 0x1
	// Position of TR19 field.
	EXTI_RTSR1_TR19_Pos = 0x13
	// Bit mask of TR19 field.
	EXTI_RTSR1_TR19_Msk = 0x80000
	// Bit TR19.
	EXTI_RTSR1_TR19 = 0x80000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR19_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR19_Enabled = 0x1
	// Position of TR20 field.
	EXTI_RTSR1_TR20_Pos = 0x14
	// Bit mask of TR20 field.
	EXTI_RTSR1_TR20_Msk = 0x100000
	// Bit TR20.
	EXTI_RTSR1_TR20 = 0x100000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR20_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR20_Enabled = 0x1
	// Position of TR21 field.
	EXTI_RTSR1_TR21_Pos = 0x15
	// Bit mask of TR21 field.
	EXTI_RTSR1_TR21_Msk = 0x200000
	// Bit TR21.
	EXTI_RTSR1_TR21 = 0x200000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR21_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR21_Enabled = 0x1

	// FTSR1: EXTI falling trigger selection register
	// Position of TR0 field.
	EXTI_FTSR1_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_FTSR1_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_FTSR1_TR0 = 0x1
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR0_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_FTSR1_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_FTSR1_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_FTSR1_TR1 = 0x2
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR1_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_FTSR1_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_FTSR1_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_FTSR1_TR2 = 0x4
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR2_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_FTSR1_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_FTSR1_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_FTSR1_TR3 = 0x8
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR3_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_FTSR1_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_FTSR1_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_FTSR1_TR4 = 0x10
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR4_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_FTSR1_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_FTSR1_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_FTSR1_TR5 = 0x20
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR5_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_FTSR1_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_FTSR1_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_FTSR1_TR6 = 0x40
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR6_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_FTSR1_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_FTSR1_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_FTSR1_TR7 = 0x80
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR7_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_FTSR1_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_FTSR1_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_FTSR1_TR8 = 0x100
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR8_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_FTSR1_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_FTSR1_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_FTSR1_TR9 = 0x200
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR9_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_FTSR1_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_FTSR1_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_FTSR1_TR10 = 0x400
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR10_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_FTSR1_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_FTSR1_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_FTSR1_TR11 = 0x800
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR11_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_FTSR1_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_FTSR1_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_FTSR1_TR12 = 0x1000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR12_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_FTSR1_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_FTSR1_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_FTSR1_TR13 = 0x2000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR13_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_FTSR1_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_FTSR1_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_FTSR1_TR14 = 0x4000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR14_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_FTSR1_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_FTSR1_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_FTSR1_TR15 = 0x8000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR15_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_FTSR1_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_FTSR1_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_FTSR1_TR16 = 0x10000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR16_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR16_Enabled = 0x1
	// Position of TR17 field.
	EXTI_FTSR1_TR17_Pos = 0x11
	// Bit mask of TR17 field.
	EXTI_FTSR1_TR17_Msk = 0x20000
	// Bit TR17.
	EXTI_FTSR1_TR17 = 0x20000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR17_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR17_Enabled = 0x1
	// Position of TR18 field.
	EXTI_FTSR1_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_FTSR1_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_FTSR1_TR18 = 0x40000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR18_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR18_Enabled = 0x1
	// Position of TR19 field.
	EXTI_FTSR1_TR19_Pos = 0x13
	// Bit mask of TR19 field.
	EXTI_FTSR1_TR19_Msk = 0x80000
	// Bit TR19.
	EXTI_FTSR1_TR19 = 0x80000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR19_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR19_Enabled = 0x1
	// Position of TR20 field.
	EXTI_FTSR1_TR20_Pos = 0x14
	// Bit mask of TR20 field.
	EXTI_FTSR1_TR20_Msk = 0x100000
	// Bit TR20.
	EXTI_FTSR1_TR20 = 0x100000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR20_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR20_Enabled = 0x1
	// Position of TR21 field.
	EXTI_FTSR1_TR21_Pos = 0x15
	// Bit mask of TR21 field.
	EXTI_FTSR1_TR21_Msk = 0x200000
	// Bit TR21.
	EXTI_FTSR1_TR21 = 0x200000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR21_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR21_Enabled = 0x1

	// SWIER1: EXTI software interrupt event register
	// Position of SWIER0 field.
	EXTI_SWIER1_SWIER0_Pos = 0x0
	// Bit mask of SWIER0 field.
	EXTI_SWIER1_SWIER0_Msk = 0x1
	// Bit SWIER0.
	EXTI_SWIER1_SWIER0 = 0x1
	// Generates an interrupt request
	EXTI_SWIER1_SWIER0_Pend = 0x1
	// Position of SWIER1 field.
	EXTI_SWIER1_SWIER1_Pos = 0x1
	// Bit mask of SWIER1 field.
	EXTI_SWIER1_SWIER1_Msk = 0x2
	// Bit SWIER1.
	EXTI_SWIER1_SWIER1 = 0x2
	// Generates an interrupt request
	EXTI_SWIER1_SWIER1_Pend = 0x1
	// Position of SWIER2 field.
	EXTI_SWIER1_SWIER2_Pos = 0x2
	// Bit mask of SWIER2 field.
	EXTI_SWIER1_SWIER2_Msk = 0x4
	// Bit SWIER2.
	EXTI_SWIER1_SWIER2 = 0x4
	// Generates an interrupt request
	EXTI_SWIER1_SWIER2_Pend = 0x1
	// Position of SWIER3 field.
	EXTI_SWIER1_SWIER3_Pos = 0x3
	// Bit mask of SWIER3 field.
	EXTI_SWIER1_SWIER3_Msk = 0x8
	// Bit SWIER3.
	EXTI_SWIER1_SWIER3 = 0x8
	// Generates an interrupt request
	EXTI_SWIER1_SWIER3_Pend = 0x1
	// Position of SWIER4 field.
	EXTI_SWIER1_SWIER4_Pos = 0x4
	// Bit mask of SWIER4 field.
	EXTI_SWIER1_SWIER4_Msk = 0x10
	// Bit SWIER4.
	EXTI_SWIER1_SWIER4 = 0x10
	// Generates an interrupt request
	EXTI_SWIER1_SWIER4_Pend = 0x1
	// Position of SWIER5 field.
	EXTI_SWIER1_SWIER5_Pos = 0x5
	// Bit mask of SWIER5 field.
	EXTI_SWIER1_SWIER5_Msk = 0x20
	// Bit SWIER5.
	EXTI_SWIER1_SWIER5 = 0x20
	// Generates an interrupt request
	EXTI_SWIER1_SWIER5_Pend = 0x1
	// Position of SWIER6 field.
	EXTI_SWIER1_SWIER6_Pos = 0x6
	// Bit mask of SWIER6 field.
	EXTI_SWIER1_SWIER6_Msk = 0x40
	// Bit SWIER6.
	EXTI_SWIER1_SWIER6 = 0x40
	// Generates an interrupt request
	EXTI_SWIER1_SWIER6_Pend = 0x1
	// Position of SWIER7 field.
	EXTI_SWIER1_SWIER7_Pos = 0x7
	// Bit mask of SWIER7 field.
	EXTI_SWIER1_SWIER7_Msk = 0x80
	// Bit SWIER7.
	EXTI_SWIER1_SWIER7 = 0x80
	// Generates an interrupt request
	EXTI_SWIER1_SWIER7_Pend = 0x1
	// Position of SWIER8 field.
	EXTI_SWIER1_SWIER8_Pos = 0x8
	// Bit mask of SWIER8 field.
	EXTI_SWIER1_SWIER8_Msk = 0x100
	// Bit SWIER8.
	EXTI_SWIER1_SWIER8 = 0x100
	// Generates an interrupt request
	EXTI_SWIER1_SWIER8_Pend = 0x1
	// Position of SWIER9 field.
	EXTI_SWIER1_SWIER9_Pos = 0x9
	// Bit mask of SWIER9 field.
	EXTI_SWIER1_SWIER9_Msk = 0x200
	// Bit SWIER9.
	EXTI_SWIER1_SWIER9 = 0x200
	// Generates an interrupt request
	EXTI_SWIER1_SWIER9_Pend = 0x1
	// Position of SWIER10 field.
	EXTI_SWIER1_SWIER10_Pos = 0xa
	// Bit mask of SWIER10 field.
	EXTI_SWIER1_SWIER10_Msk = 0x400
	// Bit SWIER10.
	EXTI_SWIER1_SWIER10 = 0x400
	// Generates an interrupt request
	EXTI_SWIER1_SWIER10_Pend = 0x1
	// Position of SWIER11 field.
	EXTI_SWIER1_SWIER11_Pos = 0xb
	// Bit mask of SWIER11 field.
	EXTI_SWIER1_SWIER11_Msk = 0x800
	// Bit SWIER11.
	EXTI_SWIER1_SWIER11 = 0x800
	// Generates an interrupt request
	EXTI_SWIER1_SWIER11_Pend = 0x1
	// Position of SWIER12 field.
	EXTI_SWIER1_SWIER12_Pos = 0xc
	// Bit mask of SWIER12 field.
	EXTI_SWIER1_SWIER12_Msk = 0x1000
	// Bit SWIER12.
	EXTI_SWIER1_SWIER12 = 0x1000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER12_Pend = 0x1
	// Position of SWIER13 field.
	EXTI_SWIER1_SWIER13_Pos = 0xd
	// Bit mask of SWIER13 field.
	EXTI_SWIER1_SWIER13_Msk = 0x2000
	// Bit SWIER13.
	EXTI_SWIER1_SWIER13 = 0x2000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER13_Pend = 0x1
	// Position of SWIER14 field.
	EXTI_SWIER1_SWIER14_Pos = 0xe
	// Bit mask of SWIER14 field.
	EXTI_SWIER1_SWIER14_Msk = 0x4000
	// Bit SWIER14.
	EXTI_SWIER1_SWIER14 = 0x4000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER14_Pend = 0x1
	// Position of SWIER15 field.
	EXTI_SWIER1_SWIER15_Pos = 0xf
	// Bit mask of SWIER15 field.
	EXTI_SWIER1_SWIER15_Msk = 0x8000
	// Bit SWIER15.
	EXTI_SWIER1_SWIER15 = 0x8000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER15_Pend = 0x1
	// Position of SWIER16 field.
	EXTI_SWIER1_SWIER16_Pos = 0x10
	// Bit mask of SWIER16 field.
	EXTI_SWIER1_SWIER16_Msk = 0x10000
	// Bit SWIER16.
	EXTI_SWIER1_SWIER16 = 0x10000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER16_Pend = 0x1
	// Position of SWIER17 field.
	EXTI_SWIER1_SWIER17_Pos = 0x11
	// Bit mask of SWIER17 field.
	EXTI_SWIER1_SWIER17_Msk = 0x20000
	// Bit SWIER17.
	EXTI_SWIER1_SWIER17 = 0x20000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER17_Pend = 0x1
	// Position of SWIER18 field.
	EXTI_SWIER1_SWIER18_Pos = 0x12
	// Bit mask of SWIER18 field.
	EXTI_SWIER1_SWIER18_Msk = 0x40000
	// Bit SWIER18.
	EXTI_SWIER1_SWIER18 = 0x40000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER18_Pend = 0x1
	// Position of SWIER19 field.
	EXTI_SWIER1_SWIER19_Pos = 0x13
	// Bit mask of SWIER19 field.
	EXTI_SWIER1_SWIER19_Msk = 0x80000
	// Bit SWIER19.
	EXTI_SWIER1_SWIER19 = 0x80000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER19_Pend = 0x1
	// Position of SWIER20 field.
	EXTI_SWIER1_SWIER20_Pos = 0x14
	// Bit mask of SWIER20 field.
	EXTI_SWIER1_SWIER20_Msk = 0x100000
	// Bit SWIER20.
	EXTI_SWIER1_SWIER20 = 0x100000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER20_Pend = 0x1
	// Position of SWIER21 field.
	EXTI_SWIER1_SWIER21_Pos = 0x15
	// Bit mask of SWIER21 field.
	EXTI_SWIER1_SWIER21_Msk = 0x200000
	// Bit SWIER21.
	EXTI_SWIER1_SWIER21 = 0x200000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER21_Pend = 0x1

	// D3PMR1: EXTI D3 pending mask register
	// Position of MR0 field.
	EXTI_D3PMR1_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_D3PMR1_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_D3PMR1_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_D3PMR1_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_D3PMR1_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_D3PMR1_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_D3PMR1_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_D3PMR1_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_D3PMR1_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_D3PMR1_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_D3PMR1_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_D3PMR1_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_D3PMR1_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_D3PMR1_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_D3PMR1_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_D3PMR1_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_D3PMR1_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_D3PMR1_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_D3PMR1_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_D3PMR1_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_D3PMR1_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_D3PMR1_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_D3PMR1_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_D3PMR1_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_D3PMR1_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_D3PMR1_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_D3PMR1_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_D3PMR1_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_D3PMR1_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_D3PMR1_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_D3PMR1_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_D3PMR1_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_D3PMR1_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_D3PMR1_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_D3PMR1_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_D3PMR1_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_D3PMR1_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_D3PMR1_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_D3PMR1_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_D3PMR1_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_D3PMR1_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_D3PMR1_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_D3PMR1_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_D3PMR1_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_D3PMR1_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_D3PMR1_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_D3PMR1_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_D3PMR1_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_D3PMR1_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_D3PMR1_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_D3PMR1_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_D3PMR1_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_D3PMR1_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_D3PMR1_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_D3PMR1_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_D3PMR1_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_D3PMR1_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_D3PMR1_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_D3PMR1_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_D3PMR1_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR15_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_D3PMR1_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_D3PMR1_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_D3PMR1_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_D3PMR1_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_D3PMR1_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_D3PMR1_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_D3PMR1_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_D3PMR1_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_D3PMR1_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR21_Unmasked = 0x1
	// Position of MR25 field.
	EXTI_D3PMR1_MR25_Pos = 0x19
	// Bit mask of MR25 field.
	EXTI_D3PMR1_MR25_Msk = 0x2000000
	// Bit MR25.
	EXTI_D3PMR1_MR25 = 0x2000000
	// Interrupt request line is masked
	EXTI_D3PMR1_MR25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR1_MR25_Unmasked = 0x1

	// D3PCR1L: EXTI D3 pending clear selection register low
	// Position of PCS0 field.
	EXTI_D3PCR1L_PCS0_Pos = 0x0
	// Bit mask of PCS0 field.
	EXTI_D3PCR1L_PCS0_Msk = 0x3
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS0_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS0_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS0_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS0_LPTIM5 = 0x3
	// Position of PCS1 field.
	EXTI_D3PCR1L_PCS1_Pos = 0x2
	// Bit mask of PCS1 field.
	EXTI_D3PCR1L_PCS1_Msk = 0xc
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS1_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS1_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS1_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS1_LPTIM5 = 0x3
	// Position of PCS2 field.
	EXTI_D3PCR1L_PCS2_Pos = 0x4
	// Bit mask of PCS2 field.
	EXTI_D3PCR1L_PCS2_Msk = 0x30
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS2_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS2_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS2_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS2_LPTIM5 = 0x3
	// Position of PCS3 field.
	EXTI_D3PCR1L_PCS3_Pos = 0x6
	// Bit mask of PCS3 field.
	EXTI_D3PCR1L_PCS3_Msk = 0xc0
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS3_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS3_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS3_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS3_LPTIM5 = 0x3
	// Position of PCS4 field.
	EXTI_D3PCR1L_PCS4_Pos = 0x8
	// Bit mask of PCS4 field.
	EXTI_D3PCR1L_PCS4_Msk = 0x300
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS4_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS4_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS4_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS4_LPTIM5 = 0x3
	// Position of PCS5 field.
	EXTI_D3PCR1L_PCS5_Pos = 0xa
	// Bit mask of PCS5 field.
	EXTI_D3PCR1L_PCS5_Msk = 0xc00
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS5_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS5_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS5_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS5_LPTIM5 = 0x3
	// Position of PCS6 field.
	EXTI_D3PCR1L_PCS6_Pos = 0xc
	// Bit mask of PCS6 field.
	EXTI_D3PCR1L_PCS6_Msk = 0x3000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS6_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS6_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS6_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS6_LPTIM5 = 0x3
	// Position of PCS7 field.
	EXTI_D3PCR1L_PCS7_Pos = 0xe
	// Bit mask of PCS7 field.
	EXTI_D3PCR1L_PCS7_Msk = 0xc000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS7_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS7_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS7_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS7_LPTIM5 = 0x3
	// Position of PCS8 field.
	EXTI_D3PCR1L_PCS8_Pos = 0x10
	// Bit mask of PCS8 field.
	EXTI_D3PCR1L_PCS8_Msk = 0x30000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS8_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS8_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS8_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS8_LPTIM5 = 0x3
	// Position of PCS9 field.
	EXTI_D3PCR1L_PCS9_Pos = 0x12
	// Bit mask of PCS9 field.
	EXTI_D3PCR1L_PCS9_Msk = 0xc0000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS9_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS9_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS9_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS9_LPTIM5 = 0x3
	// Position of PCS10 field.
	EXTI_D3PCR1L_PCS10_Pos = 0x14
	// Bit mask of PCS10 field.
	EXTI_D3PCR1L_PCS10_Msk = 0x300000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS10_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS10_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS10_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS10_LPTIM5 = 0x3
	// Position of PCS11 field.
	EXTI_D3PCR1L_PCS11_Pos = 0x16
	// Bit mask of PCS11 field.
	EXTI_D3PCR1L_PCS11_Msk = 0xc00000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS11_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS11_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS11_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS11_LPTIM5 = 0x3
	// Position of PCS12 field.
	EXTI_D3PCR1L_PCS12_Pos = 0x18
	// Bit mask of PCS12 field.
	EXTI_D3PCR1L_PCS12_Msk = 0x3000000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS12_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS12_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS12_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS12_LPTIM5 = 0x3
	// Position of PCS13 field.
	EXTI_D3PCR1L_PCS13_Pos = 0x1a
	// Bit mask of PCS13 field.
	EXTI_D3PCR1L_PCS13_Msk = 0xc000000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS13_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS13_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS13_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS13_LPTIM5 = 0x3
	// Position of PCS14 field.
	EXTI_D3PCR1L_PCS14_Pos = 0x1c
	// Bit mask of PCS14 field.
	EXTI_D3PCR1L_PCS14_Msk = 0x30000000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS14_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS14_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS14_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS14_LPTIM5 = 0x3
	// Position of PCS15 field.
	EXTI_D3PCR1L_PCS15_Pos = 0x1e
	// Bit mask of PCS15 field.
	EXTI_D3PCR1L_PCS15_Msk = 0xc0000000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS15_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS15_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS15_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1L_PCS15_LPTIM5 = 0x3

	// D3PCR1H: EXTI D3 pending clear selection register high
	// Position of PCS19 field.
	EXTI_D3PCR1H_PCS19_Pos = 0x6
	// Bit mask of PCS19 field.
	EXTI_D3PCR1H_PCS19_Msk = 0xc0
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS19_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS19_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS19_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS19_LPTIM5 = 0x3
	// Position of PCS20 field.
	EXTI_D3PCR1H_PCS20_Pos = 0x8
	// Bit mask of PCS20 field.
	EXTI_D3PCR1H_PCS20_Msk = 0x300
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS20_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS20_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS20_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS20_LPTIM5 = 0x3
	// Position of PCS21 field.
	EXTI_D3PCR1H_PCS21_Pos = 0xa
	// Bit mask of PCS21 field.
	EXTI_D3PCR1H_PCS21_Msk = 0xc00
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS21_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS21_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS21_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS21_LPTIM5 = 0x3
	// Position of PCS25 field.
	EXTI_D3PCR1H_PCS25_Pos = 0x12
	// Bit mask of PCS25 field.
	EXTI_D3PCR1H_PCS25_Msk = 0xc0000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS25_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS25_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS25_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR1H_PCS25_LPTIM5 = 0x3

	// RTSR2: EXTI rising trigger selection register
	// Position of TR49 field.
	EXTI_RTSR2_TR49_Pos = 0x11
	// Bit mask of TR49 field.
	EXTI_RTSR2_TR49_Msk = 0x20000
	// Bit TR49.
	EXTI_RTSR2_TR49 = 0x20000
	// Rising edge trigger is disabled
	EXTI_RTSR2_TR49_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_TR49_Enabled = 0x1
	// Position of TR51 field.
	EXTI_RTSR2_TR51_Pos = 0x13
	// Bit mask of TR51 field.
	EXTI_RTSR2_TR51_Msk = 0x80000
	// Bit TR51.
	EXTI_RTSR2_TR51 = 0x80000
	// Rising edge trigger is disabled
	EXTI_RTSR2_TR51_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_TR51_Enabled = 0x1

	// FTSR2: EXTI falling trigger selection register
	// Position of TR49 field.
	EXTI_FTSR2_TR49_Pos = 0x11
	// Bit mask of TR49 field.
	EXTI_FTSR2_TR49_Msk = 0x20000
	// Bit TR49.
	EXTI_FTSR2_TR49 = 0x20000
	// Falling edge trigger is disabled
	EXTI_FTSR2_TR49_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_TR49_Enabled = 0x1
	// Position of TR51 field.
	EXTI_FTSR2_TR51_Pos = 0x13
	// Bit mask of TR51 field.
	EXTI_FTSR2_TR51_Msk = 0x80000
	// Bit TR51.
	EXTI_FTSR2_TR51 = 0x80000
	// Falling edge trigger is disabled
	EXTI_FTSR2_TR51_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_TR51_Enabled = 0x1

	// SWIER2: EXTI software interrupt event register
	// Position of SWIER49 field.
	EXTI_SWIER2_SWIER49_Pos = 0x11
	// Bit mask of SWIER49 field.
	EXTI_SWIER2_SWIER49_Msk = 0x20000
	// Bit SWIER49.
	EXTI_SWIER2_SWIER49 = 0x20000
	// Generates an interrupt request
	EXTI_SWIER2_SWIER49_Pend = 0x1
	// Position of SWIER51 field.
	EXTI_SWIER2_SWIER51_Pos = 0x13
	// Bit mask of SWIER51 field.
	EXTI_SWIER2_SWIER51_Msk = 0x80000
	// Bit SWIER51.
	EXTI_SWIER2_SWIER51 = 0x80000
	// Generates an interrupt request
	EXTI_SWIER2_SWIER51_Pend = 0x1

	// D3PMR2: EXTI D3 pending mask register
	// Position of MR34 field.
	EXTI_D3PMR2_MR34_Pos = 0x2
	// Bit mask of MR34 field.
	EXTI_D3PMR2_MR34_Msk = 0x4
	// Bit MR34.
	EXTI_D3PMR2_MR34 = 0x4
	// Interrupt request line is masked
	EXTI_D3PMR2_MR34_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR34_Unmasked = 0x1
	// Position of MR35 field.
	EXTI_D3PMR2_MR35_Pos = 0x3
	// Bit mask of MR35 field.
	EXTI_D3PMR2_MR35_Msk = 0x8
	// Bit MR35.
	EXTI_D3PMR2_MR35 = 0x8
	// Interrupt request line is masked
	EXTI_D3PMR2_MR35_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR35_Unmasked = 0x1
	// Position of MR41 field.
	EXTI_D3PMR2_MR41_Pos = 0x9
	// Bit mask of MR41 field.
	EXTI_D3PMR2_MR41_Msk = 0x200
	// Bit MR41.
	EXTI_D3PMR2_MR41 = 0x200
	// Interrupt request line is masked
	EXTI_D3PMR2_MR41_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR41_Unmasked = 0x1
	// Position of MR48 field.
	EXTI_D3PMR2_MR48_Pos = 0x10
	// Bit mask of MR48 field.
	EXTI_D3PMR2_MR48_Msk = 0x10000
	// Bit MR48.
	EXTI_D3PMR2_MR48 = 0x10000
	// Interrupt request line is masked
	EXTI_D3PMR2_MR48_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR48_Unmasked = 0x1
	// Position of MR49 field.
	EXTI_D3PMR2_MR49_Pos = 0x11
	// Bit mask of MR49 field.
	EXTI_D3PMR2_MR49_Msk = 0x20000
	// Bit MR49.
	EXTI_D3PMR2_MR49 = 0x20000
	// Interrupt request line is masked
	EXTI_D3PMR2_MR49_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR49_Unmasked = 0x1
	// Position of MR50 field.
	EXTI_D3PMR2_MR50_Pos = 0x12
	// Bit mask of MR50 field.
	EXTI_D3PMR2_MR50_Msk = 0x40000
	// Bit MR50.
	EXTI_D3PMR2_MR50 = 0x40000
	// Interrupt request line is masked
	EXTI_D3PMR2_MR50_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR50_Unmasked = 0x1
	// Position of MR51 field.
	EXTI_D3PMR2_MR51_Pos = 0x13
	// Bit mask of MR51 field.
	EXTI_D3PMR2_MR51_Msk = 0x80000
	// Bit MR51.
	EXTI_D3PMR2_MR51 = 0x80000
	// Interrupt request line is masked
	EXTI_D3PMR2_MR51_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR51_Unmasked = 0x1
	// Position of MR52 field.
	EXTI_D3PMR2_MR52_Pos = 0x14
	// Bit mask of MR52 field.
	EXTI_D3PMR2_MR52_Msk = 0x100000
	// Bit MR52.
	EXTI_D3PMR2_MR52 = 0x100000
	// Interrupt request line is masked
	EXTI_D3PMR2_MR52_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR52_Unmasked = 0x1
	// Position of MR53 field.
	EXTI_D3PMR2_MR53_Pos = 0x15
	// Bit mask of MR53 field.
	EXTI_D3PMR2_MR53_Msk = 0x200000
	// Bit MR53.
	EXTI_D3PMR2_MR53 = 0x200000
	// Interrupt request line is masked
	EXTI_D3PMR2_MR53_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR2_MR53_Unmasked = 0x1

	// D3PCR2L: EXTI D3 pending clear selection register low
	// Position of PCS35 field.
	EXTI_D3PCR2L_PCS35_Pos = 0x6
	// Bit mask of PCS35 field.
	EXTI_D3PCR2L_PCS35_Msk = 0xc0
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS35_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS35_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS35_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS35_LPTIM5 = 0x3
	// Position of PCS34 field.
	EXTI_D3PCR2L_PCS34_Pos = 0x4
	// Bit mask of PCS34 field.
	EXTI_D3PCR2L_PCS34_Msk = 0x30
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS34_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS34_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS34_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS34_LPTIM5 = 0x3
	// Position of PCS41 field.
	EXTI_D3PCR2L_PCS41_Pos = 0x12
	// Bit mask of PCS41 field.
	EXTI_D3PCR2L_PCS41_Msk = 0xc0000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS41_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS41_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS41_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2L_PCS41_LPTIM5 = 0x3

	// D3PCR2H: EXTI D3 pending clear selection register high
	// Position of PCS48 field.
	EXTI_D3PCR2H_PCS48_Pos = 0x0
	// Bit mask of PCS48 field.
	EXTI_D3PCR2H_PCS48_Msk = 0x3
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS48_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS48_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS48_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS48_LPTIM5 = 0x3
	// Position of PCS49 field.
	EXTI_D3PCR2H_PCS49_Pos = 0x2
	// Bit mask of PCS49 field.
	EXTI_D3PCR2H_PCS49_Msk = 0xc
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS49_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS49_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS49_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS49_LPTIM5 = 0x3
	// Position of PCS50 field.
	EXTI_D3PCR2H_PCS50_Pos = 0x4
	// Bit mask of PCS50 field.
	EXTI_D3PCR2H_PCS50_Msk = 0x30
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS50_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS50_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS50_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS50_LPTIM5 = 0x3
	// Position of PCS51 field.
	EXTI_D3PCR2H_PCS51_Pos = 0x6
	// Bit mask of PCS51 field.
	EXTI_D3PCR2H_PCS51_Msk = 0xc0
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS51_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS51_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS51_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS51_LPTIM5 = 0x3
	// Position of PCS52 field.
	EXTI_D3PCR2H_PCS52_Pos = 0x8
	// Bit mask of PCS52 field.
	EXTI_D3PCR2H_PCS52_Msk = 0x300
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS52_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS52_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS52_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS52_LPTIM5 = 0x3
	// Position of PCS53 field.
	EXTI_D3PCR2H_PCS53_Pos = 0xa
	// Bit mask of PCS53 field.
	EXTI_D3PCR2H_PCS53_Msk = 0xc00
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS53_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS53_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS53_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR2H_PCS53_LPTIM5 = 0x3

	// RTSR3: EXTI rising trigger selection register
	// Position of TR82 field.
	EXTI_RTSR3_TR82_Pos = 0x12
	// Bit mask of TR82 field.
	EXTI_RTSR3_TR82_Msk = 0x40000
	// Bit TR82.
	EXTI_RTSR3_TR82 = 0x40000
	// Rising edge trigger is disabled
	EXTI_RTSR3_TR82_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR3_TR82_Enabled = 0x1
	// Position of TR84 field.
	EXTI_RTSR3_TR84_Pos = 0x14
	// Bit mask of TR84 field.
	EXTI_RTSR3_TR84_Msk = 0x100000
	// Bit TR84.
	EXTI_RTSR3_TR84 = 0x100000
	// Rising edge trigger is disabled
	EXTI_RTSR3_TR84_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR3_TR84_Enabled = 0x1
	// Position of TR85 field.
	EXTI_RTSR3_TR85_Pos = 0x15
	// Bit mask of TR85 field.
	EXTI_RTSR3_TR85_Msk = 0x200000
	// Bit TR85.
	EXTI_RTSR3_TR85 = 0x200000
	// Rising edge trigger is disabled
	EXTI_RTSR3_TR85_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR3_TR85_Enabled = 0x1
	// Position of TR86 field.
	EXTI_RTSR3_TR86_Pos = 0x16
	// Bit mask of TR86 field.
	EXTI_RTSR3_TR86_Msk = 0x400000
	// Bit TR86.
	EXTI_RTSR3_TR86 = 0x400000
	// Rising edge trigger is disabled
	EXTI_RTSR3_TR86_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR3_TR86_Enabled = 0x1

	// FTSR3: EXTI falling trigger selection register
	// Position of TR82 field.
	EXTI_FTSR3_TR82_Pos = 0x12
	// Bit mask of TR82 field.
	EXTI_FTSR3_TR82_Msk = 0x40000
	// Bit TR82.
	EXTI_FTSR3_TR82 = 0x40000
	// Falling edge trigger is disabled
	EXTI_FTSR3_TR82_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR3_TR82_Enabled = 0x1
	// Position of TR84 field.
	EXTI_FTSR3_TR84_Pos = 0x14
	// Bit mask of TR84 field.
	EXTI_FTSR3_TR84_Msk = 0x100000
	// Bit TR84.
	EXTI_FTSR3_TR84 = 0x100000
	// Falling edge trigger is disabled
	EXTI_FTSR3_TR84_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR3_TR84_Enabled = 0x1
	// Position of TR85 field.
	EXTI_FTSR3_TR85_Pos = 0x15
	// Bit mask of TR85 field.
	EXTI_FTSR3_TR85_Msk = 0x200000
	// Bit TR85.
	EXTI_FTSR3_TR85 = 0x200000
	// Falling edge trigger is disabled
	EXTI_FTSR3_TR85_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR3_TR85_Enabled = 0x1
	// Position of TR86 field.
	EXTI_FTSR3_TR86_Pos = 0x16
	// Bit mask of TR86 field.
	EXTI_FTSR3_TR86_Msk = 0x400000
	// Bit TR86.
	EXTI_FTSR3_TR86 = 0x400000
	// Falling edge trigger is disabled
	EXTI_FTSR3_TR86_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR3_TR86_Enabled = 0x1

	// SWIER3: EXTI software interrupt event register
	// Position of SWIER82 field.
	EXTI_SWIER3_SWIER82_Pos = 0x12
	// Bit mask of SWIER82 field.
	EXTI_SWIER3_SWIER82_Msk = 0x40000
	// Bit SWIER82.
	EXTI_SWIER3_SWIER82 = 0x40000
	// Generates an interrupt request
	EXTI_SWIER3_SWIER82_Pend = 0x1
	// Position of SWIER84 field.
	EXTI_SWIER3_SWIER84_Pos = 0x14
	// Bit mask of SWIER84 field.
	EXTI_SWIER3_SWIER84_Msk = 0x100000
	// Bit SWIER84.
	EXTI_SWIER3_SWIER84 = 0x100000
	// Generates an interrupt request
	EXTI_SWIER3_SWIER84_Pend = 0x1
	// Position of SWIER85 field.
	EXTI_SWIER3_SWIER85_Pos = 0x15
	// Bit mask of SWIER85 field.
	EXTI_SWIER3_SWIER85_Msk = 0x200000
	// Bit SWIER85.
	EXTI_SWIER3_SWIER85 = 0x200000
	// Generates an interrupt request
	EXTI_SWIER3_SWIER85_Pend = 0x1
	// Position of SWIER86 field.
	EXTI_SWIER3_SWIER86_Pos = 0x16
	// Bit mask of SWIER86 field.
	EXTI_SWIER3_SWIER86_Msk = 0x400000
	// Bit SWIER86.
	EXTI_SWIER3_SWIER86 = 0x400000
	// Generates an interrupt request
	EXTI_SWIER3_SWIER86_Pend = 0x1

	// D3PMR3: EXTI D3 pending mask register
	// Position of MR88 field.
	EXTI_D3PMR3_MR88_Pos = 0x18
	// Bit mask of MR88 field.
	EXTI_D3PMR3_MR88_Msk = 0x1000000
	// Bit MR88.
	EXTI_D3PMR3_MR88 = 0x1000000
	// Interrupt request line is masked
	EXTI_D3PMR3_MR88_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_D3PMR3_MR88_Unmasked = 0x1

	// D3PCR3H: EXTI D3 pending clear selection register high
	// Position of PCS88 field.
	EXTI_D3PCR3H_PCS88_Pos = 0x12
	// Bit mask of PCS88 field.
	EXTI_D3PCR3H_PCS88_Msk = 0xc0000
	// DMA ch6 event selected as D3 domain pendclear source
	EXTI_D3PCR3H_PCS88_DMA_CH6 = 0x0
	// DMA ch7 event selected as D3 domain pendclear source
	EXTI_D3PCR3H_PCS88_DMA_CH7 = 0x1
	// LPTIM4 out selected as D3 domain pendclear source
	EXTI_D3PCR3H_PCS88_LPTIM4 = 0x2
	// LPTIM5 out selected as D3 domain pendclear source
	EXTI_D3PCR3H_PCS88_LPTIM5 = 0x3

	// CPUIMR1: EXTI interrupt mask register
	// Position of MR0 field.
	EXTI_CPUIMR1_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_CPUIMR1_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_CPUIMR1_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_CPUIMR1_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_CPUIMR1_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_CPUIMR1_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_CPUIMR1_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_CPUIMR1_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_CPUIMR1_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_CPUIMR1_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_CPUIMR1_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_CPUIMR1_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_CPUIMR1_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_CPUIMR1_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_CPUIMR1_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_CPUIMR1_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_CPUIMR1_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_CPUIMR1_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_CPUIMR1_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_CPUIMR1_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_CPUIMR1_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_CPUIMR1_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_CPUIMR1_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_CPUIMR1_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_CPUIMR1_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_CPUIMR1_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_CPUIMR1_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_CPUIMR1_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_CPUIMR1_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_CPUIMR1_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_CPUIMR1_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_CPUIMR1_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_CPUIMR1_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_CPUIMR1_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_CPUIMR1_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_CPUIMR1_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_CPUIMR1_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_CPUIMR1_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_CPUIMR1_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_CPUIMR1_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_CPUIMR1_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_CPUIMR1_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_CPUIMR1_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_CPUIMR1_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_CPUIMR1_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_CPUIMR1_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_CPUIMR1_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_CPUIMR1_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_CPUIMR1_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_CPUIMR1_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_CPUIMR1_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_CPUIMR1_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_CPUIMR1_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_CPUIMR1_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_CPUIMR1_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_CPUIMR1_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_CPUIMR1_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_CPUIMR1_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_CPUIMR1_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_CPUIMR1_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_CPUIMR1_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_CPUIMR1_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_CPUIMR1_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_CPUIMR1_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_CPUIMR1_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_CPUIMR1_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_CPUIMR1_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_CPUIMR1_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_CPUIMR1_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR22_Unmasked = 0x1
	// Position of MR23 field.
	EXTI_CPUIMR1_MR23_Pos = 0x17
	// Bit mask of MR23 field.
	EXTI_CPUIMR1_MR23_Msk = 0x800000
	// Bit MR23.
	EXTI_CPUIMR1_MR23 = 0x800000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR23_Unmasked = 0x1
	// Position of MR24 field.
	EXTI_CPUIMR1_MR24_Pos = 0x18
	// Bit mask of MR24 field.
	EXTI_CPUIMR1_MR24_Msk = 0x1000000
	// Bit MR24.
	EXTI_CPUIMR1_MR24 = 0x1000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR24_Unmasked = 0x1
	// Position of MR25 field.
	EXTI_CPUIMR1_MR25_Pos = 0x19
	// Bit mask of MR25 field.
	EXTI_CPUIMR1_MR25_Msk = 0x2000000
	// Bit MR25.
	EXTI_CPUIMR1_MR25 = 0x2000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR25_Unmasked = 0x1
	// Position of MR26 field.
	EXTI_CPUIMR1_MR26_Pos = 0x1a
	// Bit mask of MR26 field.
	EXTI_CPUIMR1_MR26_Msk = 0x4000000
	// Bit MR26.
	EXTI_CPUIMR1_MR26 = 0x4000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR26_Unmasked = 0x1
	// Position of MR27 field.
	EXTI_CPUIMR1_MR27_Pos = 0x1b
	// Bit mask of MR27 field.
	EXTI_CPUIMR1_MR27_Msk = 0x8000000
	// Bit MR27.
	EXTI_CPUIMR1_MR27 = 0x8000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR27_Unmasked = 0x1
	// Position of MR28 field.
	EXTI_CPUIMR1_MR28_Pos = 0x1c
	// Bit mask of MR28 field.
	EXTI_CPUIMR1_MR28_Msk = 0x10000000
	// Bit MR28.
	EXTI_CPUIMR1_MR28 = 0x10000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR28_Unmasked = 0x1
	// Position of MR29 field.
	EXTI_CPUIMR1_MR29_Pos = 0x1d
	// Bit mask of MR29 field.
	EXTI_CPUIMR1_MR29_Msk = 0x20000000
	// Bit MR29.
	EXTI_CPUIMR1_MR29 = 0x20000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR29_Unmasked = 0x1
	// Position of MR30 field.
	EXTI_CPUIMR1_MR30_Pos = 0x1e
	// Bit mask of MR30 field.
	EXTI_CPUIMR1_MR30_Msk = 0x40000000
	// Bit MR30.
	EXTI_CPUIMR1_MR30 = 0x40000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR30_Unmasked = 0x1
	// Position of MR31 field.
	EXTI_CPUIMR1_MR31_Pos = 0x1f
	// Bit mask of MR31 field.
	EXTI_CPUIMR1_MR31_Msk = 0x80000000
	// Bit MR31.
	EXTI_CPUIMR1_MR31 = 0x80000000
	// Interrupt request line is masked
	EXTI_CPUIMR1_MR31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR1_MR31_Unmasked = 0x1

	// CPUEMR1: EXTI event mask register
	// Position of MR0 field.
	EXTI_CPUEMR1_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_CPUEMR1_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_CPUEMR1_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_CPUEMR1_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_CPUEMR1_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_CPUEMR1_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_CPUEMR1_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_CPUEMR1_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_CPUEMR1_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_CPUEMR1_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_CPUEMR1_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_CPUEMR1_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_CPUEMR1_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_CPUEMR1_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_CPUEMR1_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_CPUEMR1_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_CPUEMR1_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_CPUEMR1_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_CPUEMR1_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_CPUEMR1_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_CPUEMR1_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_CPUEMR1_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_CPUEMR1_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_CPUEMR1_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_CPUEMR1_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_CPUEMR1_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_CPUEMR1_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_CPUEMR1_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_CPUEMR1_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_CPUEMR1_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_CPUEMR1_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_CPUEMR1_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_CPUEMR1_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_CPUEMR1_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_CPUEMR1_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_CPUEMR1_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_CPUEMR1_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_CPUEMR1_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_CPUEMR1_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_CPUEMR1_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_CPUEMR1_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_CPUEMR1_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_CPUEMR1_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_CPUEMR1_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_CPUEMR1_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_CPUEMR1_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_CPUEMR1_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_CPUEMR1_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_CPUEMR1_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_CPUEMR1_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_CPUEMR1_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_CPUEMR1_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_CPUEMR1_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_CPUEMR1_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_CPUEMR1_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_CPUEMR1_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_CPUEMR1_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_CPUEMR1_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_CPUEMR1_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_CPUEMR1_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_CPUEMR1_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_CPUEMR1_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_CPUEMR1_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_CPUEMR1_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_CPUEMR1_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_CPUEMR1_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_CPUEMR1_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_CPUEMR1_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_CPUEMR1_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR22_Unmasked = 0x1
	// Position of MR23 field.
	EXTI_CPUEMR1_MR23_Pos = 0x17
	// Bit mask of MR23 field.
	EXTI_CPUEMR1_MR23_Msk = 0x800000
	// Bit MR23.
	EXTI_CPUEMR1_MR23 = 0x800000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR23_Unmasked = 0x1
	// Position of MR24 field.
	EXTI_CPUEMR1_MR24_Pos = 0x18
	// Bit mask of MR24 field.
	EXTI_CPUEMR1_MR24_Msk = 0x1000000
	// Bit MR24.
	EXTI_CPUEMR1_MR24 = 0x1000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR24_Unmasked = 0x1
	// Position of MR25 field.
	EXTI_CPUEMR1_MR25_Pos = 0x19
	// Bit mask of MR25 field.
	EXTI_CPUEMR1_MR25_Msk = 0x2000000
	// Bit MR25.
	EXTI_CPUEMR1_MR25 = 0x2000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR25_Unmasked = 0x1
	// Position of MR26 field.
	EXTI_CPUEMR1_MR26_Pos = 0x1a
	// Bit mask of MR26 field.
	EXTI_CPUEMR1_MR26_Msk = 0x4000000
	// Bit MR26.
	EXTI_CPUEMR1_MR26 = 0x4000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR26_Unmasked = 0x1
	// Position of MR27 field.
	EXTI_CPUEMR1_MR27_Pos = 0x1b
	// Bit mask of MR27 field.
	EXTI_CPUEMR1_MR27_Msk = 0x8000000
	// Bit MR27.
	EXTI_CPUEMR1_MR27 = 0x8000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR27_Unmasked = 0x1
	// Position of MR28 field.
	EXTI_CPUEMR1_MR28_Pos = 0x1c
	// Bit mask of MR28 field.
	EXTI_CPUEMR1_MR28_Msk = 0x10000000
	// Bit MR28.
	EXTI_CPUEMR1_MR28 = 0x10000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR28_Unmasked = 0x1
	// Position of MR29 field.
	EXTI_CPUEMR1_MR29_Pos = 0x1d
	// Bit mask of MR29 field.
	EXTI_CPUEMR1_MR29_Msk = 0x20000000
	// Bit MR29.
	EXTI_CPUEMR1_MR29 = 0x20000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR29_Unmasked = 0x1
	// Position of MR30 field.
	EXTI_CPUEMR1_MR30_Pos = 0x1e
	// Bit mask of MR30 field.
	EXTI_CPUEMR1_MR30_Msk = 0x40000000
	// Bit MR30.
	EXTI_CPUEMR1_MR30 = 0x40000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR30_Unmasked = 0x1
	// Position of MR31 field.
	EXTI_CPUEMR1_MR31_Pos = 0x1f
	// Bit mask of MR31 field.
	EXTI_CPUEMR1_MR31_Msk = 0x80000000
	// Bit MR31.
	EXTI_CPUEMR1_MR31 = 0x80000000
	// Interrupt request line is masked
	EXTI_CPUEMR1_MR31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR1_MR31_Unmasked = 0x1

	// CPUPR1: EXTI pending register
	// Position of PR0 field.
	EXTI_CPUPR1_PR0_Pos = 0x0
	// Bit mask of PR0 field.
	EXTI_CPUPR1_PR0_Msk = 0x1
	// Bit PR0.
	EXTI_CPUPR1_PR0 = 0x1
	// No trigger request occurred
	EXTI_CPUPR1_PR0_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR0_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR0_Clear = 0x1
	// Position of PR1 field.
	EXTI_CPUPR1_PR1_Pos = 0x1
	// Bit mask of PR1 field.
	EXTI_CPUPR1_PR1_Msk = 0x2
	// Bit PR1.
	EXTI_CPUPR1_PR1 = 0x2
	// No trigger request occurred
	EXTI_CPUPR1_PR1_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR1_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR1_Clear = 0x1
	// Position of PR2 field.
	EXTI_CPUPR1_PR2_Pos = 0x2
	// Bit mask of PR2 field.
	EXTI_CPUPR1_PR2_Msk = 0x4
	// Bit PR2.
	EXTI_CPUPR1_PR2 = 0x4
	// No trigger request occurred
	EXTI_CPUPR1_PR2_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR2_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR2_Clear = 0x1
	// Position of PR3 field.
	EXTI_CPUPR1_PR3_Pos = 0x3
	// Bit mask of PR3 field.
	EXTI_CPUPR1_PR3_Msk = 0x8
	// Bit PR3.
	EXTI_CPUPR1_PR3 = 0x8
	// No trigger request occurred
	EXTI_CPUPR1_PR3_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR3_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR3_Clear = 0x1
	// Position of PR4 field.
	EXTI_CPUPR1_PR4_Pos = 0x4
	// Bit mask of PR4 field.
	EXTI_CPUPR1_PR4_Msk = 0x10
	// Bit PR4.
	EXTI_CPUPR1_PR4 = 0x10
	// No trigger request occurred
	EXTI_CPUPR1_PR4_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR4_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR4_Clear = 0x1
	// Position of PR5 field.
	EXTI_CPUPR1_PR5_Pos = 0x5
	// Bit mask of PR5 field.
	EXTI_CPUPR1_PR5_Msk = 0x20
	// Bit PR5.
	EXTI_CPUPR1_PR5 = 0x20
	// No trigger request occurred
	EXTI_CPUPR1_PR5_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR5_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR5_Clear = 0x1
	// Position of PR6 field.
	EXTI_CPUPR1_PR6_Pos = 0x6
	// Bit mask of PR6 field.
	EXTI_CPUPR1_PR6_Msk = 0x40
	// Bit PR6.
	EXTI_CPUPR1_PR6 = 0x40
	// No trigger request occurred
	EXTI_CPUPR1_PR6_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR6_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR6_Clear = 0x1
	// Position of PR7 field.
	EXTI_CPUPR1_PR7_Pos = 0x7
	// Bit mask of PR7 field.
	EXTI_CPUPR1_PR7_Msk = 0x80
	// Bit PR7.
	EXTI_CPUPR1_PR7 = 0x80
	// No trigger request occurred
	EXTI_CPUPR1_PR7_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR7_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR7_Clear = 0x1
	// Position of PR8 field.
	EXTI_CPUPR1_PR8_Pos = 0x8
	// Bit mask of PR8 field.
	EXTI_CPUPR1_PR8_Msk = 0x100
	// Bit PR8.
	EXTI_CPUPR1_PR8 = 0x100
	// No trigger request occurred
	EXTI_CPUPR1_PR8_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR8_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR8_Clear = 0x1
	// Position of PR9 field.
	EXTI_CPUPR1_PR9_Pos = 0x9
	// Bit mask of PR9 field.
	EXTI_CPUPR1_PR9_Msk = 0x200
	// Bit PR9.
	EXTI_CPUPR1_PR9 = 0x200
	// No trigger request occurred
	EXTI_CPUPR1_PR9_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR9_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR9_Clear = 0x1
	// Position of PR10 field.
	EXTI_CPUPR1_PR10_Pos = 0xa
	// Bit mask of PR10 field.
	EXTI_CPUPR1_PR10_Msk = 0x400
	// Bit PR10.
	EXTI_CPUPR1_PR10 = 0x400
	// No trigger request occurred
	EXTI_CPUPR1_PR10_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR10_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR10_Clear = 0x1
	// Position of PR11 field.
	EXTI_CPUPR1_PR11_Pos = 0xb
	// Bit mask of PR11 field.
	EXTI_CPUPR1_PR11_Msk = 0x800
	// Bit PR11.
	EXTI_CPUPR1_PR11 = 0x800
	// No trigger request occurred
	EXTI_CPUPR1_PR11_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR11_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR11_Clear = 0x1
	// Position of PR12 field.
	EXTI_CPUPR1_PR12_Pos = 0xc
	// Bit mask of PR12 field.
	EXTI_CPUPR1_PR12_Msk = 0x1000
	// Bit PR12.
	EXTI_CPUPR1_PR12 = 0x1000
	// No trigger request occurred
	EXTI_CPUPR1_PR12_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR12_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR12_Clear = 0x1
	// Position of PR13 field.
	EXTI_CPUPR1_PR13_Pos = 0xd
	// Bit mask of PR13 field.
	EXTI_CPUPR1_PR13_Msk = 0x2000
	// Bit PR13.
	EXTI_CPUPR1_PR13 = 0x2000
	// No trigger request occurred
	EXTI_CPUPR1_PR13_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR13_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR13_Clear = 0x1
	// Position of PR14 field.
	EXTI_CPUPR1_PR14_Pos = 0xe
	// Bit mask of PR14 field.
	EXTI_CPUPR1_PR14_Msk = 0x4000
	// Bit PR14.
	EXTI_CPUPR1_PR14 = 0x4000
	// No trigger request occurred
	EXTI_CPUPR1_PR14_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR14_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR14_Clear = 0x1
	// Position of PR15 field.
	EXTI_CPUPR1_PR15_Pos = 0xf
	// Bit mask of PR15 field.
	EXTI_CPUPR1_PR15_Msk = 0x8000
	// Bit PR15.
	EXTI_CPUPR1_PR15 = 0x8000
	// No trigger request occurred
	EXTI_CPUPR1_PR15_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR15_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR15_Clear = 0x1
	// Position of PR16 field.
	EXTI_CPUPR1_PR16_Pos = 0x10
	// Bit mask of PR16 field.
	EXTI_CPUPR1_PR16_Msk = 0x10000
	// Bit PR16.
	EXTI_CPUPR1_PR16 = 0x10000
	// No trigger request occurred
	EXTI_CPUPR1_PR16_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR16_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR16_Clear = 0x1
	// Position of PR17 field.
	EXTI_CPUPR1_PR17_Pos = 0x11
	// Bit mask of PR17 field.
	EXTI_CPUPR1_PR17_Msk = 0x20000
	// Bit PR17.
	EXTI_CPUPR1_PR17 = 0x20000
	// No trigger request occurred
	EXTI_CPUPR1_PR17_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR17_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR17_Clear = 0x1
	// Position of PR18 field.
	EXTI_CPUPR1_PR18_Pos = 0x12
	// Bit mask of PR18 field.
	EXTI_CPUPR1_PR18_Msk = 0x40000
	// Bit PR18.
	EXTI_CPUPR1_PR18 = 0x40000
	// No trigger request occurred
	EXTI_CPUPR1_PR18_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR18_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR18_Clear = 0x1
	// Position of PR19 field.
	EXTI_CPUPR1_PR19_Pos = 0x13
	// Bit mask of PR19 field.
	EXTI_CPUPR1_PR19_Msk = 0x80000
	// Bit PR19.
	EXTI_CPUPR1_PR19 = 0x80000
	// No trigger request occurred
	EXTI_CPUPR1_PR19_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR19_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR19_Clear = 0x1
	// Position of PR20 field.
	EXTI_CPUPR1_PR20_Pos = 0x14
	// Bit mask of PR20 field.
	EXTI_CPUPR1_PR20_Msk = 0x100000
	// Bit PR20.
	EXTI_CPUPR1_PR20 = 0x100000
	// No trigger request occurred
	EXTI_CPUPR1_PR20_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR20_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR20_Clear = 0x1
	// Position of PR21 field.
	EXTI_CPUPR1_PR21_Pos = 0x15
	// Bit mask of PR21 field.
	EXTI_CPUPR1_PR21_Msk = 0x200000
	// Bit PR21.
	EXTI_CPUPR1_PR21 = 0x200000
	// No trigger request occurred
	EXTI_CPUPR1_PR21_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR1_PR21_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR1_PR21_Clear = 0x1

	// CPUIMR2: EXTI interrupt mask register
	// Position of MR0 field.
	EXTI_CPUIMR2_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_CPUIMR2_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_CPUIMR2_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_CPUIMR2_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_CPUIMR2_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_CPUIMR2_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_CPUIMR2_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_CPUIMR2_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_CPUIMR2_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_CPUIMR2_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_CPUIMR2_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_CPUIMR2_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_CPUIMR2_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_CPUIMR2_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_CPUIMR2_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_CPUIMR2_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_CPUIMR2_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_CPUIMR2_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_CPUIMR2_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_CPUIMR2_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_CPUIMR2_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_CPUIMR2_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_CPUIMR2_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_CPUIMR2_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_CPUIMR2_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_CPUIMR2_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_CPUIMR2_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_CPUIMR2_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_CPUIMR2_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_CPUIMR2_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_CPUIMR2_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_CPUIMR2_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_CPUIMR2_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_CPUIMR2_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_CPUIMR2_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_CPUIMR2_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_CPUIMR2_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_CPUIMR2_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_CPUIMR2_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR12_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_CPUIMR2_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_CPUIMR2_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_CPUIMR2_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_CPUIMR2_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_CPUIMR2_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_CPUIMR2_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_CPUIMR2_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_CPUIMR2_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_CPUIMR2_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_CPUIMR2_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_CPUIMR2_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_CPUIMR2_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_CPUIMR2_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_CPUIMR2_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_CPUIMR2_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_CPUIMR2_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_CPUIMR2_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_CPUIMR2_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_CPUIMR2_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_CPUIMR2_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_CPUIMR2_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_CPUIMR2_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_CPUIMR2_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_CPUIMR2_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_CPUIMR2_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_CPUIMR2_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_CPUIMR2_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR22_Unmasked = 0x1
	// Position of MR23 field.
	EXTI_CPUIMR2_MR23_Pos = 0x17
	// Bit mask of MR23 field.
	EXTI_CPUIMR2_MR23_Msk = 0x800000
	// Bit MR23.
	EXTI_CPUIMR2_MR23 = 0x800000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR23_Unmasked = 0x1
	// Position of MR24 field.
	EXTI_CPUIMR2_MR24_Pos = 0x18
	// Bit mask of MR24 field.
	EXTI_CPUIMR2_MR24_Msk = 0x1000000
	// Bit MR24.
	EXTI_CPUIMR2_MR24 = 0x1000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR24_Unmasked = 0x1
	// Position of MR25 field.
	EXTI_CPUIMR2_MR25_Pos = 0x19
	// Bit mask of MR25 field.
	EXTI_CPUIMR2_MR25_Msk = 0x2000000
	// Bit MR25.
	EXTI_CPUIMR2_MR25 = 0x2000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR25_Unmasked = 0x1
	// Position of MR26 field.
	EXTI_CPUIMR2_MR26_Pos = 0x1a
	// Bit mask of MR26 field.
	EXTI_CPUIMR2_MR26_Msk = 0x4000000
	// Bit MR26.
	EXTI_CPUIMR2_MR26 = 0x4000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR26_Unmasked = 0x1
	// Position of MR27 field.
	EXTI_CPUIMR2_MR27_Pos = 0x1b
	// Bit mask of MR27 field.
	EXTI_CPUIMR2_MR27_Msk = 0x8000000
	// Bit MR27.
	EXTI_CPUIMR2_MR27 = 0x8000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR27_Unmasked = 0x1
	// Position of MR28 field.
	EXTI_CPUIMR2_MR28_Pos = 0x1c
	// Bit mask of MR28 field.
	EXTI_CPUIMR2_MR28_Msk = 0x10000000
	// Bit MR28.
	EXTI_CPUIMR2_MR28 = 0x10000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR28_Unmasked = 0x1
	// Position of MR29 field.
	EXTI_CPUIMR2_MR29_Pos = 0x1d
	// Bit mask of MR29 field.
	EXTI_CPUIMR2_MR29_Msk = 0x20000000
	// Bit MR29.
	EXTI_CPUIMR2_MR29 = 0x20000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR29_Unmasked = 0x1
	// Position of MR30 field.
	EXTI_CPUIMR2_MR30_Pos = 0x1e
	// Bit mask of MR30 field.
	EXTI_CPUIMR2_MR30_Msk = 0x40000000
	// Bit MR30.
	EXTI_CPUIMR2_MR30 = 0x40000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR30_Unmasked = 0x1
	// Position of MR31 field.
	EXTI_CPUIMR2_MR31_Pos = 0x1f
	// Bit mask of MR31 field.
	EXTI_CPUIMR2_MR31_Msk = 0x80000000
	// Bit MR31.
	EXTI_CPUIMR2_MR31 = 0x80000000
	// Interrupt request line is masked
	EXTI_CPUIMR2_MR31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR2_MR31_Unmasked = 0x1

	// CPUEMR2: EXTI event mask register
	// Position of MR32 field.
	EXTI_CPUEMR2_MR32_Pos = 0x0
	// Bit mask of MR32 field.
	EXTI_CPUEMR2_MR32_Msk = 0x1
	// Bit MR32.
	EXTI_CPUEMR2_MR32 = 0x1
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR32_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR32_Unmasked = 0x1
	// Position of MR33 field.
	EXTI_CPUEMR2_MR33_Pos = 0x1
	// Bit mask of MR33 field.
	EXTI_CPUEMR2_MR33_Msk = 0x2
	// Bit MR33.
	EXTI_CPUEMR2_MR33 = 0x2
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR33_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR33_Unmasked = 0x1
	// Position of MR34 field.
	EXTI_CPUEMR2_MR34_Pos = 0x2
	// Bit mask of MR34 field.
	EXTI_CPUEMR2_MR34_Msk = 0x4
	// Bit MR34.
	EXTI_CPUEMR2_MR34 = 0x4
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR34_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR34_Unmasked = 0x1
	// Position of MR35 field.
	EXTI_CPUEMR2_MR35_Pos = 0x3
	// Bit mask of MR35 field.
	EXTI_CPUEMR2_MR35_Msk = 0x8
	// Bit MR35.
	EXTI_CPUEMR2_MR35 = 0x8
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR35_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR35_Unmasked = 0x1
	// Position of MR36 field.
	EXTI_CPUEMR2_MR36_Pos = 0x4
	// Bit mask of MR36 field.
	EXTI_CPUEMR2_MR36_Msk = 0x10
	// Bit MR36.
	EXTI_CPUEMR2_MR36 = 0x10
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR36_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR36_Unmasked = 0x1
	// Position of MR37 field.
	EXTI_CPUEMR2_MR37_Pos = 0x5
	// Bit mask of MR37 field.
	EXTI_CPUEMR2_MR37_Msk = 0x20
	// Bit MR37.
	EXTI_CPUEMR2_MR37 = 0x20
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR37_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR37_Unmasked = 0x1
	// Position of MR38 field.
	EXTI_CPUEMR2_MR38_Pos = 0x6
	// Bit mask of MR38 field.
	EXTI_CPUEMR2_MR38_Msk = 0x40
	// Bit MR38.
	EXTI_CPUEMR2_MR38 = 0x40
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR38_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR38_Unmasked = 0x1
	// Position of MR39 field.
	EXTI_CPUEMR2_MR39_Pos = 0x7
	// Bit mask of MR39 field.
	EXTI_CPUEMR2_MR39_Msk = 0x80
	// Bit MR39.
	EXTI_CPUEMR2_MR39 = 0x80
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR39_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR39_Unmasked = 0x1
	// Position of MR40 field.
	EXTI_CPUEMR2_MR40_Pos = 0x8
	// Bit mask of MR40 field.
	EXTI_CPUEMR2_MR40_Msk = 0x100
	// Bit MR40.
	EXTI_CPUEMR2_MR40 = 0x100
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR40_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR40_Unmasked = 0x1
	// Position of MR41 field.
	EXTI_CPUEMR2_MR41_Pos = 0x9
	// Bit mask of MR41 field.
	EXTI_CPUEMR2_MR41_Msk = 0x200
	// Bit MR41.
	EXTI_CPUEMR2_MR41 = 0x200
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR41_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR41_Unmasked = 0x1
	// Position of MR42 field.
	EXTI_CPUEMR2_MR42_Pos = 0xa
	// Bit mask of MR42 field.
	EXTI_CPUEMR2_MR42_Msk = 0x400
	// Bit MR42.
	EXTI_CPUEMR2_MR42 = 0x400
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR42_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR42_Unmasked = 0x1
	// Position of MR43 field.
	EXTI_CPUEMR2_MR43_Pos = 0xb
	// Bit mask of MR43 field.
	EXTI_CPUEMR2_MR43_Msk = 0x800
	// Bit MR43.
	EXTI_CPUEMR2_MR43 = 0x800
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR43_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR43_Unmasked = 0x1
	// Position of MR44 field.
	EXTI_CPUEMR2_MR44_Pos = 0xc
	// Bit mask of MR44 field.
	EXTI_CPUEMR2_MR44_Msk = 0x1000
	// Bit MR44.
	EXTI_CPUEMR2_MR44 = 0x1000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR44_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR44_Unmasked = 0x1
	// Position of MR46 field.
	EXTI_CPUEMR2_MR46_Pos = 0xe
	// Bit mask of MR46 field.
	EXTI_CPUEMR2_MR46_Msk = 0x4000
	// Bit MR46.
	EXTI_CPUEMR2_MR46 = 0x4000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR46_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR46_Unmasked = 0x1
	// Position of MR47 field.
	EXTI_CPUEMR2_MR47_Pos = 0xf
	// Bit mask of MR47 field.
	EXTI_CPUEMR2_MR47_Msk = 0x8000
	// Bit MR47.
	EXTI_CPUEMR2_MR47 = 0x8000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR47_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR47_Unmasked = 0x1
	// Position of MR48 field.
	EXTI_CPUEMR2_MR48_Pos = 0x10
	// Bit mask of MR48 field.
	EXTI_CPUEMR2_MR48_Msk = 0x10000
	// Bit MR48.
	EXTI_CPUEMR2_MR48 = 0x10000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR48_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR48_Unmasked = 0x1
	// Position of MR49 field.
	EXTI_CPUEMR2_MR49_Pos = 0x11
	// Bit mask of MR49 field.
	EXTI_CPUEMR2_MR49_Msk = 0x20000
	// Bit MR49.
	EXTI_CPUEMR2_MR49 = 0x20000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR49_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR49_Unmasked = 0x1
	// Position of MR50 field.
	EXTI_CPUEMR2_MR50_Pos = 0x12
	// Bit mask of MR50 field.
	EXTI_CPUEMR2_MR50_Msk = 0x40000
	// Bit MR50.
	EXTI_CPUEMR2_MR50 = 0x40000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR50_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR50_Unmasked = 0x1
	// Position of MR51 field.
	EXTI_CPUEMR2_MR51_Pos = 0x13
	// Bit mask of MR51 field.
	EXTI_CPUEMR2_MR51_Msk = 0x80000
	// Bit MR51.
	EXTI_CPUEMR2_MR51 = 0x80000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR51_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR51_Unmasked = 0x1
	// Position of MR52 field.
	EXTI_CPUEMR2_MR52_Pos = 0x14
	// Bit mask of MR52 field.
	EXTI_CPUEMR2_MR52_Msk = 0x100000
	// Bit MR52.
	EXTI_CPUEMR2_MR52 = 0x100000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR52_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR52_Unmasked = 0x1
	// Position of MR53 field.
	EXTI_CPUEMR2_MR53_Pos = 0x15
	// Bit mask of MR53 field.
	EXTI_CPUEMR2_MR53_Msk = 0x200000
	// Bit MR53.
	EXTI_CPUEMR2_MR53 = 0x200000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR53_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR53_Unmasked = 0x1
	// Position of MR54 field.
	EXTI_CPUEMR2_MR54_Pos = 0x16
	// Bit mask of MR54 field.
	EXTI_CPUEMR2_MR54_Msk = 0x400000
	// Bit MR54.
	EXTI_CPUEMR2_MR54 = 0x400000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR54_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR54_Unmasked = 0x1
	// Position of MR55 field.
	EXTI_CPUEMR2_MR55_Pos = 0x17
	// Bit mask of MR55 field.
	EXTI_CPUEMR2_MR55_Msk = 0x800000
	// Bit MR55.
	EXTI_CPUEMR2_MR55 = 0x800000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR55_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR55_Unmasked = 0x1
	// Position of MR56 field.
	EXTI_CPUEMR2_MR56_Pos = 0x18
	// Bit mask of MR56 field.
	EXTI_CPUEMR2_MR56_Msk = 0x1000000
	// Bit MR56.
	EXTI_CPUEMR2_MR56 = 0x1000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR56_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR56_Unmasked = 0x1
	// Position of MR57 field.
	EXTI_CPUEMR2_MR57_Pos = 0x19
	// Bit mask of MR57 field.
	EXTI_CPUEMR2_MR57_Msk = 0x2000000
	// Bit MR57.
	EXTI_CPUEMR2_MR57 = 0x2000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR57_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR57_Unmasked = 0x1
	// Position of MR58 field.
	EXTI_CPUEMR2_MR58_Pos = 0x1a
	// Bit mask of MR58 field.
	EXTI_CPUEMR2_MR58_Msk = 0x4000000
	// Bit MR58.
	EXTI_CPUEMR2_MR58 = 0x4000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR58_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR58_Unmasked = 0x1
	// Position of MR59 field.
	EXTI_CPUEMR2_MR59_Pos = 0x1b
	// Bit mask of MR59 field.
	EXTI_CPUEMR2_MR59_Msk = 0x8000000
	// Bit MR59.
	EXTI_CPUEMR2_MR59 = 0x8000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR59_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR59_Unmasked = 0x1
	// Position of MR60 field.
	EXTI_CPUEMR2_MR60_Pos = 0x1c
	// Bit mask of MR60 field.
	EXTI_CPUEMR2_MR60_Msk = 0x10000000
	// Bit MR60.
	EXTI_CPUEMR2_MR60 = 0x10000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR60_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR60_Unmasked = 0x1
	// Position of MR61 field.
	EXTI_CPUEMR2_MR61_Pos = 0x1d
	// Bit mask of MR61 field.
	EXTI_CPUEMR2_MR61_Msk = 0x20000000
	// Bit MR61.
	EXTI_CPUEMR2_MR61 = 0x20000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR61_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR61_Unmasked = 0x1
	// Position of MR62 field.
	EXTI_CPUEMR2_MR62_Pos = 0x1e
	// Bit mask of MR62 field.
	EXTI_CPUEMR2_MR62_Msk = 0x40000000
	// Bit MR62.
	EXTI_CPUEMR2_MR62 = 0x40000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR62_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR62_Unmasked = 0x1
	// Position of MR63 field.
	EXTI_CPUEMR2_MR63_Pos = 0x1f
	// Bit mask of MR63 field.
	EXTI_CPUEMR2_MR63_Msk = 0x80000000
	// Bit MR63.
	EXTI_CPUEMR2_MR63 = 0x80000000
	// Interrupt request line is masked
	EXTI_CPUEMR2_MR63_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR2_MR63_Unmasked = 0x1

	// CPUPR2: EXTI pending register
	// Position of PR49 field.
	EXTI_CPUPR2_PR49_Pos = 0x11
	// Bit mask of PR49 field.
	EXTI_CPUPR2_PR49_Msk = 0x20000
	// Bit PR49.
	EXTI_CPUPR2_PR49 = 0x20000
	// No trigger request occurred
	EXTI_CPUPR2_PR49_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR2_PR49_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR2_PR49_Clear = 0x1
	// Position of PR51 field.
	EXTI_CPUPR2_PR51_Pos = 0x13
	// Bit mask of PR51 field.
	EXTI_CPUPR2_PR51_Msk = 0x80000
	// Bit PR51.
	EXTI_CPUPR2_PR51 = 0x80000
	// No trigger request occurred
	EXTI_CPUPR2_PR51_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR2_PR51_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR2_PR51_Clear = 0x1

	// CPUIMR3: EXTI interrupt mask register
	// Position of MR64 field.
	EXTI_CPUIMR3_MR64_Pos = 0x0
	// Bit mask of MR64 field.
	EXTI_CPUIMR3_MR64_Msk = 0x1
	// Bit MR64.
	EXTI_CPUIMR3_MR64 = 0x1
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR64_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR64_Unmasked = 0x1
	// Position of MR65 field.
	EXTI_CPUIMR3_MR65_Pos = 0x1
	// Bit mask of MR65 field.
	EXTI_CPUIMR3_MR65_Msk = 0x2
	// Bit MR65.
	EXTI_CPUIMR3_MR65 = 0x2
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR65_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR65_Unmasked = 0x1
	// Position of MR66 field.
	EXTI_CPUIMR3_MR66_Pos = 0x2
	// Bit mask of MR66 field.
	EXTI_CPUIMR3_MR66_Msk = 0x4
	// Bit MR66.
	EXTI_CPUIMR3_MR66 = 0x4
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR66_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR66_Unmasked = 0x1
	// Position of MR67 field.
	EXTI_CPUIMR3_MR67_Pos = 0x3
	// Bit mask of MR67 field.
	EXTI_CPUIMR3_MR67_Msk = 0x8
	// Bit MR67.
	EXTI_CPUIMR3_MR67 = 0x8
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR67_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR67_Unmasked = 0x1
	// Position of MR68 field.
	EXTI_CPUIMR3_MR68_Pos = 0x4
	// Bit mask of MR68 field.
	EXTI_CPUIMR3_MR68_Msk = 0x10
	// Bit MR68.
	EXTI_CPUIMR3_MR68 = 0x10
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR68_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR68_Unmasked = 0x1
	// Position of MR69 field.
	EXTI_CPUIMR3_MR69_Pos = 0x5
	// Bit mask of MR69 field.
	EXTI_CPUIMR3_MR69_Msk = 0x20
	// Bit MR69.
	EXTI_CPUIMR3_MR69 = 0x20
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR69_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR69_Unmasked = 0x1
	// Position of MR70 field.
	EXTI_CPUIMR3_MR70_Pos = 0x6
	// Bit mask of MR70 field.
	EXTI_CPUIMR3_MR70_Msk = 0x40
	// Bit MR70.
	EXTI_CPUIMR3_MR70 = 0x40
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR70_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR70_Unmasked = 0x1
	// Position of MR71 field.
	EXTI_CPUIMR3_MR71_Pos = 0x7
	// Bit mask of MR71 field.
	EXTI_CPUIMR3_MR71_Msk = 0x80
	// Bit MR71.
	EXTI_CPUIMR3_MR71 = 0x80
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR71_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR71_Unmasked = 0x1
	// Position of MR72 field.
	EXTI_CPUIMR3_MR72_Pos = 0x8
	// Bit mask of MR72 field.
	EXTI_CPUIMR3_MR72_Msk = 0x100
	// Bit MR72.
	EXTI_CPUIMR3_MR72 = 0x100
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR72_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR72_Unmasked = 0x1
	// Position of MR73 field.
	EXTI_CPUIMR3_MR73_Pos = 0x9
	// Bit mask of MR73 field.
	EXTI_CPUIMR3_MR73_Msk = 0x200
	// Bit MR73.
	EXTI_CPUIMR3_MR73 = 0x200
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR73_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR73_Unmasked = 0x1
	// Position of MR74 field.
	EXTI_CPUIMR3_MR74_Pos = 0xa
	// Bit mask of MR74 field.
	EXTI_CPUIMR3_MR74_Msk = 0x400
	// Bit MR74.
	EXTI_CPUIMR3_MR74 = 0x400
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR74_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR74_Unmasked = 0x1
	// Position of MR75 field.
	EXTI_CPUIMR3_MR75_Pos = 0xb
	// Bit mask of MR75 field.
	EXTI_CPUIMR3_MR75_Msk = 0x800
	// Bit MR75.
	EXTI_CPUIMR3_MR75 = 0x800
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR75_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR75_Unmasked = 0x1
	// Position of MR76 field.
	EXTI_CPUIMR3_MR76_Pos = 0xc
	// Bit mask of MR76 field.
	EXTI_CPUIMR3_MR76_Msk = 0x1000
	// Bit MR76.
	EXTI_CPUIMR3_MR76 = 0x1000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR76_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR76_Unmasked = 0x1
	// Position of MR77 field.
	EXTI_CPUIMR3_MR77_Pos = 0xd
	// Bit mask of MR77 field.
	EXTI_CPUIMR3_MR77_Msk = 0x2000
	// Bit MR77.
	EXTI_CPUIMR3_MR77 = 0x2000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR77_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR77_Unmasked = 0x1
	// Position of MR78 field.
	EXTI_CPUIMR3_MR78_Pos = 0xe
	// Bit mask of MR78 field.
	EXTI_CPUIMR3_MR78_Msk = 0x4000
	// Bit MR78.
	EXTI_CPUIMR3_MR78 = 0x4000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR78_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR78_Unmasked = 0x1
	// Position of MR79 field.
	EXTI_CPUIMR3_MR79_Pos = 0xf
	// Bit mask of MR79 field.
	EXTI_CPUIMR3_MR79_Msk = 0x8000
	// Bit MR79.
	EXTI_CPUIMR3_MR79 = 0x8000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR79_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR79_Unmasked = 0x1
	// Position of MR80 field.
	EXTI_CPUIMR3_MR80_Pos = 0x10
	// Bit mask of MR80 field.
	EXTI_CPUIMR3_MR80_Msk = 0x10000
	// Bit MR80.
	EXTI_CPUIMR3_MR80 = 0x10000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR80_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR80_Unmasked = 0x1
	// Position of MR82 field.
	EXTI_CPUIMR3_MR82_Pos = 0x12
	// Bit mask of MR82 field.
	EXTI_CPUIMR3_MR82_Msk = 0x40000
	// Bit MR82.
	EXTI_CPUIMR3_MR82 = 0x40000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR82_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR82_Unmasked = 0x1
	// Position of MR84 field.
	EXTI_CPUIMR3_MR84_Pos = 0x14
	// Bit mask of MR84 field.
	EXTI_CPUIMR3_MR84_Msk = 0x100000
	// Bit MR84.
	EXTI_CPUIMR3_MR84 = 0x100000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR84_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR84_Unmasked = 0x1
	// Position of MR85 field.
	EXTI_CPUIMR3_MR85_Pos = 0x15
	// Bit mask of MR85 field.
	EXTI_CPUIMR3_MR85_Msk = 0x200000
	// Bit MR85.
	EXTI_CPUIMR3_MR85 = 0x200000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR85_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR85_Unmasked = 0x1
	// Position of MR86 field.
	EXTI_CPUIMR3_MR86_Pos = 0x16
	// Bit mask of MR86 field.
	EXTI_CPUIMR3_MR86_Msk = 0x400000
	// Bit MR86.
	EXTI_CPUIMR3_MR86 = 0x400000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR86_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR86_Unmasked = 0x1
	// Position of MR87 field.
	EXTI_CPUIMR3_MR87_Pos = 0x17
	// Bit mask of MR87 field.
	EXTI_CPUIMR3_MR87_Msk = 0x800000
	// Bit MR87.
	EXTI_CPUIMR3_MR87 = 0x800000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR87_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR87_Unmasked = 0x1
	// Position of MR88 field.
	EXTI_CPUIMR3_MR88_Pos = 0x18
	// Bit mask of MR88 field.
	EXTI_CPUIMR3_MR88_Msk = 0x1000000
	// Bit MR88.
	EXTI_CPUIMR3_MR88 = 0x1000000
	// Interrupt request line is masked
	EXTI_CPUIMR3_MR88_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUIMR3_MR88_Unmasked = 0x1

	// CPUEMR3: EXTI event mask register
	// Position of MR64 field.
	EXTI_CPUEMR3_MR64_Pos = 0x0
	// Bit mask of MR64 field.
	EXTI_CPUEMR3_MR64_Msk = 0x1
	// Bit MR64.
	EXTI_CPUEMR3_MR64 = 0x1
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR64_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR64_Unmasked = 0x1
	// Position of MR65 field.
	EXTI_CPUEMR3_MR65_Pos = 0x1
	// Bit mask of MR65 field.
	EXTI_CPUEMR3_MR65_Msk = 0x2
	// Bit MR65.
	EXTI_CPUEMR3_MR65 = 0x2
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR65_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR65_Unmasked = 0x1
	// Position of MR66 field.
	EXTI_CPUEMR3_MR66_Pos = 0x2
	// Bit mask of MR66 field.
	EXTI_CPUEMR3_MR66_Msk = 0x4
	// Bit MR66.
	EXTI_CPUEMR3_MR66 = 0x4
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR66_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR66_Unmasked = 0x1
	// Position of MR67 field.
	EXTI_CPUEMR3_MR67_Pos = 0x3
	// Bit mask of MR67 field.
	EXTI_CPUEMR3_MR67_Msk = 0x8
	// Bit MR67.
	EXTI_CPUEMR3_MR67 = 0x8
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR67_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR67_Unmasked = 0x1
	// Position of MR68 field.
	EXTI_CPUEMR3_MR68_Pos = 0x4
	// Bit mask of MR68 field.
	EXTI_CPUEMR3_MR68_Msk = 0x10
	// Bit MR68.
	EXTI_CPUEMR3_MR68 = 0x10
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR68_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR68_Unmasked = 0x1
	// Position of MR69 field.
	EXTI_CPUEMR3_MR69_Pos = 0x5
	// Bit mask of MR69 field.
	EXTI_CPUEMR3_MR69_Msk = 0x20
	// Bit MR69.
	EXTI_CPUEMR3_MR69 = 0x20
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR69_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR69_Unmasked = 0x1
	// Position of MR70 field.
	EXTI_CPUEMR3_MR70_Pos = 0x6
	// Bit mask of MR70 field.
	EXTI_CPUEMR3_MR70_Msk = 0x40
	// Bit MR70.
	EXTI_CPUEMR3_MR70 = 0x40
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR70_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR70_Unmasked = 0x1
	// Position of MR71 field.
	EXTI_CPUEMR3_MR71_Pos = 0x7
	// Bit mask of MR71 field.
	EXTI_CPUEMR3_MR71_Msk = 0x80
	// Bit MR71.
	EXTI_CPUEMR3_MR71 = 0x80
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR71_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR71_Unmasked = 0x1
	// Position of MR72 field.
	EXTI_CPUEMR3_MR72_Pos = 0x8
	// Bit mask of MR72 field.
	EXTI_CPUEMR3_MR72_Msk = 0x100
	// Bit MR72.
	EXTI_CPUEMR3_MR72 = 0x100
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR72_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR72_Unmasked = 0x1
	// Position of MR73 field.
	EXTI_CPUEMR3_MR73_Pos = 0x9
	// Bit mask of MR73 field.
	EXTI_CPUEMR3_MR73_Msk = 0x200
	// Bit MR73.
	EXTI_CPUEMR3_MR73 = 0x200
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR73_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR73_Unmasked = 0x1
	// Position of MR74 field.
	EXTI_CPUEMR3_MR74_Pos = 0xa
	// Bit mask of MR74 field.
	EXTI_CPUEMR3_MR74_Msk = 0x400
	// Bit MR74.
	EXTI_CPUEMR3_MR74 = 0x400
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR74_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR74_Unmasked = 0x1
	// Position of MR75 field.
	EXTI_CPUEMR3_MR75_Pos = 0xb
	// Bit mask of MR75 field.
	EXTI_CPUEMR3_MR75_Msk = 0x800
	// Bit MR75.
	EXTI_CPUEMR3_MR75 = 0x800
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR75_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR75_Unmasked = 0x1
	// Position of MR76 field.
	EXTI_CPUEMR3_MR76_Pos = 0xc
	// Bit mask of MR76 field.
	EXTI_CPUEMR3_MR76_Msk = 0x1000
	// Bit MR76.
	EXTI_CPUEMR3_MR76 = 0x1000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR76_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR76_Unmasked = 0x1
	// Position of MR77 field.
	EXTI_CPUEMR3_MR77_Pos = 0xd
	// Bit mask of MR77 field.
	EXTI_CPUEMR3_MR77_Msk = 0x2000
	// Bit MR77.
	EXTI_CPUEMR3_MR77 = 0x2000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR77_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR77_Unmasked = 0x1
	// Position of MR78 field.
	EXTI_CPUEMR3_MR78_Pos = 0xe
	// Bit mask of MR78 field.
	EXTI_CPUEMR3_MR78_Msk = 0x4000
	// Bit MR78.
	EXTI_CPUEMR3_MR78 = 0x4000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR78_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR78_Unmasked = 0x1
	// Position of MR79 field.
	EXTI_CPUEMR3_MR79_Pos = 0xf
	// Bit mask of MR79 field.
	EXTI_CPUEMR3_MR79_Msk = 0x8000
	// Bit MR79.
	EXTI_CPUEMR3_MR79 = 0x8000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR79_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR79_Unmasked = 0x1
	// Position of MR80 field.
	EXTI_CPUEMR3_MR80_Pos = 0x10
	// Bit mask of MR80 field.
	EXTI_CPUEMR3_MR80_Msk = 0x10000
	// Bit MR80.
	EXTI_CPUEMR3_MR80 = 0x10000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR80_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR80_Unmasked = 0x1
	// Position of MR82 field.
	EXTI_CPUEMR3_MR82_Pos = 0x12
	// Bit mask of MR82 field.
	EXTI_CPUEMR3_MR82_Msk = 0x40000
	// Bit MR82.
	EXTI_CPUEMR3_MR82 = 0x40000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR82_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR82_Unmasked = 0x1
	// Position of MR84 field.
	EXTI_CPUEMR3_MR84_Pos = 0x14
	// Bit mask of MR84 field.
	EXTI_CPUEMR3_MR84_Msk = 0x100000
	// Bit MR84.
	EXTI_CPUEMR3_MR84 = 0x100000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR84_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR84_Unmasked = 0x1
	// Position of MR85 field.
	EXTI_CPUEMR3_MR85_Pos = 0x15
	// Bit mask of MR85 field.
	EXTI_CPUEMR3_MR85_Msk = 0x200000
	// Bit MR85.
	EXTI_CPUEMR3_MR85 = 0x200000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR85_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR85_Unmasked = 0x1
	// Position of MR86 field.
	EXTI_CPUEMR3_MR86_Pos = 0x16
	// Bit mask of MR86 field.
	EXTI_CPUEMR3_MR86_Msk = 0x400000
	// Bit MR86.
	EXTI_CPUEMR3_MR86 = 0x400000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR86_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR86_Unmasked = 0x1
	// Position of MR87 field.
	EXTI_CPUEMR3_MR87_Pos = 0x17
	// Bit mask of MR87 field.
	EXTI_CPUEMR3_MR87_Msk = 0x800000
	// Bit MR87.
	EXTI_CPUEMR3_MR87 = 0x800000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR87_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR87_Unmasked = 0x1
	// Position of MR88 field.
	EXTI_CPUEMR3_MR88_Pos = 0x18
	// Bit mask of MR88 field.
	EXTI_CPUEMR3_MR88_Msk = 0x1000000
	// Bit MR88.
	EXTI_CPUEMR3_MR88 = 0x1000000
	// Interrupt request line is masked
	EXTI_CPUEMR3_MR88_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_CPUEMR3_MR88_Unmasked = 0x1

	// CPUPR3: EXTI pending register
	// Position of PR82 field.
	EXTI_CPUPR3_PR82_Pos = 0x12
	// Bit mask of PR82 field.
	EXTI_CPUPR3_PR82_Msk = 0x40000
	// Bit PR82.
	EXTI_CPUPR3_PR82 = 0x40000
	// No trigger request occurred
	EXTI_CPUPR3_PR82_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR3_PR82_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR3_PR82_Clear = 0x1
	// Position of PR84 field.
	EXTI_CPUPR3_PR84_Pos = 0x14
	// Bit mask of PR84 field.
	EXTI_CPUPR3_PR84_Msk = 0x100000
	// Bit PR84.
	EXTI_CPUPR3_PR84 = 0x100000
	// No trigger request occurred
	EXTI_CPUPR3_PR84_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR3_PR84_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR3_PR84_Clear = 0x1
	// Position of PR85 field.
	EXTI_CPUPR3_PR85_Pos = 0x15
	// Bit mask of PR85 field.
	EXTI_CPUPR3_PR85_Msk = 0x200000
	// Bit PR85.
	EXTI_CPUPR3_PR85 = 0x200000
	// No trigger request occurred
	EXTI_CPUPR3_PR85_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR3_PR85_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR3_PR85_Clear = 0x1
	// Position of PR86 field.
	EXTI_CPUPR3_PR86_Pos = 0x16
	// Bit mask of PR86 field.
	EXTI_CPUPR3_PR86_Msk = 0x400000
	// Bit PR86.
	EXTI_CPUPR3_PR86 = 0x400000
	// No trigger request occurred
	EXTI_CPUPR3_PR86_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_CPUPR3_PR86_Pending = 0x1
	// Clears pending bit
	EXTI_CPUPR3_PR86_Clear = 0x1
)

// Constants for Ethernet_MAC: Ethernet: media access control (MAC)
const (
	// MACCR: Operating mode configuration register
	// Position of RE field.
	Ethernet_MACCR_RE_Pos = 0x0
	// Bit mask of RE field.
	Ethernet_MACCR_RE_Msk = 0x1
	// Bit RE.
	Ethernet_MACCR_RE = 0x1
	// Position of TE field.
	Ethernet_MACCR_TE_Pos = 0x1
	// Bit mask of TE field.
	Ethernet_MACCR_TE_Msk = 0x2
	// Bit TE.
	Ethernet_MACCR_TE = 0x2
	// Position of PRELEN field.
	Ethernet_MACCR_PRELEN_Pos = 0x2
	// Bit mask of PRELEN field.
	Ethernet_MACCR_PRELEN_Msk = 0xc
	// Position of DC field.
	Ethernet_MACCR_DC_Pos = 0x4
	// Bit mask of DC field.
	Ethernet_MACCR_DC_Msk = 0x10
	// Bit DC.
	Ethernet_MACCR_DC = 0x10
	// Position of BL field.
	Ethernet_MACCR_BL_Pos = 0x5
	// Bit mask of BL field.
	Ethernet_MACCR_BL_Msk = 0x60
	// Position of DR field.
	Ethernet_MACCR_DR_Pos = 0x8
	// Bit mask of DR field.
	Ethernet_MACCR_DR_Msk = 0x100
	// Bit DR.
	Ethernet_MACCR_DR = 0x100
	// Position of DCRS field.
	Ethernet_MACCR_DCRS_Pos = 0x9
	// Bit mask of DCRS field.
	Ethernet_MACCR_DCRS_Msk = 0x200
	// Bit DCRS.
	Ethernet_MACCR_DCRS = 0x200
	// Position of DO field.
	Ethernet_MACCR_DO_Pos = 0xa
	// Bit mask of DO field.
	Ethernet_MACCR_DO_Msk = 0x400
	// Bit DO.
	Ethernet_MACCR_DO = 0x400
	// Position of ECRSFD field.
	Ethernet_MACCR_ECRSFD_Pos = 0xb
	// Bit mask of ECRSFD field.
	Ethernet_MACCR_ECRSFD_Msk = 0x800
	// Bit ECRSFD.
	Ethernet_MACCR_ECRSFD = 0x800
	// Position of LM field.
	Ethernet_MACCR_LM_Pos = 0xc
	// Bit mask of LM field.
	Ethernet_MACCR_LM_Msk = 0x1000
	// Bit LM.
	Ethernet_MACCR_LM = 0x1000
	// Position of DM field.
	Ethernet_MACCR_DM_Pos = 0xd
	// Bit mask of DM field.
	Ethernet_MACCR_DM_Msk = 0x2000
	// Bit DM.
	Ethernet_MACCR_DM = 0x2000
	// Position of FES field.
	Ethernet_MACCR_FES_Pos = 0xe
	// Bit mask of FES field.
	Ethernet_MACCR_FES_Msk = 0x4000
	// Bit FES.
	Ethernet_MACCR_FES = 0x4000
	// Position of JE field.
	Ethernet_MACCR_JE_Pos = 0x10
	// Bit mask of JE field.
	Ethernet_MACCR_JE_Msk = 0x10000
	// Bit JE.
	Ethernet_MACCR_JE = 0x10000
	// Position of JD field.
	Ethernet_MACCR_JD_Pos = 0x11
	// Bit mask of JD field.
	Ethernet_MACCR_JD_Msk = 0x20000
	// Bit JD.
	Ethernet_MACCR_JD = 0x20000
	// Position of WD field.
	Ethernet_MACCR_WD_Pos = 0x13
	// Bit mask of WD field.
	Ethernet_MACCR_WD_Msk = 0x80000
	// Bit WD.
	Ethernet_MACCR_WD = 0x80000
	// Position of ACS field.
	Ethernet_MACCR_ACS_Pos = 0x14
	// Bit mask of ACS field.
	Ethernet_MACCR_ACS_Msk = 0x100000
	// Bit ACS.
	Ethernet_MACCR_ACS = 0x100000
	// Position of CST field.
	Ethernet_MACCR_CST_Pos = 0x15
	// Bit mask of CST field.
	Ethernet_MACCR_CST_Msk = 0x200000
	// Bit CST.
	Ethernet_MACCR_CST = 0x200000
	// Position of S2KP field.
	Ethernet_MACCR_S2KP_Pos = 0x16
	// Bit mask of S2KP field.
	Ethernet_MACCR_S2KP_Msk = 0x400000
	// Bit S2KP.
	Ethernet_MACCR_S2KP = 0x400000
	// Position of GPSLCE field.
	Ethernet_MACCR_GPSLCE_Pos = 0x17
	// Bit mask of GPSLCE field.
	Ethernet_MACCR_GPSLCE_Msk = 0x800000
	// Bit GPSLCE.
	Ethernet_MACCR_GPSLCE = 0x800000
	// Position of IPG field.
	Ethernet_MACCR_IPG_Pos = 0x18
	// Bit mask of IPG field.
	Ethernet_MACCR_IPG_Msk = 0x7000000
	// Position of IPC field.
	Ethernet_MACCR_IPC_Pos = 0x1b
	// Bit mask of IPC field.
	Ethernet_MACCR_IPC_Msk = 0x8000000
	// Bit IPC.
	Ethernet_MACCR_IPC = 0x8000000
	// Position of SARC field.
	Ethernet_MACCR_SARC_Pos = 0x1c
	// Bit mask of SARC field.
	Ethernet_MACCR_SARC_Msk = 0x70000000
	// Position of ARPEN field.
	Ethernet_MACCR_ARPEN_Pos = 0x1f
	// Bit mask of ARPEN field.
	Ethernet_MACCR_ARPEN_Msk = 0x80000000
	// Bit ARPEN.
	Ethernet_MACCR_ARPEN = 0x80000000

	// MACECR: Extended operating mode configuration register
	// Position of GPSL field.
	Ethernet_MACECR_GPSL_Pos = 0x0
	// Bit mask of GPSL field.
	Ethernet_MACECR_GPSL_Msk = 0x3fff
	// Position of DCRCC field.
	Ethernet_MACECR_DCRCC_Pos = 0x10
	// Bit mask of DCRCC field.
	Ethernet_MACECR_DCRCC_Msk = 0x10000
	// Bit DCRCC.
	Ethernet_MACECR_DCRCC = 0x10000
	// Position of SPEN field.
	Ethernet_MACECR_SPEN_Pos = 0x11
	// Bit mask of SPEN field.
	Ethernet_MACECR_SPEN_Msk = 0x20000
	// Bit SPEN.
	Ethernet_MACECR_SPEN = 0x20000
	// Position of USP field.
	Ethernet_MACECR_USP_Pos = 0x12
	// Bit mask of USP field.
	Ethernet_MACECR_USP_Msk = 0x40000
	// Bit USP.
	Ethernet_MACECR_USP = 0x40000
	// Position of EIPGEN field.
	Ethernet_MACECR_EIPGEN_Pos = 0x18
	// Bit mask of EIPGEN field.
	Ethernet_MACECR_EIPGEN_Msk = 0x1000000
	// Bit EIPGEN.
	Ethernet_MACECR_EIPGEN = 0x1000000
	// Position of EIPG field.
	Ethernet_MACECR_EIPG_Pos = 0x19
	// Bit mask of EIPG field.
	Ethernet_MACECR_EIPG_Msk = 0x3e000000

	// MACPFR: Packet filtering control register
	// Position of PR field.
	Ethernet_MACPFR_PR_Pos = 0x0
	// Bit mask of PR field.
	Ethernet_MACPFR_PR_Msk = 0x1
	// Bit PR.
	Ethernet_MACPFR_PR = 0x1
	// Position of HUC field.
	Ethernet_MACPFR_HUC_Pos = 0x1
	// Bit mask of HUC field.
	Ethernet_MACPFR_HUC_Msk = 0x2
	// Bit HUC.
	Ethernet_MACPFR_HUC = 0x2
	// Position of HMC field.
	Ethernet_MACPFR_HMC_Pos = 0x2
	// Bit mask of HMC field.
	Ethernet_MACPFR_HMC_Msk = 0x4
	// Bit HMC.
	Ethernet_MACPFR_HMC = 0x4
	// Position of DAIF field.
	Ethernet_MACPFR_DAIF_Pos = 0x3
	// Bit mask of DAIF field.
	Ethernet_MACPFR_DAIF_Msk = 0x8
	// Bit DAIF.
	Ethernet_MACPFR_DAIF = 0x8
	// Position of PM field.
	Ethernet_MACPFR_PM_Pos = 0x4
	// Bit mask of PM field.
	Ethernet_MACPFR_PM_Msk = 0x10
	// Bit PM.
	Ethernet_MACPFR_PM = 0x10
	// Position of DBF field.
	Ethernet_MACPFR_DBF_Pos = 0x5
	// Bit mask of DBF field.
	Ethernet_MACPFR_DBF_Msk = 0x20
	// Bit DBF.
	Ethernet_MACPFR_DBF = 0x20
	// Position of PCF field.
	Ethernet_MACPFR_PCF_Pos = 0x6
	// Bit mask of PCF field.
	Ethernet_MACPFR_PCF_Msk = 0xc0
	// Position of SAIF field.
	Ethernet_MACPFR_SAIF_Pos = 0x8
	// Bit mask of SAIF field.
	Ethernet_MACPFR_SAIF_Msk = 0x100
	// Bit SAIF.
	Ethernet_MACPFR_SAIF = 0x100
	// Position of SAF field.
	Ethernet_MACPFR_SAF_Pos = 0x9
	// Bit mask of SAF field.
	Ethernet_MACPFR_SAF_Msk = 0x200
	// Bit SAF.
	Ethernet_MACPFR_SAF = 0x200
	// Position of HPF field.
	Ethernet_MACPFR_HPF_Pos = 0xa
	// Bit mask of HPF field.
	Ethernet_MACPFR_HPF_Msk = 0x400
	// Bit HPF.
	Ethernet_MACPFR_HPF = 0x400
	// Position of VTFE field.
	Ethernet_MACPFR_VTFE_Pos = 0x10
	// Bit mask of VTFE field.
	Ethernet_MACPFR_VTFE_Msk = 0x10000
	// Bit VTFE.
	Ethernet_MACPFR_VTFE = 0x10000
	// Position of IPFE field.
	Ethernet_MACPFR_IPFE_Pos = 0x14
	// Bit mask of IPFE field.
	Ethernet_MACPFR_IPFE_Msk = 0x100000
	// Bit IPFE.
	Ethernet_MACPFR_IPFE = 0x100000
	// Position of DNTU field.
	Ethernet_MACPFR_DNTU_Pos = 0x15
	// Bit mask of DNTU field.
	Ethernet_MACPFR_DNTU_Msk = 0x200000
	// Bit DNTU.
	Ethernet_MACPFR_DNTU = 0x200000
	// Position of RA field.
	Ethernet_MACPFR_RA_Pos = 0x1f
	// Bit mask of RA field.
	Ethernet_MACPFR_RA_Msk = 0x80000000
	// Bit RA.
	Ethernet_MACPFR_RA = 0x80000000

	// MACWTR: Watchdog timeout register
	// Position of WTO field.
	Ethernet_MACWTR_WTO_Pos = 0x0
	// Bit mask of WTO field.
	Ethernet_MACWTR_WTO_Msk = 0xf
	// Position of PWE field.
	Ethernet_MACWTR_PWE_Pos = 0x8
	// Bit mask of PWE field.
	Ethernet_MACWTR_PWE_Msk = 0x100
	// Bit PWE.
	Ethernet_MACWTR_PWE = 0x100

	// MACHT0R: Hash Table 0 register
	// Position of HT31T0 field.
	Ethernet_MACHT0R_HT31T0_Pos = 0x0
	// Bit mask of HT31T0 field.
	Ethernet_MACHT0R_HT31T0_Msk = 0xffffffff

	// MACHT1R: Hash Table 1 register
	// Position of HT63T32 field.
	Ethernet_MACHT1R_HT63T32_Pos = 0x0
	// Bit mask of HT63T32 field.
	Ethernet_MACHT1R_HT63T32_Msk = 0xffffffff

	// MACVTR: VLAN tag register
	// Position of VL field.
	Ethernet_MACVTR_VL_Pos = 0x0
	// Bit mask of VL field.
	Ethernet_MACVTR_VL_Msk = 0xffff
	// Position of ETV field.
	Ethernet_MACVTR_ETV_Pos = 0x10
	// Bit mask of ETV field.
	Ethernet_MACVTR_ETV_Msk = 0x10000
	// Bit ETV.
	Ethernet_MACVTR_ETV = 0x10000
	// Position of VTIM field.
	Ethernet_MACVTR_VTIM_Pos = 0x11
	// Bit mask of VTIM field.
	Ethernet_MACVTR_VTIM_Msk = 0x20000
	// Bit VTIM.
	Ethernet_MACVTR_VTIM = 0x20000
	// Position of ESVL field.
	Ethernet_MACVTR_ESVL_Pos = 0x12
	// Bit mask of ESVL field.
	Ethernet_MACVTR_ESVL_Msk = 0x40000
	// Bit ESVL.
	Ethernet_MACVTR_ESVL = 0x40000
	// Position of ERSVLM field.
	Ethernet_MACVTR_ERSVLM_Pos = 0x13
	// Bit mask of ERSVLM field.
	Ethernet_MACVTR_ERSVLM_Msk = 0x80000
	// Bit ERSVLM.
	Ethernet_MACVTR_ERSVLM = 0x80000
	// Position of DOVLTC field.
	Ethernet_MACVTR_DOVLTC_Pos = 0x14
	// Bit mask of DOVLTC field.
	Ethernet_MACVTR_DOVLTC_Msk = 0x100000
	// Bit DOVLTC.
	Ethernet_MACVTR_DOVLTC = 0x100000
	// Position of EVLS field.
	Ethernet_MACVTR_EVLS_Pos = 0x15
	// Bit mask of EVLS field.
	Ethernet_MACVTR_EVLS_Msk = 0x600000
	// Position of EVLRXS field.
	Ethernet_MACVTR_EVLRXS_Pos = 0x18
	// Bit mask of EVLRXS field.
	Ethernet_MACVTR_EVLRXS_Msk = 0x1000000
	// Bit EVLRXS.
	Ethernet_MACVTR_EVLRXS = 0x1000000
	// Position of VTHM field.
	Ethernet_MACVTR_VTHM_Pos = 0x19
	// Bit mask of VTHM field.
	Ethernet_MACVTR_VTHM_Msk = 0x2000000
	// Bit VTHM.
	Ethernet_MACVTR_VTHM = 0x2000000
	// Position of EDVLP field.
	Ethernet_MACVTR_EDVLP_Pos = 0x1a
	// Bit mask of EDVLP field.
	Ethernet_MACVTR_EDVLP_Msk = 0x4000000
	// Bit EDVLP.
	Ethernet_MACVTR_EDVLP = 0x4000000
	// Position of ERIVLT field.
	Ethernet_MACVTR_ERIVLT_Pos = 0x1b
	// Bit mask of ERIVLT field.
	Ethernet_MACVTR_ERIVLT_Msk = 0x8000000
	// Bit ERIVLT.
	Ethernet_MACVTR_ERIVLT = 0x8000000
	// Position of EIVLS field.
	Ethernet_MACVTR_EIVLS_Pos = 0x1c
	// Bit mask of EIVLS field.
	Ethernet_MACVTR_EIVLS_Msk = 0x30000000
	// Position of EIVLRXS field.
	Ethernet_MACVTR_EIVLRXS_Pos = 0x1f
	// Bit mask of EIVLRXS field.
	Ethernet_MACVTR_EIVLRXS_Msk = 0x80000000
	// Bit EIVLRXS.
	Ethernet_MACVTR_EIVLRXS = 0x80000000

	// MACVHTR: VLAN Hash table register
	// Position of VLHT field.
	Ethernet_MACVHTR_VLHT_Pos = 0x0
	// Bit mask of VLHT field.
	Ethernet_MACVHTR_VLHT_Msk = 0xffff

	// MACVIR: VLAN inclusion register
	// Position of VLT field.
	Ethernet_MACVIR_VLT_Pos = 0x0
	// Bit mask of VLT field.
	Ethernet_MACVIR_VLT_Msk = 0xffff
	// Position of VLC field.
	Ethernet_MACVIR_VLC_Pos = 0x10
	// Bit mask of VLC field.
	Ethernet_MACVIR_VLC_Msk = 0x30000
	// Position of VLP field.
	Ethernet_MACVIR_VLP_Pos = 0x12
	// Bit mask of VLP field.
	Ethernet_MACVIR_VLP_Msk = 0x40000
	// Bit VLP.
	Ethernet_MACVIR_VLP = 0x40000
	// Position of CSVL field.
	Ethernet_MACVIR_CSVL_Pos = 0x13
	// Bit mask of CSVL field.
	Ethernet_MACVIR_CSVL_Msk = 0x80000
	// Bit CSVL.
	Ethernet_MACVIR_CSVL = 0x80000
	// Position of VLTI field.
	Ethernet_MACVIR_VLTI_Pos = 0x14
	// Bit mask of VLTI field.
	Ethernet_MACVIR_VLTI_Msk = 0x100000
	// Bit VLTI.
	Ethernet_MACVIR_VLTI = 0x100000

	// MACIVIR: Inner VLAN inclusion register
	// Position of VLT field.
	Ethernet_MACIVIR_VLT_Pos = 0x0
	// Bit mask of VLT field.
	Ethernet_MACIVIR_VLT_Msk = 0xffff
	// Position of VLC field.
	Ethernet_MACIVIR_VLC_Pos = 0x10
	// Bit mask of VLC field.
	Ethernet_MACIVIR_VLC_Msk = 0x30000
	// Position of VLP field.
	Ethernet_MACIVIR_VLP_Pos = 0x12
	// Bit mask of VLP field.
	Ethernet_MACIVIR_VLP_Msk = 0x40000
	// Bit VLP.
	Ethernet_MACIVIR_VLP = 0x40000
	// Position of CSVL field.
	Ethernet_MACIVIR_CSVL_Pos = 0x13
	// Bit mask of CSVL field.
	Ethernet_MACIVIR_CSVL_Msk = 0x80000
	// Bit CSVL.
	Ethernet_MACIVIR_CSVL = 0x80000
	// Position of VLTI field.
	Ethernet_MACIVIR_VLTI_Pos = 0x14
	// Bit mask of VLTI field.
	Ethernet_MACIVIR_VLTI_Msk = 0x100000
	// Bit VLTI.
	Ethernet_MACIVIR_VLTI = 0x100000

	// MACQTxFCR: Tx Queue flow control register
	// Position of FCB_BPA field.
	Ethernet_MACQTxFCR_FCB_BPA_Pos = 0x0
	// Bit mask of FCB_BPA field.
	Ethernet_MACQTxFCR_FCB_BPA_Msk = 0x1
	// Bit FCB_BPA.
	Ethernet_MACQTxFCR_FCB_BPA = 0x1
	// Position of TFE field.
	Ethernet_MACQTxFCR_TFE_Pos = 0x1
	// Bit mask of TFE field.
	Ethernet_MACQTxFCR_TFE_Msk = 0x2
	// Bit TFE.
	Ethernet_MACQTxFCR_TFE = 0x2
	// Position of PLT field.
	Ethernet_MACQTxFCR_PLT_Pos = 0x4
	// Bit mask of PLT field.
	Ethernet_MACQTxFCR_PLT_Msk = 0x70
	// Position of DZPQ field.
	Ethernet_MACQTxFCR_DZPQ_Pos = 0x7
	// Bit mask of DZPQ field.
	Ethernet_MACQTxFCR_DZPQ_Msk = 0x80
	// Bit DZPQ.
	Ethernet_MACQTxFCR_DZPQ = 0x80
	// Position of PT field.
	Ethernet_MACQTxFCR_PT_Pos = 0x10
	// Bit mask of PT field.
	Ethernet_MACQTxFCR_PT_Msk = 0xffff0000

	// MACRxFCR: Rx flow control register
	// Position of RFE field.
	Ethernet_MACRxFCR_RFE_Pos = 0x0
	// Bit mask of RFE field.
	Ethernet_MACRxFCR_RFE_Msk = 0x1
	// Bit RFE.
	Ethernet_MACRxFCR_RFE = 0x1
	// Position of UP field.
	Ethernet_MACRxFCR_UP_Pos = 0x1
	// Bit mask of UP field.
	Ethernet_MACRxFCR_UP_Msk = 0x2
	// Bit UP.
	Ethernet_MACRxFCR_UP = 0x2

	// MACISR: Interrupt status register
	// Position of PHYIS field.
	Ethernet_MACISR_PHYIS_Pos = 0x3
	// Bit mask of PHYIS field.
	Ethernet_MACISR_PHYIS_Msk = 0x8
	// Bit PHYIS.
	Ethernet_MACISR_PHYIS = 0x8
	// Position of PMTIS field.
	Ethernet_MACISR_PMTIS_Pos = 0x4
	// Bit mask of PMTIS field.
	Ethernet_MACISR_PMTIS_Msk = 0x10
	// Bit PMTIS.
	Ethernet_MACISR_PMTIS = 0x10
	// Position of LPIIS field.
	Ethernet_MACISR_LPIIS_Pos = 0x5
	// Bit mask of LPIIS field.
	Ethernet_MACISR_LPIIS_Msk = 0x20
	// Bit LPIIS.
	Ethernet_MACISR_LPIIS = 0x20
	// Position of MMCIS field.
	Ethernet_MACISR_MMCIS_Pos = 0x8
	// Bit mask of MMCIS field.
	Ethernet_MACISR_MMCIS_Msk = 0x100
	// Bit MMCIS.
	Ethernet_MACISR_MMCIS = 0x100
	// Position of MMCRXIS field.
	Ethernet_MACISR_MMCRXIS_Pos = 0x9
	// Bit mask of MMCRXIS field.
	Ethernet_MACISR_MMCRXIS_Msk = 0x200
	// Bit MMCRXIS.
	Ethernet_MACISR_MMCRXIS = 0x200
	// Position of MMCTXIS field.
	Ethernet_MACISR_MMCTXIS_Pos = 0xa
	// Bit mask of MMCTXIS field.
	Ethernet_MACISR_MMCTXIS_Msk = 0x400
	// Bit MMCTXIS.
	Ethernet_MACISR_MMCTXIS = 0x400
	// Position of TSIS field.
	Ethernet_MACISR_TSIS_Pos = 0xc
	// Bit mask of TSIS field.
	Ethernet_MACISR_TSIS_Msk = 0x1000
	// Bit TSIS.
	Ethernet_MACISR_TSIS = 0x1000
	// Position of TXSTSIS field.
	Ethernet_MACISR_TXSTSIS_Pos = 0xd
	// Bit mask of TXSTSIS field.
	Ethernet_MACISR_TXSTSIS_Msk = 0x2000
	// Bit TXSTSIS.
	Ethernet_MACISR_TXSTSIS = 0x2000
	// Position of RXSTSIS field.
	Ethernet_MACISR_RXSTSIS_Pos = 0xe
	// Bit mask of RXSTSIS field.
	Ethernet_MACISR_RXSTSIS_Msk = 0x4000
	// Bit RXSTSIS.
	Ethernet_MACISR_RXSTSIS = 0x4000

	// MACIER: Interrupt enable register
	// Position of PHYIE field.
	Ethernet_MACIER_PHYIE_Pos = 0x3
	// Bit mask of PHYIE field.
	Ethernet_MACIER_PHYIE_Msk = 0x8
	// Bit PHYIE.
	Ethernet_MACIER_PHYIE = 0x8
	// Position of PMTIE field.
	Ethernet_MACIER_PMTIE_Pos = 0x4
	// Bit mask of PMTIE field.
	Ethernet_MACIER_PMTIE_Msk = 0x10
	// Bit PMTIE.
	Ethernet_MACIER_PMTIE = 0x10
	// Position of LPIIE field.
	Ethernet_MACIER_LPIIE_Pos = 0x5
	// Bit mask of LPIIE field.
	Ethernet_MACIER_LPIIE_Msk = 0x20
	// Bit LPIIE.
	Ethernet_MACIER_LPIIE = 0x20
	// Position of TSIE field.
	Ethernet_MACIER_TSIE_Pos = 0xc
	// Bit mask of TSIE field.
	Ethernet_MACIER_TSIE_Msk = 0x1000
	// Bit TSIE.
	Ethernet_MACIER_TSIE = 0x1000
	// Position of TXSTSIE field.
	Ethernet_MACIER_TXSTSIE_Pos = 0xd
	// Bit mask of TXSTSIE field.
	Ethernet_MACIER_TXSTSIE_Msk = 0x2000
	// Bit TXSTSIE.
	Ethernet_MACIER_TXSTSIE = 0x2000
	// Position of RXSTSIE field.
	Ethernet_MACIER_RXSTSIE_Pos = 0xe
	// Bit mask of RXSTSIE field.
	Ethernet_MACIER_RXSTSIE_Msk = 0x4000
	// Bit RXSTSIE.
	Ethernet_MACIER_RXSTSIE = 0x4000

	// MACRxTxSR: Rx Tx status register
	// Position of TJT field.
	Ethernet_MACRxTxSR_TJT_Pos = 0x0
	// Bit mask of TJT field.
	Ethernet_MACRxTxSR_TJT_Msk = 0x1
	// Bit TJT.
	Ethernet_MACRxTxSR_TJT = 0x1
	// Position of NCARR field.
	Ethernet_MACRxTxSR_NCARR_Pos = 0x1
	// Bit mask of NCARR field.
	Ethernet_MACRxTxSR_NCARR_Msk = 0x2
	// Bit NCARR.
	Ethernet_MACRxTxSR_NCARR = 0x2
	// Position of LCARR field.
	Ethernet_MACRxTxSR_LCARR_Pos = 0x2
	// Bit mask of LCARR field.
	Ethernet_MACRxTxSR_LCARR_Msk = 0x4
	// Bit LCARR.
	Ethernet_MACRxTxSR_LCARR = 0x4
	// Position of EXDEF field.
	Ethernet_MACRxTxSR_EXDEF_Pos = 0x3
	// Bit mask of EXDEF field.
	Ethernet_MACRxTxSR_EXDEF_Msk = 0x8
	// Bit EXDEF.
	Ethernet_MACRxTxSR_EXDEF = 0x8
	// Position of LCOL field.
	Ethernet_MACRxTxSR_LCOL_Pos = 0x4
	// Bit mask of LCOL field.
	Ethernet_MACRxTxSR_LCOL_Msk = 0x10
	// Bit LCOL.
	Ethernet_MACRxTxSR_LCOL = 0x10
	// Position of EXCOL field.
	Ethernet_MACRxTxSR_EXCOL_Pos = 0x5
	// Bit mask of EXCOL field.
	Ethernet_MACRxTxSR_EXCOL_Msk = 0x20
	// Bit EXCOL.
	Ethernet_MACRxTxSR_EXCOL = 0x20
	// Position of RWT field.
	Ethernet_MACRxTxSR_RWT_Pos = 0x8
	// Bit mask of RWT field.
	Ethernet_MACRxTxSR_RWT_Msk = 0x100
	// Bit RWT.
	Ethernet_MACRxTxSR_RWT = 0x100

	// MACPCSR: PMT control status register
	// Position of PWRDWN field.
	Ethernet_MACPCSR_PWRDWN_Pos = 0x0
	// Bit mask of PWRDWN field.
	Ethernet_MACPCSR_PWRDWN_Msk = 0x1
	// Bit PWRDWN.
	Ethernet_MACPCSR_PWRDWN = 0x1
	// Position of MGKPKTEN field.
	Ethernet_MACPCSR_MGKPKTEN_Pos = 0x1
	// Bit mask of MGKPKTEN field.
	Ethernet_MACPCSR_MGKPKTEN_Msk = 0x2
	// Bit MGKPKTEN.
	Ethernet_MACPCSR_MGKPKTEN = 0x2
	// Position of RWKPKTEN field.
	Ethernet_MACPCSR_RWKPKTEN_Pos = 0x2
	// Bit mask of RWKPKTEN field.
	Ethernet_MACPCSR_RWKPKTEN_Msk = 0x4
	// Bit RWKPKTEN.
	Ethernet_MACPCSR_RWKPKTEN = 0x4
	// Position of MGKPRCVD field.
	Ethernet_MACPCSR_MGKPRCVD_Pos = 0x5
	// Bit mask of MGKPRCVD field.
	Ethernet_MACPCSR_MGKPRCVD_Msk = 0x20
	// Bit MGKPRCVD.
	Ethernet_MACPCSR_MGKPRCVD = 0x20
	// Position of RWKPRCVD field.
	Ethernet_MACPCSR_RWKPRCVD_Pos = 0x6
	// Bit mask of RWKPRCVD field.
	Ethernet_MACPCSR_RWKPRCVD_Msk = 0x40
	// Bit RWKPRCVD.
	Ethernet_MACPCSR_RWKPRCVD = 0x40
	// Position of GLBLUCAST field.
	Ethernet_MACPCSR_GLBLUCAST_Pos = 0x9
	// Bit mask of GLBLUCAST field.
	Ethernet_MACPCSR_GLBLUCAST_Msk = 0x200
	// Bit GLBLUCAST.
	Ethernet_MACPCSR_GLBLUCAST = 0x200
	// Position of RWKPFE field.
	Ethernet_MACPCSR_RWKPFE_Pos = 0xa
	// Bit mask of RWKPFE field.
	Ethernet_MACPCSR_RWKPFE_Msk = 0x400
	// Bit RWKPFE.
	Ethernet_MACPCSR_RWKPFE = 0x400
	// Position of RWKPTR field.
	Ethernet_MACPCSR_RWKPTR_Pos = 0x18
	// Bit mask of RWKPTR field.
	Ethernet_MACPCSR_RWKPTR_Msk = 0x1f000000
	// Position of RWKFILTRST field.
	Ethernet_MACPCSR_RWKFILTRST_Pos = 0x1f
	// Bit mask of RWKFILTRST field.
	Ethernet_MACPCSR_RWKFILTRST_Msk = 0x80000000
	// Bit RWKFILTRST.
	Ethernet_MACPCSR_RWKFILTRST = 0x80000000

	// MACRWKPFR: Remove wakeup packet filter register
	// Position of WKUPFRMFTR field.
	Ethernet_MACRWKPFR_WKUPFRMFTR_Pos = 0x0
	// Bit mask of WKUPFRMFTR field.
	Ethernet_MACRWKPFR_WKUPFRMFTR_Msk = 0xffffffff

	// MACLCSR: LPI control status register
	// Position of TLPIEN field.
	Ethernet_MACLCSR_TLPIEN_Pos = 0x0
	// Bit mask of TLPIEN field.
	Ethernet_MACLCSR_TLPIEN_Msk = 0x1
	// Bit TLPIEN.
	Ethernet_MACLCSR_TLPIEN = 0x1
	// Position of TLPIEX field.
	Ethernet_MACLCSR_TLPIEX_Pos = 0x1
	// Bit mask of TLPIEX field.
	Ethernet_MACLCSR_TLPIEX_Msk = 0x2
	// Bit TLPIEX.
	Ethernet_MACLCSR_TLPIEX = 0x2
	// Position of RLPIEN field.
	Ethernet_MACLCSR_RLPIEN_Pos = 0x2
	// Bit mask of RLPIEN field.
	Ethernet_MACLCSR_RLPIEN_Msk = 0x4
	// Bit RLPIEN.
	Ethernet_MACLCSR_RLPIEN = 0x4
	// Position of RLPIEX field.
	Ethernet_MACLCSR_RLPIEX_Pos = 0x3
	// Bit mask of RLPIEX field.
	Ethernet_MACLCSR_RLPIEX_Msk = 0x8
	// Bit RLPIEX.
	Ethernet_MACLCSR_RLPIEX = 0x8
	// Position of TLPIST field.
	Ethernet_MACLCSR_TLPIST_Pos = 0x8
	// Bit mask of TLPIST field.
	Ethernet_MACLCSR_TLPIST_Msk = 0x100
	// Bit TLPIST.
	Ethernet_MACLCSR_TLPIST = 0x100
	// Position of RLPIST field.
	Ethernet_MACLCSR_RLPIST_Pos = 0x9
	// Bit mask of RLPIST field.
	Ethernet_MACLCSR_RLPIST_Msk = 0x200
	// Bit RLPIST.
	Ethernet_MACLCSR_RLPIST = 0x200
	// Position of LPIEN field.
	Ethernet_MACLCSR_LPIEN_Pos = 0x10
	// Bit mask of LPIEN field.
	Ethernet_MACLCSR_LPIEN_Msk = 0x10000
	// Bit LPIEN.
	Ethernet_MACLCSR_LPIEN = 0x10000
	// Position of PLS field.
	Ethernet_MACLCSR_PLS_Pos = 0x11
	// Bit mask of PLS field.
	Ethernet_MACLCSR_PLS_Msk = 0x20000
	// Bit PLS.
	Ethernet_MACLCSR_PLS = 0x20000
	// Position of PLSEN field.
	Ethernet_MACLCSR_PLSEN_Pos = 0x12
	// Bit mask of PLSEN field.
	Ethernet_MACLCSR_PLSEN_Msk = 0x40000
	// Bit PLSEN.
	Ethernet_MACLCSR_PLSEN = 0x40000
	// Position of LPITXA field.
	Ethernet_MACLCSR_LPITXA_Pos = 0x13
	// Bit mask of LPITXA field.
	Ethernet_MACLCSR_LPITXA_Msk = 0x80000
	// Bit LPITXA.
	Ethernet_MACLCSR_LPITXA = 0x80000
	// Position of LPITE field.
	Ethernet_MACLCSR_LPITE_Pos = 0x14
	// Bit mask of LPITE field.
	Ethernet_MACLCSR_LPITE_Msk = 0x100000
	// Bit LPITE.
	Ethernet_MACLCSR_LPITE = 0x100000
	// Position of LPITCSE field.
	Ethernet_MACLCSR_LPITCSE_Pos = 0x15
	// Bit mask of LPITCSE field.
	Ethernet_MACLCSR_LPITCSE_Msk = 0x200000
	// Bit LPITCSE.
	Ethernet_MACLCSR_LPITCSE = 0x200000

	// MACLTCR: LPI timers control register
	// Position of TWT field.
	Ethernet_MACLTCR_TWT_Pos = 0x0
	// Bit mask of TWT field.
	Ethernet_MACLTCR_TWT_Msk = 0xffff
	// Position of LST field.
	Ethernet_MACLTCR_LST_Pos = 0x10
	// Bit mask of LST field.
	Ethernet_MACLTCR_LST_Msk = 0x3ff0000

	// MACLETR: LPI entry timer register
	// Position of LPIET field.
	Ethernet_MACLETR_LPIET_Pos = 0x3
	// Bit mask of LPIET field.
	Ethernet_MACLETR_LPIET_Msk = 0xffff8

	// MAC1USTCR: 1-microsecond-tick counter register
	// Position of TIC_1US_CNTR field.
	Ethernet_MAC1USTCR_TIC_1US_CNTR_Pos = 0x0
	// Bit mask of TIC_1US_CNTR field.
	Ethernet_MAC1USTCR_TIC_1US_CNTR_Msk = 0xfff

	// MACVR: Version register
	// Position of SNPSVER field.
	Ethernet_MACVR_SNPSVER_Pos = 0x0
	// Bit mask of SNPSVER field.
	Ethernet_MACVR_SNPSVER_Msk = 0xff
	// Position of USERVER field.
	Ethernet_MACVR_USERVER_Pos = 0x8
	// Bit mask of USERVER field.
	Ethernet_MACVR_USERVER_Msk = 0xff00

	// MACDR: Debug register
	// Position of RPESTS field.
	Ethernet_MACDR_RPESTS_Pos = 0x0
	// Bit mask of RPESTS field.
	Ethernet_MACDR_RPESTS_Msk = 0x1
	// Bit RPESTS.
	Ethernet_MACDR_RPESTS = 0x1
	// Position of RFCFCSTS field.
	Ethernet_MACDR_RFCFCSTS_Pos = 0x1
	// Bit mask of RFCFCSTS field.
	Ethernet_MACDR_RFCFCSTS_Msk = 0x6
	// Position of TPESTS field.
	Ethernet_MACDR_TPESTS_Pos = 0x10
	// Bit mask of TPESTS field.
	Ethernet_MACDR_TPESTS_Msk = 0x10000
	// Bit TPESTS.
	Ethernet_MACDR_TPESTS = 0x10000
	// Position of TFCSTS field.
	Ethernet_MACDR_TFCSTS_Pos = 0x11
	// Bit mask of TFCSTS field.
	Ethernet_MACDR_TFCSTS_Msk = 0x60000

	// MACHWF1R: HW feature 1 register
	// Position of RXFIFOSIZE field.
	Ethernet_MACHWF1R_RXFIFOSIZE_Pos = 0x0
	// Bit mask of RXFIFOSIZE field.
	Ethernet_MACHWF1R_RXFIFOSIZE_Msk = 0x1f
	// Position of TXFIFOSIZE field.
	Ethernet_MACHWF1R_TXFIFOSIZE_Pos = 0x6
	// Bit mask of TXFIFOSIZE field.
	Ethernet_MACHWF1R_TXFIFOSIZE_Msk = 0x7c0
	// Position of OSTEN field.
	Ethernet_MACHWF1R_OSTEN_Pos = 0xb
	// Bit mask of OSTEN field.
	Ethernet_MACHWF1R_OSTEN_Msk = 0x800
	// Bit OSTEN.
	Ethernet_MACHWF1R_OSTEN = 0x800
	// Position of PTOEN field.
	Ethernet_MACHWF1R_PTOEN_Pos = 0xc
	// Bit mask of PTOEN field.
	Ethernet_MACHWF1R_PTOEN_Msk = 0x1000
	// Bit PTOEN.
	Ethernet_MACHWF1R_PTOEN = 0x1000
	// Position of ADVTHWORD field.
	Ethernet_MACHWF1R_ADVTHWORD_Pos = 0xd
	// Bit mask of ADVTHWORD field.
	Ethernet_MACHWF1R_ADVTHWORD_Msk = 0x2000
	// Bit ADVTHWORD.
	Ethernet_MACHWF1R_ADVTHWORD = 0x2000
	// Position of DCBEN field.
	Ethernet_MACHWF1R_DCBEN_Pos = 0x10
	// Bit mask of DCBEN field.
	Ethernet_MACHWF1R_DCBEN_Msk = 0x10000
	// Bit DCBEN.
	Ethernet_MACHWF1R_DCBEN = 0x10000
	// Position of SPHEN field.
	Ethernet_MACHWF1R_SPHEN_Pos = 0x11
	// Bit mask of SPHEN field.
	Ethernet_MACHWF1R_SPHEN_Msk = 0x20000
	// Bit SPHEN.
	Ethernet_MACHWF1R_SPHEN = 0x20000
	// Position of TSOEN field.
	Ethernet_MACHWF1R_TSOEN_Pos = 0x12
	// Bit mask of TSOEN field.
	Ethernet_MACHWF1R_TSOEN_Msk = 0x40000
	// Bit TSOEN.
	Ethernet_MACHWF1R_TSOEN = 0x40000
	// Position of DBGMEMA field.
	Ethernet_MACHWF1R_DBGMEMA_Pos = 0x13
	// Bit mask of DBGMEMA field.
	Ethernet_MACHWF1R_DBGMEMA_Msk = 0x80000
	// Bit DBGMEMA.
	Ethernet_MACHWF1R_DBGMEMA = 0x80000
	// Position of AVSEL field.
	Ethernet_MACHWF1R_AVSEL_Pos = 0x14
	// Bit mask of AVSEL field.
	Ethernet_MACHWF1R_AVSEL_Msk = 0x100000
	// Bit AVSEL.
	Ethernet_MACHWF1R_AVSEL = 0x100000
	// Position of HASHTBLSZ field.
	Ethernet_MACHWF1R_HASHTBLSZ_Pos = 0x18
	// Bit mask of HASHTBLSZ field.
	Ethernet_MACHWF1R_HASHTBLSZ_Msk = 0x3000000
	// Position of L3L4FNUM field.
	Ethernet_MACHWF1R_L3L4FNUM_Pos = 0x1b
	// Bit mask of L3L4FNUM field.
	Ethernet_MACHWF1R_L3L4FNUM_Msk = 0x78000000

	// MACHWF2R: HW feature 2 register
	// Position of RXQCNT field.
	Ethernet_MACHWF2R_RXQCNT_Pos = 0x0
	// Bit mask of RXQCNT field.
	Ethernet_MACHWF2R_RXQCNT_Msk = 0xf
	// Position of TXQCNT field.
	Ethernet_MACHWF2R_TXQCNT_Pos = 0x6
	// Bit mask of TXQCNT field.
	Ethernet_MACHWF2R_TXQCNT_Msk = 0x3c0
	// Position of RXCHCNT field.
	Ethernet_MACHWF2R_RXCHCNT_Pos = 0xc
	// Bit mask of RXCHCNT field.
	Ethernet_MACHWF2R_RXCHCNT_Msk = 0xf000
	// Position of TXCHCNT field.
	Ethernet_MACHWF2R_TXCHCNT_Pos = 0x12
	// Bit mask of TXCHCNT field.
	Ethernet_MACHWF2R_TXCHCNT_Msk = 0x3c0000
	// Position of PPSOUTNUM field.
	Ethernet_MACHWF2R_PPSOUTNUM_Pos = 0x18
	// Bit mask of PPSOUTNUM field.
	Ethernet_MACHWF2R_PPSOUTNUM_Msk = 0x7000000
	// Position of AUXSNAPNUM field.
	Ethernet_MACHWF2R_AUXSNAPNUM_Pos = 0x1c
	// Bit mask of AUXSNAPNUM field.
	Ethernet_MACHWF2R_AUXSNAPNUM_Msk = 0x70000000

	// MACMDIOAR: MDIO address register
	// Position of MB field.
	Ethernet_MACMDIOAR_MB_Pos = 0x0
	// Bit mask of MB field.
	Ethernet_MACMDIOAR_MB_Msk = 0x1
	// Bit MB.
	Ethernet_MACMDIOAR_MB = 0x1
	// Position of C45E field.
	Ethernet_MACMDIOAR_C45E_Pos = 0x1
	// Bit mask of C45E field.
	Ethernet_MACMDIOAR_C45E_Msk = 0x2
	// Bit C45E.
	Ethernet_MACMDIOAR_C45E = 0x2
	// Position of GOC field.
	Ethernet_MACMDIOAR_GOC_Pos = 0x2
	// Bit mask of GOC field.
	Ethernet_MACMDIOAR_GOC_Msk = 0xc
	// Position of SKAP field.
	Ethernet_MACMDIOAR_SKAP_Pos = 0x4
	// Bit mask of SKAP field.
	Ethernet_MACMDIOAR_SKAP_Msk = 0x10
	// Bit SKAP.
	Ethernet_MACMDIOAR_SKAP = 0x10
	// Position of CR field.
	Ethernet_MACMDIOAR_CR_Pos = 0x8
	// Bit mask of CR field.
	Ethernet_MACMDIOAR_CR_Msk = 0xf00
	// Position of NTC field.
	Ethernet_MACMDIOAR_NTC_Pos = 0xc
	// Bit mask of NTC field.
	Ethernet_MACMDIOAR_NTC_Msk = 0x7000
	// Position of RDA field.
	Ethernet_MACMDIOAR_RDA_Pos = 0x10
	// Bit mask of RDA field.
	Ethernet_MACMDIOAR_RDA_Msk = 0x1f0000
	// Position of PA field.
	Ethernet_MACMDIOAR_PA_Pos = 0x15
	// Bit mask of PA field.
	Ethernet_MACMDIOAR_PA_Msk = 0x3e00000
	// Position of BTB field.
	Ethernet_MACMDIOAR_BTB_Pos = 0x1a
	// Bit mask of BTB field.
	Ethernet_MACMDIOAR_BTB_Msk = 0x4000000
	// Bit BTB.
	Ethernet_MACMDIOAR_BTB = 0x4000000
	// Position of PSE field.
	Ethernet_MACMDIOAR_PSE_Pos = 0x1b
	// Bit mask of PSE field.
	Ethernet_MACMDIOAR_PSE_Msk = 0x8000000
	// Bit PSE.
	Ethernet_MACMDIOAR_PSE = 0x8000000

	// MACMDIODR: MDIO data register
	// Position of MD field.
	Ethernet_MACMDIODR_MD_Pos = 0x0
	// Bit mask of MD field.
	Ethernet_MACMDIODR_MD_Msk = 0xffff
	// Position of RA field.
	Ethernet_MACMDIODR_RA_Pos = 0x10
	// Bit mask of RA field.
	Ethernet_MACMDIODR_RA_Msk = 0xffff0000

	// MACA0HR: Address 0 high register
	// Position of ADDRHI field.
	Ethernet_MACA0HR_ADDRHI_Pos = 0x0
	// Bit mask of ADDRHI field.
	Ethernet_MACA0HR_ADDRHI_Msk = 0xffff
	// Position of AE field.
	Ethernet_MACA0HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA0HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA0HR_AE = 0x80000000

	// MACA0LR: Address 0 low register
	// Position of ADDRLO field.
	Ethernet_MACA0LR_ADDRLO_Pos = 0x0
	// Bit mask of ADDRLO field.
	Ethernet_MACA0LR_ADDRLO_Msk = 0xffffffff

	// MACA1HR: Address 1 high register
	// Position of ADDRHI field.
	Ethernet_MACA1HR_ADDRHI_Pos = 0x0
	// Bit mask of ADDRHI field.
	Ethernet_MACA1HR_ADDRHI_Msk = 0xffff
	// Position of MBC field.
	Ethernet_MACA1HR_MBC_Pos = 0x18
	// Bit mask of MBC field.
	Ethernet_MACA1HR_MBC_Msk = 0x3f000000
	// Position of SA field.
	Ethernet_MACA1HR_SA_Pos = 0x1e
	// Bit mask of SA field.
	Ethernet_MACA1HR_SA_Msk = 0x40000000
	// Bit SA.
	Ethernet_MACA1HR_SA = 0x40000000
	// Position of AE field.
	Ethernet_MACA1HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA1HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA1HR_AE = 0x80000000

	// MACA1LR: Address 1 low register
	// Position of ADDRLO field.
	Ethernet_MACA1LR_ADDRLO_Pos = 0x0
	// Bit mask of ADDRLO field.
	Ethernet_MACA1LR_ADDRLO_Msk = 0xffffffff

	// MACA2HR: Address 2 high register
	// Position of ADDRHI field.
	Ethernet_MACA2HR_ADDRHI_Pos = 0x0
	// Bit mask of ADDRHI field.
	Ethernet_MACA2HR_ADDRHI_Msk = 0xffff
	// Position of MBC field.
	Ethernet_MACA2HR_MBC_Pos = 0x18
	// Bit mask of MBC field.
	Ethernet_MACA2HR_MBC_Msk = 0x3f000000
	// Position of SA field.
	Ethernet_MACA2HR_SA_Pos = 0x1e
	// Bit mask of SA field.
	Ethernet_MACA2HR_SA_Msk = 0x40000000
	// Bit SA.
	Ethernet_MACA2HR_SA = 0x40000000
	// Position of AE field.
	Ethernet_MACA2HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA2HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA2HR_AE = 0x80000000

	// MACA2LR: Address 2 low register
	// Position of ADDRLO field.
	Ethernet_MACA2LR_ADDRLO_Pos = 0x0
	// Bit mask of ADDRLO field.
	Ethernet_MACA2LR_ADDRLO_Msk = 0xffffffff

	// MACA3HR: Address 3 high register
	// Position of ADDRHI field.
	Ethernet_MACA3HR_ADDRHI_Pos = 0x0
	// Bit mask of ADDRHI field.
	Ethernet_MACA3HR_ADDRHI_Msk = 0xffff
	// Position of MBC field.
	Ethernet_MACA3HR_MBC_Pos = 0x18
	// Bit mask of MBC field.
	Ethernet_MACA3HR_MBC_Msk = 0x3f000000
	// Position of SA field.
	Ethernet_MACA3HR_SA_Pos = 0x1e
	// Bit mask of SA field.
	Ethernet_MACA3HR_SA_Msk = 0x40000000
	// Bit SA.
	Ethernet_MACA3HR_SA = 0x40000000
	// Position of AE field.
	Ethernet_MACA3HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA3HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA3HR_AE = 0x80000000

	// MACA3LR: Address 3 low register
	// Position of ADDRLO field.
	Ethernet_MACA3LR_ADDRLO_Pos = 0x0
	// Bit mask of ADDRLO field.
	Ethernet_MACA3LR_ADDRLO_Msk = 0xffffffff

	// MMC_CONTROL: MMC control register
	// Position of CNTRST field.
	Ethernet_MMC_CONTROL_CNTRST_Pos = 0x0
	// Bit mask of CNTRST field.
	Ethernet_MMC_CONTROL_CNTRST_Msk = 0x1
	// Bit CNTRST.
	Ethernet_MMC_CONTROL_CNTRST = 0x1
	// Position of CNTSTOPRO field.
	Ethernet_MMC_CONTROL_CNTSTOPRO_Pos = 0x1
	// Bit mask of CNTSTOPRO field.
	Ethernet_MMC_CONTROL_CNTSTOPRO_Msk = 0x2
	// Bit CNTSTOPRO.
	Ethernet_MMC_CONTROL_CNTSTOPRO = 0x2
	// Position of RSTONRD field.
	Ethernet_MMC_CONTROL_RSTONRD_Pos = 0x2
	// Bit mask of RSTONRD field.
	Ethernet_MMC_CONTROL_RSTONRD_Msk = 0x4
	// Bit RSTONRD.
	Ethernet_MMC_CONTROL_RSTONRD = 0x4
	// Position of CNTFREEZ field.
	Ethernet_MMC_CONTROL_CNTFREEZ_Pos = 0x3
	// Bit mask of CNTFREEZ field.
	Ethernet_MMC_CONTROL_CNTFREEZ_Msk = 0x8
	// Bit CNTFREEZ.
	Ethernet_MMC_CONTROL_CNTFREEZ = 0x8
	// Position of CNTPRST field.
	Ethernet_MMC_CONTROL_CNTPRST_Pos = 0x4
	// Bit mask of CNTPRST field.
	Ethernet_MMC_CONTROL_CNTPRST_Msk = 0x10
	// Bit CNTPRST.
	Ethernet_MMC_CONTROL_CNTPRST = 0x10
	// Position of CNTPRSTLVL field.
	Ethernet_MMC_CONTROL_CNTPRSTLVL_Pos = 0x5
	// Bit mask of CNTPRSTLVL field.
	Ethernet_MMC_CONTROL_CNTPRSTLVL_Msk = 0x20
	// Bit CNTPRSTLVL.
	Ethernet_MMC_CONTROL_CNTPRSTLVL = 0x20
	// Position of UCDBC field.
	Ethernet_MMC_CONTROL_UCDBC_Pos = 0x8
	// Bit mask of UCDBC field.
	Ethernet_MMC_CONTROL_UCDBC_Msk = 0x100
	// Bit UCDBC.
	Ethernet_MMC_CONTROL_UCDBC = 0x100

	// MMC_RX_INTERRUPT: MMC Rx interrupt register
	// Position of RXCRCERPIS field.
	Ethernet_MMC_RX_INTERRUPT_RXCRCERPIS_Pos = 0x5
	// Bit mask of RXCRCERPIS field.
	Ethernet_MMC_RX_INTERRUPT_RXCRCERPIS_Msk = 0x20
	// Bit RXCRCERPIS.
	Ethernet_MMC_RX_INTERRUPT_RXCRCERPIS = 0x20
	// Position of RXALGNERPIS field.
	Ethernet_MMC_RX_INTERRUPT_RXALGNERPIS_Pos = 0x6
	// Bit mask of RXALGNERPIS field.
	Ethernet_MMC_RX_INTERRUPT_RXALGNERPIS_Msk = 0x40
	// Bit RXALGNERPIS.
	Ethernet_MMC_RX_INTERRUPT_RXALGNERPIS = 0x40
	// Position of RXUCGPIS field.
	Ethernet_MMC_RX_INTERRUPT_RXUCGPIS_Pos = 0x11
	// Bit mask of RXUCGPIS field.
	Ethernet_MMC_RX_INTERRUPT_RXUCGPIS_Msk = 0x20000
	// Bit RXUCGPIS.
	Ethernet_MMC_RX_INTERRUPT_RXUCGPIS = 0x20000
	// Position of RXLPIUSCIS field.
	Ethernet_MMC_RX_INTERRUPT_RXLPIUSCIS_Pos = 0x1a
	// Bit mask of RXLPIUSCIS field.
	Ethernet_MMC_RX_INTERRUPT_RXLPIUSCIS_Msk = 0x4000000
	// Bit RXLPIUSCIS.
	Ethernet_MMC_RX_INTERRUPT_RXLPIUSCIS = 0x4000000
	// Position of RXLPITRCIS field.
	Ethernet_MMC_RX_INTERRUPT_RXLPITRCIS_Pos = 0x1b
	// Bit mask of RXLPITRCIS field.
	Ethernet_MMC_RX_INTERRUPT_RXLPITRCIS_Msk = 0x8000000
	// Bit RXLPITRCIS.
	Ethernet_MMC_RX_INTERRUPT_RXLPITRCIS = 0x8000000

	// MMC_TX_INTERRUPT: MMC Tx interrupt register
	// Position of TXSCOLGPIS field.
	Ethernet_MMC_TX_INTERRUPT_TXSCOLGPIS_Pos = 0xe
	// Bit mask of TXSCOLGPIS field.
	Ethernet_MMC_TX_INTERRUPT_TXSCOLGPIS_Msk = 0x4000
	// Bit TXSCOLGPIS.
	Ethernet_MMC_TX_INTERRUPT_TXSCOLGPIS = 0x4000
	// Position of TXMCOLGPIS field.
	Ethernet_MMC_TX_INTERRUPT_TXMCOLGPIS_Pos = 0xf
	// Bit mask of TXMCOLGPIS field.
	Ethernet_MMC_TX_INTERRUPT_TXMCOLGPIS_Msk = 0x8000
	// Bit TXMCOLGPIS.
	Ethernet_MMC_TX_INTERRUPT_TXMCOLGPIS = 0x8000
	// Position of TXGPKTIS field.
	Ethernet_MMC_TX_INTERRUPT_TXGPKTIS_Pos = 0x15
	// Bit mask of TXGPKTIS field.
	Ethernet_MMC_TX_INTERRUPT_TXGPKTIS_Msk = 0x200000
	// Bit TXGPKTIS.
	Ethernet_MMC_TX_INTERRUPT_TXGPKTIS = 0x200000
	// Position of TXLPIUSCIS field.
	Ethernet_MMC_TX_INTERRUPT_TXLPIUSCIS_Pos = 0x1a
	// Bit mask of TXLPIUSCIS field.
	Ethernet_MMC_TX_INTERRUPT_TXLPIUSCIS_Msk = 0x4000000
	// Bit TXLPIUSCIS.
	Ethernet_MMC_TX_INTERRUPT_TXLPIUSCIS = 0x4000000
	// Position of TXLPITRCIS field.
	Ethernet_MMC_TX_INTERRUPT_TXLPITRCIS_Pos = 0x1b
	// Bit mask of TXLPITRCIS field.
	Ethernet_MMC_TX_INTERRUPT_TXLPITRCIS_Msk = 0x8000000
	// Bit TXLPITRCIS.
	Ethernet_MMC_TX_INTERRUPT_TXLPITRCIS = 0x8000000

	// MMC_RX_INTERRUPT_MASK: MMC Rx interrupt mask register
	// Position of RXCRCERPIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_Pos = 0x5
	// Bit mask of RXCRCERPIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_Msk = 0x20
	// Bit RXCRCERPIM.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXCRCERPIM = 0x20
	// Position of RXALGNERPIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_Pos = 0x6
	// Bit mask of RXALGNERPIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_Msk = 0x40
	// Bit RXALGNERPIM.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXALGNERPIM = 0x40
	// Position of RXUCGPIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXUCGPIM_Pos = 0x11
	// Bit mask of RXUCGPIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXUCGPIM_Msk = 0x20000
	// Bit RXUCGPIM.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXUCGPIM = 0x20000
	// Position of RXLPIUSCIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_Pos = 0x1a
	// Bit mask of RXLPIUSCIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_Msk = 0x4000000
	// Bit RXLPIUSCIM.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM = 0x4000000
	// Position of RXLPITRCIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_Pos = 0x1b
	// Bit mask of RXLPITRCIM field.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_Msk = 0x8000000
	// Bit RXLPITRCIM.
	Ethernet_MMC_RX_INTERRUPT_MASK_RXLPITRCIM = 0x8000000

	// MMC_TX_INTERRUPT_MASK: MMC Tx interrupt mask register
	// Position of TXSCOLGPIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_Pos = 0xe
	// Bit mask of TXSCOLGPIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_Msk = 0x4000
	// Bit TXSCOLGPIM.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM = 0x4000
	// Position of TXMCOLGPIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_Pos = 0xf
	// Bit mask of TXMCOLGPIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_Msk = 0x8000
	// Bit TXMCOLGPIM.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM = 0x8000
	// Position of TXGPKTIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXGPKTIM_Pos = 0x15
	// Bit mask of TXGPKTIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXGPKTIM_Msk = 0x200000
	// Bit TXGPKTIM.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXGPKTIM = 0x200000
	// Position of TXLPIUSCIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_Pos = 0x1a
	// Bit mask of TXLPIUSCIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_Msk = 0x4000000
	// Bit TXLPIUSCIM.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM = 0x4000000
	// Position of TXLPITRCIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_Pos = 0x1b
	// Bit mask of TXLPITRCIM field.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_Msk = 0x8000000
	// Bit TXLPITRCIM.
	Ethernet_MMC_TX_INTERRUPT_MASK_TXLPITRCIM = 0x8000000

	// TX_SINGLE_COLLISION_GOOD_PACKETS: Tx single collision good packets register
	// Position of TXSNGLCOLG field.
	Ethernet_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_Pos = 0x0
	// Bit mask of TXSNGLCOLG field.
	Ethernet_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_Msk = 0xffffffff

	// TX_MULTIPLE_COLLISION_GOOD_PACKETS: Tx multiple collision good packets register
	// Position of TXMULTCOLG field.
	Ethernet_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_Pos = 0x0
	// Bit mask of TXMULTCOLG field.
	Ethernet_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_Msk = 0xffffffff

	// TX_PACKET_COUNT_GOOD: Tx packet count good register
	// Position of TXPKTG field.
	Ethernet_TX_PACKET_COUNT_GOOD_TXPKTG_Pos = 0x0
	// Bit mask of TXPKTG field.
	Ethernet_TX_PACKET_COUNT_GOOD_TXPKTG_Msk = 0xffffffff

	// RX_CRC_ERROR_PACKETS: Rx CRC error packets register
	// Position of RXCRCERR field.
	Ethernet_RX_CRC_ERROR_PACKETS_RXCRCERR_Pos = 0x0
	// Bit mask of RXCRCERR field.
	Ethernet_RX_CRC_ERROR_PACKETS_RXCRCERR_Msk = 0xffffffff

	// RX_ALIGNMENT_ERROR_PACKETS: Rx alignment error packets register
	// Position of RXALGNERR field.
	Ethernet_RX_ALIGNMENT_ERROR_PACKETS_RXALGNERR_Pos = 0x0
	// Bit mask of RXALGNERR field.
	Ethernet_RX_ALIGNMENT_ERROR_PACKETS_RXALGNERR_Msk = 0xffffffff

	// RX_UNICAST_PACKETS_GOOD: Rx unicast packets good register
	// Position of RXUCASTG field.
	Ethernet_RX_UNICAST_PACKETS_GOOD_RXUCASTG_Pos = 0x0
	// Bit mask of RXUCASTG field.
	Ethernet_RX_UNICAST_PACKETS_GOOD_RXUCASTG_Msk = 0xffffffff

	// TX_LPI_USEC_CNTR: Tx LPI microsecond timer register
	// Position of TXLPIUSC field.
	Ethernet_TX_LPI_USEC_CNTR_TXLPIUSC_Pos = 0x0
	// Bit mask of TXLPIUSC field.
	Ethernet_TX_LPI_USEC_CNTR_TXLPIUSC_Msk = 0xffffffff

	// TX_LPI_TRAN_CNTR: Tx LPI transition counter register
	// Position of TXLPITRC field.
	Ethernet_TX_LPI_TRAN_CNTR_TXLPITRC_Pos = 0x0
	// Bit mask of TXLPITRC field.
	Ethernet_TX_LPI_TRAN_CNTR_TXLPITRC_Msk = 0xffffffff

	// RX_LPI_USEC_CNTR: Rx LPI microsecond counter register
	// Position of RXLPIUSC field.
	Ethernet_RX_LPI_USEC_CNTR_RXLPIUSC_Pos = 0x0
	// Bit mask of RXLPIUSC field.
	Ethernet_RX_LPI_USEC_CNTR_RXLPIUSC_Msk = 0xffffffff

	// RX_LPI_TRAN_CNTR: Rx LPI transition counter register
	// Position of RXLPITRC field.
	Ethernet_RX_LPI_TRAN_CNTR_RXLPITRC_Pos = 0x0
	// Bit mask of RXLPITRC field.
	Ethernet_RX_LPI_TRAN_CNTR_RXLPITRC_Msk = 0xffffffff

	// MACL3L4C0R: L3 and L4 control 0 register
	// Position of L3PEN0 field.
	Ethernet_MACL3L4C0R_L3PEN0_Pos = 0x0
	// Bit mask of L3PEN0 field.
	Ethernet_MACL3L4C0R_L3PEN0_Msk = 0x1
	// Bit L3PEN0.
	Ethernet_MACL3L4C0R_L3PEN0 = 0x1
	// Position of L3SAM0 field.
	Ethernet_MACL3L4C0R_L3SAM0_Pos = 0x2
	// Bit mask of L3SAM0 field.
	Ethernet_MACL3L4C0R_L3SAM0_Msk = 0x4
	// Bit L3SAM0.
	Ethernet_MACL3L4C0R_L3SAM0 = 0x4
	// Position of L3SAIM0 field.
	Ethernet_MACL3L4C0R_L3SAIM0_Pos = 0x3
	// Bit mask of L3SAIM0 field.
	Ethernet_MACL3L4C0R_L3SAIM0_Msk = 0x8
	// Bit L3SAIM0.
	Ethernet_MACL3L4C0R_L3SAIM0 = 0x8
	// Position of L3DAM0 field.
	Ethernet_MACL3L4C0R_L3DAM0_Pos = 0x4
	// Bit mask of L3DAM0 field.
	Ethernet_MACL3L4C0R_L3DAM0_Msk = 0x10
	// Bit L3DAM0.
	Ethernet_MACL3L4C0R_L3DAM0 = 0x10
	// Position of L3DAIM0 field.
	Ethernet_MACL3L4C0R_L3DAIM0_Pos = 0x5
	// Bit mask of L3DAIM0 field.
	Ethernet_MACL3L4C0R_L3DAIM0_Msk = 0x20
	// Bit L3DAIM0.
	Ethernet_MACL3L4C0R_L3DAIM0 = 0x20
	// Position of L3HSBM0 field.
	Ethernet_MACL3L4C0R_L3HSBM0_Pos = 0x6
	// Bit mask of L3HSBM0 field.
	Ethernet_MACL3L4C0R_L3HSBM0_Msk = 0x7c0
	// Position of L3HDBM0 field.
	Ethernet_MACL3L4C0R_L3HDBM0_Pos = 0xb
	// Bit mask of L3HDBM0 field.
	Ethernet_MACL3L4C0R_L3HDBM0_Msk = 0xf800
	// Position of L4PEN0 field.
	Ethernet_MACL3L4C0R_L4PEN0_Pos = 0x10
	// Bit mask of L4PEN0 field.
	Ethernet_MACL3L4C0R_L4PEN0_Msk = 0x10000
	// Bit L4PEN0.
	Ethernet_MACL3L4C0R_L4PEN0 = 0x10000
	// Position of L4SPM0 field.
	Ethernet_MACL3L4C0R_L4SPM0_Pos = 0x12
	// Bit mask of L4SPM0 field.
	Ethernet_MACL3L4C0R_L4SPM0_Msk = 0x40000
	// Bit L4SPM0.
	Ethernet_MACL3L4C0R_L4SPM0 = 0x40000
	// Position of L4SPIM0 field.
	Ethernet_MACL3L4C0R_L4SPIM0_Pos = 0x13
	// Bit mask of L4SPIM0 field.
	Ethernet_MACL3L4C0R_L4SPIM0_Msk = 0x80000
	// Bit L4SPIM0.
	Ethernet_MACL3L4C0R_L4SPIM0 = 0x80000
	// Position of L4DPM0 field.
	Ethernet_MACL3L4C0R_L4DPM0_Pos = 0x14
	// Bit mask of L4DPM0 field.
	Ethernet_MACL3L4C0R_L4DPM0_Msk = 0x100000
	// Bit L4DPM0.
	Ethernet_MACL3L4C0R_L4DPM0 = 0x100000
	// Position of L4DPIM0 field.
	Ethernet_MACL3L4C0R_L4DPIM0_Pos = 0x15
	// Bit mask of L4DPIM0 field.
	Ethernet_MACL3L4C0R_L4DPIM0_Msk = 0x200000
	// Bit L4DPIM0.
	Ethernet_MACL3L4C0R_L4DPIM0 = 0x200000

	// MACL4A0R: Layer4 address filter 0 register
	// Position of L4SP0 field.
	Ethernet_MACL4A0R_L4SP0_Pos = 0x0
	// Bit mask of L4SP0 field.
	Ethernet_MACL4A0R_L4SP0_Msk = 0xffff
	// Position of L4DP0 field.
	Ethernet_MACL4A0R_L4DP0_Pos = 0x10
	// Bit mask of L4DP0 field.
	Ethernet_MACL4A0R_L4DP0_Msk = 0xffff0000

	// MACL3A00R: MACL3A00R
	// Position of L3A00 field.
	Ethernet_MACL3A00R_L3A00_Pos = 0x0
	// Bit mask of L3A00 field.
	Ethernet_MACL3A00R_L3A00_Msk = 0xffffffff

	// MACL3A10R: Layer3 address 1 filter 0 register
	// Position of L3A10 field.
	Ethernet_MACL3A10R_L3A10_Pos = 0x0
	// Bit mask of L3A10 field.
	Ethernet_MACL3A10R_L3A10_Msk = 0xffffffff

	// MACL3A20: Layer3 Address 2 filter 0 register
	// Position of L3A20 field.
	Ethernet_MACL3A20_L3A20_Pos = 0x0
	// Bit mask of L3A20 field.
	Ethernet_MACL3A20_L3A20_Msk = 0xffffffff

	// MACL3A30: Layer3 Address 3 filter 0 register
	// Position of L3A30 field.
	Ethernet_MACL3A30_L3A30_Pos = 0x0
	// Bit mask of L3A30 field.
	Ethernet_MACL3A30_L3A30_Msk = 0xffffffff

	// MACL3L4C1R: L3 and L4 control 1 register
	// Position of L3PEN1 field.
	Ethernet_MACL3L4C1R_L3PEN1_Pos = 0x0
	// Bit mask of L3PEN1 field.
	Ethernet_MACL3L4C1R_L3PEN1_Msk = 0x1
	// Bit L3PEN1.
	Ethernet_MACL3L4C1R_L3PEN1 = 0x1
	// Position of L3SAM1 field.
	Ethernet_MACL3L4C1R_L3SAM1_Pos = 0x2
	// Bit mask of L3SAM1 field.
	Ethernet_MACL3L4C1R_L3SAM1_Msk = 0x4
	// Bit L3SAM1.
	Ethernet_MACL3L4C1R_L3SAM1 = 0x4
	// Position of L3SAIM1 field.
	Ethernet_MACL3L4C1R_L3SAIM1_Pos = 0x3
	// Bit mask of L3SAIM1 field.
	Ethernet_MACL3L4C1R_L3SAIM1_Msk = 0x8
	// Bit L3SAIM1.
	Ethernet_MACL3L4C1R_L3SAIM1 = 0x8
	// Position of L3DAM1 field.
	Ethernet_MACL3L4C1R_L3DAM1_Pos = 0x4
	// Bit mask of L3DAM1 field.
	Ethernet_MACL3L4C1R_L3DAM1_Msk = 0x10
	// Bit L3DAM1.
	Ethernet_MACL3L4C1R_L3DAM1 = 0x10
	// Position of L3DAIM1 field.
	Ethernet_MACL3L4C1R_L3DAIM1_Pos = 0x5
	// Bit mask of L3DAIM1 field.
	Ethernet_MACL3L4C1R_L3DAIM1_Msk = 0x20
	// Bit L3DAIM1.
	Ethernet_MACL3L4C1R_L3DAIM1 = 0x20
	// Position of L3HSBM1 field.
	Ethernet_MACL3L4C1R_L3HSBM1_Pos = 0x6
	// Bit mask of L3HSBM1 field.
	Ethernet_MACL3L4C1R_L3HSBM1_Msk = 0x7c0
	// Position of L3HDBM1 field.
	Ethernet_MACL3L4C1R_L3HDBM1_Pos = 0xb
	// Bit mask of L3HDBM1 field.
	Ethernet_MACL3L4C1R_L3HDBM1_Msk = 0xf800
	// Position of L4PEN1 field.
	Ethernet_MACL3L4C1R_L4PEN1_Pos = 0x10
	// Bit mask of L4PEN1 field.
	Ethernet_MACL3L4C1R_L4PEN1_Msk = 0x10000
	// Bit L4PEN1.
	Ethernet_MACL3L4C1R_L4PEN1 = 0x10000
	// Position of L4SPM1 field.
	Ethernet_MACL3L4C1R_L4SPM1_Pos = 0x12
	// Bit mask of L4SPM1 field.
	Ethernet_MACL3L4C1R_L4SPM1_Msk = 0x40000
	// Bit L4SPM1.
	Ethernet_MACL3L4C1R_L4SPM1 = 0x40000
	// Position of L4SPIM1 field.
	Ethernet_MACL3L4C1R_L4SPIM1_Pos = 0x13
	// Bit mask of L4SPIM1 field.
	Ethernet_MACL3L4C1R_L4SPIM1_Msk = 0x80000
	// Bit L4SPIM1.
	Ethernet_MACL3L4C1R_L4SPIM1 = 0x80000
	// Position of L4DPM1 field.
	Ethernet_MACL3L4C1R_L4DPM1_Pos = 0x14
	// Bit mask of L4DPM1 field.
	Ethernet_MACL3L4C1R_L4DPM1_Msk = 0x100000
	// Bit L4DPM1.
	Ethernet_MACL3L4C1R_L4DPM1 = 0x100000
	// Position of L4DPIM1 field.
	Ethernet_MACL3L4C1R_L4DPIM1_Pos = 0x15
	// Bit mask of L4DPIM1 field.
	Ethernet_MACL3L4C1R_L4DPIM1_Msk = 0x200000
	// Bit L4DPIM1.
	Ethernet_MACL3L4C1R_L4DPIM1 = 0x200000

	// MACL4A1R: Layer 4 address filter 1 register
	// Position of L4SP1 field.
	Ethernet_MACL4A1R_L4SP1_Pos = 0x0
	// Bit mask of L4SP1 field.
	Ethernet_MACL4A1R_L4SP1_Msk = 0xffff
	// Position of L4DP1 field.
	Ethernet_MACL4A1R_L4DP1_Pos = 0x10
	// Bit mask of L4DP1 field.
	Ethernet_MACL4A1R_L4DP1_Msk = 0xffff0000

	// MACL3A01R: Layer3 address 0 filter 1 Register
	// Position of L3A01 field.
	Ethernet_MACL3A01R_L3A01_Pos = 0x0
	// Bit mask of L3A01 field.
	Ethernet_MACL3A01R_L3A01_Msk = 0xffffffff

	// MACL3A11R: Layer3 address 1 filter 1 register
	// Position of L3A11 field.
	Ethernet_MACL3A11R_L3A11_Pos = 0x0
	// Bit mask of L3A11 field.
	Ethernet_MACL3A11R_L3A11_Msk = 0xffffffff

	// MACL3A21R: Layer3 address 2 filter 1 Register
	// Position of L3A21 field.
	Ethernet_MACL3A21R_L3A21_Pos = 0x0
	// Bit mask of L3A21 field.
	Ethernet_MACL3A21R_L3A21_Msk = 0xffffffff

	// MACL3A31R: Layer3 address 3 filter 1 register
	// Position of L3A31 field.
	Ethernet_MACL3A31R_L3A31_Pos = 0x0
	// Bit mask of L3A31 field.
	Ethernet_MACL3A31R_L3A31_Msk = 0xffffffff

	// MACARPAR: ARP address register
	// Position of ARPPA field.
	Ethernet_MACARPAR_ARPPA_Pos = 0x0
	// Bit mask of ARPPA field.
	Ethernet_MACARPAR_ARPPA_Msk = 0xffffffff

	// MACTSCR: Timestamp control Register
	// Position of TSENA field.
	Ethernet_MACTSCR_TSENA_Pos = 0x0
	// Bit mask of TSENA field.
	Ethernet_MACTSCR_TSENA_Msk = 0x1
	// Bit TSENA.
	Ethernet_MACTSCR_TSENA = 0x1
	// Position of TSCFUPDT field.
	Ethernet_MACTSCR_TSCFUPDT_Pos = 0x1
	// Bit mask of TSCFUPDT field.
	Ethernet_MACTSCR_TSCFUPDT_Msk = 0x2
	// Bit TSCFUPDT.
	Ethernet_MACTSCR_TSCFUPDT = 0x2
	// Position of TSINIT field.
	Ethernet_MACTSCR_TSINIT_Pos = 0x2
	// Bit mask of TSINIT field.
	Ethernet_MACTSCR_TSINIT_Msk = 0x4
	// Bit TSINIT.
	Ethernet_MACTSCR_TSINIT = 0x4
	// Position of TSUPDT field.
	Ethernet_MACTSCR_TSUPDT_Pos = 0x3
	// Bit mask of TSUPDT field.
	Ethernet_MACTSCR_TSUPDT_Msk = 0x8
	// Bit TSUPDT.
	Ethernet_MACTSCR_TSUPDT = 0x8
	// Position of TSADDREG field.
	Ethernet_MACTSCR_TSADDREG_Pos = 0x5
	// Bit mask of TSADDREG field.
	Ethernet_MACTSCR_TSADDREG_Msk = 0x20
	// Bit TSADDREG.
	Ethernet_MACTSCR_TSADDREG = 0x20
	// Position of TSENALL field.
	Ethernet_MACTSCR_TSENALL_Pos = 0x8
	// Bit mask of TSENALL field.
	Ethernet_MACTSCR_TSENALL_Msk = 0x100
	// Bit TSENALL.
	Ethernet_MACTSCR_TSENALL = 0x100
	// Position of TSCTRLSSR field.
	Ethernet_MACTSCR_TSCTRLSSR_Pos = 0x9
	// Bit mask of TSCTRLSSR field.
	Ethernet_MACTSCR_TSCTRLSSR_Msk = 0x200
	// Bit TSCTRLSSR.
	Ethernet_MACTSCR_TSCTRLSSR = 0x200
	// Position of TSVER2ENA field.
	Ethernet_MACTSCR_TSVER2ENA_Pos = 0xa
	// Bit mask of TSVER2ENA field.
	Ethernet_MACTSCR_TSVER2ENA_Msk = 0x400
	// Bit TSVER2ENA.
	Ethernet_MACTSCR_TSVER2ENA = 0x400
	// Position of TSIPENA field.
	Ethernet_MACTSCR_TSIPENA_Pos = 0xb
	// Bit mask of TSIPENA field.
	Ethernet_MACTSCR_TSIPENA_Msk = 0x800
	// Bit TSIPENA.
	Ethernet_MACTSCR_TSIPENA = 0x800
	// Position of TSIPV6ENA field.
	Ethernet_MACTSCR_TSIPV6ENA_Pos = 0xc
	// Bit mask of TSIPV6ENA field.
	Ethernet_MACTSCR_TSIPV6ENA_Msk = 0x1000
	// Bit TSIPV6ENA.
	Ethernet_MACTSCR_TSIPV6ENA = 0x1000
	// Position of TSIPV4ENA field.
	Ethernet_MACTSCR_TSIPV4ENA_Pos = 0xd
	// Bit mask of TSIPV4ENA field.
	Ethernet_MACTSCR_TSIPV4ENA_Msk = 0x2000
	// Bit TSIPV4ENA.
	Ethernet_MACTSCR_TSIPV4ENA = 0x2000
	// Position of TSEVNTENA field.
	Ethernet_MACTSCR_TSEVNTENA_Pos = 0xe
	// Bit mask of TSEVNTENA field.
	Ethernet_MACTSCR_TSEVNTENA_Msk = 0x4000
	// Bit TSEVNTENA.
	Ethernet_MACTSCR_TSEVNTENA = 0x4000
	// Position of TSMSTRENA field.
	Ethernet_MACTSCR_TSMSTRENA_Pos = 0xf
	// Bit mask of TSMSTRENA field.
	Ethernet_MACTSCR_TSMSTRENA_Msk = 0x8000
	// Bit TSMSTRENA.
	Ethernet_MACTSCR_TSMSTRENA = 0x8000
	// Position of SNAPTYPSEL field.
	Ethernet_MACTSCR_SNAPTYPSEL_Pos = 0x10
	// Bit mask of SNAPTYPSEL field.
	Ethernet_MACTSCR_SNAPTYPSEL_Msk = 0x30000
	// Position of TSENMACADDR field.
	Ethernet_MACTSCR_TSENMACADDR_Pos = 0x12
	// Bit mask of TSENMACADDR field.
	Ethernet_MACTSCR_TSENMACADDR_Msk = 0x40000
	// Bit TSENMACADDR.
	Ethernet_MACTSCR_TSENMACADDR = 0x40000
	// Position of CSC field.
	Ethernet_MACTSCR_CSC_Pos = 0x13
	// Bit mask of CSC field.
	Ethernet_MACTSCR_CSC_Msk = 0x80000
	// Bit CSC.
	Ethernet_MACTSCR_CSC = 0x80000
	// Position of TXTSSTSM field.
	Ethernet_MACTSCR_TXTSSTSM_Pos = 0x18
	// Bit mask of TXTSSTSM field.
	Ethernet_MACTSCR_TXTSSTSM_Msk = 0x1000000
	// Bit TXTSSTSM.
	Ethernet_MACTSCR_TXTSSTSM = 0x1000000

	// MACSSIR: Sub-second increment register
	// Position of SNSINC field.
	Ethernet_MACSSIR_SNSINC_Pos = 0x8
	// Bit mask of SNSINC field.
	Ethernet_MACSSIR_SNSINC_Msk = 0xff00
	// Position of SSINC field.
	Ethernet_MACSSIR_SSINC_Pos = 0x10
	// Bit mask of SSINC field.
	Ethernet_MACSSIR_SSINC_Msk = 0xff0000

	// MACSTSR: System time seconds register
	// Position of TSS field.
	Ethernet_MACSTSR_TSS_Pos = 0x0
	// Bit mask of TSS field.
	Ethernet_MACSTSR_TSS_Msk = 0xffffffff

	// MACSTNR: System time nanoseconds register
	// Position of TSSS field.
	Ethernet_MACSTNR_TSSS_Pos = 0x0
	// Bit mask of TSSS field.
	Ethernet_MACSTNR_TSSS_Msk = 0x7fffffff

	// MACSTSUR: System time seconds update register
	// Position of TSS field.
	Ethernet_MACSTSUR_TSS_Pos = 0x0
	// Bit mask of TSS field.
	Ethernet_MACSTSUR_TSS_Msk = 0xffffffff

	// MACSTNUR: System time nanoseconds update register
	// Position of TSSS field.
	Ethernet_MACSTNUR_TSSS_Pos = 0x0
	// Bit mask of TSSS field.
	Ethernet_MACSTNUR_TSSS_Msk = 0x7fffffff
	// Position of ADDSUB field.
	Ethernet_MACSTNUR_ADDSUB_Pos = 0x1f
	// Bit mask of ADDSUB field.
	Ethernet_MACSTNUR_ADDSUB_Msk = 0x80000000
	// Bit ADDSUB.
	Ethernet_MACSTNUR_ADDSUB = 0x80000000

	// MACTSAR: Timestamp addend register
	// Position of TSAR field.
	Ethernet_MACTSAR_TSAR_Pos = 0x0
	// Bit mask of TSAR field.
	Ethernet_MACTSAR_TSAR_Msk = 0xffffffff

	// MACTSSR: Timestamp status register
	// Position of TSSOVF field.
	Ethernet_MACTSSR_TSSOVF_Pos = 0x0
	// Bit mask of TSSOVF field.
	Ethernet_MACTSSR_TSSOVF_Msk = 0x1
	// Bit TSSOVF.
	Ethernet_MACTSSR_TSSOVF = 0x1
	// Position of TSTARGT0 field.
	Ethernet_MACTSSR_TSTARGT0_Pos = 0x1
	// Bit mask of TSTARGT0 field.
	Ethernet_MACTSSR_TSTARGT0_Msk = 0x2
	// Bit TSTARGT0.
	Ethernet_MACTSSR_TSTARGT0 = 0x2
	// Position of AUXTSTRIG field.
	Ethernet_MACTSSR_AUXTSTRIG_Pos = 0x2
	// Bit mask of AUXTSTRIG field.
	Ethernet_MACTSSR_AUXTSTRIG_Msk = 0x4
	// Bit AUXTSTRIG.
	Ethernet_MACTSSR_AUXTSTRIG = 0x4
	// Position of TSTRGTERR0 field.
	Ethernet_MACTSSR_TSTRGTERR0_Pos = 0x3
	// Bit mask of TSTRGTERR0 field.
	Ethernet_MACTSSR_TSTRGTERR0_Msk = 0x8
	// Bit TSTRGTERR0.
	Ethernet_MACTSSR_TSTRGTERR0 = 0x8
	// Position of TXTSSIS field.
	Ethernet_MACTSSR_TXTSSIS_Pos = 0xf
	// Bit mask of TXTSSIS field.
	Ethernet_MACTSSR_TXTSSIS_Msk = 0x8000
	// Bit TXTSSIS.
	Ethernet_MACTSSR_TXTSSIS = 0x8000
	// Position of ATSSTN field.
	Ethernet_MACTSSR_ATSSTN_Pos = 0x10
	// Bit mask of ATSSTN field.
	Ethernet_MACTSSR_ATSSTN_Msk = 0xf0000
	// Position of ATSSTM field.
	Ethernet_MACTSSR_ATSSTM_Pos = 0x18
	// Bit mask of ATSSTM field.
	Ethernet_MACTSSR_ATSSTM_Msk = 0x1000000
	// Bit ATSSTM.
	Ethernet_MACTSSR_ATSSTM = 0x1000000
	// Position of ATSNS field.
	Ethernet_MACTSSR_ATSNS_Pos = 0x19
	// Bit mask of ATSNS field.
	Ethernet_MACTSSR_ATSNS_Msk = 0x3e000000

	// MACTxTSSNR: Tx timestamp status nanoseconds register
	// Position of TXTSSLO field.
	Ethernet_MACTxTSSNR_TXTSSLO_Pos = 0x0
	// Bit mask of TXTSSLO field.
	Ethernet_MACTxTSSNR_TXTSSLO_Msk = 0x7fffffff
	// Position of TXTSSMIS field.
	Ethernet_MACTxTSSNR_TXTSSMIS_Pos = 0x1f
	// Bit mask of TXTSSMIS field.
	Ethernet_MACTxTSSNR_TXTSSMIS_Msk = 0x80000000
	// Bit TXTSSMIS.
	Ethernet_MACTxTSSNR_TXTSSMIS = 0x80000000

	// MACTxTSSSR: Tx timestamp status seconds register
	// Position of TXTSSHI field.
	Ethernet_MACTxTSSSR_TXTSSHI_Pos = 0x0
	// Bit mask of TXTSSHI field.
	Ethernet_MACTxTSSSR_TXTSSHI_Msk = 0xffffffff

	// MACACR: Auxiliary control register
	// Position of ATSFC field.
	Ethernet_MACACR_ATSFC_Pos = 0x0
	// Bit mask of ATSFC field.
	Ethernet_MACACR_ATSFC_Msk = 0x1
	// Bit ATSFC.
	Ethernet_MACACR_ATSFC = 0x1
	// Position of ATSEN0 field.
	Ethernet_MACACR_ATSEN0_Pos = 0x4
	// Bit mask of ATSEN0 field.
	Ethernet_MACACR_ATSEN0_Msk = 0x10
	// Bit ATSEN0.
	Ethernet_MACACR_ATSEN0 = 0x10
	// Position of ATSEN1 field.
	Ethernet_MACACR_ATSEN1_Pos = 0x5
	// Bit mask of ATSEN1 field.
	Ethernet_MACACR_ATSEN1_Msk = 0x20
	// Bit ATSEN1.
	Ethernet_MACACR_ATSEN1 = 0x20
	// Position of ATSEN2 field.
	Ethernet_MACACR_ATSEN2_Pos = 0x6
	// Bit mask of ATSEN2 field.
	Ethernet_MACACR_ATSEN2_Msk = 0x40
	// Bit ATSEN2.
	Ethernet_MACACR_ATSEN2 = 0x40
	// Position of ATSEN3 field.
	Ethernet_MACACR_ATSEN3_Pos = 0x7
	// Bit mask of ATSEN3 field.
	Ethernet_MACACR_ATSEN3_Msk = 0x80
	// Bit ATSEN3.
	Ethernet_MACACR_ATSEN3 = 0x80

	// MACATSNR: Auxiliary timestamp nanoseconds register
	// Position of AUXTSLO field.
	Ethernet_MACATSNR_AUXTSLO_Pos = 0x0
	// Bit mask of AUXTSLO field.
	Ethernet_MACATSNR_AUXTSLO_Msk = 0x7fffffff

	// MACATSSR: Auxiliary timestamp seconds register
	// Position of AUXTSHI field.
	Ethernet_MACATSSR_AUXTSHI_Pos = 0x0
	// Bit mask of AUXTSHI field.
	Ethernet_MACATSSR_AUXTSHI_Msk = 0xffffffff

	// MACTSIACR: Timestamp Ingress asymmetric correction register
	// Position of OSTIAC field.
	Ethernet_MACTSIACR_OSTIAC_Pos = 0x0
	// Bit mask of OSTIAC field.
	Ethernet_MACTSIACR_OSTIAC_Msk = 0xffffffff

	// MACTSEACR: Timestamp Egress asymmetric correction register
	// Position of OSTEAC field.
	Ethernet_MACTSEACR_OSTEAC_Pos = 0x0
	// Bit mask of OSTEAC field.
	Ethernet_MACTSEACR_OSTEAC_Msk = 0xffffffff

	// MACTSICNR: Timestamp Ingress correction nanosecond register
	// Position of TSIC field.
	Ethernet_MACTSICNR_TSIC_Pos = 0x0
	// Bit mask of TSIC field.
	Ethernet_MACTSICNR_TSIC_Msk = 0xffffffff

	// MACTSECNR: Timestamp Egress correction nanosecond register
	// Position of TSEC field.
	Ethernet_MACTSECNR_TSEC_Pos = 0x0
	// Bit mask of TSEC field.
	Ethernet_MACTSECNR_TSEC_Msk = 0xffffffff

	// MACPPSCR: PPS control register
	// Position of PPSCTRL field.
	Ethernet_MACPPSCR_PPSCTRL_Pos = 0x0
	// Bit mask of PPSCTRL field.
	Ethernet_MACPPSCR_PPSCTRL_Msk = 0xf
	// Position of PPSEN0 field.
	Ethernet_MACPPSCR_PPSEN0_Pos = 0x4
	// Bit mask of PPSEN0 field.
	Ethernet_MACPPSCR_PPSEN0_Msk = 0x10
	// Bit PPSEN0.
	Ethernet_MACPPSCR_PPSEN0 = 0x10
	// Position of TRGTMODSEL0 field.
	Ethernet_MACPPSCR_TRGTMODSEL0_Pos = 0x5
	// Bit mask of TRGTMODSEL0 field.
	Ethernet_MACPPSCR_TRGTMODSEL0_Msk = 0x60

	// MACPPSTTSR: PPS target time seconds register
	// Position of TSTRH0 field.
	Ethernet_MACPPSTTSR_TSTRH0_Pos = 0x0
	// Bit mask of TSTRH0 field.
	Ethernet_MACPPSTTSR_TSTRH0_Msk = 0x7fffffff

	// MACPPSTTNR: PPS target time nanoseconds register
	// Position of TTSL0 field.
	Ethernet_MACPPSTTNR_TTSL0_Pos = 0x0
	// Bit mask of TTSL0 field.
	Ethernet_MACPPSTTNR_TTSL0_Msk = 0x7fffffff
	// Position of TRGTBUSY0 field.
	Ethernet_MACPPSTTNR_TRGTBUSY0_Pos = 0x1f
	// Bit mask of TRGTBUSY0 field.
	Ethernet_MACPPSTTNR_TRGTBUSY0_Msk = 0x80000000
	// Bit TRGTBUSY0.
	Ethernet_MACPPSTTNR_TRGTBUSY0 = 0x80000000

	// MACPPSIR: PPS interval register
	// Position of PPSINT0 field.
	Ethernet_MACPPSIR_PPSINT0_Pos = 0x0
	// Bit mask of PPSINT0 field.
	Ethernet_MACPPSIR_PPSINT0_Msk = 0xffffffff

	// MACPPSWR: PPS width register
	// Position of PPSWIDTH0 field.
	Ethernet_MACPPSWR_PPSWIDTH0_Pos = 0x0
	// Bit mask of PPSWIDTH0 field.
	Ethernet_MACPPSWR_PPSWIDTH0_Msk = 0xffffffff

	// MACPOCR: PTP Offload control register
	// Position of PTOEN field.
	Ethernet_MACPOCR_PTOEN_Pos = 0x0
	// Bit mask of PTOEN field.
	Ethernet_MACPOCR_PTOEN_Msk = 0x1
	// Bit PTOEN.
	Ethernet_MACPOCR_PTOEN = 0x1
	// Position of ASYNCEN field.
	Ethernet_MACPOCR_ASYNCEN_Pos = 0x1
	// Bit mask of ASYNCEN field.
	Ethernet_MACPOCR_ASYNCEN_Msk = 0x2
	// Bit ASYNCEN.
	Ethernet_MACPOCR_ASYNCEN = 0x2
	// Position of APDREQEN field.
	Ethernet_MACPOCR_APDREQEN_Pos = 0x2
	// Bit mask of APDREQEN field.
	Ethernet_MACPOCR_APDREQEN_Msk = 0x4
	// Bit APDREQEN.
	Ethernet_MACPOCR_APDREQEN = 0x4
	// Position of ASYNCTRIG field.
	Ethernet_MACPOCR_ASYNCTRIG_Pos = 0x4
	// Bit mask of ASYNCTRIG field.
	Ethernet_MACPOCR_ASYNCTRIG_Msk = 0x10
	// Bit ASYNCTRIG.
	Ethernet_MACPOCR_ASYNCTRIG = 0x10
	// Position of APDREQTRIG field.
	Ethernet_MACPOCR_APDREQTRIG_Pos = 0x5
	// Bit mask of APDREQTRIG field.
	Ethernet_MACPOCR_APDREQTRIG_Msk = 0x20
	// Bit APDREQTRIG.
	Ethernet_MACPOCR_APDREQTRIG = 0x20
	// Position of DRRDIS field.
	Ethernet_MACPOCR_DRRDIS_Pos = 0x6
	// Bit mask of DRRDIS field.
	Ethernet_MACPOCR_DRRDIS_Msk = 0x40
	// Bit DRRDIS.
	Ethernet_MACPOCR_DRRDIS = 0x40
	// Position of DN field.
	Ethernet_MACPOCR_DN_Pos = 0x8
	// Bit mask of DN field.
	Ethernet_MACPOCR_DN_Msk = 0xff00

	// MACSPI0R: PTP Source Port Identity 0 Register
	// Position of SPI0 field.
	Ethernet_MACSPI0R_SPI0_Pos = 0x0
	// Bit mask of SPI0 field.
	Ethernet_MACSPI0R_SPI0_Msk = 0xffffffff

	// MACSPI1R: PTP Source port identity 1 register
	// Position of SPI1 field.
	Ethernet_MACSPI1R_SPI1_Pos = 0x0
	// Bit mask of SPI1 field.
	Ethernet_MACSPI1R_SPI1_Msk = 0xffffffff

	// MACSPI2R: PTP Source port identity 2 register
	// Position of SPI2 field.
	Ethernet_MACSPI2R_SPI2_Pos = 0x0
	// Bit mask of SPI2 field.
	Ethernet_MACSPI2R_SPI2_Msk = 0xffff

	// MACLMIR: Log message interval register
	// Position of LSI field.
	Ethernet_MACLMIR_LSI_Pos = 0x0
	// Bit mask of LSI field.
	Ethernet_MACLMIR_LSI_Msk = 0xff
	// Position of DRSYNCR field.
	Ethernet_MACLMIR_DRSYNCR_Pos = 0x8
	// Bit mask of DRSYNCR field.
	Ethernet_MACLMIR_DRSYNCR_Msk = 0x700
	// Position of LMPDRI field.
	Ethernet_MACLMIR_LMPDRI_Pos = 0x18
	// Bit mask of LMPDRI field.
	Ethernet_MACLMIR_LMPDRI_Msk = 0xff000000
)

// Constants for FMC: FMC
const (
	// BCR1: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	// Position of MBKEN field.
	FMC_BCR1_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR1_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR1_MBKEN = 0x1
	// Position of MUXEN field.
	FMC_BCR1_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR1_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR1_MUXEN = 0x2
	// Position of MTYP field.
	FMC_BCR1_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR1_MTYP_Msk = 0xc
	// Position of MWID field.
	FMC_BCR1_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR1_MWID_Msk = 0x30
	// Position of FACCEN field.
	FMC_BCR1_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR1_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR1_FACCEN = 0x40
	// Position of BURSTEN field.
	FMC_BCR1_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR1_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR1_BURSTEN = 0x100
	// Position of WAITPOL field.
	FMC_BCR1_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR1_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR1_WAITPOL = 0x200
	// Position of WAITCFG field.
	FMC_BCR1_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR1_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR1_WAITCFG = 0x800
	// Position of WREN field.
	FMC_BCR1_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR1_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR1_WREN = 0x1000
	// Position of WAITEN field.
	FMC_BCR1_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR1_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR1_WAITEN = 0x2000
	// Position of EXTMOD field.
	FMC_BCR1_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR1_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR1_EXTMOD = 0x4000
	// Position of ASYNCWAIT field.
	FMC_BCR1_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR1_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR1_ASYNCWAIT = 0x8000
	// Position of CPSIZE field.
	FMC_BCR1_CPSIZE_Pos = 0x10
	// Bit mask of CPSIZE field.
	FMC_BCR1_CPSIZE_Msk = 0x70000
	// Position of CBURSTRW field.
	FMC_BCR1_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR1_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR1_CBURSTRW = 0x80000
	// Position of CCLKEN field.
	FMC_BCR1_CCLKEN_Pos = 0x14
	// Bit mask of CCLKEN field.
	FMC_BCR1_CCLKEN_Msk = 0x100000
	// Bit CCLKEN.
	FMC_BCR1_CCLKEN = 0x100000
	// Position of WFDIS field.
	FMC_BCR1_WFDIS_Pos = 0x15
	// Bit mask of WFDIS field.
	FMC_BCR1_WFDIS_Msk = 0x200000
	// Bit WFDIS.
	FMC_BCR1_WFDIS = 0x200000
	// Position of BMAP field.
	FMC_BCR1_BMAP_Pos = 0x18
	// Bit mask of BMAP field.
	FMC_BCR1_BMAP_Msk = 0x3000000
	// Position of FMCEN field.
	FMC_BCR1_FMCEN_Pos = 0x1f
	// Bit mask of FMCEN field.
	FMC_BCR1_FMCEN_Msk = 0x80000000
	// Bit FMCEN.
	FMC_BCR1_FMCEN = 0x80000000

	// BTR1: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	// Position of ADDSET field.
	FMC_BTR1_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR1_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BTR1_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR1_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BTR1_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR1_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BTR1_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR1_BUSTURN_Msk = 0xf0000
	// Position of CLKDIV field.
	FMC_BTR1_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR1_CLKDIV_Msk = 0xf00000
	// Position of DATLAT field.
	FMC_BTR1_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR1_DATLAT_Msk = 0xf000000
	// Position of ACCMOD field.
	FMC_BTR1_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR1_ACCMOD_Msk = 0x30000000

	// BCR2: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	// Position of MBKEN field.
	FMC_BCR2_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR2_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR2_MBKEN = 0x1
	// Position of MUXEN field.
	FMC_BCR2_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR2_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR2_MUXEN = 0x2
	// Position of MTYP field.
	FMC_BCR2_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR2_MTYP_Msk = 0xc
	// Position of MWID field.
	FMC_BCR2_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR2_MWID_Msk = 0x30
	// Position of FACCEN field.
	FMC_BCR2_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR2_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR2_FACCEN = 0x40
	// Position of BURSTEN field.
	FMC_BCR2_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR2_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR2_BURSTEN = 0x100
	// Position of WAITPOL field.
	FMC_BCR2_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR2_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR2_WAITPOL = 0x200
	// Position of WAITCFG field.
	FMC_BCR2_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR2_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR2_WAITCFG = 0x800
	// Position of WREN field.
	FMC_BCR2_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR2_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR2_WREN = 0x1000
	// Position of WAITEN field.
	FMC_BCR2_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR2_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR2_WAITEN = 0x2000
	// Position of EXTMOD field.
	FMC_BCR2_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR2_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR2_EXTMOD = 0x4000
	// Position of ASYNCWAIT field.
	FMC_BCR2_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR2_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR2_ASYNCWAIT = 0x8000
	// Position of CPSIZE field.
	FMC_BCR2_CPSIZE_Pos = 0x10
	// Bit mask of CPSIZE field.
	FMC_BCR2_CPSIZE_Msk = 0x70000
	// Position of CBURSTRW field.
	FMC_BCR2_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR2_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR2_CBURSTRW = 0x80000
	// Position of CCLKEN field.
	FMC_BCR2_CCLKEN_Pos = 0x14
	// Bit mask of CCLKEN field.
	FMC_BCR2_CCLKEN_Msk = 0x100000
	// Bit CCLKEN.
	FMC_BCR2_CCLKEN = 0x100000
	// Position of WFDIS field.
	FMC_BCR2_WFDIS_Pos = 0x15
	// Bit mask of WFDIS field.
	FMC_BCR2_WFDIS_Msk = 0x200000
	// Bit WFDIS.
	FMC_BCR2_WFDIS = 0x200000
	// Position of BMAP field.
	FMC_BCR2_BMAP_Pos = 0x18
	// Bit mask of BMAP field.
	FMC_BCR2_BMAP_Msk = 0x3000000
	// Position of FMCEN field.
	FMC_BCR2_FMCEN_Pos = 0x1f
	// Bit mask of FMCEN field.
	FMC_BCR2_FMCEN_Msk = 0x80000000
	// Bit FMCEN.
	FMC_BCR2_FMCEN = 0x80000000

	// BTR2: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	// Position of ADDSET field.
	FMC_BTR2_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR2_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BTR2_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR2_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BTR2_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR2_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BTR2_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR2_BUSTURN_Msk = 0xf0000
	// Position of CLKDIV field.
	FMC_BTR2_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR2_CLKDIV_Msk = 0xf00000
	// Position of DATLAT field.
	FMC_BTR2_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR2_DATLAT_Msk = 0xf000000
	// Position of ACCMOD field.
	FMC_BTR2_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR2_ACCMOD_Msk = 0x30000000

	// BCR3: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	// Position of MBKEN field.
	FMC_BCR3_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR3_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR3_MBKEN = 0x1
	// Position of MUXEN field.
	FMC_BCR3_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR3_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR3_MUXEN = 0x2
	// Position of MTYP field.
	FMC_BCR3_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR3_MTYP_Msk = 0xc
	// Position of MWID field.
	FMC_BCR3_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR3_MWID_Msk = 0x30
	// Position of FACCEN field.
	FMC_BCR3_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR3_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR3_FACCEN = 0x40
	// Position of BURSTEN field.
	FMC_BCR3_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR3_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR3_BURSTEN = 0x100
	// Position of WAITPOL field.
	FMC_BCR3_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR3_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR3_WAITPOL = 0x200
	// Position of WAITCFG field.
	FMC_BCR3_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR3_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR3_WAITCFG = 0x800
	// Position of WREN field.
	FMC_BCR3_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR3_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR3_WREN = 0x1000
	// Position of WAITEN field.
	FMC_BCR3_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR3_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR3_WAITEN = 0x2000
	// Position of EXTMOD field.
	FMC_BCR3_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR3_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR3_EXTMOD = 0x4000
	// Position of ASYNCWAIT field.
	FMC_BCR3_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR3_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR3_ASYNCWAIT = 0x8000
	// Position of CPSIZE field.
	FMC_BCR3_CPSIZE_Pos = 0x10
	// Bit mask of CPSIZE field.
	FMC_BCR3_CPSIZE_Msk = 0x70000
	// Position of CBURSTRW field.
	FMC_BCR3_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR3_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR3_CBURSTRW = 0x80000
	// Position of CCLKEN field.
	FMC_BCR3_CCLKEN_Pos = 0x14
	// Bit mask of CCLKEN field.
	FMC_BCR3_CCLKEN_Msk = 0x100000
	// Bit CCLKEN.
	FMC_BCR3_CCLKEN = 0x100000
	// Position of WFDIS field.
	FMC_BCR3_WFDIS_Pos = 0x15
	// Bit mask of WFDIS field.
	FMC_BCR3_WFDIS_Msk = 0x200000
	// Bit WFDIS.
	FMC_BCR3_WFDIS = 0x200000
	// Position of BMAP field.
	FMC_BCR3_BMAP_Pos = 0x18
	// Bit mask of BMAP field.
	FMC_BCR3_BMAP_Msk = 0x3000000
	// Position of FMCEN field.
	FMC_BCR3_FMCEN_Pos = 0x1f
	// Bit mask of FMCEN field.
	FMC_BCR3_FMCEN_Msk = 0x80000000
	// Bit FMCEN.
	FMC_BCR3_FMCEN = 0x80000000

	// BTR3: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	// Position of ADDSET field.
	FMC_BTR3_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR3_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BTR3_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR3_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BTR3_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR3_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BTR3_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR3_BUSTURN_Msk = 0xf0000
	// Position of CLKDIV field.
	FMC_BTR3_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR3_CLKDIV_Msk = 0xf00000
	// Position of DATLAT field.
	FMC_BTR3_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR3_DATLAT_Msk = 0xf000000
	// Position of ACCMOD field.
	FMC_BTR3_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR3_ACCMOD_Msk = 0x30000000

	// BCR4: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	// Position of MBKEN field.
	FMC_BCR4_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR4_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR4_MBKEN = 0x1
	// Position of MUXEN field.
	FMC_BCR4_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR4_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR4_MUXEN = 0x2
	// Position of MTYP field.
	FMC_BCR4_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR4_MTYP_Msk = 0xc
	// Position of MWID field.
	FMC_BCR4_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR4_MWID_Msk = 0x30
	// Position of FACCEN field.
	FMC_BCR4_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR4_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR4_FACCEN = 0x40
	// Position of BURSTEN field.
	FMC_BCR4_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR4_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR4_BURSTEN = 0x100
	// Position of WAITPOL field.
	FMC_BCR4_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR4_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR4_WAITPOL = 0x200
	// Position of WAITCFG field.
	FMC_BCR4_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR4_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR4_WAITCFG = 0x800
	// Position of WREN field.
	FMC_BCR4_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR4_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR4_WREN = 0x1000
	// Position of WAITEN field.
	FMC_BCR4_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR4_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR4_WAITEN = 0x2000
	// Position of EXTMOD field.
	FMC_BCR4_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR4_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR4_EXTMOD = 0x4000
	// Position of ASYNCWAIT field.
	FMC_BCR4_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR4_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR4_ASYNCWAIT = 0x8000
	// Position of CPSIZE field.
	FMC_BCR4_CPSIZE_Pos = 0x10
	// Bit mask of CPSIZE field.
	FMC_BCR4_CPSIZE_Msk = 0x70000
	// Position of CBURSTRW field.
	FMC_BCR4_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR4_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR4_CBURSTRW = 0x80000
	// Position of CCLKEN field.
	FMC_BCR4_CCLKEN_Pos = 0x14
	// Bit mask of CCLKEN field.
	FMC_BCR4_CCLKEN_Msk = 0x100000
	// Bit CCLKEN.
	FMC_BCR4_CCLKEN = 0x100000
	// Position of WFDIS field.
	FMC_BCR4_WFDIS_Pos = 0x15
	// Bit mask of WFDIS field.
	FMC_BCR4_WFDIS_Msk = 0x200000
	// Bit WFDIS.
	FMC_BCR4_WFDIS = 0x200000
	// Position of BMAP field.
	FMC_BCR4_BMAP_Pos = 0x18
	// Bit mask of BMAP field.
	FMC_BCR4_BMAP_Msk = 0x3000000
	// Position of FMCEN field.
	FMC_BCR4_FMCEN_Pos = 0x1f
	// Bit mask of FMCEN field.
	FMC_BCR4_FMCEN_Msk = 0x80000000
	// Bit FMCEN.
	FMC_BCR4_FMCEN = 0x80000000

	// BTR4: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	// Position of ADDSET field.
	FMC_BTR4_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR4_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BTR4_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR4_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BTR4_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR4_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BTR4_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR4_BUSTURN_Msk = 0xf0000
	// Position of CLKDIV field.
	FMC_BTR4_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR4_CLKDIV_Msk = 0xf00000
	// Position of DATLAT field.
	FMC_BTR4_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR4_DATLAT_Msk = 0xf000000
	// Position of ACCMOD field.
	FMC_BTR4_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR4_ACCMOD_Msk = 0x30000000

	// PCR: NAND Flash control registers
	// Position of PWAITEN field.
	FMC_PCR_PWAITEN_Pos = 0x1
	// Bit mask of PWAITEN field.
	FMC_PCR_PWAITEN_Msk = 0x2
	// Bit PWAITEN.
	FMC_PCR_PWAITEN = 0x2
	// Position of PBKEN field.
	FMC_PCR_PBKEN_Pos = 0x2
	// Bit mask of PBKEN field.
	FMC_PCR_PBKEN_Msk = 0x4
	// Bit PBKEN.
	FMC_PCR_PBKEN = 0x4
	// Position of PWID field.
	FMC_PCR_PWID_Pos = 0x4
	// Bit mask of PWID field.
	FMC_PCR_PWID_Msk = 0x30
	// Position of ECCEN field.
	FMC_PCR_ECCEN_Pos = 0x6
	// Bit mask of ECCEN field.
	FMC_PCR_ECCEN_Msk = 0x40
	// Bit ECCEN.
	FMC_PCR_ECCEN = 0x40
	// Position of TCLR field.
	FMC_PCR_TCLR_Pos = 0x9
	// Bit mask of TCLR field.
	FMC_PCR_TCLR_Msk = 0x1e00
	// Position of TAR field.
	FMC_PCR_TAR_Pos = 0xd
	// Bit mask of TAR field.
	FMC_PCR_TAR_Msk = 0x1e000
	// Position of ECCPS field.
	FMC_PCR_ECCPS_Pos = 0x11
	// Bit mask of ECCPS field.
	FMC_PCR_ECCPS_Msk = 0xe0000

	// SR: This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
	// Position of IRS field.
	FMC_SR_IRS_Pos = 0x0
	// Bit mask of IRS field.
	FMC_SR_IRS_Msk = 0x1
	// Bit IRS.
	FMC_SR_IRS = 0x1
	// Position of ILS field.
	FMC_SR_ILS_Pos = 0x1
	// Bit mask of ILS field.
	FMC_SR_ILS_Msk = 0x2
	// Bit ILS.
	FMC_SR_ILS = 0x2
	// Position of IFS field.
	FMC_SR_IFS_Pos = 0x2
	// Bit mask of IFS field.
	FMC_SR_IFS_Msk = 0x4
	// Bit IFS.
	FMC_SR_IFS = 0x4
	// Position of IREN field.
	FMC_SR_IREN_Pos = 0x3
	// Bit mask of IREN field.
	FMC_SR_IREN_Msk = 0x8
	// Bit IREN.
	FMC_SR_IREN = 0x8
	// Position of ILEN field.
	FMC_SR_ILEN_Pos = 0x4
	// Bit mask of ILEN field.
	FMC_SR_ILEN_Msk = 0x10
	// Bit ILEN.
	FMC_SR_ILEN = 0x10
	// Position of IFEN field.
	FMC_SR_IFEN_Pos = 0x5
	// Bit mask of IFEN field.
	FMC_SR_IFEN_Msk = 0x20
	// Bit IFEN.
	FMC_SR_IFEN = 0x20
	// Position of FEMPT field.
	FMC_SR_FEMPT_Pos = 0x6
	// Bit mask of FEMPT field.
	FMC_SR_FEMPT_Msk = 0x40
	// Bit FEMPT.
	FMC_SR_FEMPT = 0x40

	// PMEM: The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
	// Position of MEMSET field.
	FMC_PMEM_MEMSET_Pos = 0x0
	// Bit mask of MEMSET field.
	FMC_PMEM_MEMSET_Msk = 0xff
	// Position of MEMWAIT field.
	FMC_PMEM_MEMWAIT_Pos = 0x8
	// Bit mask of MEMWAIT field.
	FMC_PMEM_MEMWAIT_Msk = 0xff00
	// Position of MEMHOLD field.
	FMC_PMEM_MEMHOLD_Pos = 0x10
	// Bit mask of MEMHOLD field.
	FMC_PMEM_MEMHOLD_Msk = 0xff0000
	// Position of MEMHIZ field.
	FMC_PMEM_MEMHIZ_Pos = 0x18
	// Bit mask of MEMHIZ field.
	FMC_PMEM_MEMHIZ_Msk = 0xff000000

	// PATT: The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
	// Position of ATTSET field.
	FMC_PATT_ATTSET_Pos = 0x0
	// Bit mask of ATTSET field.
	FMC_PATT_ATTSET_Msk = 0xff
	// Position of ATTWAIT field.
	FMC_PATT_ATTWAIT_Pos = 0x8
	// Bit mask of ATTWAIT field.
	FMC_PATT_ATTWAIT_Msk = 0xff00
	// Position of ATTHOLD field.
	FMC_PATT_ATTHOLD_Pos = 0x10
	// Bit mask of ATTHOLD field.
	FMC_PATT_ATTHOLD_Msk = 0xff0000
	// Position of ATTHIZ field.
	FMC_PATT_ATTHIZ_Pos = 0x18
	// Bit mask of ATTHIZ field.
	FMC_PATT_ATTHIZ_Msk = 0xff000000

	// ECCR: This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
	// Position of ECC field.
	FMC_ECCR_ECC_Pos = 0x0
	// Bit mask of ECC field.
	FMC_ECCR_ECC_Msk = 0xffffffff

	// BWTR1: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	// Position of ADDSET field.
	FMC_BWTR1_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR1_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BWTR1_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR1_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BWTR1_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR1_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BWTR1_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BWTR1_BUSTURN_Msk = 0xf0000
	// Position of ACCMOD field.
	FMC_BWTR1_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR1_ACCMOD_Msk = 0x30000000

	// BWTR2: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	// Position of ADDSET field.
	FMC_BWTR2_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR2_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BWTR2_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR2_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BWTR2_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR2_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BWTR2_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BWTR2_BUSTURN_Msk = 0xf0000
	// Position of ACCMOD field.
	FMC_BWTR2_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR2_ACCMOD_Msk = 0x30000000

	// BWTR3: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	// Position of ADDSET field.
	FMC_BWTR3_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR3_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BWTR3_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR3_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BWTR3_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR3_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BWTR3_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BWTR3_BUSTURN_Msk = 0xf0000
	// Position of ACCMOD field.
	FMC_BWTR3_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR3_ACCMOD_Msk = 0x30000000

	// BWTR4: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	// Position of ADDSET field.
	FMC_BWTR4_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR4_ADDSET_Msk = 0xf
	// Position of ADDHLD field.
	FMC_BWTR4_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR4_ADDHLD_Msk = 0xf0
	// Position of DATAST field.
	FMC_BWTR4_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR4_DATAST_Msk = 0xff00
	// Position of BUSTURN field.
	FMC_BWTR4_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BWTR4_BUSTURN_Msk = 0xf0000
	// Position of ACCMOD field.
	FMC_BWTR4_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR4_ACCMOD_Msk = 0x30000000

	// SDBANK.SDCR: This register contains the control parameters for each SDRAM memory bank
	// Position of NC field.
	FMC_SDBANK_SDCR_NC_Pos = 0x0
	// Bit mask of NC field.
	FMC_SDBANK_SDCR_NC_Msk = 0x3
	// Position of NR field.
	FMC_SDBANK_SDCR_NR_Pos = 0x2
	// Bit mask of NR field.
	FMC_SDBANK_SDCR_NR_Msk = 0xc
	// Position of MWID field.
	FMC_SDBANK_SDCR_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_SDBANK_SDCR_MWID_Msk = 0x30
	// Position of NB field.
	FMC_SDBANK_SDCR_NB_Pos = 0x6
	// Bit mask of NB field.
	FMC_SDBANK_SDCR_NB_Msk = 0x40
	// Bit NB.
	FMC_SDBANK_SDCR_NB = 0x40
	// Position of CAS field.
	FMC_SDBANK_SDCR_CAS_Pos = 0x7
	// Bit mask of CAS field.
	FMC_SDBANK_SDCR_CAS_Msk = 0x180
	// Position of WP field.
	FMC_SDBANK_SDCR_WP_Pos = 0x9
	// Bit mask of WP field.
	FMC_SDBANK_SDCR_WP_Msk = 0x200
	// Bit WP.
	FMC_SDBANK_SDCR_WP = 0x200
	// Position of SDCLK field.
	FMC_SDBANK_SDCR_SDCLK_Pos = 0xa
	// Bit mask of SDCLK field.
	FMC_SDBANK_SDCR_SDCLK_Msk = 0xc00
	// Position of RBURST field.
	FMC_SDBANK_SDCR_RBURST_Pos = 0xc
	// Bit mask of RBURST field.
	FMC_SDBANK_SDCR_RBURST_Msk = 0x1000
	// Bit RBURST.
	FMC_SDBANK_SDCR_RBURST = 0x1000
	// Position of RPIPE field.
	FMC_SDBANK_SDCR_RPIPE_Pos = 0xd
	// Bit mask of RPIPE field.
	FMC_SDBANK_SDCR_RPIPE_Msk = 0x6000

	// SDBANK.SDTR: This register contains the timing parameters of each SDRAM bank
	// Position of TMRD field.
	FMC_SDBANK_SDTR_TMRD_Pos = 0x0
	// Bit mask of TMRD field.
	FMC_SDBANK_SDTR_TMRD_Msk = 0xf
	// Position of TXSR field.
	FMC_SDBANK_SDTR_TXSR_Pos = 0x4
	// Bit mask of TXSR field.
	FMC_SDBANK_SDTR_TXSR_Msk = 0xf0
	// Position of TRAS field.
	FMC_SDBANK_SDTR_TRAS_Pos = 0x8
	// Bit mask of TRAS field.
	FMC_SDBANK_SDTR_TRAS_Msk = 0xf00
	// Position of TRC field.
	FMC_SDBANK_SDTR_TRC_Pos = 0xc
	// Bit mask of TRC field.
	FMC_SDBANK_SDTR_TRC_Msk = 0xf000
	// Position of TWR field.
	FMC_SDBANK_SDTR_TWR_Pos = 0x10
	// Bit mask of TWR field.
	FMC_SDBANK_SDTR_TWR_Msk = 0xf0000
	// Position of TRP field.
	FMC_SDBANK_SDTR_TRP_Pos = 0x14
	// Bit mask of TRP field.
	FMC_SDBANK_SDTR_TRP_Msk = 0xf00000
	// Position of TRCD field.
	FMC_SDBANK_SDTR_TRCD_Pos = 0x18
	// Bit mask of TRCD field.
	FMC_SDBANK_SDTR_TRCD_Msk = 0xf000000

	// SDCMR: This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
	// Position of MODE field.
	FMC_SDCMR_MODE_Pos = 0x0
	// Bit mask of MODE field.
	FMC_SDCMR_MODE_Msk = 0x7
	// Position of CTB2 field.
	FMC_SDCMR_CTB2_Pos = 0x3
	// Bit mask of CTB2 field.
	FMC_SDCMR_CTB2_Msk = 0x8
	// Bit CTB2.
	FMC_SDCMR_CTB2 = 0x8
	// Position of CTB1 field.
	FMC_SDCMR_CTB1_Pos = 0x4
	// Bit mask of CTB1 field.
	FMC_SDCMR_CTB1_Msk = 0x10
	// Bit CTB1.
	FMC_SDCMR_CTB1 = 0x10
	// Position of NRFS field.
	FMC_SDCMR_NRFS_Pos = 0x5
	// Bit mask of NRFS field.
	FMC_SDCMR_NRFS_Msk = 0x1e0
	// Position of MRD field.
	FMC_SDCMR_MRD_Pos = 0x9
	// Bit mask of MRD field.
	FMC_SDCMR_MRD_Msk = 0x7ffe00

	// SDRTR: This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
	// Position of CRE field.
	FMC_SDRTR_CRE_Pos = 0x0
	// Bit mask of CRE field.
	FMC_SDRTR_CRE_Msk = 0x1
	// Bit CRE.
	FMC_SDRTR_CRE = 0x1
	// Position of COUNT field.
	FMC_SDRTR_COUNT_Pos = 0x1
	// Bit mask of COUNT field.
	FMC_SDRTR_COUNT_Msk = 0x3ffe
	// Position of REIE field.
	FMC_SDRTR_REIE_Pos = 0xe
	// Bit mask of REIE field.
	FMC_SDRTR_REIE_Msk = 0x4000
	// Bit REIE.
	FMC_SDRTR_REIE = 0x4000

	// SDSR: SDRAM Status register
	// Position of RE field.
	FMC_SDSR_RE_Pos = 0x0
	// Bit mask of RE field.
	FMC_SDSR_RE_Msk = 0x1
	// Bit RE.
	FMC_SDSR_RE = 0x1
	// Position of MODES1 field.
	FMC_SDSR_MODES1_Pos = 0x1
	// Bit mask of MODES1 field.
	FMC_SDSR_MODES1_Msk = 0x6
	// Position of MODES2 field.
	FMC_SDSR_MODES2_Pos = 0x3
	// Bit mask of MODES2 field.
	FMC_SDSR_MODES2_Msk = 0x18
)

// Constants for FPU: Floting point unit
const (
	// FPCCR: Floating-point context control register
	// Position of LSPACT field.
	FPU_FPCCR_LSPACT_Pos = 0x0
	// Bit mask of LSPACT field.
	FPU_FPCCR_LSPACT_Msk = 0x1
	// Bit LSPACT.
	FPU_FPCCR_LSPACT = 0x1
	// Position of USER field.
	FPU_FPCCR_USER_Pos = 0x1
	// Bit mask of USER field.
	FPU_FPCCR_USER_Msk = 0x2
	// Bit USER.
	FPU_FPCCR_USER = 0x2
	// Position of THREAD field.
	FPU_FPCCR_THREAD_Pos = 0x3
	// Bit mask of THREAD field.
	FPU_FPCCR_THREAD_Msk = 0x8
	// Bit THREAD.
	FPU_FPCCR_THREAD = 0x8
	// Position of HFRDY field.
	FPU_FPCCR_HFRDY_Pos = 0x4
	// Bit mask of HFRDY field.
	FPU_FPCCR_HFRDY_Msk = 0x10
	// Bit HFRDY.
	FPU_FPCCR_HFRDY = 0x10
	// Position of MMRDY field.
	FPU_FPCCR_MMRDY_Pos = 0x5
	// Bit mask of MMRDY field.
	FPU_FPCCR_MMRDY_Msk = 0x20
	// Bit MMRDY.
	FPU_FPCCR_MMRDY = 0x20
	// Position of BFRDY field.
	FPU_FPCCR_BFRDY_Pos = 0x6
	// Bit mask of BFRDY field.
	FPU_FPCCR_BFRDY_Msk = 0x40
	// Bit BFRDY.
	FPU_FPCCR_BFRDY = 0x40
	// Position of MONRDY field.
	FPU_FPCCR_MONRDY_Pos = 0x8
	// Bit mask of MONRDY field.
	FPU_FPCCR_MONRDY_Msk = 0x100
	// Bit MONRDY.
	FPU_FPCCR_MONRDY = 0x100
	// Position of LSPEN field.
	FPU_FPCCR_LSPEN_Pos = 0x1e
	// Bit mask of LSPEN field.
	FPU_FPCCR_LSPEN_Msk = 0x40000000
	// Bit LSPEN.
	FPU_FPCCR_LSPEN = 0x40000000
	// Position of ASPEN field.
	FPU_FPCCR_ASPEN_Pos = 0x1f
	// Bit mask of ASPEN field.
	FPU_FPCCR_ASPEN_Msk = 0x80000000
	// Bit ASPEN.
	FPU_FPCCR_ASPEN = 0x80000000

	// FPCAR: Floating-point context address register
	// Position of ADDRESS field.
	FPU_FPCAR_ADDRESS_Pos = 0x3
	// Bit mask of ADDRESS field.
	FPU_FPCAR_ADDRESS_Msk = 0xfffffff8

	// FPSCR: Floating-point status control register
	// Position of IOC field.
	FPU_FPSCR_IOC_Pos = 0x0
	// Bit mask of IOC field.
	FPU_FPSCR_IOC_Msk = 0x1
	// Bit IOC.
	FPU_FPSCR_IOC = 0x1
	// Position of DZC field.
	FPU_FPSCR_DZC_Pos = 0x1
	// Bit mask of DZC field.
	FPU_FPSCR_DZC_Msk = 0x2
	// Bit DZC.
	FPU_FPSCR_DZC = 0x2
	// Position of OFC field.
	FPU_FPSCR_OFC_Pos = 0x2
	// Bit mask of OFC field.
	FPU_FPSCR_OFC_Msk = 0x4
	// Bit OFC.
	FPU_FPSCR_OFC = 0x4
	// Position of UFC field.
	FPU_FPSCR_UFC_Pos = 0x3
	// Bit mask of UFC field.
	FPU_FPSCR_UFC_Msk = 0x8
	// Bit UFC.
	FPU_FPSCR_UFC = 0x8
	// Position of IXC field.
	FPU_FPSCR_IXC_Pos = 0x4
	// Bit mask of IXC field.
	FPU_FPSCR_IXC_Msk = 0x10
	// Bit IXC.
	FPU_FPSCR_IXC = 0x10
	// Position of IDC field.
	FPU_FPSCR_IDC_Pos = 0x7
	// Bit mask of IDC field.
	FPU_FPSCR_IDC_Msk = 0x80
	// Bit IDC.
	FPU_FPSCR_IDC = 0x80
	// Position of RMode field.
	FPU_FPSCR_RMode_Pos = 0x16
	// Bit mask of RMode field.
	FPU_FPSCR_RMode_Msk = 0xc00000
	// Position of FZ field.
	FPU_FPSCR_FZ_Pos = 0x18
	// Bit mask of FZ field.
	FPU_FPSCR_FZ_Msk = 0x1000000
	// Bit FZ.
	FPU_FPSCR_FZ = 0x1000000
	// Position of DN field.
	FPU_FPSCR_DN_Pos = 0x19
	// Bit mask of DN field.
	FPU_FPSCR_DN_Msk = 0x2000000
	// Bit DN.
	FPU_FPSCR_DN = 0x2000000
	// Position of AHP field.
	FPU_FPSCR_AHP_Pos = 0x1a
	// Bit mask of AHP field.
	FPU_FPSCR_AHP_Msk = 0x4000000
	// Bit AHP.
	FPU_FPSCR_AHP = 0x4000000
	// Position of V field.
	FPU_FPSCR_V_Pos = 0x1c
	// Bit mask of V field.
	FPU_FPSCR_V_Msk = 0x10000000
	// Bit V.
	FPU_FPSCR_V = 0x10000000
	// Position of C field.
	FPU_FPSCR_C_Pos = 0x1d
	// Bit mask of C field.
	FPU_FPSCR_C_Msk = 0x20000000
	// Bit C.
	FPU_FPSCR_C = 0x20000000
	// Position of Z field.
	FPU_FPSCR_Z_Pos = 0x1e
	// Bit mask of Z field.
	FPU_FPSCR_Z_Msk = 0x40000000
	// Bit Z.
	FPU_FPSCR_Z = 0x40000000
	// Position of N field.
	FPU_FPSCR_N_Pos = 0x1f
	// Bit mask of N field.
	FPU_FPSCR_N_Msk = 0x80000000
	// Bit N.
	FPU_FPSCR_N = 0x80000000
)

// Constants for FLASH: Flash
const (
	// ACR: Access control register
	// Position of LATENCY field.
	FLASH_ACR_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	FLASH_ACR_LATENCY_Msk = 0x7
	// Position of WRHIGHFREQ field.
	FLASH_ACR_WRHIGHFREQ_Pos = 0x4
	// Bit mask of WRHIGHFREQ field.
	FLASH_ACR_WRHIGHFREQ_Msk = 0x30

	// BANK.KEYR: FLASH key register for bank 1
	// Position of KEYR field.
	FLASH_BANK_KEYR_KEYR_Pos = 0x0
	// Bit mask of KEYR field.
	FLASH_BANK_KEYR_KEYR_Msk = 0xffffffff

	// BANK.CR: FLASH control register for bank 1
	// Position of LOCK field.
	FLASH_BANK_CR_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	FLASH_BANK_CR_LOCK_Msk = 0x1
	// Bit LOCK.
	FLASH_BANK_CR_LOCK = 0x1
	// Position of PG field.
	FLASH_BANK_CR_PG_Pos = 0x1
	// Bit mask of PG field.
	FLASH_BANK_CR_PG_Msk = 0x2
	// Bit PG.
	FLASH_BANK_CR_PG = 0x2
	// Position of SER field.
	FLASH_BANK_CR_SER_Pos = 0x2
	// Bit mask of SER field.
	FLASH_BANK_CR_SER_Msk = 0x4
	// Bit SER.
	FLASH_BANK_CR_SER = 0x4
	// Position of BER field.
	FLASH_BANK_CR_BER_Pos = 0x3
	// Bit mask of BER field.
	FLASH_BANK_CR_BER_Msk = 0x8
	// Bit BER.
	FLASH_BANK_CR_BER = 0x8
	// Position of PSIZE field.
	FLASH_BANK_CR_PSIZE_Pos = 0x4
	// Bit mask of PSIZE field.
	FLASH_BANK_CR_PSIZE_Msk = 0x30
	// Position of FW field.
	FLASH_BANK_CR_FW_Pos = 0x6
	// Bit mask of FW field.
	FLASH_BANK_CR_FW_Msk = 0x40
	// Bit FW.
	FLASH_BANK_CR_FW = 0x40
	// Position of START field.
	FLASH_BANK_CR_START_Pos = 0x7
	// Bit mask of START field.
	FLASH_BANK_CR_START_Msk = 0x80
	// Bit START.
	FLASH_BANK_CR_START = 0x80
	// Position of SNB field.
	FLASH_BANK_CR_SNB_Pos = 0x8
	// Bit mask of SNB field.
	FLASH_BANK_CR_SNB_Msk = 0x700
	// Position of CRC_EN field.
	FLASH_BANK_CR_CRC_EN_Pos = 0xf
	// Bit mask of CRC_EN field.
	FLASH_BANK_CR_CRC_EN_Msk = 0x8000
	// Bit CRC_EN.
	FLASH_BANK_CR_CRC_EN = 0x8000
	// Position of EOPIE field.
	FLASH_BANK_CR_EOPIE_Pos = 0x10
	// Bit mask of EOPIE field.
	FLASH_BANK_CR_EOPIE_Msk = 0x10000
	// Bit EOPIE.
	FLASH_BANK_CR_EOPIE = 0x10000
	// Position of WRPERRIE field.
	FLASH_BANK_CR_WRPERRIE_Pos = 0x11
	// Bit mask of WRPERRIE field.
	FLASH_BANK_CR_WRPERRIE_Msk = 0x20000
	// Bit WRPERRIE.
	FLASH_BANK_CR_WRPERRIE = 0x20000
	// Position of PGSERRIE field.
	FLASH_BANK_CR_PGSERRIE_Pos = 0x12
	// Bit mask of PGSERRIE field.
	FLASH_BANK_CR_PGSERRIE_Msk = 0x40000
	// Bit PGSERRIE.
	FLASH_BANK_CR_PGSERRIE = 0x40000
	// Position of STRBERRIE field.
	FLASH_BANK_CR_STRBERRIE_Pos = 0x13
	// Bit mask of STRBERRIE field.
	FLASH_BANK_CR_STRBERRIE_Msk = 0x80000
	// Bit STRBERRIE.
	FLASH_BANK_CR_STRBERRIE = 0x80000
	// Position of INCERRIE field.
	FLASH_BANK_CR_INCERRIE_Pos = 0x15
	// Bit mask of INCERRIE field.
	FLASH_BANK_CR_INCERRIE_Msk = 0x200000
	// Bit INCERRIE.
	FLASH_BANK_CR_INCERRIE = 0x200000
	// Position of OPERRIE field.
	FLASH_BANK_CR_OPERRIE_Pos = 0x16
	// Bit mask of OPERRIE field.
	FLASH_BANK_CR_OPERRIE_Msk = 0x400000
	// Bit OPERRIE.
	FLASH_BANK_CR_OPERRIE = 0x400000
	// Position of RDPERRIE field.
	FLASH_BANK_CR_RDPERRIE_Pos = 0x17
	// Bit mask of RDPERRIE field.
	FLASH_BANK_CR_RDPERRIE_Msk = 0x800000
	// Bit RDPERRIE.
	FLASH_BANK_CR_RDPERRIE = 0x800000
	// Position of RDSERRIE field.
	FLASH_BANK_CR_RDSERRIE_Pos = 0x18
	// Bit mask of RDSERRIE field.
	FLASH_BANK_CR_RDSERRIE_Msk = 0x1000000
	// Bit RDSERRIE.
	FLASH_BANK_CR_RDSERRIE = 0x1000000
	// Position of SNECCERRIE field.
	FLASH_BANK_CR_SNECCERRIE_Pos = 0x19
	// Bit mask of SNECCERRIE field.
	FLASH_BANK_CR_SNECCERRIE_Msk = 0x2000000
	// Bit SNECCERRIE.
	FLASH_BANK_CR_SNECCERRIE = 0x2000000
	// Position of DBECCERRIE field.
	FLASH_BANK_CR_DBECCERRIE_Pos = 0x1a
	// Bit mask of DBECCERRIE field.
	FLASH_BANK_CR_DBECCERRIE_Msk = 0x4000000
	// Bit DBECCERRIE.
	FLASH_BANK_CR_DBECCERRIE = 0x4000000
	// Position of CRCENDIE field.
	FLASH_BANK_CR_CRCENDIE_Pos = 0x1b
	// Bit mask of CRCENDIE field.
	FLASH_BANK_CR_CRCENDIE_Msk = 0x8000000
	// Bit CRCENDIE.
	FLASH_BANK_CR_CRCENDIE = 0x8000000

	// BANK.SR: FLASH status register for bank 1
	// Position of BSY field.
	FLASH_BANK_SR_BSY_Pos = 0x0
	// Bit mask of BSY field.
	FLASH_BANK_SR_BSY_Msk = 0x1
	// Bit BSY.
	FLASH_BANK_SR_BSY = 0x1
	// Position of WBNE field.
	FLASH_BANK_SR_WBNE_Pos = 0x1
	// Bit mask of WBNE field.
	FLASH_BANK_SR_WBNE_Msk = 0x2
	// Bit WBNE.
	FLASH_BANK_SR_WBNE = 0x2
	// Position of QW field.
	FLASH_BANK_SR_QW_Pos = 0x2
	// Bit mask of QW field.
	FLASH_BANK_SR_QW_Msk = 0x4
	// Bit QW.
	FLASH_BANK_SR_QW = 0x4
	// Position of CRC_BUSY field.
	FLASH_BANK_SR_CRC_BUSY_Pos = 0x3
	// Bit mask of CRC_BUSY field.
	FLASH_BANK_SR_CRC_BUSY_Msk = 0x8
	// Bit CRC_BUSY.
	FLASH_BANK_SR_CRC_BUSY = 0x8
	// Position of EOP field.
	FLASH_BANK_SR_EOP_Pos = 0x10
	// Bit mask of EOP field.
	FLASH_BANK_SR_EOP_Msk = 0x10000
	// Bit EOP.
	FLASH_BANK_SR_EOP = 0x10000
	// Position of WRPERR field.
	FLASH_BANK_SR_WRPERR_Pos = 0x11
	// Bit mask of WRPERR field.
	FLASH_BANK_SR_WRPERR_Msk = 0x20000
	// Bit WRPERR.
	FLASH_BANK_SR_WRPERR = 0x20000
	// Position of PGSERR field.
	FLASH_BANK_SR_PGSERR_Pos = 0x12
	// Bit mask of PGSERR field.
	FLASH_BANK_SR_PGSERR_Msk = 0x40000
	// Bit PGSERR.
	FLASH_BANK_SR_PGSERR = 0x40000
	// Position of STRBERR field.
	FLASH_BANK_SR_STRBERR_Pos = 0x13
	// Bit mask of STRBERR field.
	FLASH_BANK_SR_STRBERR_Msk = 0x80000
	// Bit STRBERR.
	FLASH_BANK_SR_STRBERR = 0x80000
	// Position of INCERR field.
	FLASH_BANK_SR_INCERR_Pos = 0x15
	// Bit mask of INCERR field.
	FLASH_BANK_SR_INCERR_Msk = 0x200000
	// Bit INCERR.
	FLASH_BANK_SR_INCERR = 0x200000
	// Position of OPERR field.
	FLASH_BANK_SR_OPERR_Pos = 0x16
	// Bit mask of OPERR field.
	FLASH_BANK_SR_OPERR_Msk = 0x400000
	// Bit OPERR.
	FLASH_BANK_SR_OPERR = 0x400000
	// Position of RDPERR field.
	FLASH_BANK_SR_RDPERR_Pos = 0x17
	// Bit mask of RDPERR field.
	FLASH_BANK_SR_RDPERR_Msk = 0x800000
	// Bit RDPERR.
	FLASH_BANK_SR_RDPERR = 0x800000
	// Position of RDSERR field.
	FLASH_BANK_SR_RDSERR_Pos = 0x18
	// Bit mask of RDSERR field.
	FLASH_BANK_SR_RDSERR_Msk = 0x1000000
	// Bit RDSERR.
	FLASH_BANK_SR_RDSERR = 0x1000000
	// Position of SNECCERR1 field.
	FLASH_BANK_SR_SNECCERR1_Pos = 0x19
	// Bit mask of SNECCERR1 field.
	FLASH_BANK_SR_SNECCERR1_Msk = 0x2000000
	// Bit SNECCERR1.
	FLASH_BANK_SR_SNECCERR1 = 0x2000000
	// Position of DBECCERR field.
	FLASH_BANK_SR_DBECCERR_Pos = 0x1a
	// Bit mask of DBECCERR field.
	FLASH_BANK_SR_DBECCERR_Msk = 0x4000000
	// Bit DBECCERR.
	FLASH_BANK_SR_DBECCERR = 0x4000000
	// Position of CRCEND field.
	FLASH_BANK_SR_CRCEND_Pos = 0x1b
	// Bit mask of CRCEND field.
	FLASH_BANK_SR_CRCEND_Msk = 0x8000000
	// Bit CRCEND.
	FLASH_BANK_SR_CRCEND = 0x8000000

	// BANK.CCR: FLASH clear control register for bank 1
	// Position of CLR_EOP field.
	FLASH_BANK_CCR_CLR_EOP_Pos = 0x10
	// Bit mask of CLR_EOP field.
	FLASH_BANK_CCR_CLR_EOP_Msk = 0x10000
	// Bit CLR_EOP.
	FLASH_BANK_CCR_CLR_EOP = 0x10000
	// Position of CLR_WRPERR field.
	FLASH_BANK_CCR_CLR_WRPERR_Pos = 0x11
	// Bit mask of CLR_WRPERR field.
	FLASH_BANK_CCR_CLR_WRPERR_Msk = 0x20000
	// Bit CLR_WRPERR.
	FLASH_BANK_CCR_CLR_WRPERR = 0x20000
	// Position of CLR_PGSERR field.
	FLASH_BANK_CCR_CLR_PGSERR_Pos = 0x12
	// Bit mask of CLR_PGSERR field.
	FLASH_BANK_CCR_CLR_PGSERR_Msk = 0x40000
	// Bit CLR_PGSERR.
	FLASH_BANK_CCR_CLR_PGSERR = 0x40000
	// Position of CLR_STRBERR field.
	FLASH_BANK_CCR_CLR_STRBERR_Pos = 0x13
	// Bit mask of CLR_STRBERR field.
	FLASH_BANK_CCR_CLR_STRBERR_Msk = 0x80000
	// Bit CLR_STRBERR.
	FLASH_BANK_CCR_CLR_STRBERR = 0x80000
	// Position of CLR_INCERR field.
	FLASH_BANK_CCR_CLR_INCERR_Pos = 0x15
	// Bit mask of CLR_INCERR field.
	FLASH_BANK_CCR_CLR_INCERR_Msk = 0x200000
	// Bit CLR_INCERR.
	FLASH_BANK_CCR_CLR_INCERR = 0x200000
	// Position of CLR_OPERR field.
	FLASH_BANK_CCR_CLR_OPERR_Pos = 0x16
	// Bit mask of CLR_OPERR field.
	FLASH_BANK_CCR_CLR_OPERR_Msk = 0x400000
	// Bit CLR_OPERR.
	FLASH_BANK_CCR_CLR_OPERR = 0x400000
	// Position of CLR_RDPERR field.
	FLASH_BANK_CCR_CLR_RDPERR_Pos = 0x17
	// Bit mask of CLR_RDPERR field.
	FLASH_BANK_CCR_CLR_RDPERR_Msk = 0x800000
	// Bit CLR_RDPERR.
	FLASH_BANK_CCR_CLR_RDPERR = 0x800000
	// Position of CLR_RDSERR field.
	FLASH_BANK_CCR_CLR_RDSERR_Pos = 0x18
	// Bit mask of CLR_RDSERR field.
	FLASH_BANK_CCR_CLR_RDSERR_Msk = 0x1000000
	// Bit CLR_RDSERR.
	FLASH_BANK_CCR_CLR_RDSERR = 0x1000000
	// Position of CLR_SNECCERR field.
	FLASH_BANK_CCR_CLR_SNECCERR_Pos = 0x19
	// Bit mask of CLR_SNECCERR field.
	FLASH_BANK_CCR_CLR_SNECCERR_Msk = 0x2000000
	// Bit CLR_SNECCERR.
	FLASH_BANK_CCR_CLR_SNECCERR = 0x2000000
	// Position of CLR_DBECCERR field.
	FLASH_BANK_CCR_CLR_DBECCERR_Pos = 0x1a
	// Bit mask of CLR_DBECCERR field.
	FLASH_BANK_CCR_CLR_DBECCERR_Msk = 0x4000000
	// Bit CLR_DBECCERR.
	FLASH_BANK_CCR_CLR_DBECCERR = 0x4000000
	// Position of CLR_CRCEND field.
	FLASH_BANK_CCR_CLR_CRCEND_Pos = 0x1b
	// Bit mask of CLR_CRCEND field.
	FLASH_BANK_CCR_CLR_CRCEND_Msk = 0x8000000
	// Bit CLR_CRCEND.
	FLASH_BANK_CCR_CLR_CRCEND = 0x8000000

	// BANK.PRAR_CUR: FLASH protection address for bank 1
	// Position of PROT_AREA_START field.
	FLASH_BANK_PRAR_CUR_PROT_AREA_START_Pos = 0x0
	// Bit mask of PROT_AREA_START field.
	FLASH_BANK_PRAR_CUR_PROT_AREA_START_Msk = 0xfff
	// Position of PROT_AREA_END field.
	FLASH_BANK_PRAR_CUR_PROT_AREA_END_Pos = 0x10
	// Bit mask of PROT_AREA_END field.
	FLASH_BANK_PRAR_CUR_PROT_AREA_END_Msk = 0xfff0000
	// Position of DMEP field.
	FLASH_BANK_PRAR_CUR_DMEP_Pos = 0x1f
	// Bit mask of DMEP field.
	FLASH_BANK_PRAR_CUR_DMEP_Msk = 0x80000000
	// Bit DMEP.
	FLASH_BANK_PRAR_CUR_DMEP = 0x80000000

	// BANK.PRAR_PRG: FLASH protection address for bank 1
	// Position of PROT_AREA_START field.
	FLASH_BANK_PRAR_PRG_PROT_AREA_START_Pos = 0x0
	// Bit mask of PROT_AREA_START field.
	FLASH_BANK_PRAR_PRG_PROT_AREA_START_Msk = 0xfff
	// Position of PROT_AREA_END field.
	FLASH_BANK_PRAR_PRG_PROT_AREA_END_Pos = 0x10
	// Bit mask of PROT_AREA_END field.
	FLASH_BANK_PRAR_PRG_PROT_AREA_END_Msk = 0xfff0000
	// Position of DMEP field.
	FLASH_BANK_PRAR_PRG_DMEP_Pos = 0x1f
	// Bit mask of DMEP field.
	FLASH_BANK_PRAR_PRG_DMEP_Msk = 0x80000000
	// Bit DMEP.
	FLASH_BANK_PRAR_PRG_DMEP = 0x80000000

	// BANK.SCAR_CUR: FLASH secure address for bank 1
	// Position of SEC_AREA_START field.
	FLASH_BANK_SCAR_CUR_SEC_AREA_START_Pos = 0x0
	// Bit mask of SEC_AREA_START field.
	FLASH_BANK_SCAR_CUR_SEC_AREA_START_Msk = 0xfff
	// Position of SEC_AREA_END field.
	FLASH_BANK_SCAR_CUR_SEC_AREA_END_Pos = 0x10
	// Bit mask of SEC_AREA_END field.
	FLASH_BANK_SCAR_CUR_SEC_AREA_END_Msk = 0xfff0000
	// Position of DMES field.
	FLASH_BANK_SCAR_CUR_DMES_Pos = 0x1f
	// Bit mask of DMES field.
	FLASH_BANK_SCAR_CUR_DMES_Msk = 0x80000000
	// Bit DMES.
	FLASH_BANK_SCAR_CUR_DMES = 0x80000000

	// BANK.SCAR_PRG: FLASH secure address for bank 1
	// Position of SEC_AREA_START field.
	FLASH_BANK_SCAR_PRG_SEC_AREA_START_Pos = 0x0
	// Bit mask of SEC_AREA_START field.
	FLASH_BANK_SCAR_PRG_SEC_AREA_START_Msk = 0xfff
	// Position of SEC_AREA_END field.
	FLASH_BANK_SCAR_PRG_SEC_AREA_END_Pos = 0x10
	// Bit mask of SEC_AREA_END field.
	FLASH_BANK_SCAR_PRG_SEC_AREA_END_Msk = 0xfff0000
	// Position of DMES field.
	FLASH_BANK_SCAR_PRG_DMES_Pos = 0x1f
	// Bit mask of DMES field.
	FLASH_BANK_SCAR_PRG_DMES_Msk = 0x80000000
	// Bit DMES.
	FLASH_BANK_SCAR_PRG_DMES = 0x80000000

	// BANK.WPSN_CURR: FLASH write sector protection for bank 1
	// Position of WRPSn field.
	FLASH_BANK_WPSN_CURR_WRPSn_Pos = 0x0
	// Bit mask of WRPSn field.
	FLASH_BANK_WPSN_CURR_WRPSn_Msk = 0xff

	// BANK.WPSN_PRGR: FLASH write sector protection for bank 1
	// Position of WRPSn field.
	FLASH_BANK_WPSN_PRGR_WRPSn_Pos = 0x0
	// Bit mask of WRPSn field.
	FLASH_BANK_WPSN_PRGR_WRPSn_Msk = 0xff

	// BANK.CRCCR: FLASH CRC control register for bank 1
	// Position of CRC_SECT field.
	FLASH_BANK_CRCCR_CRC_SECT_Pos = 0x0
	// Bit mask of CRC_SECT field.
	FLASH_BANK_CRCCR_CRC_SECT_Msk = 0x7
	// Position of ALL_BANK field.
	FLASH_BANK_CRCCR_ALL_BANK_Pos = 0x7
	// Bit mask of ALL_BANK field.
	FLASH_BANK_CRCCR_ALL_BANK_Msk = 0x80
	// Bit ALL_BANK.
	FLASH_BANK_CRCCR_ALL_BANK = 0x80
	// Position of CRC_BY_SECT field.
	FLASH_BANK_CRCCR_CRC_BY_SECT_Pos = 0x8
	// Bit mask of CRC_BY_SECT field.
	FLASH_BANK_CRCCR_CRC_BY_SECT_Msk = 0x100
	// Bit CRC_BY_SECT.
	FLASH_BANK_CRCCR_CRC_BY_SECT = 0x100
	// Position of ADD_SECT field.
	FLASH_BANK_CRCCR_ADD_SECT_Pos = 0x9
	// Bit mask of ADD_SECT field.
	FLASH_BANK_CRCCR_ADD_SECT_Msk = 0x200
	// Bit ADD_SECT.
	FLASH_BANK_CRCCR_ADD_SECT = 0x200
	// Position of CLEAN_SECT field.
	FLASH_BANK_CRCCR_CLEAN_SECT_Pos = 0xa
	// Bit mask of CLEAN_SECT field.
	FLASH_BANK_CRCCR_CLEAN_SECT_Msk = 0x400
	// Bit CLEAN_SECT.
	FLASH_BANK_CRCCR_CLEAN_SECT = 0x400
	// Position of START_CRC field.
	FLASH_BANK_CRCCR_START_CRC_Pos = 0x10
	// Bit mask of START_CRC field.
	FLASH_BANK_CRCCR_START_CRC_Msk = 0x10000
	// Bit START_CRC.
	FLASH_BANK_CRCCR_START_CRC = 0x10000
	// Position of CLEAN_CRC field.
	FLASH_BANK_CRCCR_CLEAN_CRC_Pos = 0x11
	// Bit mask of CLEAN_CRC field.
	FLASH_BANK_CRCCR_CLEAN_CRC_Msk = 0x20000
	// Bit CLEAN_CRC.
	FLASH_BANK_CRCCR_CLEAN_CRC = 0x20000
	// Position of CRC_BURST field.
	FLASH_BANK_CRCCR_CRC_BURST_Pos = 0x14
	// Bit mask of CRC_BURST field.
	FLASH_BANK_CRCCR_CRC_BURST_Msk = 0x300000

	// BANK.CRCSADDR: FLASH CRC start address register for bank 1
	// Position of CRC_START_ADDR field.
	FLASH_BANK_CRCSADDR_CRC_START_ADDR_Pos = 0x0
	// Bit mask of CRC_START_ADDR field.
	FLASH_BANK_CRCSADDR_CRC_START_ADDR_Msk = 0xffffffff

	// BANK.CRCEADDR: FLASH CRC end address register for bank 1
	// Position of CRC_END_ADDR field.
	FLASH_BANK_CRCEADDR_CRC_END_ADDR_Pos = 0x0
	// Bit mask of CRC_END_ADDR field.
	FLASH_BANK_CRCEADDR_CRC_END_ADDR_Msk = 0xffffffff

	// BANK.FAR: FLASH ECC fail address for bank 1
	// Position of FAIL_ECC_ADDR field.
	FLASH_BANK_FAR_FAIL_ECC_ADDR_Pos = 0x0
	// Bit mask of FAIL_ECC_ADDR field.
	FLASH_BANK_FAR_FAIL_ECC_ADDR_Msk = 0x7fff

	// OPTKEYR: FLASH option key register
	// Position of OPTKEYR field.
	FLASH_OPTKEYR_OPTKEYR_Pos = 0x0
	// Bit mask of OPTKEYR field.
	FLASH_OPTKEYR_OPTKEYR_Msk = 0xffffffff

	// OPTCR: FLASH option control register
	// Position of OPTLOCK field.
	FLASH_OPTCR_OPTLOCK_Pos = 0x0
	// Bit mask of OPTLOCK field.
	FLASH_OPTCR_OPTLOCK_Msk = 0x1
	// Bit OPTLOCK.
	FLASH_OPTCR_OPTLOCK = 0x1
	// Position of OPTSTART field.
	FLASH_OPTCR_OPTSTART_Pos = 0x1
	// Bit mask of OPTSTART field.
	FLASH_OPTCR_OPTSTART_Msk = 0x2
	// Bit OPTSTART.
	FLASH_OPTCR_OPTSTART = 0x2
	// Position of MER field.
	FLASH_OPTCR_MER_Pos = 0x4
	// Bit mask of MER field.
	FLASH_OPTCR_MER_Msk = 0x10
	// Bit MER.
	FLASH_OPTCR_MER = 0x10
	// Position of OPTCHANGEERRIE field.
	FLASH_OPTCR_OPTCHANGEERRIE_Pos = 0x1e
	// Bit mask of OPTCHANGEERRIE field.
	FLASH_OPTCR_OPTCHANGEERRIE_Msk = 0x40000000
	// Bit OPTCHANGEERRIE.
	FLASH_OPTCR_OPTCHANGEERRIE = 0x40000000
	// Position of SWAP_BANK field.
	FLASH_OPTCR_SWAP_BANK_Pos = 0x1f
	// Bit mask of SWAP_BANK field.
	FLASH_OPTCR_SWAP_BANK_Msk = 0x80000000
	// Bit SWAP_BANK.
	FLASH_OPTCR_SWAP_BANK = 0x80000000

	// OPTSR_CUR: FLASH option status register
	// Position of OPT_BUSY field.
	FLASH_OPTSR_CUR_OPT_BUSY_Pos = 0x0
	// Bit mask of OPT_BUSY field.
	FLASH_OPTSR_CUR_OPT_BUSY_Msk = 0x1
	// Bit OPT_BUSY.
	FLASH_OPTSR_CUR_OPT_BUSY = 0x1
	// Position of BOR_LEV field.
	FLASH_OPTSR_CUR_BOR_LEV_Pos = 0x2
	// Bit mask of BOR_LEV field.
	FLASH_OPTSR_CUR_BOR_LEV_Msk = 0xc
	// Position of IWDG1_HW field.
	FLASH_OPTSR_CUR_IWDG1_HW_Pos = 0x4
	// Bit mask of IWDG1_HW field.
	FLASH_OPTSR_CUR_IWDG1_HW_Msk = 0x10
	// Bit IWDG1_HW.
	FLASH_OPTSR_CUR_IWDG1_HW = 0x10
	// Position of NRST_STOP_D1 field.
	FLASH_OPTSR_CUR_NRST_STOP_D1_Pos = 0x6
	// Bit mask of NRST_STOP_D1 field.
	FLASH_OPTSR_CUR_NRST_STOP_D1_Msk = 0x40
	// Bit NRST_STOP_D1.
	FLASH_OPTSR_CUR_NRST_STOP_D1 = 0x40
	// Position of NRST_STBY_D1 field.
	FLASH_OPTSR_CUR_NRST_STBY_D1_Pos = 0x7
	// Bit mask of NRST_STBY_D1 field.
	FLASH_OPTSR_CUR_NRST_STBY_D1_Msk = 0x80
	// Bit NRST_STBY_D1.
	FLASH_OPTSR_CUR_NRST_STBY_D1 = 0x80
	// Position of RDP field.
	FLASH_OPTSR_CUR_RDP_Pos = 0x8
	// Bit mask of RDP field.
	FLASH_OPTSR_CUR_RDP_Msk = 0xff00
	// Position of FZ_IWDG_STOP field.
	FLASH_OPTSR_CUR_FZ_IWDG_STOP_Pos = 0x11
	// Bit mask of FZ_IWDG_STOP field.
	FLASH_OPTSR_CUR_FZ_IWDG_STOP_Msk = 0x20000
	// Bit FZ_IWDG_STOP.
	FLASH_OPTSR_CUR_FZ_IWDG_STOP = 0x20000
	// Position of FZ_IWDG_SDBY field.
	FLASH_OPTSR_CUR_FZ_IWDG_SDBY_Pos = 0x12
	// Bit mask of FZ_IWDG_SDBY field.
	FLASH_OPTSR_CUR_FZ_IWDG_SDBY_Msk = 0x40000
	// Bit FZ_IWDG_SDBY.
	FLASH_OPTSR_CUR_FZ_IWDG_SDBY = 0x40000
	// Position of ST_RAM_SIZE field.
	FLASH_OPTSR_CUR_ST_RAM_SIZE_Pos = 0x13
	// Bit mask of ST_RAM_SIZE field.
	FLASH_OPTSR_CUR_ST_RAM_SIZE_Msk = 0x180000
	// Position of SECURITY field.
	FLASH_OPTSR_CUR_SECURITY_Pos = 0x15
	// Bit mask of SECURITY field.
	FLASH_OPTSR_CUR_SECURITY_Msk = 0x200000
	// Bit SECURITY.
	FLASH_OPTSR_CUR_SECURITY = 0x200000
	// Position of RSS1 field.
	FLASH_OPTSR_CUR_RSS1_Pos = 0x1a
	// Bit mask of RSS1 field.
	FLASH_OPTSR_CUR_RSS1_Msk = 0x4000000
	// Bit RSS1.
	FLASH_OPTSR_CUR_RSS1 = 0x4000000
	// Position of PERSO_OK field.
	FLASH_OPTSR_CUR_PERSO_OK_Pos = 0x1c
	// Bit mask of PERSO_OK field.
	FLASH_OPTSR_CUR_PERSO_OK_Msk = 0x10000000
	// Bit PERSO_OK.
	FLASH_OPTSR_CUR_PERSO_OK = 0x10000000
	// Position of IO_HSLV field.
	FLASH_OPTSR_CUR_IO_HSLV_Pos = 0x1d
	// Bit mask of IO_HSLV field.
	FLASH_OPTSR_CUR_IO_HSLV_Msk = 0x20000000
	// Bit IO_HSLV.
	FLASH_OPTSR_CUR_IO_HSLV = 0x20000000
	// Position of OPTCHANGEERR field.
	FLASH_OPTSR_CUR_OPTCHANGEERR_Pos = 0x1e
	// Bit mask of OPTCHANGEERR field.
	FLASH_OPTSR_CUR_OPTCHANGEERR_Msk = 0x40000000
	// Bit OPTCHANGEERR.
	FLASH_OPTSR_CUR_OPTCHANGEERR = 0x40000000
	// Position of SWAP_BANK_OPT field.
	FLASH_OPTSR_CUR_SWAP_BANK_OPT_Pos = 0x1f
	// Bit mask of SWAP_BANK_OPT field.
	FLASH_OPTSR_CUR_SWAP_BANK_OPT_Msk = 0x80000000
	// Bit SWAP_BANK_OPT.
	FLASH_OPTSR_CUR_SWAP_BANK_OPT = 0x80000000

	// OPTSR_PRG: FLASH option status register
	// Position of BOR_LEV field.
	FLASH_OPTSR_PRG_BOR_LEV_Pos = 0x2
	// Bit mask of BOR_LEV field.
	FLASH_OPTSR_PRG_BOR_LEV_Msk = 0xc
	// Position of IWDG1_HW field.
	FLASH_OPTSR_PRG_IWDG1_HW_Pos = 0x4
	// Bit mask of IWDG1_HW field.
	FLASH_OPTSR_PRG_IWDG1_HW_Msk = 0x10
	// Bit IWDG1_HW.
	FLASH_OPTSR_PRG_IWDG1_HW = 0x10
	// Position of NRST_STOP_D1 field.
	FLASH_OPTSR_PRG_NRST_STOP_D1_Pos = 0x6
	// Bit mask of NRST_STOP_D1 field.
	FLASH_OPTSR_PRG_NRST_STOP_D1_Msk = 0x40
	// Bit NRST_STOP_D1.
	FLASH_OPTSR_PRG_NRST_STOP_D1 = 0x40
	// Position of NRST_STBY_D1 field.
	FLASH_OPTSR_PRG_NRST_STBY_D1_Pos = 0x7
	// Bit mask of NRST_STBY_D1 field.
	FLASH_OPTSR_PRG_NRST_STBY_D1_Msk = 0x80
	// Bit NRST_STBY_D1.
	FLASH_OPTSR_PRG_NRST_STBY_D1 = 0x80
	// Position of RDP field.
	FLASH_OPTSR_PRG_RDP_Pos = 0x8
	// Bit mask of RDP field.
	FLASH_OPTSR_PRG_RDP_Msk = 0xff00
	// Position of FZ_IWDG_STOP field.
	FLASH_OPTSR_PRG_FZ_IWDG_STOP_Pos = 0x11
	// Bit mask of FZ_IWDG_STOP field.
	FLASH_OPTSR_PRG_FZ_IWDG_STOP_Msk = 0x20000
	// Bit FZ_IWDG_STOP.
	FLASH_OPTSR_PRG_FZ_IWDG_STOP = 0x20000
	// Position of FZ_IWDG_SDBY field.
	FLASH_OPTSR_PRG_FZ_IWDG_SDBY_Pos = 0x12
	// Bit mask of FZ_IWDG_SDBY field.
	FLASH_OPTSR_PRG_FZ_IWDG_SDBY_Msk = 0x40000
	// Bit FZ_IWDG_SDBY.
	FLASH_OPTSR_PRG_FZ_IWDG_SDBY = 0x40000
	// Position of ST_RAM_SIZE field.
	FLASH_OPTSR_PRG_ST_RAM_SIZE_Pos = 0x13
	// Bit mask of ST_RAM_SIZE field.
	FLASH_OPTSR_PRG_ST_RAM_SIZE_Msk = 0x180000
	// Position of SECURITY field.
	FLASH_OPTSR_PRG_SECURITY_Pos = 0x15
	// Bit mask of SECURITY field.
	FLASH_OPTSR_PRG_SECURITY_Msk = 0x200000
	// Bit SECURITY.
	FLASH_OPTSR_PRG_SECURITY = 0x200000
	// Position of RSS1 field.
	FLASH_OPTSR_PRG_RSS1_Pos = 0x1a
	// Bit mask of RSS1 field.
	FLASH_OPTSR_PRG_RSS1_Msk = 0x4000000
	// Bit RSS1.
	FLASH_OPTSR_PRG_RSS1 = 0x4000000
	// Position of RSS2 field.
	FLASH_OPTSR_PRG_RSS2_Pos = 0x1b
	// Bit mask of RSS2 field.
	FLASH_OPTSR_PRG_RSS2_Msk = 0x8000000
	// Bit RSS2.
	FLASH_OPTSR_PRG_RSS2 = 0x8000000
	// Position of IO_HSLV field.
	FLASH_OPTSR_PRG_IO_HSLV_Pos = 0x1d
	// Bit mask of IO_HSLV field.
	FLASH_OPTSR_PRG_IO_HSLV_Msk = 0x20000000
	// Bit IO_HSLV.
	FLASH_OPTSR_PRG_IO_HSLV = 0x20000000
	// Position of SWAP_BANK_OPT field.
	FLASH_OPTSR_PRG_SWAP_BANK_OPT_Pos = 0x1f
	// Bit mask of SWAP_BANK_OPT field.
	FLASH_OPTSR_PRG_SWAP_BANK_OPT_Msk = 0x80000000
	// Bit SWAP_BANK_OPT.
	FLASH_OPTSR_PRG_SWAP_BANK_OPT = 0x80000000

	// OPTCCR: FLASH option clear control register
	// Position of CLR_OPTCHANGEERR field.
	FLASH_OPTCCR_CLR_OPTCHANGEERR_Pos = 0x1e
	// Bit mask of CLR_OPTCHANGEERR field.
	FLASH_OPTCCR_CLR_OPTCHANGEERR_Msk = 0x40000000
	// Bit CLR_OPTCHANGEERR.
	FLASH_OPTCCR_CLR_OPTCHANGEERR = 0x40000000

	// BOOT_CURR: FLASH register with boot address
	// Position of BOOT_ADD0 field.
	FLASH_BOOT_CURR_BOOT_ADD0_Pos = 0x0
	// Bit mask of BOOT_ADD0 field.
	FLASH_BOOT_CURR_BOOT_ADD0_Msk = 0xffff
	// Position of BOOT_ADD1 field.
	FLASH_BOOT_CURR_BOOT_ADD1_Pos = 0x10
	// Bit mask of BOOT_ADD1 field.
	FLASH_BOOT_CURR_BOOT_ADD1_Msk = 0xffff0000

	// BOOT_PRGR: FLASH register with boot address
	// Position of BOOT_ADD0 field.
	FLASH_BOOT_PRGR_BOOT_ADD0_Pos = 0x0
	// Bit mask of BOOT_ADD0 field.
	FLASH_BOOT_PRGR_BOOT_ADD0_Msk = 0xffff
	// Position of BOOT_ADD1 field.
	FLASH_BOOT_PRGR_BOOT_ADD1_Pos = 0x10
	// Bit mask of BOOT_ADD1 field.
	FLASH_BOOT_PRGR_BOOT_ADD1_Msk = 0xffff0000

	// CRCDATAR: FLASH CRC data register
	// Position of CRC_DATA field.
	FLASH_CRCDATAR_CRC_DATA_Pos = 0x0
	// Bit mask of CRC_DATA field.
	FLASH_CRCDATAR_CRC_DATA_Msk = 0xffffffff

	// ACR_: Access control register
	// Position of LATENCY field.
	FLASH_ACR__LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	FLASH_ACR__LATENCY_Msk = 0x7
	// Position of WRHIGHFREQ field.
	FLASH_ACR__WRHIGHFREQ_Pos = 0x4
	// Bit mask of WRHIGHFREQ field.
	FLASH_ACR__WRHIGHFREQ_Msk = 0x30

	// OPTKEYR_: FLASH option key register
	// Position of OPTKEYR field.
	FLASH_OPTKEYR__OPTKEYR_Pos = 0x0
	// Bit mask of OPTKEYR field.
	FLASH_OPTKEYR__OPTKEYR_Msk = 0xffffffff

	// OPTCR_: FLASH option control register
	// Position of OPTLOCK field.
	FLASH_OPTCR__OPTLOCK_Pos = 0x0
	// Bit mask of OPTLOCK field.
	FLASH_OPTCR__OPTLOCK_Msk = 0x1
	// Bit OPTLOCK.
	FLASH_OPTCR__OPTLOCK = 0x1
	// Position of OPTSTART field.
	FLASH_OPTCR__OPTSTART_Pos = 0x1
	// Bit mask of OPTSTART field.
	FLASH_OPTCR__OPTSTART_Msk = 0x2
	// Bit OPTSTART.
	FLASH_OPTCR__OPTSTART = 0x2
	// Position of MER field.
	FLASH_OPTCR__MER_Pos = 0x4
	// Bit mask of MER field.
	FLASH_OPTCR__MER_Msk = 0x10
	// Bit MER.
	FLASH_OPTCR__MER = 0x10
	// Position of OPTCHANGEERRIE field.
	FLASH_OPTCR__OPTCHANGEERRIE_Pos = 0x1e
	// Bit mask of OPTCHANGEERRIE field.
	FLASH_OPTCR__OPTCHANGEERRIE_Msk = 0x40000000
	// Bit OPTCHANGEERRIE.
	FLASH_OPTCR__OPTCHANGEERRIE = 0x40000000
	// Position of SWAP_BANK field.
	FLASH_OPTCR__SWAP_BANK_Pos = 0x1f
	// Bit mask of SWAP_BANK field.
	FLASH_OPTCR__SWAP_BANK_Msk = 0x80000000
	// Bit SWAP_BANK.
	FLASH_OPTCR__SWAP_BANK = 0x80000000

	// OPTSR_CUR_: FLASH option status register
	// Position of OPT_BUSY field.
	FLASH_OPTSR_CUR__OPT_BUSY_Pos = 0x0
	// Bit mask of OPT_BUSY field.
	FLASH_OPTSR_CUR__OPT_BUSY_Msk = 0x1
	// Bit OPT_BUSY.
	FLASH_OPTSR_CUR__OPT_BUSY = 0x1
	// Position of BOR_LEV field.
	FLASH_OPTSR_CUR__BOR_LEV_Pos = 0x2
	// Bit mask of BOR_LEV field.
	FLASH_OPTSR_CUR__BOR_LEV_Msk = 0xc
	// Position of IWDG1_HW field.
	FLASH_OPTSR_CUR__IWDG1_HW_Pos = 0x4
	// Bit mask of IWDG1_HW field.
	FLASH_OPTSR_CUR__IWDG1_HW_Msk = 0x10
	// Bit IWDG1_HW.
	FLASH_OPTSR_CUR__IWDG1_HW = 0x10
	// Position of NRST_STOP_D1 field.
	FLASH_OPTSR_CUR__NRST_STOP_D1_Pos = 0x6
	// Bit mask of NRST_STOP_D1 field.
	FLASH_OPTSR_CUR__NRST_STOP_D1_Msk = 0x40
	// Bit NRST_STOP_D1.
	FLASH_OPTSR_CUR__NRST_STOP_D1 = 0x40
	// Position of NRST_STBY_D1 field.
	FLASH_OPTSR_CUR__NRST_STBY_D1_Pos = 0x7
	// Bit mask of NRST_STBY_D1 field.
	FLASH_OPTSR_CUR__NRST_STBY_D1_Msk = 0x80
	// Bit NRST_STBY_D1.
	FLASH_OPTSR_CUR__NRST_STBY_D1 = 0x80
	// Position of RDP field.
	FLASH_OPTSR_CUR__RDP_Pos = 0x8
	// Bit mask of RDP field.
	FLASH_OPTSR_CUR__RDP_Msk = 0xff00
	// Position of FZ_IWDG_STOP field.
	FLASH_OPTSR_CUR__FZ_IWDG_STOP_Pos = 0x11
	// Bit mask of FZ_IWDG_STOP field.
	FLASH_OPTSR_CUR__FZ_IWDG_STOP_Msk = 0x20000
	// Bit FZ_IWDG_STOP.
	FLASH_OPTSR_CUR__FZ_IWDG_STOP = 0x20000
	// Position of FZ_IWDG_SDBY field.
	FLASH_OPTSR_CUR__FZ_IWDG_SDBY_Pos = 0x12
	// Bit mask of FZ_IWDG_SDBY field.
	FLASH_OPTSR_CUR__FZ_IWDG_SDBY_Msk = 0x40000
	// Bit FZ_IWDG_SDBY.
	FLASH_OPTSR_CUR__FZ_IWDG_SDBY = 0x40000
	// Position of ST_RAM_SIZE field.
	FLASH_OPTSR_CUR__ST_RAM_SIZE_Pos = 0x13
	// Bit mask of ST_RAM_SIZE field.
	FLASH_OPTSR_CUR__ST_RAM_SIZE_Msk = 0x180000
	// Position of SECURITY field.
	FLASH_OPTSR_CUR__SECURITY_Pos = 0x15
	// Bit mask of SECURITY field.
	FLASH_OPTSR_CUR__SECURITY_Msk = 0x200000
	// Bit SECURITY.
	FLASH_OPTSR_CUR__SECURITY = 0x200000
	// Position of RSS1 field.
	FLASH_OPTSR_CUR__RSS1_Pos = 0x1a
	// Bit mask of RSS1 field.
	FLASH_OPTSR_CUR__RSS1_Msk = 0x4000000
	// Bit RSS1.
	FLASH_OPTSR_CUR__RSS1 = 0x4000000
	// Position of PERSO_OK field.
	FLASH_OPTSR_CUR__PERSO_OK_Pos = 0x1c
	// Bit mask of PERSO_OK field.
	FLASH_OPTSR_CUR__PERSO_OK_Msk = 0x10000000
	// Bit PERSO_OK.
	FLASH_OPTSR_CUR__PERSO_OK = 0x10000000
	// Position of IO_HSLV field.
	FLASH_OPTSR_CUR__IO_HSLV_Pos = 0x1d
	// Bit mask of IO_HSLV field.
	FLASH_OPTSR_CUR__IO_HSLV_Msk = 0x20000000
	// Bit IO_HSLV.
	FLASH_OPTSR_CUR__IO_HSLV = 0x20000000
	// Position of OPTCHANGEERR field.
	FLASH_OPTSR_CUR__OPTCHANGEERR_Pos = 0x1e
	// Bit mask of OPTCHANGEERR field.
	FLASH_OPTSR_CUR__OPTCHANGEERR_Msk = 0x40000000
	// Bit OPTCHANGEERR.
	FLASH_OPTSR_CUR__OPTCHANGEERR = 0x40000000
	// Position of SWAP_BANK_OPT field.
	FLASH_OPTSR_CUR__SWAP_BANK_OPT_Pos = 0x1f
	// Bit mask of SWAP_BANK_OPT field.
	FLASH_OPTSR_CUR__SWAP_BANK_OPT_Msk = 0x80000000
	// Bit SWAP_BANK_OPT.
	FLASH_OPTSR_CUR__SWAP_BANK_OPT = 0x80000000

	// OPTSR_PRG_: FLASH option status register
	// Position of BOR_LEV field.
	FLASH_OPTSR_PRG__BOR_LEV_Pos = 0x2
	// Bit mask of BOR_LEV field.
	FLASH_OPTSR_PRG__BOR_LEV_Msk = 0xc
	// Position of IWDG1_HW field.
	FLASH_OPTSR_PRG__IWDG1_HW_Pos = 0x4
	// Bit mask of IWDG1_HW field.
	FLASH_OPTSR_PRG__IWDG1_HW_Msk = 0x10
	// Bit IWDG1_HW.
	FLASH_OPTSR_PRG__IWDG1_HW = 0x10
	// Position of NRST_STOP_D1 field.
	FLASH_OPTSR_PRG__NRST_STOP_D1_Pos = 0x6
	// Bit mask of NRST_STOP_D1 field.
	FLASH_OPTSR_PRG__NRST_STOP_D1_Msk = 0x40
	// Bit NRST_STOP_D1.
	FLASH_OPTSR_PRG__NRST_STOP_D1 = 0x40
	// Position of NRST_STBY_D1 field.
	FLASH_OPTSR_PRG__NRST_STBY_D1_Pos = 0x7
	// Bit mask of NRST_STBY_D1 field.
	FLASH_OPTSR_PRG__NRST_STBY_D1_Msk = 0x80
	// Bit NRST_STBY_D1.
	FLASH_OPTSR_PRG__NRST_STBY_D1 = 0x80
	// Position of RDP field.
	FLASH_OPTSR_PRG__RDP_Pos = 0x8
	// Bit mask of RDP field.
	FLASH_OPTSR_PRG__RDP_Msk = 0xff00
	// Position of FZ_IWDG_STOP field.
	FLASH_OPTSR_PRG__FZ_IWDG_STOP_Pos = 0x11
	// Bit mask of FZ_IWDG_STOP field.
	FLASH_OPTSR_PRG__FZ_IWDG_STOP_Msk = 0x20000
	// Bit FZ_IWDG_STOP.
	FLASH_OPTSR_PRG__FZ_IWDG_STOP = 0x20000
	// Position of FZ_IWDG_SDBY field.
	FLASH_OPTSR_PRG__FZ_IWDG_SDBY_Pos = 0x12
	// Bit mask of FZ_IWDG_SDBY field.
	FLASH_OPTSR_PRG__FZ_IWDG_SDBY_Msk = 0x40000
	// Bit FZ_IWDG_SDBY.
	FLASH_OPTSR_PRG__FZ_IWDG_SDBY = 0x40000
	// Position of ST_RAM_SIZE field.
	FLASH_OPTSR_PRG__ST_RAM_SIZE_Pos = 0x13
	// Bit mask of ST_RAM_SIZE field.
	FLASH_OPTSR_PRG__ST_RAM_SIZE_Msk = 0x180000
	// Position of SECURITY field.
	FLASH_OPTSR_PRG__SECURITY_Pos = 0x15
	// Bit mask of SECURITY field.
	FLASH_OPTSR_PRG__SECURITY_Msk = 0x200000
	// Bit SECURITY.
	FLASH_OPTSR_PRG__SECURITY = 0x200000
	// Position of RSS1 field.
	FLASH_OPTSR_PRG__RSS1_Pos = 0x1a
	// Bit mask of RSS1 field.
	FLASH_OPTSR_PRG__RSS1_Msk = 0x4000000
	// Bit RSS1.
	FLASH_OPTSR_PRG__RSS1 = 0x4000000
	// Position of RSS2 field.
	FLASH_OPTSR_PRG__RSS2_Pos = 0x1b
	// Bit mask of RSS2 field.
	FLASH_OPTSR_PRG__RSS2_Msk = 0x8000000
	// Bit RSS2.
	FLASH_OPTSR_PRG__RSS2 = 0x8000000
	// Position of IO_HSLV field.
	FLASH_OPTSR_PRG__IO_HSLV_Pos = 0x1d
	// Bit mask of IO_HSLV field.
	FLASH_OPTSR_PRG__IO_HSLV_Msk = 0x20000000
	// Bit IO_HSLV.
	FLASH_OPTSR_PRG__IO_HSLV = 0x20000000
	// Position of SWAP_BANK_OPT field.
	FLASH_OPTSR_PRG__SWAP_BANK_OPT_Pos = 0x1f
	// Bit mask of SWAP_BANK_OPT field.
	FLASH_OPTSR_PRG__SWAP_BANK_OPT_Msk = 0x80000000
	// Bit SWAP_BANK_OPT.
	FLASH_OPTSR_PRG__SWAP_BANK_OPT = 0x80000000

	// OPTCCR_: FLASH option clear control register
	// Position of CLR_OPTCHANGEERR field.
	FLASH_OPTCCR__CLR_OPTCHANGEERR_Pos = 0x1e
	// Bit mask of CLR_OPTCHANGEERR field.
	FLASH_OPTCCR__CLR_OPTCHANGEERR_Msk = 0x40000000
	// Bit CLR_OPTCHANGEERR.
	FLASH_OPTCCR__CLR_OPTCHANGEERR = 0x40000000
)

// Constants for GPIOA: GPIO
const (
	// MODER: GPIO port mode register
	// Position of MODER0 field.
	GPIO_MODER_MODER0_Pos = 0x0
	// Bit mask of MODER0 field.
	GPIO_MODER_MODER0_Msk = 0x3
	// Input mode (reset state)
	GPIO_MODER_MODER0_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER0_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER0_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER0_Analog = 0x3
	// Position of MODER1 field.
	GPIO_MODER_MODER1_Pos = 0x2
	// Bit mask of MODER1 field.
	GPIO_MODER_MODER1_Msk = 0xc
	// Input mode (reset state)
	GPIO_MODER_MODER1_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER1_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER1_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER1_Analog = 0x3
	// Position of MODER2 field.
	GPIO_MODER_MODER2_Pos = 0x4
	// Bit mask of MODER2 field.
	GPIO_MODER_MODER2_Msk = 0x30
	// Input mode (reset state)
	GPIO_MODER_MODER2_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER2_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER2_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER2_Analog = 0x3
	// Position of MODER3 field.
	GPIO_MODER_MODER3_Pos = 0x6
	// Bit mask of MODER3 field.
	GPIO_MODER_MODER3_Msk = 0xc0
	// Input mode (reset state)
	GPIO_MODER_MODER3_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER3_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER3_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER3_Analog = 0x3
	// Position of MODER4 field.
	GPIO_MODER_MODER4_Pos = 0x8
	// Bit mask of MODER4 field.
	GPIO_MODER_MODER4_Msk = 0x300
	// Input mode (reset state)
	GPIO_MODER_MODER4_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER4_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER4_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER4_Analog = 0x3
	// Position of MODER5 field.
	GPIO_MODER_MODER5_Pos = 0xa
	// Bit mask of MODER5 field.
	GPIO_MODER_MODER5_Msk = 0xc00
	// Input mode (reset state)
	GPIO_MODER_MODER5_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER5_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER5_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER5_Analog = 0x3
	// Position of MODER6 field.
	GPIO_MODER_MODER6_Pos = 0xc
	// Bit mask of MODER6 field.
	GPIO_MODER_MODER6_Msk = 0x3000
	// Input mode (reset state)
	GPIO_MODER_MODER6_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER6_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER6_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER6_Analog = 0x3
	// Position of MODER7 field.
	GPIO_MODER_MODER7_Pos = 0xe
	// Bit mask of MODER7 field.
	GPIO_MODER_MODER7_Msk = 0xc000
	// Input mode (reset state)
	GPIO_MODER_MODER7_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER7_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER7_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER7_Analog = 0x3
	// Position of MODER8 field.
	GPIO_MODER_MODER8_Pos = 0x10
	// Bit mask of MODER8 field.
	GPIO_MODER_MODER8_Msk = 0x30000
	// Input mode (reset state)
	GPIO_MODER_MODER8_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER8_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER8_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER8_Analog = 0x3
	// Position of MODER9 field.
	GPIO_MODER_MODER9_Pos = 0x12
	// Bit mask of MODER9 field.
	GPIO_MODER_MODER9_Msk = 0xc0000
	// Input mode (reset state)
	GPIO_MODER_MODER9_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER9_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER9_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER9_Analog = 0x3
	// Position of MODER10 field.
	GPIO_MODER_MODER10_Pos = 0x14
	// Bit mask of MODER10 field.
	GPIO_MODER_MODER10_Msk = 0x300000
	// Input mode (reset state)
	GPIO_MODER_MODER10_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER10_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER10_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER10_Analog = 0x3
	// Position of MODER11 field.
	GPIO_MODER_MODER11_Pos = 0x16
	// Bit mask of MODER11 field.
	GPIO_MODER_MODER11_Msk = 0xc00000
	// Input mode (reset state)
	GPIO_MODER_MODER11_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER11_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER11_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER11_Analog = 0x3
	// Position of MODER12 field.
	GPIO_MODER_MODER12_Pos = 0x18
	// Bit mask of MODER12 field.
	GPIO_MODER_MODER12_Msk = 0x3000000
	// Input mode (reset state)
	GPIO_MODER_MODER12_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER12_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER12_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER12_Analog = 0x3
	// Position of MODER13 field.
	GPIO_MODER_MODER13_Pos = 0x1a
	// Bit mask of MODER13 field.
	GPIO_MODER_MODER13_Msk = 0xc000000
	// Input mode (reset state)
	GPIO_MODER_MODER13_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER13_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER13_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER13_Analog = 0x3
	// Position of MODER14 field.
	GPIO_MODER_MODER14_Pos = 0x1c
	// Bit mask of MODER14 field.
	GPIO_MODER_MODER14_Msk = 0x30000000
	// Input mode (reset state)
	GPIO_MODER_MODER14_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER14_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER14_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER14_Analog = 0x3
	// Position of MODER15 field.
	GPIO_MODER_MODER15_Pos = 0x1e
	// Bit mask of MODER15 field.
	GPIO_MODER_MODER15_Msk = 0xc0000000
	// Input mode (reset state)
	GPIO_MODER_MODER15_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER15_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER15_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER15_Analog = 0x3

	// OTYPER: GPIO port output type register
	// Position of OT0 field.
	GPIO_OTYPER_OT0_Pos = 0x0
	// Bit mask of OT0 field.
	GPIO_OTYPER_OT0_Msk = 0x1
	// Bit OT0.
	GPIO_OTYPER_OT0 = 0x1
	// Output push-pull (reset state)
	GPIO_OTYPER_OT0_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT0_OpenDrain = 0x1
	// Position of OT1 field.
	GPIO_OTYPER_OT1_Pos = 0x1
	// Bit mask of OT1 field.
	GPIO_OTYPER_OT1_Msk = 0x2
	// Bit OT1.
	GPIO_OTYPER_OT1 = 0x2
	// Output push-pull (reset state)
	GPIO_OTYPER_OT1_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT1_OpenDrain = 0x1
	// Position of OT2 field.
	GPIO_OTYPER_OT2_Pos = 0x2
	// Bit mask of OT2 field.
	GPIO_OTYPER_OT2_Msk = 0x4
	// Bit OT2.
	GPIO_OTYPER_OT2 = 0x4
	// Output push-pull (reset state)
	GPIO_OTYPER_OT2_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT2_OpenDrain = 0x1
	// Position of OT3 field.
	GPIO_OTYPER_OT3_Pos = 0x3
	// Bit mask of OT3 field.
	GPIO_OTYPER_OT3_Msk = 0x8
	// Bit OT3.
	GPIO_OTYPER_OT3 = 0x8
	// Output push-pull (reset state)
	GPIO_OTYPER_OT3_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT3_OpenDrain = 0x1
	// Position of OT4 field.
	GPIO_OTYPER_OT4_Pos = 0x4
	// Bit mask of OT4 field.
	GPIO_OTYPER_OT4_Msk = 0x10
	// Bit OT4.
	GPIO_OTYPER_OT4 = 0x10
	// Output push-pull (reset state)
	GPIO_OTYPER_OT4_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT4_OpenDrain = 0x1
	// Position of OT5 field.
	GPIO_OTYPER_OT5_Pos = 0x5
	// Bit mask of OT5 field.
	GPIO_OTYPER_OT5_Msk = 0x20
	// Bit OT5.
	GPIO_OTYPER_OT5 = 0x20
	// Output push-pull (reset state)
	GPIO_OTYPER_OT5_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT5_OpenDrain = 0x1
	// Position of OT6 field.
	GPIO_OTYPER_OT6_Pos = 0x6
	// Bit mask of OT6 field.
	GPIO_OTYPER_OT6_Msk = 0x40
	// Bit OT6.
	GPIO_OTYPER_OT6 = 0x40
	// Output push-pull (reset state)
	GPIO_OTYPER_OT6_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT6_OpenDrain = 0x1
	// Position of OT7 field.
	GPIO_OTYPER_OT7_Pos = 0x7
	// Bit mask of OT7 field.
	GPIO_OTYPER_OT7_Msk = 0x80
	// Bit OT7.
	GPIO_OTYPER_OT7 = 0x80
	// Output push-pull (reset state)
	GPIO_OTYPER_OT7_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT7_OpenDrain = 0x1
	// Position of OT8 field.
	GPIO_OTYPER_OT8_Pos = 0x8
	// Bit mask of OT8 field.
	GPIO_OTYPER_OT8_Msk = 0x100
	// Bit OT8.
	GPIO_OTYPER_OT8 = 0x100
	// Output push-pull (reset state)
	GPIO_OTYPER_OT8_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT8_OpenDrain = 0x1
	// Position of OT9 field.
	GPIO_OTYPER_OT9_Pos = 0x9
	// Bit mask of OT9 field.
	GPIO_OTYPER_OT9_Msk = 0x200
	// Bit OT9.
	GPIO_OTYPER_OT9 = 0x200
	// Output push-pull (reset state)
	GPIO_OTYPER_OT9_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT9_OpenDrain = 0x1
	// Position of OT10 field.
	GPIO_OTYPER_OT10_Pos = 0xa
	// Bit mask of OT10 field.
	GPIO_OTYPER_OT10_Msk = 0x400
	// Bit OT10.
	GPIO_OTYPER_OT10 = 0x400
	// Output push-pull (reset state)
	GPIO_OTYPER_OT10_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT10_OpenDrain = 0x1
	// Position of OT11 field.
	GPIO_OTYPER_OT11_Pos = 0xb
	// Bit mask of OT11 field.
	GPIO_OTYPER_OT11_Msk = 0x800
	// Bit OT11.
	GPIO_OTYPER_OT11 = 0x800
	// Output push-pull (reset state)
	GPIO_OTYPER_OT11_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT11_OpenDrain = 0x1
	// Position of OT12 field.
	GPIO_OTYPER_OT12_Pos = 0xc
	// Bit mask of OT12 field.
	GPIO_OTYPER_OT12_Msk = 0x1000
	// Bit OT12.
	GPIO_OTYPER_OT12 = 0x1000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT12_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT12_OpenDrain = 0x1
	// Position of OT13 field.
	GPIO_OTYPER_OT13_Pos = 0xd
	// Bit mask of OT13 field.
	GPIO_OTYPER_OT13_Msk = 0x2000
	// Bit OT13.
	GPIO_OTYPER_OT13 = 0x2000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT13_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT13_OpenDrain = 0x1
	// Position of OT14 field.
	GPIO_OTYPER_OT14_Pos = 0xe
	// Bit mask of OT14 field.
	GPIO_OTYPER_OT14_Msk = 0x4000
	// Bit OT14.
	GPIO_OTYPER_OT14 = 0x4000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT14_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT14_OpenDrain = 0x1
	// Position of OT15 field.
	GPIO_OTYPER_OT15_Pos = 0xf
	// Bit mask of OT15 field.
	GPIO_OTYPER_OT15_Msk = 0x8000
	// Bit OT15.
	GPIO_OTYPER_OT15 = 0x8000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT15_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT15_OpenDrain = 0x1

	// OSPEEDR: GPIO port output speed register
	// Position of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Pos = 0x0
	// Bit mask of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Msk = 0x3
	// Low speed
	GPIO_OSPEEDR_OSPEEDR0_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR0_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR0_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR0_VeryHighSpeed = 0x3
	// Position of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Pos = 0x2
	// Bit mask of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Msk = 0xc
	// Low speed
	GPIO_OSPEEDR_OSPEEDR1_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR1_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR1_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR1_VeryHighSpeed = 0x3
	// Position of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Pos = 0x4
	// Bit mask of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Msk = 0x30
	// Low speed
	GPIO_OSPEEDR_OSPEEDR2_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR2_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR2_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR2_VeryHighSpeed = 0x3
	// Position of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Pos = 0x6
	// Bit mask of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Msk = 0xc0
	// Low speed
	GPIO_OSPEEDR_OSPEEDR3_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR3_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR3_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR3_VeryHighSpeed = 0x3
	// Position of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Pos = 0x8
	// Bit mask of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Msk = 0x300
	// Low speed
	GPIO_OSPEEDR_OSPEEDR4_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR4_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR4_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR4_VeryHighSpeed = 0x3
	// Position of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Pos = 0xa
	// Bit mask of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Msk = 0xc00
	// Low speed
	GPIO_OSPEEDR_OSPEEDR5_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR5_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR5_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR5_VeryHighSpeed = 0x3
	// Position of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Pos = 0xc
	// Bit mask of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Msk = 0x3000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR6_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR6_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR6_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR6_VeryHighSpeed = 0x3
	// Position of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Pos = 0xe
	// Bit mask of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Msk = 0xc000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR7_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR7_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR7_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR7_VeryHighSpeed = 0x3
	// Position of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Pos = 0x10
	// Bit mask of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Msk = 0x30000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR8_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR8_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR8_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR8_VeryHighSpeed = 0x3
	// Position of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Pos = 0x12
	// Bit mask of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Msk = 0xc0000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR9_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR9_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR9_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR9_VeryHighSpeed = 0x3
	// Position of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Pos = 0x14
	// Bit mask of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Msk = 0x300000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR10_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR10_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR10_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR10_VeryHighSpeed = 0x3
	// Position of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Pos = 0x16
	// Bit mask of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Msk = 0xc00000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR11_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR11_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR11_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR11_VeryHighSpeed = 0x3
	// Position of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Pos = 0x18
	// Bit mask of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Msk = 0x3000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR12_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR12_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR12_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR12_VeryHighSpeed = 0x3
	// Position of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Pos = 0x1a
	// Bit mask of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Msk = 0xc000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR13_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR13_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR13_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR13_VeryHighSpeed = 0x3
	// Position of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Pos = 0x1c
	// Bit mask of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Msk = 0x30000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR14_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR14_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR14_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR14_VeryHighSpeed = 0x3
	// Position of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Pos = 0x1e
	// Bit mask of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Msk = 0xc0000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR15_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR15_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR15_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR15_VeryHighSpeed = 0x3

	// PUPDR: GPIO port pull-up/pull-down register
	// Position of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Pos = 0x0
	// Bit mask of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Msk = 0x3
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR0_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR0_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR0_PullDown = 0x2
	// Position of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Pos = 0x2
	// Bit mask of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Msk = 0xc
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR1_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR1_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR1_PullDown = 0x2
	// Position of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Pos = 0x4
	// Bit mask of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Msk = 0x30
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR2_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR2_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR2_PullDown = 0x2
	// Position of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Pos = 0x6
	// Bit mask of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Msk = 0xc0
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR3_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR3_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR3_PullDown = 0x2
	// Position of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Pos = 0x8
	// Bit mask of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Msk = 0x300
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR4_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR4_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR4_PullDown = 0x2
	// Position of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Pos = 0xa
	// Bit mask of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Msk = 0xc00
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR5_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR5_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR5_PullDown = 0x2
	// Position of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Pos = 0xc
	// Bit mask of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Msk = 0x3000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR6_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR6_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR6_PullDown = 0x2
	// Position of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Pos = 0xe
	// Bit mask of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Msk = 0xc000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR7_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR7_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR7_PullDown = 0x2
	// Position of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Pos = 0x10
	// Bit mask of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Msk = 0x30000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR8_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR8_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR8_PullDown = 0x2
	// Position of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Pos = 0x12
	// Bit mask of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Msk = 0xc0000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR9_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR9_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR9_PullDown = 0x2
	// Position of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Pos = 0x14
	// Bit mask of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Msk = 0x300000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR10_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR10_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR10_PullDown = 0x2
	// Position of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Pos = 0x16
	// Bit mask of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Msk = 0xc00000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR11_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR11_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR11_PullDown = 0x2
	// Position of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Pos = 0x18
	// Bit mask of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Msk = 0x3000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR12_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR12_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR12_PullDown = 0x2
	// Position of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Pos = 0x1a
	// Bit mask of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Msk = 0xc000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR13_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR13_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR13_PullDown = 0x2
	// Position of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Pos = 0x1c
	// Bit mask of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Msk = 0x30000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR14_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR14_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR14_PullDown = 0x2
	// Position of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Pos = 0x1e
	// Bit mask of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Msk = 0xc0000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR15_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR15_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR15_PullDown = 0x2

	// IDR: GPIO port input data register
	// Position of IDR0 field.
	GPIO_IDR_IDR0_Pos = 0x0
	// Bit mask of IDR0 field.
	GPIO_IDR_IDR0_Msk = 0x1
	// Bit IDR0.
	GPIO_IDR_IDR0 = 0x1
	// Input is logic high
	GPIO_IDR_IDR0_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR0_Low = 0x0
	// Position of IDR1 field.
	GPIO_IDR_IDR1_Pos = 0x1
	// Bit mask of IDR1 field.
	GPIO_IDR_IDR1_Msk = 0x2
	// Bit IDR1.
	GPIO_IDR_IDR1 = 0x2
	// Input is logic high
	GPIO_IDR_IDR1_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR1_Low = 0x0
	// Position of IDR2 field.
	GPIO_IDR_IDR2_Pos = 0x2
	// Bit mask of IDR2 field.
	GPIO_IDR_IDR2_Msk = 0x4
	// Bit IDR2.
	GPIO_IDR_IDR2 = 0x4
	// Input is logic high
	GPIO_IDR_IDR2_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR2_Low = 0x0
	// Position of IDR3 field.
	GPIO_IDR_IDR3_Pos = 0x3
	// Bit mask of IDR3 field.
	GPIO_IDR_IDR3_Msk = 0x8
	// Bit IDR3.
	GPIO_IDR_IDR3 = 0x8
	// Input is logic high
	GPIO_IDR_IDR3_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR3_Low = 0x0
	// Position of IDR4 field.
	GPIO_IDR_IDR4_Pos = 0x4
	// Bit mask of IDR4 field.
	GPIO_IDR_IDR4_Msk = 0x10
	// Bit IDR4.
	GPIO_IDR_IDR4 = 0x10
	// Input is logic high
	GPIO_IDR_IDR4_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR4_Low = 0x0
	// Position of IDR5 field.
	GPIO_IDR_IDR5_Pos = 0x5
	// Bit mask of IDR5 field.
	GPIO_IDR_IDR5_Msk = 0x20
	// Bit IDR5.
	GPIO_IDR_IDR5 = 0x20
	// Input is logic high
	GPIO_IDR_IDR5_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR5_Low = 0x0
	// Position of IDR6 field.
	GPIO_IDR_IDR6_Pos = 0x6
	// Bit mask of IDR6 field.
	GPIO_IDR_IDR6_Msk = 0x40
	// Bit IDR6.
	GPIO_IDR_IDR6 = 0x40
	// Input is logic high
	GPIO_IDR_IDR6_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR6_Low = 0x0
	// Position of IDR7 field.
	GPIO_IDR_IDR7_Pos = 0x7
	// Bit mask of IDR7 field.
	GPIO_IDR_IDR7_Msk = 0x80
	// Bit IDR7.
	GPIO_IDR_IDR7 = 0x80
	// Input is logic high
	GPIO_IDR_IDR7_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR7_Low = 0x0
	// Position of IDR8 field.
	GPIO_IDR_IDR8_Pos = 0x8
	// Bit mask of IDR8 field.
	GPIO_IDR_IDR8_Msk = 0x100
	// Bit IDR8.
	GPIO_IDR_IDR8 = 0x100
	// Input is logic high
	GPIO_IDR_IDR8_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR8_Low = 0x0
	// Position of IDR9 field.
	GPIO_IDR_IDR9_Pos = 0x9
	// Bit mask of IDR9 field.
	GPIO_IDR_IDR9_Msk = 0x200
	// Bit IDR9.
	GPIO_IDR_IDR9 = 0x200
	// Input is logic high
	GPIO_IDR_IDR9_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR9_Low = 0x0
	// Position of IDR10 field.
	GPIO_IDR_IDR10_Pos = 0xa
	// Bit mask of IDR10 field.
	GPIO_IDR_IDR10_Msk = 0x400
	// Bit IDR10.
	GPIO_IDR_IDR10 = 0x400
	// Input is logic high
	GPIO_IDR_IDR10_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR10_Low = 0x0
	// Position of IDR11 field.
	GPIO_IDR_IDR11_Pos = 0xb
	// Bit mask of IDR11 field.
	GPIO_IDR_IDR11_Msk = 0x800
	// Bit IDR11.
	GPIO_IDR_IDR11 = 0x800
	// Input is logic high
	GPIO_IDR_IDR11_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR11_Low = 0x0
	// Position of IDR12 field.
	GPIO_IDR_IDR12_Pos = 0xc
	// Bit mask of IDR12 field.
	GPIO_IDR_IDR12_Msk = 0x1000
	// Bit IDR12.
	GPIO_IDR_IDR12 = 0x1000
	// Input is logic high
	GPIO_IDR_IDR12_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR12_Low = 0x0
	// Position of IDR13 field.
	GPIO_IDR_IDR13_Pos = 0xd
	// Bit mask of IDR13 field.
	GPIO_IDR_IDR13_Msk = 0x2000
	// Bit IDR13.
	GPIO_IDR_IDR13 = 0x2000
	// Input is logic high
	GPIO_IDR_IDR13_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR13_Low = 0x0
	// Position of IDR14 field.
	GPIO_IDR_IDR14_Pos = 0xe
	// Bit mask of IDR14 field.
	GPIO_IDR_IDR14_Msk = 0x4000
	// Bit IDR14.
	GPIO_IDR_IDR14 = 0x4000
	// Input is logic high
	GPIO_IDR_IDR14_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR14_Low = 0x0
	// Position of IDR15 field.
	GPIO_IDR_IDR15_Pos = 0xf
	// Bit mask of IDR15 field.
	GPIO_IDR_IDR15_Msk = 0x8000
	// Bit IDR15.
	GPIO_IDR_IDR15 = 0x8000
	// Input is logic high
	GPIO_IDR_IDR15_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR15_Low = 0x0

	// ODR: GPIO port output data register
	// Position of ODR0 field.
	GPIO_ODR_ODR0_Pos = 0x0
	// Bit mask of ODR0 field.
	GPIO_ODR_ODR0_Msk = 0x1
	// Bit ODR0.
	GPIO_ODR_ODR0 = 0x1
	// Set output to logic high
	GPIO_ODR_ODR0_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR0_Low = 0x0
	// Position of ODR1 field.
	GPIO_ODR_ODR1_Pos = 0x1
	// Bit mask of ODR1 field.
	GPIO_ODR_ODR1_Msk = 0x2
	// Bit ODR1.
	GPIO_ODR_ODR1 = 0x2
	// Set output to logic high
	GPIO_ODR_ODR1_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR1_Low = 0x0
	// Position of ODR2 field.
	GPIO_ODR_ODR2_Pos = 0x2
	// Bit mask of ODR2 field.
	GPIO_ODR_ODR2_Msk = 0x4
	// Bit ODR2.
	GPIO_ODR_ODR2 = 0x4
	// Set output to logic high
	GPIO_ODR_ODR2_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR2_Low = 0x0
	// Position of ODR3 field.
	GPIO_ODR_ODR3_Pos = 0x3
	// Bit mask of ODR3 field.
	GPIO_ODR_ODR3_Msk = 0x8
	// Bit ODR3.
	GPIO_ODR_ODR3 = 0x8
	// Set output to logic high
	GPIO_ODR_ODR3_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR3_Low = 0x0
	// Position of ODR4 field.
	GPIO_ODR_ODR4_Pos = 0x4
	// Bit mask of ODR4 field.
	GPIO_ODR_ODR4_Msk = 0x10
	// Bit ODR4.
	GPIO_ODR_ODR4 = 0x10
	// Set output to logic high
	GPIO_ODR_ODR4_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR4_Low = 0x0
	// Position of ODR5 field.
	GPIO_ODR_ODR5_Pos = 0x5
	// Bit mask of ODR5 field.
	GPIO_ODR_ODR5_Msk = 0x20
	// Bit ODR5.
	GPIO_ODR_ODR5 = 0x20
	// Set output to logic high
	GPIO_ODR_ODR5_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR5_Low = 0x0
	// Position of ODR6 field.
	GPIO_ODR_ODR6_Pos = 0x6
	// Bit mask of ODR6 field.
	GPIO_ODR_ODR6_Msk = 0x40
	// Bit ODR6.
	GPIO_ODR_ODR6 = 0x40
	// Set output to logic high
	GPIO_ODR_ODR6_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR6_Low = 0x0
	// Position of ODR7 field.
	GPIO_ODR_ODR7_Pos = 0x7
	// Bit mask of ODR7 field.
	GPIO_ODR_ODR7_Msk = 0x80
	// Bit ODR7.
	GPIO_ODR_ODR7 = 0x80
	// Set output to logic high
	GPIO_ODR_ODR7_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR7_Low = 0x0
	// Position of ODR8 field.
	GPIO_ODR_ODR8_Pos = 0x8
	// Bit mask of ODR8 field.
	GPIO_ODR_ODR8_Msk = 0x100
	// Bit ODR8.
	GPIO_ODR_ODR8 = 0x100
	// Set output to logic high
	GPIO_ODR_ODR8_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR8_Low = 0x0
	// Position of ODR9 field.
	GPIO_ODR_ODR9_Pos = 0x9
	// Bit mask of ODR9 field.
	GPIO_ODR_ODR9_Msk = 0x200
	// Bit ODR9.
	GPIO_ODR_ODR9 = 0x200
	// Set output to logic high
	GPIO_ODR_ODR9_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR9_Low = 0x0
	// Position of ODR10 field.
	GPIO_ODR_ODR10_Pos = 0xa
	// Bit mask of ODR10 field.
	GPIO_ODR_ODR10_Msk = 0x400
	// Bit ODR10.
	GPIO_ODR_ODR10 = 0x400
	// Set output to logic high
	GPIO_ODR_ODR10_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR10_Low = 0x0
	// Position of ODR11 field.
	GPIO_ODR_ODR11_Pos = 0xb
	// Bit mask of ODR11 field.
	GPIO_ODR_ODR11_Msk = 0x800
	// Bit ODR11.
	GPIO_ODR_ODR11 = 0x800
	// Set output to logic high
	GPIO_ODR_ODR11_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR11_Low = 0x0
	// Position of ODR12 field.
	GPIO_ODR_ODR12_Pos = 0xc
	// Bit mask of ODR12 field.
	GPIO_ODR_ODR12_Msk = 0x1000
	// Bit ODR12.
	GPIO_ODR_ODR12 = 0x1000
	// Set output to logic high
	GPIO_ODR_ODR12_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR12_Low = 0x0
	// Position of ODR13 field.
	GPIO_ODR_ODR13_Pos = 0xd
	// Bit mask of ODR13 field.
	GPIO_ODR_ODR13_Msk = 0x2000
	// Bit ODR13.
	GPIO_ODR_ODR13 = 0x2000
	// Set output to logic high
	GPIO_ODR_ODR13_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR13_Low = 0x0
	// Position of ODR14 field.
	GPIO_ODR_ODR14_Pos = 0xe
	// Bit mask of ODR14 field.
	GPIO_ODR_ODR14_Msk = 0x4000
	// Bit ODR14.
	GPIO_ODR_ODR14 = 0x4000
	// Set output to logic high
	GPIO_ODR_ODR14_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR14_Low = 0x0
	// Position of ODR15 field.
	GPIO_ODR_ODR15_Pos = 0xf
	// Bit mask of ODR15 field.
	GPIO_ODR_ODR15_Msk = 0x8000
	// Bit ODR15.
	GPIO_ODR_ODR15 = 0x8000
	// Set output to logic high
	GPIO_ODR_ODR15_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR15_Low = 0x0

	// BSRR: GPIO port bit set/reset register
	// Position of BS0 field.
	GPIO_BSRR_BS0_Pos = 0x0
	// Bit mask of BS0 field.
	GPIO_BSRR_BS0_Msk = 0x1
	// Bit BS0.
	GPIO_BSRR_BS0 = 0x1
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS0_Set = 0x1
	// Position of BS1 field.
	GPIO_BSRR_BS1_Pos = 0x1
	// Bit mask of BS1 field.
	GPIO_BSRR_BS1_Msk = 0x2
	// Bit BS1.
	GPIO_BSRR_BS1 = 0x2
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS1_Set = 0x1
	// Position of BS2 field.
	GPIO_BSRR_BS2_Pos = 0x2
	// Bit mask of BS2 field.
	GPIO_BSRR_BS2_Msk = 0x4
	// Bit BS2.
	GPIO_BSRR_BS2 = 0x4
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS2_Set = 0x1
	// Position of BS3 field.
	GPIO_BSRR_BS3_Pos = 0x3
	// Bit mask of BS3 field.
	GPIO_BSRR_BS3_Msk = 0x8
	// Bit BS3.
	GPIO_BSRR_BS3 = 0x8
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS3_Set = 0x1
	// Position of BS4 field.
	GPIO_BSRR_BS4_Pos = 0x4
	// Bit mask of BS4 field.
	GPIO_BSRR_BS4_Msk = 0x10
	// Bit BS4.
	GPIO_BSRR_BS4 = 0x10
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS4_Set = 0x1
	// Position of BS5 field.
	GPIO_BSRR_BS5_Pos = 0x5
	// Bit mask of BS5 field.
	GPIO_BSRR_BS5_Msk = 0x20
	// Bit BS5.
	GPIO_BSRR_BS5 = 0x20
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS5_Set = 0x1
	// Position of BS6 field.
	GPIO_BSRR_BS6_Pos = 0x6
	// Bit mask of BS6 field.
	GPIO_BSRR_BS6_Msk = 0x40
	// Bit BS6.
	GPIO_BSRR_BS6 = 0x40
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS6_Set = 0x1
	// Position of BS7 field.
	GPIO_BSRR_BS7_Pos = 0x7
	// Bit mask of BS7 field.
	GPIO_BSRR_BS7_Msk = 0x80
	// Bit BS7.
	GPIO_BSRR_BS7 = 0x80
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS7_Set = 0x1
	// Position of BS8 field.
	GPIO_BSRR_BS8_Pos = 0x8
	// Bit mask of BS8 field.
	GPIO_BSRR_BS8_Msk = 0x100
	// Bit BS8.
	GPIO_BSRR_BS8 = 0x100
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS8_Set = 0x1
	// Position of BS9 field.
	GPIO_BSRR_BS9_Pos = 0x9
	// Bit mask of BS9 field.
	GPIO_BSRR_BS9_Msk = 0x200
	// Bit BS9.
	GPIO_BSRR_BS9 = 0x200
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS9_Set = 0x1
	// Position of BS10 field.
	GPIO_BSRR_BS10_Pos = 0xa
	// Bit mask of BS10 field.
	GPIO_BSRR_BS10_Msk = 0x400
	// Bit BS10.
	GPIO_BSRR_BS10 = 0x400
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS10_Set = 0x1
	// Position of BS11 field.
	GPIO_BSRR_BS11_Pos = 0xb
	// Bit mask of BS11 field.
	GPIO_BSRR_BS11_Msk = 0x800
	// Bit BS11.
	GPIO_BSRR_BS11 = 0x800
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS11_Set = 0x1
	// Position of BS12 field.
	GPIO_BSRR_BS12_Pos = 0xc
	// Bit mask of BS12 field.
	GPIO_BSRR_BS12_Msk = 0x1000
	// Bit BS12.
	GPIO_BSRR_BS12 = 0x1000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS12_Set = 0x1
	// Position of BS13 field.
	GPIO_BSRR_BS13_Pos = 0xd
	// Bit mask of BS13 field.
	GPIO_BSRR_BS13_Msk = 0x2000
	// Bit BS13.
	GPIO_BSRR_BS13 = 0x2000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS13_Set = 0x1
	// Position of BS14 field.
	GPIO_BSRR_BS14_Pos = 0xe
	// Bit mask of BS14 field.
	GPIO_BSRR_BS14_Msk = 0x4000
	// Bit BS14.
	GPIO_BSRR_BS14 = 0x4000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS14_Set = 0x1
	// Position of BS15 field.
	GPIO_BSRR_BS15_Pos = 0xf
	// Bit mask of BS15 field.
	GPIO_BSRR_BS15_Msk = 0x8000
	// Bit BS15.
	GPIO_BSRR_BS15 = 0x8000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS15_Set = 0x1
	// Position of BR0 field.
	GPIO_BSRR_BR0_Pos = 0x10
	// Bit mask of BR0 field.
	GPIO_BSRR_BR0_Msk = 0x10000
	// Bit BR0.
	GPIO_BSRR_BR0 = 0x10000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR0_Reset = 0x1
	// Position of BR1 field.
	GPIO_BSRR_BR1_Pos = 0x11
	// Bit mask of BR1 field.
	GPIO_BSRR_BR1_Msk = 0x20000
	// Bit BR1.
	GPIO_BSRR_BR1 = 0x20000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR1_Reset = 0x1
	// Position of BR2 field.
	GPIO_BSRR_BR2_Pos = 0x12
	// Bit mask of BR2 field.
	GPIO_BSRR_BR2_Msk = 0x40000
	// Bit BR2.
	GPIO_BSRR_BR2 = 0x40000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR2_Reset = 0x1
	// Position of BR3 field.
	GPIO_BSRR_BR3_Pos = 0x13
	// Bit mask of BR3 field.
	GPIO_BSRR_BR3_Msk = 0x80000
	// Bit BR3.
	GPIO_BSRR_BR3 = 0x80000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR3_Reset = 0x1
	// Position of BR4 field.
	GPIO_BSRR_BR4_Pos = 0x14
	// Bit mask of BR4 field.
	GPIO_BSRR_BR4_Msk = 0x100000
	// Bit BR4.
	GPIO_BSRR_BR4 = 0x100000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR4_Reset = 0x1
	// Position of BR5 field.
	GPIO_BSRR_BR5_Pos = 0x15
	// Bit mask of BR5 field.
	GPIO_BSRR_BR5_Msk = 0x200000
	// Bit BR5.
	GPIO_BSRR_BR5 = 0x200000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR5_Reset = 0x1
	// Position of BR6 field.
	GPIO_BSRR_BR6_Pos = 0x16
	// Bit mask of BR6 field.
	GPIO_BSRR_BR6_Msk = 0x400000
	// Bit BR6.
	GPIO_BSRR_BR6 = 0x400000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR6_Reset = 0x1
	// Position of BR7 field.
	GPIO_BSRR_BR7_Pos = 0x17
	// Bit mask of BR7 field.
	GPIO_BSRR_BR7_Msk = 0x800000
	// Bit BR7.
	GPIO_BSRR_BR7 = 0x800000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR7_Reset = 0x1
	// Position of BR8 field.
	GPIO_BSRR_BR8_Pos = 0x18
	// Bit mask of BR8 field.
	GPIO_BSRR_BR8_Msk = 0x1000000
	// Bit BR8.
	GPIO_BSRR_BR8 = 0x1000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR8_Reset = 0x1
	// Position of BR9 field.
	GPIO_BSRR_BR9_Pos = 0x19
	// Bit mask of BR9 field.
	GPIO_BSRR_BR9_Msk = 0x2000000
	// Bit BR9.
	GPIO_BSRR_BR9 = 0x2000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR9_Reset = 0x1
	// Position of BR10 field.
	GPIO_BSRR_BR10_Pos = 0x1a
	// Bit mask of BR10 field.
	GPIO_BSRR_BR10_Msk = 0x4000000
	// Bit BR10.
	GPIO_BSRR_BR10 = 0x4000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR10_Reset = 0x1
	// Position of BR11 field.
	GPIO_BSRR_BR11_Pos = 0x1b
	// Bit mask of BR11 field.
	GPIO_BSRR_BR11_Msk = 0x8000000
	// Bit BR11.
	GPIO_BSRR_BR11 = 0x8000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR11_Reset = 0x1
	// Position of BR12 field.
	GPIO_BSRR_BR12_Pos = 0x1c
	// Bit mask of BR12 field.
	GPIO_BSRR_BR12_Msk = 0x10000000
	// Bit BR12.
	GPIO_BSRR_BR12 = 0x10000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR12_Reset = 0x1
	// Position of BR13 field.
	GPIO_BSRR_BR13_Pos = 0x1d
	// Bit mask of BR13 field.
	GPIO_BSRR_BR13_Msk = 0x20000000
	// Bit BR13.
	GPIO_BSRR_BR13 = 0x20000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR13_Reset = 0x1
	// Position of BR14 field.
	GPIO_BSRR_BR14_Pos = 0x1e
	// Bit mask of BR14 field.
	GPIO_BSRR_BR14_Msk = 0x40000000
	// Bit BR14.
	GPIO_BSRR_BR14 = 0x40000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR14_Reset = 0x1
	// Position of BR15 field.
	GPIO_BSRR_BR15_Pos = 0x1f
	// Bit mask of BR15 field.
	GPIO_BSRR_BR15_Msk = 0x80000000
	// Bit BR15.
	GPIO_BSRR_BR15 = 0x80000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR15_Reset = 0x1

	// LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
	// Position of LCK0 field.
	GPIO_LCKR_LCK0_Pos = 0x0
	// Bit mask of LCK0 field.
	GPIO_LCKR_LCK0_Msk = 0x1
	// Bit LCK0.
	GPIO_LCKR_LCK0 = 0x1
	// Port configuration not locked
	GPIO_LCKR_LCK0_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK0_Locked = 0x1
	// Position of LCK1 field.
	GPIO_LCKR_LCK1_Pos = 0x1
	// Bit mask of LCK1 field.
	GPIO_LCKR_LCK1_Msk = 0x2
	// Bit LCK1.
	GPIO_LCKR_LCK1 = 0x2
	// Port configuration not locked
	GPIO_LCKR_LCK1_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK1_Locked = 0x1
	// Position of LCK2 field.
	GPIO_LCKR_LCK2_Pos = 0x2
	// Bit mask of LCK2 field.
	GPIO_LCKR_LCK2_Msk = 0x4
	// Bit LCK2.
	GPIO_LCKR_LCK2 = 0x4
	// Port configuration not locked
	GPIO_LCKR_LCK2_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK2_Locked = 0x1
	// Position of LCK3 field.
	GPIO_LCKR_LCK3_Pos = 0x3
	// Bit mask of LCK3 field.
	GPIO_LCKR_LCK3_Msk = 0x8
	// Bit LCK3.
	GPIO_LCKR_LCK3 = 0x8
	// Port configuration not locked
	GPIO_LCKR_LCK3_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK3_Locked = 0x1
	// Position of LCK4 field.
	GPIO_LCKR_LCK4_Pos = 0x4
	// Bit mask of LCK4 field.
	GPIO_LCKR_LCK4_Msk = 0x10
	// Bit LCK4.
	GPIO_LCKR_LCK4 = 0x10
	// Port configuration not locked
	GPIO_LCKR_LCK4_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK4_Locked = 0x1
	// Position of LCK5 field.
	GPIO_LCKR_LCK5_Pos = 0x5
	// Bit mask of LCK5 field.
	GPIO_LCKR_LCK5_Msk = 0x20
	// Bit LCK5.
	GPIO_LCKR_LCK5 = 0x20
	// Port configuration not locked
	GPIO_LCKR_LCK5_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK5_Locked = 0x1
	// Position of LCK6 field.
	GPIO_LCKR_LCK6_Pos = 0x6
	// Bit mask of LCK6 field.
	GPIO_LCKR_LCK6_Msk = 0x40
	// Bit LCK6.
	GPIO_LCKR_LCK6 = 0x40
	// Port configuration not locked
	GPIO_LCKR_LCK6_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK6_Locked = 0x1
	// Position of LCK7 field.
	GPIO_LCKR_LCK7_Pos = 0x7
	// Bit mask of LCK7 field.
	GPIO_LCKR_LCK7_Msk = 0x80
	// Bit LCK7.
	GPIO_LCKR_LCK7 = 0x80
	// Port configuration not locked
	GPIO_LCKR_LCK7_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK7_Locked = 0x1
	// Position of LCK8 field.
	GPIO_LCKR_LCK8_Pos = 0x8
	// Bit mask of LCK8 field.
	GPIO_LCKR_LCK8_Msk = 0x100
	// Bit LCK8.
	GPIO_LCKR_LCK8 = 0x100
	// Port configuration not locked
	GPIO_LCKR_LCK8_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK8_Locked = 0x1
	// Position of LCK9 field.
	GPIO_LCKR_LCK9_Pos = 0x9
	// Bit mask of LCK9 field.
	GPIO_LCKR_LCK9_Msk = 0x200
	// Bit LCK9.
	GPIO_LCKR_LCK9 = 0x200
	// Port configuration not locked
	GPIO_LCKR_LCK9_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK9_Locked = 0x1
	// Position of LCK10 field.
	GPIO_LCKR_LCK10_Pos = 0xa
	// Bit mask of LCK10 field.
	GPIO_LCKR_LCK10_Msk = 0x400
	// Bit LCK10.
	GPIO_LCKR_LCK10 = 0x400
	// Port configuration not locked
	GPIO_LCKR_LCK10_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK10_Locked = 0x1
	// Position of LCK11 field.
	GPIO_LCKR_LCK11_Pos = 0xb
	// Bit mask of LCK11 field.
	GPIO_LCKR_LCK11_Msk = 0x800
	// Bit LCK11.
	GPIO_LCKR_LCK11 = 0x800
	// Port configuration not locked
	GPIO_LCKR_LCK11_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK11_Locked = 0x1
	// Position of LCK12 field.
	GPIO_LCKR_LCK12_Pos = 0xc
	// Bit mask of LCK12 field.
	GPIO_LCKR_LCK12_Msk = 0x1000
	// Bit LCK12.
	GPIO_LCKR_LCK12 = 0x1000
	// Port configuration not locked
	GPIO_LCKR_LCK12_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK12_Locked = 0x1
	// Position of LCK13 field.
	GPIO_LCKR_LCK13_Pos = 0xd
	// Bit mask of LCK13 field.
	GPIO_LCKR_LCK13_Msk = 0x2000
	// Bit LCK13.
	GPIO_LCKR_LCK13 = 0x2000
	// Port configuration not locked
	GPIO_LCKR_LCK13_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK13_Locked = 0x1
	// Position of LCK14 field.
	GPIO_LCKR_LCK14_Pos = 0xe
	// Bit mask of LCK14 field.
	GPIO_LCKR_LCK14_Msk = 0x4000
	// Bit LCK14.
	GPIO_LCKR_LCK14 = 0x4000
	// Port configuration not locked
	GPIO_LCKR_LCK14_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK14_Locked = 0x1
	// Position of LCK15 field.
	GPIO_LCKR_LCK15_Pos = 0xf
	// Bit mask of LCK15 field.
	GPIO_LCKR_LCK15_Msk = 0x8000
	// Bit LCK15.
	GPIO_LCKR_LCK15 = 0x8000
	// Port configuration not locked
	GPIO_LCKR_LCK15_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK15_Locked = 0x1
	// Position of LCKK field.
	GPIO_LCKR_LCKK_Pos = 0x10
	// Bit mask of LCKK field.
	GPIO_LCKR_LCKK_Msk = 0x10000
	// Bit LCKK.
	GPIO_LCKR_LCKK = 0x10000
	// Port configuration lock key not active
	GPIO_LCKR_LCKK_NotActive = 0x0
	// Port configuration lock key active
	GPIO_LCKR_LCKK_Active = 0x1

	// AFRL: GPIO alternate function low register
	// Position of AFR0 field.
	GPIO_AFRL_AFR0_Pos = 0x0
	// Bit mask of AFR0 field.
	GPIO_AFRL_AFR0_Msk = 0xf
	// AF0
	GPIO_AFRL_AFR0_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR0_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR0_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR0_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR0_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR0_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR0_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR0_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR0_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR0_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR0_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR0_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR0_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR0_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR0_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR0_AF15 = 0xf
	// Position of AFR1 field.
	GPIO_AFRL_AFR1_Pos = 0x4
	// Bit mask of AFR1 field.
	GPIO_AFRL_AFR1_Msk = 0xf0
	// AF0
	GPIO_AFRL_AFR1_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR1_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR1_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR1_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR1_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR1_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR1_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR1_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR1_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR1_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR1_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR1_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR1_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR1_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR1_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR1_AF15 = 0xf
	// Position of AFR2 field.
	GPIO_AFRL_AFR2_Pos = 0x8
	// Bit mask of AFR2 field.
	GPIO_AFRL_AFR2_Msk = 0xf00
	// AF0
	GPIO_AFRL_AFR2_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR2_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR2_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR2_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR2_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR2_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR2_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR2_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR2_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR2_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR2_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR2_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR2_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR2_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR2_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR2_AF15 = 0xf
	// Position of AFR3 field.
	GPIO_AFRL_AFR3_Pos = 0xc
	// Bit mask of AFR3 field.
	GPIO_AFRL_AFR3_Msk = 0xf000
	// AF0
	GPIO_AFRL_AFR3_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR3_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR3_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR3_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR3_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR3_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR3_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR3_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR3_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR3_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR3_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR3_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR3_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR3_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR3_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR3_AF15 = 0xf
	// Position of AFR4 field.
	GPIO_AFRL_AFR4_Pos = 0x10
	// Bit mask of AFR4 field.
	GPIO_AFRL_AFR4_Msk = 0xf0000
	// AF0
	GPIO_AFRL_AFR4_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR4_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR4_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR4_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR4_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR4_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR4_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR4_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR4_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR4_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR4_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR4_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR4_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR4_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR4_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR4_AF15 = 0xf
	// Position of AFR5 field.
	GPIO_AFRL_AFR5_Pos = 0x14
	// Bit mask of AFR5 field.
	GPIO_AFRL_AFR5_Msk = 0xf00000
	// AF0
	GPIO_AFRL_AFR5_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR5_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR5_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR5_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR5_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR5_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR5_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR5_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR5_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR5_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR5_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR5_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR5_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR5_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR5_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR5_AF15 = 0xf
	// Position of AFR6 field.
	GPIO_AFRL_AFR6_Pos = 0x18
	// Bit mask of AFR6 field.
	GPIO_AFRL_AFR6_Msk = 0xf000000
	// AF0
	GPIO_AFRL_AFR6_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR6_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR6_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR6_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR6_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR6_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR6_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR6_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR6_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR6_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR6_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR6_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR6_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR6_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR6_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR6_AF15 = 0xf
	// Position of AFR7 field.
	GPIO_AFRL_AFR7_Pos = 0x1c
	// Bit mask of AFR7 field.
	GPIO_AFRL_AFR7_Msk = 0xf0000000
	// AF0
	GPIO_AFRL_AFR7_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFR7_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFR7_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFR7_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFR7_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFR7_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFR7_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFR7_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFR7_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFR7_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFR7_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFR7_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFR7_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFR7_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFR7_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFR7_AF15 = 0xf

	// AFRH: GPIO alternate function high register
	// Position of AFR8 field.
	GPIO_AFRH_AFR8_Pos = 0x0
	// Bit mask of AFR8 field.
	GPIO_AFRH_AFR8_Msk = 0xf
	// AF0
	GPIO_AFRH_AFR8_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR8_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR8_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR8_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR8_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR8_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR8_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR8_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR8_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR8_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR8_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR8_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR8_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR8_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR8_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR8_AF15 = 0xf
	// Position of AFR9 field.
	GPIO_AFRH_AFR9_Pos = 0x4
	// Bit mask of AFR9 field.
	GPIO_AFRH_AFR9_Msk = 0xf0
	// AF0
	GPIO_AFRH_AFR9_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR9_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR9_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR9_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR9_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR9_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR9_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR9_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR9_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR9_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR9_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR9_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR9_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR9_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR9_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR9_AF15 = 0xf
	// Position of AFR10 field.
	GPIO_AFRH_AFR10_Pos = 0x8
	// Bit mask of AFR10 field.
	GPIO_AFRH_AFR10_Msk = 0xf00
	// AF0
	GPIO_AFRH_AFR10_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR10_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR10_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR10_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR10_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR10_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR10_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR10_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR10_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR10_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR10_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR10_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR10_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR10_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR10_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR10_AF15 = 0xf
	// Position of AFR11 field.
	GPIO_AFRH_AFR11_Pos = 0xc
	// Bit mask of AFR11 field.
	GPIO_AFRH_AFR11_Msk = 0xf000
	// AF0
	GPIO_AFRH_AFR11_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR11_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR11_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR11_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR11_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR11_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR11_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR11_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR11_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR11_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR11_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR11_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR11_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR11_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR11_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR11_AF15 = 0xf
	// Position of AFR12 field.
	GPIO_AFRH_AFR12_Pos = 0x10
	// Bit mask of AFR12 field.
	GPIO_AFRH_AFR12_Msk = 0xf0000
	// AF0
	GPIO_AFRH_AFR12_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR12_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR12_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR12_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR12_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR12_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR12_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR12_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR12_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR12_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR12_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR12_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR12_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR12_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR12_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR12_AF15 = 0xf
	// Position of AFR13 field.
	GPIO_AFRH_AFR13_Pos = 0x14
	// Bit mask of AFR13 field.
	GPIO_AFRH_AFR13_Msk = 0xf00000
	// AF0
	GPIO_AFRH_AFR13_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR13_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR13_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR13_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR13_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR13_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR13_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR13_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR13_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR13_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR13_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR13_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR13_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR13_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR13_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR13_AF15 = 0xf
	// Position of AFR14 field.
	GPIO_AFRH_AFR14_Pos = 0x18
	// Bit mask of AFR14 field.
	GPIO_AFRH_AFR14_Msk = 0xf000000
	// AF0
	GPIO_AFRH_AFR14_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR14_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR14_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR14_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR14_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR14_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR14_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR14_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR14_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR14_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR14_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR14_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR14_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR14_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR14_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR14_AF15 = 0xf
	// Position of AFR15 field.
	GPIO_AFRH_AFR15_Pos = 0x1c
	// Bit mask of AFR15 field.
	GPIO_AFRH_AFR15_Msk = 0xf0000000
	// AF0
	GPIO_AFRH_AFR15_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFR15_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFR15_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFR15_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFR15_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFR15_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFR15_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFR15_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFR15_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFR15_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFR15_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFR15_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFR15_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFR15_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFR15_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFR15_AF15 = 0xf
)

// Constants for HSEM: HSEM
const (
	// R0: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R0_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R0_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R0_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R0_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R0_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R0_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R0_LOCK = 0x80000000

	// R1: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R1_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R1_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R1_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R1_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R1_LOCK = 0x80000000

	// R2: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R2_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R2_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R2_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R2_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R2_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R2_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R2_LOCK = 0x80000000

	// R3: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R3_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R3_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R3_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R3_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R3_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R3_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R3_LOCK = 0x80000000

	// R4: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R4_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R4_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R4_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R4_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R4_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R4_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R4_LOCK = 0x80000000

	// R5: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R5_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R5_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R5_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R5_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R5_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R5_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R5_LOCK = 0x80000000

	// R6: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R6_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R6_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R6_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R6_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R6_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R6_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R6_LOCK = 0x80000000

	// R7: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R7_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R7_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R7_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R7_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R7_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R7_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R7_LOCK = 0x80000000

	// R8: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R8_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R8_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R8_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R8_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R8_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R8_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R8_LOCK = 0x80000000

	// R9: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R9_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R9_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R9_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R9_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R9_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R9_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R9_LOCK = 0x80000000

	// R10: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R10_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R10_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R10_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R10_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R10_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R10_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R10_LOCK = 0x80000000

	// R11: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R11_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R11_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R11_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R11_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R11_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R11_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R11_LOCK = 0x80000000

	// R12: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R12_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R12_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R12_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R12_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R12_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R12_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R12_LOCK = 0x80000000

	// R13: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R13_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R13_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R13_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R13_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R13_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R13_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R13_LOCK = 0x80000000

	// R14: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R14_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R14_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R14_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R14_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R14_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R14_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R14_LOCK = 0x80000000

	// R15: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R15_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R15_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R15_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R15_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R15_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R15_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R15_LOCK = 0x80000000

	// R16: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R16_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R16_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R16_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R16_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R16_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R16_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R16_LOCK = 0x80000000

	// R17: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R17_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R17_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R17_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R17_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R17_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R17_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R17_LOCK = 0x80000000

	// R18: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R18_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R18_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R18_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R18_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R18_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R18_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R18_LOCK = 0x80000000

	// R19: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R19_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R19_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R19_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R19_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R19_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R19_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R19_LOCK = 0x80000000

	// R20: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R20_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R20_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R20_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R20_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R20_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R20_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R20_LOCK = 0x80000000

	// R21: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R21_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R21_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R21_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R21_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R21_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R21_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R21_LOCK = 0x80000000

	// R22: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R22_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R22_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R22_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R22_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R22_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R22_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R22_LOCK = 0x80000000

	// R23: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R23_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R23_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R23_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R23_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R23_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R23_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R23_LOCK = 0x80000000

	// R24: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R24_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R24_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R24_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R24_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R24_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R24_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R24_LOCK = 0x80000000

	// R25: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R25_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R25_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R25_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R25_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R25_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R25_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R25_LOCK = 0x80000000

	// R26: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R26_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R26_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R26_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R26_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R26_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R26_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R26_LOCK = 0x80000000

	// R27: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R27_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R27_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R27_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R27_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R27_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R27_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R27_LOCK = 0x80000000

	// R28: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R28_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R28_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R28_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R28_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R28_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R28_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R28_LOCK = 0x80000000

	// R29: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R29_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R29_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R29_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R29_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R29_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R29_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R29_LOCK = 0x80000000

	// R30: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R30_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R30_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R30_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R30_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R30_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R30_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R30_LOCK = 0x80000000

	// R31: HSEM register HSEM_R0 HSEM_R31
	// Position of PROCID field.
	HSEM_R31_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_R31_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_R31_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_R31_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_R31_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_R31_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_R31_LOCK = 0x80000000

	// RLR0: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR0_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR0_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR0_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR0_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR0_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR0_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR0_LOCK = 0x80000000

	// RLR1: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR1_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR1_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR1_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR1_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR1_LOCK = 0x80000000

	// RLR2: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR2_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR2_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR2_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR2_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR2_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR2_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR2_LOCK = 0x80000000

	// RLR3: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR3_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR3_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR3_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR3_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR3_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR3_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR3_LOCK = 0x80000000

	// RLR4: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR4_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR4_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR4_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR4_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR4_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR4_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR4_LOCK = 0x80000000

	// RLR5: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR5_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR5_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR5_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR5_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR5_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR5_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR5_LOCK = 0x80000000

	// RLR6: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR6_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR6_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR6_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR6_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR6_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR6_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR6_LOCK = 0x80000000

	// RLR7: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR7_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR7_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR7_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR7_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR7_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR7_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR7_LOCK = 0x80000000

	// RLR8: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR8_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR8_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR8_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR8_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR8_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR8_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR8_LOCK = 0x80000000

	// RLR9: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR9_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR9_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR9_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR9_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR9_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR9_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR9_LOCK = 0x80000000

	// RLR10: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR10_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR10_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR10_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR10_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR10_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR10_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR10_LOCK = 0x80000000

	// RLR11: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR11_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR11_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR11_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR11_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR11_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR11_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR11_LOCK = 0x80000000

	// RLR12: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR12_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR12_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR12_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR12_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR12_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR12_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR12_LOCK = 0x80000000

	// RLR13: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR13_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR13_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR13_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR13_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR13_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR13_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR13_LOCK = 0x80000000

	// RLR14: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR14_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR14_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR14_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR14_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR14_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR14_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR14_LOCK = 0x80000000

	// RLR15: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR15_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR15_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR15_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR15_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR15_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR15_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR15_LOCK = 0x80000000

	// RLR16: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR16_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR16_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR16_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR16_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR16_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR16_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR16_LOCK = 0x80000000

	// RLR17: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR17_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR17_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR17_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR17_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR17_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR17_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR17_LOCK = 0x80000000

	// RLR18: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR18_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR18_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR18_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR18_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR18_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR18_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR18_LOCK = 0x80000000

	// RLR19: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR19_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR19_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR19_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR19_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR19_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR19_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR19_LOCK = 0x80000000

	// RLR20: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR20_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR20_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR20_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR20_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR20_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR20_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR20_LOCK = 0x80000000

	// RLR21: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR21_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR21_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR21_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR21_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR21_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR21_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR21_LOCK = 0x80000000

	// RLR22: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR22_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR22_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR22_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR22_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR22_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR22_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR22_LOCK = 0x80000000

	// RLR23: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR23_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR23_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR23_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR23_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR23_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR23_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR23_LOCK = 0x80000000

	// RLR24: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR24_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR24_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR24_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR24_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR24_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR24_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR24_LOCK = 0x80000000

	// RLR25: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR25_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR25_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR25_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR25_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR25_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR25_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR25_LOCK = 0x80000000

	// RLR26: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR26_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR26_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR26_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR26_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR26_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR26_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR26_LOCK = 0x80000000

	// RLR27: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR27_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR27_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR27_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR27_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR27_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR27_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR27_LOCK = 0x80000000

	// RLR28: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR28_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR28_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR28_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR28_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR28_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR28_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR28_LOCK = 0x80000000

	// RLR29: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR29_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR29_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR29_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR29_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR29_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR29_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR29_LOCK = 0x80000000

	// RLR30: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR30_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR30_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR30_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR30_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR30_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR30_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR30_LOCK = 0x80000000

	// RLR31: HSEM Read lock register
	// Position of PROCID field.
	HSEM_RLR31_PROCID_Pos = 0x0
	// Bit mask of PROCID field.
	HSEM_RLR31_PROCID_Msk = 0xff
	// Position of MASTERID field.
	HSEM_RLR31_MASTERID_Pos = 0x8
	// Bit mask of MASTERID field.
	HSEM_RLR31_MASTERID_Msk = 0xff00
	// Position of LOCK field.
	HSEM_RLR31_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	HSEM_RLR31_LOCK_Msk = 0x80000000
	// Bit LOCK.
	HSEM_RLR31_LOCK = 0x80000000

	// C1IER: HSEM Interrupt enable register
	// Position of ISEM0 field.
	HSEM_C1IER_ISEM0_Pos = 0x0
	// Bit mask of ISEM0 field.
	HSEM_C1IER_ISEM0_Msk = 0x1
	// Bit ISEM0.
	HSEM_C1IER_ISEM0 = 0x1
	// Position of ISEM1 field.
	HSEM_C1IER_ISEM1_Pos = 0x1
	// Bit mask of ISEM1 field.
	HSEM_C1IER_ISEM1_Msk = 0x2
	// Bit ISEM1.
	HSEM_C1IER_ISEM1 = 0x2
	// Position of ISEM2 field.
	HSEM_C1IER_ISEM2_Pos = 0x2
	// Bit mask of ISEM2 field.
	HSEM_C1IER_ISEM2_Msk = 0x4
	// Bit ISEM2.
	HSEM_C1IER_ISEM2 = 0x4
	// Position of ISEM3 field.
	HSEM_C1IER_ISEM3_Pos = 0x3
	// Bit mask of ISEM3 field.
	HSEM_C1IER_ISEM3_Msk = 0x8
	// Bit ISEM3.
	HSEM_C1IER_ISEM3 = 0x8
	// Position of ISEM4 field.
	HSEM_C1IER_ISEM4_Pos = 0x4
	// Bit mask of ISEM4 field.
	HSEM_C1IER_ISEM4_Msk = 0x10
	// Bit ISEM4.
	HSEM_C1IER_ISEM4 = 0x10
	// Position of ISEM5 field.
	HSEM_C1IER_ISEM5_Pos = 0x5
	// Bit mask of ISEM5 field.
	HSEM_C1IER_ISEM5_Msk = 0x20
	// Bit ISEM5.
	HSEM_C1IER_ISEM5 = 0x20
	// Position of ISEM6 field.
	HSEM_C1IER_ISEM6_Pos = 0x6
	// Bit mask of ISEM6 field.
	HSEM_C1IER_ISEM6_Msk = 0x40
	// Bit ISEM6.
	HSEM_C1IER_ISEM6 = 0x40
	// Position of ISEM7 field.
	HSEM_C1IER_ISEM7_Pos = 0x7
	// Bit mask of ISEM7 field.
	HSEM_C1IER_ISEM7_Msk = 0x80
	// Bit ISEM7.
	HSEM_C1IER_ISEM7 = 0x80
	// Position of ISEM8 field.
	HSEM_C1IER_ISEM8_Pos = 0x8
	// Bit mask of ISEM8 field.
	HSEM_C1IER_ISEM8_Msk = 0x100
	// Bit ISEM8.
	HSEM_C1IER_ISEM8 = 0x100
	// Position of ISEM9 field.
	HSEM_C1IER_ISEM9_Pos = 0x9
	// Bit mask of ISEM9 field.
	HSEM_C1IER_ISEM9_Msk = 0x200
	// Bit ISEM9.
	HSEM_C1IER_ISEM9 = 0x200
	// Position of ISEM10 field.
	HSEM_C1IER_ISEM10_Pos = 0xa
	// Bit mask of ISEM10 field.
	HSEM_C1IER_ISEM10_Msk = 0x400
	// Bit ISEM10.
	HSEM_C1IER_ISEM10 = 0x400
	// Position of ISEM11 field.
	HSEM_C1IER_ISEM11_Pos = 0xb
	// Bit mask of ISEM11 field.
	HSEM_C1IER_ISEM11_Msk = 0x800
	// Bit ISEM11.
	HSEM_C1IER_ISEM11 = 0x800
	// Position of ISEM12 field.
	HSEM_C1IER_ISEM12_Pos = 0xc
	// Bit mask of ISEM12 field.
	HSEM_C1IER_ISEM12_Msk = 0x1000
	// Bit ISEM12.
	HSEM_C1IER_ISEM12 = 0x1000
	// Position of ISEM13 field.
	HSEM_C1IER_ISEM13_Pos = 0xd
	// Bit mask of ISEM13 field.
	HSEM_C1IER_ISEM13_Msk = 0x2000
	// Bit ISEM13.
	HSEM_C1IER_ISEM13 = 0x2000
	// Position of ISEM14 field.
	HSEM_C1IER_ISEM14_Pos = 0xe
	// Bit mask of ISEM14 field.
	HSEM_C1IER_ISEM14_Msk = 0x4000
	// Bit ISEM14.
	HSEM_C1IER_ISEM14 = 0x4000
	// Position of ISEM15 field.
	HSEM_C1IER_ISEM15_Pos = 0xf
	// Bit mask of ISEM15 field.
	HSEM_C1IER_ISEM15_Msk = 0x8000
	// Bit ISEM15.
	HSEM_C1IER_ISEM15 = 0x8000
	// Position of ISEM16 field.
	HSEM_C1IER_ISEM16_Pos = 0x10
	// Bit mask of ISEM16 field.
	HSEM_C1IER_ISEM16_Msk = 0x10000
	// Bit ISEM16.
	HSEM_C1IER_ISEM16 = 0x10000
	// Position of ISEM17 field.
	HSEM_C1IER_ISEM17_Pos = 0x11
	// Bit mask of ISEM17 field.
	HSEM_C1IER_ISEM17_Msk = 0x20000
	// Bit ISEM17.
	HSEM_C1IER_ISEM17 = 0x20000
	// Position of ISEM18 field.
	HSEM_C1IER_ISEM18_Pos = 0x12
	// Bit mask of ISEM18 field.
	HSEM_C1IER_ISEM18_Msk = 0x40000
	// Bit ISEM18.
	HSEM_C1IER_ISEM18 = 0x40000
	// Position of ISEM19 field.
	HSEM_C1IER_ISEM19_Pos = 0x13
	// Bit mask of ISEM19 field.
	HSEM_C1IER_ISEM19_Msk = 0x80000
	// Bit ISEM19.
	HSEM_C1IER_ISEM19 = 0x80000
	// Position of ISEM20 field.
	HSEM_C1IER_ISEM20_Pos = 0x14
	// Bit mask of ISEM20 field.
	HSEM_C1IER_ISEM20_Msk = 0x100000
	// Bit ISEM20.
	HSEM_C1IER_ISEM20 = 0x100000
	// Position of ISEM21 field.
	HSEM_C1IER_ISEM21_Pos = 0x15
	// Bit mask of ISEM21 field.
	HSEM_C1IER_ISEM21_Msk = 0x200000
	// Bit ISEM21.
	HSEM_C1IER_ISEM21 = 0x200000
	// Position of ISEM22 field.
	HSEM_C1IER_ISEM22_Pos = 0x16
	// Bit mask of ISEM22 field.
	HSEM_C1IER_ISEM22_Msk = 0x400000
	// Bit ISEM22.
	HSEM_C1IER_ISEM22 = 0x400000
	// Position of ISEM23 field.
	HSEM_C1IER_ISEM23_Pos = 0x17
	// Bit mask of ISEM23 field.
	HSEM_C1IER_ISEM23_Msk = 0x800000
	// Bit ISEM23.
	HSEM_C1IER_ISEM23 = 0x800000
	// Position of ISEM24 field.
	HSEM_C1IER_ISEM24_Pos = 0x18
	// Bit mask of ISEM24 field.
	HSEM_C1IER_ISEM24_Msk = 0x1000000
	// Bit ISEM24.
	HSEM_C1IER_ISEM24 = 0x1000000
	// Position of ISEM25 field.
	HSEM_C1IER_ISEM25_Pos = 0x19
	// Bit mask of ISEM25 field.
	HSEM_C1IER_ISEM25_Msk = 0x2000000
	// Bit ISEM25.
	HSEM_C1IER_ISEM25 = 0x2000000
	// Position of ISEM26 field.
	HSEM_C1IER_ISEM26_Pos = 0x1a
	// Bit mask of ISEM26 field.
	HSEM_C1IER_ISEM26_Msk = 0x4000000
	// Bit ISEM26.
	HSEM_C1IER_ISEM26 = 0x4000000
	// Position of ISEM27 field.
	HSEM_C1IER_ISEM27_Pos = 0x1b
	// Bit mask of ISEM27 field.
	HSEM_C1IER_ISEM27_Msk = 0x8000000
	// Bit ISEM27.
	HSEM_C1IER_ISEM27 = 0x8000000
	// Position of ISEM28 field.
	HSEM_C1IER_ISEM28_Pos = 0x1c
	// Bit mask of ISEM28 field.
	HSEM_C1IER_ISEM28_Msk = 0x10000000
	// Bit ISEM28.
	HSEM_C1IER_ISEM28 = 0x10000000
	// Position of ISEM29 field.
	HSEM_C1IER_ISEM29_Pos = 0x1d
	// Bit mask of ISEM29 field.
	HSEM_C1IER_ISEM29_Msk = 0x20000000
	// Bit ISEM29.
	HSEM_C1IER_ISEM29 = 0x20000000
	// Position of ISEM30 field.
	HSEM_C1IER_ISEM30_Pos = 0x1e
	// Bit mask of ISEM30 field.
	HSEM_C1IER_ISEM30_Msk = 0x40000000
	// Bit ISEM30.
	HSEM_C1IER_ISEM30 = 0x40000000
	// Position of ISEM31 field.
	HSEM_C1IER_ISEM31_Pos = 0x1f
	// Bit mask of ISEM31 field.
	HSEM_C1IER_ISEM31_Msk = 0x80000000
	// Bit ISEM31.
	HSEM_C1IER_ISEM31 = 0x80000000

	// C1ICR: HSEM Interrupt clear register
	// Position of ISEM0 field.
	HSEM_C1ICR_ISEM0_Pos = 0x0
	// Bit mask of ISEM0 field.
	HSEM_C1ICR_ISEM0_Msk = 0x1
	// Bit ISEM0.
	HSEM_C1ICR_ISEM0 = 0x1
	// Position of ISEM1 field.
	HSEM_C1ICR_ISEM1_Pos = 0x1
	// Bit mask of ISEM1 field.
	HSEM_C1ICR_ISEM1_Msk = 0x2
	// Bit ISEM1.
	HSEM_C1ICR_ISEM1 = 0x2
	// Position of ISEM2 field.
	HSEM_C1ICR_ISEM2_Pos = 0x2
	// Bit mask of ISEM2 field.
	HSEM_C1ICR_ISEM2_Msk = 0x4
	// Bit ISEM2.
	HSEM_C1ICR_ISEM2 = 0x4
	// Position of ISEM3 field.
	HSEM_C1ICR_ISEM3_Pos = 0x3
	// Bit mask of ISEM3 field.
	HSEM_C1ICR_ISEM3_Msk = 0x8
	// Bit ISEM3.
	HSEM_C1ICR_ISEM3 = 0x8
	// Position of ISEM4 field.
	HSEM_C1ICR_ISEM4_Pos = 0x4
	// Bit mask of ISEM4 field.
	HSEM_C1ICR_ISEM4_Msk = 0x10
	// Bit ISEM4.
	HSEM_C1ICR_ISEM4 = 0x10
	// Position of ISEM5 field.
	HSEM_C1ICR_ISEM5_Pos = 0x5
	// Bit mask of ISEM5 field.
	HSEM_C1ICR_ISEM5_Msk = 0x20
	// Bit ISEM5.
	HSEM_C1ICR_ISEM5 = 0x20
	// Position of ISEM6 field.
	HSEM_C1ICR_ISEM6_Pos = 0x6
	// Bit mask of ISEM6 field.
	HSEM_C1ICR_ISEM6_Msk = 0x40
	// Bit ISEM6.
	HSEM_C1ICR_ISEM6 = 0x40
	// Position of ISEM7 field.
	HSEM_C1ICR_ISEM7_Pos = 0x7
	// Bit mask of ISEM7 field.
	HSEM_C1ICR_ISEM7_Msk = 0x80
	// Bit ISEM7.
	HSEM_C1ICR_ISEM7 = 0x80
	// Position of ISEM8 field.
	HSEM_C1ICR_ISEM8_Pos = 0x8
	// Bit mask of ISEM8 field.
	HSEM_C1ICR_ISEM8_Msk = 0x100
	// Bit ISEM8.
	HSEM_C1ICR_ISEM8 = 0x100
	// Position of ISEM9 field.
	HSEM_C1ICR_ISEM9_Pos = 0x9
	// Bit mask of ISEM9 field.
	HSEM_C1ICR_ISEM9_Msk = 0x200
	// Bit ISEM9.
	HSEM_C1ICR_ISEM9 = 0x200
	// Position of ISEM10 field.
	HSEM_C1ICR_ISEM10_Pos = 0xa
	// Bit mask of ISEM10 field.
	HSEM_C1ICR_ISEM10_Msk = 0x400
	// Bit ISEM10.
	HSEM_C1ICR_ISEM10 = 0x400
	// Position of ISEM11 field.
	HSEM_C1ICR_ISEM11_Pos = 0xb
	// Bit mask of ISEM11 field.
	HSEM_C1ICR_ISEM11_Msk = 0x800
	// Bit ISEM11.
	HSEM_C1ICR_ISEM11 = 0x800
	// Position of ISEM12 field.
	HSEM_C1ICR_ISEM12_Pos = 0xc
	// Bit mask of ISEM12 field.
	HSEM_C1ICR_ISEM12_Msk = 0x1000
	// Bit ISEM12.
	HSEM_C1ICR_ISEM12 = 0x1000
	// Position of ISEM13 field.
	HSEM_C1ICR_ISEM13_Pos = 0xd
	// Bit mask of ISEM13 field.
	HSEM_C1ICR_ISEM13_Msk = 0x2000
	// Bit ISEM13.
	HSEM_C1ICR_ISEM13 = 0x2000
	// Position of ISEM14 field.
	HSEM_C1ICR_ISEM14_Pos = 0xe
	// Bit mask of ISEM14 field.
	HSEM_C1ICR_ISEM14_Msk = 0x4000
	// Bit ISEM14.
	HSEM_C1ICR_ISEM14 = 0x4000
	// Position of ISEM15 field.
	HSEM_C1ICR_ISEM15_Pos = 0xf
	// Bit mask of ISEM15 field.
	HSEM_C1ICR_ISEM15_Msk = 0x8000
	// Bit ISEM15.
	HSEM_C1ICR_ISEM15 = 0x8000
	// Position of ISEM16 field.
	HSEM_C1ICR_ISEM16_Pos = 0x10
	// Bit mask of ISEM16 field.
	HSEM_C1ICR_ISEM16_Msk = 0x10000
	// Bit ISEM16.
	HSEM_C1ICR_ISEM16 = 0x10000
	// Position of ISEM17 field.
	HSEM_C1ICR_ISEM17_Pos = 0x11
	// Bit mask of ISEM17 field.
	HSEM_C1ICR_ISEM17_Msk = 0x20000
	// Bit ISEM17.
	HSEM_C1ICR_ISEM17 = 0x20000
	// Position of ISEM18 field.
	HSEM_C1ICR_ISEM18_Pos = 0x12
	// Bit mask of ISEM18 field.
	HSEM_C1ICR_ISEM18_Msk = 0x40000
	// Bit ISEM18.
	HSEM_C1ICR_ISEM18 = 0x40000
	// Position of ISEM19 field.
	HSEM_C1ICR_ISEM19_Pos = 0x13
	// Bit mask of ISEM19 field.
	HSEM_C1ICR_ISEM19_Msk = 0x80000
	// Bit ISEM19.
	HSEM_C1ICR_ISEM19 = 0x80000
	// Position of ISEM20 field.
	HSEM_C1ICR_ISEM20_Pos = 0x14
	// Bit mask of ISEM20 field.
	HSEM_C1ICR_ISEM20_Msk = 0x100000
	// Bit ISEM20.
	HSEM_C1ICR_ISEM20 = 0x100000
	// Position of ISEM21 field.
	HSEM_C1ICR_ISEM21_Pos = 0x15
	// Bit mask of ISEM21 field.
	HSEM_C1ICR_ISEM21_Msk = 0x200000
	// Bit ISEM21.
	HSEM_C1ICR_ISEM21 = 0x200000
	// Position of ISEM22 field.
	HSEM_C1ICR_ISEM22_Pos = 0x16
	// Bit mask of ISEM22 field.
	HSEM_C1ICR_ISEM22_Msk = 0x400000
	// Bit ISEM22.
	HSEM_C1ICR_ISEM22 = 0x400000
	// Position of ISEM23 field.
	HSEM_C1ICR_ISEM23_Pos = 0x17
	// Bit mask of ISEM23 field.
	HSEM_C1ICR_ISEM23_Msk = 0x800000
	// Bit ISEM23.
	HSEM_C1ICR_ISEM23 = 0x800000
	// Position of ISEM24 field.
	HSEM_C1ICR_ISEM24_Pos = 0x18
	// Bit mask of ISEM24 field.
	HSEM_C1ICR_ISEM24_Msk = 0x1000000
	// Bit ISEM24.
	HSEM_C1ICR_ISEM24 = 0x1000000
	// Position of ISEM25 field.
	HSEM_C1ICR_ISEM25_Pos = 0x19
	// Bit mask of ISEM25 field.
	HSEM_C1ICR_ISEM25_Msk = 0x2000000
	// Bit ISEM25.
	HSEM_C1ICR_ISEM25 = 0x2000000
	// Position of ISEM26 field.
	HSEM_C1ICR_ISEM26_Pos = 0x1a
	// Bit mask of ISEM26 field.
	HSEM_C1ICR_ISEM26_Msk = 0x4000000
	// Bit ISEM26.
	HSEM_C1ICR_ISEM26 = 0x4000000
	// Position of ISEM27 field.
	HSEM_C1ICR_ISEM27_Pos = 0x1b
	// Bit mask of ISEM27 field.
	HSEM_C1ICR_ISEM27_Msk = 0x8000000
	// Bit ISEM27.
	HSEM_C1ICR_ISEM27 = 0x8000000
	// Position of ISEM28 field.
	HSEM_C1ICR_ISEM28_Pos = 0x1c
	// Bit mask of ISEM28 field.
	HSEM_C1ICR_ISEM28_Msk = 0x10000000
	// Bit ISEM28.
	HSEM_C1ICR_ISEM28 = 0x10000000
	// Position of ISEM29 field.
	HSEM_C1ICR_ISEM29_Pos = 0x1d
	// Bit mask of ISEM29 field.
	HSEM_C1ICR_ISEM29_Msk = 0x20000000
	// Bit ISEM29.
	HSEM_C1ICR_ISEM29 = 0x20000000
	// Position of ISEM30 field.
	HSEM_C1ICR_ISEM30_Pos = 0x1e
	// Bit mask of ISEM30 field.
	HSEM_C1ICR_ISEM30_Msk = 0x40000000
	// Bit ISEM30.
	HSEM_C1ICR_ISEM30 = 0x40000000
	// Position of ISEM31 field.
	HSEM_C1ICR_ISEM31_Pos = 0x1f
	// Bit mask of ISEM31 field.
	HSEM_C1ICR_ISEM31_Msk = 0x80000000
	// Bit ISEM31.
	HSEM_C1ICR_ISEM31 = 0x80000000

	// C1ISR: HSEM Interrupt status register
	// Position of ISEM0 field.
	HSEM_C1ISR_ISEM0_Pos = 0x0
	// Bit mask of ISEM0 field.
	HSEM_C1ISR_ISEM0_Msk = 0x1
	// Bit ISEM0.
	HSEM_C1ISR_ISEM0 = 0x1
	// Position of ISEM1 field.
	HSEM_C1ISR_ISEM1_Pos = 0x1
	// Bit mask of ISEM1 field.
	HSEM_C1ISR_ISEM1_Msk = 0x2
	// Bit ISEM1.
	HSEM_C1ISR_ISEM1 = 0x2
	// Position of ISEM2 field.
	HSEM_C1ISR_ISEM2_Pos = 0x2
	// Bit mask of ISEM2 field.
	HSEM_C1ISR_ISEM2_Msk = 0x4
	// Bit ISEM2.
	HSEM_C1ISR_ISEM2 = 0x4
	// Position of ISEM3 field.
	HSEM_C1ISR_ISEM3_Pos = 0x3
	// Bit mask of ISEM3 field.
	HSEM_C1ISR_ISEM3_Msk = 0x8
	// Bit ISEM3.
	HSEM_C1ISR_ISEM3 = 0x8
	// Position of ISEM4 field.
	HSEM_C1ISR_ISEM4_Pos = 0x4
	// Bit mask of ISEM4 field.
	HSEM_C1ISR_ISEM4_Msk = 0x10
	// Bit ISEM4.
	HSEM_C1ISR_ISEM4 = 0x10
	// Position of ISEM5 field.
	HSEM_C1ISR_ISEM5_Pos = 0x5
	// Bit mask of ISEM5 field.
	HSEM_C1ISR_ISEM5_Msk = 0x20
	// Bit ISEM5.
	HSEM_C1ISR_ISEM5 = 0x20
	// Position of ISEM6 field.
	HSEM_C1ISR_ISEM6_Pos = 0x6
	// Bit mask of ISEM6 field.
	HSEM_C1ISR_ISEM6_Msk = 0x40
	// Bit ISEM6.
	HSEM_C1ISR_ISEM6 = 0x40
	// Position of ISEM7 field.
	HSEM_C1ISR_ISEM7_Pos = 0x7
	// Bit mask of ISEM7 field.
	HSEM_C1ISR_ISEM7_Msk = 0x80
	// Bit ISEM7.
	HSEM_C1ISR_ISEM7 = 0x80
	// Position of ISEM8 field.
	HSEM_C1ISR_ISEM8_Pos = 0x8
	// Bit mask of ISEM8 field.
	HSEM_C1ISR_ISEM8_Msk = 0x100
	// Bit ISEM8.
	HSEM_C1ISR_ISEM8 = 0x100
	// Position of ISEM9 field.
	HSEM_C1ISR_ISEM9_Pos = 0x9
	// Bit mask of ISEM9 field.
	HSEM_C1ISR_ISEM9_Msk = 0x200
	// Bit ISEM9.
	HSEM_C1ISR_ISEM9 = 0x200
	// Position of ISEM10 field.
	HSEM_C1ISR_ISEM10_Pos = 0xa
	// Bit mask of ISEM10 field.
	HSEM_C1ISR_ISEM10_Msk = 0x400
	// Bit ISEM10.
	HSEM_C1ISR_ISEM10 = 0x400
	// Position of ISEM11 field.
	HSEM_C1ISR_ISEM11_Pos = 0xb
	// Bit mask of ISEM11 field.
	HSEM_C1ISR_ISEM11_Msk = 0x800
	// Bit ISEM11.
	HSEM_C1ISR_ISEM11 = 0x800
	// Position of ISEM12 field.
	HSEM_C1ISR_ISEM12_Pos = 0xc
	// Bit mask of ISEM12 field.
	HSEM_C1ISR_ISEM12_Msk = 0x1000
	// Bit ISEM12.
	HSEM_C1ISR_ISEM12 = 0x1000
	// Position of ISEM13 field.
	HSEM_C1ISR_ISEM13_Pos = 0xd
	// Bit mask of ISEM13 field.
	HSEM_C1ISR_ISEM13_Msk = 0x2000
	// Bit ISEM13.
	HSEM_C1ISR_ISEM13 = 0x2000
	// Position of ISEM14 field.
	HSEM_C1ISR_ISEM14_Pos = 0xe
	// Bit mask of ISEM14 field.
	HSEM_C1ISR_ISEM14_Msk = 0x4000
	// Bit ISEM14.
	HSEM_C1ISR_ISEM14 = 0x4000
	// Position of ISEM15 field.
	HSEM_C1ISR_ISEM15_Pos = 0xf
	// Bit mask of ISEM15 field.
	HSEM_C1ISR_ISEM15_Msk = 0x8000
	// Bit ISEM15.
	HSEM_C1ISR_ISEM15 = 0x8000
	// Position of ISEM16 field.
	HSEM_C1ISR_ISEM16_Pos = 0x10
	// Bit mask of ISEM16 field.
	HSEM_C1ISR_ISEM16_Msk = 0x10000
	// Bit ISEM16.
	HSEM_C1ISR_ISEM16 = 0x10000
	// Position of ISEM17 field.
	HSEM_C1ISR_ISEM17_Pos = 0x11
	// Bit mask of ISEM17 field.
	HSEM_C1ISR_ISEM17_Msk = 0x20000
	// Bit ISEM17.
	HSEM_C1ISR_ISEM17 = 0x20000
	// Position of ISEM18 field.
	HSEM_C1ISR_ISEM18_Pos = 0x12
	// Bit mask of ISEM18 field.
	HSEM_C1ISR_ISEM18_Msk = 0x40000
	// Bit ISEM18.
	HSEM_C1ISR_ISEM18 = 0x40000
	// Position of ISEM19 field.
	HSEM_C1ISR_ISEM19_Pos = 0x13
	// Bit mask of ISEM19 field.
	HSEM_C1ISR_ISEM19_Msk = 0x80000
	// Bit ISEM19.
	HSEM_C1ISR_ISEM19 = 0x80000
	// Position of ISEM20 field.
	HSEM_C1ISR_ISEM20_Pos = 0x14
	// Bit mask of ISEM20 field.
	HSEM_C1ISR_ISEM20_Msk = 0x100000
	// Bit ISEM20.
	HSEM_C1ISR_ISEM20 = 0x100000
	// Position of ISEM21 field.
	HSEM_C1ISR_ISEM21_Pos = 0x15
	// Bit mask of ISEM21 field.
	HSEM_C1ISR_ISEM21_Msk = 0x200000
	// Bit ISEM21.
	HSEM_C1ISR_ISEM21 = 0x200000
	// Position of ISEM22 field.
	HSEM_C1ISR_ISEM22_Pos = 0x16
	// Bit mask of ISEM22 field.
	HSEM_C1ISR_ISEM22_Msk = 0x400000
	// Bit ISEM22.
	HSEM_C1ISR_ISEM22 = 0x400000
	// Position of ISEM23 field.
	HSEM_C1ISR_ISEM23_Pos = 0x17
	// Bit mask of ISEM23 field.
	HSEM_C1ISR_ISEM23_Msk = 0x800000
	// Bit ISEM23.
	HSEM_C1ISR_ISEM23 = 0x800000
	// Position of ISEM24 field.
	HSEM_C1ISR_ISEM24_Pos = 0x18
	// Bit mask of ISEM24 field.
	HSEM_C1ISR_ISEM24_Msk = 0x1000000
	// Bit ISEM24.
	HSEM_C1ISR_ISEM24 = 0x1000000
	// Position of ISEM25 field.
	HSEM_C1ISR_ISEM25_Pos = 0x19
	// Bit mask of ISEM25 field.
	HSEM_C1ISR_ISEM25_Msk = 0x2000000
	// Bit ISEM25.
	HSEM_C1ISR_ISEM25 = 0x2000000
	// Position of ISEM26 field.
	HSEM_C1ISR_ISEM26_Pos = 0x1a
	// Bit mask of ISEM26 field.
	HSEM_C1ISR_ISEM26_Msk = 0x4000000
	// Bit ISEM26.
	HSEM_C1ISR_ISEM26 = 0x4000000
	// Position of ISEM27 field.
	HSEM_C1ISR_ISEM27_Pos = 0x1b
	// Bit mask of ISEM27 field.
	HSEM_C1ISR_ISEM27_Msk = 0x8000000
	// Bit ISEM27.
	HSEM_C1ISR_ISEM27 = 0x8000000
	// Position of ISEM28 field.
	HSEM_C1ISR_ISEM28_Pos = 0x1c
	// Bit mask of ISEM28 field.
	HSEM_C1ISR_ISEM28_Msk = 0x10000000
	// Bit ISEM28.
	HSEM_C1ISR_ISEM28 = 0x10000000
	// Position of ISEM29 field.
	HSEM_C1ISR_ISEM29_Pos = 0x1d
	// Bit mask of ISEM29 field.
	HSEM_C1ISR_ISEM29_Msk = 0x20000000
	// Bit ISEM29.
	HSEM_C1ISR_ISEM29 = 0x20000000
	// Position of ISEM30 field.
	HSEM_C1ISR_ISEM30_Pos = 0x1e
	// Bit mask of ISEM30 field.
	HSEM_C1ISR_ISEM30_Msk = 0x40000000
	// Bit ISEM30.
	HSEM_C1ISR_ISEM30 = 0x40000000
	// Position of ISEM31 field.
	HSEM_C1ISR_ISEM31_Pos = 0x1f
	// Bit mask of ISEM31 field.
	HSEM_C1ISR_ISEM31_Msk = 0x80000000
	// Bit ISEM31.
	HSEM_C1ISR_ISEM31 = 0x80000000

	// C1MISR: HSEM Masked interrupt status register
	// Position of ISEM0 field.
	HSEM_C1MISR_ISEM0_Pos = 0x0
	// Bit mask of ISEM0 field.
	HSEM_C1MISR_ISEM0_Msk = 0x1
	// Bit ISEM0.
	HSEM_C1MISR_ISEM0 = 0x1
	// Position of ISEM1 field.
	HSEM_C1MISR_ISEM1_Pos = 0x1
	// Bit mask of ISEM1 field.
	HSEM_C1MISR_ISEM1_Msk = 0x2
	// Bit ISEM1.
	HSEM_C1MISR_ISEM1 = 0x2
	// Position of ISEM2 field.
	HSEM_C1MISR_ISEM2_Pos = 0x2
	// Bit mask of ISEM2 field.
	HSEM_C1MISR_ISEM2_Msk = 0x4
	// Bit ISEM2.
	HSEM_C1MISR_ISEM2 = 0x4
	// Position of ISEM3 field.
	HSEM_C1MISR_ISEM3_Pos = 0x3
	// Bit mask of ISEM3 field.
	HSEM_C1MISR_ISEM3_Msk = 0x8
	// Bit ISEM3.
	HSEM_C1MISR_ISEM3 = 0x8
	// Position of ISEM4 field.
	HSEM_C1MISR_ISEM4_Pos = 0x4
	// Bit mask of ISEM4 field.
	HSEM_C1MISR_ISEM4_Msk = 0x10
	// Bit ISEM4.
	HSEM_C1MISR_ISEM4 = 0x10
	// Position of ISEM5 field.
	HSEM_C1MISR_ISEM5_Pos = 0x5
	// Bit mask of ISEM5 field.
	HSEM_C1MISR_ISEM5_Msk = 0x20
	// Bit ISEM5.
	HSEM_C1MISR_ISEM5 = 0x20
	// Position of ISEM6 field.
	HSEM_C1MISR_ISEM6_Pos = 0x6
	// Bit mask of ISEM6 field.
	HSEM_C1MISR_ISEM6_Msk = 0x40
	// Bit ISEM6.
	HSEM_C1MISR_ISEM6 = 0x40
	// Position of ISEM7 field.
	HSEM_C1MISR_ISEM7_Pos = 0x7
	// Bit mask of ISEM7 field.
	HSEM_C1MISR_ISEM7_Msk = 0x80
	// Bit ISEM7.
	HSEM_C1MISR_ISEM7 = 0x80
	// Position of ISEM8 field.
	HSEM_C1MISR_ISEM8_Pos = 0x8
	// Bit mask of ISEM8 field.
	HSEM_C1MISR_ISEM8_Msk = 0x100
	// Bit ISEM8.
	HSEM_C1MISR_ISEM8 = 0x100
	// Position of ISEM9 field.
	HSEM_C1MISR_ISEM9_Pos = 0x9
	// Bit mask of ISEM9 field.
	HSEM_C1MISR_ISEM9_Msk = 0x200
	// Bit ISEM9.
	HSEM_C1MISR_ISEM9 = 0x200
	// Position of ISEM10 field.
	HSEM_C1MISR_ISEM10_Pos = 0xa
	// Bit mask of ISEM10 field.
	HSEM_C1MISR_ISEM10_Msk = 0x400
	// Bit ISEM10.
	HSEM_C1MISR_ISEM10 = 0x400
	// Position of ISEM11 field.
	HSEM_C1MISR_ISEM11_Pos = 0xb
	// Bit mask of ISEM11 field.
	HSEM_C1MISR_ISEM11_Msk = 0x800
	// Bit ISEM11.
	HSEM_C1MISR_ISEM11 = 0x800
	// Position of ISEM12 field.
	HSEM_C1MISR_ISEM12_Pos = 0xc
	// Bit mask of ISEM12 field.
	HSEM_C1MISR_ISEM12_Msk = 0x1000
	// Bit ISEM12.
	HSEM_C1MISR_ISEM12 = 0x1000
	// Position of ISEM13 field.
	HSEM_C1MISR_ISEM13_Pos = 0xd
	// Bit mask of ISEM13 field.
	HSEM_C1MISR_ISEM13_Msk = 0x2000
	// Bit ISEM13.
	HSEM_C1MISR_ISEM13 = 0x2000
	// Position of ISEM14 field.
	HSEM_C1MISR_ISEM14_Pos = 0xe
	// Bit mask of ISEM14 field.
	HSEM_C1MISR_ISEM14_Msk = 0x4000
	// Bit ISEM14.
	HSEM_C1MISR_ISEM14 = 0x4000
	// Position of ISEM15 field.
	HSEM_C1MISR_ISEM15_Pos = 0xf
	// Bit mask of ISEM15 field.
	HSEM_C1MISR_ISEM15_Msk = 0x8000
	// Bit ISEM15.
	HSEM_C1MISR_ISEM15 = 0x8000
	// Position of ISEM16 field.
	HSEM_C1MISR_ISEM16_Pos = 0x10
	// Bit mask of ISEM16 field.
	HSEM_C1MISR_ISEM16_Msk = 0x10000
	// Bit ISEM16.
	HSEM_C1MISR_ISEM16 = 0x10000
	// Position of ISEM17 field.
	HSEM_C1MISR_ISEM17_Pos = 0x11
	// Bit mask of ISEM17 field.
	HSEM_C1MISR_ISEM17_Msk = 0x20000
	// Bit ISEM17.
	HSEM_C1MISR_ISEM17 = 0x20000
	// Position of ISEM18 field.
	HSEM_C1MISR_ISEM18_Pos = 0x12
	// Bit mask of ISEM18 field.
	HSEM_C1MISR_ISEM18_Msk = 0x40000
	// Bit ISEM18.
	HSEM_C1MISR_ISEM18 = 0x40000
	// Position of ISEM19 field.
	HSEM_C1MISR_ISEM19_Pos = 0x13
	// Bit mask of ISEM19 field.
	HSEM_C1MISR_ISEM19_Msk = 0x80000
	// Bit ISEM19.
	HSEM_C1MISR_ISEM19 = 0x80000
	// Position of ISEM20 field.
	HSEM_C1MISR_ISEM20_Pos = 0x14
	// Bit mask of ISEM20 field.
	HSEM_C1MISR_ISEM20_Msk = 0x100000
	// Bit ISEM20.
	HSEM_C1MISR_ISEM20 = 0x100000
	// Position of ISEM21 field.
	HSEM_C1MISR_ISEM21_Pos = 0x15
	// Bit mask of ISEM21 field.
	HSEM_C1MISR_ISEM21_Msk = 0x200000
	// Bit ISEM21.
	HSEM_C1MISR_ISEM21 = 0x200000
	// Position of ISEM22 field.
	HSEM_C1MISR_ISEM22_Pos = 0x16
	// Bit mask of ISEM22 field.
	HSEM_C1MISR_ISEM22_Msk = 0x400000
	// Bit ISEM22.
	HSEM_C1MISR_ISEM22 = 0x400000
	// Position of ISEM23 field.
	HSEM_C1MISR_ISEM23_Pos = 0x17
	// Bit mask of ISEM23 field.
	HSEM_C1MISR_ISEM23_Msk = 0x800000
	// Bit ISEM23.
	HSEM_C1MISR_ISEM23 = 0x800000
	// Position of ISEM24 field.
	HSEM_C1MISR_ISEM24_Pos = 0x18
	// Bit mask of ISEM24 field.
	HSEM_C1MISR_ISEM24_Msk = 0x1000000
	// Bit ISEM24.
	HSEM_C1MISR_ISEM24 = 0x1000000
	// Position of ISEM25 field.
	HSEM_C1MISR_ISEM25_Pos = 0x19
	// Bit mask of ISEM25 field.
	HSEM_C1MISR_ISEM25_Msk = 0x2000000
	// Bit ISEM25.
	HSEM_C1MISR_ISEM25 = 0x2000000
	// Position of ISEM26 field.
	HSEM_C1MISR_ISEM26_Pos = 0x1a
	// Bit mask of ISEM26 field.
	HSEM_C1MISR_ISEM26_Msk = 0x4000000
	// Bit ISEM26.
	HSEM_C1MISR_ISEM26 = 0x4000000
	// Position of ISEM27 field.
	HSEM_C1MISR_ISEM27_Pos = 0x1b
	// Bit mask of ISEM27 field.
	HSEM_C1MISR_ISEM27_Msk = 0x8000000
	// Bit ISEM27.
	HSEM_C1MISR_ISEM27 = 0x8000000
	// Position of ISEM28 field.
	HSEM_C1MISR_ISEM28_Pos = 0x1c
	// Bit mask of ISEM28 field.
	HSEM_C1MISR_ISEM28_Msk = 0x10000000
	// Bit ISEM28.
	HSEM_C1MISR_ISEM28 = 0x10000000
	// Position of ISEM29 field.
	HSEM_C1MISR_ISEM29_Pos = 0x1d
	// Bit mask of ISEM29 field.
	HSEM_C1MISR_ISEM29_Msk = 0x20000000
	// Bit ISEM29.
	HSEM_C1MISR_ISEM29 = 0x20000000
	// Position of ISEM30 field.
	HSEM_C1MISR_ISEM30_Pos = 0x1e
	// Bit mask of ISEM30 field.
	HSEM_C1MISR_ISEM30_Msk = 0x40000000
	// Bit ISEM30.
	HSEM_C1MISR_ISEM30 = 0x40000000
	// Position of ISEM31 field.
	HSEM_C1MISR_ISEM31_Pos = 0x1f
	// Bit mask of ISEM31 field.
	HSEM_C1MISR_ISEM31_Msk = 0x80000000
	// Bit ISEM31.
	HSEM_C1MISR_ISEM31 = 0x80000000

	// CR: HSEM Clear register
	// Position of COREID field.
	HSEM_CR_COREID_Pos = 0x8
	// Bit mask of COREID field.
	HSEM_CR_COREID_Msk = 0xf00
	// Position of KEY field.
	HSEM_CR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	HSEM_CR_KEY_Msk = 0xffff0000

	// KEYR: HSEM Interrupt clear register
	// Position of KEY field.
	HSEM_KEYR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	HSEM_KEYR_KEY_Msk = 0xffff0000
)

// Constants for I2C1: I2C
const (
	// CR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	// Position of PE field.
	I2C_CR1_PE_Pos = 0x0
	// Bit mask of PE field.
	I2C_CR1_PE_Msk = 0x1
	// Bit PE.
	I2C_CR1_PE = 0x1
	// Peripheral disabled
	I2C_CR1_PE_Disabled = 0x0
	// Peripheral enabled
	I2C_CR1_PE_Enabled = 0x1
	// Position of TXIE field.
	I2C_CR1_TXIE_Pos = 0x1
	// Bit mask of TXIE field.
	I2C_CR1_TXIE_Msk = 0x2
	// Bit TXIE.
	I2C_CR1_TXIE = 0x2
	// Transmit (TXIS) interrupt disabled
	I2C_CR1_TXIE_Disabled = 0x0
	// Transmit (TXIS) interrupt enabled
	I2C_CR1_TXIE_Enabled = 0x1
	// Position of RXIE field.
	I2C_CR1_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	I2C_CR1_RXIE_Msk = 0x4
	// Bit RXIE.
	I2C_CR1_RXIE = 0x4
	// Receive (RXNE) interrupt disabled
	I2C_CR1_RXIE_Disabled = 0x0
	// Receive (RXNE) interrupt enabled
	I2C_CR1_RXIE_Enabled = 0x1
	// Position of ADDRIE field.
	I2C_CR1_ADDRIE_Pos = 0x3
	// Bit mask of ADDRIE field.
	I2C_CR1_ADDRIE_Msk = 0x8
	// Bit ADDRIE.
	I2C_CR1_ADDRIE = 0x8
	// Address match (ADDR) interrupts disabled
	I2C_CR1_ADDRIE_Disabled = 0x0
	// Address match (ADDR) interrupts enabled
	I2C_CR1_ADDRIE_Enabled = 0x1
	// Position of NACKIE field.
	I2C_CR1_NACKIE_Pos = 0x4
	// Bit mask of NACKIE field.
	I2C_CR1_NACKIE_Msk = 0x10
	// Bit NACKIE.
	I2C_CR1_NACKIE = 0x10
	// Not acknowledge (NACKF) received interrupts disabled
	I2C_CR1_NACKIE_Disabled = 0x0
	// Not acknowledge (NACKF) received interrupts enabled
	I2C_CR1_NACKIE_Enabled = 0x1
	// Position of STOPIE field.
	I2C_CR1_STOPIE_Pos = 0x5
	// Bit mask of STOPIE field.
	I2C_CR1_STOPIE_Msk = 0x20
	// Bit STOPIE.
	I2C_CR1_STOPIE = 0x20
	// Stop detection (STOPF) interrupt disabled
	I2C_CR1_STOPIE_Disabled = 0x0
	// Stop detection (STOPF) interrupt enabled
	I2C_CR1_STOPIE_Enabled = 0x1
	// Position of TCIE field.
	I2C_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	I2C_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	I2C_CR1_TCIE = 0x40
	// Transfer Complete interrupt disabled
	I2C_CR1_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	I2C_CR1_TCIE_Enabled = 0x1
	// Position of ERRIE field.
	I2C_CR1_ERRIE_Pos = 0x7
	// Bit mask of ERRIE field.
	I2C_CR1_ERRIE_Msk = 0x80
	// Bit ERRIE.
	I2C_CR1_ERRIE = 0x80
	// Error detection interrupts disabled
	I2C_CR1_ERRIE_Disabled = 0x0
	// Error detection interrupts enabled
	I2C_CR1_ERRIE_Enabled = 0x1
	// Position of DNF field.
	I2C_CR1_DNF_Pos = 0x8
	// Bit mask of DNF field.
	I2C_CR1_DNF_Msk = 0xf00
	// Digital filter disabled
	I2C_CR1_DNF_NoFilter = 0x0
	// Digital filter enabled and filtering capability up to 1 tI2CCLK
	I2C_CR1_DNF_Filter1 = 0x1
	// Digital filter enabled and filtering capability up to 2 tI2CCLK
	I2C_CR1_DNF_Filter2 = 0x2
	// Digital filter enabled and filtering capability up to 3 tI2CCLK
	I2C_CR1_DNF_Filter3 = 0x3
	// Digital filter enabled and filtering capability up to 4 tI2CCLK
	I2C_CR1_DNF_Filter4 = 0x4
	// Digital filter enabled and filtering capability up to 5 tI2CCLK
	I2C_CR1_DNF_Filter5 = 0x5
	// Digital filter enabled and filtering capability up to 6 tI2CCLK
	I2C_CR1_DNF_Filter6 = 0x6
	// Digital filter enabled and filtering capability up to 7 tI2CCLK
	I2C_CR1_DNF_Filter7 = 0x7
	// Digital filter enabled and filtering capability up to 8 tI2CCLK
	I2C_CR1_DNF_Filter8 = 0x8
	// Digital filter enabled and filtering capability up to 9 tI2CCLK
	I2C_CR1_DNF_Filter9 = 0x9
	// Digital filter enabled and filtering capability up to 10 tI2CCLK
	I2C_CR1_DNF_Filter10 = 0xa
	// Digital filter enabled and filtering capability up to 11 tI2CCLK
	I2C_CR1_DNF_Filter11 = 0xb
	// Digital filter enabled and filtering capability up to 12 tI2CCLK
	I2C_CR1_DNF_Filter12 = 0xc
	// Digital filter enabled and filtering capability up to 13 tI2CCLK
	I2C_CR1_DNF_Filter13 = 0xd
	// Digital filter enabled and filtering capability up to 14 tI2CCLK
	I2C_CR1_DNF_Filter14 = 0xe
	// Digital filter enabled and filtering capability up to 15 tI2CCLK
	I2C_CR1_DNF_Filter15 = 0xf
	// Position of ANFOFF field.
	I2C_CR1_ANFOFF_Pos = 0xc
	// Bit mask of ANFOFF field.
	I2C_CR1_ANFOFF_Msk = 0x1000
	// Bit ANFOFF.
	I2C_CR1_ANFOFF = 0x1000
	// Analog noise filter enabled
	I2C_CR1_ANFOFF_Enabled = 0x0
	// Analog noise filter disabled
	I2C_CR1_ANFOFF_Disabled = 0x1
	// Position of TXDMAEN field.
	I2C_CR1_TXDMAEN_Pos = 0xe
	// Bit mask of TXDMAEN field.
	I2C_CR1_TXDMAEN_Msk = 0x4000
	// Bit TXDMAEN.
	I2C_CR1_TXDMAEN = 0x4000
	// DMA mode disabled for transmission
	I2C_CR1_TXDMAEN_Disabled = 0x0
	// DMA mode enabled for transmission
	I2C_CR1_TXDMAEN_Enabled = 0x1
	// Position of RXDMAEN field.
	I2C_CR1_RXDMAEN_Pos = 0xf
	// Bit mask of RXDMAEN field.
	I2C_CR1_RXDMAEN_Msk = 0x8000
	// Bit RXDMAEN.
	I2C_CR1_RXDMAEN = 0x8000
	// DMA mode disabled for reception
	I2C_CR1_RXDMAEN_Disabled = 0x0
	// DMA mode enabled for reception
	I2C_CR1_RXDMAEN_Enabled = 0x1
	// Position of SBC field.
	I2C_CR1_SBC_Pos = 0x10
	// Bit mask of SBC field.
	I2C_CR1_SBC_Msk = 0x10000
	// Bit SBC.
	I2C_CR1_SBC = 0x10000
	// Slave byte control disabled
	I2C_CR1_SBC_Disabled = 0x0
	// Slave byte control enabled
	I2C_CR1_SBC_Enabled = 0x1
	// Position of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Pos = 0x11
	// Bit mask of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Msk = 0x20000
	// Bit NOSTRETCH.
	I2C_CR1_NOSTRETCH = 0x20000
	// Clock stretching enabled
	I2C_CR1_NOSTRETCH_Enabled = 0x0
	// Clock stretching disabled
	I2C_CR1_NOSTRETCH_Disabled = 0x1
	// Position of WUPEN field.
	I2C_CR1_WUPEN_Pos = 0x12
	// Bit mask of WUPEN field.
	I2C_CR1_WUPEN_Msk = 0x40000
	// Bit WUPEN.
	I2C_CR1_WUPEN = 0x40000
	// Wakeup from Stop mode disabled
	I2C_CR1_WUPEN_Disabled = 0x0
	// Wakeup from Stop mode enabled
	I2C_CR1_WUPEN_Enabled = 0x1
	// Position of GCEN field.
	I2C_CR1_GCEN_Pos = 0x13
	// Bit mask of GCEN field.
	I2C_CR1_GCEN_Msk = 0x80000
	// Bit GCEN.
	I2C_CR1_GCEN = 0x80000
	// General call disabled. Address 0b00000000 is NACKed
	I2C_CR1_GCEN_Disabled = 0x0
	// General call enabled. Address 0b00000000 is ACKed
	I2C_CR1_GCEN_Enabled = 0x1
	// Position of SMBHEN field.
	I2C_CR1_SMBHEN_Pos = 0x14
	// Bit mask of SMBHEN field.
	I2C_CR1_SMBHEN_Msk = 0x100000
	// Bit SMBHEN.
	I2C_CR1_SMBHEN = 0x100000
	// Host address disabled. Address 0b0001000x is NACKed
	I2C_CR1_SMBHEN_Disabled = 0x0
	// Host address enabled. Address 0b0001000x is ACKed
	I2C_CR1_SMBHEN_Enabled = 0x1
	// Position of SMBDEN field.
	I2C_CR1_SMBDEN_Pos = 0x15
	// Bit mask of SMBDEN field.
	I2C_CR1_SMBDEN_Msk = 0x200000
	// Bit SMBDEN.
	I2C_CR1_SMBDEN = 0x200000
	// Device default address disabled. Address 0b1100001x is NACKed
	I2C_CR1_SMBDEN_Disabled = 0x0
	// Device default address enabled. Address 0b1100001x is ACKed
	I2C_CR1_SMBDEN_Enabled = 0x1
	// Position of ALERTEN field.
	I2C_CR1_ALERTEN_Pos = 0x16
	// Bit mask of ALERTEN field.
	I2C_CR1_ALERTEN_Msk = 0x400000
	// Bit ALERTEN.
	I2C_CR1_ALERTEN = 0x400000
	// In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported
	I2C_CR1_ALERTEN_Disabled = 0x0
	// In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported
	I2C_CR1_ALERTEN_Enabled = 0x1
	// Position of PECEN field.
	I2C_CR1_PECEN_Pos = 0x17
	// Bit mask of PECEN field.
	I2C_CR1_PECEN_Msk = 0x800000
	// Bit PECEN.
	I2C_CR1_PECEN = 0x800000
	// PEC calculation disabled
	I2C_CR1_PECEN_Disabled = 0x0
	// PEC calculation enabled
	I2C_CR1_PECEN_Enabled = 0x1

	// CR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	// Position of RD_WRN field.
	I2C_CR2_RD_WRN_Pos = 0xa
	// Bit mask of RD_WRN field.
	I2C_CR2_RD_WRN_Msk = 0x400
	// Bit RD_WRN.
	I2C_CR2_RD_WRN = 0x400
	// Master requests a write transfer
	I2C_CR2_RD_WRN_Write = 0x0
	// Master requests a read transfer
	I2C_CR2_RD_WRN_Read = 0x1
	// Position of ADD10 field.
	I2C_CR2_ADD10_Pos = 0xb
	// Bit mask of ADD10 field.
	I2C_CR2_ADD10_Msk = 0x800
	// Bit ADD10.
	I2C_CR2_ADD10 = 0x800
	// The master operates in 7-bit addressing mode
	I2C_CR2_ADD10_Bit7 = 0x0
	// The master operates in 10-bit addressing mode
	I2C_CR2_ADD10_Bit10 = 0x1
	// Position of HEAD10R field.
	I2C_CR2_HEAD10R_Pos = 0xc
	// Bit mask of HEAD10R field.
	I2C_CR2_HEAD10R_Msk = 0x1000
	// Bit HEAD10R.
	I2C_CR2_HEAD10R = 0x1000
	// The master sends the complete 10 bit slave address read sequence
	I2C_CR2_HEAD10R_Complete = 0x0
	// The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction
	I2C_CR2_HEAD10R_Partial = 0x1
	// Position of START field.
	I2C_CR2_START_Pos = 0xd
	// Bit mask of START field.
	I2C_CR2_START_Msk = 0x2000
	// Bit START.
	I2C_CR2_START = 0x2000
	// No Start generation
	I2C_CR2_START_NoStart = 0x0
	// Restart/Start generation
	I2C_CR2_START_Start = 0x1
	// Position of STOP field.
	I2C_CR2_STOP_Pos = 0xe
	// Bit mask of STOP field.
	I2C_CR2_STOP_Msk = 0x4000
	// Bit STOP.
	I2C_CR2_STOP = 0x4000
	// No Stop generation
	I2C_CR2_STOP_NoStop = 0x0
	// Stop generation after current byte transfer
	I2C_CR2_STOP_Stop = 0x1
	// Position of NACK field.
	I2C_CR2_NACK_Pos = 0xf
	// Bit mask of NACK field.
	I2C_CR2_NACK_Msk = 0x8000
	// Bit NACK.
	I2C_CR2_NACK = 0x8000
	// an ACK is sent after current received byte
	I2C_CR2_NACK_Ack = 0x0
	// a NACK is sent after current received byte
	I2C_CR2_NACK_Nack = 0x1
	// Position of NBYTES field.
	I2C_CR2_NBYTES_Pos = 0x10
	// Bit mask of NBYTES field.
	I2C_CR2_NBYTES_Msk = 0xff0000
	// Position of RELOAD field.
	I2C_CR2_RELOAD_Pos = 0x18
	// Bit mask of RELOAD field.
	I2C_CR2_RELOAD_Msk = 0x1000000
	// Bit RELOAD.
	I2C_CR2_RELOAD = 0x1000000
	// The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)
	I2C_CR2_RELOAD_Completed = 0x0
	// The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)
	I2C_CR2_RELOAD_NotCompleted = 0x1
	// Position of AUTOEND field.
	I2C_CR2_AUTOEND_Pos = 0x19
	// Bit mask of AUTOEND field.
	I2C_CR2_AUTOEND_Msk = 0x2000000
	// Bit AUTOEND.
	I2C_CR2_AUTOEND = 0x2000000
	// Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low
	I2C_CR2_AUTOEND_Software = 0x0
	// Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred
	I2C_CR2_AUTOEND_Automatic = 0x1
	// Position of PECBYTE field.
	I2C_CR2_PECBYTE_Pos = 0x1a
	// Bit mask of PECBYTE field.
	I2C_CR2_PECBYTE_Msk = 0x4000000
	// Bit PECBYTE.
	I2C_CR2_PECBYTE = 0x4000000
	// No PEC transfer
	I2C_CR2_PECBYTE_NoPec = 0x0
	// PEC transmission/reception is requested
	I2C_CR2_PECBYTE_Pec = 0x1
	// Position of SADD field.
	I2C_CR2_SADD_Pos = 0x0
	// Bit mask of SADD field.
	I2C_CR2_SADD_Msk = 0x3ff

	// OAR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	// Position of OA1 field.
	I2C_OAR1_OA1_Pos = 0x0
	// Bit mask of OA1 field.
	I2C_OAR1_OA1_Msk = 0x3ff
	// Position of OA1MODE field.
	I2C_OAR1_OA1MODE_Pos = 0xa
	// Bit mask of OA1MODE field.
	I2C_OAR1_OA1MODE_Msk = 0x400
	// Bit OA1MODE.
	I2C_OAR1_OA1MODE = 0x400
	// Own address 1 is a 7-bit address
	I2C_OAR1_OA1MODE_Bit7 = 0x0
	// Own address 1 is a 10-bit address
	I2C_OAR1_OA1MODE_Bit10 = 0x1
	// Position of OA1EN field.
	I2C_OAR1_OA1EN_Pos = 0xf
	// Bit mask of OA1EN field.
	I2C_OAR1_OA1EN_Msk = 0x8000
	// Bit OA1EN.
	I2C_OAR1_OA1EN = 0x8000
	// Own address 1 disabled. The received slave address OA1 is NACKed
	I2C_OAR1_OA1EN_Disabled = 0x0
	// Own address 1 enabled. The received slave address OA1 is ACKed
	I2C_OAR1_OA1EN_Enabled = 0x1

	// OAR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	// Position of OA2 field.
	I2C_OAR2_OA2_Pos = 0x1
	// Bit mask of OA2 field.
	I2C_OAR2_OA2_Msk = 0xfe
	// Position of OA2MSK field.
	I2C_OAR2_OA2MSK_Pos = 0x8
	// Bit mask of OA2MSK field.
	I2C_OAR2_OA2MSK_Msk = 0x700
	// No mask
	I2C_OAR2_OA2MSK_NoMask = 0x0
	// OA2[1] is masked and dont care. Only OA2[7:2] are compared
	I2C_OAR2_OA2MSK_Mask1 = 0x1
	// OA2[2:1] are masked and dont care. Only OA2[7:3] are compared
	I2C_OAR2_OA2MSK_Mask2 = 0x2
	// OA2[3:1] are masked and dont care. Only OA2[7:4] are compared
	I2C_OAR2_OA2MSK_Mask3 = 0x3
	// OA2[4:1] are masked and dont care. Only OA2[7:5] are compared
	I2C_OAR2_OA2MSK_Mask4 = 0x4
	// OA2[5:1] are masked and dont care. Only OA2[7:6] are compared
	I2C_OAR2_OA2MSK_Mask5 = 0x5
	// OA2[6:1] are masked and dont care. Only OA2[7] is compared.
	I2C_OAR2_OA2MSK_Mask6 = 0x6
	// OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged
	I2C_OAR2_OA2MSK_Mask7 = 0x7
	// Position of OA2EN field.
	I2C_OAR2_OA2EN_Pos = 0xf
	// Bit mask of OA2EN field.
	I2C_OAR2_OA2EN_Msk = 0x8000
	// Bit OA2EN.
	I2C_OAR2_OA2EN = 0x8000
	// Own address 2 disabled. The received slave address OA2 is NACKed
	I2C_OAR2_OA2EN_Disabled = 0x0
	// Own address 2 enabled. The received slave address OA2 is ACKed
	I2C_OAR2_OA2EN_Enabled = 0x1

	// TIMINGR: Access: No wait states
	// Position of SCLL field.
	I2C_TIMINGR_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_TIMINGR_SCLL_Msk = 0xff
	// Position of SCLH field.
	I2C_TIMINGR_SCLH_Pos = 0x8
	// Bit mask of SCLH field.
	I2C_TIMINGR_SCLH_Msk = 0xff00
	// Position of SDADEL field.
	I2C_TIMINGR_SDADEL_Pos = 0x10
	// Bit mask of SDADEL field.
	I2C_TIMINGR_SDADEL_Msk = 0xf0000
	// Position of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Pos = 0x14
	// Bit mask of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Msk = 0xf00000
	// Position of PRESC field.
	I2C_TIMINGR_PRESC_Pos = 0x1c
	// Bit mask of PRESC field.
	I2C_TIMINGR_PRESC_Msk = 0xf0000000

	// TIMEOUTR: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	// Position of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Pos = 0x0
	// Bit mask of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Msk = 0xfff
	// Position of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Pos = 0xc
	// Bit mask of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Msk = 0x1000
	// Bit TIDLE.
	I2C_TIMEOUTR_TIDLE = 0x1000
	// TIMEOUTA is used to detect SCL low timeout
	I2C_TIMEOUTR_TIDLE_Disabled = 0x0
	// TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
	I2C_TIMEOUTR_TIDLE_Enabled = 0x1
	// Position of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Pos = 0xf
	// Bit mask of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Msk = 0x8000
	// Bit TIMOUTEN.
	I2C_TIMEOUTR_TIMOUTEN = 0x8000
	// SCL timeout detection is disabled
	I2C_TIMEOUTR_TIMOUTEN_Disabled = 0x0
	// SCL timeout detection is enabled
	I2C_TIMEOUTR_TIMOUTEN_Enabled = 0x1
	// Position of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Pos = 0x10
	// Bit mask of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Msk = 0xfff0000
	// Position of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Pos = 0x1f
	// Bit mask of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Msk = 0x80000000
	// Bit TEXTEN.
	I2C_TIMEOUTR_TEXTEN = 0x80000000
	// Extended clock timeout detection is disabled
	I2C_TIMEOUTR_TEXTEN_Disabled = 0x0
	// Extended clock timeout detection is enabled
	I2C_TIMEOUTR_TEXTEN_Enabled = 0x1

	// ISR: Access: No wait states
	// Position of TXE field.
	I2C_ISR_TXE_Pos = 0x0
	// Bit mask of TXE field.
	I2C_ISR_TXE_Msk = 0x1
	// Bit TXE.
	I2C_ISR_TXE = 0x1
	// TXDR register not empty
	I2C_ISR_TXE_NotEmpty = 0x0
	// TXDR register empty
	I2C_ISR_TXE_Empty = 0x1
	// Position of TXIS field.
	I2C_ISR_TXIS_Pos = 0x1
	// Bit mask of TXIS field.
	I2C_ISR_TXIS_Msk = 0x2
	// Bit TXIS.
	I2C_ISR_TXIS = 0x2
	// The TXDR register is not empty
	I2C_ISR_TXIS_NotEmpty = 0x0
	// The TXDR register is empty and the data to be transmitted must be written in the TXDR register
	I2C_ISR_TXIS_Empty = 0x1
	// Position of RXNE field.
	I2C_ISR_RXNE_Pos = 0x2
	// Bit mask of RXNE field.
	I2C_ISR_RXNE_Msk = 0x4
	// Bit RXNE.
	I2C_ISR_RXNE = 0x4
	// The RXDR register is empty
	I2C_ISR_RXNE_Empty = 0x0
	// Received data is copied into the RXDR register, and is ready to be read
	I2C_ISR_RXNE_NotEmpty = 0x1
	// Position of ADDR field.
	I2C_ISR_ADDR_Pos = 0x3
	// Bit mask of ADDR field.
	I2C_ISR_ADDR_Msk = 0x8
	// Bit ADDR.
	I2C_ISR_ADDR = 0x8
	// Adress mismatched or not received
	I2C_ISR_ADDR_NotMatch = 0x0
	// Received slave address matched with one of the enabled slave addresses
	I2C_ISR_ADDR_Match = 0x1
	// Position of NACKF field.
	I2C_ISR_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	I2C_ISR_NACKF_Msk = 0x10
	// Bit NACKF.
	I2C_ISR_NACKF = 0x10
	// No NACK has been received
	I2C_ISR_NACKF_NoNack = 0x0
	// NACK has been received
	I2C_ISR_NACKF_Nack = 0x1
	// Position of STOPF field.
	I2C_ISR_STOPF_Pos = 0x5
	// Bit mask of STOPF field.
	I2C_ISR_STOPF_Msk = 0x20
	// Bit STOPF.
	I2C_ISR_STOPF = 0x20
	// No Stop condition detected
	I2C_ISR_STOPF_NoStop = 0x0
	// Stop condition detected
	I2C_ISR_STOPF_Stop = 0x1
	// Position of TC field.
	I2C_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	I2C_ISR_TC_Msk = 0x40
	// Bit TC.
	I2C_ISR_TC = 0x40
	// Transfer is not complete
	I2C_ISR_TC_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TC_Complete = 0x1
	// Position of TCR field.
	I2C_ISR_TCR_Pos = 0x7
	// Bit mask of TCR field.
	I2C_ISR_TCR_Msk = 0x80
	// Bit TCR.
	I2C_ISR_TCR = 0x80
	// Transfer is not complete
	I2C_ISR_TCR_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TCR_Complete = 0x1
	// Position of BERR field.
	I2C_ISR_BERR_Pos = 0x8
	// Bit mask of BERR field.
	I2C_ISR_BERR_Msk = 0x100
	// Bit BERR.
	I2C_ISR_BERR = 0x100
	// No bus error
	I2C_ISR_BERR_NoError = 0x0
	// Misplaced Start and Stop condition is detected
	I2C_ISR_BERR_Error = 0x1
	// Position of ARLO field.
	I2C_ISR_ARLO_Pos = 0x9
	// Bit mask of ARLO field.
	I2C_ISR_ARLO_Msk = 0x200
	// Bit ARLO.
	I2C_ISR_ARLO = 0x200
	// No arbitration lost
	I2C_ISR_ARLO_NotLost = 0x0
	// Arbitration lost
	I2C_ISR_ARLO_Lost = 0x1
	// Position of OVR field.
	I2C_ISR_OVR_Pos = 0xa
	// Bit mask of OVR field.
	I2C_ISR_OVR_Msk = 0x400
	// Bit OVR.
	I2C_ISR_OVR = 0x400
	// No overrun/underrun error occurs
	I2C_ISR_OVR_NoOverrun = 0x0
	// slave mode with NOSTRETCH=1, when an overrun/underrun error occurs
	I2C_ISR_OVR_Overrun = 0x1
	// Position of PECERR field.
	I2C_ISR_PECERR_Pos = 0xb
	// Bit mask of PECERR field.
	I2C_ISR_PECERR_Msk = 0x800
	// Bit PECERR.
	I2C_ISR_PECERR = 0x800
	// Received PEC does match with PEC register
	I2C_ISR_PECERR_Match = 0x0
	// Received PEC does not match with PEC register
	I2C_ISR_PECERR_NoMatch = 0x1
	// Position of TIMEOUT field.
	I2C_ISR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	I2C_ISR_TIMEOUT_Msk = 0x1000
	// Bit TIMEOUT.
	I2C_ISR_TIMEOUT = 0x1000
	// No timeout occured
	I2C_ISR_TIMEOUT_NoTimeout = 0x0
	// Timeout occured
	I2C_ISR_TIMEOUT_Timeout = 0x1
	// Position of ALERT field.
	I2C_ISR_ALERT_Pos = 0xd
	// Bit mask of ALERT field.
	I2C_ISR_ALERT_Msk = 0x2000
	// Bit ALERT.
	I2C_ISR_ALERT = 0x2000
	// SMBA alert is not detected
	I2C_ISR_ALERT_NoAlert = 0x0
	// SMBA alert event is detected on SMBA pin
	I2C_ISR_ALERT_Alert = 0x1
	// Position of BUSY field.
	I2C_ISR_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	I2C_ISR_BUSY_Msk = 0x8000
	// Bit BUSY.
	I2C_ISR_BUSY = 0x8000
	// No communication is in progress on the bus
	I2C_ISR_BUSY_NotBusy = 0x0
	// A communication is in progress on the bus
	I2C_ISR_BUSY_Busy = 0x1
	// Position of DIR field.
	I2C_ISR_DIR_Pos = 0x10
	// Bit mask of DIR field.
	I2C_ISR_DIR_Msk = 0x10000
	// Bit DIR.
	I2C_ISR_DIR = 0x10000
	// Write transfer, slave enters receiver mode
	I2C_ISR_DIR_Write = 0x0
	// Read transfer, slave enters transmitter mode
	I2C_ISR_DIR_Read = 0x1
	// Position of ADDCODE field.
	I2C_ISR_ADDCODE_Pos = 0x11
	// Bit mask of ADDCODE field.
	I2C_ISR_ADDCODE_Msk = 0xfe0000

	// ICR: Access: No wait states
	// Position of ADDRCF field.
	I2C_ICR_ADDRCF_Pos = 0x3
	// Bit mask of ADDRCF field.
	I2C_ICR_ADDRCF_Msk = 0x8
	// Bit ADDRCF.
	I2C_ICR_ADDRCF = 0x8
	// Clears the ADDR flag in ISR register
	I2C_ICR_ADDRCF_Clear = 0x1
	// Position of NACKCF field.
	I2C_ICR_NACKCF_Pos = 0x4
	// Bit mask of NACKCF field.
	I2C_ICR_NACKCF_Msk = 0x10
	// Bit NACKCF.
	I2C_ICR_NACKCF = 0x10
	// Clears the NACK flag in ISR register
	I2C_ICR_NACKCF_Clear = 0x1
	// Position of STOPCF field.
	I2C_ICR_STOPCF_Pos = 0x5
	// Bit mask of STOPCF field.
	I2C_ICR_STOPCF_Msk = 0x20
	// Bit STOPCF.
	I2C_ICR_STOPCF = 0x20
	// Clears the STOP flag in ISR register
	I2C_ICR_STOPCF_Clear = 0x1
	// Position of BERRCF field.
	I2C_ICR_BERRCF_Pos = 0x8
	// Bit mask of BERRCF field.
	I2C_ICR_BERRCF_Msk = 0x100
	// Bit BERRCF.
	I2C_ICR_BERRCF = 0x100
	// Clears the BERR flag in ISR register
	I2C_ICR_BERRCF_Clear = 0x1
	// Position of ARLOCF field.
	I2C_ICR_ARLOCF_Pos = 0x9
	// Bit mask of ARLOCF field.
	I2C_ICR_ARLOCF_Msk = 0x200
	// Bit ARLOCF.
	I2C_ICR_ARLOCF = 0x200
	// Clears the ARLO flag in ISR register
	I2C_ICR_ARLOCF_Clear = 0x1
	// Position of OVRCF field.
	I2C_ICR_OVRCF_Pos = 0xa
	// Bit mask of OVRCF field.
	I2C_ICR_OVRCF_Msk = 0x400
	// Bit OVRCF.
	I2C_ICR_OVRCF = 0x400
	// Clears the OVR flag in ISR register
	I2C_ICR_OVRCF_Clear = 0x1
	// Position of PECCF field.
	I2C_ICR_PECCF_Pos = 0xb
	// Bit mask of PECCF field.
	I2C_ICR_PECCF_Msk = 0x800
	// Bit PECCF.
	I2C_ICR_PECCF = 0x800
	// Clears the PEC flag in ISR register
	I2C_ICR_PECCF_Clear = 0x1
	// Position of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Pos = 0xc
	// Bit mask of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Msk = 0x1000
	// Bit TIMOUTCF.
	I2C_ICR_TIMOUTCF = 0x1000
	// Clears the TIMOUT flag in ISR register
	I2C_ICR_TIMOUTCF_Clear = 0x1
	// Position of ALERTCF field.
	I2C_ICR_ALERTCF_Pos = 0xd
	// Bit mask of ALERTCF field.
	I2C_ICR_ALERTCF_Msk = 0x2000
	// Bit ALERTCF.
	I2C_ICR_ALERTCF = 0x2000
	// Clears the ALERT flag in ISR register
	I2C_ICR_ALERTCF_Clear = 0x1

	// PECR: Access: No wait states
	// Position of PEC field.
	I2C_PECR_PEC_Pos = 0x0
	// Bit mask of PEC field.
	I2C_PECR_PEC_Msk = 0xff

	// RXDR: Access: No wait states
	// Position of RXDATA field.
	I2C_RXDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	I2C_RXDR_RXDATA_Msk = 0xff

	// TXDR: Access: No wait states
	// Position of TXDATA field.
	I2C_TXDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	I2C_TXDR_TXDATA_Msk = 0xff
)

// Constants for IWDG1: IWDG
const (
	// KR: Key register
	// Position of KEY field.
	IWDG_KR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	IWDG_KR_KEY_Msk = 0xffff
	// Enable access to PR, RLR and WINR registers (0x5555)
	IWDG_KR_KEY_Enable = 0x5555
	// Reset the watchdog value (0xAAAA)
	IWDG_KR_KEY_Reset = 0xaaaa
	// Start the watchdog (0xCCCC)
	IWDG_KR_KEY_Start = 0xcccc

	// PR: Prescaler register
	// Position of PR field.
	IWDG_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	IWDG_PR_PR_Msk = 0x7
	// Divider /4
	IWDG_PR_PR_DivideBy4 = 0x0
	// Divider /8
	IWDG_PR_PR_DivideBy8 = 0x1
	// Divider /16
	IWDG_PR_PR_DivideBy16 = 0x2
	// Divider /32
	IWDG_PR_PR_DivideBy32 = 0x3
	// Divider /64
	IWDG_PR_PR_DivideBy64 = 0x4
	// Divider /128
	IWDG_PR_PR_DivideBy128 = 0x5
	// Divider /256
	IWDG_PR_PR_DivideBy256 = 0x6
	// Divider /256
	IWDG_PR_PR_DivideBy256bis = 0x7

	// RLR: Reload register
	// Position of RL field.
	IWDG_RLR_RL_Pos = 0x0
	// Bit mask of RL field.
	IWDG_RLR_RL_Msk = 0xfff

	// SR: Status register
	// Position of PVU field.
	IWDG_SR_PVU_Pos = 0x0
	// Bit mask of PVU field.
	IWDG_SR_PVU_Msk = 0x1
	// Bit PVU.
	IWDG_SR_PVU = 0x1
	// Position of RVU field.
	IWDG_SR_RVU_Pos = 0x1
	// Bit mask of RVU field.
	IWDG_SR_RVU_Msk = 0x2
	// Bit RVU.
	IWDG_SR_RVU = 0x2
	// Position of WVU field.
	IWDG_SR_WVU_Pos = 0x2
	// Bit mask of WVU field.
	IWDG_SR_WVU_Msk = 0x4
	// Bit WVU.
	IWDG_SR_WVU = 0x4

	// WINR: Window register
	// Position of WIN field.
	IWDG_WINR_WIN_Pos = 0x0
	// Bit mask of WIN field.
	IWDG_WINR_WIN_Msk = 0xfff
)

// Constants for LPTIM1: Low power timer
const (
	// ISR: Interrupt and Status Register
	// Position of DOWN field.
	LPTIM_ISR_DOWN_Pos = 0x6
	// Bit mask of DOWN field.
	LPTIM_ISR_DOWN_Msk = 0x40
	// Bit DOWN.
	LPTIM_ISR_DOWN = 0x40
	// Counter direction change up to down
	LPTIM_ISR_DOWN_Set = 0x1
	// Position of UP field.
	LPTIM_ISR_UP_Pos = 0x5
	// Bit mask of UP field.
	LPTIM_ISR_UP_Msk = 0x20
	// Bit UP.
	LPTIM_ISR_UP = 0x20
	// Counter direction change down to up
	LPTIM_ISR_UP_Set = 0x1
	// Position of ARROK field.
	LPTIM_ISR_ARROK_Pos = 0x4
	// Bit mask of ARROK field.
	LPTIM_ISR_ARROK_Msk = 0x10
	// Bit ARROK.
	LPTIM_ISR_ARROK = 0x10
	// Autoreload register update OK
	LPTIM_ISR_ARROK_Set = 0x1
	// Position of CMPOK field.
	LPTIM_ISR_CMPOK_Pos = 0x3
	// Bit mask of CMPOK field.
	LPTIM_ISR_CMPOK_Msk = 0x8
	// Bit CMPOK.
	LPTIM_ISR_CMPOK = 0x8
	// Compare register update OK
	LPTIM_ISR_CMPOK_Set = 0x1
	// Position of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Pos = 0x2
	// Bit mask of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Msk = 0x4
	// Bit EXTTRIG.
	LPTIM_ISR_EXTTRIG = 0x4
	// External trigger edge event
	LPTIM_ISR_EXTTRIG_Set = 0x1
	// Position of ARRM field.
	LPTIM_ISR_ARRM_Pos = 0x1
	// Bit mask of ARRM field.
	LPTIM_ISR_ARRM_Msk = 0x2
	// Bit ARRM.
	LPTIM_ISR_ARRM = 0x2
	// Autoreload match
	LPTIM_ISR_ARRM_Set = 0x1
	// Position of CMPM field.
	LPTIM_ISR_CMPM_Pos = 0x0
	// Bit mask of CMPM field.
	LPTIM_ISR_CMPM_Msk = 0x1
	// Bit CMPM.
	LPTIM_ISR_CMPM = 0x1
	// Compare match
	LPTIM_ISR_CMPM_Set = 0x1

	// ICR: Interrupt Clear Register
	// Position of DOWNCF field.
	LPTIM_ICR_DOWNCF_Pos = 0x6
	// Bit mask of DOWNCF field.
	LPTIM_ICR_DOWNCF_Msk = 0x40
	// Bit DOWNCF.
	LPTIM_ICR_DOWNCF = 0x40
	// Direction change to down Clear Flag
	LPTIM_ICR_DOWNCF_Clear = 0x1
	// Position of UPCF field.
	LPTIM_ICR_UPCF_Pos = 0x5
	// Bit mask of UPCF field.
	LPTIM_ICR_UPCF_Msk = 0x20
	// Bit UPCF.
	LPTIM_ICR_UPCF = 0x20
	// Direction change to up Clear Flag
	LPTIM_ICR_UPCF_Clear = 0x1
	// Position of ARROKCF field.
	LPTIM_ICR_ARROKCF_Pos = 0x4
	// Bit mask of ARROKCF field.
	LPTIM_ICR_ARROKCF_Msk = 0x10
	// Bit ARROKCF.
	LPTIM_ICR_ARROKCF = 0x10
	// Autoreload register update OK Clear Flag
	LPTIM_ICR_ARROKCF_Clear = 0x1
	// Position of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Pos = 0x3
	// Bit mask of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Msk = 0x8
	// Bit CMPOKCF.
	LPTIM_ICR_CMPOKCF = 0x8
	// Compare register update OK Clear Flag
	LPTIM_ICR_CMPOKCF_Clear = 0x1
	// Position of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Pos = 0x2
	// Bit mask of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Msk = 0x4
	// Bit EXTTRIGCF.
	LPTIM_ICR_EXTTRIGCF = 0x4
	// External trigger valid edge Clear Flag
	LPTIM_ICR_EXTTRIGCF_Clear = 0x1
	// Position of ARRMCF field.
	LPTIM_ICR_ARRMCF_Pos = 0x1
	// Bit mask of ARRMCF field.
	LPTIM_ICR_ARRMCF_Msk = 0x2
	// Bit ARRMCF.
	LPTIM_ICR_ARRMCF = 0x2
	// Autoreload match Clear Flag
	LPTIM_ICR_ARRMCF_Clear = 0x1
	// Position of CMPMCF field.
	LPTIM_ICR_CMPMCF_Pos = 0x0
	// Bit mask of CMPMCF field.
	LPTIM_ICR_CMPMCF_Msk = 0x1
	// Bit CMPMCF.
	LPTIM_ICR_CMPMCF = 0x1
	// Compare match Clear Flag
	LPTIM_ICR_CMPMCF_Clear = 0x1

	// IER: Interrupt Enable Register
	// Position of DOWNIE field.
	LPTIM_IER_DOWNIE_Pos = 0x6
	// Bit mask of DOWNIE field.
	LPTIM_IER_DOWNIE_Msk = 0x40
	// Bit DOWNIE.
	LPTIM_IER_DOWNIE = 0x40
	// DOWN interrupt disabled
	LPTIM_IER_DOWNIE_Disabled = 0x0
	// DOWN interrupt enabled
	LPTIM_IER_DOWNIE_Enabled = 0x1
	// Position of UPIE field.
	LPTIM_IER_UPIE_Pos = 0x5
	// Bit mask of UPIE field.
	LPTIM_IER_UPIE_Msk = 0x20
	// Bit UPIE.
	LPTIM_IER_UPIE = 0x20
	// UP interrupt disabled
	LPTIM_IER_UPIE_Disabled = 0x0
	// UP interrupt enabled
	LPTIM_IER_UPIE_Enabled = 0x1
	// Position of ARROKIE field.
	LPTIM_IER_ARROKIE_Pos = 0x4
	// Bit mask of ARROKIE field.
	LPTIM_IER_ARROKIE_Msk = 0x10
	// Bit ARROKIE.
	LPTIM_IER_ARROKIE = 0x10
	// ARROK interrupt disabled
	LPTIM_IER_ARROKIE_Disabled = 0x0
	// ARROK interrupt enabled
	LPTIM_IER_ARROKIE_Enabled = 0x1
	// Position of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Pos = 0x3
	// Bit mask of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Msk = 0x8
	// Bit CMPOKIE.
	LPTIM_IER_CMPOKIE = 0x8
	// CMPOK interrupt disabled
	LPTIM_IER_CMPOKIE_Disabled = 0x0
	// CMPOK interrupt enabled
	LPTIM_IER_CMPOKIE_Enabled = 0x1
	// Position of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Pos = 0x2
	// Bit mask of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Msk = 0x4
	// Bit EXTTRIGIE.
	LPTIM_IER_EXTTRIGIE = 0x4
	// EXTTRIG interrupt disabled
	LPTIM_IER_EXTTRIGIE_Disabled = 0x0
	// EXTTRIG interrupt enabled
	LPTIM_IER_EXTTRIGIE_Enabled = 0x1
	// Position of ARRMIE field.
	LPTIM_IER_ARRMIE_Pos = 0x1
	// Bit mask of ARRMIE field.
	LPTIM_IER_ARRMIE_Msk = 0x2
	// Bit ARRMIE.
	LPTIM_IER_ARRMIE = 0x2
	// ARRM interrupt disabled
	LPTIM_IER_ARRMIE_Disabled = 0x0
	// ARRM interrupt enabled
	LPTIM_IER_ARRMIE_Enabled = 0x1
	// Position of CMPMIE field.
	LPTIM_IER_CMPMIE_Pos = 0x0
	// Bit mask of CMPMIE field.
	LPTIM_IER_CMPMIE_Msk = 0x1
	// Bit CMPMIE.
	LPTIM_IER_CMPMIE = 0x1
	// CMPM interrupt disabled
	LPTIM_IER_CMPMIE_Disabled = 0x0
	// CMPM interrupt enabled
	LPTIM_IER_CMPMIE_Enabled = 0x1

	// CFGR: Configuration Register
	// Position of ENC field.
	LPTIM_CFGR_ENC_Pos = 0x18
	// Bit mask of ENC field.
	LPTIM_CFGR_ENC_Msk = 0x1000000
	// Bit ENC.
	LPTIM_CFGR_ENC = 0x1000000
	// Encoder mode disabled
	LPTIM_CFGR_ENC_Disabled = 0x0
	// Encoder mode enabled
	LPTIM_CFGR_ENC_Enabled = 0x1
	// Position of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Pos = 0x17
	// Bit mask of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Msk = 0x800000
	// Bit COUNTMODE.
	LPTIM_CFGR_COUNTMODE = 0x800000
	// The counter is incremented following each internal clock pulse
	LPTIM_CFGR_COUNTMODE_Internal = 0x0
	// The counter is incremented following each valid clock pulse on the LPTIM external Input1
	LPTIM_CFGR_COUNTMODE_External = 0x1
	// Position of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Pos = 0x16
	// Bit mask of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Msk = 0x400000
	// Bit PRELOAD.
	LPTIM_CFGR_PRELOAD = 0x400000
	// Registers are updated after each APB bus write access
	LPTIM_CFGR_PRELOAD_Immediate = 0x0
	// Registers are updated at the end of the current LPTIM period
	LPTIM_CFGR_PRELOAD_EndOfPeriod = 0x1
	// Position of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Pos = 0x15
	// Bit mask of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Msk = 0x200000
	// Bit WAVPOL.
	LPTIM_CFGR_WAVPOL = 0x200000
	// The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
	LPTIM_CFGR_WAVPOL_Positive = 0x0
	// The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
	LPTIM_CFGR_WAVPOL_Negative = 0x1
	// Position of WAVE field.
	LPTIM_CFGR_WAVE_Pos = 0x14
	// Bit mask of WAVE field.
	LPTIM_CFGR_WAVE_Msk = 0x100000
	// Bit WAVE.
	LPTIM_CFGR_WAVE = 0x100000
	// Deactivate Set-once mode, PWM / One Pulse waveform (depending on OPMODE bit)
	LPTIM_CFGR_WAVE_Inactive = 0x0
	// Activate the Set-once mode
	LPTIM_CFGR_WAVE_Active = 0x1
	// Position of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Pos = 0x13
	// Bit mask of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Msk = 0x80000
	// Bit TIMOUT.
	LPTIM_CFGR_TIMOUT = 0x80000
	// A trigger event arriving when the timer is already started will be ignored
	LPTIM_CFGR_TIMOUT_Disabled = 0x0
	// A trigger event arriving when the timer is already started will reset and restart the counter
	LPTIM_CFGR_TIMOUT_Enabled = 0x1
	// Position of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Pos = 0x11
	// Bit mask of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Msk = 0x60000
	// Software trigger (counting start is initiated by software)
	LPTIM_CFGR_TRIGEN_SW = 0x0
	// Rising edge is the active edge
	LPTIM_CFGR_TRIGEN_RisingEdge = 0x1
	// Falling edge is the active edge
	LPTIM_CFGR_TRIGEN_FallingEdge = 0x2
	// Both edges are active edges
	LPTIM_CFGR_TRIGEN_BothEdges = 0x3
	// Position of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Pos = 0xd
	// Bit mask of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Msk = 0xe000
	// lptim_ext_trig0
	LPTIM_CFGR_TRIGSEL_Trig0 = 0x0
	// lptim_ext_trig1
	LPTIM_CFGR_TRIGSEL_Trig1 = 0x1
	// lptim_ext_trig2
	LPTIM_CFGR_TRIGSEL_Trig2 = 0x2
	// lptim_ext_trig3
	LPTIM_CFGR_TRIGSEL_Trig3 = 0x3
	// lptim_ext_trig4
	LPTIM_CFGR_TRIGSEL_Trig4 = 0x4
	// lptim_ext_trig5
	LPTIM_CFGR_TRIGSEL_Trig5 = 0x5
	// lptim_ext_trig6
	LPTIM_CFGR_TRIGSEL_Trig6 = 0x6
	// lptim_ext_trig7
	LPTIM_CFGR_TRIGSEL_Trig7 = 0x7
	// Position of PRESC field.
	LPTIM_CFGR_PRESC_Pos = 0x9
	// Bit mask of PRESC field.
	LPTIM_CFGR_PRESC_Msk = 0xe00
	// /1
	LPTIM_CFGR_PRESC_Div1 = 0x0
	// /2
	LPTIM_CFGR_PRESC_Div2 = 0x1
	// /4
	LPTIM_CFGR_PRESC_Div4 = 0x2
	// /8
	LPTIM_CFGR_PRESC_Div8 = 0x3
	// /16
	LPTIM_CFGR_PRESC_Div16 = 0x4
	// /32
	LPTIM_CFGR_PRESC_Div32 = 0x5
	// /64
	LPTIM_CFGR_PRESC_Div64 = 0x6
	// /128
	LPTIM_CFGR_PRESC_Div128 = 0x7
	// Position of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Pos = 0x6
	// Bit mask of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Msk = 0xc0
	// Any trigger active level change is considered as a valid trigger
	LPTIM_CFGR_TRGFLT_Immediate = 0x0
	// Trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger
	LPTIM_CFGR_TRGFLT_Clocks2 = 0x1
	// Trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger
	LPTIM_CFGR_TRGFLT_Clocks4 = 0x2
	// Trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger
	LPTIM_CFGR_TRGFLT_Clocks8 = 0x3
	// Position of CKFLT field.
	LPTIM_CFGR_CKFLT_Pos = 0x3
	// Bit mask of CKFLT field.
	LPTIM_CFGR_CKFLT_Msk = 0x18
	// Any external clock signal level change is considered as a valid transition
	LPTIM_CFGR_CKFLT_Immediate = 0x0
	// External clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition
	LPTIM_CFGR_CKFLT_Clocks2 = 0x1
	// External clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition
	LPTIM_CFGR_CKFLT_Clocks4 = 0x2
	// External clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition
	LPTIM_CFGR_CKFLT_Clocks8 = 0x3
	// Position of CKPOL field.
	LPTIM_CFGR_CKPOL_Pos = 0x1
	// Bit mask of CKPOL field.
	LPTIM_CFGR_CKPOL_Msk = 0x6
	// The rising edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 1 is active.
	LPTIM_CFGR_CKPOL_RisingEdge = 0x0
	// The falling edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 2 is active.
	LPTIM_CFGR_CKPOL_FallingEdge = 0x1
	// Both edges are active edge. If LPTIM is in encoder mode: Encoder sub-mode 3 is active.
	LPTIM_CFGR_CKPOL_BothEdges = 0x2
	// Position of CKSEL field.
	LPTIM_CFGR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	LPTIM_CFGR_CKSEL_Msk = 0x1
	// Bit CKSEL.
	LPTIM_CFGR_CKSEL = 0x1
	// LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
	LPTIM_CFGR_CKSEL_Internal = 0x0
	// LPTIM is clocked by an external clock source through the LPTIM external Input1
	LPTIM_CFGR_CKSEL_External = 0x1

	// CR: Control Register
	// Position of ENABLE field.
	LPTIM_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPTIM_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	LPTIM_CR_ENABLE = 0x1
	// LPTIM is disabled
	LPTIM_CR_ENABLE_Disabled = 0x0
	// LPTIM is enabled
	LPTIM_CR_ENABLE_Enabled = 0x1
	// Position of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Pos = 0x1
	// Bit mask of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Msk = 0x2
	// Bit SNGSTRT.
	LPTIM_CR_SNGSTRT = 0x2
	// LPTIM start in Single mode
	LPTIM_CR_SNGSTRT_Start = 0x1
	// Position of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Pos = 0x2
	// Bit mask of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Msk = 0x4
	// Bit CNTSTRT.
	LPTIM_CR_CNTSTRT = 0x4
	// Timer start in Continuous mode
	LPTIM_CR_CNTSTRT_Start = 0x1
	// Position of COUNTRST field.
	LPTIM_CR_COUNTRST_Pos = 0x3
	// Bit mask of COUNTRST field.
	LPTIM_CR_COUNTRST_Msk = 0x8
	// Bit COUNTRST.
	LPTIM_CR_COUNTRST = 0x8
	// Position of RSTARE field.
	LPTIM_CR_RSTARE_Pos = 0x4
	// Bit mask of RSTARE field.
	LPTIM_CR_RSTARE_Msk = 0x10
	// Bit RSTARE.
	LPTIM_CR_RSTARE = 0x10

	// CMP: Compare Register
	// Position of CMP field.
	LPTIM_CMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	LPTIM_CMP_CMP_Msk = 0xffff

	// ARR: Autoreload Register
	// Position of ARR field.
	LPTIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	LPTIM_ARR_ARR_Msk = 0xffff

	// CNT: Counter Register
	// Position of CNT field.
	LPTIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	LPTIM_CNT_CNT_Msk = 0xffff

	// CFGR2: LPTIM configuration register 2
	// Position of IN1SEL field.
	LPTIM_CFGR2_IN1SEL_Pos = 0x0
	// Bit mask of IN1SEL field.
	LPTIM_CFGR2_IN1SEL_Msk = 0x3
	// Position of IN2SEL field.
	LPTIM_CFGR2_IN2SEL_Pos = 0x4
	// Bit mask of IN2SEL field.
	LPTIM_CFGR2_IN2SEL_Msk = 0x30
)

// Constants for LPUART1: LPUART1
const (
	// CR1: Control register 1
	// Position of RXFFIE field.
	LPUART_CR1_RXFFIE_Pos = 0x1f
	// Bit mask of RXFFIE field.
	LPUART_CR1_RXFFIE_Msk = 0x80000000
	// Bit RXFFIE.
	LPUART_CR1_RXFFIE = 0x80000000
	// Position of TXFEIE field.
	LPUART_CR1_TXFEIE_Pos = 0x1e
	// Bit mask of TXFEIE field.
	LPUART_CR1_TXFEIE_Msk = 0x40000000
	// Bit TXFEIE.
	LPUART_CR1_TXFEIE = 0x40000000
	// Position of FIFOEN field.
	LPUART_CR1_FIFOEN_Pos = 0x1d
	// Bit mask of FIFOEN field.
	LPUART_CR1_FIFOEN_Msk = 0x20000000
	// Bit FIFOEN.
	LPUART_CR1_FIFOEN = 0x20000000
	// Position of M1 field.
	LPUART_CR1_M1_Pos = 0x1c
	// Bit mask of M1 field.
	LPUART_CR1_M1_Msk = 0x10000000
	// Bit M1.
	LPUART_CR1_M1 = 0x10000000
	// Position of DEAT field.
	LPUART_CR1_DEAT_Pos = 0x15
	// Bit mask of DEAT field.
	LPUART_CR1_DEAT_Msk = 0x3e00000
	// Position of DEDT field.
	LPUART_CR1_DEDT_Pos = 0x10
	// Bit mask of DEDT field.
	LPUART_CR1_DEDT_Msk = 0x1f0000
	// Position of CMIE field.
	LPUART_CR1_CMIE_Pos = 0xe
	// Bit mask of CMIE field.
	LPUART_CR1_CMIE_Msk = 0x4000
	// Bit CMIE.
	LPUART_CR1_CMIE = 0x4000
	// Position of MME field.
	LPUART_CR1_MME_Pos = 0xd
	// Bit mask of MME field.
	LPUART_CR1_MME_Msk = 0x2000
	// Bit MME.
	LPUART_CR1_MME = 0x2000
	// Position of M0 field.
	LPUART_CR1_M0_Pos = 0xc
	// Bit mask of M0 field.
	LPUART_CR1_M0_Msk = 0x1000
	// Bit M0.
	LPUART_CR1_M0 = 0x1000
	// Position of WAKE field.
	LPUART_CR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	LPUART_CR1_WAKE_Msk = 0x800
	// Bit WAKE.
	LPUART_CR1_WAKE = 0x800
	// Position of PCE field.
	LPUART_CR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	LPUART_CR1_PCE_Msk = 0x400
	// Bit PCE.
	LPUART_CR1_PCE = 0x400
	// Position of PS field.
	LPUART_CR1_PS_Pos = 0x9
	// Bit mask of PS field.
	LPUART_CR1_PS_Msk = 0x200
	// Bit PS.
	LPUART_CR1_PS = 0x200
	// Position of PEIE field.
	LPUART_CR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	LPUART_CR1_PEIE_Msk = 0x100
	// Bit PEIE.
	LPUART_CR1_PEIE = 0x100
	// Position of TXEIE field.
	LPUART_CR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	LPUART_CR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	LPUART_CR1_TXEIE = 0x80
	// Position of TCIE field.
	LPUART_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	LPUART_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	LPUART_CR1_TCIE = 0x40
	// Position of RXNEIE field.
	LPUART_CR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	LPUART_CR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	LPUART_CR1_RXNEIE = 0x20
	// Position of IDLEIE field.
	LPUART_CR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	LPUART_CR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	LPUART_CR1_IDLEIE = 0x10
	// Position of TE field.
	LPUART_CR1_TE_Pos = 0x3
	// Bit mask of TE field.
	LPUART_CR1_TE_Msk = 0x8
	// Bit TE.
	LPUART_CR1_TE = 0x8
	// Position of RE field.
	LPUART_CR1_RE_Pos = 0x2
	// Bit mask of RE field.
	LPUART_CR1_RE_Msk = 0x4
	// Bit RE.
	LPUART_CR1_RE = 0x4
	// Position of UESM field.
	LPUART_CR1_UESM_Pos = 0x1
	// Bit mask of UESM field.
	LPUART_CR1_UESM_Msk = 0x2
	// Bit UESM.
	LPUART_CR1_UESM = 0x2
	// Position of UE field.
	LPUART_CR1_UE_Pos = 0x0
	// Bit mask of UE field.
	LPUART_CR1_UE_Msk = 0x1
	// Bit UE.
	LPUART_CR1_UE = 0x1

	// CR2: Control register 2
	// Position of ADD field.
	LPUART_CR2_ADD_Pos = 0x18
	// Bit mask of ADD field.
	LPUART_CR2_ADD_Msk = 0xff000000
	// Position of MSBFIRST field.
	LPUART_CR2_MSBFIRST_Pos = 0x13
	// Bit mask of MSBFIRST field.
	LPUART_CR2_MSBFIRST_Msk = 0x80000
	// Bit MSBFIRST.
	LPUART_CR2_MSBFIRST = 0x80000
	// Position of DATAINV field.
	LPUART_CR2_DATAINV_Pos = 0x12
	// Bit mask of DATAINV field.
	LPUART_CR2_DATAINV_Msk = 0x40000
	// Bit DATAINV.
	LPUART_CR2_DATAINV = 0x40000
	// Position of TXINV field.
	LPUART_CR2_TXINV_Pos = 0x11
	// Bit mask of TXINV field.
	LPUART_CR2_TXINV_Msk = 0x20000
	// Bit TXINV.
	LPUART_CR2_TXINV = 0x20000
	// Position of RXINV field.
	LPUART_CR2_RXINV_Pos = 0x10
	// Bit mask of RXINV field.
	LPUART_CR2_RXINV_Msk = 0x10000
	// Bit RXINV.
	LPUART_CR2_RXINV = 0x10000
	// Position of SWAP field.
	LPUART_CR2_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	LPUART_CR2_SWAP_Msk = 0x8000
	// Bit SWAP.
	LPUART_CR2_SWAP = 0x8000
	// Position of STOP field.
	LPUART_CR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	LPUART_CR2_STOP_Msk = 0x3000
	// Position of ADDM7 field.
	LPUART_CR2_ADDM7_Pos = 0x4
	// Bit mask of ADDM7 field.
	LPUART_CR2_ADDM7_Msk = 0x10
	// Bit ADDM7.
	LPUART_CR2_ADDM7 = 0x10

	// CR3: Control register 3
	// Position of TXFTCFG field.
	LPUART_CR3_TXFTCFG_Pos = 0x1d
	// Bit mask of TXFTCFG field.
	LPUART_CR3_TXFTCFG_Msk = 0xe0000000
	// Position of RXFTIE field.
	LPUART_CR3_RXFTIE_Pos = 0x1c
	// Bit mask of RXFTIE field.
	LPUART_CR3_RXFTIE_Msk = 0x10000000
	// Bit RXFTIE.
	LPUART_CR3_RXFTIE = 0x10000000
	// Position of RXFTCFG field.
	LPUART_CR3_RXFTCFG_Pos = 0x19
	// Bit mask of RXFTCFG field.
	LPUART_CR3_RXFTCFG_Msk = 0xe000000
	// Position of TXFTIE field.
	LPUART_CR3_TXFTIE_Pos = 0x17
	// Bit mask of TXFTIE field.
	LPUART_CR3_TXFTIE_Msk = 0x800000
	// Bit TXFTIE.
	LPUART_CR3_TXFTIE = 0x800000
	// Position of WUFIE field.
	LPUART_CR3_WUFIE_Pos = 0x16
	// Bit mask of WUFIE field.
	LPUART_CR3_WUFIE_Msk = 0x400000
	// Bit WUFIE.
	LPUART_CR3_WUFIE = 0x400000
	// Position of WUS field.
	LPUART_CR3_WUS_Pos = 0x14
	// Bit mask of WUS field.
	LPUART_CR3_WUS_Msk = 0x300000
	// Position of DEP field.
	LPUART_CR3_DEP_Pos = 0xf
	// Bit mask of DEP field.
	LPUART_CR3_DEP_Msk = 0x8000
	// Bit DEP.
	LPUART_CR3_DEP = 0x8000
	// Position of DEM field.
	LPUART_CR3_DEM_Pos = 0xe
	// Bit mask of DEM field.
	LPUART_CR3_DEM_Msk = 0x4000
	// Bit DEM.
	LPUART_CR3_DEM = 0x4000
	// Position of DDRE field.
	LPUART_CR3_DDRE_Pos = 0xd
	// Bit mask of DDRE field.
	LPUART_CR3_DDRE_Msk = 0x2000
	// Bit DDRE.
	LPUART_CR3_DDRE = 0x2000
	// Position of OVRDIS field.
	LPUART_CR3_OVRDIS_Pos = 0xc
	// Bit mask of OVRDIS field.
	LPUART_CR3_OVRDIS_Msk = 0x1000
	// Bit OVRDIS.
	LPUART_CR3_OVRDIS = 0x1000
	// Position of CTSIE field.
	LPUART_CR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	LPUART_CR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	LPUART_CR3_CTSIE = 0x400
	// Position of CTSE field.
	LPUART_CR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	LPUART_CR3_CTSE_Msk = 0x200
	// Bit CTSE.
	LPUART_CR3_CTSE = 0x200
	// Position of RTSE field.
	LPUART_CR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	LPUART_CR3_RTSE_Msk = 0x100
	// Bit RTSE.
	LPUART_CR3_RTSE = 0x100
	// Position of DMAT field.
	LPUART_CR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	LPUART_CR3_DMAT_Msk = 0x80
	// Bit DMAT.
	LPUART_CR3_DMAT = 0x80
	// Position of DMAR field.
	LPUART_CR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	LPUART_CR3_DMAR_Msk = 0x40
	// Bit DMAR.
	LPUART_CR3_DMAR = 0x40
	// Position of HDSEL field.
	LPUART_CR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	LPUART_CR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	LPUART_CR3_HDSEL = 0x8
	// Position of EIE field.
	LPUART_CR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	LPUART_CR3_EIE_Msk = 0x1
	// Bit EIE.
	LPUART_CR3_EIE = 0x1

	// BRR: Baud rate register
	// Position of BRR field.
	LPUART_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	LPUART_BRR_BRR_Msk = 0xfffff

	// GTPR: Guard time and prescaler register
	// Position of GT field.
	LPUART_GTPR_GT_Pos = 0x8
	// Bit mask of GT field.
	LPUART_GTPR_GT_Msk = 0xff00
	// Position of PSC field.
	LPUART_GTPR_PSC_Pos = 0x0
	// Bit mask of PSC field.
	LPUART_GTPR_PSC_Msk = 0xff

	// RTOR: Receiver timeout register
	// Position of BLEN field.
	LPUART_RTOR_BLEN_Pos = 0x18
	// Bit mask of BLEN field.
	LPUART_RTOR_BLEN_Msk = 0xff000000
	// Position of RTO field.
	LPUART_RTOR_RTO_Pos = 0x0
	// Bit mask of RTO field.
	LPUART_RTOR_RTO_Msk = 0xffffff

	// RQR: Request register
	// Position of TXFRQ field.
	LPUART_RQR_TXFRQ_Pos = 0x4
	// Bit mask of TXFRQ field.
	LPUART_RQR_TXFRQ_Msk = 0x10
	// Bit TXFRQ.
	LPUART_RQR_TXFRQ = 0x10
	// Position of RXFRQ field.
	LPUART_RQR_RXFRQ_Pos = 0x3
	// Bit mask of RXFRQ field.
	LPUART_RQR_RXFRQ_Msk = 0x8
	// Bit RXFRQ.
	LPUART_RQR_RXFRQ = 0x8
	// Position of MMRQ field.
	LPUART_RQR_MMRQ_Pos = 0x2
	// Bit mask of MMRQ field.
	LPUART_RQR_MMRQ_Msk = 0x4
	// Bit MMRQ.
	LPUART_RQR_MMRQ = 0x4
	// Position of SBKRQ field.
	LPUART_RQR_SBKRQ_Pos = 0x1
	// Bit mask of SBKRQ field.
	LPUART_RQR_SBKRQ_Msk = 0x2
	// Bit SBKRQ.
	LPUART_RQR_SBKRQ = 0x2
	// Position of ABRRQ field.
	LPUART_RQR_ABRRQ_Pos = 0x0
	// Bit mask of ABRRQ field.
	LPUART_RQR_ABRRQ_Msk = 0x1
	// Bit ABRRQ.
	LPUART_RQR_ABRRQ = 0x1

	// ISR: Interrupt & status register
	// Position of TXFT field.
	LPUART_ISR_TXFT_Pos = 0x1b
	// Bit mask of TXFT field.
	LPUART_ISR_TXFT_Msk = 0x8000000
	// Bit TXFT.
	LPUART_ISR_TXFT = 0x8000000
	// Position of RXFT field.
	LPUART_ISR_RXFT_Pos = 0x1a
	// Bit mask of RXFT field.
	LPUART_ISR_RXFT_Msk = 0x4000000
	// Bit RXFT.
	LPUART_ISR_RXFT = 0x4000000
	// Position of RXFF field.
	LPUART_ISR_RXFF_Pos = 0x18
	// Bit mask of RXFF field.
	LPUART_ISR_RXFF_Msk = 0x1000000
	// Bit RXFF.
	LPUART_ISR_RXFF = 0x1000000
	// Position of TXFE field.
	LPUART_ISR_TXFE_Pos = 0x17
	// Bit mask of TXFE field.
	LPUART_ISR_TXFE_Msk = 0x800000
	// Bit TXFE.
	LPUART_ISR_TXFE = 0x800000
	// Position of REACK field.
	LPUART_ISR_REACK_Pos = 0x16
	// Bit mask of REACK field.
	LPUART_ISR_REACK_Msk = 0x400000
	// Bit REACK.
	LPUART_ISR_REACK = 0x400000
	// Position of TEACK field.
	LPUART_ISR_TEACK_Pos = 0x15
	// Bit mask of TEACK field.
	LPUART_ISR_TEACK_Msk = 0x200000
	// Bit TEACK.
	LPUART_ISR_TEACK = 0x200000
	// Position of WUF field.
	LPUART_ISR_WUF_Pos = 0x14
	// Bit mask of WUF field.
	LPUART_ISR_WUF_Msk = 0x100000
	// Bit WUF.
	LPUART_ISR_WUF = 0x100000
	// Position of RWU field.
	LPUART_ISR_RWU_Pos = 0x13
	// Bit mask of RWU field.
	LPUART_ISR_RWU_Msk = 0x80000
	// Bit RWU.
	LPUART_ISR_RWU = 0x80000
	// Position of SBKF field.
	LPUART_ISR_SBKF_Pos = 0x12
	// Bit mask of SBKF field.
	LPUART_ISR_SBKF_Msk = 0x40000
	// Bit SBKF.
	LPUART_ISR_SBKF = 0x40000
	// Position of CMF field.
	LPUART_ISR_CMF_Pos = 0x11
	// Bit mask of CMF field.
	LPUART_ISR_CMF_Msk = 0x20000
	// Bit CMF.
	LPUART_ISR_CMF = 0x20000
	// Position of BUSY field.
	LPUART_ISR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	LPUART_ISR_BUSY_Msk = 0x10000
	// Bit BUSY.
	LPUART_ISR_BUSY = 0x10000
	// Position of CTS field.
	LPUART_ISR_CTS_Pos = 0xa
	// Bit mask of CTS field.
	LPUART_ISR_CTS_Msk = 0x400
	// Bit CTS.
	LPUART_ISR_CTS = 0x400
	// Position of CTSIF field.
	LPUART_ISR_CTSIF_Pos = 0x9
	// Bit mask of CTSIF field.
	LPUART_ISR_CTSIF_Msk = 0x200
	// Bit CTSIF.
	LPUART_ISR_CTSIF = 0x200
	// Position of TXE field.
	LPUART_ISR_TXE_Pos = 0x7
	// Bit mask of TXE field.
	LPUART_ISR_TXE_Msk = 0x80
	// Bit TXE.
	LPUART_ISR_TXE = 0x80
	// Position of TC field.
	LPUART_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	LPUART_ISR_TC_Msk = 0x40
	// Bit TC.
	LPUART_ISR_TC = 0x40
	// Position of RXNE field.
	LPUART_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	LPUART_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	LPUART_ISR_RXNE = 0x20
	// Position of IDLE field.
	LPUART_ISR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	LPUART_ISR_IDLE_Msk = 0x10
	// Bit IDLE.
	LPUART_ISR_IDLE = 0x10
	// Position of ORE field.
	LPUART_ISR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	LPUART_ISR_ORE_Msk = 0x8
	// Bit ORE.
	LPUART_ISR_ORE = 0x8
	// Position of NE field.
	LPUART_ISR_NE_Pos = 0x2
	// Bit mask of NE field.
	LPUART_ISR_NE_Msk = 0x4
	// Bit NE.
	LPUART_ISR_NE = 0x4
	// Position of FE field.
	LPUART_ISR_FE_Pos = 0x1
	// Bit mask of FE field.
	LPUART_ISR_FE_Msk = 0x2
	// Bit FE.
	LPUART_ISR_FE = 0x2
	// Position of PE field.
	LPUART_ISR_PE_Pos = 0x0
	// Bit mask of PE field.
	LPUART_ISR_PE_Msk = 0x1
	// Bit PE.
	LPUART_ISR_PE = 0x1

	// ICR: Interrupt flag clear register
	// Position of WUCF field.
	LPUART_ICR_WUCF_Pos = 0x14
	// Bit mask of WUCF field.
	LPUART_ICR_WUCF_Msk = 0x100000
	// Bit WUCF.
	LPUART_ICR_WUCF = 0x100000
	// Position of CMCF field.
	LPUART_ICR_CMCF_Pos = 0x11
	// Bit mask of CMCF field.
	LPUART_ICR_CMCF_Msk = 0x20000
	// Bit CMCF.
	LPUART_ICR_CMCF = 0x20000
	// Position of CTSCF field.
	LPUART_ICR_CTSCF_Pos = 0x9
	// Bit mask of CTSCF field.
	LPUART_ICR_CTSCF_Msk = 0x200
	// Bit CTSCF.
	LPUART_ICR_CTSCF = 0x200
	// Position of TCCF field.
	LPUART_ICR_TCCF_Pos = 0x6
	// Bit mask of TCCF field.
	LPUART_ICR_TCCF_Msk = 0x40
	// Bit TCCF.
	LPUART_ICR_TCCF = 0x40
	// Position of IDLECF field.
	LPUART_ICR_IDLECF_Pos = 0x4
	// Bit mask of IDLECF field.
	LPUART_ICR_IDLECF_Msk = 0x10
	// Bit IDLECF.
	LPUART_ICR_IDLECF = 0x10
	// Position of ORECF field.
	LPUART_ICR_ORECF_Pos = 0x3
	// Bit mask of ORECF field.
	LPUART_ICR_ORECF_Msk = 0x8
	// Bit ORECF.
	LPUART_ICR_ORECF = 0x8
	// Position of NCF field.
	LPUART_ICR_NCF_Pos = 0x2
	// Bit mask of NCF field.
	LPUART_ICR_NCF_Msk = 0x4
	// Bit NCF.
	LPUART_ICR_NCF = 0x4
	// Position of FECF field.
	LPUART_ICR_FECF_Pos = 0x1
	// Bit mask of FECF field.
	LPUART_ICR_FECF_Msk = 0x2
	// Bit FECF.
	LPUART_ICR_FECF = 0x2
	// Position of PECF field.
	LPUART_ICR_PECF_Pos = 0x0
	// Bit mask of PECF field.
	LPUART_ICR_PECF_Msk = 0x1
	// Bit PECF.
	LPUART_ICR_PECF = 0x1

	// RDR: Receive data register
	// Position of RDR field.
	LPUART_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	LPUART_RDR_RDR_Msk = 0x1ff

	// TDR: Transmit data register
	// Position of TDR field.
	LPUART_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	LPUART_TDR_TDR_Msk = 0x1ff

	// PRESC: Prescaler register
	// Position of PRESCALER field.
	LPUART_PRESC_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	LPUART_PRESC_PRESCALER_Msk = 0xf
)

// Constants for LTDC: LCD-TFT Controller
const (
	// SSCR: Synchronization Size Configuration Register
	// Position of HSW field.
	LTDC_SSCR_HSW_Pos = 0x10
	// Bit mask of HSW field.
	LTDC_SSCR_HSW_Msk = 0xfff0000
	// Position of VSH field.
	LTDC_SSCR_VSH_Pos = 0x0
	// Bit mask of VSH field.
	LTDC_SSCR_VSH_Msk = 0x7ff

	// BPCR: Back Porch Configuration Register
	// Position of AHBP field.
	LTDC_BPCR_AHBP_Pos = 0x10
	// Bit mask of AHBP field.
	LTDC_BPCR_AHBP_Msk = 0xfff0000
	// Position of AVBP field.
	LTDC_BPCR_AVBP_Pos = 0x0
	// Bit mask of AVBP field.
	LTDC_BPCR_AVBP_Msk = 0x7ff

	// AWCR: Active Width Configuration Register
	// Position of AAW field.
	LTDC_AWCR_AAW_Pos = 0x10
	// Bit mask of AAW field.
	LTDC_AWCR_AAW_Msk = 0xfff0000
	// Position of AAH field.
	LTDC_AWCR_AAH_Pos = 0x0
	// Bit mask of AAH field.
	LTDC_AWCR_AAH_Msk = 0x7ff

	// TWCR: Total Width Configuration Register
	// Position of TOTALW field.
	LTDC_TWCR_TOTALW_Pos = 0x10
	// Bit mask of TOTALW field.
	LTDC_TWCR_TOTALW_Msk = 0xfff0000
	// Position of TOTALH field.
	LTDC_TWCR_TOTALH_Pos = 0x0
	// Bit mask of TOTALH field.
	LTDC_TWCR_TOTALH_Msk = 0x7ff

	// GCR: Global Control Register
	// Position of HSPOL field.
	LTDC_GCR_HSPOL_Pos = 0x1f
	// Bit mask of HSPOL field.
	LTDC_GCR_HSPOL_Msk = 0x80000000
	// Bit HSPOL.
	LTDC_GCR_HSPOL = 0x80000000
	// Horizontal synchronization polarity is active low
	LTDC_GCR_HSPOL_ActiveLow = 0x0
	// Horizontal synchronization polarity is active high
	LTDC_GCR_HSPOL_ActiveHigh = 0x1
	// Position of VSPOL field.
	LTDC_GCR_VSPOL_Pos = 0x1e
	// Bit mask of VSPOL field.
	LTDC_GCR_VSPOL_Msk = 0x40000000
	// Bit VSPOL.
	LTDC_GCR_VSPOL = 0x40000000
	// Vertical synchronization polarity is active low
	LTDC_GCR_VSPOL_ActiveLow = 0x0
	// Vertical synchronization polarity is active high
	LTDC_GCR_VSPOL_ActiveHigh = 0x1
	// Position of DEPOL field.
	LTDC_GCR_DEPOL_Pos = 0x1d
	// Bit mask of DEPOL field.
	LTDC_GCR_DEPOL_Msk = 0x20000000
	// Bit DEPOL.
	LTDC_GCR_DEPOL = 0x20000000
	// Data enable polarity is active low
	LTDC_GCR_DEPOL_ActiveLow = 0x0
	// Data enable polarity is active high
	LTDC_GCR_DEPOL_ActiveHigh = 0x1
	// Position of PCPOL field.
	LTDC_GCR_PCPOL_Pos = 0x1c
	// Bit mask of PCPOL field.
	LTDC_GCR_PCPOL_Msk = 0x10000000
	// Bit PCPOL.
	LTDC_GCR_PCPOL = 0x10000000
	// Pixel clock on rising edge
	LTDC_GCR_PCPOL_RisingEdge = 0x0
	// Pixel clock on falling edge
	LTDC_GCR_PCPOL_FallingEdge = 0x1
	// Position of DEN field.
	LTDC_GCR_DEN_Pos = 0x10
	// Bit mask of DEN field.
	LTDC_GCR_DEN_Msk = 0x10000
	// Bit DEN.
	LTDC_GCR_DEN = 0x10000
	// Dither disabled
	LTDC_GCR_DEN_Disabled = 0x0
	// Dither enabled
	LTDC_GCR_DEN_Enabled = 0x1
	// Position of DRW field.
	LTDC_GCR_DRW_Pos = 0xc
	// Bit mask of DRW field.
	LTDC_GCR_DRW_Msk = 0x7000
	// Position of DGW field.
	LTDC_GCR_DGW_Pos = 0x8
	// Bit mask of DGW field.
	LTDC_GCR_DGW_Msk = 0x700
	// Position of DBW field.
	LTDC_GCR_DBW_Pos = 0x4
	// Bit mask of DBW field.
	LTDC_GCR_DBW_Msk = 0x70
	// Position of LTDCEN field.
	LTDC_GCR_LTDCEN_Pos = 0x0
	// Bit mask of LTDCEN field.
	LTDC_GCR_LTDCEN_Msk = 0x1
	// Bit LTDCEN.
	LTDC_GCR_LTDCEN = 0x1
	// LCD-TFT controller disabled
	LTDC_GCR_LTDCEN_Disabled = 0x0
	// LCD-TFT controller enabled
	LTDC_GCR_LTDCEN_Enabled = 0x1

	// SRCR: Shadow Reload Configuration Register
	// Position of VBR field.
	LTDC_SRCR_VBR_Pos = 0x1
	// Bit mask of VBR field.
	LTDC_SRCR_VBR_Msk = 0x2
	// Bit VBR.
	LTDC_SRCR_VBR = 0x2
	// The shadow registers are reloaded during the vertical blanking period (at the beginning of the first line after the active display area).
	LTDC_SRCR_VBR_Reload = 0x1
	// This bit is set by software and cleared only by hardware after reload (it cannot be cleared through register write once it is set)
	LTDC_SRCR_VBR_NoEffect = 0x0
	// Position of IMR field.
	LTDC_SRCR_IMR_Pos = 0x0
	// Bit mask of IMR field.
	LTDC_SRCR_IMR_Msk = 0x1
	// Bit IMR.
	LTDC_SRCR_IMR = 0x1
	// The shadow registers are reloaded immediately. This bit is set by software and cleared only by hardware after reload
	LTDC_SRCR_IMR_Reload = 0x1
	// This bit is set by software and cleared only by hardware after reload (it cannot be cleared through register write once it is set)
	LTDC_SRCR_IMR_NoEffect = 0x0

	// BCCR: Background Color Configuration Register
	// Position of BCBLUE field.
	LTDC_BCCR_BCBLUE_Pos = 0x0
	// Bit mask of BCBLUE field.
	LTDC_BCCR_BCBLUE_Msk = 0xff
	// Position of BCGREEN field.
	LTDC_BCCR_BCGREEN_Pos = 0x8
	// Bit mask of BCGREEN field.
	LTDC_BCCR_BCGREEN_Msk = 0xff00
	// Position of BCRED field.
	LTDC_BCCR_BCRED_Pos = 0x10
	// Bit mask of BCRED field.
	LTDC_BCCR_BCRED_Msk = 0xff0000

	// IER: Interrupt Enable Register
	// Position of RRIE field.
	LTDC_IER_RRIE_Pos = 0x3
	// Bit mask of RRIE field.
	LTDC_IER_RRIE_Msk = 0x8
	// Bit RRIE.
	LTDC_IER_RRIE = 0x8
	// Register reload interrupt disabled
	LTDC_IER_RRIE_Disabled = 0x0
	// Register reload interrupt enabled
	LTDC_IER_RRIE_Enabled = 0x1
	// Position of TERRIE field.
	LTDC_IER_TERRIE_Pos = 0x2
	// Bit mask of TERRIE field.
	LTDC_IER_TERRIE_Msk = 0x4
	// Bit TERRIE.
	LTDC_IER_TERRIE = 0x4
	// Transfer error interrupt disabled
	LTDC_IER_TERRIE_Disabled = 0x0
	// Transfer error interrupt enabled
	LTDC_IER_TERRIE_Enabled = 0x1
	// Position of FUIE field.
	LTDC_IER_FUIE_Pos = 0x1
	// Bit mask of FUIE field.
	LTDC_IER_FUIE_Msk = 0x2
	// Bit FUIE.
	LTDC_IER_FUIE = 0x2
	// FIFO underrun interrupt disabled
	LTDC_IER_FUIE_Disabled = 0x0
	// FIFO underrun interrupt enabled
	LTDC_IER_FUIE_Enabled = 0x1
	// Position of LIE field.
	LTDC_IER_LIE_Pos = 0x0
	// Bit mask of LIE field.
	LTDC_IER_LIE_Msk = 0x1
	// Bit LIE.
	LTDC_IER_LIE = 0x1
	// Line interrupt disabled
	LTDC_IER_LIE_Disabled = 0x0
	// Line interrupt enabled
	LTDC_IER_LIE_Enabled = 0x1

	// ISR: Interrupt Status Register
	// Position of RRIF field.
	LTDC_ISR_RRIF_Pos = 0x3
	// Bit mask of RRIF field.
	LTDC_ISR_RRIF_Msk = 0x8
	// Bit RRIF.
	LTDC_ISR_RRIF = 0x8
	// No register reload
	LTDC_ISR_RRIF_NoReload = 0x0
	// Register reload interrupt generated when a vertical blanking reload occurs (and the first line after the active area is reached)
	LTDC_ISR_RRIF_Reload = 0x1
	// Position of TERRIF field.
	LTDC_ISR_TERRIF_Pos = 0x2
	// Bit mask of TERRIF field.
	LTDC_ISR_TERRIF_Msk = 0x4
	// Bit TERRIF.
	LTDC_ISR_TERRIF = 0x4
	// No transfer error
	LTDC_ISR_TERRIF_NoError = 0x0
	// Transfer error interrupt generated when a bus error occurs
	LTDC_ISR_TERRIF_Error = 0x1
	// Position of FUIF field.
	LTDC_ISR_FUIF_Pos = 0x1
	// Bit mask of FUIF field.
	LTDC_ISR_FUIF_Msk = 0x2
	// Bit FUIF.
	LTDC_ISR_FUIF = 0x2
	// No FIFO underrun
	LTDC_ISR_FUIF_NoUnderrun = 0x0
	// FIFO underrun interrupt generated, if one of the layer FIFOs is empty and pixel data is read from the FIFO
	LTDC_ISR_FUIF_Underrun = 0x1
	// Position of LIF field.
	LTDC_ISR_LIF_Pos = 0x0
	// Bit mask of LIF field.
	LTDC_ISR_LIF_Msk = 0x1
	// Bit LIF.
	LTDC_ISR_LIF = 0x1
	// Programmed line not reached
	LTDC_ISR_LIF_NotReached = 0x0
	// Line interrupt generated when a programmed line is reached
	LTDC_ISR_LIF_Reached = 0x1

	// ICR: Interrupt Clear Register
	// Position of CRRIF field.
	LTDC_ICR_CRRIF_Pos = 0x3
	// Bit mask of CRRIF field.
	LTDC_ICR_CRRIF_Msk = 0x8
	// Bit CRRIF.
	LTDC_ICR_CRRIF = 0x8
	// Clears the RRIF flag in the ISR register
	LTDC_ICR_CRRIF_Clear = 0x1
	// Position of CTERRIF field.
	LTDC_ICR_CTERRIF_Pos = 0x2
	// Bit mask of CTERRIF field.
	LTDC_ICR_CTERRIF_Msk = 0x4
	// Bit CTERRIF.
	LTDC_ICR_CTERRIF = 0x4
	// Clears the TERRIF flag in the ISR register
	LTDC_ICR_CTERRIF_Clear = 0x1
	// Position of CFUIF field.
	LTDC_ICR_CFUIF_Pos = 0x1
	// Bit mask of CFUIF field.
	LTDC_ICR_CFUIF_Msk = 0x2
	// Bit CFUIF.
	LTDC_ICR_CFUIF = 0x2
	// Clears the FUIF flag in the ISR register
	LTDC_ICR_CFUIF_Clear = 0x1
	// Position of CLIF field.
	LTDC_ICR_CLIF_Pos = 0x0
	// Bit mask of CLIF field.
	LTDC_ICR_CLIF_Msk = 0x1
	// Bit CLIF.
	LTDC_ICR_CLIF = 0x1
	// Clears the LIF flag in the ISR register
	LTDC_ICR_CLIF_Clear = 0x1

	// LIPCR: Line Interrupt Position Configuration Register
	// Position of LIPOS field.
	LTDC_LIPCR_LIPOS_Pos = 0x0
	// Bit mask of LIPOS field.
	LTDC_LIPCR_LIPOS_Msk = 0x7ff

	// CPSR: Current Position Status Register
	// Position of CXPOS field.
	LTDC_CPSR_CXPOS_Pos = 0x10
	// Bit mask of CXPOS field.
	LTDC_CPSR_CXPOS_Msk = 0xffff0000
	// Position of CYPOS field.
	LTDC_CPSR_CYPOS_Pos = 0x0
	// Bit mask of CYPOS field.
	LTDC_CPSR_CYPOS_Msk = 0xffff

	// CDSR: Current Display Status Register
	// Position of HSYNCS field.
	LTDC_CDSR_HSYNCS_Pos = 0x3
	// Bit mask of HSYNCS field.
	LTDC_CDSR_HSYNCS_Msk = 0x8
	// Bit HSYNCS.
	LTDC_CDSR_HSYNCS = 0x8
	// Currently not in HSYNC phase
	LTDC_CDSR_HSYNCS_NotActive = 0x0
	// Currently in HSYNC phase
	LTDC_CDSR_HSYNCS_Active = 0x1
	// Position of VSYNCS field.
	LTDC_CDSR_VSYNCS_Pos = 0x2
	// Bit mask of VSYNCS field.
	LTDC_CDSR_VSYNCS_Msk = 0x4
	// Bit VSYNCS.
	LTDC_CDSR_VSYNCS = 0x4
	// Currently not in VSYNC phase
	LTDC_CDSR_VSYNCS_NotActive = 0x0
	// Currently in VSYNC phase
	LTDC_CDSR_VSYNCS_Active = 0x1
	// Position of HDES field.
	LTDC_CDSR_HDES_Pos = 0x1
	// Bit mask of HDES field.
	LTDC_CDSR_HDES_Msk = 0x2
	// Bit HDES.
	LTDC_CDSR_HDES = 0x2
	// Currently not in horizontal Data Enable phase
	LTDC_CDSR_HDES_NotActive = 0x0
	// Currently in horizontal Data Enable phase
	LTDC_CDSR_HDES_Active = 0x1
	// Position of VDES field.
	LTDC_CDSR_VDES_Pos = 0x0
	// Bit mask of VDES field.
	LTDC_CDSR_VDES_Msk = 0x1
	// Bit VDES.
	LTDC_CDSR_VDES = 0x1
	// Currently not in vertical Data Enable phase
	LTDC_CDSR_VDES_NotActive = 0x0
	// Currently in vertical Data Enable phase
	LTDC_CDSR_VDES_Active = 0x1

	// LAYER.CR: Layerx Control Register
	// Position of CLUTEN field.
	LTDC_LAYER_CR_CLUTEN_Pos = 0x4
	// Bit mask of CLUTEN field.
	LTDC_LAYER_CR_CLUTEN_Msk = 0x10
	// Bit CLUTEN.
	LTDC_LAYER_CR_CLUTEN = 0x10
	// Color look-up table disabled
	LTDC_LAYER_CR_CLUTEN_Disabled = 0x0
	// Color look-up table enabled
	LTDC_LAYER_CR_CLUTEN_Enabled = 0x1
	// Position of COLKEN field.
	LTDC_LAYER_CR_COLKEN_Pos = 0x1
	// Bit mask of COLKEN field.
	LTDC_LAYER_CR_COLKEN_Msk = 0x2
	// Bit COLKEN.
	LTDC_LAYER_CR_COLKEN = 0x2
	// Color keying disabled
	LTDC_LAYER_CR_COLKEN_Disabled = 0x0
	// Color keying enabled
	LTDC_LAYER_CR_COLKEN_Enabled = 0x1
	// Position of LEN field.
	LTDC_LAYER_CR_LEN_Pos = 0x0
	// Bit mask of LEN field.
	LTDC_LAYER_CR_LEN_Msk = 0x1
	// Bit LEN.
	LTDC_LAYER_CR_LEN = 0x1
	// Layer disabled
	LTDC_LAYER_CR_LEN_Disabled = 0x0
	// Layer enabled
	LTDC_LAYER_CR_LEN_Enabled = 0x1

	// LAYER.WHPCR: Layerx Window Horizontal Position Configuration Register
	// Position of WHSPPOS field.
	LTDC_LAYER_WHPCR_WHSPPOS_Pos = 0x10
	// Bit mask of WHSPPOS field.
	LTDC_LAYER_WHPCR_WHSPPOS_Msk = 0xfff0000
	// Position of WHSTPOS field.
	LTDC_LAYER_WHPCR_WHSTPOS_Pos = 0x0
	// Bit mask of WHSTPOS field.
	LTDC_LAYER_WHPCR_WHSTPOS_Msk = 0xfff

	// LAYER.WVPCR: Layerx Window Vertical Position Configuration Register
	// Position of WVSPPOS field.
	LTDC_LAYER_WVPCR_WVSPPOS_Pos = 0x10
	// Bit mask of WVSPPOS field.
	LTDC_LAYER_WVPCR_WVSPPOS_Msk = 0x7ff0000
	// Position of WVSTPOS field.
	LTDC_LAYER_WVPCR_WVSTPOS_Pos = 0x0
	// Bit mask of WVSTPOS field.
	LTDC_LAYER_WVPCR_WVSTPOS_Msk = 0x7ff

	// LAYER.CKCR: Layerx Color Keying Configuration Register
	// Position of CKRED field.
	LTDC_LAYER_CKCR_CKRED_Pos = 0x10
	// Bit mask of CKRED field.
	LTDC_LAYER_CKCR_CKRED_Msk = 0xff0000
	// Position of CKGREEN field.
	LTDC_LAYER_CKCR_CKGREEN_Pos = 0x8
	// Bit mask of CKGREEN field.
	LTDC_LAYER_CKCR_CKGREEN_Msk = 0xff00
	// Position of CKBLUE field.
	LTDC_LAYER_CKCR_CKBLUE_Pos = 0x0
	// Bit mask of CKBLUE field.
	LTDC_LAYER_CKCR_CKBLUE_Msk = 0xff

	// LAYER.PFCR: Layerx Pixel Format Configuration Register
	// Position of PF field.
	LTDC_LAYER_PFCR_PF_Pos = 0x0
	// Bit mask of PF field.
	LTDC_LAYER_PFCR_PF_Msk = 0x7
	// ARGB8888
	LTDC_LAYER_PFCR_PF_ARGB8888 = 0x0
	// RGB888
	LTDC_LAYER_PFCR_PF_RGB888 = 0x1
	// RGB565
	LTDC_LAYER_PFCR_PF_RGB565 = 0x2
	// ARGB1555
	LTDC_LAYER_PFCR_PF_ARGB1555 = 0x3
	// ARGB4444
	LTDC_LAYER_PFCR_PF_ARGB4444 = 0x4
	// L8 (8-bit luminance)
	LTDC_LAYER_PFCR_PF_L8 = 0x5
	// AL44 (4-bit alpha, 4-bit luminance)
	LTDC_LAYER_PFCR_PF_AL44 = 0x6
	// AL88 (8-bit alpha, 8-bit luminance)
	LTDC_LAYER_PFCR_PF_AL88 = 0x7

	// LAYER.CACR: Layerx Constant Alpha Configuration Register
	// Position of CONSTA field.
	LTDC_LAYER_CACR_CONSTA_Pos = 0x0
	// Bit mask of CONSTA field.
	LTDC_LAYER_CACR_CONSTA_Msk = 0xff

	// LAYER.DCCR: Layerx Default Color Configuration Register
	// Position of DCALPHA field.
	LTDC_LAYER_DCCR_DCALPHA_Pos = 0x18
	// Bit mask of DCALPHA field.
	LTDC_LAYER_DCCR_DCALPHA_Msk = 0xff000000
	// Position of DCRED field.
	LTDC_LAYER_DCCR_DCRED_Pos = 0x10
	// Bit mask of DCRED field.
	LTDC_LAYER_DCCR_DCRED_Msk = 0xff0000
	// Position of DCGREEN field.
	LTDC_LAYER_DCCR_DCGREEN_Pos = 0x8
	// Bit mask of DCGREEN field.
	LTDC_LAYER_DCCR_DCGREEN_Msk = 0xff00
	// Position of DCBLUE field.
	LTDC_LAYER_DCCR_DCBLUE_Pos = 0x0
	// Bit mask of DCBLUE field.
	LTDC_LAYER_DCCR_DCBLUE_Msk = 0xff

	// LAYER.BFCR: Layerx Blending Factors Configuration Register
	// Position of BF1 field.
	LTDC_LAYER_BFCR_BF1_Pos = 0x8
	// Bit mask of BF1 field.
	LTDC_LAYER_BFCR_BF1_Msk = 0x700
	// BF1 = constant alpha
	LTDC_LAYER_BFCR_BF1_Constant = 0x4
	// BF1 = pixel alpha * constant alpha
	LTDC_LAYER_BFCR_BF1_Pixel = 0x6
	// Position of BF2 field.
	LTDC_LAYER_BFCR_BF2_Pos = 0x0
	// Bit mask of BF2 field.
	LTDC_LAYER_BFCR_BF2_Msk = 0x7
	// BF2 = 1 - constant alpha
	LTDC_LAYER_BFCR_BF2_Constant = 0x5
	// BF2 = 1 - pixel alpha * constant alpha
	LTDC_LAYER_BFCR_BF2_Pixel = 0x7

	// LAYER.CFBAR: Layerx Color Frame Buffer Address Register
	// Position of CFBADD field.
	LTDC_LAYER_CFBAR_CFBADD_Pos = 0x0
	// Bit mask of CFBADD field.
	LTDC_LAYER_CFBAR_CFBADD_Msk = 0xffffffff

	// LAYER.CFBLR: Layerx Color Frame Buffer Length Register
	// Position of CFBP field.
	LTDC_LAYER_CFBLR_CFBP_Pos = 0x10
	// Bit mask of CFBP field.
	LTDC_LAYER_CFBLR_CFBP_Msk = 0x1fff0000
	// Position of CFBLL field.
	LTDC_LAYER_CFBLR_CFBLL_Pos = 0x0
	// Bit mask of CFBLL field.
	LTDC_LAYER_CFBLR_CFBLL_Msk = 0x1fff

	// LAYER.CFBLNR: Layerx ColorFrame Buffer Line Number Register
	// Position of CFBLNBR field.
	LTDC_LAYER_CFBLNR_CFBLNBR_Pos = 0x0
	// Bit mask of CFBLNBR field.
	LTDC_LAYER_CFBLNR_CFBLNBR_Msk = 0x7ff

	// LAYER.CLUTWR: Layerx CLUT Write Register
	// Position of CLUTADD field.
	LTDC_LAYER_CLUTWR_CLUTADD_Pos = 0x18
	// Bit mask of CLUTADD field.
	LTDC_LAYER_CLUTWR_CLUTADD_Msk = 0xff000000
	// Position of RED field.
	LTDC_LAYER_CLUTWR_RED_Pos = 0x10
	// Bit mask of RED field.
	LTDC_LAYER_CLUTWR_RED_Msk = 0xff0000
	// Position of GREEN field.
	LTDC_LAYER_CLUTWR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LTDC_LAYER_CLUTWR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	LTDC_LAYER_CLUTWR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	LTDC_LAYER_CLUTWR_BLUE_Msk = 0xff
)

// Constants for MDIOS: Management data input/output slave
const (
	// CR: MDIOS configuration register
	// Position of EN field.
	MDIOS_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	MDIOS_CR_EN_Msk = 0x1
	// Bit EN.
	MDIOS_CR_EN = 0x1
	// Position of WRIE field.
	MDIOS_CR_WRIE_Pos = 0x1
	// Bit mask of WRIE field.
	MDIOS_CR_WRIE_Msk = 0x2
	// Bit WRIE.
	MDIOS_CR_WRIE = 0x2
	// Position of RDIE field.
	MDIOS_CR_RDIE_Pos = 0x2
	// Bit mask of RDIE field.
	MDIOS_CR_RDIE_Msk = 0x4
	// Bit RDIE.
	MDIOS_CR_RDIE = 0x4
	// Position of EIE field.
	MDIOS_CR_EIE_Pos = 0x3
	// Bit mask of EIE field.
	MDIOS_CR_EIE_Msk = 0x8
	// Bit EIE.
	MDIOS_CR_EIE = 0x8
	// Position of DPC field.
	MDIOS_CR_DPC_Pos = 0x7
	// Bit mask of DPC field.
	MDIOS_CR_DPC_Msk = 0x80
	// Bit DPC.
	MDIOS_CR_DPC = 0x80
	// Position of PORT_ADDRESS field.
	MDIOS_CR_PORT_ADDRESS_Pos = 0x8
	// Bit mask of PORT_ADDRESS field.
	MDIOS_CR_PORT_ADDRESS_Msk = 0x1f00

	// WRFR: MDIOS write flag register
	// Position of WRF field.
	MDIOS_WRFR_WRF_Pos = 0x0
	// Bit mask of WRF field.
	MDIOS_WRFR_WRF_Msk = 0xffffffff

	// CWRFR: MDIOS clear write flag register
	// Position of CWRF field.
	MDIOS_CWRFR_CWRF_Pos = 0x0
	// Bit mask of CWRF field.
	MDIOS_CWRFR_CWRF_Msk = 0xffffffff

	// RDFR: MDIOS read flag register
	// Position of RDF field.
	MDIOS_RDFR_RDF_Pos = 0x0
	// Bit mask of RDF field.
	MDIOS_RDFR_RDF_Msk = 0xffffffff

	// CRDFR: MDIOS clear read flag register
	// Position of CRDF field.
	MDIOS_CRDFR_CRDF_Pos = 0x0
	// Bit mask of CRDF field.
	MDIOS_CRDFR_CRDF_Msk = 0xffffffff

	// SR: MDIOS status register
	// Position of PERF field.
	MDIOS_SR_PERF_Pos = 0x0
	// Bit mask of PERF field.
	MDIOS_SR_PERF_Msk = 0x1
	// Bit PERF.
	MDIOS_SR_PERF = 0x1
	// Position of SERF field.
	MDIOS_SR_SERF_Pos = 0x1
	// Bit mask of SERF field.
	MDIOS_SR_SERF_Msk = 0x2
	// Bit SERF.
	MDIOS_SR_SERF = 0x2
	// Position of TERF field.
	MDIOS_SR_TERF_Pos = 0x2
	// Bit mask of TERF field.
	MDIOS_SR_TERF_Msk = 0x4
	// Bit TERF.
	MDIOS_SR_TERF = 0x4

	// CLRFR: MDIOS clear flag register
	// Position of CPERF field.
	MDIOS_CLRFR_CPERF_Pos = 0x0
	// Bit mask of CPERF field.
	MDIOS_CLRFR_CPERF_Msk = 0x1
	// Bit CPERF.
	MDIOS_CLRFR_CPERF = 0x1
	// Position of CSERF field.
	MDIOS_CLRFR_CSERF_Pos = 0x1
	// Bit mask of CSERF field.
	MDIOS_CLRFR_CSERF_Msk = 0x2
	// Bit CSERF.
	MDIOS_CLRFR_CSERF = 0x2
	// Position of CTERF field.
	MDIOS_CLRFR_CTERF_Pos = 0x2
	// Bit mask of CTERF field.
	MDIOS_CLRFR_CTERF_Msk = 0x4
	// Bit CTERF.
	MDIOS_CLRFR_CTERF = 0x4

	// DINR0: MDIOS input data register 0
	// Position of DIN0 field.
	MDIOS_DINR0_DIN0_Pos = 0x0
	// Bit mask of DIN0 field.
	MDIOS_DINR0_DIN0_Msk = 0xffff

	// DINR1: MDIOS input data register 1
	// Position of DIN1 field.
	MDIOS_DINR1_DIN1_Pos = 0x0
	// Bit mask of DIN1 field.
	MDIOS_DINR1_DIN1_Msk = 0xffff

	// DINR2: MDIOS input data register 2
	// Position of DIN2 field.
	MDIOS_DINR2_DIN2_Pos = 0x0
	// Bit mask of DIN2 field.
	MDIOS_DINR2_DIN2_Msk = 0xffff

	// DINR3: MDIOS input data register 3
	// Position of DIN3 field.
	MDIOS_DINR3_DIN3_Pos = 0x0
	// Bit mask of DIN3 field.
	MDIOS_DINR3_DIN3_Msk = 0xffff

	// DINR4: MDIOS input data register 4
	// Position of DIN4 field.
	MDIOS_DINR4_DIN4_Pos = 0x0
	// Bit mask of DIN4 field.
	MDIOS_DINR4_DIN4_Msk = 0xffff

	// DINR5: MDIOS input data register 5
	// Position of DIN5 field.
	MDIOS_DINR5_DIN5_Pos = 0x0
	// Bit mask of DIN5 field.
	MDIOS_DINR5_DIN5_Msk = 0xffff

	// DINR6: MDIOS input data register 6
	// Position of DIN6 field.
	MDIOS_DINR6_DIN6_Pos = 0x0
	// Bit mask of DIN6 field.
	MDIOS_DINR6_DIN6_Msk = 0xffff

	// DINR7: MDIOS input data register 7
	// Position of DIN7 field.
	MDIOS_DINR7_DIN7_Pos = 0x0
	// Bit mask of DIN7 field.
	MDIOS_DINR7_DIN7_Msk = 0xffff

	// DINR8: MDIOS input data register 8
	// Position of DIN8 field.
	MDIOS_DINR8_DIN8_Pos = 0x0
	// Bit mask of DIN8 field.
	MDIOS_DINR8_DIN8_Msk = 0xffff

	// DINR9: MDIOS input data register 9
	// Position of DIN9 field.
	MDIOS_DINR9_DIN9_Pos = 0x0
	// Bit mask of DIN9 field.
	MDIOS_DINR9_DIN9_Msk = 0xffff

	// DINR10: MDIOS input data register 10
	// Position of DIN10 field.
	MDIOS_DINR10_DIN10_Pos = 0x0
	// Bit mask of DIN10 field.
	MDIOS_DINR10_DIN10_Msk = 0xffff

	// DINR11: MDIOS input data register 11
	// Position of DIN11 field.
	MDIOS_DINR11_DIN11_Pos = 0x0
	// Bit mask of DIN11 field.
	MDIOS_DINR11_DIN11_Msk = 0xffff

	// DINR12: MDIOS input data register 12
	// Position of DIN12 field.
	MDIOS_DINR12_DIN12_Pos = 0x0
	// Bit mask of DIN12 field.
	MDIOS_DINR12_DIN12_Msk = 0xffff

	// DINR13: MDIOS input data register 13
	// Position of DIN13 field.
	MDIOS_DINR13_DIN13_Pos = 0x0
	// Bit mask of DIN13 field.
	MDIOS_DINR13_DIN13_Msk = 0xffff

	// DINR14: MDIOS input data register 14
	// Position of DIN14 field.
	MDIOS_DINR14_DIN14_Pos = 0x0
	// Bit mask of DIN14 field.
	MDIOS_DINR14_DIN14_Msk = 0xffff

	// DINR15: MDIOS input data register 15
	// Position of DIN15 field.
	MDIOS_DINR15_DIN15_Pos = 0x0
	// Bit mask of DIN15 field.
	MDIOS_DINR15_DIN15_Msk = 0xffff

	// DINR16: MDIOS input data register 16
	// Position of DIN16 field.
	MDIOS_DINR16_DIN16_Pos = 0x0
	// Bit mask of DIN16 field.
	MDIOS_DINR16_DIN16_Msk = 0xffff

	// DINR17: MDIOS input data register 17
	// Position of DIN17 field.
	MDIOS_DINR17_DIN17_Pos = 0x0
	// Bit mask of DIN17 field.
	MDIOS_DINR17_DIN17_Msk = 0xffff

	// DINR18: MDIOS input data register 18
	// Position of DIN18 field.
	MDIOS_DINR18_DIN18_Pos = 0x0
	// Bit mask of DIN18 field.
	MDIOS_DINR18_DIN18_Msk = 0xffff

	// DINR19: MDIOS input data register 19
	// Position of DIN19 field.
	MDIOS_DINR19_DIN19_Pos = 0x0
	// Bit mask of DIN19 field.
	MDIOS_DINR19_DIN19_Msk = 0xffff

	// DINR20: MDIOS input data register 20
	// Position of DIN20 field.
	MDIOS_DINR20_DIN20_Pos = 0x0
	// Bit mask of DIN20 field.
	MDIOS_DINR20_DIN20_Msk = 0xffff

	// DINR21: MDIOS input data register 21
	// Position of DIN21 field.
	MDIOS_DINR21_DIN21_Pos = 0x0
	// Bit mask of DIN21 field.
	MDIOS_DINR21_DIN21_Msk = 0xffff

	// DINR22: MDIOS input data register 22
	// Position of DIN22 field.
	MDIOS_DINR22_DIN22_Pos = 0x0
	// Bit mask of DIN22 field.
	MDIOS_DINR22_DIN22_Msk = 0xffff

	// DINR23: MDIOS input data register 23
	// Position of DIN23 field.
	MDIOS_DINR23_DIN23_Pos = 0x0
	// Bit mask of DIN23 field.
	MDIOS_DINR23_DIN23_Msk = 0xffff

	// DINR24: MDIOS input data register 24
	// Position of DIN24 field.
	MDIOS_DINR24_DIN24_Pos = 0x0
	// Bit mask of DIN24 field.
	MDIOS_DINR24_DIN24_Msk = 0xffff

	// DINR25: MDIOS input data register 25
	// Position of DIN25 field.
	MDIOS_DINR25_DIN25_Pos = 0x0
	// Bit mask of DIN25 field.
	MDIOS_DINR25_DIN25_Msk = 0xffff

	// DINR26: MDIOS input data register 26
	// Position of DIN26 field.
	MDIOS_DINR26_DIN26_Pos = 0x0
	// Bit mask of DIN26 field.
	MDIOS_DINR26_DIN26_Msk = 0xffff

	// DINR27: MDIOS input data register 27
	// Position of DIN27 field.
	MDIOS_DINR27_DIN27_Pos = 0x0
	// Bit mask of DIN27 field.
	MDIOS_DINR27_DIN27_Msk = 0xffff

	// DINR28: MDIOS input data register 28
	// Position of DIN28 field.
	MDIOS_DINR28_DIN28_Pos = 0x0
	// Bit mask of DIN28 field.
	MDIOS_DINR28_DIN28_Msk = 0xffff

	// DINR29: MDIOS input data register 29
	// Position of DIN29 field.
	MDIOS_DINR29_DIN29_Pos = 0x0
	// Bit mask of DIN29 field.
	MDIOS_DINR29_DIN29_Msk = 0xffff

	// DINR30: MDIOS input data register 30
	// Position of DIN30 field.
	MDIOS_DINR30_DIN30_Pos = 0x0
	// Bit mask of DIN30 field.
	MDIOS_DINR30_DIN30_Msk = 0xffff

	// DINR31: MDIOS input data register 31
	// Position of DIN31 field.
	MDIOS_DINR31_DIN31_Pos = 0x0
	// Bit mask of DIN31 field.
	MDIOS_DINR31_DIN31_Msk = 0xffff

	// DOUTR0: MDIOS output data register 0
	// Position of DOUT0 field.
	MDIOS_DOUTR0_DOUT0_Pos = 0x0
	// Bit mask of DOUT0 field.
	MDIOS_DOUTR0_DOUT0_Msk = 0xffff

	// DOUTR1: MDIOS output data register 1
	// Position of DOUT1 field.
	MDIOS_DOUTR1_DOUT1_Pos = 0x0
	// Bit mask of DOUT1 field.
	MDIOS_DOUTR1_DOUT1_Msk = 0xffff

	// DOUTR2: MDIOS output data register 2
	// Position of DOUT2 field.
	MDIOS_DOUTR2_DOUT2_Pos = 0x0
	// Bit mask of DOUT2 field.
	MDIOS_DOUTR2_DOUT2_Msk = 0xffff

	// DOUTR3: MDIOS output data register 3
	// Position of DOUT3 field.
	MDIOS_DOUTR3_DOUT3_Pos = 0x0
	// Bit mask of DOUT3 field.
	MDIOS_DOUTR3_DOUT3_Msk = 0xffff

	// DOUTR4: MDIOS output data register 4
	// Position of DOUT4 field.
	MDIOS_DOUTR4_DOUT4_Pos = 0x0
	// Bit mask of DOUT4 field.
	MDIOS_DOUTR4_DOUT4_Msk = 0xffff

	// DOUTR5: MDIOS output data register 5
	// Position of DOUT5 field.
	MDIOS_DOUTR5_DOUT5_Pos = 0x0
	// Bit mask of DOUT5 field.
	MDIOS_DOUTR5_DOUT5_Msk = 0xffff

	// DOUTR6: MDIOS output data register 6
	// Position of DOUT6 field.
	MDIOS_DOUTR6_DOUT6_Pos = 0x0
	// Bit mask of DOUT6 field.
	MDIOS_DOUTR6_DOUT6_Msk = 0xffff

	// DOUTR7: MDIOS output data register 7
	// Position of DOUT7 field.
	MDIOS_DOUTR7_DOUT7_Pos = 0x0
	// Bit mask of DOUT7 field.
	MDIOS_DOUTR7_DOUT7_Msk = 0xffff

	// DOUTR8: MDIOS output data register 8
	// Position of DOUT8 field.
	MDIOS_DOUTR8_DOUT8_Pos = 0x0
	// Bit mask of DOUT8 field.
	MDIOS_DOUTR8_DOUT8_Msk = 0xffff

	// DOUTR9: MDIOS output data register 9
	// Position of DOUT9 field.
	MDIOS_DOUTR9_DOUT9_Pos = 0x0
	// Bit mask of DOUT9 field.
	MDIOS_DOUTR9_DOUT9_Msk = 0xffff

	// DOUTR10: MDIOS output data register 10
	// Position of DOUT10 field.
	MDIOS_DOUTR10_DOUT10_Pos = 0x0
	// Bit mask of DOUT10 field.
	MDIOS_DOUTR10_DOUT10_Msk = 0xffff

	// DOUTR11: MDIOS output data register 11
	// Position of DOUT11 field.
	MDIOS_DOUTR11_DOUT11_Pos = 0x0
	// Bit mask of DOUT11 field.
	MDIOS_DOUTR11_DOUT11_Msk = 0xffff

	// DOUTR12: MDIOS output data register 12
	// Position of DOUT12 field.
	MDIOS_DOUTR12_DOUT12_Pos = 0x0
	// Bit mask of DOUT12 field.
	MDIOS_DOUTR12_DOUT12_Msk = 0xffff

	// DOUTR13: MDIOS output data register 13
	// Position of DOUT13 field.
	MDIOS_DOUTR13_DOUT13_Pos = 0x0
	// Bit mask of DOUT13 field.
	MDIOS_DOUTR13_DOUT13_Msk = 0xffff

	// DOUTR14: MDIOS output data register 14
	// Position of DOUT14 field.
	MDIOS_DOUTR14_DOUT14_Pos = 0x0
	// Bit mask of DOUT14 field.
	MDIOS_DOUTR14_DOUT14_Msk = 0xffff

	// DOUTR15: MDIOS output data register 15
	// Position of DOUT15 field.
	MDIOS_DOUTR15_DOUT15_Pos = 0x0
	// Bit mask of DOUT15 field.
	MDIOS_DOUTR15_DOUT15_Msk = 0xffff

	// DOUTR16: MDIOS output data register 16
	// Position of DOUT16 field.
	MDIOS_DOUTR16_DOUT16_Pos = 0x0
	// Bit mask of DOUT16 field.
	MDIOS_DOUTR16_DOUT16_Msk = 0xffff

	// DOUTR17: MDIOS output data register 17
	// Position of DOUT17 field.
	MDIOS_DOUTR17_DOUT17_Pos = 0x0
	// Bit mask of DOUT17 field.
	MDIOS_DOUTR17_DOUT17_Msk = 0xffff

	// DOUTR18: MDIOS output data register 18
	// Position of DOUT18 field.
	MDIOS_DOUTR18_DOUT18_Pos = 0x0
	// Bit mask of DOUT18 field.
	MDIOS_DOUTR18_DOUT18_Msk = 0xffff

	// DOUTR19: MDIOS output data register 19
	// Position of DOUT19 field.
	MDIOS_DOUTR19_DOUT19_Pos = 0x0
	// Bit mask of DOUT19 field.
	MDIOS_DOUTR19_DOUT19_Msk = 0xffff

	// DOUTR20: MDIOS output data register 20
	// Position of DOUT20 field.
	MDIOS_DOUTR20_DOUT20_Pos = 0x0
	// Bit mask of DOUT20 field.
	MDIOS_DOUTR20_DOUT20_Msk = 0xffff

	// DOUTR21: MDIOS output data register 21
	// Position of DOUT21 field.
	MDIOS_DOUTR21_DOUT21_Pos = 0x0
	// Bit mask of DOUT21 field.
	MDIOS_DOUTR21_DOUT21_Msk = 0xffff

	// DOUTR22: MDIOS output data register 22
	// Position of DOUT22 field.
	MDIOS_DOUTR22_DOUT22_Pos = 0x0
	// Bit mask of DOUT22 field.
	MDIOS_DOUTR22_DOUT22_Msk = 0xffff

	// DOUTR23: MDIOS output data register 23
	// Position of DOUT23 field.
	MDIOS_DOUTR23_DOUT23_Pos = 0x0
	// Bit mask of DOUT23 field.
	MDIOS_DOUTR23_DOUT23_Msk = 0xffff

	// DOUTR24: MDIOS output data register 24
	// Position of DOUT24 field.
	MDIOS_DOUTR24_DOUT24_Pos = 0x0
	// Bit mask of DOUT24 field.
	MDIOS_DOUTR24_DOUT24_Msk = 0xffff

	// DOUTR25: MDIOS output data register 25
	// Position of DOUT25 field.
	MDIOS_DOUTR25_DOUT25_Pos = 0x0
	// Bit mask of DOUT25 field.
	MDIOS_DOUTR25_DOUT25_Msk = 0xffff

	// DOUTR26: MDIOS output data register 26
	// Position of DOUT26 field.
	MDIOS_DOUTR26_DOUT26_Pos = 0x0
	// Bit mask of DOUT26 field.
	MDIOS_DOUTR26_DOUT26_Msk = 0xffff

	// DOUTR27: MDIOS output data register 27
	// Position of DOUT27 field.
	MDIOS_DOUTR27_DOUT27_Pos = 0x0
	// Bit mask of DOUT27 field.
	MDIOS_DOUTR27_DOUT27_Msk = 0xffff

	// DOUTR28: MDIOS output data register 28
	// Position of DOUT28 field.
	MDIOS_DOUTR28_DOUT28_Pos = 0x0
	// Bit mask of DOUT28 field.
	MDIOS_DOUTR28_DOUT28_Msk = 0xffff

	// DOUTR29: MDIOS output data register 29
	// Position of DOUT29 field.
	MDIOS_DOUTR29_DOUT29_Pos = 0x0
	// Bit mask of DOUT29 field.
	MDIOS_DOUTR29_DOUT29_Msk = 0xffff

	// DOUTR30: MDIOS output data register 30
	// Position of DOUT30 field.
	MDIOS_DOUTR30_DOUT30_Pos = 0x0
	// Bit mask of DOUT30 field.
	MDIOS_DOUTR30_DOUT30_Msk = 0xffff

	// DOUTR31: MDIOS output data register 31
	// Position of DOUT31 field.
	MDIOS_DOUTR31_DOUT31_Pos = 0x0
	// Bit mask of DOUT31 field.
	MDIOS_DOUTR31_DOUT31_Msk = 0xffff
)

// Constants for MDMA: MDMA
const (
	// GISR0: MDMA Global Interrupt/Status Register
	// Position of GIF0 field.
	MDMA_GISR0_GIF0_Pos = 0x0
	// Bit mask of GIF0 field.
	MDMA_GISR0_GIF0_Msk = 0x1
	// Bit GIF0.
	MDMA_GISR0_GIF0 = 0x1
	// Position of GIF1 field.
	MDMA_GISR0_GIF1_Pos = 0x1
	// Bit mask of GIF1 field.
	MDMA_GISR0_GIF1_Msk = 0x2
	// Bit GIF1.
	MDMA_GISR0_GIF1 = 0x2
	// Position of GIF2 field.
	MDMA_GISR0_GIF2_Pos = 0x2
	// Bit mask of GIF2 field.
	MDMA_GISR0_GIF2_Msk = 0x4
	// Bit GIF2.
	MDMA_GISR0_GIF2 = 0x4
	// Position of GIF3 field.
	MDMA_GISR0_GIF3_Pos = 0x3
	// Bit mask of GIF3 field.
	MDMA_GISR0_GIF3_Msk = 0x8
	// Bit GIF3.
	MDMA_GISR0_GIF3 = 0x8
	// Position of GIF4 field.
	MDMA_GISR0_GIF4_Pos = 0x4
	// Bit mask of GIF4 field.
	MDMA_GISR0_GIF4_Msk = 0x10
	// Bit GIF4.
	MDMA_GISR0_GIF4 = 0x10
	// Position of GIF5 field.
	MDMA_GISR0_GIF5_Pos = 0x5
	// Bit mask of GIF5 field.
	MDMA_GISR0_GIF5_Msk = 0x20
	// Bit GIF5.
	MDMA_GISR0_GIF5 = 0x20
	// Position of GIF6 field.
	MDMA_GISR0_GIF6_Pos = 0x6
	// Bit mask of GIF6 field.
	MDMA_GISR0_GIF6_Msk = 0x40
	// Bit GIF6.
	MDMA_GISR0_GIF6 = 0x40
	// Position of GIF7 field.
	MDMA_GISR0_GIF7_Pos = 0x7
	// Bit mask of GIF7 field.
	MDMA_GISR0_GIF7_Msk = 0x80
	// Bit GIF7.
	MDMA_GISR0_GIF7 = 0x80
	// Position of GIF8 field.
	MDMA_GISR0_GIF8_Pos = 0x8
	// Bit mask of GIF8 field.
	MDMA_GISR0_GIF8_Msk = 0x100
	// Bit GIF8.
	MDMA_GISR0_GIF8 = 0x100
	// Position of GIF9 field.
	MDMA_GISR0_GIF9_Pos = 0x9
	// Bit mask of GIF9 field.
	MDMA_GISR0_GIF9_Msk = 0x200
	// Bit GIF9.
	MDMA_GISR0_GIF9 = 0x200
	// Position of GIF10 field.
	MDMA_GISR0_GIF10_Pos = 0xa
	// Bit mask of GIF10 field.
	MDMA_GISR0_GIF10_Msk = 0x400
	// Bit GIF10.
	MDMA_GISR0_GIF10 = 0x400
	// Position of GIF11 field.
	MDMA_GISR0_GIF11_Pos = 0xb
	// Bit mask of GIF11 field.
	MDMA_GISR0_GIF11_Msk = 0x800
	// Bit GIF11.
	MDMA_GISR0_GIF11 = 0x800
	// Position of GIF12 field.
	MDMA_GISR0_GIF12_Pos = 0xc
	// Bit mask of GIF12 field.
	MDMA_GISR0_GIF12_Msk = 0x1000
	// Bit GIF12.
	MDMA_GISR0_GIF12 = 0x1000
	// Position of GIF13 field.
	MDMA_GISR0_GIF13_Pos = 0xd
	// Bit mask of GIF13 field.
	MDMA_GISR0_GIF13_Msk = 0x2000
	// Bit GIF13.
	MDMA_GISR0_GIF13 = 0x2000
	// Position of GIF14 field.
	MDMA_GISR0_GIF14_Pos = 0xe
	// Bit mask of GIF14 field.
	MDMA_GISR0_GIF14_Msk = 0x4000
	// Bit GIF14.
	MDMA_GISR0_GIF14 = 0x4000
	// Position of GIF15 field.
	MDMA_GISR0_GIF15_Pos = 0xf
	// Bit mask of GIF15 field.
	MDMA_GISR0_GIF15_Msk = 0x8000
	// Bit GIF15.
	MDMA_GISR0_GIF15 = 0x8000

	// CH.ISR: MDMA channel x interrupt/status register
	// Position of TEIF field.
	MDMA_CH_ISR_TEIF_Pos = 0x0
	// Bit mask of TEIF field.
	MDMA_CH_ISR_TEIF_Msk = 0x1
	// Bit TEIF.
	MDMA_CH_ISR_TEIF = 0x1
	// Position of CTCIF field.
	MDMA_CH_ISR_CTCIF_Pos = 0x1
	// Bit mask of CTCIF field.
	MDMA_CH_ISR_CTCIF_Msk = 0x2
	// Bit CTCIF.
	MDMA_CH_ISR_CTCIF = 0x2
	// Position of BRTIF field.
	MDMA_CH_ISR_BRTIF_Pos = 0x2
	// Bit mask of BRTIF field.
	MDMA_CH_ISR_BRTIF_Msk = 0x4
	// Bit BRTIF.
	MDMA_CH_ISR_BRTIF = 0x4
	// Position of BTIF field.
	MDMA_CH_ISR_BTIF_Pos = 0x3
	// Bit mask of BTIF field.
	MDMA_CH_ISR_BTIF_Msk = 0x8
	// Bit BTIF.
	MDMA_CH_ISR_BTIF = 0x8
	// Position of TCIF field.
	MDMA_CH_ISR_TCIF_Pos = 0x4
	// Bit mask of TCIF field.
	MDMA_CH_ISR_TCIF_Msk = 0x10
	// Bit TCIF.
	MDMA_CH_ISR_TCIF = 0x10
	// Position of CRQA field.
	MDMA_CH_ISR_CRQA_Pos = 0x10
	// Bit mask of CRQA field.
	MDMA_CH_ISR_CRQA_Msk = 0x10000
	// Bit CRQA.
	MDMA_CH_ISR_CRQA = 0x10000

	// CH.IFCR: MDMA channel x interrupt flag clear register
	// Position of CTEIF field.
	MDMA_CH_IFCR_CTEIF_Pos = 0x0
	// Bit mask of CTEIF field.
	MDMA_CH_IFCR_CTEIF_Msk = 0x1
	// Bit CTEIF.
	MDMA_CH_IFCR_CTEIF = 0x1
	// Position of CCTCIF field.
	MDMA_CH_IFCR_CCTCIF_Pos = 0x1
	// Bit mask of CCTCIF field.
	MDMA_CH_IFCR_CCTCIF_Msk = 0x2
	// Bit CCTCIF.
	MDMA_CH_IFCR_CCTCIF = 0x2
	// Position of CBRTIF field.
	MDMA_CH_IFCR_CBRTIF_Pos = 0x2
	// Bit mask of CBRTIF field.
	MDMA_CH_IFCR_CBRTIF_Msk = 0x4
	// Bit CBRTIF.
	MDMA_CH_IFCR_CBRTIF = 0x4
	// Position of CBTIF field.
	MDMA_CH_IFCR_CBTIF_Pos = 0x3
	// Bit mask of CBTIF field.
	MDMA_CH_IFCR_CBTIF_Msk = 0x8
	// Bit CBTIF.
	MDMA_CH_IFCR_CBTIF = 0x8
	// Position of CLTCIF field.
	MDMA_CH_IFCR_CLTCIF_Pos = 0x4
	// Bit mask of CLTCIF field.
	MDMA_CH_IFCR_CLTCIF_Msk = 0x10
	// Bit CLTCIF.
	MDMA_CH_IFCR_CLTCIF = 0x10

	// CH.ESR: MDMA Channel x error status register
	// Position of TEA field.
	MDMA_CH_ESR_TEA_Pos = 0x0
	// Bit mask of TEA field.
	MDMA_CH_ESR_TEA_Msk = 0x7f
	// Position of TED field.
	MDMA_CH_ESR_TED_Pos = 0x7
	// Bit mask of TED field.
	MDMA_CH_ESR_TED_Msk = 0x80
	// Bit TED.
	MDMA_CH_ESR_TED = 0x80
	// Position of TELD field.
	MDMA_CH_ESR_TELD_Pos = 0x8
	// Bit mask of TELD field.
	MDMA_CH_ESR_TELD_Msk = 0x100
	// Bit TELD.
	MDMA_CH_ESR_TELD = 0x100
	// Position of TEMD field.
	MDMA_CH_ESR_TEMD_Pos = 0x9
	// Bit mask of TEMD field.
	MDMA_CH_ESR_TEMD_Msk = 0x200
	// Bit TEMD.
	MDMA_CH_ESR_TEMD = 0x200
	// Position of ASE field.
	MDMA_CH_ESR_ASE_Pos = 0xa
	// Bit mask of ASE field.
	MDMA_CH_ESR_ASE_Msk = 0x400
	// Bit ASE.
	MDMA_CH_ESR_ASE = 0x400
	// Position of BSE field.
	MDMA_CH_ESR_BSE_Pos = 0xb
	// Bit mask of BSE field.
	MDMA_CH_ESR_BSE_Msk = 0x800
	// Bit BSE.
	MDMA_CH_ESR_BSE = 0x800

	// CH.CR: This register is used to control the concerned channel.
	// Position of EN field.
	MDMA_CH_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	MDMA_CH_CR_EN_Msk = 0x1
	// Bit EN.
	MDMA_CH_CR_EN = 0x1
	// Position of TEIE field.
	MDMA_CH_CR_TEIE_Pos = 0x1
	// Bit mask of TEIE field.
	MDMA_CH_CR_TEIE_Msk = 0x2
	// Bit TEIE.
	MDMA_CH_CR_TEIE = 0x2
	// Position of CTCIE field.
	MDMA_CH_CR_CTCIE_Pos = 0x2
	// Bit mask of CTCIE field.
	MDMA_CH_CR_CTCIE_Msk = 0x4
	// Bit CTCIE.
	MDMA_CH_CR_CTCIE = 0x4
	// Position of BRTIE field.
	MDMA_CH_CR_BRTIE_Pos = 0x3
	// Bit mask of BRTIE field.
	MDMA_CH_CR_BRTIE_Msk = 0x8
	// Bit BRTIE.
	MDMA_CH_CR_BRTIE = 0x8
	// Position of BTIE field.
	MDMA_CH_CR_BTIE_Pos = 0x4
	// Bit mask of BTIE field.
	MDMA_CH_CR_BTIE_Msk = 0x10
	// Bit BTIE.
	MDMA_CH_CR_BTIE = 0x10
	// Position of TCIE field.
	MDMA_CH_CR_TCIE_Pos = 0x5
	// Bit mask of TCIE field.
	MDMA_CH_CR_TCIE_Msk = 0x20
	// Bit TCIE.
	MDMA_CH_CR_TCIE = 0x20
	// Position of PL field.
	MDMA_CH_CR_PL_Pos = 0x6
	// Bit mask of PL field.
	MDMA_CH_CR_PL_Msk = 0xc0
	// Position of BEX field.
	MDMA_CH_CR_BEX_Pos = 0xc
	// Bit mask of BEX field.
	MDMA_CH_CR_BEX_Msk = 0x1000
	// Bit BEX.
	MDMA_CH_CR_BEX = 0x1000
	// Position of HEX field.
	MDMA_CH_CR_HEX_Pos = 0xd
	// Bit mask of HEX field.
	MDMA_CH_CR_HEX_Msk = 0x2000
	// Bit HEX.
	MDMA_CH_CR_HEX = 0x2000
	// Position of WEX field.
	MDMA_CH_CR_WEX_Pos = 0xe
	// Bit mask of WEX field.
	MDMA_CH_CR_WEX_Msk = 0x4000
	// Bit WEX.
	MDMA_CH_CR_WEX = 0x4000
	// Position of SWRQ field.
	MDMA_CH_CR_SWRQ_Pos = 0x10
	// Bit mask of SWRQ field.
	MDMA_CH_CR_SWRQ_Msk = 0x10000
	// Bit SWRQ.
	MDMA_CH_CR_SWRQ = 0x10000

	// CH.TCR: This register is used to configure the concerned channel.
	// Position of SINC field.
	MDMA_CH_TCR_SINC_Pos = 0x0
	// Bit mask of SINC field.
	MDMA_CH_TCR_SINC_Msk = 0x3
	// Position of DINC field.
	MDMA_CH_TCR_DINC_Pos = 0x2
	// Bit mask of DINC field.
	MDMA_CH_TCR_DINC_Msk = 0xc
	// Position of SSIZE field.
	MDMA_CH_TCR_SSIZE_Pos = 0x4
	// Bit mask of SSIZE field.
	MDMA_CH_TCR_SSIZE_Msk = 0x30
	// Position of DSIZE field.
	MDMA_CH_TCR_DSIZE_Pos = 0x6
	// Bit mask of DSIZE field.
	MDMA_CH_TCR_DSIZE_Msk = 0xc0
	// Position of SINCOS field.
	MDMA_CH_TCR_SINCOS_Pos = 0x8
	// Bit mask of SINCOS field.
	MDMA_CH_TCR_SINCOS_Msk = 0x300
	// Position of DINCOS field.
	MDMA_CH_TCR_DINCOS_Pos = 0xa
	// Bit mask of DINCOS field.
	MDMA_CH_TCR_DINCOS_Msk = 0xc00
	// Position of SBURST field.
	MDMA_CH_TCR_SBURST_Pos = 0xc
	// Bit mask of SBURST field.
	MDMA_CH_TCR_SBURST_Msk = 0x7000
	// Position of DBURST field.
	MDMA_CH_TCR_DBURST_Pos = 0xf
	// Bit mask of DBURST field.
	MDMA_CH_TCR_DBURST_Msk = 0x38000
	// Position of TLEN field.
	MDMA_CH_TCR_TLEN_Pos = 0x12
	// Bit mask of TLEN field.
	MDMA_CH_TCR_TLEN_Msk = 0x1fc0000
	// Position of PKE field.
	MDMA_CH_TCR_PKE_Pos = 0x19
	// Bit mask of PKE field.
	MDMA_CH_TCR_PKE_Msk = 0x2000000
	// Bit PKE.
	MDMA_CH_TCR_PKE = 0x2000000
	// Position of PAM field.
	MDMA_CH_TCR_PAM_Pos = 0x1a
	// Bit mask of PAM field.
	MDMA_CH_TCR_PAM_Msk = 0xc000000
	// Position of TRGM field.
	MDMA_CH_TCR_TRGM_Pos = 0x1c
	// Bit mask of TRGM field.
	MDMA_CH_TCR_TRGM_Msk = 0x30000000
	// Position of SWRM field.
	MDMA_CH_TCR_SWRM_Pos = 0x1e
	// Bit mask of SWRM field.
	MDMA_CH_TCR_SWRM_Msk = 0x40000000
	// Bit SWRM.
	MDMA_CH_TCR_SWRM = 0x40000000
	// Position of BWM field.
	MDMA_CH_TCR_BWM_Pos = 0x1f
	// Bit mask of BWM field.
	MDMA_CH_TCR_BWM_Msk = 0x80000000
	// Bit BWM.
	MDMA_CH_TCR_BWM = 0x80000000

	// CH.BNDTR: MDMA Channel x block number of data register
	// Position of BNDT field.
	MDMA_CH_BNDTR_BNDT_Pos = 0x0
	// Bit mask of BNDT field.
	MDMA_CH_BNDTR_BNDT_Msk = 0x1ffff
	// Position of BRSUM field.
	MDMA_CH_BNDTR_BRSUM_Pos = 0x12
	// Bit mask of BRSUM field.
	MDMA_CH_BNDTR_BRSUM_Msk = 0x40000
	// Bit BRSUM.
	MDMA_CH_BNDTR_BRSUM = 0x40000
	// Position of BRDUM field.
	MDMA_CH_BNDTR_BRDUM_Pos = 0x13
	// Bit mask of BRDUM field.
	MDMA_CH_BNDTR_BRDUM_Msk = 0x80000
	// Bit BRDUM.
	MDMA_CH_BNDTR_BRDUM = 0x80000
	// Position of BRC field.
	MDMA_CH_BNDTR_BRC_Pos = 0x14
	// Bit mask of BRC field.
	MDMA_CH_BNDTR_BRC_Msk = 0xfff00000

	// CH.SAR: MDMA channel x source address register
	// Position of SAR field.
	MDMA_CH_SAR_SAR_Pos = 0x0
	// Bit mask of SAR field.
	MDMA_CH_SAR_SAR_Msk = 0xffffffff

	// CH.DAR: MDMA channel x destination address register
	// Position of DAR field.
	MDMA_CH_DAR_DAR_Pos = 0x0
	// Bit mask of DAR field.
	MDMA_CH_DAR_DAR_Msk = 0xffffffff

	// CH.BRUR: MDMA channel x Block Repeat address Update register
	// Position of SUV field.
	MDMA_CH_BRUR_SUV_Pos = 0x0
	// Bit mask of SUV field.
	MDMA_CH_BRUR_SUV_Msk = 0xffff
	// Position of DUV field.
	MDMA_CH_BRUR_DUV_Pos = 0x10
	// Bit mask of DUV field.
	MDMA_CH_BRUR_DUV_Msk = 0xffff0000

	// CH.LAR: MDMA channel x Link Address register
	// Position of LAR field.
	MDMA_CH_LAR_LAR_Pos = 0x0
	// Bit mask of LAR field.
	MDMA_CH_LAR_LAR_Msk = 0xffffffff

	// CH.TBR: MDMA channel x Trigger and Bus selection Register
	// Position of TSEL field.
	MDMA_CH_TBR_TSEL_Pos = 0x0
	// Bit mask of TSEL field.
	MDMA_CH_TBR_TSEL_Msk = 0x3f
	// Position of SBUS field.
	MDMA_CH_TBR_SBUS_Pos = 0x10
	// Bit mask of SBUS field.
	MDMA_CH_TBR_SBUS_Msk = 0x10000
	// Bit SBUS.
	MDMA_CH_TBR_SBUS = 0x10000
	// Position of DBUS field.
	MDMA_CH_TBR_DBUS_Pos = 0x11
	// Bit mask of DBUS field.
	MDMA_CH_TBR_DBUS_Msk = 0x20000
	// Bit DBUS.
	MDMA_CH_TBR_DBUS = 0x20000

	// CH.MAR: MDMA channel x Mask address register
	// Position of MAR field.
	MDMA_CH_MAR_MAR_Pos = 0x0
	// Bit mask of MAR field.
	MDMA_CH_MAR_MAR_Msk = 0xffffffff

	// CH.MDR: MDMA channel x Mask Data register
	// Position of MDR field.
	MDMA_CH_MDR_MDR_Pos = 0x0
	// Bit mask of MDR field.
	MDMA_CH_MDR_MDR_Msk = 0xffffffff
)

// Constants for MPU: Memory protection unit
const (
	// TYPER: MPU type register
	// Position of SEPARATE field.
	MPU_TYPER_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPER_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPER_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPER_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPER_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPER_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPER_IREGION_Msk = 0xff0000

	// CTRL: MPU control register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU region number register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU region base address register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU region attribute and size register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x3e
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER0: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER0_SETENA_Msk = 0xffffffff

	// ISER1: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER1_SETENA_Msk = 0xffffffff

	// ISER2: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER2_SETENA_Msk = 0xffffffff

	// ICER0: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER0_CLRENA_Msk = 0xffffffff

	// ICER1: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER1_CLRENA_Msk = 0xffffffff

	// ICER2: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER2_CLRENA_Msk = 0xffffffff

	// ISPR0: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR0_SETPEND_Msk = 0xffffffff

	// ISPR1: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR1_SETPEND_Msk = 0xffffffff

	// ISPR2: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR2_SETPEND_Msk = 0xffffffff

	// ICPR0: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Msk = 0xffffffff

	// ICPR1: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Msk = 0xffffffff

	// ICPR2: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR2_CLRPEND_Msk = 0xffffffff

	// IABR0: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR0_ACTIVE_Msk = 0xffffffff

	// IABR1: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR1_ACTIVE_Msk = 0xffffffff

	// IABR2: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR2_ACTIVE_Msk = 0xffffffff

	// IPR0: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Msk = 0xff000000

	// IPR1: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Msk = 0xff000000

	// IPR2: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Msk = 0xff000000

	// IPR3: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Msk = 0xff000000

	// IPR4: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Msk = 0xff000000

	// IPR5: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Msk = 0xff000000

	// IPR6: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Msk = 0xff000000

	// IPR7: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Msk = 0xff000000

	// IPR8: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Msk = 0xff000000

	// IPR9: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Msk = 0xff000000

	// IPR10: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Msk = 0xff000000

	// IPR11: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Msk = 0xff000000

	// IPR12: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Msk = 0xff000000

	// IPR13: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Msk = 0xff000000

	// IPR14: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Msk = 0xff000000

	// IPR15: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Msk = 0xff000000

	// IPR16: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Msk = 0xff000000

	// IPR17: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Msk = 0xff000000

	// IPR18: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR18_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR18_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR18_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR18_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR18_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR18_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR18_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR18_IPR_N3_Msk = 0xff000000

	// IPR19: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR19_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR19_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR19_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR19_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR19_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR19_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR19_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR19_IPR_N3_Msk = 0xff000000

	// IPR20: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR20_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR20_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR20_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR20_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR20_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR20_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR20_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR20_IPR_N3_Msk = 0xff000000

	// IPR21: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR21_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR21_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR21_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR21_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR21_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR21_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR21_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR21_IPR_N3_Msk = 0xff000000

	// IPR22: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR22_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR22_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR22_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR22_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR22_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR22_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR22_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR22_IPR_N3_Msk = 0xff000000

	// IPR23: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR23_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR23_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR23_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR23_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR23_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR23_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR23_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR23_IPR_N3_Msk = 0xff000000

	// IPR24: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR24_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR24_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR24_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR24_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR24_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR24_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR24_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR24_IPR_N3_Msk = 0xff000000

	// IPR25: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR25_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR25_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR25_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR25_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR25_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR25_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR25_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR25_IPR_N3_Msk = 0xff000000

	// IPR26: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR26_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR26_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR26_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR26_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR26_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR26_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR26_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR26_IPR_N3_Msk = 0xff000000

	// IPR27: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR27_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR27_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR27_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR27_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR27_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR27_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR27_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR27_IPR_N3_Msk = 0xff000000

	// IPR28: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR28_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR28_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR28_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR28_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR28_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR28_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR28_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR28_IPR_N3_Msk = 0xff000000

	// IPR29: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR29_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR29_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR29_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR29_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR29_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR29_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR29_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR29_IPR_N3_Msk = 0xff000000

	// IPR30: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR30_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR30_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR30_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR30_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR30_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR30_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR30_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR30_IPR_N3_Msk = 0xff000000

	// IPR31: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR31_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR31_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR31_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR31_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR31_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR31_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR31_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR31_IPR_N3_Msk = 0xff000000

	// IPR32: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR32_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR32_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR32_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR32_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR32_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR32_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR32_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR32_IPR_N3_Msk = 0xff000000

	// IPR33: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR33_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR33_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR33_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR33_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR33_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR33_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR33_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR33_IPR_N3_Msk = 0xff000000

	// IPR34: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR34_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR34_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR34_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR34_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR34_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR34_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR34_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR34_IPR_N3_Msk = 0xff000000

	// IPR35: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR35_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR35_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR35_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR35_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR35_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR35_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR35_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR35_IPR_N3_Msk = 0xff000000

	// IPR36: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR36_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR36_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR36_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR36_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR36_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR36_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR36_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR36_IPR_N3_Msk = 0xff000000

	// IPR37: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR37_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR37_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR37_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR37_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR37_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR37_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR37_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR37_IPR_N3_Msk = 0xff000000

	// IPR38: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR38_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR38_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR38_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR38_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR38_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR38_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR38_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR38_IPR_N3_Msk = 0xff000000
)

// Constants for OCTOSPI1: OctoSPI
const (
	// CR: control register
	// Position of FMODE field.
	OctoSPI_CR_FMODE_Pos = 0x1c
	// Bit mask of FMODE field.
	OctoSPI_CR_FMODE_Msk = 0x30000000
	// Position of PMM field.
	OctoSPI_CR_PMM_Pos = 0x17
	// Bit mask of PMM field.
	OctoSPI_CR_PMM_Msk = 0x800000
	// Bit PMM.
	OctoSPI_CR_PMM = 0x800000
	// Position of APMS field.
	OctoSPI_CR_APMS_Pos = 0x16
	// Bit mask of APMS field.
	OctoSPI_CR_APMS_Msk = 0x400000
	// Bit APMS.
	OctoSPI_CR_APMS = 0x400000
	// Position of TOIE field.
	OctoSPI_CR_TOIE_Pos = 0x14
	// Bit mask of TOIE field.
	OctoSPI_CR_TOIE_Msk = 0x100000
	// Bit TOIE.
	OctoSPI_CR_TOIE = 0x100000
	// Position of SMIE field.
	OctoSPI_CR_SMIE_Pos = 0x13
	// Bit mask of SMIE field.
	OctoSPI_CR_SMIE_Msk = 0x80000
	// Bit SMIE.
	OctoSPI_CR_SMIE = 0x80000
	// Position of FTIE field.
	OctoSPI_CR_FTIE_Pos = 0x12
	// Bit mask of FTIE field.
	OctoSPI_CR_FTIE_Msk = 0x40000
	// Bit FTIE.
	OctoSPI_CR_FTIE = 0x40000
	// Position of TCIE field.
	OctoSPI_CR_TCIE_Pos = 0x11
	// Bit mask of TCIE field.
	OctoSPI_CR_TCIE_Msk = 0x20000
	// Bit TCIE.
	OctoSPI_CR_TCIE = 0x20000
	// Position of TEIE field.
	OctoSPI_CR_TEIE_Pos = 0x10
	// Bit mask of TEIE field.
	OctoSPI_CR_TEIE_Msk = 0x10000
	// Bit TEIE.
	OctoSPI_CR_TEIE = 0x10000
	// Position of FTHRES field.
	OctoSPI_CR_FTHRES_Pos = 0x8
	// Bit mask of FTHRES field.
	OctoSPI_CR_FTHRES_Msk = 0x1f00
	// Position of FSEL field.
	OctoSPI_CR_FSEL_Pos = 0x7
	// Bit mask of FSEL field.
	OctoSPI_CR_FSEL_Msk = 0x80
	// Bit FSEL.
	OctoSPI_CR_FSEL = 0x80
	// Position of DQM field.
	OctoSPI_CR_DQM_Pos = 0x6
	// Bit mask of DQM field.
	OctoSPI_CR_DQM_Msk = 0x40
	// Bit DQM.
	OctoSPI_CR_DQM = 0x40
	// Position of TCEN field.
	OctoSPI_CR_TCEN_Pos = 0x3
	// Bit mask of TCEN field.
	OctoSPI_CR_TCEN_Msk = 0x8
	// Bit TCEN.
	OctoSPI_CR_TCEN = 0x8
	// Position of DMAEN field.
	OctoSPI_CR_DMAEN_Pos = 0x2
	// Bit mask of DMAEN field.
	OctoSPI_CR_DMAEN_Msk = 0x4
	// Bit DMAEN.
	OctoSPI_CR_DMAEN = 0x4
	// Position of ABORT field.
	OctoSPI_CR_ABORT_Pos = 0x1
	// Bit mask of ABORT field.
	OctoSPI_CR_ABORT_Msk = 0x2
	// Bit ABORT.
	OctoSPI_CR_ABORT = 0x2
	// Position of EN field.
	OctoSPI_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	OctoSPI_CR_EN_Msk = 0x1
	// Bit EN.
	OctoSPI_CR_EN = 0x1

	// DCR1: device configuration register
	// Position of CKMODE field.
	OctoSPI_DCR1_CKMODE_Pos = 0x0
	// Bit mask of CKMODE field.
	OctoSPI_DCR1_CKMODE_Msk = 0x1
	// Bit CKMODE.
	OctoSPI_DCR1_CKMODE = 0x1
	// Position of FRCK field.
	OctoSPI_DCR1_FRCK_Pos = 0x1
	// Bit mask of FRCK field.
	OctoSPI_DCR1_FRCK_Msk = 0x2
	// Bit FRCK.
	OctoSPI_DCR1_FRCK = 0x2
	// Position of CSHT field.
	OctoSPI_DCR1_CSHT_Pos = 0x8
	// Bit mask of CSHT field.
	OctoSPI_DCR1_CSHT_Msk = 0x3f00
	// Position of DEVSIZE field.
	OctoSPI_DCR1_DEVSIZE_Pos = 0x10
	// Bit mask of DEVSIZE field.
	OctoSPI_DCR1_DEVSIZE_Msk = 0x1f0000
	// Position of MTYP field.
	OctoSPI_DCR1_MTYP_Pos = 0x18
	// Bit mask of MTYP field.
	OctoSPI_DCR1_MTYP_Msk = 0x7000000
	// Position of DLYBYP field.
	OctoSPI_DCR1_DLYBYP_Pos = 0x3
	// Bit mask of DLYBYP field.
	OctoSPI_DCR1_DLYBYP_Msk = 0x8
	// Bit DLYBYP.
	OctoSPI_DCR1_DLYBYP = 0x8

	// DCR2: device configuration register 2
	// Position of PRESCALER field.
	OctoSPI_DCR2_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	OctoSPI_DCR2_PRESCALER_Msk = 0xff
	// Position of WRAPSIZE field.
	OctoSPI_DCR2_WRAPSIZE_Pos = 0x10
	// Bit mask of WRAPSIZE field.
	OctoSPI_DCR2_WRAPSIZE_Msk = 0x70000

	// DCR3: device configuration register 3
	// Position of MAXTRAN field.
	OctoSPI_DCR3_MAXTRAN_Pos = 0x0
	// Bit mask of MAXTRAN field.
	OctoSPI_DCR3_MAXTRAN_Msk = 0xff
	// Position of CSBOUND field.
	OctoSPI_DCR3_CSBOUND_Pos = 0x10
	// Bit mask of CSBOUND field.
	OctoSPI_DCR3_CSBOUND_Msk = 0x1f0000

	// DCR4: DCR4
	// Position of REFRESH field.
	OctoSPI_DCR4_REFRESH_Pos = 0x0
	// Bit mask of REFRESH field.
	OctoSPI_DCR4_REFRESH_Msk = 0xffffffff

	// SR: status register
	// Position of TEF field.
	OctoSPI_SR_TEF_Pos = 0x0
	// Bit mask of TEF field.
	OctoSPI_SR_TEF_Msk = 0x1
	// Bit TEF.
	OctoSPI_SR_TEF = 0x1
	// Position of TCF field.
	OctoSPI_SR_TCF_Pos = 0x1
	// Bit mask of TCF field.
	OctoSPI_SR_TCF_Msk = 0x2
	// Bit TCF.
	OctoSPI_SR_TCF = 0x2
	// Position of SMF field.
	OctoSPI_SR_SMF_Pos = 0x3
	// Bit mask of SMF field.
	OctoSPI_SR_SMF_Msk = 0x8
	// Bit SMF.
	OctoSPI_SR_SMF = 0x8
	// Position of TOF field.
	OctoSPI_SR_TOF_Pos = 0x4
	// Bit mask of TOF field.
	OctoSPI_SR_TOF_Msk = 0x10
	// Bit TOF.
	OctoSPI_SR_TOF = 0x10
	// Position of FTF field.
	OctoSPI_SR_FTF_Pos = 0x2
	// Bit mask of FTF field.
	OctoSPI_SR_FTF_Msk = 0x4
	// Bit FTF.
	OctoSPI_SR_FTF = 0x4
	// Position of BUSY field.
	OctoSPI_SR_BUSY_Pos = 0x5
	// Bit mask of BUSY field.
	OctoSPI_SR_BUSY_Msk = 0x20
	// Bit BUSY.
	OctoSPI_SR_BUSY = 0x20
	// Position of FLEVEL field.
	OctoSPI_SR_FLEVEL_Pos = 0x8
	// Bit mask of FLEVEL field.
	OctoSPI_SR_FLEVEL_Msk = 0x3f00

	// FCR: flag clear register
	// Position of CTEF field.
	OctoSPI_FCR_CTEF_Pos = 0x0
	// Bit mask of CTEF field.
	OctoSPI_FCR_CTEF_Msk = 0x1
	// Bit CTEF.
	OctoSPI_FCR_CTEF = 0x1
	// Position of CTCF field.
	OctoSPI_FCR_CTCF_Pos = 0x1
	// Bit mask of CTCF field.
	OctoSPI_FCR_CTCF_Msk = 0x2
	// Bit CTCF.
	OctoSPI_FCR_CTCF = 0x2
	// Position of CSMF field.
	OctoSPI_FCR_CSMF_Pos = 0x3
	// Bit mask of CSMF field.
	OctoSPI_FCR_CSMF_Msk = 0x8
	// Bit CSMF.
	OctoSPI_FCR_CSMF = 0x8
	// Position of CTOF field.
	OctoSPI_FCR_CTOF_Pos = 0x4
	// Bit mask of CTOF field.
	OctoSPI_FCR_CTOF_Msk = 0x10
	// Bit CTOF.
	OctoSPI_FCR_CTOF = 0x10

	// DLR: data length register
	// Position of DL field.
	OctoSPI_DLR_DL_Pos = 0x0
	// Bit mask of DL field.
	OctoSPI_DLR_DL_Msk = 0xffffffff

	// AR: address register
	// Position of ADDRESS field.
	OctoSPI_AR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	OctoSPI_AR_ADDRESS_Msk = 0xffffffff

	// DR: data register
	// Position of DATA field.
	OctoSPI_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OctoSPI_DR_DATA_Msk = 0xffffffff

	// PSMKR: polling status mask register
	// Position of MASK field.
	OctoSPI_PSMKR_MASK_Pos = 0x0
	// Bit mask of MASK field.
	OctoSPI_PSMKR_MASK_Msk = 0xffffffff

	// PSMAR: polling status match register
	// Position of MATCH field.
	OctoSPI_PSMAR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	OctoSPI_PSMAR_MATCH_Msk = 0xffffffff

	// PIR: OCTOSPI polling interval register
	// Position of INTERVAL field.
	OctoSPI_PIR_INTERVAL_Pos = 0x0
	// Bit mask of INTERVAL field.
	OctoSPI_PIR_INTERVAL_Msk = 0xffff

	// CCR: polling interval register
	// Position of IMODE field.
	OctoSPI_CCR_IMODE_Pos = 0x0
	// Bit mask of IMODE field.
	OctoSPI_CCR_IMODE_Msk = 0x7
	// Position of IDTR field.
	OctoSPI_CCR_IDTR_Pos = 0x3
	// Bit mask of IDTR field.
	OctoSPI_CCR_IDTR_Msk = 0x8
	// Bit IDTR.
	OctoSPI_CCR_IDTR = 0x8
	// Position of ISIZE field.
	OctoSPI_CCR_ISIZE_Pos = 0x4
	// Bit mask of ISIZE field.
	OctoSPI_CCR_ISIZE_Msk = 0x30
	// Position of ADMODE field.
	OctoSPI_CCR_ADMODE_Pos = 0x8
	// Bit mask of ADMODE field.
	OctoSPI_CCR_ADMODE_Msk = 0x700
	// Position of ADDTR field.
	OctoSPI_CCR_ADDTR_Pos = 0xb
	// Bit mask of ADDTR field.
	OctoSPI_CCR_ADDTR_Msk = 0x800
	// Bit ADDTR.
	OctoSPI_CCR_ADDTR = 0x800
	// Position of ADSIZE field.
	OctoSPI_CCR_ADSIZE_Pos = 0xc
	// Bit mask of ADSIZE field.
	OctoSPI_CCR_ADSIZE_Msk = 0x3000
	// Position of ABMODE field.
	OctoSPI_CCR_ABMODE_Pos = 0x10
	// Bit mask of ABMODE field.
	OctoSPI_CCR_ABMODE_Msk = 0x70000
	// Position of ABDTR field.
	OctoSPI_CCR_ABDTR_Pos = 0x13
	// Bit mask of ABDTR field.
	OctoSPI_CCR_ABDTR_Msk = 0x80000
	// Bit ABDTR.
	OctoSPI_CCR_ABDTR = 0x80000
	// Position of ABSIZE field.
	OctoSPI_CCR_ABSIZE_Pos = 0x14
	// Bit mask of ABSIZE field.
	OctoSPI_CCR_ABSIZE_Msk = 0x300000
	// Position of DMODE field.
	OctoSPI_CCR_DMODE_Pos = 0x18
	// Bit mask of DMODE field.
	OctoSPI_CCR_DMODE_Msk = 0x7000000
	// Position of DDTR field.
	OctoSPI_CCR_DDTR_Pos = 0x1b
	// Bit mask of DDTR field.
	OctoSPI_CCR_DDTR_Msk = 0x8000000
	// Bit DDTR.
	OctoSPI_CCR_DDTR = 0x8000000
	// Position of DQSE field.
	OctoSPI_CCR_DQSE_Pos = 0x1d
	// Bit mask of DQSE field.
	OctoSPI_CCR_DQSE_Msk = 0x20000000
	// Bit DQSE.
	OctoSPI_CCR_DQSE = 0x20000000
	// Position of SIOO field.
	OctoSPI_CCR_SIOO_Pos = 0x1f
	// Bit mask of SIOO field.
	OctoSPI_CCR_SIOO_Msk = 0x80000000
	// Bit SIOO.
	OctoSPI_CCR_SIOO = 0x80000000

	// TCR: communication configuration register
	// Position of DCYC field.
	OctoSPI_TCR_DCYC_Pos = 0x0
	// Bit mask of DCYC field.
	OctoSPI_TCR_DCYC_Msk = 0x1f
	// Position of DHQC field.
	OctoSPI_TCR_DHQC_Pos = 0x1c
	// Bit mask of DHQC field.
	OctoSPI_TCR_DHQC_Msk = 0x10000000
	// Bit DHQC.
	OctoSPI_TCR_DHQC = 0x10000000
	// Position of SSHIFT field.
	OctoSPI_TCR_SSHIFT_Pos = 0x1e
	// Bit mask of SSHIFT field.
	OctoSPI_TCR_SSHIFT_Msk = 0x40000000
	// Bit SSHIFT.
	OctoSPI_TCR_SSHIFT = 0x40000000

	// IR: timing configuration register
	// Position of INSTRUCTION field.
	OctoSPI_IR_INSTRUCTION_Pos = 0x0
	// Bit mask of INSTRUCTION field.
	OctoSPI_IR_INSTRUCTION_Msk = 0xffffffff

	// ABR: instruction register
	// Position of ALTERNATE field.
	OctoSPI_ABR_ALTERNATE_Pos = 0x0
	// Bit mask of ALTERNATE field.
	OctoSPI_ABR_ALTERNATE_Msk = 0xffffffff

	// LPTR: alternate bytes register
	// Position of TIMEOUT field.
	OctoSPI_LPTR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	OctoSPI_LPTR_TIMEOUT_Msk = 0xffff

	// WPCCR: low-power timeout register
	// Position of IMODE field.
	OctoSPI_WPCCR_IMODE_Pos = 0x0
	// Bit mask of IMODE field.
	OctoSPI_WPCCR_IMODE_Msk = 0x7
	// Position of IDTR field.
	OctoSPI_WPCCR_IDTR_Pos = 0x3
	// Bit mask of IDTR field.
	OctoSPI_WPCCR_IDTR_Msk = 0x8
	// Bit IDTR.
	OctoSPI_WPCCR_IDTR = 0x8
	// Position of ISIZE field.
	OctoSPI_WPCCR_ISIZE_Pos = 0x4
	// Bit mask of ISIZE field.
	OctoSPI_WPCCR_ISIZE_Msk = 0x30
	// Position of ADMODE field.
	OctoSPI_WPCCR_ADMODE_Pos = 0x8
	// Bit mask of ADMODE field.
	OctoSPI_WPCCR_ADMODE_Msk = 0x700
	// Position of ADDTR field.
	OctoSPI_WPCCR_ADDTR_Pos = 0xb
	// Bit mask of ADDTR field.
	OctoSPI_WPCCR_ADDTR_Msk = 0x800
	// Bit ADDTR.
	OctoSPI_WPCCR_ADDTR = 0x800
	// Position of ADSIZE field.
	OctoSPI_WPCCR_ADSIZE_Pos = 0xc
	// Bit mask of ADSIZE field.
	OctoSPI_WPCCR_ADSIZE_Msk = 0x3000
	// Position of ABMODE field.
	OctoSPI_WPCCR_ABMODE_Pos = 0x10
	// Bit mask of ABMODE field.
	OctoSPI_WPCCR_ABMODE_Msk = 0x70000
	// Position of ABDTR field.
	OctoSPI_WPCCR_ABDTR_Pos = 0x13
	// Bit mask of ABDTR field.
	OctoSPI_WPCCR_ABDTR_Msk = 0x80000
	// Bit ABDTR.
	OctoSPI_WPCCR_ABDTR = 0x80000
	// Position of ABSIZE field.
	OctoSPI_WPCCR_ABSIZE_Pos = 0x14
	// Bit mask of ABSIZE field.
	OctoSPI_WPCCR_ABSIZE_Msk = 0x300000
	// Position of DMODE field.
	OctoSPI_WPCCR_DMODE_Pos = 0x18
	// Bit mask of DMODE field.
	OctoSPI_WPCCR_DMODE_Msk = 0x7000000
	// Position of DDTR field.
	OctoSPI_WPCCR_DDTR_Pos = 0x1b
	// Bit mask of DDTR field.
	OctoSPI_WPCCR_DDTR_Msk = 0x8000000
	// Bit DDTR.
	OctoSPI_WPCCR_DDTR = 0x8000000
	// Position of DQSE field.
	OctoSPI_WPCCR_DQSE_Pos = 0x1d
	// Bit mask of DQSE field.
	OctoSPI_WPCCR_DQSE_Msk = 0x20000000
	// Bit DQSE.
	OctoSPI_WPCCR_DQSE = 0x20000000

	// WPTCR: wrap timing configuration register
	// Position of DCYC field.
	OctoSPI_WPTCR_DCYC_Pos = 0x0
	// Bit mask of DCYC field.
	OctoSPI_WPTCR_DCYC_Msk = 0x1f
	// Position of DHQC field.
	OctoSPI_WPTCR_DHQC_Pos = 0x1c
	// Bit mask of DHQC field.
	OctoSPI_WPTCR_DHQC_Msk = 0x10000000
	// Bit DHQC.
	OctoSPI_WPTCR_DHQC = 0x10000000
	// Position of SSHIFT field.
	OctoSPI_WPTCR_SSHIFT_Pos = 0x1e
	// Bit mask of SSHIFT field.
	OctoSPI_WPTCR_SSHIFT_Msk = 0x40000000
	// Bit SSHIFT.
	OctoSPI_WPTCR_SSHIFT = 0x40000000

	// WPIR: wrap instruction register
	// Position of INSTRUCTION field.
	OctoSPI_WPIR_INSTRUCTION_Pos = 0x0
	// Bit mask of INSTRUCTION field.
	OctoSPI_WPIR_INSTRUCTION_Msk = 0xffffffff

	// WPABR: wrap alternate bytes register
	// Position of ALTERNATE field.
	OctoSPI_WPABR_ALTERNATE_Pos = 0x0
	// Bit mask of ALTERNATE field.
	OctoSPI_WPABR_ALTERNATE_Msk = 0xffffffff

	// WCCR: write communication configuration register
	// Position of IMODE field.
	OctoSPI_WCCR_IMODE_Pos = 0x0
	// Bit mask of IMODE field.
	OctoSPI_WCCR_IMODE_Msk = 0x3
	// Position of IDTR field.
	OctoSPI_WCCR_IDTR_Pos = 0x2
	// Bit mask of IDTR field.
	OctoSPI_WCCR_IDTR_Msk = 0x4
	// Bit IDTR.
	OctoSPI_WCCR_IDTR = 0x4
	// Position of ISIZE field.
	OctoSPI_WCCR_ISIZE_Pos = 0x3
	// Bit mask of ISIZE field.
	OctoSPI_WCCR_ISIZE_Msk = 0x8
	// Bit ISIZE.
	OctoSPI_WCCR_ISIZE = 0x8
	// Position of ADMODE field.
	OctoSPI_WCCR_ADMODE_Pos = 0x8
	// Bit mask of ADMODE field.
	OctoSPI_WCCR_ADMODE_Msk = 0x700
	// Position of ADDTR field.
	OctoSPI_WCCR_ADDTR_Pos = 0xb
	// Bit mask of ADDTR field.
	OctoSPI_WCCR_ADDTR_Msk = 0x800
	// Bit ADDTR.
	OctoSPI_WCCR_ADDTR = 0x800
	// Position of ADSIZE field.
	OctoSPI_WCCR_ADSIZE_Pos = 0xc
	// Bit mask of ADSIZE field.
	OctoSPI_WCCR_ADSIZE_Msk = 0x3000
	// Position of ABMODE field.
	OctoSPI_WCCR_ABMODE_Pos = 0x10
	// Bit mask of ABMODE field.
	OctoSPI_WCCR_ABMODE_Msk = 0x70000
	// Position of ABDTR field.
	OctoSPI_WCCR_ABDTR_Pos = 0x13
	// Bit mask of ABDTR field.
	OctoSPI_WCCR_ABDTR_Msk = 0x80000
	// Bit ABDTR.
	OctoSPI_WCCR_ABDTR = 0x80000
	// Position of ABSIZE field.
	OctoSPI_WCCR_ABSIZE_Pos = 0x14
	// Bit mask of ABSIZE field.
	OctoSPI_WCCR_ABSIZE_Msk = 0x300000
	// Position of DMODE field.
	OctoSPI_WCCR_DMODE_Pos = 0x18
	// Bit mask of DMODE field.
	OctoSPI_WCCR_DMODE_Msk = 0x7000000
	// Position of DDTR field.
	OctoSPI_WCCR_DDTR_Pos = 0x1b
	// Bit mask of DDTR field.
	OctoSPI_WCCR_DDTR_Msk = 0x8000000
	// Bit DDTR.
	OctoSPI_WCCR_DDTR = 0x8000000
	// Position of DQSE field.
	OctoSPI_WCCR_DQSE_Pos = 0x1d
	// Bit mask of DQSE field.
	OctoSPI_WCCR_DQSE_Msk = 0x20000000
	// Bit DQSE.
	OctoSPI_WCCR_DQSE = 0x20000000

	// WTCR: write timing configuration register
	// Position of DCYC field.
	OctoSPI_WTCR_DCYC_Pos = 0x0
	// Bit mask of DCYC field.
	OctoSPI_WTCR_DCYC_Msk = 0x1f

	// WIR: instruction register
	// Position of INSTRUCTION field.
	OctoSPI_WIR_INSTRUCTION_Pos = 0x0
	// Bit mask of INSTRUCTION field.
	OctoSPI_WIR_INSTRUCTION_Msk = 0xffffffff

	// WABR: write alternate bytes register
	// Position of ALTERNATE field.
	OctoSPI_WABR_ALTERNATE_Pos = 0x0
	// Bit mask of ALTERNATE field.
	OctoSPI_WABR_ALTERNATE_Msk = 0xffffffff

	// HLCR: HyperBusTM latency configuration register
	// Position of LM field.
	OctoSPI_HLCR_LM_Pos = 0x0
	// Bit mask of LM field.
	OctoSPI_HLCR_LM_Msk = 0x1
	// Bit LM.
	OctoSPI_HLCR_LM = 0x1
	// Position of WZL field.
	OctoSPI_HLCR_WZL_Pos = 0x1
	// Bit mask of WZL field.
	OctoSPI_HLCR_WZL_Msk = 0x2
	// Bit WZL.
	OctoSPI_HLCR_WZL = 0x2
	// Position of TACC field.
	OctoSPI_HLCR_TACC_Pos = 0x8
	// Bit mask of TACC field.
	OctoSPI_HLCR_TACC_Msk = 0xff00
	// Position of TRWR field.
	OctoSPI_HLCR_TRWR_Pos = 0x10
	// Bit mask of TRWR field.
	OctoSPI_HLCR_TRWR_Msk = 0xff0000
)

// Constants for OPAMP: Operational amplifiers
const (
	// OPAMP1_CSR: OPAMP1 control/status register
	// Position of OPAEN field.
	OPAMP_OPAMP1_CSR_OPAEN_Pos = 0x0
	// Bit mask of OPAEN field.
	OPAMP_OPAMP1_CSR_OPAEN_Msk = 0x1
	// Bit OPAEN.
	OPAMP_OPAMP1_CSR_OPAEN = 0x1
	// Position of FORCE_VP field.
	OPAMP_OPAMP1_CSR_FORCE_VP_Pos = 0x1
	// Bit mask of FORCE_VP field.
	OPAMP_OPAMP1_CSR_FORCE_VP_Msk = 0x2
	// Bit FORCE_VP.
	OPAMP_OPAMP1_CSR_FORCE_VP = 0x2
	// Position of VP_SEL field.
	OPAMP_OPAMP1_CSR_VP_SEL_Pos = 0x2
	// Bit mask of VP_SEL field.
	OPAMP_OPAMP1_CSR_VP_SEL_Msk = 0xc
	// Position of VM_SEL field.
	OPAMP_OPAMP1_CSR_VM_SEL_Pos = 0x5
	// Bit mask of VM_SEL field.
	OPAMP_OPAMP1_CSR_VM_SEL_Msk = 0x60
	// Position of OPAHSM field.
	OPAMP_OPAMP1_CSR_OPAHSM_Pos = 0x8
	// Bit mask of OPAHSM field.
	OPAMP_OPAMP1_CSR_OPAHSM_Msk = 0x100
	// Bit OPAHSM.
	OPAMP_OPAMP1_CSR_OPAHSM = 0x100
	// Position of CALON field.
	OPAMP_OPAMP1_CSR_CALON_Pos = 0xb
	// Bit mask of CALON field.
	OPAMP_OPAMP1_CSR_CALON_Msk = 0x800
	// Bit CALON.
	OPAMP_OPAMP1_CSR_CALON = 0x800
	// Position of CALSEL field.
	OPAMP_OPAMP1_CSR_CALSEL_Pos = 0xc
	// Bit mask of CALSEL field.
	OPAMP_OPAMP1_CSR_CALSEL_Msk = 0x3000
	// Position of PGA_GAIN field.
	OPAMP_OPAMP1_CSR_PGA_GAIN_Pos = 0xe
	// Bit mask of PGA_GAIN field.
	OPAMP_OPAMP1_CSR_PGA_GAIN_Msk = 0x3c000
	// Position of USERTRIM field.
	OPAMP_OPAMP1_CSR_USERTRIM_Pos = 0x12
	// Bit mask of USERTRIM field.
	OPAMP_OPAMP1_CSR_USERTRIM_Msk = 0x40000
	// Bit USERTRIM.
	OPAMP_OPAMP1_CSR_USERTRIM = 0x40000
	// Position of TSTREF field.
	OPAMP_OPAMP1_CSR_TSTREF_Pos = 0x1d
	// Bit mask of TSTREF field.
	OPAMP_OPAMP1_CSR_TSTREF_Msk = 0x20000000
	// Bit TSTREF.
	OPAMP_OPAMP1_CSR_TSTREF = 0x20000000
	// Position of CALOUT field.
	OPAMP_OPAMP1_CSR_CALOUT_Pos = 0x1e
	// Bit mask of CALOUT field.
	OPAMP_OPAMP1_CSR_CALOUT_Msk = 0x40000000
	// Bit CALOUT.
	OPAMP_OPAMP1_CSR_CALOUT = 0x40000000

	// OPAMP1_OTR: OPAMP1 offset trimming register in normal mode
	// Position of TRIMOFFSETN field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETN_Pos = 0x0
	// Bit mask of TRIMOFFSETN field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETN_Msk = 0x1f
	// Position of TRIMOFFSETP field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETP_Pos = 0x8
	// Bit mask of TRIMOFFSETP field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETP_Msk = 0x1f00

	// OPAMP1_HSOTR: OPAMP1 offset trimming register in low-power mode
	// Position of TRIMLPOFFSETN field.
	OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN_Pos = 0x0
	// Bit mask of TRIMLPOFFSETN field.
	OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN_Msk = 0x1f
	// Position of TRIMLPOFFSETP field.
	OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP_Pos = 0x8
	// Bit mask of TRIMLPOFFSETP field.
	OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP_Msk = 0x1f00

	// OPAMP2_CSR: OPAMP2 control/status register
	// Position of OPAEN field.
	OPAMP_OPAMP2_CSR_OPAEN_Pos = 0x0
	// Bit mask of OPAEN field.
	OPAMP_OPAMP2_CSR_OPAEN_Msk = 0x1
	// Bit OPAEN.
	OPAMP_OPAMP2_CSR_OPAEN = 0x1
	// Position of FORCE_VP field.
	OPAMP_OPAMP2_CSR_FORCE_VP_Pos = 0x1
	// Bit mask of FORCE_VP field.
	OPAMP_OPAMP2_CSR_FORCE_VP_Msk = 0x2
	// Bit FORCE_VP.
	OPAMP_OPAMP2_CSR_FORCE_VP = 0x2
	// Position of VM_SEL field.
	OPAMP_OPAMP2_CSR_VM_SEL_Pos = 0x5
	// Bit mask of VM_SEL field.
	OPAMP_OPAMP2_CSR_VM_SEL_Msk = 0x60
	// Position of OPAHSM field.
	OPAMP_OPAMP2_CSR_OPAHSM_Pos = 0x8
	// Bit mask of OPAHSM field.
	OPAMP_OPAMP2_CSR_OPAHSM_Msk = 0x100
	// Bit OPAHSM.
	OPAMP_OPAMP2_CSR_OPAHSM = 0x100
	// Position of CALON field.
	OPAMP_OPAMP2_CSR_CALON_Pos = 0xb
	// Bit mask of CALON field.
	OPAMP_OPAMP2_CSR_CALON_Msk = 0x800
	// Bit CALON.
	OPAMP_OPAMP2_CSR_CALON = 0x800
	// Position of CALSEL field.
	OPAMP_OPAMP2_CSR_CALSEL_Pos = 0xc
	// Bit mask of CALSEL field.
	OPAMP_OPAMP2_CSR_CALSEL_Msk = 0x3000
	// Position of PGA_GAIN field.
	OPAMP_OPAMP2_CSR_PGA_GAIN_Pos = 0xe
	// Bit mask of PGA_GAIN field.
	OPAMP_OPAMP2_CSR_PGA_GAIN_Msk = 0x3c000
	// Position of USERTRIM field.
	OPAMP_OPAMP2_CSR_USERTRIM_Pos = 0x12
	// Bit mask of USERTRIM field.
	OPAMP_OPAMP2_CSR_USERTRIM_Msk = 0x40000
	// Bit USERTRIM.
	OPAMP_OPAMP2_CSR_USERTRIM = 0x40000
	// Position of TSTREF field.
	OPAMP_OPAMP2_CSR_TSTREF_Pos = 0x1d
	// Bit mask of TSTREF field.
	OPAMP_OPAMP2_CSR_TSTREF_Msk = 0x20000000
	// Bit TSTREF.
	OPAMP_OPAMP2_CSR_TSTREF = 0x20000000
	// Position of CALOUT field.
	OPAMP_OPAMP2_CSR_CALOUT_Pos = 0x1e
	// Bit mask of CALOUT field.
	OPAMP_OPAMP2_CSR_CALOUT_Msk = 0x40000000
	// Bit CALOUT.
	OPAMP_OPAMP2_CSR_CALOUT = 0x40000000

	// OPAMP2_OTR: OPAMP2 offset trimming register in normal mode
	// Position of TRIMOFFSETN field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETN_Pos = 0x0
	// Bit mask of TRIMOFFSETN field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETN_Msk = 0x1f
	// Position of TRIMOFFSETP field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETP_Pos = 0x8
	// Bit mask of TRIMOFFSETP field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETP_Msk = 0x1f00

	// OPAMP2_HSOTR: OPAMP2 offset trimming register in low-power mode
	// Position of TRIMLPOFFSETN field.
	OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN_Pos = 0x0
	// Bit mask of TRIMLPOFFSETN field.
	OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN_Msk = 0x1f
	// Position of TRIMLPOFFSETP field.
	OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP_Pos = 0x8
	// Bit mask of TRIMLPOFFSETP field.
	OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP_Msk = 0x1f00
)

// Constants for OTG1_HS_DEVICE: USB 1 on the go high speed
const (
	// DCFG: OTG_HS device configuration register
	// Position of DSPD field.
	USB_OTG_HS_DCFG_DSPD_Pos = 0x0
	// Bit mask of DSPD field.
	USB_OTG_HS_DCFG_DSPD_Msk = 0x3
	// Position of NZLSOHSK field.
	USB_OTG_HS_DCFG_NZLSOHSK_Pos = 0x2
	// Bit mask of NZLSOHSK field.
	USB_OTG_HS_DCFG_NZLSOHSK_Msk = 0x4
	// Bit NZLSOHSK.
	USB_OTG_HS_DCFG_NZLSOHSK = 0x4
	// Position of DAD field.
	USB_OTG_HS_DCFG_DAD_Pos = 0x4
	// Bit mask of DAD field.
	USB_OTG_HS_DCFG_DAD_Msk = 0x7f0
	// Position of PFIVL field.
	USB_OTG_HS_DCFG_PFIVL_Pos = 0xb
	// Bit mask of PFIVL field.
	USB_OTG_HS_DCFG_PFIVL_Msk = 0x1800
	// Position of PERSCHIVL field.
	USB_OTG_HS_DCFG_PERSCHIVL_Pos = 0x18
	// Bit mask of PERSCHIVL field.
	USB_OTG_HS_DCFG_PERSCHIVL_Msk = 0x3000000

	// DCTL: OTG_HS device control register
	// Position of RWUSIG field.
	USB_OTG_HS_DCTL_RWUSIG_Pos = 0x0
	// Bit mask of RWUSIG field.
	USB_OTG_HS_DCTL_RWUSIG_Msk = 0x1
	// Bit RWUSIG.
	USB_OTG_HS_DCTL_RWUSIG = 0x1
	// Position of SDIS field.
	USB_OTG_HS_DCTL_SDIS_Pos = 0x1
	// Bit mask of SDIS field.
	USB_OTG_HS_DCTL_SDIS_Msk = 0x2
	// Bit SDIS.
	USB_OTG_HS_DCTL_SDIS = 0x2
	// Position of GINSTS field.
	USB_OTG_HS_DCTL_GINSTS_Pos = 0x2
	// Bit mask of GINSTS field.
	USB_OTG_HS_DCTL_GINSTS_Msk = 0x4
	// Bit GINSTS.
	USB_OTG_HS_DCTL_GINSTS = 0x4
	// Position of GONSTS field.
	USB_OTG_HS_DCTL_GONSTS_Pos = 0x3
	// Bit mask of GONSTS field.
	USB_OTG_HS_DCTL_GONSTS_Msk = 0x8
	// Bit GONSTS.
	USB_OTG_HS_DCTL_GONSTS = 0x8
	// Position of TCTL field.
	USB_OTG_HS_DCTL_TCTL_Pos = 0x4
	// Bit mask of TCTL field.
	USB_OTG_HS_DCTL_TCTL_Msk = 0x70
	// Position of SGINAK field.
	USB_OTG_HS_DCTL_SGINAK_Pos = 0x7
	// Bit mask of SGINAK field.
	USB_OTG_HS_DCTL_SGINAK_Msk = 0x80
	// Bit SGINAK.
	USB_OTG_HS_DCTL_SGINAK = 0x80
	// Position of CGINAK field.
	USB_OTG_HS_DCTL_CGINAK_Pos = 0x8
	// Bit mask of CGINAK field.
	USB_OTG_HS_DCTL_CGINAK_Msk = 0x100
	// Bit CGINAK.
	USB_OTG_HS_DCTL_CGINAK = 0x100
	// Position of SGONAK field.
	USB_OTG_HS_DCTL_SGONAK_Pos = 0x9
	// Bit mask of SGONAK field.
	USB_OTG_HS_DCTL_SGONAK_Msk = 0x200
	// Bit SGONAK.
	USB_OTG_HS_DCTL_SGONAK = 0x200
	// Position of CGONAK field.
	USB_OTG_HS_DCTL_CGONAK_Pos = 0xa
	// Bit mask of CGONAK field.
	USB_OTG_HS_DCTL_CGONAK_Msk = 0x400
	// Bit CGONAK.
	USB_OTG_HS_DCTL_CGONAK = 0x400
	// Position of POPRGDNE field.
	USB_OTG_HS_DCTL_POPRGDNE_Pos = 0xb
	// Bit mask of POPRGDNE field.
	USB_OTG_HS_DCTL_POPRGDNE_Msk = 0x800
	// Bit POPRGDNE.
	USB_OTG_HS_DCTL_POPRGDNE = 0x800

	// DSTS: OTG_HS device status register
	// Position of SUSPSTS field.
	USB_OTG_HS_DSTS_SUSPSTS_Pos = 0x0
	// Bit mask of SUSPSTS field.
	USB_OTG_HS_DSTS_SUSPSTS_Msk = 0x1
	// Bit SUSPSTS.
	USB_OTG_HS_DSTS_SUSPSTS = 0x1
	// Position of ENUMSPD field.
	USB_OTG_HS_DSTS_ENUMSPD_Pos = 0x1
	// Bit mask of ENUMSPD field.
	USB_OTG_HS_DSTS_ENUMSPD_Msk = 0x6
	// Position of EERR field.
	USB_OTG_HS_DSTS_EERR_Pos = 0x3
	// Bit mask of EERR field.
	USB_OTG_HS_DSTS_EERR_Msk = 0x8
	// Bit EERR.
	USB_OTG_HS_DSTS_EERR = 0x8
	// Position of FNSOF field.
	USB_OTG_HS_DSTS_FNSOF_Pos = 0x8
	// Bit mask of FNSOF field.
	USB_OTG_HS_DSTS_FNSOF_Msk = 0x3fff00

	// DIEPMSK: OTG_HS device IN endpoint common interrupt mask register
	// Position of XFRCM field.
	USB_OTG_HS_DIEPMSK_XFRCM_Pos = 0x0
	// Bit mask of XFRCM field.
	USB_OTG_HS_DIEPMSK_XFRCM_Msk = 0x1
	// Bit XFRCM.
	USB_OTG_HS_DIEPMSK_XFRCM = 0x1
	// Position of EPDM field.
	USB_OTG_HS_DIEPMSK_EPDM_Pos = 0x1
	// Bit mask of EPDM field.
	USB_OTG_HS_DIEPMSK_EPDM_Msk = 0x2
	// Bit EPDM.
	USB_OTG_HS_DIEPMSK_EPDM = 0x2
	// Position of TOM field.
	USB_OTG_HS_DIEPMSK_TOM_Pos = 0x3
	// Bit mask of TOM field.
	USB_OTG_HS_DIEPMSK_TOM_Msk = 0x8
	// Bit TOM.
	USB_OTG_HS_DIEPMSK_TOM = 0x8
	// Position of ITTXFEMSK field.
	USB_OTG_HS_DIEPMSK_ITTXFEMSK_Pos = 0x4
	// Bit mask of ITTXFEMSK field.
	USB_OTG_HS_DIEPMSK_ITTXFEMSK_Msk = 0x10
	// Bit ITTXFEMSK.
	USB_OTG_HS_DIEPMSK_ITTXFEMSK = 0x10
	// Position of INEPNMM field.
	USB_OTG_HS_DIEPMSK_INEPNMM_Pos = 0x5
	// Bit mask of INEPNMM field.
	USB_OTG_HS_DIEPMSK_INEPNMM_Msk = 0x20
	// Bit INEPNMM.
	USB_OTG_HS_DIEPMSK_INEPNMM = 0x20
	// Position of INEPNEM field.
	USB_OTG_HS_DIEPMSK_INEPNEM_Pos = 0x6
	// Bit mask of INEPNEM field.
	USB_OTG_HS_DIEPMSK_INEPNEM_Msk = 0x40
	// Bit INEPNEM.
	USB_OTG_HS_DIEPMSK_INEPNEM = 0x40
	// Position of TXFURM field.
	USB_OTG_HS_DIEPMSK_TXFURM_Pos = 0x8
	// Bit mask of TXFURM field.
	USB_OTG_HS_DIEPMSK_TXFURM_Msk = 0x100
	// Bit TXFURM.
	USB_OTG_HS_DIEPMSK_TXFURM = 0x100
	// Position of BIM field.
	USB_OTG_HS_DIEPMSK_BIM_Pos = 0x9
	// Bit mask of BIM field.
	USB_OTG_HS_DIEPMSK_BIM_Msk = 0x200
	// Bit BIM.
	USB_OTG_HS_DIEPMSK_BIM = 0x200

	// DOEPMSK: OTG_HS device OUT endpoint common interrupt mask register
	// Position of XFRCM field.
	USB_OTG_HS_DOEPMSK_XFRCM_Pos = 0x0
	// Bit mask of XFRCM field.
	USB_OTG_HS_DOEPMSK_XFRCM_Msk = 0x1
	// Bit XFRCM.
	USB_OTG_HS_DOEPMSK_XFRCM = 0x1
	// Position of EPDM field.
	USB_OTG_HS_DOEPMSK_EPDM_Pos = 0x1
	// Bit mask of EPDM field.
	USB_OTG_HS_DOEPMSK_EPDM_Msk = 0x2
	// Bit EPDM.
	USB_OTG_HS_DOEPMSK_EPDM = 0x2
	// Position of STUPM field.
	USB_OTG_HS_DOEPMSK_STUPM_Pos = 0x3
	// Bit mask of STUPM field.
	USB_OTG_HS_DOEPMSK_STUPM_Msk = 0x8
	// Bit STUPM.
	USB_OTG_HS_DOEPMSK_STUPM = 0x8
	// Position of OTEPDM field.
	USB_OTG_HS_DOEPMSK_OTEPDM_Pos = 0x4
	// Bit mask of OTEPDM field.
	USB_OTG_HS_DOEPMSK_OTEPDM_Msk = 0x10
	// Bit OTEPDM.
	USB_OTG_HS_DOEPMSK_OTEPDM = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPMSK_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPMSK_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPMSK_B2BSTUP = 0x40
	// Position of OPEM field.
	USB_OTG_HS_DOEPMSK_OPEM_Pos = 0x8
	// Bit mask of OPEM field.
	USB_OTG_HS_DOEPMSK_OPEM_Msk = 0x100
	// Bit OPEM.
	USB_OTG_HS_DOEPMSK_OPEM = 0x100
	// Position of BOIM field.
	USB_OTG_HS_DOEPMSK_BOIM_Pos = 0x9
	// Bit mask of BOIM field.
	USB_OTG_HS_DOEPMSK_BOIM_Msk = 0x200
	// Bit BOIM.
	USB_OTG_HS_DOEPMSK_BOIM = 0x200

	// DAINT: OTG_HS device all endpoints interrupt register
	// Position of IEPINT field.
	USB_OTG_HS_DAINT_IEPINT_Pos = 0x0
	// Bit mask of IEPINT field.
	USB_OTG_HS_DAINT_IEPINT_Msk = 0xffff
	// Position of OEPINT field.
	USB_OTG_HS_DAINT_OEPINT_Pos = 0x10
	// Bit mask of OEPINT field.
	USB_OTG_HS_DAINT_OEPINT_Msk = 0xffff0000

	// DAINTMSK: OTG_HS all endpoints interrupt mask register
	// Position of IEPM field.
	USB_OTG_HS_DAINTMSK_IEPM_Pos = 0x0
	// Bit mask of IEPM field.
	USB_OTG_HS_DAINTMSK_IEPM_Msk = 0xffff
	// Position of OEPM field.
	USB_OTG_HS_DAINTMSK_OEPM_Pos = 0x10
	// Bit mask of OEPM field.
	USB_OTG_HS_DAINTMSK_OEPM_Msk = 0xffff0000

	// DVBUSDIS: OTG_HS device VBUS discharge time register
	// Position of VBUSDT field.
	USB_OTG_HS_DVBUSDIS_VBUSDT_Pos = 0x0
	// Bit mask of VBUSDT field.
	USB_OTG_HS_DVBUSDIS_VBUSDT_Msk = 0xffff

	// DVBUSPULSE: OTG_HS device VBUS pulsing time register
	// Position of DVBUSP field.
	USB_OTG_HS_DVBUSPULSE_DVBUSP_Pos = 0x0
	// Bit mask of DVBUSP field.
	USB_OTG_HS_DVBUSPULSE_DVBUSP_Msk = 0xfff

	// DTHRCTL: OTG_HS Device threshold control register
	// Position of NONISOTHREN field.
	USB_OTG_HS_DTHRCTL_NONISOTHREN_Pos = 0x0
	// Bit mask of NONISOTHREN field.
	USB_OTG_HS_DTHRCTL_NONISOTHREN_Msk = 0x1
	// Bit NONISOTHREN.
	USB_OTG_HS_DTHRCTL_NONISOTHREN = 0x1
	// Position of ISOTHREN field.
	USB_OTG_HS_DTHRCTL_ISOTHREN_Pos = 0x1
	// Bit mask of ISOTHREN field.
	USB_OTG_HS_DTHRCTL_ISOTHREN_Msk = 0x2
	// Bit ISOTHREN.
	USB_OTG_HS_DTHRCTL_ISOTHREN = 0x2
	// Position of TXTHRLEN field.
	USB_OTG_HS_DTHRCTL_TXTHRLEN_Pos = 0x2
	// Bit mask of TXTHRLEN field.
	USB_OTG_HS_DTHRCTL_TXTHRLEN_Msk = 0x7fc
	// Position of RXTHREN field.
	USB_OTG_HS_DTHRCTL_RXTHREN_Pos = 0x10
	// Bit mask of RXTHREN field.
	USB_OTG_HS_DTHRCTL_RXTHREN_Msk = 0x10000
	// Bit RXTHREN.
	USB_OTG_HS_DTHRCTL_RXTHREN = 0x10000
	// Position of RXTHRLEN field.
	USB_OTG_HS_DTHRCTL_RXTHRLEN_Pos = 0x11
	// Bit mask of RXTHRLEN field.
	USB_OTG_HS_DTHRCTL_RXTHRLEN_Msk = 0x3fe0000
	// Position of ARPEN field.
	USB_OTG_HS_DTHRCTL_ARPEN_Pos = 0x1b
	// Bit mask of ARPEN field.
	USB_OTG_HS_DTHRCTL_ARPEN_Msk = 0x8000000
	// Bit ARPEN.
	USB_OTG_HS_DTHRCTL_ARPEN = 0x8000000

	// DIEPEMPMSK: OTG_HS device IN endpoint FIFO empty interrupt mask register
	// Position of INEPTXFEM field.
	USB_OTG_HS_DIEPEMPMSK_INEPTXFEM_Pos = 0x0
	// Bit mask of INEPTXFEM field.
	USB_OTG_HS_DIEPEMPMSK_INEPTXFEM_Msk = 0xffff

	// DEACHINT: OTG_HS device each endpoint interrupt register
	// Position of IEP1INT field.
	USB_OTG_HS_DEACHINT_IEP1INT_Pos = 0x1
	// Bit mask of IEP1INT field.
	USB_OTG_HS_DEACHINT_IEP1INT_Msk = 0x2
	// Bit IEP1INT.
	USB_OTG_HS_DEACHINT_IEP1INT = 0x2
	// Position of OEP1INT field.
	USB_OTG_HS_DEACHINT_OEP1INT_Pos = 0x11
	// Bit mask of OEP1INT field.
	USB_OTG_HS_DEACHINT_OEP1INT_Msk = 0x20000
	// Bit OEP1INT.
	USB_OTG_HS_DEACHINT_OEP1INT = 0x20000

	// DEACHINTMSK: OTG_HS device each endpoint interrupt register mask
	// Position of IEP1INTM field.
	USB_OTG_HS_DEACHINTMSK_IEP1INTM_Pos = 0x1
	// Bit mask of IEP1INTM field.
	USB_OTG_HS_DEACHINTMSK_IEP1INTM_Msk = 0x2
	// Bit IEP1INTM.
	USB_OTG_HS_DEACHINTMSK_IEP1INTM = 0x2
	// Position of OEP1INTM field.
	USB_OTG_HS_DEACHINTMSK_OEP1INTM_Pos = 0x11
	// Bit mask of OEP1INTM field.
	USB_OTG_HS_DEACHINTMSK_OEP1INTM_Msk = 0x20000
	// Bit OEP1INTM.
	USB_OTG_HS_DEACHINTMSK_OEP1INTM = 0x20000

	// DIEPCTL0: OTG device endpoint-0 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL0_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL0_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL0_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL0_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL0_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL0_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL0_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL0_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL0_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL0_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL0_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL0_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL0_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL0_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL0_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL0_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL0_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL0_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL0_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL0_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL0_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL0_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL0_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL0_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL0_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL0_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL0_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL0_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL0_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL0_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL0_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL0_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL0_EPENA = 0x80000000

	// DIEPINT0: OTG device endpoint-0 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT0_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT0_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT0_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT0_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT0_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT0_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT0_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT0_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT0_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT0_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT0_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT0_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT0_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT0_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT0_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT0_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT0_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT0_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT0_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT0_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT0_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT0_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT0_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT0_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT0_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT0_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT0_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT0_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT0_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT0_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT0_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT0_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT0_NAK = 0x2000

	// DIEPTSIZ0: OTG_HS device IN endpoint 0 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ0_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ0_XFRSIZ_Msk = 0x7f
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ0_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ0_PKTCNT_Msk = 0x180000

	// DIEPDMA1: OTG_HS device endpoint-1 DMA address register
	// Position of DMAADDR field.
	USB_OTG_HS_DIEPDMA1_DMAADDR_Pos = 0x0
	// Bit mask of DMAADDR field.
	USB_OTG_HS_DIEPDMA1_DMAADDR_Msk = 0xffffffff

	// DTXFSTS0: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS0_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS0_INEPTFSAV_Msk = 0xffff

	// DIEPCTL1: OTG device endpoint-1 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL1_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL1_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL1_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL1_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL1_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL1_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL1_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL1_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL1_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL1_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL1_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL1_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL1_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL1_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL1_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL1_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL1_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL1_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL1_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL1_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL1_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL1_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL1_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL1_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL1_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL1_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL1_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL1_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL1_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL1_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL1_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL1_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL1_EPENA = 0x80000000

	// DIEPINT1: OTG device endpoint-1 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT1_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT1_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT1_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT1_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT1_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT1_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT1_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT1_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT1_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT1_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT1_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT1_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT1_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT1_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT1_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT1_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT1_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT1_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT1_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT1_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT1_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT1_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT1_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT1_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT1_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT1_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT1_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT1_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT1_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT1_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT1_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT1_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT1_NAK = 0x2000

	// DIEPTSIZ1: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ1_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ1_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ1_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ1_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ1_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ1_MCNT_Msk = 0x60000000

	// DIEPDMA2: OTG_HS device endpoint-2 DMA address register
	// Position of DMAADDR field.
	USB_OTG_HS_DIEPDMA2_DMAADDR_Pos = 0x0
	// Bit mask of DMAADDR field.
	USB_OTG_HS_DIEPDMA2_DMAADDR_Msk = 0xffffffff

	// DTXFSTS1: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS1_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS1_INEPTFSAV_Msk = 0xffff

	// DIEPCTL2: OTG device endpoint-2 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL2_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL2_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL2_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL2_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL2_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL2_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL2_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL2_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL2_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL2_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL2_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL2_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL2_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL2_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL2_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL2_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL2_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL2_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL2_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL2_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL2_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL2_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL2_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL2_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL2_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL2_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL2_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL2_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL2_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL2_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL2_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL2_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL2_EPENA = 0x80000000

	// DIEPINT2: OTG device endpoint-2 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT2_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT2_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT2_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT2_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT2_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT2_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT2_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT2_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT2_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT2_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT2_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT2_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT2_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT2_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT2_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT2_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT2_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT2_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT2_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT2_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT2_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT2_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT2_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT2_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT2_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT2_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT2_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT2_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT2_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT2_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT2_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT2_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT2_NAK = 0x2000

	// DIEPTSIZ2: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ2_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ2_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ2_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ2_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ2_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ2_MCNT_Msk = 0x60000000

	// DIEPDMA3: OTG_HS device endpoint-3 DMA address register
	// Position of DMAADDR field.
	USB_OTG_HS_DIEPDMA3_DMAADDR_Pos = 0x0
	// Bit mask of DMAADDR field.
	USB_OTG_HS_DIEPDMA3_DMAADDR_Msk = 0xffffffff

	// DTXFSTS2: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS2_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS2_INEPTFSAV_Msk = 0xffff

	// DIEPCTL3: OTG device endpoint-3 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL3_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL3_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL3_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL3_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL3_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL3_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL3_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL3_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL3_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL3_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL3_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL3_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL3_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL3_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL3_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL3_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL3_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL3_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL3_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL3_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL3_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL3_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL3_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL3_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL3_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL3_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL3_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL3_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL3_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL3_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL3_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL3_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL3_EPENA = 0x80000000

	// DIEPINT3: OTG device endpoint-3 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT3_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT3_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT3_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT3_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT3_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT3_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT3_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT3_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT3_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT3_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT3_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT3_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT3_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT3_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT3_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT3_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT3_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT3_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT3_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT3_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT3_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT3_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT3_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT3_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT3_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT3_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT3_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT3_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT3_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT3_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT3_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT3_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT3_NAK = 0x2000

	// DIEPTSIZ3: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ3_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ3_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ3_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ3_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ3_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ3_MCNT_Msk = 0x60000000

	// DIEPDMA4: OTG_HS device endpoint-4 DMA address register
	// Position of DMAADDR field.
	USB_OTG_HS_DIEPDMA4_DMAADDR_Pos = 0x0
	// Bit mask of DMAADDR field.
	USB_OTG_HS_DIEPDMA4_DMAADDR_Msk = 0xffffffff

	// DTXFSTS3: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS3_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS3_INEPTFSAV_Msk = 0xffff

	// DIEPCTL4: OTG device endpoint-4 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL4_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL4_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL4_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL4_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL4_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL4_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL4_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL4_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL4_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL4_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL4_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL4_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL4_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL4_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL4_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL4_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL4_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL4_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL4_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL4_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL4_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL4_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL4_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL4_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL4_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL4_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL4_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL4_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL4_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL4_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL4_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL4_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL4_EPENA = 0x80000000

	// DIEPINT4: OTG device endpoint-4 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT4_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT4_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT4_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT4_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT4_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT4_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT4_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT4_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT4_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT4_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT4_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT4_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT4_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT4_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT4_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT4_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT4_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT4_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT4_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT4_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT4_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT4_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT4_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT4_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT4_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT4_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT4_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT4_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT4_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT4_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT4_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT4_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT4_NAK = 0x2000

	// DIEPTSIZ4: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ4_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ4_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ4_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ4_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ4_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ4_MCNT_Msk = 0x60000000

	// DIEPDMA5: OTG_HS device endpoint-5 DMA address register
	// Position of DMAADDR field.
	USB_OTG_HS_DIEPDMA5_DMAADDR_Pos = 0x0
	// Bit mask of DMAADDR field.
	USB_OTG_HS_DIEPDMA5_DMAADDR_Msk = 0xffffffff

	// DTXFSTS4: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS4_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS4_INEPTFSAV_Msk = 0xffff

	// DIEPCTL5: OTG device endpoint-5 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL5_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL5_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL5_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL5_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL5_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL5_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL5_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL5_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL5_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL5_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL5_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL5_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL5_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL5_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL5_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL5_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL5_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL5_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL5_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL5_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL5_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL5_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL5_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL5_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL5_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL5_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL5_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL5_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL5_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL5_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL5_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL5_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL5_EPENA = 0x80000000

	// DIEPTSIZ6: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ6_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ6_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ6_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ6_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ6_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ6_MCNT_Msk = 0x60000000

	// DTXFSTS6: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS6_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS6_INEPTFSAV_Msk = 0xffff

	// DIEPINT5: OTG device endpoint-5 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT5_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT5_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT5_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT5_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT5_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT5_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT5_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT5_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT5_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT5_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT5_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT5_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT5_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT5_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT5_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT5_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT5_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT5_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT5_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT5_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT5_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT5_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT5_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT5_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT5_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT5_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT5_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT5_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT5_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT5_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT5_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT5_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT5_NAK = 0x2000

	// DIEPTSIZ7: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ7_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ7_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ7_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ7_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ7_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ7_MCNT_Msk = 0x60000000

	// DTXFSTS7: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS7_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS7_INEPTFSAV_Msk = 0xffff

	// DIEPTSIZ5: OTG_HS device endpoint transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ5_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DIEPTSIZ5_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ5_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DIEPTSIZ5_PKTCNT_Msk = 0x1ff80000
	// Position of MCNT field.
	USB_OTG_HS_DIEPTSIZ5_MCNT_Pos = 0x1d
	// Bit mask of MCNT field.
	USB_OTG_HS_DIEPTSIZ5_MCNT_Msk = 0x60000000

	// DTXFSTS5: OTG_HS device IN endpoint transmit FIFO status register
	// Position of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS5_INEPTFSAV_Pos = 0x0
	// Bit mask of INEPTFSAV field.
	USB_OTG_HS_DTXFSTS5_INEPTFSAV_Msk = 0xffff

	// DIEPCTL6: OTG device endpoint-6 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL6_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL6_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL6_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL6_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL6_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL6_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL6_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL6_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL6_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL6_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL6_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL6_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL6_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL6_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL6_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL6_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL6_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL6_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL6_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL6_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL6_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL6_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL6_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL6_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL6_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL6_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL6_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL6_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL6_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL6_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL6_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL6_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL6_EPENA = 0x80000000

	// DIEPINT6: OTG device endpoint-6 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT6_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT6_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT6_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT6_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT6_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT6_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT6_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT6_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT6_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT6_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT6_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT6_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT6_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT6_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT6_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT6_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT6_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT6_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT6_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT6_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT6_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT6_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT6_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT6_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT6_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT6_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT6_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT6_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT6_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT6_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT6_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT6_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT6_NAK = 0x2000

	// DIEPCTL7: OTG device endpoint-7 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DIEPCTL7_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DIEPCTL7_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DIEPCTL7_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DIEPCTL7_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DIEPCTL7_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL7_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DIEPCTL7_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DIEPCTL7_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DIEPCTL7_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DIEPCTL7_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DIEPCTL7_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DIEPCTL7_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DIEPCTL7_EPTYP_Msk = 0xc0000
	// Position of Stall field.
	USB_OTG_HS_DIEPCTL7_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DIEPCTL7_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DIEPCTL7_Stall = 0x200000
	// Position of TXFNUM field.
	USB_OTG_HS_DIEPCTL7_TXFNUM_Pos = 0x16
	// Bit mask of TXFNUM field.
	USB_OTG_HS_DIEPCTL7_TXFNUM_Msk = 0x3c00000
	// Position of CNAK field.
	USB_OTG_HS_DIEPCTL7_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DIEPCTL7_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DIEPCTL7_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DIEPCTL7_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DIEPCTL7_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DIEPCTL7_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DIEPCTL7_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DIEPCTL7_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DIEPCTL7_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DIEPCTL7_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DIEPCTL7_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DIEPCTL7_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DIEPCTL7_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DIEPCTL7_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DIEPCTL7_EPENA = 0x80000000

	// DIEPINT7: OTG device endpoint-7 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DIEPINT7_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DIEPINT7_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DIEPINT7_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DIEPINT7_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DIEPINT7_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DIEPINT7_EPDISD = 0x2
	// Position of TOC field.
	USB_OTG_HS_DIEPINT7_TOC_Pos = 0x3
	// Bit mask of TOC field.
	USB_OTG_HS_DIEPINT7_TOC_Msk = 0x8
	// Bit TOC.
	USB_OTG_HS_DIEPINT7_TOC = 0x8
	// Position of ITTXFE field.
	USB_OTG_HS_DIEPINT7_ITTXFE_Pos = 0x4
	// Bit mask of ITTXFE field.
	USB_OTG_HS_DIEPINT7_ITTXFE_Msk = 0x10
	// Bit ITTXFE.
	USB_OTG_HS_DIEPINT7_ITTXFE = 0x10
	// Position of INEPNE field.
	USB_OTG_HS_DIEPINT7_INEPNE_Pos = 0x6
	// Bit mask of INEPNE field.
	USB_OTG_HS_DIEPINT7_INEPNE_Msk = 0x40
	// Bit INEPNE.
	USB_OTG_HS_DIEPINT7_INEPNE = 0x40
	// Position of TXFE field.
	USB_OTG_HS_DIEPINT7_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	USB_OTG_HS_DIEPINT7_TXFE_Msk = 0x80
	// Bit TXFE.
	USB_OTG_HS_DIEPINT7_TXFE = 0x80
	// Position of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT7_TXFIFOUDRN_Pos = 0x8
	// Bit mask of TXFIFOUDRN field.
	USB_OTG_HS_DIEPINT7_TXFIFOUDRN_Msk = 0x100
	// Bit TXFIFOUDRN.
	USB_OTG_HS_DIEPINT7_TXFIFOUDRN = 0x100
	// Position of BNA field.
	USB_OTG_HS_DIEPINT7_BNA_Pos = 0x9
	// Bit mask of BNA field.
	USB_OTG_HS_DIEPINT7_BNA_Msk = 0x200
	// Bit BNA.
	USB_OTG_HS_DIEPINT7_BNA = 0x200
	// Position of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT7_PKTDRPSTS_Pos = 0xb
	// Bit mask of PKTDRPSTS field.
	USB_OTG_HS_DIEPINT7_PKTDRPSTS_Msk = 0x800
	// Bit PKTDRPSTS.
	USB_OTG_HS_DIEPINT7_PKTDRPSTS = 0x800
	// Position of BERR field.
	USB_OTG_HS_DIEPINT7_BERR_Pos = 0xc
	// Bit mask of BERR field.
	USB_OTG_HS_DIEPINT7_BERR_Msk = 0x1000
	// Bit BERR.
	USB_OTG_HS_DIEPINT7_BERR = 0x1000
	// Position of NAK field.
	USB_OTG_HS_DIEPINT7_NAK_Pos = 0xd
	// Bit mask of NAK field.
	USB_OTG_HS_DIEPINT7_NAK_Msk = 0x2000
	// Bit NAK.
	USB_OTG_HS_DIEPINT7_NAK = 0x2000

	// DOEPCTL0: OTG_HS device control OUT endpoint 0 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL0_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL0_MPSIZ_Msk = 0x3
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL0_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL0_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL0_USBAEP = 0x8000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL0_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL0_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL0_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL0_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL0_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL0_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL0_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL0_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL0_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL0_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL0_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL0_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL0_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL0_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL0_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL0_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL0_SNAK = 0x8000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL0_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL0_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL0_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL0_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL0_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL0_EPENA = 0x80000000

	// DOEPINT0: OTG_HS device endpoint-0 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT0_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT0_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT0_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT0_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT0_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT0_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT0_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT0_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT0_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT0_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT0_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT0_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT0_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT0_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT0_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT0_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT0_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT0_NYET = 0x4000

	// DOEPTSIZ0: OTG_HS device endpoint-0 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ0_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ0_XFRSIZ_Msk = 0x7f
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ0_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ0_PKTCNT_Msk = 0x80000
	// Bit PKTCNT.
	USB_OTG_HS_DOEPTSIZ0_PKTCNT = 0x80000
	// Position of STUPCNT field.
	USB_OTG_HS_DOEPTSIZ0_STUPCNT_Pos = 0x1d
	// Bit mask of STUPCNT field.
	USB_OTG_HS_DOEPTSIZ0_STUPCNT_Msk = 0x60000000

	// DOEPCTL1: OTG device endpoint-1 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL1_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL1_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL1_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL1_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL1_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL1_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL1_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL1_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL1_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL1_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL1_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL1_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL1_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL1_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL1_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL1_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL1_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL1_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL1_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL1_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL1_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL1_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL1_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL1_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL1_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL1_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL1_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL1_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL1_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL1_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL1_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL1_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL1_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL1_EPENA = 0x80000000

	// DOEPINT1: OTG_HS device endpoint-1 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT1_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT1_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT1_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT1_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT1_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT1_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT1_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT1_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT1_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT1_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT1_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT1_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT1_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT1_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT1_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT1_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT1_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT1_NYET = 0x4000

	// DOEPTSIZ1: OTG_HS device endpoint-1 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ1_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ1_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ1_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ1_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_Msk = 0x60000000

	// DOEPCTL2: OTG device endpoint-2 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL2_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL2_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL2_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL2_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL2_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL2_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL2_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL2_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL2_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL2_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL2_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL2_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL2_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL2_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL2_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL2_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL2_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL2_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL2_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL2_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL2_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL2_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL2_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL2_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL2_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL2_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL2_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL2_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL2_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL2_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL2_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL2_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL2_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL2_EPENA = 0x80000000

	// DOEPINT2: OTG_HS device endpoint-2 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT2_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT2_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT2_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT2_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT2_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT2_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT2_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT2_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT2_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT2_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT2_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT2_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT2_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT2_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT2_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT2_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT2_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT2_NYET = 0x4000

	// DOEPTSIZ2: OTG_HS device endpoint-2 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ2_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ2_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ2_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ2_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_Msk = 0x60000000

	// DOEPCTL3: OTG device endpoint-3 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL3_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL3_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL3_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL3_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL3_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL3_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL3_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL3_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL3_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL3_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL3_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL3_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL3_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL3_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL3_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL3_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL3_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL3_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL3_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL3_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL3_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL3_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL3_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL3_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL3_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL3_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL3_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL3_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL3_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL3_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL3_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL3_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL3_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL3_EPENA = 0x80000000

	// DOEPINT3: OTG_HS device endpoint-3 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT3_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT3_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT3_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT3_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT3_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT3_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT3_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT3_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT3_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT3_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT3_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT3_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT3_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT3_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT3_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT3_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT3_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT3_NYET = 0x4000

	// DOEPTSIZ3: OTG_HS device endpoint-3 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ3_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ3_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ3_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ3_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_Msk = 0x60000000

	// DOEPCTL4: OTG device endpoint-4 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL4_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL4_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL4_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL4_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL4_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL4_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL4_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL4_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL4_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL4_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL4_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL4_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL4_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL4_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL4_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL4_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL4_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL4_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL4_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL4_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL4_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL4_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL4_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL4_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL4_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL4_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL4_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL4_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL4_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL4_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL4_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL4_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL4_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL4_EPENA = 0x80000000

	// DOEPINT4: OTG_HS device endpoint-4 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT4_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT4_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT4_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT4_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT4_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT4_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT4_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT4_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT4_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT4_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT4_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT4_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT4_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT4_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT4_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT4_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT4_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT4_NYET = 0x4000

	// DOEPTSIZ4: OTG_HS device endpoint-4 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ4_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ4_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ4_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ4_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_Msk = 0x60000000

	// DOEPCTL5: OTG device endpoint-5 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL5_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL5_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL5_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL5_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL5_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL5_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL5_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL5_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL5_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL5_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL5_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL5_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL5_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL5_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL5_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL5_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL5_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL5_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL5_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL5_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL5_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL5_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL5_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL5_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL5_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL5_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL5_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL5_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL5_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL5_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL5_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL5_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL5_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL5_EPENA = 0x80000000

	// DOEPINT5: OTG_HS device endpoint-5 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT5_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT5_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT5_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT5_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT5_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT5_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT5_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT5_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT5_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT5_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT5_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT5_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT5_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT5_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT5_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT5_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT5_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT5_NYET = 0x4000

	// DOEPTSIZ5: OTG_HS device endpoint-5 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ5_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ5_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ5_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ5_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_Msk = 0x60000000

	// DOEPCTL6: OTG device endpoint-6 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL6_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL6_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL6_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL6_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL6_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL6_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL6_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL6_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL6_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL6_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL6_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL6_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL6_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL6_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL6_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL6_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL6_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL6_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL6_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL6_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL6_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL6_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL6_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL6_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL6_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL6_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL6_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL6_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL6_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL6_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL6_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL6_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL6_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL6_EPENA = 0x80000000

	// DOEPINT6: OTG_HS device endpoint-6 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT6_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT6_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT6_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT6_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT6_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT6_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT6_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT6_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT6_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT6_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT6_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT6_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT6_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT6_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT6_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT6_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT6_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT6_NYET = 0x4000

	// DOEPTSIZ6: OTG_HS device endpoint-6 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ6_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ6_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ6_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ6_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_Msk = 0x60000000

	// DOEPCTL7: OTG device endpoint-7 control register
	// Position of MPSIZ field.
	USB_OTG_HS_DOEPCTL7_MPSIZ_Pos = 0x0
	// Bit mask of MPSIZ field.
	USB_OTG_HS_DOEPCTL7_MPSIZ_Msk = 0x7ff
	// Position of USBAEP field.
	USB_OTG_HS_DOEPCTL7_USBAEP_Pos = 0xf
	// Bit mask of USBAEP field.
	USB_OTG_HS_DOEPCTL7_USBAEP_Msk = 0x8000
	// Bit USBAEP.
	USB_OTG_HS_DOEPCTL7_USBAEP = 0x8000
	// Position of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL7_EONUM_DPID_Pos = 0x10
	// Bit mask of EONUM_DPID field.
	USB_OTG_HS_DOEPCTL7_EONUM_DPID_Msk = 0x10000
	// Bit EONUM_DPID.
	USB_OTG_HS_DOEPCTL7_EONUM_DPID = 0x10000
	// Position of NAKSTS field.
	USB_OTG_HS_DOEPCTL7_NAKSTS_Pos = 0x11
	// Bit mask of NAKSTS field.
	USB_OTG_HS_DOEPCTL7_NAKSTS_Msk = 0x20000
	// Bit NAKSTS.
	USB_OTG_HS_DOEPCTL7_NAKSTS = 0x20000
	// Position of EPTYP field.
	USB_OTG_HS_DOEPCTL7_EPTYP_Pos = 0x12
	// Bit mask of EPTYP field.
	USB_OTG_HS_DOEPCTL7_EPTYP_Msk = 0xc0000
	// Position of SNPM field.
	USB_OTG_HS_DOEPCTL7_SNPM_Pos = 0x14
	// Bit mask of SNPM field.
	USB_OTG_HS_DOEPCTL7_SNPM_Msk = 0x100000
	// Bit SNPM.
	USB_OTG_HS_DOEPCTL7_SNPM = 0x100000
	// Position of Stall field.
	USB_OTG_HS_DOEPCTL7_Stall_Pos = 0x15
	// Bit mask of Stall field.
	USB_OTG_HS_DOEPCTL7_Stall_Msk = 0x200000
	// Bit Stall.
	USB_OTG_HS_DOEPCTL7_Stall = 0x200000
	// Position of CNAK field.
	USB_OTG_HS_DOEPCTL7_CNAK_Pos = 0x1a
	// Bit mask of CNAK field.
	USB_OTG_HS_DOEPCTL7_CNAK_Msk = 0x4000000
	// Bit CNAK.
	USB_OTG_HS_DOEPCTL7_CNAK = 0x4000000
	// Position of SNAK field.
	USB_OTG_HS_DOEPCTL7_SNAK_Pos = 0x1b
	// Bit mask of SNAK field.
	USB_OTG_HS_DOEPCTL7_SNAK_Msk = 0x8000000
	// Bit SNAK.
	USB_OTG_HS_DOEPCTL7_SNAK = 0x8000000
	// Position of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM_Pos = 0x1c
	// Bit mask of SD0PID_SEVNFRM field.
	USB_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM_Msk = 0x10000000
	// Bit SD0PID_SEVNFRM.
	USB_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 0x10000000
	// Position of SODDFRM field.
	USB_OTG_HS_DOEPCTL7_SODDFRM_Pos = 0x1d
	// Bit mask of SODDFRM field.
	USB_OTG_HS_DOEPCTL7_SODDFRM_Msk = 0x20000000
	// Bit SODDFRM.
	USB_OTG_HS_DOEPCTL7_SODDFRM = 0x20000000
	// Position of EPDIS field.
	USB_OTG_HS_DOEPCTL7_EPDIS_Pos = 0x1e
	// Bit mask of EPDIS field.
	USB_OTG_HS_DOEPCTL7_EPDIS_Msk = 0x40000000
	// Bit EPDIS.
	USB_OTG_HS_DOEPCTL7_EPDIS = 0x40000000
	// Position of EPENA field.
	USB_OTG_HS_DOEPCTL7_EPENA_Pos = 0x1f
	// Bit mask of EPENA field.
	USB_OTG_HS_DOEPCTL7_EPENA_Msk = 0x80000000
	// Bit EPENA.
	USB_OTG_HS_DOEPCTL7_EPENA = 0x80000000

	// DOEPINT7: OTG_HS device endpoint-7 interrupt register
	// Position of XFRC field.
	USB_OTG_HS_DOEPINT7_XFRC_Pos = 0x0
	// Bit mask of XFRC field.
	USB_OTG_HS_DOEPINT7_XFRC_Msk = 0x1
	// Bit XFRC.
	USB_OTG_HS_DOEPINT7_XFRC = 0x1
	// Position of EPDISD field.
	USB_OTG_HS_DOEPINT7_EPDISD_Pos = 0x1
	// Bit mask of EPDISD field.
	USB_OTG_HS_DOEPINT7_EPDISD_Msk = 0x2
	// Bit EPDISD.
	USB_OTG_HS_DOEPINT7_EPDISD = 0x2
	// Position of STUP field.
	USB_OTG_HS_DOEPINT7_STUP_Pos = 0x3
	// Bit mask of STUP field.
	USB_OTG_HS_DOEPINT7_STUP_Msk = 0x8
	// Bit STUP.
	USB_OTG_HS_DOEPINT7_STUP = 0x8
	// Position of OTEPDIS field.
	USB_OTG_HS_DOEPINT7_OTEPDIS_Pos = 0x4
	// Bit mask of OTEPDIS field.
	USB_OTG_HS_DOEPINT7_OTEPDIS_Msk = 0x10
	// Bit OTEPDIS.
	USB_OTG_HS_DOEPINT7_OTEPDIS = 0x10
	// Position of B2BSTUP field.
	USB_OTG_HS_DOEPINT7_B2BSTUP_Pos = 0x6
	// Bit mask of B2BSTUP field.
	USB_OTG_HS_DOEPINT7_B2BSTUP_Msk = 0x40
	// Bit B2BSTUP.
	USB_OTG_HS_DOEPINT7_B2BSTUP = 0x40
	// Position of NYET field.
	USB_OTG_HS_DOEPINT7_NYET_Pos = 0xe
	// Bit mask of NYET field.
	USB_OTG_HS_DOEPINT7_NYET_Msk = 0x4000
	// Bit NYET.
	USB_OTG_HS_DOEPINT7_NYET = 0x4000

	// DOEPTSIZ7: OTG_HS device endpoint-7 transfer size register
	// Position of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ7_XFRSIZ_Pos = 0x0
	// Bit mask of XFRSIZ field.
	USB_OTG_HS_DOEPTSIZ7_XFRSIZ_Msk = 0x7ffff
	// Position of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ7_PKTCNT_Pos = 0x13
	// Bit mask of PKTCNT field.
	USB_OTG_HS_DOEPTSIZ7_PKTCNT_Msk = 0x1ff80000
	// Position of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_Pos = 0x1d
	// Bit mask of RXDPID_STUPCNT field.
	USB_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_Msk = 0x60000000
)

// Constants for OctoSPII_O_Manager: OctoSPI IO Manager
const (
	// CR: OctoSPI IO Manager Control Register
	// Position of MUXEN field.
	OctoSPII_O_Manager_CR_MUXEN_Pos = 0x0
	// Bit mask of MUXEN field.
	OctoSPII_O_Manager_CR_MUXEN_Msk = 0x1
	// Bit MUXEN.
	OctoSPII_O_Manager_CR_MUXEN = 0x1
	// Position of REQ2ACK_TIME field.
	OctoSPII_O_Manager_CR_REQ2ACK_TIME_Pos = 0x10
	// Bit mask of REQ2ACK_TIME field.
	OctoSPII_O_Manager_CR_REQ2ACK_TIME_Msk = 0xff0000

	// P1CR: OctoSPI IO Manager Port 1 configuration register
	// Position of CLKEN field.
	OctoSPII_O_Manager_P1CR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	OctoSPII_O_Manager_P1CR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	OctoSPII_O_Manager_P1CR_CLKEN = 0x1
	// Position of CLKSRC field.
	OctoSPII_O_Manager_P1CR_CLKSRC_Pos = 0x1
	// Bit mask of CLKSRC field.
	OctoSPII_O_Manager_P1CR_CLKSRC_Msk = 0x2
	// Bit CLKSRC.
	OctoSPII_O_Manager_P1CR_CLKSRC = 0x2
	// Position of DQSEN field.
	OctoSPII_O_Manager_P1CR_DQSEN_Pos = 0x4
	// Bit mask of DQSEN field.
	OctoSPII_O_Manager_P1CR_DQSEN_Msk = 0x10
	// Bit DQSEN.
	OctoSPII_O_Manager_P1CR_DQSEN = 0x10
	// Position of DQSSRC field.
	OctoSPII_O_Manager_P1CR_DQSSRC_Pos = 0x5
	// Bit mask of DQSSRC field.
	OctoSPII_O_Manager_P1CR_DQSSRC_Msk = 0x20
	// Bit DQSSRC.
	OctoSPII_O_Manager_P1CR_DQSSRC = 0x20
	// Position of NCSEN field.
	OctoSPII_O_Manager_P1CR_NCSEN_Pos = 0x8
	// Bit mask of NCSEN field.
	OctoSPII_O_Manager_P1CR_NCSEN_Msk = 0x100
	// Bit NCSEN.
	OctoSPII_O_Manager_P1CR_NCSEN = 0x100
	// Position of NCSSRC field.
	OctoSPII_O_Manager_P1CR_NCSSRC_Pos = 0x9
	// Bit mask of NCSSRC field.
	OctoSPII_O_Manager_P1CR_NCSSRC_Msk = 0x200
	// Bit NCSSRC.
	OctoSPII_O_Manager_P1CR_NCSSRC = 0x200
	// Position of IOLEN field.
	OctoSPII_O_Manager_P1CR_IOLEN_Pos = 0x10
	// Bit mask of IOLEN field.
	OctoSPII_O_Manager_P1CR_IOLEN_Msk = 0x10000
	// Bit IOLEN.
	OctoSPII_O_Manager_P1CR_IOLEN = 0x10000
	// Position of IOLSRC field.
	OctoSPII_O_Manager_P1CR_IOLSRC_Pos = 0x11
	// Bit mask of IOLSRC field.
	OctoSPII_O_Manager_P1CR_IOLSRC_Msk = 0x60000
	// Position of IOHEN field.
	OctoSPII_O_Manager_P1CR_IOHEN_Pos = 0x18
	// Bit mask of IOHEN field.
	OctoSPII_O_Manager_P1CR_IOHEN_Msk = 0x1000000
	// Bit IOHEN.
	OctoSPII_O_Manager_P1CR_IOHEN = 0x1000000
	// Position of IOHSRC field.
	OctoSPII_O_Manager_P1CR_IOHSRC_Pos = 0x19
	// Bit mask of IOHSRC field.
	OctoSPII_O_Manager_P1CR_IOHSRC_Msk = 0x6000000

	// P2CR: OctoSPI IO Manager Port 2 configuration register
	// Position of CLKEN field.
	OctoSPII_O_Manager_P2CR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	OctoSPII_O_Manager_P2CR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	OctoSPII_O_Manager_P2CR_CLKEN = 0x1
	// Position of CLKSRC field.
	OctoSPII_O_Manager_P2CR_CLKSRC_Pos = 0x1
	// Bit mask of CLKSRC field.
	OctoSPII_O_Manager_P2CR_CLKSRC_Msk = 0x2
	// Bit CLKSRC.
	OctoSPII_O_Manager_P2CR_CLKSRC = 0x2
	// Position of DQSEN field.
	OctoSPII_O_Manager_P2CR_DQSEN_Pos = 0x4
	// Bit mask of DQSEN field.
	OctoSPII_O_Manager_P2CR_DQSEN_Msk = 0x10
	// Bit DQSEN.
	OctoSPII_O_Manager_P2CR_DQSEN = 0x10
	// Position of DQSSRC field.
	OctoSPII_O_Manager_P2CR_DQSSRC_Pos = 0x5
	// Bit mask of DQSSRC field.
	OctoSPII_O_Manager_P2CR_DQSSRC_Msk = 0x20
	// Bit DQSSRC.
	OctoSPII_O_Manager_P2CR_DQSSRC = 0x20
	// Position of NCSEN field.
	OctoSPII_O_Manager_P2CR_NCSEN_Pos = 0x8
	// Bit mask of NCSEN field.
	OctoSPII_O_Manager_P2CR_NCSEN_Msk = 0x100
	// Bit NCSEN.
	OctoSPII_O_Manager_P2CR_NCSEN = 0x100
	// Position of NCSSRC field.
	OctoSPII_O_Manager_P2CR_NCSSRC_Pos = 0x9
	// Bit mask of NCSSRC field.
	OctoSPII_O_Manager_P2CR_NCSSRC_Msk = 0x200
	// Bit NCSSRC.
	OctoSPII_O_Manager_P2CR_NCSSRC = 0x200
	// Position of IOLEN field.
	OctoSPII_O_Manager_P2CR_IOLEN_Pos = 0x10
	// Bit mask of IOLEN field.
	OctoSPII_O_Manager_P2CR_IOLEN_Msk = 0x10000
	// Bit IOLEN.
	OctoSPII_O_Manager_P2CR_IOLEN = 0x10000
	// Position of IOLSRC field.
	OctoSPII_O_Manager_P2CR_IOLSRC_Pos = 0x11
	// Bit mask of IOLSRC field.
	OctoSPII_O_Manager_P2CR_IOLSRC_Msk = 0x60000
	// Position of IOHEN field.
	OctoSPII_O_Manager_P2CR_IOHEN_Pos = 0x18
	// Bit mask of IOHEN field.
	OctoSPII_O_Manager_P2CR_IOHEN_Msk = 0x1000000
	// Bit IOHEN.
	OctoSPII_O_Manager_P2CR_IOHEN = 0x1000000
	// Position of IOHSRC field.
	OctoSPII_O_Manager_P2CR_IOHSRC_Pos = 0x19
	// Bit mask of IOHSRC field.
	OctoSPII_O_Manager_P2CR_IOHSRC_Msk = 0x6000000
)

// Constants for PF: Processor features
const (
	// CLIDR: Cache Level ID register
	// Position of CL1 field.
	PF_CLIDR_CL1_Pos = 0x0
	// Bit mask of CL1 field.
	PF_CLIDR_CL1_Msk = 0x7
	// Position of CL2 field.
	PF_CLIDR_CL2_Pos = 0x3
	// Bit mask of CL2 field.
	PF_CLIDR_CL2_Msk = 0x38
	// Position of CL3 field.
	PF_CLIDR_CL3_Pos = 0x6
	// Bit mask of CL3 field.
	PF_CLIDR_CL3_Msk = 0x1c0
	// Position of CL4 field.
	PF_CLIDR_CL4_Pos = 0x9
	// Bit mask of CL4 field.
	PF_CLIDR_CL4_Msk = 0xe00
	// Position of CL5 field.
	PF_CLIDR_CL5_Pos = 0xc
	// Bit mask of CL5 field.
	PF_CLIDR_CL5_Msk = 0x7000
	// Position of CL6 field.
	PF_CLIDR_CL6_Pos = 0xf
	// Bit mask of CL6 field.
	PF_CLIDR_CL6_Msk = 0x38000
	// Position of CL7 field.
	PF_CLIDR_CL7_Pos = 0x12
	// Bit mask of CL7 field.
	PF_CLIDR_CL7_Msk = 0x1c0000
	// Position of LoUIS field.
	PF_CLIDR_LoUIS_Pos = 0x15
	// Bit mask of LoUIS field.
	PF_CLIDR_LoUIS_Msk = 0xe00000
	// Position of LoC field.
	PF_CLIDR_LoC_Pos = 0x18
	// Bit mask of LoC field.
	PF_CLIDR_LoC_Msk = 0x7000000
	// Position of LoU field.
	PF_CLIDR_LoU_Pos = 0x1b
	// Bit mask of LoU field.
	PF_CLIDR_LoU_Msk = 0x38000000

	// CTR: Cache Type register
	// Position of _IMINLINE field.
	PF_CTR__IMINLINE_Pos = 0x0
	// Bit mask of _IMINLINE field.
	PF_CTR__IMINLINE_Msk = 0xf
	// Position of DMinLine field.
	PF_CTR_DMinLine_Pos = 0x10
	// Bit mask of DMinLine field.
	PF_CTR_DMinLine_Msk = 0xf0000
	// Position of ERG field.
	PF_CTR_ERG_Pos = 0x14
	// Bit mask of ERG field.
	PF_CTR_ERG_Msk = 0xf00000
	// Position of CWG field.
	PF_CTR_CWG_Pos = 0x18
	// Bit mask of CWG field.
	PF_CTR_CWG_Msk = 0xf000000
	// Position of Format field.
	PF_CTR_Format_Pos = 0x1d
	// Bit mask of Format field.
	PF_CTR_Format_Msk = 0xe0000000

	// CCSIDR: Cache Size ID register
	// Position of LineSize field.
	PF_CCSIDR_LineSize_Pos = 0x0
	// Bit mask of LineSize field.
	PF_CCSIDR_LineSize_Msk = 0x7
	// Position of Associativity field.
	PF_CCSIDR_Associativity_Pos = 0x3
	// Bit mask of Associativity field.
	PF_CCSIDR_Associativity_Msk = 0x1ff8
	// Position of NumSets field.
	PF_CCSIDR_NumSets_Pos = 0xd
	// Bit mask of NumSets field.
	PF_CCSIDR_NumSets_Msk = 0xfffe000
	// Position of WA field.
	PF_CCSIDR_WA_Pos = 0x1c
	// Bit mask of WA field.
	PF_CCSIDR_WA_Msk = 0x10000000
	// Bit WA.
	PF_CCSIDR_WA = 0x10000000
	// Position of RA field.
	PF_CCSIDR_RA_Pos = 0x1d
	// Bit mask of RA field.
	PF_CCSIDR_RA_Msk = 0x20000000
	// Bit RA.
	PF_CCSIDR_RA = 0x20000000
	// Position of WB field.
	PF_CCSIDR_WB_Pos = 0x1e
	// Bit mask of WB field.
	PF_CCSIDR_WB_Msk = 0x40000000
	// Bit WB.
	PF_CCSIDR_WB = 0x40000000
	// Position of WT field.
	PF_CCSIDR_WT_Pos = 0x1f
	// Bit mask of WT field.
	PF_CCSIDR_WT_Msk = 0x80000000
	// Bit WT.
	PF_CCSIDR_WT = 0x80000000
)

// Constants for PWR: PWR
const (
	// CR1: PWR control register 1
	// Position of LPDS field.
	PWR_CR1_LPDS_Pos = 0x0
	// Bit mask of LPDS field.
	PWR_CR1_LPDS_Msk = 0x1
	// Bit LPDS.
	PWR_CR1_LPDS = 0x1
	// Position of PVDE field.
	PWR_CR1_PVDE_Pos = 0x4
	// Bit mask of PVDE field.
	PWR_CR1_PVDE_Msk = 0x10
	// Bit PVDE.
	PWR_CR1_PVDE = 0x10
	// Position of PLS field.
	PWR_CR1_PLS_Pos = 0x5
	// Bit mask of PLS field.
	PWR_CR1_PLS_Msk = 0xe0
	// Position of DBP field.
	PWR_CR1_DBP_Pos = 0x8
	// Bit mask of DBP field.
	PWR_CR1_DBP_Msk = 0x100
	// Bit DBP.
	PWR_CR1_DBP = 0x100
	// Position of FLPS field.
	PWR_CR1_FLPS_Pos = 0x9
	// Bit mask of FLPS field.
	PWR_CR1_FLPS_Msk = 0x200
	// Bit FLPS.
	PWR_CR1_FLPS = 0x200
	// Position of SVOS field.
	PWR_CR1_SVOS_Pos = 0xe
	// Bit mask of SVOS field.
	PWR_CR1_SVOS_Msk = 0xc000
	// Position of AVDEN field.
	PWR_CR1_AVDEN_Pos = 0x10
	// Bit mask of AVDEN field.
	PWR_CR1_AVDEN_Msk = 0x10000
	// Bit AVDEN.
	PWR_CR1_AVDEN = 0x10000
	// Position of ALS field.
	PWR_CR1_ALS_Pos = 0x11
	// Bit mask of ALS field.
	PWR_CR1_ALS_Msk = 0x60000

	// CSR1: PWR control status register 1
	// Position of PVDO field.
	PWR_CSR1_PVDO_Pos = 0x4
	// Bit mask of PVDO field.
	PWR_CSR1_PVDO_Msk = 0x10
	// Bit PVDO.
	PWR_CSR1_PVDO = 0x10
	// Position of ACTVOSRDY field.
	PWR_CSR1_ACTVOSRDY_Pos = 0xd
	// Bit mask of ACTVOSRDY field.
	PWR_CSR1_ACTVOSRDY_Msk = 0x2000
	// Bit ACTVOSRDY.
	PWR_CSR1_ACTVOSRDY = 0x2000
	// Position of ACTVOS field.
	PWR_CSR1_ACTVOS_Pos = 0xe
	// Bit mask of ACTVOS field.
	PWR_CSR1_ACTVOS_Msk = 0xc000
	// Position of AVDO field.
	PWR_CSR1_AVDO_Pos = 0x10
	// Bit mask of AVDO field.
	PWR_CSR1_AVDO_Msk = 0x10000
	// Bit AVDO.
	PWR_CSR1_AVDO = 0x10000

	// CR2: This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
	// Position of BREN field.
	PWR_CR2_BREN_Pos = 0x0
	// Bit mask of BREN field.
	PWR_CR2_BREN_Msk = 0x1
	// Bit BREN.
	PWR_CR2_BREN = 0x1
	// Position of MONEN field.
	PWR_CR2_MONEN_Pos = 0x4
	// Bit mask of MONEN field.
	PWR_CR2_MONEN_Msk = 0x10
	// Bit MONEN.
	PWR_CR2_MONEN = 0x10
	// Position of BRRDY field.
	PWR_CR2_BRRDY_Pos = 0x10
	// Bit mask of BRRDY field.
	PWR_CR2_BRRDY_Msk = 0x10000
	// Bit BRRDY.
	PWR_CR2_BRRDY = 0x10000
	// Position of VBATL field.
	PWR_CR2_VBATL_Pos = 0x14
	// Bit mask of VBATL field.
	PWR_CR2_VBATL_Msk = 0x100000
	// Bit VBATL.
	PWR_CR2_VBATL = 0x100000
	// Position of VBATH field.
	PWR_CR2_VBATH_Pos = 0x15
	// Bit mask of VBATH field.
	PWR_CR2_VBATH_Msk = 0x200000
	// Bit VBATH.
	PWR_CR2_VBATH = 0x200000
	// Position of TEMPL field.
	PWR_CR2_TEMPL_Pos = 0x16
	// Bit mask of TEMPL field.
	PWR_CR2_TEMPL_Msk = 0x400000
	// Bit TEMPL.
	PWR_CR2_TEMPL = 0x400000
	// Position of TEMPH field.
	PWR_CR2_TEMPH_Pos = 0x17
	// Bit mask of TEMPH field.
	PWR_CR2_TEMPH_Msk = 0x800000
	// Bit TEMPH.
	PWR_CR2_TEMPH = 0x800000

	// CR3: Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
	// Position of BYPASS field.
	PWR_CR3_BYPASS_Pos = 0x0
	// Bit mask of BYPASS field.
	PWR_CR3_BYPASS_Msk = 0x1
	// Bit BYPASS.
	PWR_CR3_BYPASS = 0x1
	// Position of LDOEN field.
	PWR_CR3_LDOEN_Pos = 0x1
	// Bit mask of LDOEN field.
	PWR_CR3_LDOEN_Msk = 0x2
	// Bit LDOEN.
	PWR_CR3_LDOEN = 0x2
	// Position of SDEN field.
	PWR_CR3_SDEN_Pos = 0x2
	// Bit mask of SDEN field.
	PWR_CR3_SDEN_Msk = 0x4
	// Bit SDEN.
	PWR_CR3_SDEN = 0x4
	// Position of VBE field.
	PWR_CR3_VBE_Pos = 0x8
	// Bit mask of VBE field.
	PWR_CR3_VBE_Msk = 0x100
	// Bit VBE.
	PWR_CR3_VBE = 0x100
	// Position of VBRS field.
	PWR_CR3_VBRS_Pos = 0x9
	// Bit mask of VBRS field.
	PWR_CR3_VBRS_Msk = 0x200
	// Bit VBRS.
	PWR_CR3_VBRS = 0x200
	// Position of USB33DEN field.
	PWR_CR3_USB33DEN_Pos = 0x18
	// Bit mask of USB33DEN field.
	PWR_CR3_USB33DEN_Msk = 0x1000000
	// Bit USB33DEN.
	PWR_CR3_USB33DEN = 0x1000000
	// Position of USBREGEN field.
	PWR_CR3_USBREGEN_Pos = 0x19
	// Bit mask of USBREGEN field.
	PWR_CR3_USBREGEN_Msk = 0x2000000
	// Bit USBREGEN.
	PWR_CR3_USBREGEN = 0x2000000
	// Position of USB33RDY field.
	PWR_CR3_USB33RDY_Pos = 0x1a
	// Bit mask of USB33RDY field.
	PWR_CR3_USB33RDY_Msk = 0x4000000
	// Bit USB33RDY.
	PWR_CR3_USB33RDY = 0x4000000
	// Position of SDEXTHP field.
	PWR_CR3_SDEXTHP_Pos = 0x3
	// Bit mask of SDEXTHP field.
	PWR_CR3_SDEXTHP_Msk = 0x8
	// Bit SDEXTHP.
	PWR_CR3_SDEXTHP = 0x8
	// Position of SDLEVEL field.
	PWR_CR3_SDLEVEL_Pos = 0x4
	// Bit mask of SDLEVEL field.
	PWR_CR3_SDLEVEL_Msk = 0x30
	// Position of SDEXTRDY field.
	PWR_CR3_SDEXTRDY_Pos = 0x10
	// Bit mask of SDEXTRDY field.
	PWR_CR3_SDEXTRDY_Msk = 0x10000
	// Bit SDEXTRDY.
	PWR_CR3_SDEXTRDY = 0x10000

	// CPUCR: This register allows controlling CPU1 power.
	// Position of PDDS_D1 field.
	PWR_CPUCR_PDDS_D1_Pos = 0x0
	// Bit mask of PDDS_D1 field.
	PWR_CPUCR_PDDS_D1_Msk = 0x1
	// Bit PDDS_D1.
	PWR_CPUCR_PDDS_D1 = 0x1
	// Position of PDDS_D2 field.
	PWR_CPUCR_PDDS_D2_Pos = 0x1
	// Bit mask of PDDS_D2 field.
	PWR_CPUCR_PDDS_D2_Msk = 0x2
	// Bit PDDS_D2.
	PWR_CPUCR_PDDS_D2 = 0x2
	// Position of PDDS_D3 field.
	PWR_CPUCR_PDDS_D3_Pos = 0x2
	// Bit mask of PDDS_D3 field.
	PWR_CPUCR_PDDS_D3_Msk = 0x4
	// Bit PDDS_D3.
	PWR_CPUCR_PDDS_D3 = 0x4
	// Position of STOPF field.
	PWR_CPUCR_STOPF_Pos = 0x5
	// Bit mask of STOPF field.
	PWR_CPUCR_STOPF_Msk = 0x20
	// Bit STOPF.
	PWR_CPUCR_STOPF = 0x20
	// Position of SBF field.
	PWR_CPUCR_SBF_Pos = 0x6
	// Bit mask of SBF field.
	PWR_CPUCR_SBF_Msk = 0x40
	// Bit SBF.
	PWR_CPUCR_SBF = 0x40
	// Position of SBF_D1 field.
	PWR_CPUCR_SBF_D1_Pos = 0x7
	// Bit mask of SBF_D1 field.
	PWR_CPUCR_SBF_D1_Msk = 0x80
	// Bit SBF_D1.
	PWR_CPUCR_SBF_D1 = 0x80
	// Position of SBF_D2 field.
	PWR_CPUCR_SBF_D2_Pos = 0x8
	// Bit mask of SBF_D2 field.
	PWR_CPUCR_SBF_D2_Msk = 0x100
	// Bit SBF_D2.
	PWR_CPUCR_SBF_D2 = 0x100
	// Position of CSSF field.
	PWR_CPUCR_CSSF_Pos = 0x9
	// Bit mask of CSSF field.
	PWR_CPUCR_CSSF_Msk = 0x200
	// Bit CSSF.
	PWR_CPUCR_CSSF = 0x200
	// Position of RUN_D3 field.
	PWR_CPUCR_RUN_D3_Pos = 0xb
	// Bit mask of RUN_D3 field.
	PWR_CPUCR_RUN_D3_Msk = 0x800
	// Bit RUN_D3.
	PWR_CPUCR_RUN_D3 = 0x800

	// D3CR: This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
	// Position of VOSRDY field.
	PWR_D3CR_VOSRDY_Pos = 0xd
	// Bit mask of VOSRDY field.
	PWR_D3CR_VOSRDY_Msk = 0x2000
	// Bit VOSRDY.
	PWR_D3CR_VOSRDY = 0x2000
	// Position of VOS field.
	PWR_D3CR_VOS_Pos = 0xe
	// Bit mask of VOS field.
	PWR_D3CR_VOS_Msk = 0xc000

	// WKUPCR: reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
	// Position of WKUPC1 field.
	PWR_WKUPCR_WKUPC1_Pos = 0x0
	// Bit mask of WKUPC1 field.
	PWR_WKUPCR_WKUPC1_Msk = 0x1
	// Bit WKUPC1.
	PWR_WKUPCR_WKUPC1 = 0x1
	// Position of WKUPC2 field.
	PWR_WKUPCR_WKUPC2_Pos = 0x1
	// Bit mask of WKUPC2 field.
	PWR_WKUPCR_WKUPC2_Msk = 0x2
	// Bit WKUPC2.
	PWR_WKUPCR_WKUPC2 = 0x2
	// Position of WKUPC4 field.
	PWR_WKUPCR_WKUPC4_Pos = 0x3
	// Bit mask of WKUPC4 field.
	PWR_WKUPCR_WKUPC4_Msk = 0x8
	// Bit WKUPC4.
	PWR_WKUPCR_WKUPC4 = 0x8
	// Position of WKUPC6 field.
	PWR_WKUPCR_WKUPC6_Pos = 0x5
	// Bit mask of WKUPC6 field.
	PWR_WKUPCR_WKUPC6_Msk = 0x20
	// Bit WKUPC6.
	PWR_WKUPCR_WKUPC6 = 0x20

	// WKUPFR: reset only by system reset, not reset by wakeup from Standby mode
	// Position of WKUPF1 field.
	PWR_WKUPFR_WKUPF1_Pos = 0x0
	// Bit mask of WKUPF1 field.
	PWR_WKUPFR_WKUPF1_Msk = 0x1
	// Bit WKUPF1.
	PWR_WKUPFR_WKUPF1 = 0x1
	// Position of WKUPF2 field.
	PWR_WKUPFR_WKUPF2_Pos = 0x1
	// Bit mask of WKUPF2 field.
	PWR_WKUPFR_WKUPF2_Msk = 0x2
	// Bit WKUPF2.
	PWR_WKUPFR_WKUPF2 = 0x2
	// Position of WKUPF4 field.
	PWR_WKUPFR_WKUPF4_Pos = 0x3
	// Bit mask of WKUPF4 field.
	PWR_WKUPFR_WKUPF4_Msk = 0x8
	// Bit WKUPF4.
	PWR_WKUPFR_WKUPF4 = 0x8
	// Position of WKUPF6 field.
	PWR_WKUPFR_WKUPF6_Pos = 0x5
	// Bit mask of WKUPF6 field.
	PWR_WKUPFR_WKUPF6_Msk = 0x20
	// Bit WKUPF6.
	PWR_WKUPFR_WKUPF6 = 0x20

	// WKUPEPR: Reset only by system reset, not reset by wakeup from Standby mode
	// Position of WKUPEN1 field.
	PWR_WKUPEPR_WKUPEN1_Pos = 0x0
	// Bit mask of WKUPEN1 field.
	PWR_WKUPEPR_WKUPEN1_Msk = 0x1
	// Bit WKUPEN1.
	PWR_WKUPEPR_WKUPEN1 = 0x1
	// Position of WKUPEN2 field.
	PWR_WKUPEPR_WKUPEN2_Pos = 0x1
	// Bit mask of WKUPEN2 field.
	PWR_WKUPEPR_WKUPEN2_Msk = 0x2
	// Bit WKUPEN2.
	PWR_WKUPEPR_WKUPEN2 = 0x2
	// Position of WKUPEN3 field.
	PWR_WKUPEPR_WKUPEN3_Pos = 0x2
	// Bit mask of WKUPEN3 field.
	PWR_WKUPEPR_WKUPEN3_Msk = 0x4
	// Bit WKUPEN3.
	PWR_WKUPEPR_WKUPEN3 = 0x4
	// Position of WKUPEN4 field.
	PWR_WKUPEPR_WKUPEN4_Pos = 0x3
	// Bit mask of WKUPEN4 field.
	PWR_WKUPEPR_WKUPEN4_Msk = 0x8
	// Bit WKUPEN4.
	PWR_WKUPEPR_WKUPEN4 = 0x8
	// Position of WKUPEN5 field.
	PWR_WKUPEPR_WKUPEN5_Pos = 0x4
	// Bit mask of WKUPEN5 field.
	PWR_WKUPEPR_WKUPEN5_Msk = 0x10
	// Bit WKUPEN5.
	PWR_WKUPEPR_WKUPEN5 = 0x10
	// Position of WKUPEN6 field.
	PWR_WKUPEPR_WKUPEN6_Pos = 0x5
	// Bit mask of WKUPEN6 field.
	PWR_WKUPEPR_WKUPEN6_Msk = 0x20
	// Bit WKUPEN6.
	PWR_WKUPEPR_WKUPEN6 = 0x20
	// Position of WKUPP1 field.
	PWR_WKUPEPR_WKUPP1_Pos = 0x8
	// Bit mask of WKUPP1 field.
	PWR_WKUPEPR_WKUPP1_Msk = 0x100
	// Bit WKUPP1.
	PWR_WKUPEPR_WKUPP1 = 0x100
	// Position of WKUPP2 field.
	PWR_WKUPEPR_WKUPP2_Pos = 0x9
	// Bit mask of WKUPP2 field.
	PWR_WKUPEPR_WKUPP2_Msk = 0x200
	// Bit WKUPP2.
	PWR_WKUPEPR_WKUPP2 = 0x200
	// Position of WKUPP3 field.
	PWR_WKUPEPR_WKUPP3_Pos = 0xa
	// Bit mask of WKUPP3 field.
	PWR_WKUPEPR_WKUPP3_Msk = 0x400
	// Bit WKUPP3.
	PWR_WKUPEPR_WKUPP3 = 0x400
	// Position of WKUPP4 field.
	PWR_WKUPEPR_WKUPP4_Pos = 0xb
	// Bit mask of WKUPP4 field.
	PWR_WKUPEPR_WKUPP4_Msk = 0x800
	// Bit WKUPP4.
	PWR_WKUPEPR_WKUPP4 = 0x800
	// Position of WKUPP5 field.
	PWR_WKUPEPR_WKUPP5_Pos = 0xc
	// Bit mask of WKUPP5 field.
	PWR_WKUPEPR_WKUPP5_Msk = 0x1000
	// Bit WKUPP5.
	PWR_WKUPEPR_WKUPP5 = 0x1000
	// Position of WKUPP6 field.
	PWR_WKUPEPR_WKUPP6_Pos = 0xd
	// Bit mask of WKUPP6 field.
	PWR_WKUPEPR_WKUPP6_Msk = 0x2000
	// Bit WKUPP6.
	PWR_WKUPEPR_WKUPP6 = 0x2000
	// Position of WKUPPUPD1 field.
	PWR_WKUPEPR_WKUPPUPD1_Pos = 0x10
	// Bit mask of WKUPPUPD1 field.
	PWR_WKUPEPR_WKUPPUPD1_Msk = 0x30000
	// Position of WKUPPUPD2 field.
	PWR_WKUPEPR_WKUPPUPD2_Pos = 0x12
	// Bit mask of WKUPPUPD2 field.
	PWR_WKUPEPR_WKUPPUPD2_Msk = 0xc0000
	// Position of WKUPPUPD3 field.
	PWR_WKUPEPR_WKUPPUPD3_Pos = 0x14
	// Bit mask of WKUPPUPD3 field.
	PWR_WKUPEPR_WKUPPUPD3_Msk = 0x300000
	// Position of WKUPPUPD4 field.
	PWR_WKUPEPR_WKUPPUPD4_Pos = 0x16
	// Bit mask of WKUPPUPD4 field.
	PWR_WKUPEPR_WKUPPUPD4_Msk = 0xc00000
	// Position of WKUPPUPD5 field.
	PWR_WKUPEPR_WKUPPUPD5_Pos = 0x18
	// Bit mask of WKUPPUPD5 field.
	PWR_WKUPEPR_WKUPPUPD5_Msk = 0x3000000
	// Position of WKUPPUPD6 field.
	PWR_WKUPEPR_WKUPPUPD6_Pos = 0x1a
	// Bit mask of WKUPPUPD6 field.
	PWR_WKUPEPR_WKUPPUPD6_Msk = 0xc000000
)

// Constants for RAMECC1: ECC controller is associated to each RAM area
const (
	// IER: RAMECC interrupt enable register
	// Position of GIE field.
	RAMECC_IER_GIE_Pos = 0x0
	// Bit mask of GIE field.
	RAMECC_IER_GIE_Msk = 0x1
	// Bit GIE.
	RAMECC_IER_GIE = 0x1
	// Position of GECCSEIE_ field.
	RAMECC_IER_GECCSEIE__Pos = 0x1
	// Bit mask of GECCSEIE_ field.
	RAMECC_IER_GECCSEIE__Msk = 0x2
	// Bit GECCSEIE_.
	RAMECC_IER_GECCSEIE_ = 0x2
	// Position of GECCDEIE field.
	RAMECC_IER_GECCDEIE_Pos = 0x2
	// Bit mask of GECCDEIE field.
	RAMECC_IER_GECCDEIE_Msk = 0x4
	// Bit GECCDEIE.
	RAMECC_IER_GECCDEIE = 0x4
	// Position of GECCDEBWIE field.
	RAMECC_IER_GECCDEBWIE_Pos = 0x3
	// Bit mask of GECCDEBWIE field.
	RAMECC_IER_GECCDEBWIE_Msk = 0x8
	// Bit GECCDEBWIE.
	RAMECC_IER_GECCDEBWIE = 0x8

	// M1CR: RAMECC monitor x configuration register
	// Position of ECCSEIE field.
	RAMECC_M1CR_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	RAMECC_M1CR_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	RAMECC_M1CR_ECCSEIE = 0x4
	// Position of ECCDEIE field.
	RAMECC_M1CR_ECCDEIE_Pos = 0x3
	// Bit mask of ECCDEIE field.
	RAMECC_M1CR_ECCDEIE_Msk = 0x8
	// Bit ECCDEIE.
	RAMECC_M1CR_ECCDEIE = 0x8
	// Position of ECCDEBWIE field.
	RAMECC_M1CR_ECCDEBWIE_Pos = 0x4
	// Bit mask of ECCDEBWIE field.
	RAMECC_M1CR_ECCDEBWIE_Msk = 0x10
	// Bit ECCDEBWIE.
	RAMECC_M1CR_ECCDEBWIE = 0x10
	// Position of ECCELEN field.
	RAMECC_M1CR_ECCELEN_Pos = 0x5
	// Bit mask of ECCELEN field.
	RAMECC_M1CR_ECCELEN_Msk = 0x20
	// Bit ECCELEN.
	RAMECC_M1CR_ECCELEN = 0x20

	// M1SR: RAMECC monitor x status register
	// Position of ECCSEIE field.
	RAMECC_M1SR_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	RAMECC_M1SR_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	RAMECC_M1SR_ECCSEIE = 0x4
	// Position of ECCDEIE field.
	RAMECC_M1SR_ECCDEIE_Pos = 0x3
	// Bit mask of ECCDEIE field.
	RAMECC_M1SR_ECCDEIE_Msk = 0x8
	// Bit ECCDEIE.
	RAMECC_M1SR_ECCDEIE = 0x8
	// Position of ECCDEBWIE field.
	RAMECC_M1SR_ECCDEBWIE_Pos = 0x4
	// Bit mask of ECCDEBWIE field.
	RAMECC_M1SR_ECCDEBWIE_Msk = 0x10
	// Bit ECCDEBWIE.
	RAMECC_M1SR_ECCDEBWIE = 0x10
	// Position of ECCELEN field.
	RAMECC_M1SR_ECCELEN_Pos = 0x5
	// Bit mask of ECCELEN field.
	RAMECC_M1SR_ECCELEN_Msk = 0x20
	// Bit ECCELEN.
	RAMECC_M1SR_ECCELEN = 0x20

	// M1FAR: RAMECC monitor x failing address register
	// Position of ECCSEIE field.
	RAMECC_M1FAR_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	RAMECC_M1FAR_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	RAMECC_M1FAR_ECCSEIE = 0x4
	// Position of ECCDEIE field.
	RAMECC_M1FAR_ECCDEIE_Pos = 0x3
	// Bit mask of ECCDEIE field.
	RAMECC_M1FAR_ECCDEIE_Msk = 0x8
	// Bit ECCDEIE.
	RAMECC_M1FAR_ECCDEIE = 0x8
	// Position of ECCDEBWIE field.
	RAMECC_M1FAR_ECCDEBWIE_Pos = 0x4
	// Bit mask of ECCDEBWIE field.
	RAMECC_M1FAR_ECCDEBWIE_Msk = 0x10
	// Bit ECCDEBWIE.
	RAMECC_M1FAR_ECCDEBWIE = 0x10
	// Position of ECCELEN field.
	RAMECC_M1FAR_ECCELEN_Pos = 0x5
	// Bit mask of ECCELEN field.
	RAMECC_M1FAR_ECCELEN_Msk = 0x20
	// Bit ECCELEN.
	RAMECC_M1FAR_ECCELEN = 0x20

	// M1FDRL: RAMECC monitor x failing data low register
	// Position of ECCSEIE field.
	RAMECC_M1FDRL_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	RAMECC_M1FDRL_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	RAMECC_M1FDRL_ECCSEIE = 0x4
	// Position of ECCDEIE field.
	RAMECC_M1FDRL_ECCDEIE_Pos = 0x3
	// Bit mask of ECCDEIE field.
	RAMECC_M1FDRL_ECCDEIE_Msk = 0x8
	// Bit ECCDEIE.
	RAMECC_M1FDRL_ECCDEIE = 0x8
	// Position of ECCDEBWIE field.
	RAMECC_M1FDRL_ECCDEBWIE_Pos = 0x4
	// Bit mask of ECCDEBWIE field.
	RAMECC_M1FDRL_ECCDEBWIE_Msk = 0x10
	// Bit ECCDEBWIE.
	RAMECC_M1FDRL_ECCDEBWIE = 0x10
	// Position of ECCELEN field.
	RAMECC_M1FDRL_ECCELEN_Pos = 0x5
	// Bit mask of ECCELEN field.
	RAMECC_M1FDRL_ECCELEN_Msk = 0x20
	// Bit ECCELEN.
	RAMECC_M1FDRL_ECCELEN = 0x20

	// M1FDRH: RAMECC monitor x failing data high register
	// Position of ECCSEIE field.
	RAMECC_M1FDRH_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	RAMECC_M1FDRH_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	RAMECC_M1FDRH_ECCSEIE = 0x4
	// Position of ECCDEIE field.
	RAMECC_M1FDRH_ECCDEIE_Pos = 0x3
	// Bit mask of ECCDEIE field.
	RAMECC_M1FDRH_ECCDEIE_Msk = 0x8
	// Bit ECCDEIE.
	RAMECC_M1FDRH_ECCDEIE = 0x8
	// Position of ECCDEBWIE field.
	RAMECC_M1FDRH_ECCDEBWIE_Pos = 0x4
	// Bit mask of ECCDEBWIE field.
	RAMECC_M1FDRH_ECCDEBWIE_Msk = 0x10
	// Bit ECCDEBWIE.
	RAMECC_M1FDRH_ECCDEBWIE = 0x10
	// Position of ECCELEN field.
	RAMECC_M1FDRH_ECCELEN_Pos = 0x5
	// Bit mask of ECCELEN field.
	RAMECC_M1FDRH_ECCELEN_Msk = 0x20
	// Bit ECCELEN.
	RAMECC_M1FDRH_ECCELEN = 0x20

	// M1FECR: RAMECC monitor x failing ECC error code register
	// Position of SEDCF field.
	RAMECC_M1FECR_SEDCF_Pos = 0x0
	// Bit mask of SEDCF field.
	RAMECC_M1FECR_SEDCF_Msk = 0x1
	// Bit SEDCF.
	RAMECC_M1FECR_SEDCF = 0x1
	// Position of DEDF field.
	RAMECC_M1FECR_DEDF_Pos = 0x1
	// Bit mask of DEDF field.
	RAMECC_M1FECR_DEDF_Msk = 0x2
	// Bit DEDF.
	RAMECC_M1FECR_DEDF = 0x2
	// Position of DEBWDF field.
	RAMECC_M1FECR_DEBWDF_Pos = 0x2
	// Bit mask of DEBWDF field.
	RAMECC_M1FECR_DEBWDF_Msk = 0x4
	// Bit DEBWDF.
	RAMECC_M1FECR_DEBWDF = 0x4

	// M2CR: RAMECC monitor x configuration register
	// Position of SEDCF field.
	RAMECC_M2CR_SEDCF_Pos = 0x0
	// Bit mask of SEDCF field.
	RAMECC_M2CR_SEDCF_Msk = 0x1
	// Bit SEDCF.
	RAMECC_M2CR_SEDCF = 0x1
	// Position of DEDF field.
	RAMECC_M2CR_DEDF_Pos = 0x1
	// Bit mask of DEDF field.
	RAMECC_M2CR_DEDF_Msk = 0x2
	// Bit DEDF.
	RAMECC_M2CR_DEDF = 0x2
	// Position of DEBWDF field.
	RAMECC_M2CR_DEBWDF_Pos = 0x2
	// Bit mask of DEBWDF field.
	RAMECC_M2CR_DEBWDF_Msk = 0x4
	// Bit DEBWDF.
	RAMECC_M2CR_DEBWDF = 0x4

	// M2SR: RAMECC monitor x status register
	// Position of SEDCF field.
	RAMECC_M2SR_SEDCF_Pos = 0x0
	// Bit mask of SEDCF field.
	RAMECC_M2SR_SEDCF_Msk = 0x1
	// Bit SEDCF.
	RAMECC_M2SR_SEDCF = 0x1
	// Position of DEDF field.
	RAMECC_M2SR_DEDF_Pos = 0x1
	// Bit mask of DEDF field.
	RAMECC_M2SR_DEDF_Msk = 0x2
	// Bit DEDF.
	RAMECC_M2SR_DEDF = 0x2
	// Position of DEBWDF field.
	RAMECC_M2SR_DEBWDF_Pos = 0x2
	// Bit mask of DEBWDF field.
	RAMECC_M2SR_DEBWDF_Msk = 0x4
	// Bit DEBWDF.
	RAMECC_M2SR_DEBWDF = 0x4

	// M2FAR: RAMECC monitor x failing address register
	// Position of SEDCF field.
	RAMECC_M2FAR_SEDCF_Pos = 0x0
	// Bit mask of SEDCF field.
	RAMECC_M2FAR_SEDCF_Msk = 0x1
	// Bit SEDCF.
	RAMECC_M2FAR_SEDCF = 0x1
	// Position of DEDF field.
	RAMECC_M2FAR_DEDF_Pos = 0x1
	// Bit mask of DEDF field.
	RAMECC_M2FAR_DEDF_Msk = 0x2
	// Bit DEDF.
	RAMECC_M2FAR_DEDF = 0x2
	// Position of DEBWDF field.
	RAMECC_M2FAR_DEBWDF_Pos = 0x2
	// Bit mask of DEBWDF field.
	RAMECC_M2FAR_DEBWDF_Msk = 0x4
	// Bit DEBWDF.
	RAMECC_M2FAR_DEBWDF = 0x4

	// M2FDRL: RAMECC monitor x failing data low register
	// Position of SEDCF field.
	RAMECC_M2FDRL_SEDCF_Pos = 0x0
	// Bit mask of SEDCF field.
	RAMECC_M2FDRL_SEDCF_Msk = 0x1
	// Bit SEDCF.
	RAMECC_M2FDRL_SEDCF = 0x1
	// Position of DEDF field.
	RAMECC_M2FDRL_DEDF_Pos = 0x1
	// Bit mask of DEDF field.
	RAMECC_M2FDRL_DEDF_Msk = 0x2
	// Bit DEDF.
	RAMECC_M2FDRL_DEDF = 0x2
	// Position of DEBWDF field.
	RAMECC_M2FDRL_DEBWDF_Pos = 0x2
	// Bit mask of DEBWDF field.
	RAMECC_M2FDRL_DEBWDF_Msk = 0x4
	// Bit DEBWDF.
	RAMECC_M2FDRL_DEBWDF = 0x4

	// M2FDRH: RAMECC monitor x failing data high register
	// Position of FADD field.
	RAMECC_M2FDRH_FADD_Pos = 0x0
	// Bit mask of FADD field.
	RAMECC_M2FDRH_FADD_Msk = 0xffffffff

	// M2FECR: RAMECC monitor x failing ECC error code register
	// Position of FADD field.
	RAMECC_M2FECR_FADD_Pos = 0x0
	// Bit mask of FADD field.
	RAMECC_M2FECR_FADD_Msk = 0xffffffff

	// M3CR: RAMECC monitor x configuration register
	// Position of FADD field.
	RAMECC_M3CR_FADD_Pos = 0x0
	// Bit mask of FADD field.
	RAMECC_M3CR_FADD_Msk = 0xffffffff

	// M3SR: RAMECC monitor x status register
	// Position of FADD field.
	RAMECC_M3SR_FADD_Pos = 0x0
	// Bit mask of FADD field.
	RAMECC_M3SR_FADD_Msk = 0xffffffff

	// M3FAR: RAMECC monitor x failing address register
	// Position of FADD field.
	RAMECC_M3FAR_FADD_Pos = 0x0
	// Bit mask of FADD field.
	RAMECC_M3FAR_FADD_Msk = 0xffffffff

	// M3FDRL: RAMECC monitor x failing data low register
	// Position of FDATAL field.
	RAMECC_M3FDRL_FDATAL_Pos = 0x0
	// Bit mask of FDATAL field.
	RAMECC_M3FDRL_FDATAL_Msk = 0xffffffff

	// M3FDRH: RAMECC monitor x failing data high register
	// Position of FDATAL field.
	RAMECC_M3FDRH_FDATAL_Pos = 0x0
	// Bit mask of FDATAL field.
	RAMECC_M3FDRH_FDATAL_Msk = 0xffffffff

	// M3FECR: RAMECC monitor x failing ECC error code register
	// Position of FDATAL field.
	RAMECC_M3FECR_FDATAL_Pos = 0x0
	// Bit mask of FDATAL field.
	RAMECC_M3FECR_FDATAL_Msk = 0xffffffff

	// M4CR: RAMECC monitor x configuration register
	// Position of FDATAL field.
	RAMECC_M4CR_FDATAL_Pos = 0x0
	// Bit mask of FDATAL field.
	RAMECC_M4CR_FDATAL_Msk = 0xffffffff

	// M4SR: RAMECC monitor x status register
	// Position of FDATAL field.
	RAMECC_M4SR_FDATAL_Pos = 0x0
	// Bit mask of FDATAL field.
	RAMECC_M4SR_FDATAL_Msk = 0xffffffff

	// M4FAR: RAMECC monitor x failing address register
	// Position of FDATAH field.
	RAMECC_M4FAR_FDATAH_Pos = 0x0
	// Bit mask of FDATAH field.
	RAMECC_M4FAR_FDATAH_Msk = 0xffffffff

	// M4FDRL: RAMECC monitor x failing data low register
	// Position of FDATAH field.
	RAMECC_M4FDRL_FDATAH_Pos = 0x0
	// Bit mask of FDATAH field.
	RAMECC_M4FDRL_FDATAH_Msk = 0xffffffff

	// M4FDRH: RAMECC monitor x failing data high register
	// Position of FDATAH field.
	RAMECC_M4FDRH_FDATAH_Pos = 0x0
	// Bit mask of FDATAH field.
	RAMECC_M4FDRH_FDATAH_Msk = 0xffffffff

	// M4FECR: RAMECC monitor x failing ECC error code register
	// Position of FDATAH field.
	RAMECC_M4FECR_FDATAH_Pos = 0x0
	// Bit mask of FDATAH field.
	RAMECC_M4FECR_FDATAH_Msk = 0xffffffff

	// M5CR: RAMECC monitor x configuration register
	// Position of FEC field.
	RAMECC_M5CR_FEC_Pos = 0x0
	// Bit mask of FEC field.
	RAMECC_M5CR_FEC_Msk = 0xffffffff

	// M5SR: RAMECC monitor x status register
	// Position of FEC field.
	RAMECC_M5SR_FEC_Pos = 0x0
	// Bit mask of FEC field.
	RAMECC_M5SR_FEC_Msk = 0xffffffff

	// M5FAR: RAMECC monitor x failing address register
	// Position of FEC field.
	RAMECC_M5FAR_FEC_Pos = 0x0
	// Bit mask of FEC field.
	RAMECC_M5FAR_FEC_Msk = 0xffffffff

	// M5FDRL: RAMECC monitor x failing data low register
	// Position of FEC field.
	RAMECC_M5FDRL_FEC_Pos = 0x0
	// Bit mask of FEC field.
	RAMECC_M5FDRL_FEC_Msk = 0xffffffff

	// M5FDRH: RAMECC monitor x failing data high register
	// Position of FEC field.
	RAMECC_M5FDRH_FEC_Pos = 0x0
	// Bit mask of FEC field.
	RAMECC_M5FDRH_FEC_Msk = 0xffffffff

	// M5FECR: RAMECC monitor x failing ECC error code register
	// Position of FEC field.
	RAMECC_M5FECR_FEC_Pos = 0x0
	// Bit mask of FEC field.
	RAMECC_M5FECR_FEC_Msk = 0xffffffff
)

// Constants for RCC: Reset and clock control
const (
	// CR: clock control register
	// Position of HSION field.
	RCC_CR_HSION_Pos = 0x0
	// Bit mask of HSION field.
	RCC_CR_HSION_Msk = 0x1
	// Bit HSION.
	RCC_CR_HSION = 0x1
	// Clock Off
	RCC_CR_HSION_Off = 0x0
	// Clock On
	RCC_CR_HSION_On = 0x1
	// Position of HSIKERON field.
	RCC_CR_HSIKERON_Pos = 0x1
	// Bit mask of HSIKERON field.
	RCC_CR_HSIKERON_Msk = 0x2
	// Bit HSIKERON.
	RCC_CR_HSIKERON = 0x2
	// Clock Off
	RCC_CR_HSIKERON_Off = 0x0
	// Clock On
	RCC_CR_HSIKERON_On = 0x1
	// Position of HSIRDY field.
	RCC_CR_HSIRDY_Pos = 0x2
	// Bit mask of HSIRDY field.
	RCC_CR_HSIRDY_Msk = 0x4
	// Bit HSIRDY.
	RCC_CR_HSIRDY = 0x4
	// Clock not ready
	RCC_CR_HSIRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_HSIRDY_Ready = 0x1
	// Position of HSIDIV field.
	RCC_CR_HSIDIV_Pos = 0x3
	// Bit mask of HSIDIV field.
	RCC_CR_HSIDIV_Msk = 0x18
	// No division
	RCC_CR_HSIDIV_Div1 = 0x0
	// Division by 2
	RCC_CR_HSIDIV_Div2 = 0x1
	// Division by 4
	RCC_CR_HSIDIV_Div4 = 0x2
	// Division by 8
	RCC_CR_HSIDIV_Div8 = 0x3
	// Position of HSIDIVF field.
	RCC_CR_HSIDIVF_Pos = 0x5
	// Bit mask of HSIDIVF field.
	RCC_CR_HSIDIVF_Msk = 0x20
	// Bit HSIDIVF.
	RCC_CR_HSIDIVF = 0x20
	// New HSIDIV ratio has not yet propagated to hsi_ck
	RCC_CR_HSIDIVF_NotPropagated = 0x0
	// HSIDIV ratio has propagated to hsi_ck
	RCC_CR_HSIDIVF_Propagated = 0x1
	// Position of CSION field.
	RCC_CR_CSION_Pos = 0x7
	// Bit mask of CSION field.
	RCC_CR_CSION_Msk = 0x80
	// Bit CSION.
	RCC_CR_CSION = 0x80
	// Clock Off
	RCC_CR_CSION_Off = 0x0
	// Clock On
	RCC_CR_CSION_On = 0x1
	// Position of CSIRDY field.
	RCC_CR_CSIRDY_Pos = 0x8
	// Bit mask of CSIRDY field.
	RCC_CR_CSIRDY_Msk = 0x100
	// Bit CSIRDY.
	RCC_CR_CSIRDY = 0x100
	// Clock not ready
	RCC_CR_CSIRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_CSIRDY_Ready = 0x1
	// Position of CSIKERON field.
	RCC_CR_CSIKERON_Pos = 0x9
	// Bit mask of CSIKERON field.
	RCC_CR_CSIKERON_Msk = 0x200
	// Bit CSIKERON.
	RCC_CR_CSIKERON = 0x200
	// Clock Off
	RCC_CR_CSIKERON_Off = 0x0
	// Clock On
	RCC_CR_CSIKERON_On = 0x1
	// Position of HSI48ON field.
	RCC_CR_HSI48ON_Pos = 0xc
	// Bit mask of HSI48ON field.
	RCC_CR_HSI48ON_Msk = 0x1000
	// Bit HSI48ON.
	RCC_CR_HSI48ON = 0x1000
	// Clock Off
	RCC_CR_HSI48ON_Off = 0x0
	// Clock On
	RCC_CR_HSI48ON_On = 0x1
	// Position of HSI48RDY field.
	RCC_CR_HSI48RDY_Pos = 0xd
	// Bit mask of HSI48RDY field.
	RCC_CR_HSI48RDY_Msk = 0x2000
	// Bit HSI48RDY.
	RCC_CR_HSI48RDY = 0x2000
	// Clock not ready
	RCC_CR_HSI48RDY_NotReady = 0x0
	// Clock ready
	RCC_CR_HSI48RDY_Ready = 0x1
	// Position of D1CKRDY field.
	RCC_CR_D1CKRDY_Pos = 0xe
	// Bit mask of D1CKRDY field.
	RCC_CR_D1CKRDY_Msk = 0x4000
	// Bit D1CKRDY.
	RCC_CR_D1CKRDY = 0x4000
	// Clock not ready
	RCC_CR_D1CKRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_D1CKRDY_Ready = 0x1
	// Position of D2CKRDY field.
	RCC_CR_D2CKRDY_Pos = 0xf
	// Bit mask of D2CKRDY field.
	RCC_CR_D2CKRDY_Msk = 0x8000
	// Bit D2CKRDY.
	RCC_CR_D2CKRDY = 0x8000
	// Clock not ready
	RCC_CR_D2CKRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_D2CKRDY_Ready = 0x1
	// Position of HSEON field.
	RCC_CR_HSEON_Pos = 0x10
	// Bit mask of HSEON field.
	RCC_CR_HSEON_Msk = 0x10000
	// Bit HSEON.
	RCC_CR_HSEON = 0x10000
	// Clock Off
	RCC_CR_HSEON_Off = 0x0
	// Clock On
	RCC_CR_HSEON_On = 0x1
	// Position of HSERDY field.
	RCC_CR_HSERDY_Pos = 0x11
	// Bit mask of HSERDY field.
	RCC_CR_HSERDY_Msk = 0x20000
	// Bit HSERDY.
	RCC_CR_HSERDY = 0x20000
	// Clock not ready
	RCC_CR_HSERDY_NotReady = 0x0
	// Clock ready
	RCC_CR_HSERDY_Ready = 0x1
	// Position of HSEBYP field.
	RCC_CR_HSEBYP_Pos = 0x12
	// Bit mask of HSEBYP field.
	RCC_CR_HSEBYP_Msk = 0x40000
	// Bit HSEBYP.
	RCC_CR_HSEBYP = 0x40000
	// HSE crystal oscillator not bypassed
	RCC_CR_HSEBYP_NotBypassed = 0x0
	// HSE crystal oscillator bypassed with external clock
	RCC_CR_HSEBYP_Bypassed = 0x1
	// Position of HSECSSON field.
	RCC_CR_HSECSSON_Pos = 0x13
	// Bit mask of HSECSSON field.
	RCC_CR_HSECSSON_Msk = 0x80000
	// Bit HSECSSON.
	RCC_CR_HSECSSON = 0x80000
	// Clock Off
	RCC_CR_HSECSSON_Off = 0x0
	// Clock On
	RCC_CR_HSECSSON_On = 0x1
	// Position of PLL1ON field.
	RCC_CR_PLL1ON_Pos = 0x18
	// Bit mask of PLL1ON field.
	RCC_CR_PLL1ON_Msk = 0x1000000
	// Bit PLL1ON.
	RCC_CR_PLL1ON = 0x1000000
	// Clock Off
	RCC_CR_PLL1ON_Off = 0x0
	// Clock On
	RCC_CR_PLL1ON_On = 0x1
	// Position of PLL1RDY field.
	RCC_CR_PLL1RDY_Pos = 0x19
	// Bit mask of PLL1RDY field.
	RCC_CR_PLL1RDY_Msk = 0x2000000
	// Bit PLL1RDY.
	RCC_CR_PLL1RDY = 0x2000000
	// Clock not ready
	RCC_CR_PLL1RDY_NotReady = 0x0
	// Clock ready
	RCC_CR_PLL1RDY_Ready = 0x1
	// Position of PLL2ON field.
	RCC_CR_PLL2ON_Pos = 0x1a
	// Bit mask of PLL2ON field.
	RCC_CR_PLL2ON_Msk = 0x4000000
	// Bit PLL2ON.
	RCC_CR_PLL2ON = 0x4000000
	// Clock Off
	RCC_CR_PLL2ON_Off = 0x0
	// Clock On
	RCC_CR_PLL2ON_On = 0x1
	// Position of PLL2RDY field.
	RCC_CR_PLL2RDY_Pos = 0x1b
	// Bit mask of PLL2RDY field.
	RCC_CR_PLL2RDY_Msk = 0x8000000
	// Bit PLL2RDY.
	RCC_CR_PLL2RDY = 0x8000000
	// Clock not ready
	RCC_CR_PLL2RDY_NotReady = 0x0
	// Clock ready
	RCC_CR_PLL2RDY_Ready = 0x1
	// Position of PLL3ON field.
	RCC_CR_PLL3ON_Pos = 0x1c
	// Bit mask of PLL3ON field.
	RCC_CR_PLL3ON_Msk = 0x10000000
	// Bit PLL3ON.
	RCC_CR_PLL3ON = 0x10000000
	// Clock Off
	RCC_CR_PLL3ON_Off = 0x0
	// Clock On
	RCC_CR_PLL3ON_On = 0x1
	// Position of PLL3RDY field.
	RCC_CR_PLL3RDY_Pos = 0x1d
	// Bit mask of PLL3RDY field.
	RCC_CR_PLL3RDY_Msk = 0x20000000
	// Bit PLL3RDY.
	RCC_CR_PLL3RDY = 0x20000000
	// Clock not ready
	RCC_CR_PLL3RDY_NotReady = 0x0
	// Clock ready
	RCC_CR_PLL3RDY_Ready = 0x1

	// HSICFGR: RCC HSI configuration register
	// Position of HSITRIM field.
	RCC_HSICFGR_HSITRIM_Pos = 0x18
	// Bit mask of HSITRIM field.
	RCC_HSICFGR_HSITRIM_Msk = 0x7f000000
	// Position of HSICAL field.
	RCC_HSICFGR_HSICAL_Pos = 0x0
	// Bit mask of HSICAL field.
	RCC_HSICFGR_HSICAL_Msk = 0xfff

	// CRRCR: RCC Clock Recovery RC Register
	// Position of HSI48CAL field.
	RCC_CRRCR_HSI48CAL_Pos = 0x0
	// Bit mask of HSI48CAL field.
	RCC_CRRCR_HSI48CAL_Msk = 0x3ff

	// CSICFGR: RCC CSI configuration register
	// Position of CSITRIM field.
	RCC_CSICFGR_CSITRIM_Pos = 0x18
	// Bit mask of CSITRIM field.
	RCC_CSICFGR_CSITRIM_Msk = 0x3f000000
	// Position of CSICAL field.
	RCC_CSICFGR_CSICAL_Pos = 0x0
	// Bit mask of CSICAL field.
	RCC_CSICFGR_CSICAL_Msk = 0x3ff

	// CFGR: RCC Clock Configuration Register
	// Position of SW field.
	RCC_CFGR_SW_Pos = 0x0
	// Bit mask of SW field.
	RCC_CFGR_SW_Msk = 0x7
	// HSI selected as system clock
	RCC_CFGR_SW_HSI = 0x0
	// CSI selected as system clock
	RCC_CFGR_SW_CSI = 0x1
	// HSE selected as system clock
	RCC_CFGR_SW_HSE = 0x2
	// PLL1 selected as system clock
	RCC_CFGR_SW_PLL1 = 0x3
	// Position of SWS field.
	RCC_CFGR_SWS_Pos = 0x3
	// Bit mask of SWS field.
	RCC_CFGR_SWS_Msk = 0x38
	// HSI oscillator used as system clock
	RCC_CFGR_SWS_HSI = 0x0
	// CSI oscillator used as system clock
	RCC_CFGR_SWS_CSI = 0x1
	// HSE oscillator used as system clock
	RCC_CFGR_SWS_HSE = 0x2
	// PLL1 used as system clock
	RCC_CFGR_SWS_PLL1 = 0x3
	// Position of STOPWUCK field.
	RCC_CFGR_STOPWUCK_Pos = 0x6
	// Bit mask of STOPWUCK field.
	RCC_CFGR_STOPWUCK_Msk = 0x40
	// Bit STOPWUCK.
	RCC_CFGR_STOPWUCK = 0x40
	// HSI selected as wake up clock from system Stop
	RCC_CFGR_STOPWUCK_HSI = 0x0
	// CSI selected as wake up clock from system Stop
	RCC_CFGR_STOPWUCK_CSI = 0x1
	// Position of STOPKERWUCK field.
	RCC_CFGR_STOPKERWUCK_Pos = 0x7
	// Bit mask of STOPKERWUCK field.
	RCC_CFGR_STOPKERWUCK_Msk = 0x80
	// Bit STOPKERWUCK.
	RCC_CFGR_STOPKERWUCK = 0x80
	// HSI selected as wake up clock from system Stop
	RCC_CFGR_STOPKERWUCK_HSI = 0x0
	// CSI selected as wake up clock from system Stop
	RCC_CFGR_STOPKERWUCK_CSI = 0x1
	// Position of RTCPRE field.
	RCC_CFGR_RTCPRE_Pos = 0x8
	// Bit mask of RTCPRE field.
	RCC_CFGR_RTCPRE_Msk = 0x3f00
	// Position of HRTIMSEL field.
	RCC_CFGR_HRTIMSEL_Pos = 0xe
	// Bit mask of HRTIMSEL field.
	RCC_CFGR_HRTIMSEL_Msk = 0x4000
	// Bit HRTIMSEL.
	RCC_CFGR_HRTIMSEL = 0x4000
	// Position of TIMPRE field.
	RCC_CFGR_TIMPRE_Pos = 0xf
	// Bit mask of TIMPRE field.
	RCC_CFGR_TIMPRE_Msk = 0x8000
	// Bit TIMPRE.
	RCC_CFGR_TIMPRE = 0x8000
	// Timer kernel clock equal to 2x pclk by default
	RCC_CFGR_TIMPRE_DefaultX2 = 0x0
	// Timer kernel clock equal to 4x pclk by default
	RCC_CFGR_TIMPRE_DefaultX4 = 0x1
	// Position of MCO1PRE field.
	RCC_CFGR_MCO1PRE_Pos = 0x12
	// Bit mask of MCO1PRE field.
	RCC_CFGR_MCO1PRE_Msk = 0x3c0000
	// Position of MCO1 field.
	RCC_CFGR_MCO1_Pos = 0x16
	// Bit mask of MCO1 field.
	RCC_CFGR_MCO1_Msk = 0x1c00000
	// HSI selected for micro-controller clock output
	RCC_CFGR_MCO1_HSI = 0x0
	// LSE selected for micro-controller clock output
	RCC_CFGR_MCO1_LSE = 0x1
	// HSE selected for micro-controller clock output
	RCC_CFGR_MCO1_HSE = 0x2
	// pll1_q selected for micro-controller clock output
	RCC_CFGR_MCO1_PLL1_Q = 0x3
	// HSI48 selected for micro-controller clock output
	RCC_CFGR_MCO1_HSI48 = 0x4
	// Position of MCO2PRE field.
	RCC_CFGR_MCO2PRE_Pos = 0x19
	// Bit mask of MCO2PRE field.
	RCC_CFGR_MCO2PRE_Msk = 0x1e000000
	// Position of MCO2 field.
	RCC_CFGR_MCO2_Pos = 0x1d
	// Bit mask of MCO2 field.
	RCC_CFGR_MCO2_Msk = 0xe0000000
	// System clock selected for micro-controller clock output
	RCC_CFGR_MCO2_SYSCLK = 0x0
	// pll2_p selected for micro-controller clock output
	RCC_CFGR_MCO2_PLL2_P = 0x1
	// HSE selected for micro-controller clock output
	RCC_CFGR_MCO2_HSE = 0x2
	// pll1_p selected for micro-controller clock output
	RCC_CFGR_MCO2_PLL1_P = 0x3
	// CSI selected for micro-controller clock output
	RCC_CFGR_MCO2_CSI = 0x4
	// LSI selected for micro-controller clock output
	RCC_CFGR_MCO2_LSI = 0x5

	// D1CFGR: RCC Domain 1 Clock Configuration Register
	// Position of HPRE field.
	RCC_D1CFGR_HPRE_Pos = 0x0
	// Bit mask of HPRE field.
	RCC_D1CFGR_HPRE_Msk = 0xf
	// sys_ck not divided
	RCC_D1CFGR_HPRE_Div1 = 0x0
	// sys_ck divided by 2
	RCC_D1CFGR_HPRE_Div2 = 0x8
	// sys_ck divided by 4
	RCC_D1CFGR_HPRE_Div4 = 0x9
	// sys_ck divided by 8
	RCC_D1CFGR_HPRE_Div8 = 0xa
	// sys_ck divided by 16
	RCC_D1CFGR_HPRE_Div16 = 0xb
	// sys_ck divided by 64
	RCC_D1CFGR_HPRE_Div64 = 0xc
	// sys_ck divided by 128
	RCC_D1CFGR_HPRE_Div128 = 0xd
	// sys_ck divided by 256
	RCC_D1CFGR_HPRE_Div256 = 0xe
	// sys_ck divided by 512
	RCC_D1CFGR_HPRE_Div512 = 0xf
	// Position of D1PPRE field.
	RCC_D1CFGR_D1PPRE_Pos = 0x4
	// Bit mask of D1PPRE field.
	RCC_D1CFGR_D1PPRE_Msk = 0x70
	// rcc_hclk not divided
	RCC_D1CFGR_D1PPRE_Div1 = 0x0
	// rcc_hclk divided by 2
	RCC_D1CFGR_D1PPRE_Div2 = 0x4
	// rcc_hclk divided by 4
	RCC_D1CFGR_D1PPRE_Div4 = 0x5
	// rcc_hclk divided by 8
	RCC_D1CFGR_D1PPRE_Div8 = 0x6
	// rcc_hclk divided by 16
	RCC_D1CFGR_D1PPRE_Div16 = 0x7
	// Position of D1CPRE field.
	RCC_D1CFGR_D1CPRE_Pos = 0x8
	// Bit mask of D1CPRE field.
	RCC_D1CFGR_D1CPRE_Msk = 0xf00
	// sys_ck not divided
	RCC_D1CFGR_D1CPRE_Div1 = 0x0
	// sys_ck divided by 2
	RCC_D1CFGR_D1CPRE_Div2 = 0x8
	// sys_ck divided by 4
	RCC_D1CFGR_D1CPRE_Div4 = 0x9
	// sys_ck divided by 8
	RCC_D1CFGR_D1CPRE_Div8 = 0xa
	// sys_ck divided by 16
	RCC_D1CFGR_D1CPRE_Div16 = 0xb
	// sys_ck divided by 64
	RCC_D1CFGR_D1CPRE_Div64 = 0xc
	// sys_ck divided by 128
	RCC_D1CFGR_D1CPRE_Div128 = 0xd
	// sys_ck divided by 256
	RCC_D1CFGR_D1CPRE_Div256 = 0xe
	// sys_ck divided by 512
	RCC_D1CFGR_D1CPRE_Div512 = 0xf

	// D2CFGR: RCC Domain 2 Clock Configuration Register
	// Position of D2PPRE1 field.
	RCC_D2CFGR_D2PPRE1_Pos = 0x4
	// Bit mask of D2PPRE1 field.
	RCC_D2CFGR_D2PPRE1_Msk = 0x70
	// rcc_hclk not divided
	RCC_D2CFGR_D2PPRE1_Div1 = 0x0
	// rcc_hclk divided by 2
	RCC_D2CFGR_D2PPRE1_Div2 = 0x4
	// rcc_hclk divided by 4
	RCC_D2CFGR_D2PPRE1_Div4 = 0x5
	// rcc_hclk divided by 8
	RCC_D2CFGR_D2PPRE1_Div8 = 0x6
	// rcc_hclk divided by 16
	RCC_D2CFGR_D2PPRE1_Div16 = 0x7
	// Position of D2PPRE2 field.
	RCC_D2CFGR_D2PPRE2_Pos = 0x8
	// Bit mask of D2PPRE2 field.
	RCC_D2CFGR_D2PPRE2_Msk = 0x700
	// rcc_hclk not divided
	RCC_D2CFGR_D2PPRE2_Div1 = 0x0
	// rcc_hclk divided by 2
	RCC_D2CFGR_D2PPRE2_Div2 = 0x4
	// rcc_hclk divided by 4
	RCC_D2CFGR_D2PPRE2_Div4 = 0x5
	// rcc_hclk divided by 8
	RCC_D2CFGR_D2PPRE2_Div8 = 0x6
	// rcc_hclk divided by 16
	RCC_D2CFGR_D2PPRE2_Div16 = 0x7

	// D3CFGR: RCC Domain 3 Clock Configuration Register
	// Position of D3PPRE field.
	RCC_D3CFGR_D3PPRE_Pos = 0x4
	// Bit mask of D3PPRE field.
	RCC_D3CFGR_D3PPRE_Msk = 0x70
	// rcc_hclk not divided
	RCC_D3CFGR_D3PPRE_Div1 = 0x0
	// rcc_hclk divided by 2
	RCC_D3CFGR_D3PPRE_Div2 = 0x4
	// rcc_hclk divided by 4
	RCC_D3CFGR_D3PPRE_Div4 = 0x5
	// rcc_hclk divided by 8
	RCC_D3CFGR_D3PPRE_Div8 = 0x6
	// rcc_hclk divided by 16
	RCC_D3CFGR_D3PPRE_Div16 = 0x7

	// PLLCKSELR: RCC PLLs Clock Source Selection Register
	// Position of PLLSRC field.
	RCC_PLLCKSELR_PLLSRC_Pos = 0x0
	// Bit mask of PLLSRC field.
	RCC_PLLCKSELR_PLLSRC_Msk = 0x3
	// HSI selected as PLL clock
	RCC_PLLCKSELR_PLLSRC_HSI = 0x0
	// CSI selected as PLL clock
	RCC_PLLCKSELR_PLLSRC_CSI = 0x1
	// HSE selected as PLL clock
	RCC_PLLCKSELR_PLLSRC_HSE = 0x2
	// No clock sent to DIVMx dividers and PLLs
	RCC_PLLCKSELR_PLLSRC_None = 0x3
	// Position of DIVM1 field.
	RCC_PLLCKSELR_DIVM1_Pos = 0x4
	// Bit mask of DIVM1 field.
	RCC_PLLCKSELR_DIVM1_Msk = 0x3f0
	// Position of DIVM2 field.
	RCC_PLLCKSELR_DIVM2_Pos = 0xc
	// Bit mask of DIVM2 field.
	RCC_PLLCKSELR_DIVM2_Msk = 0x3f000
	// Position of DIVM3 field.
	RCC_PLLCKSELR_DIVM3_Pos = 0x14
	// Bit mask of DIVM3 field.
	RCC_PLLCKSELR_DIVM3_Msk = 0x3f00000

	// PLLCFGR: RCC PLLs Configuration Register
	// Position of PLL1FRACEN field.
	RCC_PLLCFGR_PLL1FRACEN_Pos = 0x0
	// Bit mask of PLL1FRACEN field.
	RCC_PLLCFGR_PLL1FRACEN_Msk = 0x1
	// Bit PLL1FRACEN.
	RCC_PLLCFGR_PLL1FRACEN = 0x1
	// Reset latch to tranfer FRACN to the Sigma-Delta modulator
	RCC_PLLCFGR_PLL1FRACEN_Reset = 0x0
	// Set latch to tranfer FRACN to the Sigma-Delta modulator
	RCC_PLLCFGR_PLL1FRACEN_Set = 0x1
	// Position of PLL1VCOSEL field.
	RCC_PLLCFGR_PLL1VCOSEL_Pos = 0x1
	// Bit mask of PLL1VCOSEL field.
	RCC_PLLCFGR_PLL1VCOSEL_Msk = 0x2
	// Bit PLL1VCOSEL.
	RCC_PLLCFGR_PLL1VCOSEL = 0x2
	// VCO frequency range 192 to 836 MHz
	RCC_PLLCFGR_PLL1VCOSEL_WideVCO = 0x0
	// VCO frequency range 150 to 420 MHz
	RCC_PLLCFGR_PLL1VCOSEL_MediumVCO = 0x1
	// Position of PLL1RGE field.
	RCC_PLLCFGR_PLL1RGE_Pos = 0x2
	// Bit mask of PLL1RGE field.
	RCC_PLLCFGR_PLL1RGE_Msk = 0xc
	// Frequency is between 1 and 2 MHz
	RCC_PLLCFGR_PLL1RGE_Range1 = 0x0
	// Frequency is between 2 and 4 MHz
	RCC_PLLCFGR_PLL1RGE_Range2 = 0x1
	// Frequency is between 4 and 8 MHz
	RCC_PLLCFGR_PLL1RGE_Range4 = 0x2
	// Frequency is between 8 and 16 MHz
	RCC_PLLCFGR_PLL1RGE_Range8 = 0x3
	// Position of PLL2FRACEN field.
	RCC_PLLCFGR_PLL2FRACEN_Pos = 0x4
	// Bit mask of PLL2FRACEN field.
	RCC_PLLCFGR_PLL2FRACEN_Msk = 0x10
	// Bit PLL2FRACEN.
	RCC_PLLCFGR_PLL2FRACEN = 0x10
	// Reset latch to tranfer FRACN to the Sigma-Delta modulator
	RCC_PLLCFGR_PLL2FRACEN_Reset = 0x0
	// Set latch to tranfer FRACN to the Sigma-Delta modulator
	RCC_PLLCFGR_PLL2FRACEN_Set = 0x1
	// Position of PLL2VCOSEL field.
	RCC_PLLCFGR_PLL2VCOSEL_Pos = 0x5
	// Bit mask of PLL2VCOSEL field.
	RCC_PLLCFGR_PLL2VCOSEL_Msk = 0x20
	// Bit PLL2VCOSEL.
	RCC_PLLCFGR_PLL2VCOSEL = 0x20
	// VCO frequency range 192 to 836 MHz
	RCC_PLLCFGR_PLL2VCOSEL_WideVCO = 0x0
	// VCO frequency range 150 to 420 MHz
	RCC_PLLCFGR_PLL2VCOSEL_MediumVCO = 0x1
	// Position of PLL2RGE field.
	RCC_PLLCFGR_PLL2RGE_Pos = 0x6
	// Bit mask of PLL2RGE field.
	RCC_PLLCFGR_PLL2RGE_Msk = 0xc0
	// Frequency is between 1 and 2 MHz
	RCC_PLLCFGR_PLL2RGE_Range1 = 0x0
	// Frequency is between 2 and 4 MHz
	RCC_PLLCFGR_PLL2RGE_Range2 = 0x1
	// Frequency is between 4 and 8 MHz
	RCC_PLLCFGR_PLL2RGE_Range4 = 0x2
	// Frequency is between 8 and 16 MHz
	RCC_PLLCFGR_PLL2RGE_Range8 = 0x3
	// Position of PLL3FRACEN field.
	RCC_PLLCFGR_PLL3FRACEN_Pos = 0x8
	// Bit mask of PLL3FRACEN field.
	RCC_PLLCFGR_PLL3FRACEN_Msk = 0x100
	// Bit PLL3FRACEN.
	RCC_PLLCFGR_PLL3FRACEN = 0x100
	// Reset latch to tranfer FRACN to the Sigma-Delta modulator
	RCC_PLLCFGR_PLL3FRACEN_Reset = 0x0
	// Set latch to tranfer FRACN to the Sigma-Delta modulator
	RCC_PLLCFGR_PLL3FRACEN_Set = 0x1
	// Position of PLL3VCOSEL field.
	RCC_PLLCFGR_PLL3VCOSEL_Pos = 0x9
	// Bit mask of PLL3VCOSEL field.
	RCC_PLLCFGR_PLL3VCOSEL_Msk = 0x200
	// Bit PLL3VCOSEL.
	RCC_PLLCFGR_PLL3VCOSEL = 0x200
	// VCO frequency range 192 to 836 MHz
	RCC_PLLCFGR_PLL3VCOSEL_WideVCO = 0x0
	// VCO frequency range 150 to 420 MHz
	RCC_PLLCFGR_PLL3VCOSEL_MediumVCO = 0x1
	// Position of PLL3RGE field.
	RCC_PLLCFGR_PLL3RGE_Pos = 0xa
	// Bit mask of PLL3RGE field.
	RCC_PLLCFGR_PLL3RGE_Msk = 0xc00
	// Frequency is between 1 and 2 MHz
	RCC_PLLCFGR_PLL3RGE_Range1 = 0x0
	// Frequency is between 2 and 4 MHz
	RCC_PLLCFGR_PLL3RGE_Range2 = 0x1
	// Frequency is between 4 and 8 MHz
	RCC_PLLCFGR_PLL3RGE_Range4 = 0x2
	// Frequency is between 8 and 16 MHz
	RCC_PLLCFGR_PLL3RGE_Range8 = 0x3
	// Position of DIVP1EN field.
	RCC_PLLCFGR_DIVP1EN_Pos = 0x10
	// Bit mask of DIVP1EN field.
	RCC_PLLCFGR_DIVP1EN_Msk = 0x10000
	// Bit DIVP1EN.
	RCC_PLLCFGR_DIVP1EN = 0x10000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVP1EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVP1EN_Enabled = 0x1
	// Position of DIVQ1EN field.
	RCC_PLLCFGR_DIVQ1EN_Pos = 0x11
	// Bit mask of DIVQ1EN field.
	RCC_PLLCFGR_DIVQ1EN_Msk = 0x20000
	// Bit DIVQ1EN.
	RCC_PLLCFGR_DIVQ1EN = 0x20000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVQ1EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVQ1EN_Enabled = 0x1
	// Position of DIVR1EN field.
	RCC_PLLCFGR_DIVR1EN_Pos = 0x12
	// Bit mask of DIVR1EN field.
	RCC_PLLCFGR_DIVR1EN_Msk = 0x40000
	// Bit DIVR1EN.
	RCC_PLLCFGR_DIVR1EN = 0x40000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVR1EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVR1EN_Enabled = 0x1
	// Position of DIVP2EN field.
	RCC_PLLCFGR_DIVP2EN_Pos = 0x13
	// Bit mask of DIVP2EN field.
	RCC_PLLCFGR_DIVP2EN_Msk = 0x80000
	// Bit DIVP2EN.
	RCC_PLLCFGR_DIVP2EN = 0x80000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVP2EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVP2EN_Enabled = 0x1
	// Position of DIVQ2EN field.
	RCC_PLLCFGR_DIVQ2EN_Pos = 0x14
	// Bit mask of DIVQ2EN field.
	RCC_PLLCFGR_DIVQ2EN_Msk = 0x100000
	// Bit DIVQ2EN.
	RCC_PLLCFGR_DIVQ2EN = 0x100000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVQ2EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVQ2EN_Enabled = 0x1
	// Position of DIVR2EN field.
	RCC_PLLCFGR_DIVR2EN_Pos = 0x15
	// Bit mask of DIVR2EN field.
	RCC_PLLCFGR_DIVR2EN_Msk = 0x200000
	// Bit DIVR2EN.
	RCC_PLLCFGR_DIVR2EN = 0x200000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVR2EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVR2EN_Enabled = 0x1
	// Position of DIVP3EN field.
	RCC_PLLCFGR_DIVP3EN_Pos = 0x16
	// Bit mask of DIVP3EN field.
	RCC_PLLCFGR_DIVP3EN_Msk = 0x400000
	// Bit DIVP3EN.
	RCC_PLLCFGR_DIVP3EN = 0x400000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVP3EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVP3EN_Enabled = 0x1
	// Position of DIVQ3EN field.
	RCC_PLLCFGR_DIVQ3EN_Pos = 0x17
	// Bit mask of DIVQ3EN field.
	RCC_PLLCFGR_DIVQ3EN_Msk = 0x800000
	// Bit DIVQ3EN.
	RCC_PLLCFGR_DIVQ3EN = 0x800000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVQ3EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVQ3EN_Enabled = 0x1
	// Position of DIVR3EN field.
	RCC_PLLCFGR_DIVR3EN_Pos = 0x18
	// Bit mask of DIVR3EN field.
	RCC_PLLCFGR_DIVR3EN_Msk = 0x1000000
	// Bit DIVR3EN.
	RCC_PLLCFGR_DIVR3EN = 0x1000000
	// Clock ouput is disabled
	RCC_PLLCFGR_DIVR3EN_Disabled = 0x0
	// Clock output is enabled
	RCC_PLLCFGR_DIVR3EN_Enabled = 0x1

	// PLL1DIVR: RCC PLL1 Dividers Configuration Register
	// Position of DIVN1 field.
	RCC_PLL1DIVR_DIVN1_Pos = 0x0
	// Bit mask of DIVN1 field.
	RCC_PLL1DIVR_DIVN1_Msk = 0x1ff
	// Position of DIVP1 field.
	RCC_PLL1DIVR_DIVP1_Pos = 0x9
	// Bit mask of DIVP1 field.
	RCC_PLL1DIVR_DIVP1_Msk = 0xfe00
	// pll_p_ck = vco_ck
	RCC_PLL1DIVR_DIVP1_Div1 = 0x0
	// pll_p_ck = vco_ck / 2
	RCC_PLL1DIVR_DIVP1_Div2 = 0x1
	// pll_p_ck = vco_ck / 4
	RCC_PLL1DIVR_DIVP1_Div4 = 0x3
	// pll_p_ck = vco_ck / 6
	RCC_PLL1DIVR_DIVP1_Div6 = 0x5
	// pll_p_ck = vco_ck / 8
	RCC_PLL1DIVR_DIVP1_Div8 = 0x7
	// pll_p_ck = vco_ck / 10
	RCC_PLL1DIVR_DIVP1_Div10 = 0x9
	// pll_p_ck = vco_ck / 12
	RCC_PLL1DIVR_DIVP1_Div12 = 0xb
	// pll_p_ck = vco_ck / 14
	RCC_PLL1DIVR_DIVP1_Div14 = 0xd
	// pll_p_ck = vco_ck / 16
	RCC_PLL1DIVR_DIVP1_Div16 = 0xf
	// pll_p_ck = vco_ck / 18
	RCC_PLL1DIVR_DIVP1_Div18 = 0x11
	// pll_p_ck = vco_ck / 20
	RCC_PLL1DIVR_DIVP1_Div20 = 0x13
	// pll_p_ck = vco_ck / 22
	RCC_PLL1DIVR_DIVP1_Div22 = 0x15
	// pll_p_ck = vco_ck / 24
	RCC_PLL1DIVR_DIVP1_Div24 = 0x17
	// pll_p_ck = vco_ck / 26
	RCC_PLL1DIVR_DIVP1_Div26 = 0x19
	// pll_p_ck = vco_ck / 28
	RCC_PLL1DIVR_DIVP1_Div28 = 0x1b
	// pll_p_ck = vco_ck / 30
	RCC_PLL1DIVR_DIVP1_Div30 = 0x1d
	// pll_p_ck = vco_ck / 32
	RCC_PLL1DIVR_DIVP1_Div32 = 0x1f
	// pll_p_ck = vco_ck / 34
	RCC_PLL1DIVR_DIVP1_Div34 = 0x21
	// pll_p_ck = vco_ck / 36
	RCC_PLL1DIVR_DIVP1_Div36 = 0x23
	// pll_p_ck = vco_ck / 38
	RCC_PLL1DIVR_DIVP1_Div38 = 0x25
	// pll_p_ck = vco_ck / 40
	RCC_PLL1DIVR_DIVP1_Div40 = 0x27
	// pll_p_ck = vco_ck / 42
	RCC_PLL1DIVR_DIVP1_Div42 = 0x29
	// pll_p_ck = vco_ck / 44
	RCC_PLL1DIVR_DIVP1_Div44 = 0x2b
	// pll_p_ck = vco_ck / 46
	RCC_PLL1DIVR_DIVP1_Div46 = 0x2d
	// pll_p_ck = vco_ck / 48
	RCC_PLL1DIVR_DIVP1_Div48 = 0x2f
	// pll_p_ck = vco_ck / 50
	RCC_PLL1DIVR_DIVP1_Div50 = 0x31
	// pll_p_ck = vco_ck / 52
	RCC_PLL1DIVR_DIVP1_Div52 = 0x33
	// pll_p_ck = vco_ck / 54
	RCC_PLL1DIVR_DIVP1_Div54 = 0x35
	// pll_p_ck = vco_ck / 56
	RCC_PLL1DIVR_DIVP1_Div56 = 0x37
	// pll_p_ck = vco_ck / 58
	RCC_PLL1DIVR_DIVP1_Div58 = 0x39
	// pll_p_ck = vco_ck / 60
	RCC_PLL1DIVR_DIVP1_Div60 = 0x3b
	// pll_p_ck = vco_ck / 62
	RCC_PLL1DIVR_DIVP1_Div62 = 0x3d
	// pll_p_ck = vco_ck / 64
	RCC_PLL1DIVR_DIVP1_Div64 = 0x3f
	// pll_p_ck = vco_ck / 66
	RCC_PLL1DIVR_DIVP1_Div66 = 0x41
	// pll_p_ck = vco_ck / 68
	RCC_PLL1DIVR_DIVP1_Div68 = 0x43
	// pll_p_ck = vco_ck / 70
	RCC_PLL1DIVR_DIVP1_Div70 = 0x45
	// pll_p_ck = vco_ck / 72
	RCC_PLL1DIVR_DIVP1_Div72 = 0x47
	// pll_p_ck = vco_ck / 74
	RCC_PLL1DIVR_DIVP1_Div74 = 0x49
	// pll_p_ck = vco_ck / 76
	RCC_PLL1DIVR_DIVP1_Div76 = 0x4b
	// pll_p_ck = vco_ck / 78
	RCC_PLL1DIVR_DIVP1_Div78 = 0x4d
	// pll_p_ck = vco_ck / 80
	RCC_PLL1DIVR_DIVP1_Div80 = 0x4f
	// pll_p_ck = vco_ck / 82
	RCC_PLL1DIVR_DIVP1_Div82 = 0x51
	// pll_p_ck = vco_ck / 84
	RCC_PLL1DIVR_DIVP1_Div84 = 0x53
	// pll_p_ck = vco_ck / 86
	RCC_PLL1DIVR_DIVP1_Div86 = 0x55
	// pll_p_ck = vco_ck / 88
	RCC_PLL1DIVR_DIVP1_Div88 = 0x57
	// pll_p_ck = vco_ck / 90
	RCC_PLL1DIVR_DIVP1_Div90 = 0x59
	// pll_p_ck = vco_ck / 92
	RCC_PLL1DIVR_DIVP1_Div92 = 0x5b
	// pll_p_ck = vco_ck / 94
	RCC_PLL1DIVR_DIVP1_Div94 = 0x5d
	// pll_p_ck = vco_ck / 96
	RCC_PLL1DIVR_DIVP1_Div96 = 0x5f
	// pll_p_ck = vco_ck / 98
	RCC_PLL1DIVR_DIVP1_Div98 = 0x61
	// pll_p_ck = vco_ck / 100
	RCC_PLL1DIVR_DIVP1_Div100 = 0x63
	// pll_p_ck = vco_ck / 102
	RCC_PLL1DIVR_DIVP1_Div102 = 0x65
	// pll_p_ck = vco_ck / 104
	RCC_PLL1DIVR_DIVP1_Div104 = 0x67
	// pll_p_ck = vco_ck / 106
	RCC_PLL1DIVR_DIVP1_Div106 = 0x69
	// pll_p_ck = vco_ck / 108
	RCC_PLL1DIVR_DIVP1_Div108 = 0x6b
	// pll_p_ck = vco_ck / 110
	RCC_PLL1DIVR_DIVP1_Div110 = 0x6d
	// pll_p_ck = vco_ck / 112
	RCC_PLL1DIVR_DIVP1_Div112 = 0x6f
	// pll_p_ck = vco_ck / 114
	RCC_PLL1DIVR_DIVP1_Div114 = 0x71
	// pll_p_ck = vco_ck / 116
	RCC_PLL1DIVR_DIVP1_Div116 = 0x73
	// pll_p_ck = vco_ck / 118
	RCC_PLL1DIVR_DIVP1_Div118 = 0x75
	// pll_p_ck = vco_ck / 120
	RCC_PLL1DIVR_DIVP1_Div120 = 0x77
	// pll_p_ck = vco_ck / 122
	RCC_PLL1DIVR_DIVP1_Div122 = 0x79
	// pll_p_ck = vco_ck / 124
	RCC_PLL1DIVR_DIVP1_Div124 = 0x7b
	// pll_p_ck = vco_ck / 126
	RCC_PLL1DIVR_DIVP1_Div126 = 0x7d
	// pll_p_ck = vco_ck / 128
	RCC_PLL1DIVR_DIVP1_Div128 = 0x7f
	// Position of DIVQ1 field.
	RCC_PLL1DIVR_DIVQ1_Pos = 0x10
	// Bit mask of DIVQ1 field.
	RCC_PLL1DIVR_DIVQ1_Msk = 0x7f0000
	// Position of DIVR1 field.
	RCC_PLL1DIVR_DIVR1_Pos = 0x18
	// Bit mask of DIVR1 field.
	RCC_PLL1DIVR_DIVR1_Msk = 0x7f000000

	// PLL1FRACR: RCC PLL1 Fractional Divider Register
	// Position of FRACN1 field.
	RCC_PLL1FRACR_FRACN1_Pos = 0x3
	// Bit mask of FRACN1 field.
	RCC_PLL1FRACR_FRACN1_Msk = 0xfff8

	// PLL2DIVR: RCC PLL2 Dividers Configuration Register
	// Position of DIVN2 field.
	RCC_PLL2DIVR_DIVN2_Pos = 0x0
	// Bit mask of DIVN2 field.
	RCC_PLL2DIVR_DIVN2_Msk = 0x1ff
	// Position of DIVP2 field.
	RCC_PLL2DIVR_DIVP2_Pos = 0x9
	// Bit mask of DIVP2 field.
	RCC_PLL2DIVR_DIVP2_Msk = 0xfe00
	// Position of DIVQ2 field.
	RCC_PLL2DIVR_DIVQ2_Pos = 0x10
	// Bit mask of DIVQ2 field.
	RCC_PLL2DIVR_DIVQ2_Msk = 0x7f0000
	// Position of DIVR2 field.
	RCC_PLL2DIVR_DIVR2_Pos = 0x18
	// Bit mask of DIVR2 field.
	RCC_PLL2DIVR_DIVR2_Msk = 0x7f000000

	// PLL2FRACR: RCC PLL2 Fractional Divider Register
	// Position of FRACN2 field.
	RCC_PLL2FRACR_FRACN2_Pos = 0x3
	// Bit mask of FRACN2 field.
	RCC_PLL2FRACR_FRACN2_Msk = 0xfff8

	// PLL3DIVR: RCC PLL3 Dividers Configuration Register
	// Position of DIVN3 field.
	RCC_PLL3DIVR_DIVN3_Pos = 0x0
	// Bit mask of DIVN3 field.
	RCC_PLL3DIVR_DIVN3_Msk = 0x1ff
	// Position of DIVP3 field.
	RCC_PLL3DIVR_DIVP3_Pos = 0x9
	// Bit mask of DIVP3 field.
	RCC_PLL3DIVR_DIVP3_Msk = 0xfe00
	// Position of DIVQ3 field.
	RCC_PLL3DIVR_DIVQ3_Pos = 0x10
	// Bit mask of DIVQ3 field.
	RCC_PLL3DIVR_DIVQ3_Msk = 0x7f0000
	// Position of DIVR3 field.
	RCC_PLL3DIVR_DIVR3_Pos = 0x18
	// Bit mask of DIVR3 field.
	RCC_PLL3DIVR_DIVR3_Msk = 0x7f000000

	// PLL3FRACR: RCC PLL3 Fractional Divider Register
	// Position of FRACN3 field.
	RCC_PLL3FRACR_FRACN3_Pos = 0x3
	// Bit mask of FRACN3 field.
	RCC_PLL3FRACR_FRACN3_Msk = 0xfff8

	// D1CCIPR: RCC Domain 1 Kernel Clock Configuration Register
	// Position of FMCSEL field.
	RCC_D1CCIPR_FMCSEL_Pos = 0x0
	// Bit mask of FMCSEL field.
	RCC_D1CCIPR_FMCSEL_Msk = 0x3
	// rcc_hclk3 selected as peripheral clock
	RCC_D1CCIPR_FMCSEL_RCC_HCLK3 = 0x0
	// pll1_q selected as peripheral clock
	RCC_D1CCIPR_FMCSEL_PLL1_Q = 0x1
	// pll2_r selected as peripheral clock
	RCC_D1CCIPR_FMCSEL_PLL2_R = 0x2
	// PER selected as peripheral clock
	RCC_D1CCIPR_FMCSEL_PER = 0x3
	// Position of OCTOSPISEL field.
	RCC_D1CCIPR_OCTOSPISEL_Pos = 0x4
	// Bit mask of OCTOSPISEL field.
	RCC_D1CCIPR_OCTOSPISEL_Msk = 0x30
	// rcc_hclk3 selected as peripheral clock
	RCC_D1CCIPR_OCTOSPISEL_RCC_HCLK3 = 0x0
	// pll1_q selected as peripheral clock
	RCC_D1CCIPR_OCTOSPISEL_PLL1_Q = 0x1
	// pll2_r selected as peripheral clock
	RCC_D1CCIPR_OCTOSPISEL_PLL2_R = 0x2
	// PER selected as peripheral clock
	RCC_D1CCIPR_OCTOSPISEL_PER = 0x3
	// Position of SDMMCSEL field.
	RCC_D1CCIPR_SDMMCSEL_Pos = 0x10
	// Bit mask of SDMMCSEL field.
	RCC_D1CCIPR_SDMMCSEL_Msk = 0x10000
	// Bit SDMMCSEL.
	RCC_D1CCIPR_SDMMCSEL = 0x10000
	// pll1_q selected as peripheral clock
	RCC_D1CCIPR_SDMMCSEL_PLL1_Q = 0x0
	// pll2_r selected as peripheral clock
	RCC_D1CCIPR_SDMMCSEL_PLL2_R = 0x1
	// Position of CKPERSEL field.
	RCC_D1CCIPR_CKPERSEL_Pos = 0x1c
	// Bit mask of CKPERSEL field.
	RCC_D1CCIPR_CKPERSEL_Msk = 0x30000000
	// HSI selected as peripheral clock
	RCC_D1CCIPR_CKPERSEL_HSI = 0x0
	// CSI selected as peripheral clock
	RCC_D1CCIPR_CKPERSEL_CSI = 0x1
	// HSE selected as peripheral clock
	RCC_D1CCIPR_CKPERSEL_HSE = 0x2

	// D2CCIP1R: RCC Domain 2 Kernel Clock Configuration Register
	// Position of SAI1SEL field.
	RCC_D2CCIP1R_SAI1SEL_Pos = 0x0
	// Bit mask of SAI1SEL field.
	RCC_D2CCIP1R_SAI1SEL_Msk = 0x7
	// pll1_q selected as peripheral clock
	RCC_D2CCIP1R_SAI1SEL_PLL1_Q = 0x0
	// pll2_p selected as peripheral clock
	RCC_D2CCIP1R_SAI1SEL_PLL2_P = 0x1
	// pll3_p selected as peripheral clock
	RCC_D2CCIP1R_SAI1SEL_PLL3_P = 0x2
	// I2S_CKIN selected as peripheral clock
	RCC_D2CCIP1R_SAI1SEL_I2S_CKIN = 0x3
	// PER selected as peripheral clock
	RCC_D2CCIP1R_SAI1SEL_PER = 0x4
	// Position of SPI123SEL field.
	RCC_D2CCIP1R_SPI123SEL_Pos = 0xc
	// Bit mask of SPI123SEL field.
	RCC_D2CCIP1R_SPI123SEL_Msk = 0x7000
	// pll1_q selected as peripheral clock
	RCC_D2CCIP1R_SPI123SEL_PLL1_Q = 0x0
	// pll2_p selected as peripheral clock
	RCC_D2CCIP1R_SPI123SEL_PLL2_P = 0x1
	// pll3_p selected as peripheral clock
	RCC_D2CCIP1R_SPI123SEL_PLL3_P = 0x2
	// I2S_CKIN selected as peripheral clock
	RCC_D2CCIP1R_SPI123SEL_I2S_CKIN = 0x3
	// PER selected as peripheral clock
	RCC_D2CCIP1R_SPI123SEL_PER = 0x4
	// Position of SPI45SEL field.
	RCC_D2CCIP1R_SPI45SEL_Pos = 0x10
	// Bit mask of SPI45SEL field.
	RCC_D2CCIP1R_SPI45SEL_Msk = 0x70000
	// APB clock selected as peripheral clock
	RCC_D2CCIP1R_SPI45SEL_APB = 0x0
	// pll2_q selected as peripheral clock
	RCC_D2CCIP1R_SPI45SEL_PLL2_Q = 0x1
	// pll3_q selected as peripheral clock
	RCC_D2CCIP1R_SPI45SEL_PLL3_Q = 0x2
	// hsi_ker selected as peripheral clock
	RCC_D2CCIP1R_SPI45SEL_HSI_KER = 0x3
	// csi_ker selected as peripheral clock
	RCC_D2CCIP1R_SPI45SEL_CSI_KER = 0x4
	// HSE selected as peripheral clock
	RCC_D2CCIP1R_SPI45SEL_HSE = 0x5
	// Position of SPDIFSEL field.
	RCC_D2CCIP1R_SPDIFSEL_Pos = 0x14
	// Bit mask of SPDIFSEL field.
	RCC_D2CCIP1R_SPDIFSEL_Msk = 0x300000
	// pll1_q selected as peripheral clock
	RCC_D2CCIP1R_SPDIFSEL_PLL1_Q = 0x0
	// pll2_r selected as peripheral clock
	RCC_D2CCIP1R_SPDIFSEL_PLL2_R = 0x1
	// pll3_r selected as peripheral clock
	RCC_D2CCIP1R_SPDIFSEL_PLL3_R = 0x2
	// hsi_ker selected as peripheral clock
	RCC_D2CCIP1R_SPDIFSEL_HSI_KER = 0x3
	// Position of DFSDM1SEL field.
	RCC_D2CCIP1R_DFSDM1SEL_Pos = 0x18
	// Bit mask of DFSDM1SEL field.
	RCC_D2CCIP1R_DFSDM1SEL_Msk = 0x1000000
	// Bit DFSDM1SEL.
	RCC_D2CCIP1R_DFSDM1SEL = 0x1000000
	// rcc_pclk2 selected as peripheral clock
	RCC_D2CCIP1R_DFSDM1SEL_RCC_PCLK2 = 0x0
	// System clock selected as peripheral clock
	RCC_D2CCIP1R_DFSDM1SEL_SYS = 0x1
	// Position of FDCANSEL field.
	RCC_D2CCIP1R_FDCANSEL_Pos = 0x1c
	// Bit mask of FDCANSEL field.
	RCC_D2CCIP1R_FDCANSEL_Msk = 0x30000000
	// HSE selected as peripheral clock
	RCC_D2CCIP1R_FDCANSEL_HSE = 0x0
	// pll1_q selected as peripheral clock
	RCC_D2CCIP1R_FDCANSEL_PLL1_Q = 0x1
	// pll2_q selected as peripheral clock
	RCC_D2CCIP1R_FDCANSEL_PLL2_Q = 0x2
	// Position of SWPMISEL field.
	RCC_D2CCIP1R_SWPMISEL_Pos = 0x1f
	// Bit mask of SWPMISEL field.
	RCC_D2CCIP1R_SWPMISEL_Msk = 0x80000000
	// Bit SWPMISEL.
	RCC_D2CCIP1R_SWPMISEL = 0x80000000
	// pclk selected as peripheral clock
	RCC_D2CCIP1R_SWPMISEL_PCLK = 0x0
	// hsi_ker selected as peripheral clock
	RCC_D2CCIP1R_SWPMISEL_HSI_KER = 0x1

	// D2CCIP2R: RCC Domain 2 Kernel Clock Configuration Register
	// Position of USART234578SEL field.
	RCC_D2CCIP2R_USART234578SEL_Pos = 0x0
	// Bit mask of USART234578SEL field.
	RCC_D2CCIP2R_USART234578SEL_Msk = 0x7
	// rcc_pclk1 selected as peripheral clock
	RCC_D2CCIP2R_USART234578SEL_RCC_PCLK1 = 0x0
	// pll2_q selected as peripheral clock
	RCC_D2CCIP2R_USART234578SEL_PLL2_Q = 0x1
	// pll3_q selected as peripheral clock
	RCC_D2CCIP2R_USART234578SEL_PLL3_Q = 0x2
	// hsi_ker selected as peripheral clock
	RCC_D2CCIP2R_USART234578SEL_HSI_KER = 0x3
	// csi_ker selected as peripheral clock
	RCC_D2CCIP2R_USART234578SEL_CSI_KER = 0x4
	// LSE selected as peripheral clock
	RCC_D2CCIP2R_USART234578SEL_LSE = 0x5
	// Position of USART16910SEL field.
	RCC_D2CCIP2R_USART16910SEL_Pos = 0x3
	// Bit mask of USART16910SEL field.
	RCC_D2CCIP2R_USART16910SEL_Msk = 0x38
	// rcc_pclk2 selected as peripheral clock
	RCC_D2CCIP2R_USART16910SEL_RCC_PCLK2 = 0x0
	// pll2_q selected as peripheral clock
	RCC_D2CCIP2R_USART16910SEL_PLL2_Q = 0x1
	// pll3_q selected as peripheral clock
	RCC_D2CCIP2R_USART16910SEL_PLL3_Q = 0x2
	// hsi_ker selected as peripheral clock
	RCC_D2CCIP2R_USART16910SEL_HSI_KER = 0x3
	// csi_ker selected as peripheral clock
	RCC_D2CCIP2R_USART16910SEL_CSI_KER = 0x4
	// LSE selected as peripheral clock
	RCC_D2CCIP2R_USART16910SEL_LSE = 0x5
	// Position of RNGSEL field.
	RCC_D2CCIP2R_RNGSEL_Pos = 0x8
	// Bit mask of RNGSEL field.
	RCC_D2CCIP2R_RNGSEL_Msk = 0x300
	// HSI48 selected as peripheral clock
	RCC_D2CCIP2R_RNGSEL_HSI48 = 0x0
	// pll1_q selected as peripheral clock
	RCC_D2CCIP2R_RNGSEL_PLL1_Q = 0x1
	// LSE selected as peripheral clock
	RCC_D2CCIP2R_RNGSEL_LSE = 0x2
	// LSI selected as peripheral clock
	RCC_D2CCIP2R_RNGSEL_LSI = 0x3
	// Position of I2C1235SEL field.
	RCC_D2CCIP2R_I2C1235SEL_Pos = 0xc
	// Bit mask of I2C1235SEL field.
	RCC_D2CCIP2R_I2C1235SEL_Msk = 0x3000
	// rcc_pclk1 selected as peripheral clock
	RCC_D2CCIP2R_I2C1235SEL_RCC_PCLK1 = 0x0
	// pll3_r selected as peripheral clock
	RCC_D2CCIP2R_I2C1235SEL_PLL3_R = 0x1
	// hsi_ker selected as peripheral clock
	RCC_D2CCIP2R_I2C1235SEL_HSI_KER = 0x2
	// csi_ker selected as peripheral clock
	RCC_D2CCIP2R_I2C1235SEL_CSI_KER = 0x3
	// Position of USBSEL field.
	RCC_D2CCIP2R_USBSEL_Pos = 0x14
	// Bit mask of USBSEL field.
	RCC_D2CCIP2R_USBSEL_Msk = 0x300000
	// Disable the kernel clock
	RCC_D2CCIP2R_USBSEL_DISABLE = 0x0
	// pll1_q selected as peripheral clock
	RCC_D2CCIP2R_USBSEL_PLL1_Q = 0x1
	// pll3_q selected as peripheral clock
	RCC_D2CCIP2R_USBSEL_PLL3_Q = 0x2
	// HSI48 selected as peripheral clock
	RCC_D2CCIP2R_USBSEL_HSI48 = 0x3
	// Position of CECSEL field.
	RCC_D2CCIP2R_CECSEL_Pos = 0x16
	// Bit mask of CECSEL field.
	RCC_D2CCIP2R_CECSEL_Msk = 0xc00000
	// LSE selected as peripheral clock
	RCC_D2CCIP2R_CECSEL_LSE = 0x0
	// LSI selected as peripheral clock
	RCC_D2CCIP2R_CECSEL_LSI = 0x1
	// csi_ker selected as peripheral clock
	RCC_D2CCIP2R_CECSEL_CSI_KER = 0x2
	// Position of LPTIM1SEL field.
	RCC_D2CCIP2R_LPTIM1SEL_Pos = 0x1c
	// Bit mask of LPTIM1SEL field.
	RCC_D2CCIP2R_LPTIM1SEL_Msk = 0x70000000
	// rcc_pclk1 selected as peripheral clock
	RCC_D2CCIP2R_LPTIM1SEL_RCC_PCLK1 = 0x0
	// pll2_p selected as peripheral clock
	RCC_D2CCIP2R_LPTIM1SEL_PLL2_P = 0x1
	// pll3_r selected as peripheral clock
	RCC_D2CCIP2R_LPTIM1SEL_PLL3_R = 0x2
	// LSE selected as peripheral clock
	RCC_D2CCIP2R_LPTIM1SEL_LSE = 0x3
	// LSI selected as peripheral clock
	RCC_D2CCIP2R_LPTIM1SEL_LSI = 0x4
	// PER selected as peripheral clock
	RCC_D2CCIP2R_LPTIM1SEL_PER = 0x5

	// D3CCIPR: RCC Domain 3 Kernel Clock Configuration Register
	// Position of LPUART1SEL field.
	RCC_D3CCIPR_LPUART1SEL_Pos = 0x0
	// Bit mask of LPUART1SEL field.
	RCC_D3CCIPR_LPUART1SEL_Msk = 0x7
	// rcc_pclk_d3 selected as peripheral clock
	RCC_D3CCIPR_LPUART1SEL_RCC_PCLK_D3 = 0x0
	// pll2_q selected as peripheral clock
	RCC_D3CCIPR_LPUART1SEL_PLL2_Q = 0x1
	// pll3_q selected as peripheral clock
	RCC_D3CCIPR_LPUART1SEL_PLL3_Q = 0x2
	// hsi_ker selected as peripheral clock
	RCC_D3CCIPR_LPUART1SEL_HSI_KER = 0x3
	// csi_ker selected as peripheral clock
	RCC_D3CCIPR_LPUART1SEL_CSI_KER = 0x4
	// LSE selected as peripheral clock
	RCC_D3CCIPR_LPUART1SEL_LSE = 0x5
	// Position of I2C4SEL field.
	RCC_D3CCIPR_I2C4SEL_Pos = 0x8
	// Bit mask of I2C4SEL field.
	RCC_D3CCIPR_I2C4SEL_Msk = 0x300
	// rcc_pclk4 selected as peripheral clock
	RCC_D3CCIPR_I2C4SEL_RCC_PCLK4 = 0x0
	// pll3_r selected as peripheral clock
	RCC_D3CCIPR_I2C4SEL_PLL3_R = 0x1
	// hsi_ker selected as peripheral clock
	RCC_D3CCIPR_I2C4SEL_HSI_KER = 0x2
	// csi_ker selected as peripheral clock
	RCC_D3CCIPR_I2C4SEL_CSI_KER = 0x3
	// Position of LPTIM2SEL field.
	RCC_D3CCIPR_LPTIM2SEL_Pos = 0xa
	// Bit mask of LPTIM2SEL field.
	RCC_D3CCIPR_LPTIM2SEL_Msk = 0x1c00
	// rcc_pclk4 selected as peripheral clock
	RCC_D3CCIPR_LPTIM2SEL_RCC_PCLK4 = 0x0
	// pll2_p selected as peripheral clock
	RCC_D3CCIPR_LPTIM2SEL_PLL2_P = 0x1
	// pll3_r selected as peripheral clock
	RCC_D3CCIPR_LPTIM2SEL_PLL3_R = 0x2
	// LSE selected as peripheral clock
	RCC_D3CCIPR_LPTIM2SEL_LSE = 0x3
	// LSI selected as peripheral clock
	RCC_D3CCIPR_LPTIM2SEL_LSI = 0x4
	// PER selected as peripheral clock
	RCC_D3CCIPR_LPTIM2SEL_PER = 0x5
	// Position of LPTIM345SEL field.
	RCC_D3CCIPR_LPTIM345SEL_Pos = 0xd
	// Bit mask of LPTIM345SEL field.
	RCC_D3CCIPR_LPTIM345SEL_Msk = 0xe000
	// rcc_pclk4 selected as peripheral clock
	RCC_D3CCIPR_LPTIM345SEL_RCC_PCLK4 = 0x0
	// pll2_p selected as peripheral clock
	RCC_D3CCIPR_LPTIM345SEL_PLL2_P = 0x1
	// pll3_r selected as peripheral clock
	RCC_D3CCIPR_LPTIM345SEL_PLL3_R = 0x2
	// LSE selected as peripheral clock
	RCC_D3CCIPR_LPTIM345SEL_LSE = 0x3
	// LSI selected as peripheral clock
	RCC_D3CCIPR_LPTIM345SEL_LSI = 0x4
	// PER selected as peripheral clock
	RCC_D3CCIPR_LPTIM345SEL_PER = 0x5
	// Position of ADCSEL field.
	RCC_D3CCIPR_ADCSEL_Pos = 0x10
	// Bit mask of ADCSEL field.
	RCC_D3CCIPR_ADCSEL_Msk = 0x30000
	// pll2_p selected as peripheral clock
	RCC_D3CCIPR_ADCSEL_PLL2_P = 0x0
	// pll3_r selected as peripheral clock
	RCC_D3CCIPR_ADCSEL_PLL3_R = 0x1
	// PER selected as peripheral clock
	RCC_D3CCIPR_ADCSEL_PER = 0x2
	// Position of SAI4ASEL field.
	RCC_D3CCIPR_SAI4ASEL_Pos = 0x15
	// Bit mask of SAI4ASEL field.
	RCC_D3CCIPR_SAI4ASEL_Msk = 0xe00000
	// pll1_q selected as peripheral clock
	RCC_D3CCIPR_SAI4ASEL_PLL1_Q = 0x0
	// pll2_p selected as peripheral clock
	RCC_D3CCIPR_SAI4ASEL_PLL2_P = 0x1
	// pll3_p selected as peripheral clock
	RCC_D3CCIPR_SAI4ASEL_PLL3_P = 0x2
	// i2s_ckin selected as peripheral clock
	RCC_D3CCIPR_SAI4ASEL_I2S_CKIN = 0x3
	// PER selected as peripheral clock
	RCC_D3CCIPR_SAI4ASEL_PER = 0x4
	// Position of SAI4BSEL field.
	RCC_D3CCIPR_SAI4BSEL_Pos = 0x18
	// Bit mask of SAI4BSEL field.
	RCC_D3CCIPR_SAI4BSEL_Msk = 0x7000000
	// pll1_q selected as peripheral clock
	RCC_D3CCIPR_SAI4BSEL_PLL1_Q = 0x0
	// pll2_p selected as peripheral clock
	RCC_D3CCIPR_SAI4BSEL_PLL2_P = 0x1
	// pll3_p selected as peripheral clock
	RCC_D3CCIPR_SAI4BSEL_PLL3_P = 0x2
	// i2s_ckin selected as peripheral clock
	RCC_D3CCIPR_SAI4BSEL_I2S_CKIN = 0x3
	// PER selected as peripheral clock
	RCC_D3CCIPR_SAI4BSEL_PER = 0x4
	// Position of SPI6SEL field.
	RCC_D3CCIPR_SPI6SEL_Pos = 0x1c
	// Bit mask of SPI6SEL field.
	RCC_D3CCIPR_SPI6SEL_Msk = 0x70000000
	// rcc_pclk4 selected as peripheral clock
	RCC_D3CCIPR_SPI6SEL_RCC_PCLK4 = 0x0
	// pll2_q selected as peripheral clock
	RCC_D3CCIPR_SPI6SEL_PLL2_Q = 0x1
	// pll3_q selected as peripheral clock
	RCC_D3CCIPR_SPI6SEL_PLL3_Q = 0x2
	// hsi_ker selected as peripheral clock
	RCC_D3CCIPR_SPI6SEL_HSI_KER = 0x3
	// csi_ker selected as peripheral clock
	RCC_D3CCIPR_SPI6SEL_CSI_KER = 0x4
	// HSE selected as peripheral clock
	RCC_D3CCIPR_SPI6SEL_HSE = 0x5

	// CIER: RCC Clock Source Interrupt Enable Register
	// Position of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Pos = 0x0
	// Bit mask of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Msk = 0x1
	// Bit LSIRDYIE.
	RCC_CIER_LSIRDYIE = 0x1
	// Interrupt disabled
	RCC_CIER_LSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_LSIRDYIE_Enabled = 0x1
	// Position of LSERDYIE field.
	RCC_CIER_LSERDYIE_Pos = 0x1
	// Bit mask of LSERDYIE field.
	RCC_CIER_LSERDYIE_Msk = 0x2
	// Bit LSERDYIE.
	RCC_CIER_LSERDYIE = 0x2
	// Interrupt disabled
	RCC_CIER_LSERDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_LSERDYIE_Enabled = 0x1
	// Position of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Pos = 0x2
	// Bit mask of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Msk = 0x4
	// Bit HSIRDYIE.
	RCC_CIER_HSIRDYIE = 0x4
	// Interrupt disabled
	RCC_CIER_HSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_HSIRDYIE_Enabled = 0x1
	// Position of HSERDYIE field.
	RCC_CIER_HSERDYIE_Pos = 0x3
	// Bit mask of HSERDYIE field.
	RCC_CIER_HSERDYIE_Msk = 0x8
	// Bit HSERDYIE.
	RCC_CIER_HSERDYIE = 0x8
	// Interrupt disabled
	RCC_CIER_HSERDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_HSERDYIE_Enabled = 0x1
	// Position of CSIRDYIE field.
	RCC_CIER_CSIRDYIE_Pos = 0x4
	// Bit mask of CSIRDYIE field.
	RCC_CIER_CSIRDYIE_Msk = 0x10
	// Bit CSIRDYIE.
	RCC_CIER_CSIRDYIE = 0x10
	// Interrupt disabled
	RCC_CIER_CSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_CSIRDYIE_Enabled = 0x1
	// Position of HSI48RDYIE field.
	RCC_CIER_HSI48RDYIE_Pos = 0x5
	// Bit mask of HSI48RDYIE field.
	RCC_CIER_HSI48RDYIE_Msk = 0x20
	// Bit HSI48RDYIE.
	RCC_CIER_HSI48RDYIE = 0x20
	// Interrupt disabled
	RCC_CIER_HSI48RDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_HSI48RDYIE_Enabled = 0x1
	// Position of PLL1RDYIE field.
	RCC_CIER_PLL1RDYIE_Pos = 0x6
	// Bit mask of PLL1RDYIE field.
	RCC_CIER_PLL1RDYIE_Msk = 0x40
	// Bit PLL1RDYIE.
	RCC_CIER_PLL1RDYIE = 0x40
	// Interrupt disabled
	RCC_CIER_PLL1RDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_PLL1RDYIE_Enabled = 0x1
	// Position of PLL2RDYIE field.
	RCC_CIER_PLL2RDYIE_Pos = 0x7
	// Bit mask of PLL2RDYIE field.
	RCC_CIER_PLL2RDYIE_Msk = 0x80
	// Bit PLL2RDYIE.
	RCC_CIER_PLL2RDYIE = 0x80
	// Interrupt disabled
	RCC_CIER_PLL2RDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_PLL2RDYIE_Enabled = 0x1
	// Position of PLL3RDYIE field.
	RCC_CIER_PLL3RDYIE_Pos = 0x8
	// Bit mask of PLL3RDYIE field.
	RCC_CIER_PLL3RDYIE_Msk = 0x100
	// Bit PLL3RDYIE.
	RCC_CIER_PLL3RDYIE = 0x100
	// Interrupt disabled
	RCC_CIER_PLL3RDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_PLL3RDYIE_Enabled = 0x1
	// Position of LSECSSIE field.
	RCC_CIER_LSECSSIE_Pos = 0x9
	// Bit mask of LSECSSIE field.
	RCC_CIER_LSECSSIE_Msk = 0x200
	// Bit LSECSSIE.
	RCC_CIER_LSECSSIE = 0x200
	// Interrupt disabled
	RCC_CIER_LSECSSIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIER_LSECSSIE_Enabled = 0x1

	// CIFR: RCC Clock Source Interrupt Flag Register
	// Position of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Pos = 0x0
	// Bit mask of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Msk = 0x1
	// Bit LSIRDYF.
	RCC_CIFR_LSIRDYF = 0x1
	// Position of LSERDYF field.
	RCC_CIFR_LSERDYF_Pos = 0x1
	// Bit mask of LSERDYF field.
	RCC_CIFR_LSERDYF_Msk = 0x2
	// Bit LSERDYF.
	RCC_CIFR_LSERDYF = 0x2
	// Position of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Pos = 0x2
	// Bit mask of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Msk = 0x4
	// Bit HSIRDYF.
	RCC_CIFR_HSIRDYF = 0x4
	// Position of HSERDYF field.
	RCC_CIFR_HSERDYF_Pos = 0x3
	// Bit mask of HSERDYF field.
	RCC_CIFR_HSERDYF_Msk = 0x8
	// Bit HSERDYF.
	RCC_CIFR_HSERDYF = 0x8
	// Position of CSIRDY field.
	RCC_CIFR_CSIRDY_Pos = 0x4
	// Bit mask of CSIRDY field.
	RCC_CIFR_CSIRDY_Msk = 0x10
	// Bit CSIRDY.
	RCC_CIFR_CSIRDY = 0x10
	// Position of HSI48RDYF field.
	RCC_CIFR_HSI48RDYF_Pos = 0x5
	// Bit mask of HSI48RDYF field.
	RCC_CIFR_HSI48RDYF_Msk = 0x20
	// Bit HSI48RDYF.
	RCC_CIFR_HSI48RDYF = 0x20
	// Position of PLL1RDYF field.
	RCC_CIFR_PLL1RDYF_Pos = 0x6
	// Bit mask of PLL1RDYF field.
	RCC_CIFR_PLL1RDYF_Msk = 0x40
	// Bit PLL1RDYF.
	RCC_CIFR_PLL1RDYF = 0x40
	// Position of PLL2RDYF field.
	RCC_CIFR_PLL2RDYF_Pos = 0x7
	// Bit mask of PLL2RDYF field.
	RCC_CIFR_PLL2RDYF_Msk = 0x80
	// Bit PLL2RDYF.
	RCC_CIFR_PLL2RDYF = 0x80
	// Position of PLL3RDYF field.
	RCC_CIFR_PLL3RDYF_Pos = 0x8
	// Bit mask of PLL3RDYF field.
	RCC_CIFR_PLL3RDYF_Msk = 0x100
	// Bit PLL3RDYF.
	RCC_CIFR_PLL3RDYF = 0x100
	// Position of LSECSSF field.
	RCC_CIFR_LSECSSF_Pos = 0x9
	// Bit mask of LSECSSF field.
	RCC_CIFR_LSECSSF_Msk = 0x200
	// Bit LSECSSF.
	RCC_CIFR_LSECSSF = 0x200
	// Position of HSECSSF field.
	RCC_CIFR_HSECSSF_Pos = 0xa
	// Bit mask of HSECSSF field.
	RCC_CIFR_HSECSSF_Msk = 0x400
	// Bit HSECSSF.
	RCC_CIFR_HSECSSF = 0x400

	// CICR: RCC Clock Source Interrupt Clear Register
	// Position of LSIRDYC field.
	RCC_CICR_LSIRDYC_Pos = 0x0
	// Bit mask of LSIRDYC field.
	RCC_CICR_LSIRDYC_Msk = 0x1
	// Bit LSIRDYC.
	RCC_CICR_LSIRDYC = 0x1
	// Clear interrupt flag
	RCC_CICR_LSIRDYC_Clear = 0x1
	// Position of LSERDYC field.
	RCC_CICR_LSERDYC_Pos = 0x1
	// Bit mask of LSERDYC field.
	RCC_CICR_LSERDYC_Msk = 0x2
	// Bit LSERDYC.
	RCC_CICR_LSERDYC = 0x2
	// Clear interrupt flag
	RCC_CICR_LSERDYC_Clear = 0x1
	// Position of HSIRDYC field.
	RCC_CICR_HSIRDYC_Pos = 0x2
	// Bit mask of HSIRDYC field.
	RCC_CICR_HSIRDYC_Msk = 0x4
	// Bit HSIRDYC.
	RCC_CICR_HSIRDYC = 0x4
	// Clear interrupt flag
	RCC_CICR_HSIRDYC_Clear = 0x1
	// Position of HSERDYC field.
	RCC_CICR_HSERDYC_Pos = 0x3
	// Bit mask of HSERDYC field.
	RCC_CICR_HSERDYC_Msk = 0x8
	// Bit HSERDYC.
	RCC_CICR_HSERDYC = 0x8
	// Clear interrupt flag
	RCC_CICR_HSERDYC_Clear = 0x1
	// Position of HSE_ready_Interrupt_Clear field.
	RCC_CICR_HSE_ready_Interrupt_Clear_Pos = 0x4
	// Bit mask of HSE_ready_Interrupt_Clear field.
	RCC_CICR_HSE_ready_Interrupt_Clear_Msk = 0x10
	// Bit HSE_ready_Interrupt_Clear.
	RCC_CICR_HSE_ready_Interrupt_Clear = 0x10
	// Position of HSI48RDYC field.
	RCC_CICR_HSI48RDYC_Pos = 0x5
	// Bit mask of HSI48RDYC field.
	RCC_CICR_HSI48RDYC_Msk = 0x20
	// Bit HSI48RDYC.
	RCC_CICR_HSI48RDYC = 0x20
	// Clear interrupt flag
	RCC_CICR_HSI48RDYC_Clear = 0x1
	// Position of PLL1RDYC field.
	RCC_CICR_PLL1RDYC_Pos = 0x6
	// Bit mask of PLL1RDYC field.
	RCC_CICR_PLL1RDYC_Msk = 0x40
	// Bit PLL1RDYC.
	RCC_CICR_PLL1RDYC = 0x40
	// Clear interrupt flag
	RCC_CICR_PLL1RDYC_Clear = 0x1
	// Position of PLL2RDYC field.
	RCC_CICR_PLL2RDYC_Pos = 0x7
	// Bit mask of PLL2RDYC field.
	RCC_CICR_PLL2RDYC_Msk = 0x80
	// Bit PLL2RDYC.
	RCC_CICR_PLL2RDYC = 0x80
	// Clear interrupt flag
	RCC_CICR_PLL2RDYC_Clear = 0x1
	// Position of PLL3RDYC field.
	RCC_CICR_PLL3RDYC_Pos = 0x8
	// Bit mask of PLL3RDYC field.
	RCC_CICR_PLL3RDYC_Msk = 0x100
	// Bit PLL3RDYC.
	RCC_CICR_PLL3RDYC = 0x100
	// Clear interrupt flag
	RCC_CICR_PLL3RDYC_Clear = 0x1
	// Position of LSECSSC field.
	RCC_CICR_LSECSSC_Pos = 0x9
	// Bit mask of LSECSSC field.
	RCC_CICR_LSECSSC_Msk = 0x200
	// Bit LSECSSC.
	RCC_CICR_LSECSSC = 0x200
	// Clear interrupt flag
	RCC_CICR_LSECSSC_Clear = 0x1
	// Position of HSECSSC field.
	RCC_CICR_HSECSSC_Pos = 0xa
	// Bit mask of HSECSSC field.
	RCC_CICR_HSECSSC_Msk = 0x400
	// Bit HSECSSC.
	RCC_CICR_HSECSSC = 0x400
	// Clear interrupt flag
	RCC_CICR_HSECSSC_Clear = 0x1

	// BDCR: RCC Backup Domain Control Register
	// Position of LSEON field.
	RCC_BDCR_LSEON_Pos = 0x0
	// Bit mask of LSEON field.
	RCC_BDCR_LSEON_Msk = 0x1
	// Bit LSEON.
	RCC_BDCR_LSEON = 0x1
	// LSE oscillator Off
	RCC_BDCR_LSEON_Off = 0x0
	// LSE oscillator On
	RCC_BDCR_LSEON_On = 0x1
	// Position of LSERDY field.
	RCC_BDCR_LSERDY_Pos = 0x1
	// Bit mask of LSERDY field.
	RCC_BDCR_LSERDY_Msk = 0x2
	// Bit LSERDY.
	RCC_BDCR_LSERDY = 0x2
	// LSE oscillator not ready
	RCC_BDCR_LSERDY_NotReady = 0x0
	// LSE oscillator ready
	RCC_BDCR_LSERDY_Ready = 0x1
	// Position of LSEBYP field.
	RCC_BDCR_LSEBYP_Pos = 0x2
	// Bit mask of LSEBYP field.
	RCC_BDCR_LSEBYP_Msk = 0x4
	// Bit LSEBYP.
	RCC_BDCR_LSEBYP = 0x4
	// LSE crystal oscillator not bypassed
	RCC_BDCR_LSEBYP_NotBypassed = 0x0
	// LSE crystal oscillator bypassed with external clock
	RCC_BDCR_LSEBYP_Bypassed = 0x1
	// Position of LSEDRV field.
	RCC_BDCR_LSEDRV_Pos = 0x3
	// Bit mask of LSEDRV field.
	RCC_BDCR_LSEDRV_Msk = 0x18
	// Lowest LSE oscillator driving capability
	RCC_BDCR_LSEDRV_Lowest = 0x0
	// Medium low LSE oscillator driving capability
	RCC_BDCR_LSEDRV_MediumLow = 0x1
	// Medium high LSE oscillator driving capability
	RCC_BDCR_LSEDRV_MediumHigh = 0x2
	// Highest LSE oscillator driving capability
	RCC_BDCR_LSEDRV_Highest = 0x3
	// Position of LSECSSON field.
	RCC_BDCR_LSECSSON_Pos = 0x5
	// Bit mask of LSECSSON field.
	RCC_BDCR_LSECSSON_Msk = 0x20
	// Bit LSECSSON.
	RCC_BDCR_LSECSSON = 0x20
	// Clock security system on 32 kHz oscillator off
	RCC_BDCR_LSECSSON_SecurityOff = 0x0
	// Clock security system on 32 kHz oscillator on
	RCC_BDCR_LSECSSON_SecurityOn = 0x1
	// Position of LSECSSD field.
	RCC_BDCR_LSECSSD_Pos = 0x6
	// Bit mask of LSECSSD field.
	RCC_BDCR_LSECSSD_Msk = 0x40
	// Bit LSECSSD.
	RCC_BDCR_LSECSSD = 0x40
	// No failure detected on 32 kHz oscillator
	RCC_BDCR_LSECSSD_NoFailure = 0x0
	// Failure detected on 32 kHz oscillator
	RCC_BDCR_LSECSSD_Failure = 0x1
	// Position of RTCSEL field.
	RCC_BDCR_RTCSEL_Pos = 0x8
	// Bit mask of RTCSEL field.
	RCC_BDCR_RTCSEL_Msk = 0x300
	// No clock
	RCC_BDCR_RTCSEL_NoClock = 0x0
	// LSE oscillator clock used as RTC clock
	RCC_BDCR_RTCSEL_LSE = 0x1
	// LSI oscillator clock used as RTC clock
	RCC_BDCR_RTCSEL_LSI = 0x2
	// HSE oscillator clock divided by a prescaler used as RTC clock
	RCC_BDCR_RTCSEL_HSE = 0x3
	// Position of RTCEN field.
	RCC_BDCR_RTCEN_Pos = 0xf
	// Bit mask of RTCEN field.
	RCC_BDCR_RTCEN_Msk = 0x8000
	// Bit RTCEN.
	RCC_BDCR_RTCEN = 0x8000
	// RTC clock disabled
	RCC_BDCR_RTCEN_Disabled = 0x0
	// RTC clock enabled
	RCC_BDCR_RTCEN_Enabled = 0x1
	// Position of BDRST field.
	RCC_BDCR_BDRST_Pos = 0x10
	// Bit mask of BDRST field.
	RCC_BDCR_BDRST_Msk = 0x10000
	// Bit BDRST.
	RCC_BDCR_BDRST = 0x10000
	// Resets the entire VSW domain
	RCC_BDCR_BDRST_Reset = 0x1

	// CSR: RCC Clock Control and Status Register
	// Position of LSION field.
	RCC_CSR_LSION_Pos = 0x0
	// Bit mask of LSION field.
	RCC_CSR_LSION_Msk = 0x1
	// Bit LSION.
	RCC_CSR_LSION = 0x1
	// LSI oscillator Off
	RCC_CSR_LSION_Off = 0x0
	// LSI oscillator On
	RCC_CSR_LSION_On = 0x1
	// Position of LSIRDY field.
	RCC_CSR_LSIRDY_Pos = 0x1
	// Bit mask of LSIRDY field.
	RCC_CSR_LSIRDY_Msk = 0x2
	// Bit LSIRDY.
	RCC_CSR_LSIRDY = 0x2
	// LSI oscillator not ready
	RCC_CSR_LSIRDY_NotReady = 0x0
	// LSI oscillator ready
	RCC_CSR_LSIRDY_Ready = 0x1

	// AHB3RSTR: RCC AHB3 Reset Register
	// Position of MDMARST field.
	RCC_AHB3RSTR_MDMARST_Pos = 0x0
	// Bit mask of MDMARST field.
	RCC_AHB3RSTR_MDMARST_Msk = 0x1
	// Bit MDMARST.
	RCC_AHB3RSTR_MDMARST = 0x1
	// Reset the selected module
	RCC_AHB3RSTR_MDMARST_Reset = 0x1
	// Position of DMA2DRST field.
	RCC_AHB3RSTR_DMA2DRST_Pos = 0x4
	// Bit mask of DMA2DRST field.
	RCC_AHB3RSTR_DMA2DRST_Msk = 0x10
	// Bit DMA2DRST.
	RCC_AHB3RSTR_DMA2DRST = 0x10
	// Reset the selected module
	RCC_AHB3RSTR_DMA2DRST_Reset = 0x1
	// Position of FMCRST field.
	RCC_AHB3RSTR_FMCRST_Pos = 0xc
	// Bit mask of FMCRST field.
	RCC_AHB3RSTR_FMCRST_Msk = 0x1000
	// Bit FMCRST.
	RCC_AHB3RSTR_FMCRST = 0x1000
	// Reset the selected module
	RCC_AHB3RSTR_FMCRST_Reset = 0x1
	// Position of SDMMC1RST field.
	RCC_AHB3RSTR_SDMMC1RST_Pos = 0x10
	// Bit mask of SDMMC1RST field.
	RCC_AHB3RSTR_SDMMC1RST_Msk = 0x10000
	// Bit SDMMC1RST.
	RCC_AHB3RSTR_SDMMC1RST = 0x10000
	// Reset the selected module
	RCC_AHB3RSTR_SDMMC1RST_Reset = 0x1
	// Position of CPURST field.
	RCC_AHB3RSTR_CPURST_Pos = 0x1f
	// Bit mask of CPURST field.
	RCC_AHB3RSTR_CPURST_Msk = 0x80000000
	// Bit CPURST.
	RCC_AHB3RSTR_CPURST = 0x80000000
	// Reset the selected module
	RCC_AHB3RSTR_CPURST_Reset = 0x1
	// Position of OCTOSPI1RST field.
	RCC_AHB3RSTR_OCTOSPI1RST_Pos = 0xe
	// Bit mask of OCTOSPI1RST field.
	RCC_AHB3RSTR_OCTOSPI1RST_Msk = 0x4000
	// Bit OCTOSPI1RST.
	RCC_AHB3RSTR_OCTOSPI1RST = 0x4000
	// Reset the selected module
	RCC_AHB3RSTR_OCTOSPI1RST_Reset = 0x1
	// Position of OCTOSPI2RST field.
	RCC_AHB3RSTR_OCTOSPI2RST_Pos = 0x13
	// Bit mask of OCTOSPI2RST field.
	RCC_AHB3RSTR_OCTOSPI2RST_Msk = 0x80000
	// Bit OCTOSPI2RST.
	RCC_AHB3RSTR_OCTOSPI2RST = 0x80000
	// Reset the selected module
	RCC_AHB3RSTR_OCTOSPI2RST_Reset = 0x1
	// Position of IOMNGRRST field.
	RCC_AHB3RSTR_IOMNGRRST_Pos = 0x15
	// Bit mask of IOMNGRRST field.
	RCC_AHB3RSTR_IOMNGRRST_Msk = 0x200000
	// Bit IOMNGRRST.
	RCC_AHB3RSTR_IOMNGRRST = 0x200000
	// Reset the selected module
	RCC_AHB3RSTR_IOMNGRRST_Reset = 0x1
	// Position of OTFD1RST field.
	RCC_AHB3RSTR_OTFD1RST_Pos = 0x16
	// Bit mask of OTFD1RST field.
	RCC_AHB3RSTR_OTFD1RST_Msk = 0x400000
	// Bit OTFD1RST.
	RCC_AHB3RSTR_OTFD1RST = 0x400000
	// Reset the selected module
	RCC_AHB3RSTR_OTFD1RST_Reset = 0x1
	// Position of OTFD2RST field.
	RCC_AHB3RSTR_OTFD2RST_Pos = 0x17
	// Bit mask of OTFD2RST field.
	RCC_AHB3RSTR_OTFD2RST_Msk = 0x800000
	// Bit OTFD2RST.
	RCC_AHB3RSTR_OTFD2RST = 0x800000
	// Reset the selected module
	RCC_AHB3RSTR_OTFD2RST_Reset = 0x1

	// AHB1RSTR: RCC AHB1 Peripheral Reset Register
	// Position of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Pos = 0x0
	// Bit mask of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Msk = 0x1
	// Bit DMA1RST.
	RCC_AHB1RSTR_DMA1RST = 0x1
	// Reset the selected module
	RCC_AHB1RSTR_DMA1RST_Reset = 0x1
	// Position of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Pos = 0x1
	// Bit mask of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Msk = 0x2
	// Bit DMA2RST.
	RCC_AHB1RSTR_DMA2RST = 0x2
	// Reset the selected module
	RCC_AHB1RSTR_DMA2RST_Reset = 0x1
	// Position of ADC12RST field.
	RCC_AHB1RSTR_ADC12RST_Pos = 0x5
	// Bit mask of ADC12RST field.
	RCC_AHB1RSTR_ADC12RST_Msk = 0x20
	// Bit ADC12RST.
	RCC_AHB1RSTR_ADC12RST = 0x20
	// Reset the selected module
	RCC_AHB1RSTR_ADC12RST_Reset = 0x1
	// Position of ETH1MACRST field.
	RCC_AHB1RSTR_ETH1MACRST_Pos = 0xf
	// Bit mask of ETH1MACRST field.
	RCC_AHB1RSTR_ETH1MACRST_Msk = 0x8000
	// Bit ETH1MACRST.
	RCC_AHB1RSTR_ETH1MACRST = 0x8000
	// Reset the selected module
	RCC_AHB1RSTR_ETH1MACRST_Reset = 0x1
	// Position of USB1OTGRST field.
	RCC_AHB1RSTR_USB1OTGRST_Pos = 0x19
	// Bit mask of USB1OTGRST field.
	RCC_AHB1RSTR_USB1OTGRST_Msk = 0x2000000
	// Bit USB1OTGRST.
	RCC_AHB1RSTR_USB1OTGRST = 0x2000000
	// Reset the selected module
	RCC_AHB1RSTR_USB1OTGRST_Reset = 0x1

	// AHB2RSTR: RCC AHB2 Peripheral Reset Register
	// Position of CAMITFRST field.
	RCC_AHB2RSTR_CAMITFRST_Pos = 0x0
	// Bit mask of CAMITFRST field.
	RCC_AHB2RSTR_CAMITFRST_Msk = 0x1
	// Bit CAMITFRST.
	RCC_AHB2RSTR_CAMITFRST = 0x1
	// Reset the selected module
	RCC_AHB2RSTR_CAMITFRST_Reset = 0x1
	// Position of CRYPTRST field.
	RCC_AHB2RSTR_CRYPTRST_Pos = 0x4
	// Bit mask of CRYPTRST field.
	RCC_AHB2RSTR_CRYPTRST_Msk = 0x10
	// Bit CRYPTRST.
	RCC_AHB2RSTR_CRYPTRST = 0x10
	// Reset the selected module
	RCC_AHB2RSTR_CRYPTRST_Reset = 0x1
	// Position of HASHRST field.
	RCC_AHB2RSTR_HASHRST_Pos = 0x5
	// Bit mask of HASHRST field.
	RCC_AHB2RSTR_HASHRST_Msk = 0x20
	// Bit HASHRST.
	RCC_AHB2RSTR_HASHRST = 0x20
	// Reset the selected module
	RCC_AHB2RSTR_HASHRST_Reset = 0x1
	// Position of RNGRST field.
	RCC_AHB2RSTR_RNGRST_Pos = 0x6
	// Bit mask of RNGRST field.
	RCC_AHB2RSTR_RNGRST_Msk = 0x40
	// Bit RNGRST.
	RCC_AHB2RSTR_RNGRST = 0x40
	// Reset the selected module
	RCC_AHB2RSTR_RNGRST_Reset = 0x1
	// Position of SDMMC2RST field.
	RCC_AHB2RSTR_SDMMC2RST_Pos = 0x9
	// Bit mask of SDMMC2RST field.
	RCC_AHB2RSTR_SDMMC2RST_Msk = 0x200
	// Bit SDMMC2RST.
	RCC_AHB2RSTR_SDMMC2RST = 0x200
	// Reset the selected module
	RCC_AHB2RSTR_SDMMC2RST_Reset = 0x1
	// Position of FMACRST field.
	RCC_AHB2RSTR_FMACRST_Pos = 0x10
	// Bit mask of FMACRST field.
	RCC_AHB2RSTR_FMACRST_Msk = 0x10000
	// Bit FMACRST.
	RCC_AHB2RSTR_FMACRST = 0x10000
	// Reset the selected module
	RCC_AHB2RSTR_FMACRST_Reset = 0x1
	// Position of CORDICRST field.
	RCC_AHB2RSTR_CORDICRST_Pos = 0x11
	// Bit mask of CORDICRST field.
	RCC_AHB2RSTR_CORDICRST_Msk = 0x20000
	// Bit CORDICRST.
	RCC_AHB2RSTR_CORDICRST = 0x20000
	// Reset the selected module
	RCC_AHB2RSTR_CORDICRST_Reset = 0x1

	// AHB4RSTR: RCC AHB4 Peripheral Reset Register
	// Position of GPIOARST field.
	RCC_AHB4RSTR_GPIOARST_Pos = 0x0
	// Bit mask of GPIOARST field.
	RCC_AHB4RSTR_GPIOARST_Msk = 0x1
	// Bit GPIOARST.
	RCC_AHB4RSTR_GPIOARST = 0x1
	// Reset the selected module
	RCC_AHB4RSTR_GPIOARST_Reset = 0x1
	// Position of GPIOBRST field.
	RCC_AHB4RSTR_GPIOBRST_Pos = 0x1
	// Bit mask of GPIOBRST field.
	RCC_AHB4RSTR_GPIOBRST_Msk = 0x2
	// Bit GPIOBRST.
	RCC_AHB4RSTR_GPIOBRST = 0x2
	// Reset the selected module
	RCC_AHB4RSTR_GPIOBRST_Reset = 0x1
	// Position of GPIOCRST field.
	RCC_AHB4RSTR_GPIOCRST_Pos = 0x2
	// Bit mask of GPIOCRST field.
	RCC_AHB4RSTR_GPIOCRST_Msk = 0x4
	// Bit GPIOCRST.
	RCC_AHB4RSTR_GPIOCRST = 0x4
	// Reset the selected module
	RCC_AHB4RSTR_GPIOCRST_Reset = 0x1
	// Position of GPIODRST field.
	RCC_AHB4RSTR_GPIODRST_Pos = 0x3
	// Bit mask of GPIODRST field.
	RCC_AHB4RSTR_GPIODRST_Msk = 0x8
	// Bit GPIODRST.
	RCC_AHB4RSTR_GPIODRST = 0x8
	// Reset the selected module
	RCC_AHB4RSTR_GPIODRST_Reset = 0x1
	// Position of GPIOERST field.
	RCC_AHB4RSTR_GPIOERST_Pos = 0x4
	// Bit mask of GPIOERST field.
	RCC_AHB4RSTR_GPIOERST_Msk = 0x10
	// Bit GPIOERST.
	RCC_AHB4RSTR_GPIOERST = 0x10
	// Reset the selected module
	RCC_AHB4RSTR_GPIOERST_Reset = 0x1
	// Position of GPIOFRST field.
	RCC_AHB4RSTR_GPIOFRST_Pos = 0x5
	// Bit mask of GPIOFRST field.
	RCC_AHB4RSTR_GPIOFRST_Msk = 0x20
	// Bit GPIOFRST.
	RCC_AHB4RSTR_GPIOFRST = 0x20
	// Reset the selected module
	RCC_AHB4RSTR_GPIOFRST_Reset = 0x1
	// Position of GPIOGRST field.
	RCC_AHB4RSTR_GPIOGRST_Pos = 0x6
	// Bit mask of GPIOGRST field.
	RCC_AHB4RSTR_GPIOGRST_Msk = 0x40
	// Bit GPIOGRST.
	RCC_AHB4RSTR_GPIOGRST = 0x40
	// Reset the selected module
	RCC_AHB4RSTR_GPIOGRST_Reset = 0x1
	// Position of GPIOHRST field.
	RCC_AHB4RSTR_GPIOHRST_Pos = 0x7
	// Bit mask of GPIOHRST field.
	RCC_AHB4RSTR_GPIOHRST_Msk = 0x80
	// Bit GPIOHRST.
	RCC_AHB4RSTR_GPIOHRST = 0x80
	// Reset the selected module
	RCC_AHB4RSTR_GPIOHRST_Reset = 0x1
	// Position of GPIOIRST field.
	RCC_AHB4RSTR_GPIOIRST_Pos = 0x8
	// Bit mask of GPIOIRST field.
	RCC_AHB4RSTR_GPIOIRST_Msk = 0x100
	// Bit GPIOIRST.
	RCC_AHB4RSTR_GPIOIRST = 0x100
	// Reset the selected module
	RCC_AHB4RSTR_GPIOIRST_Reset = 0x1
	// Position of GPIOJRST field.
	RCC_AHB4RSTR_GPIOJRST_Pos = 0x9
	// Bit mask of GPIOJRST field.
	RCC_AHB4RSTR_GPIOJRST_Msk = 0x200
	// Bit GPIOJRST.
	RCC_AHB4RSTR_GPIOJRST = 0x200
	// Reset the selected module
	RCC_AHB4RSTR_GPIOJRST_Reset = 0x1
	// Position of GPIOKRST field.
	RCC_AHB4RSTR_GPIOKRST_Pos = 0xa
	// Bit mask of GPIOKRST field.
	RCC_AHB4RSTR_GPIOKRST_Msk = 0x400
	// Bit GPIOKRST.
	RCC_AHB4RSTR_GPIOKRST = 0x400
	// Reset the selected module
	RCC_AHB4RSTR_GPIOKRST_Reset = 0x1
	// Position of CRCRST field.
	RCC_AHB4RSTR_CRCRST_Pos = 0x13
	// Bit mask of CRCRST field.
	RCC_AHB4RSTR_CRCRST_Msk = 0x80000
	// Bit CRCRST.
	RCC_AHB4RSTR_CRCRST = 0x80000
	// Reset the selected module
	RCC_AHB4RSTR_CRCRST_Reset = 0x1
	// Position of BDMARST field.
	RCC_AHB4RSTR_BDMARST_Pos = 0x15
	// Bit mask of BDMARST field.
	RCC_AHB4RSTR_BDMARST_Msk = 0x200000
	// Bit BDMARST.
	RCC_AHB4RSTR_BDMARST = 0x200000
	// Reset the selected module
	RCC_AHB4RSTR_BDMARST_Reset = 0x1
	// Position of ADC3RST field.
	RCC_AHB4RSTR_ADC3RST_Pos = 0x18
	// Bit mask of ADC3RST field.
	RCC_AHB4RSTR_ADC3RST_Msk = 0x1000000
	// Bit ADC3RST.
	RCC_AHB4RSTR_ADC3RST = 0x1000000
	// Reset the selected module
	RCC_AHB4RSTR_ADC3RST_Reset = 0x1
	// Position of HSEMRST field.
	RCC_AHB4RSTR_HSEMRST_Pos = 0x19
	// Bit mask of HSEMRST field.
	RCC_AHB4RSTR_HSEMRST_Msk = 0x2000000
	// Bit HSEMRST.
	RCC_AHB4RSTR_HSEMRST = 0x2000000
	// Reset the selected module
	RCC_AHB4RSTR_HSEMRST_Reset = 0x1

	// APB3RSTR: RCC APB3 Peripheral Reset Register
	// Position of LTDCRST field.
	RCC_APB3RSTR_LTDCRST_Pos = 0x3
	// Bit mask of LTDCRST field.
	RCC_APB3RSTR_LTDCRST_Msk = 0x8
	// Bit LTDCRST.
	RCC_APB3RSTR_LTDCRST = 0x8
	// Reset the selected module
	RCC_APB3RSTR_LTDCRST_Reset = 0x1

	// APB1LRSTR: RCC APB1 Peripheral Reset Register
	// Position of TIM2RST field.
	RCC_APB1LRSTR_TIM2RST_Pos = 0x0
	// Bit mask of TIM2RST field.
	RCC_APB1LRSTR_TIM2RST_Msk = 0x1
	// Bit TIM2RST.
	RCC_APB1LRSTR_TIM2RST = 0x1
	// Reset the selected module
	RCC_APB1LRSTR_TIM2RST_Reset = 0x1
	// Position of TIM3RST field.
	RCC_APB1LRSTR_TIM3RST_Pos = 0x1
	// Bit mask of TIM3RST field.
	RCC_APB1LRSTR_TIM3RST_Msk = 0x2
	// Bit TIM3RST.
	RCC_APB1LRSTR_TIM3RST = 0x2
	// Reset the selected module
	RCC_APB1LRSTR_TIM3RST_Reset = 0x1
	// Position of TIM4RST field.
	RCC_APB1LRSTR_TIM4RST_Pos = 0x2
	// Bit mask of TIM4RST field.
	RCC_APB1LRSTR_TIM4RST_Msk = 0x4
	// Bit TIM4RST.
	RCC_APB1LRSTR_TIM4RST = 0x4
	// Reset the selected module
	RCC_APB1LRSTR_TIM4RST_Reset = 0x1
	// Position of TIM5RST field.
	RCC_APB1LRSTR_TIM5RST_Pos = 0x3
	// Bit mask of TIM5RST field.
	RCC_APB1LRSTR_TIM5RST_Msk = 0x8
	// Bit TIM5RST.
	RCC_APB1LRSTR_TIM5RST = 0x8
	// Reset the selected module
	RCC_APB1LRSTR_TIM5RST_Reset = 0x1
	// Position of TIM6RST field.
	RCC_APB1LRSTR_TIM6RST_Pos = 0x4
	// Bit mask of TIM6RST field.
	RCC_APB1LRSTR_TIM6RST_Msk = 0x10
	// Bit TIM6RST.
	RCC_APB1LRSTR_TIM6RST = 0x10
	// Reset the selected module
	RCC_APB1LRSTR_TIM6RST_Reset = 0x1
	// Position of TIM7RST field.
	RCC_APB1LRSTR_TIM7RST_Pos = 0x5
	// Bit mask of TIM7RST field.
	RCC_APB1LRSTR_TIM7RST_Msk = 0x20
	// Bit TIM7RST.
	RCC_APB1LRSTR_TIM7RST = 0x20
	// Reset the selected module
	RCC_APB1LRSTR_TIM7RST_Reset = 0x1
	// Position of TIM12RST field.
	RCC_APB1LRSTR_TIM12RST_Pos = 0x6
	// Bit mask of TIM12RST field.
	RCC_APB1LRSTR_TIM12RST_Msk = 0x40
	// Bit TIM12RST.
	RCC_APB1LRSTR_TIM12RST = 0x40
	// Reset the selected module
	RCC_APB1LRSTR_TIM12RST_Reset = 0x1
	// Position of TIM13RST field.
	RCC_APB1LRSTR_TIM13RST_Pos = 0x7
	// Bit mask of TIM13RST field.
	RCC_APB1LRSTR_TIM13RST_Msk = 0x80
	// Bit TIM13RST.
	RCC_APB1LRSTR_TIM13RST = 0x80
	// Reset the selected module
	RCC_APB1LRSTR_TIM13RST_Reset = 0x1
	// Position of TIM14RST field.
	RCC_APB1LRSTR_TIM14RST_Pos = 0x8
	// Bit mask of TIM14RST field.
	RCC_APB1LRSTR_TIM14RST_Msk = 0x100
	// Bit TIM14RST.
	RCC_APB1LRSTR_TIM14RST = 0x100
	// Reset the selected module
	RCC_APB1LRSTR_TIM14RST_Reset = 0x1
	// Position of LPTIM1RST field.
	RCC_APB1LRSTR_LPTIM1RST_Pos = 0x9
	// Bit mask of LPTIM1RST field.
	RCC_APB1LRSTR_LPTIM1RST_Msk = 0x200
	// Bit LPTIM1RST.
	RCC_APB1LRSTR_LPTIM1RST = 0x200
	// Reset the selected module
	RCC_APB1LRSTR_LPTIM1RST_Reset = 0x1
	// Position of SPI2RST field.
	RCC_APB1LRSTR_SPI2RST_Pos = 0xe
	// Bit mask of SPI2RST field.
	RCC_APB1LRSTR_SPI2RST_Msk = 0x4000
	// Bit SPI2RST.
	RCC_APB1LRSTR_SPI2RST = 0x4000
	// Reset the selected module
	RCC_APB1LRSTR_SPI2RST_Reset = 0x1
	// Position of SPI3RST field.
	RCC_APB1LRSTR_SPI3RST_Pos = 0xf
	// Bit mask of SPI3RST field.
	RCC_APB1LRSTR_SPI3RST_Msk = 0x8000
	// Bit SPI3RST.
	RCC_APB1LRSTR_SPI3RST = 0x8000
	// Reset the selected module
	RCC_APB1LRSTR_SPI3RST_Reset = 0x1
	// Position of SPDIFRXRST field.
	RCC_APB1LRSTR_SPDIFRXRST_Pos = 0x10
	// Bit mask of SPDIFRXRST field.
	RCC_APB1LRSTR_SPDIFRXRST_Msk = 0x10000
	// Bit SPDIFRXRST.
	RCC_APB1LRSTR_SPDIFRXRST = 0x10000
	// Reset the selected module
	RCC_APB1LRSTR_SPDIFRXRST_Reset = 0x1
	// Position of USART2RST field.
	RCC_APB1LRSTR_USART2RST_Pos = 0x11
	// Bit mask of USART2RST field.
	RCC_APB1LRSTR_USART2RST_Msk = 0x20000
	// Bit USART2RST.
	RCC_APB1LRSTR_USART2RST = 0x20000
	// Reset the selected module
	RCC_APB1LRSTR_USART2RST_Reset = 0x1
	// Position of USART3RST field.
	RCC_APB1LRSTR_USART3RST_Pos = 0x12
	// Bit mask of USART3RST field.
	RCC_APB1LRSTR_USART3RST_Msk = 0x40000
	// Bit USART3RST.
	RCC_APB1LRSTR_USART3RST = 0x40000
	// Reset the selected module
	RCC_APB1LRSTR_USART3RST_Reset = 0x1
	// Position of UART4RST field.
	RCC_APB1LRSTR_UART4RST_Pos = 0x13
	// Bit mask of UART4RST field.
	RCC_APB1LRSTR_UART4RST_Msk = 0x80000
	// Bit UART4RST.
	RCC_APB1LRSTR_UART4RST = 0x80000
	// Reset the selected module
	RCC_APB1LRSTR_UART4RST_Reset = 0x1
	// Position of UART5RST field.
	RCC_APB1LRSTR_UART5RST_Pos = 0x14
	// Bit mask of UART5RST field.
	RCC_APB1LRSTR_UART5RST_Msk = 0x100000
	// Bit UART5RST.
	RCC_APB1LRSTR_UART5RST = 0x100000
	// Reset the selected module
	RCC_APB1LRSTR_UART5RST_Reset = 0x1
	// Position of I2C1RST field.
	RCC_APB1LRSTR_I2C1RST_Pos = 0x15
	// Bit mask of I2C1RST field.
	RCC_APB1LRSTR_I2C1RST_Msk = 0x200000
	// Bit I2C1RST.
	RCC_APB1LRSTR_I2C1RST = 0x200000
	// Reset the selected module
	RCC_APB1LRSTR_I2C1RST_Reset = 0x1
	// Position of I2C2RST field.
	RCC_APB1LRSTR_I2C2RST_Pos = 0x16
	// Bit mask of I2C2RST field.
	RCC_APB1LRSTR_I2C2RST_Msk = 0x400000
	// Bit I2C2RST.
	RCC_APB1LRSTR_I2C2RST = 0x400000
	// Reset the selected module
	RCC_APB1LRSTR_I2C2RST_Reset = 0x1
	// Position of I2C3RST field.
	RCC_APB1LRSTR_I2C3RST_Pos = 0x17
	// Bit mask of I2C3RST field.
	RCC_APB1LRSTR_I2C3RST_Msk = 0x800000
	// Bit I2C3RST.
	RCC_APB1LRSTR_I2C3RST = 0x800000
	// Reset the selected module
	RCC_APB1LRSTR_I2C3RST_Reset = 0x1
	// Position of CECRST field.
	RCC_APB1LRSTR_CECRST_Pos = 0x1b
	// Bit mask of CECRST field.
	RCC_APB1LRSTR_CECRST_Msk = 0x8000000
	// Bit CECRST.
	RCC_APB1LRSTR_CECRST = 0x8000000
	// Reset the selected module
	RCC_APB1LRSTR_CECRST_Reset = 0x1
	// Position of DAC12RST field.
	RCC_APB1LRSTR_DAC12RST_Pos = 0x1d
	// Bit mask of DAC12RST field.
	RCC_APB1LRSTR_DAC12RST_Msk = 0x20000000
	// Bit DAC12RST.
	RCC_APB1LRSTR_DAC12RST = 0x20000000
	// Reset the selected module
	RCC_APB1LRSTR_DAC12RST_Reset = 0x1
	// Position of UART7RST field.
	RCC_APB1LRSTR_UART7RST_Pos = 0x1e
	// Bit mask of UART7RST field.
	RCC_APB1LRSTR_UART7RST_Msk = 0x40000000
	// Bit UART7RST.
	RCC_APB1LRSTR_UART7RST = 0x40000000
	// Reset the selected module
	RCC_APB1LRSTR_UART7RST_Reset = 0x1
	// Position of UART8RST field.
	RCC_APB1LRSTR_UART8RST_Pos = 0x1f
	// Bit mask of UART8RST field.
	RCC_APB1LRSTR_UART8RST_Msk = 0x80000000
	// Bit UART8RST.
	RCC_APB1LRSTR_UART8RST = 0x80000000
	// Reset the selected module
	RCC_APB1LRSTR_UART8RST_Reset = 0x1
	// Position of I2C5RST field.
	RCC_APB1LRSTR_I2C5RST_Pos = 0x19
	// Bit mask of I2C5RST field.
	RCC_APB1LRSTR_I2C5RST_Msk = 0x2000000
	// Bit I2C5RST.
	RCC_APB1LRSTR_I2C5RST = 0x2000000
	// Reset the selected module
	RCC_APB1LRSTR_I2C5RST_Reset = 0x1

	// APB1HRSTR: RCC APB1 Peripheral Reset Register
	// Position of CRSRST field.
	RCC_APB1HRSTR_CRSRST_Pos = 0x1
	// Bit mask of CRSRST field.
	RCC_APB1HRSTR_CRSRST_Msk = 0x2
	// Bit CRSRST.
	RCC_APB1HRSTR_CRSRST = 0x2
	// Reset the selected module
	RCC_APB1HRSTR_CRSRST_Reset = 0x1
	// Position of SWPMIRST field.
	RCC_APB1HRSTR_SWPMIRST_Pos = 0x2
	// Bit mask of SWPMIRST field.
	RCC_APB1HRSTR_SWPMIRST_Msk = 0x4
	// Bit SWPMIRST.
	RCC_APB1HRSTR_SWPMIRST = 0x4
	// Reset the selected module
	RCC_APB1HRSTR_SWPMIRST_Reset = 0x1
	// Position of OPAMPRST field.
	RCC_APB1HRSTR_OPAMPRST_Pos = 0x4
	// Bit mask of OPAMPRST field.
	RCC_APB1HRSTR_OPAMPRST_Msk = 0x10
	// Bit OPAMPRST.
	RCC_APB1HRSTR_OPAMPRST = 0x10
	// Reset the selected module
	RCC_APB1HRSTR_OPAMPRST_Reset = 0x1
	// Position of MDIOSRST field.
	RCC_APB1HRSTR_MDIOSRST_Pos = 0x5
	// Bit mask of MDIOSRST field.
	RCC_APB1HRSTR_MDIOSRST_Msk = 0x20
	// Bit MDIOSRST.
	RCC_APB1HRSTR_MDIOSRST = 0x20
	// Reset the selected module
	RCC_APB1HRSTR_MDIOSRST_Reset = 0x1
	// Position of FDCANRST field.
	RCC_APB1HRSTR_FDCANRST_Pos = 0x8
	// Bit mask of FDCANRST field.
	RCC_APB1HRSTR_FDCANRST_Msk = 0x100
	// Bit FDCANRST.
	RCC_APB1HRSTR_FDCANRST = 0x100
	// Reset the selected module
	RCC_APB1HRSTR_FDCANRST_Reset = 0x1
	// Position of TIM23RST field.
	RCC_APB1HRSTR_TIM23RST_Pos = 0x18
	// Bit mask of TIM23RST field.
	RCC_APB1HRSTR_TIM23RST_Msk = 0x1000000
	// Bit TIM23RST.
	RCC_APB1HRSTR_TIM23RST = 0x1000000
	// Reset the selected module
	RCC_APB1HRSTR_TIM23RST_Reset = 0x1
	// Position of TIM24RST field.
	RCC_APB1HRSTR_TIM24RST_Pos = 0x19
	// Bit mask of TIM24RST field.
	RCC_APB1HRSTR_TIM24RST_Msk = 0x2000000
	// Bit TIM24RST.
	RCC_APB1HRSTR_TIM24RST = 0x2000000
	// Reset the selected module
	RCC_APB1HRSTR_TIM24RST_Reset = 0x1

	// APB2RSTR: RCC APB2 Peripheral Reset Register
	// Position of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Pos = 0x0
	// Bit mask of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Msk = 0x1
	// Bit TIM1RST.
	RCC_APB2RSTR_TIM1RST = 0x1
	// Reset the selected module
	RCC_APB2RSTR_TIM1RST_Reset = 0x1
	// Position of TIM8RST field.
	RCC_APB2RSTR_TIM8RST_Pos = 0x1
	// Bit mask of TIM8RST field.
	RCC_APB2RSTR_TIM8RST_Msk = 0x2
	// Bit TIM8RST.
	RCC_APB2RSTR_TIM8RST = 0x2
	// Reset the selected module
	RCC_APB2RSTR_TIM8RST_Reset = 0x1
	// Position of USART1RST field.
	RCC_APB2RSTR_USART1RST_Pos = 0x4
	// Bit mask of USART1RST field.
	RCC_APB2RSTR_USART1RST_Msk = 0x10
	// Bit USART1RST.
	RCC_APB2RSTR_USART1RST = 0x10
	// Reset the selected module
	RCC_APB2RSTR_USART1RST_Reset = 0x1
	// Position of USART6RST field.
	RCC_APB2RSTR_USART6RST_Pos = 0x5
	// Bit mask of USART6RST field.
	RCC_APB2RSTR_USART6RST_Msk = 0x20
	// Bit USART6RST.
	RCC_APB2RSTR_USART6RST = 0x20
	// Reset the selected module
	RCC_APB2RSTR_USART6RST_Reset = 0x1
	// Position of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Pos = 0xc
	// Bit mask of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Msk = 0x1000
	// Bit SPI1RST.
	RCC_APB2RSTR_SPI1RST = 0x1000
	// Reset the selected module
	RCC_APB2RSTR_SPI1RST_Reset = 0x1
	// Position of SPI4RST field.
	RCC_APB2RSTR_SPI4RST_Pos = 0xd
	// Bit mask of SPI4RST field.
	RCC_APB2RSTR_SPI4RST_Msk = 0x2000
	// Bit SPI4RST.
	RCC_APB2RSTR_SPI4RST = 0x2000
	// Reset the selected module
	RCC_APB2RSTR_SPI4RST_Reset = 0x1
	// Position of TIM15RST field.
	RCC_APB2RSTR_TIM15RST_Pos = 0x10
	// Bit mask of TIM15RST field.
	RCC_APB2RSTR_TIM15RST_Msk = 0x10000
	// Bit TIM15RST.
	RCC_APB2RSTR_TIM15RST = 0x10000
	// Reset the selected module
	RCC_APB2RSTR_TIM15RST_Reset = 0x1
	// Position of TIM16RST field.
	RCC_APB2RSTR_TIM16RST_Pos = 0x11
	// Bit mask of TIM16RST field.
	RCC_APB2RSTR_TIM16RST_Msk = 0x20000
	// Bit TIM16RST.
	RCC_APB2RSTR_TIM16RST = 0x20000
	// Reset the selected module
	RCC_APB2RSTR_TIM16RST_Reset = 0x1
	// Position of TIM17RST field.
	RCC_APB2RSTR_TIM17RST_Pos = 0x12
	// Bit mask of TIM17RST field.
	RCC_APB2RSTR_TIM17RST_Msk = 0x40000
	// Bit TIM17RST.
	RCC_APB2RSTR_TIM17RST = 0x40000
	// Reset the selected module
	RCC_APB2RSTR_TIM17RST_Reset = 0x1
	// Position of SPI5RST field.
	RCC_APB2RSTR_SPI5RST_Pos = 0x14
	// Bit mask of SPI5RST field.
	RCC_APB2RSTR_SPI5RST_Msk = 0x100000
	// Bit SPI5RST.
	RCC_APB2RSTR_SPI5RST = 0x100000
	// Reset the selected module
	RCC_APB2RSTR_SPI5RST_Reset = 0x1
	// Position of SAI1RST field.
	RCC_APB2RSTR_SAI1RST_Pos = 0x16
	// Bit mask of SAI1RST field.
	RCC_APB2RSTR_SAI1RST_Msk = 0x400000
	// Bit SAI1RST.
	RCC_APB2RSTR_SAI1RST = 0x400000
	// Reset the selected module
	RCC_APB2RSTR_SAI1RST_Reset = 0x1
	// Position of SAI2RST field.
	RCC_APB2RSTR_SAI2RST_Pos = 0x17
	// Bit mask of SAI2RST field.
	RCC_APB2RSTR_SAI2RST_Msk = 0x800000
	// Bit SAI2RST.
	RCC_APB2RSTR_SAI2RST = 0x800000
	// Reset the selected module
	RCC_APB2RSTR_SAI2RST_Reset = 0x1
	// Position of SAI3RST field.
	RCC_APB2RSTR_SAI3RST_Pos = 0x18
	// Bit mask of SAI3RST field.
	RCC_APB2RSTR_SAI3RST_Msk = 0x1000000
	// Bit SAI3RST.
	RCC_APB2RSTR_SAI3RST = 0x1000000
	// Reset the selected module
	RCC_APB2RSTR_SAI3RST_Reset = 0x1
	// Position of DFSDM1RST field.
	RCC_APB2RSTR_DFSDM1RST_Pos = 0x1c
	// Bit mask of DFSDM1RST field.
	RCC_APB2RSTR_DFSDM1RST_Msk = 0x10000000
	// Bit DFSDM1RST.
	RCC_APB2RSTR_DFSDM1RST = 0x10000000
	// Reset the selected module
	RCC_APB2RSTR_DFSDM1RST_Reset = 0x1

	// APB4RSTR: RCC APB4 Peripheral Reset Register
	// Position of SYSCFGRST field.
	RCC_APB4RSTR_SYSCFGRST_Pos = 0x1
	// Bit mask of SYSCFGRST field.
	RCC_APB4RSTR_SYSCFGRST_Msk = 0x2
	// Bit SYSCFGRST.
	RCC_APB4RSTR_SYSCFGRST = 0x2
	// Reset the selected module
	RCC_APB4RSTR_SYSCFGRST_Reset = 0x1
	// Position of LPUART1RST field.
	RCC_APB4RSTR_LPUART1RST_Pos = 0x3
	// Bit mask of LPUART1RST field.
	RCC_APB4RSTR_LPUART1RST_Msk = 0x8
	// Bit LPUART1RST.
	RCC_APB4RSTR_LPUART1RST = 0x8
	// Reset the selected module
	RCC_APB4RSTR_LPUART1RST_Reset = 0x1
	// Position of SPI6RST field.
	RCC_APB4RSTR_SPI6RST_Pos = 0x5
	// Bit mask of SPI6RST field.
	RCC_APB4RSTR_SPI6RST_Msk = 0x20
	// Bit SPI6RST.
	RCC_APB4RSTR_SPI6RST = 0x20
	// Reset the selected module
	RCC_APB4RSTR_SPI6RST_Reset = 0x1
	// Position of I2C4RST field.
	RCC_APB4RSTR_I2C4RST_Pos = 0x7
	// Bit mask of I2C4RST field.
	RCC_APB4RSTR_I2C4RST_Msk = 0x80
	// Bit I2C4RST.
	RCC_APB4RSTR_I2C4RST = 0x80
	// Reset the selected module
	RCC_APB4RSTR_I2C4RST_Reset = 0x1
	// Position of LPTIM2RST field.
	RCC_APB4RSTR_LPTIM2RST_Pos = 0x9
	// Bit mask of LPTIM2RST field.
	RCC_APB4RSTR_LPTIM2RST_Msk = 0x200
	// Bit LPTIM2RST.
	RCC_APB4RSTR_LPTIM2RST = 0x200
	// Reset the selected module
	RCC_APB4RSTR_LPTIM2RST_Reset = 0x1
	// Position of LPTIM3RST field.
	RCC_APB4RSTR_LPTIM3RST_Pos = 0xa
	// Bit mask of LPTIM3RST field.
	RCC_APB4RSTR_LPTIM3RST_Msk = 0x400
	// Bit LPTIM3RST.
	RCC_APB4RSTR_LPTIM3RST = 0x400
	// Reset the selected module
	RCC_APB4RSTR_LPTIM3RST_Reset = 0x1
	// Position of LPTIM4RST field.
	RCC_APB4RSTR_LPTIM4RST_Pos = 0xb
	// Bit mask of LPTIM4RST field.
	RCC_APB4RSTR_LPTIM4RST_Msk = 0x800
	// Bit LPTIM4RST.
	RCC_APB4RSTR_LPTIM4RST = 0x800
	// Reset the selected module
	RCC_APB4RSTR_LPTIM4RST_Reset = 0x1
	// Position of LPTIM5RST field.
	RCC_APB4RSTR_LPTIM5RST_Pos = 0xc
	// Bit mask of LPTIM5RST field.
	RCC_APB4RSTR_LPTIM5RST_Msk = 0x1000
	// Bit LPTIM5RST.
	RCC_APB4RSTR_LPTIM5RST = 0x1000
	// Reset the selected module
	RCC_APB4RSTR_LPTIM5RST_Reset = 0x1
	// Position of COMP12RST field.
	RCC_APB4RSTR_COMP12RST_Pos = 0xe
	// Bit mask of COMP12RST field.
	RCC_APB4RSTR_COMP12RST_Msk = 0x4000
	// Bit COMP12RST.
	RCC_APB4RSTR_COMP12RST = 0x4000
	// Reset the selected module
	RCC_APB4RSTR_COMP12RST_Reset = 0x1
	// Position of VREFRST field.
	RCC_APB4RSTR_VREFRST_Pos = 0xf
	// Bit mask of VREFRST field.
	RCC_APB4RSTR_VREFRST_Msk = 0x8000
	// Bit VREFRST.
	RCC_APB4RSTR_VREFRST = 0x8000
	// Reset the selected module
	RCC_APB4RSTR_VREFRST_Reset = 0x1
	// Position of SAI4RST field.
	RCC_APB4RSTR_SAI4RST_Pos = 0x15
	// Bit mask of SAI4RST field.
	RCC_APB4RSTR_SAI4RST_Msk = 0x200000
	// Bit SAI4RST.
	RCC_APB4RSTR_SAI4RST = 0x200000
	// Reset the selected module
	RCC_APB4RSTR_SAI4RST_Reset = 0x1
	// Position of DTSRST field.
	RCC_APB4RSTR_DTSRST_Pos = 0x1a
	// Bit mask of DTSRST field.
	RCC_APB4RSTR_DTSRST_Msk = 0x4000000
	// Bit DTSRST.
	RCC_APB4RSTR_DTSRST = 0x4000000
	// Reset the selected module
	RCC_APB4RSTR_DTSRST_Reset = 0x1

	// GCR: RCC Global Control Register
	// Position of WW1RSC field.
	RCC_GCR_WW1RSC_Pos = 0x0
	// Bit mask of WW1RSC field.
	RCC_GCR_WW1RSC_Msk = 0x1
	// Bit WW1RSC.
	RCC_GCR_WW1RSC = 0x1
	// Clear WWDG1 scope control
	RCC_GCR_WW1RSC_Clear = 0x0
	// Set WWDG1 scope control
	RCC_GCR_WW1RSC_Set = 0x1

	// D3AMR: RCC D3 Autonomous mode Register
	// Position of BDMAAMEN field.
	RCC_D3AMR_BDMAAMEN_Pos = 0x0
	// Bit mask of BDMAAMEN field.
	RCC_D3AMR_BDMAAMEN_Msk = 0x1
	// Bit BDMAAMEN.
	RCC_D3AMR_BDMAAMEN = 0x1
	// Clock disabled in autonomous mode
	RCC_D3AMR_BDMAAMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_BDMAAMEN_Enabled = 0x1
	// Position of LPUART1AMEN field.
	RCC_D3AMR_LPUART1AMEN_Pos = 0x3
	// Bit mask of LPUART1AMEN field.
	RCC_D3AMR_LPUART1AMEN_Msk = 0x8
	// Bit LPUART1AMEN.
	RCC_D3AMR_LPUART1AMEN = 0x8
	// Clock disabled in autonomous mode
	RCC_D3AMR_LPUART1AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_LPUART1AMEN_Enabled = 0x1
	// Position of SPI6AMEN field.
	RCC_D3AMR_SPI6AMEN_Pos = 0x5
	// Bit mask of SPI6AMEN field.
	RCC_D3AMR_SPI6AMEN_Msk = 0x20
	// Bit SPI6AMEN.
	RCC_D3AMR_SPI6AMEN = 0x20
	// Clock disabled in autonomous mode
	RCC_D3AMR_SPI6AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_SPI6AMEN_Enabled = 0x1
	// Position of I2C4AMEN field.
	RCC_D3AMR_I2C4AMEN_Pos = 0x7
	// Bit mask of I2C4AMEN field.
	RCC_D3AMR_I2C4AMEN_Msk = 0x80
	// Bit I2C4AMEN.
	RCC_D3AMR_I2C4AMEN = 0x80
	// Clock disabled in autonomous mode
	RCC_D3AMR_I2C4AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_I2C4AMEN_Enabled = 0x1
	// Position of LPTIM2AMEN field.
	RCC_D3AMR_LPTIM2AMEN_Pos = 0x9
	// Bit mask of LPTIM2AMEN field.
	RCC_D3AMR_LPTIM2AMEN_Msk = 0x200
	// Bit LPTIM2AMEN.
	RCC_D3AMR_LPTIM2AMEN = 0x200
	// Clock disabled in autonomous mode
	RCC_D3AMR_LPTIM2AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_LPTIM2AMEN_Enabled = 0x1
	// Position of LPTIM3AMEN field.
	RCC_D3AMR_LPTIM3AMEN_Pos = 0xa
	// Bit mask of LPTIM3AMEN field.
	RCC_D3AMR_LPTIM3AMEN_Msk = 0x400
	// Bit LPTIM3AMEN.
	RCC_D3AMR_LPTIM3AMEN = 0x400
	// Clock disabled in autonomous mode
	RCC_D3AMR_LPTIM3AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_LPTIM3AMEN_Enabled = 0x1
	// Position of LPTIM4AMEN field.
	RCC_D3AMR_LPTIM4AMEN_Pos = 0xb
	// Bit mask of LPTIM4AMEN field.
	RCC_D3AMR_LPTIM4AMEN_Msk = 0x800
	// Bit LPTIM4AMEN.
	RCC_D3AMR_LPTIM4AMEN = 0x800
	// Clock disabled in autonomous mode
	RCC_D3AMR_LPTIM4AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_LPTIM4AMEN_Enabled = 0x1
	// Position of LPTIM5AMEN field.
	RCC_D3AMR_LPTIM5AMEN_Pos = 0xc
	// Bit mask of LPTIM5AMEN field.
	RCC_D3AMR_LPTIM5AMEN_Msk = 0x1000
	// Bit LPTIM5AMEN.
	RCC_D3AMR_LPTIM5AMEN = 0x1000
	// Clock disabled in autonomous mode
	RCC_D3AMR_LPTIM5AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_LPTIM5AMEN_Enabled = 0x1
	// Position of COMP12AMEN field.
	RCC_D3AMR_COMP12AMEN_Pos = 0xe
	// Bit mask of COMP12AMEN field.
	RCC_D3AMR_COMP12AMEN_Msk = 0x4000
	// Bit COMP12AMEN.
	RCC_D3AMR_COMP12AMEN = 0x4000
	// Clock disabled in autonomous mode
	RCC_D3AMR_COMP12AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_COMP12AMEN_Enabled = 0x1
	// Position of VREFAMEN field.
	RCC_D3AMR_VREFAMEN_Pos = 0xf
	// Bit mask of VREFAMEN field.
	RCC_D3AMR_VREFAMEN_Msk = 0x8000
	// Bit VREFAMEN.
	RCC_D3AMR_VREFAMEN = 0x8000
	// Clock disabled in autonomous mode
	RCC_D3AMR_VREFAMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_VREFAMEN_Enabled = 0x1
	// Position of RTCAMEN field.
	RCC_D3AMR_RTCAMEN_Pos = 0x10
	// Bit mask of RTCAMEN field.
	RCC_D3AMR_RTCAMEN_Msk = 0x10000
	// Bit RTCAMEN.
	RCC_D3AMR_RTCAMEN = 0x10000
	// Clock disabled in autonomous mode
	RCC_D3AMR_RTCAMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_RTCAMEN_Enabled = 0x1
	// Position of CRCAMEN field.
	RCC_D3AMR_CRCAMEN_Pos = 0x13
	// Bit mask of CRCAMEN field.
	RCC_D3AMR_CRCAMEN_Msk = 0x80000
	// Bit CRCAMEN.
	RCC_D3AMR_CRCAMEN = 0x80000
	// Clock disabled in autonomous mode
	RCC_D3AMR_CRCAMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_CRCAMEN_Enabled = 0x1
	// Position of SAI4AMEN field.
	RCC_D3AMR_SAI4AMEN_Pos = 0x15
	// Bit mask of SAI4AMEN field.
	RCC_D3AMR_SAI4AMEN_Msk = 0x200000
	// Bit SAI4AMEN.
	RCC_D3AMR_SAI4AMEN = 0x200000
	// Clock disabled in autonomous mode
	RCC_D3AMR_SAI4AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_SAI4AMEN_Enabled = 0x1
	// Position of ADC3AMEN field.
	RCC_D3AMR_ADC3AMEN_Pos = 0x18
	// Bit mask of ADC3AMEN field.
	RCC_D3AMR_ADC3AMEN_Msk = 0x1000000
	// Bit ADC3AMEN.
	RCC_D3AMR_ADC3AMEN = 0x1000000
	// Clock disabled in autonomous mode
	RCC_D3AMR_ADC3AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_ADC3AMEN_Enabled = 0x1
	// Position of BKPSRAMAMEN field.
	RCC_D3AMR_BKPSRAMAMEN_Pos = 0x1c
	// Bit mask of BKPSRAMAMEN field.
	RCC_D3AMR_BKPSRAMAMEN_Msk = 0x10000000
	// Bit BKPSRAMAMEN.
	RCC_D3AMR_BKPSRAMAMEN = 0x10000000
	// Clock disabled in autonomous mode
	RCC_D3AMR_BKPSRAMAMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_BKPSRAMAMEN_Enabled = 0x1
	// Position of SRAM4AMEN field.
	RCC_D3AMR_SRAM4AMEN_Pos = 0x1d
	// Bit mask of SRAM4AMEN field.
	RCC_D3AMR_SRAM4AMEN_Msk = 0x20000000
	// Bit SRAM4AMEN.
	RCC_D3AMR_SRAM4AMEN = 0x20000000
	// Clock disabled in autonomous mode
	RCC_D3AMR_SRAM4AMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_SRAM4AMEN_Enabled = 0x1
	// Position of DTSAMEN field.
	RCC_D3AMR_DTSAMEN_Pos = 0x1a
	// Bit mask of DTSAMEN field.
	RCC_D3AMR_DTSAMEN_Msk = 0x4000000
	// Bit DTSAMEN.
	RCC_D3AMR_DTSAMEN = 0x4000000
	// Clock disabled in autonomous mode
	RCC_D3AMR_DTSAMEN_Disabled = 0x0
	// Clock enabled in autonomous mode
	RCC_D3AMR_DTSAMEN_Enabled = 0x1

	// RSR: RCC Reset Status Register
	// Position of RMVF field.
	RCC_RSR_RMVF_Pos = 0x10
	// Bit mask of RMVF field.
	RCC_RSR_RMVF_Msk = 0x10000
	// Bit RMVF.
	RCC_RSR_RMVF = 0x10000
	// Not clearing the the reset flags
	RCC_RSR_RMVF_NotActive = 0x0
	// Clear the reset flags
	RCC_RSR_RMVF_Clear = 0x1
	// Position of CPURSTF field.
	RCC_RSR_CPURSTF_Pos = 0x11
	// Bit mask of CPURSTF field.
	RCC_RSR_CPURSTF_Msk = 0x20000
	// Bit CPURSTF.
	RCC_RSR_CPURSTF = 0x20000
	// No reset occoured for block
	RCC_RSR_CPURSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_CPURSTF_ResetOccourred = 0x1
	// Position of D1RSTF field.
	RCC_RSR_D1RSTF_Pos = 0x13
	// Bit mask of D1RSTF field.
	RCC_RSR_D1RSTF_Msk = 0x80000
	// Bit D1RSTF.
	RCC_RSR_D1RSTF = 0x80000
	// No reset occoured for block
	RCC_RSR_D1RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_D1RSTF_ResetOccourred = 0x1
	// Position of D2RSTF field.
	RCC_RSR_D2RSTF_Pos = 0x14
	// Bit mask of D2RSTF field.
	RCC_RSR_D2RSTF_Msk = 0x100000
	// Bit D2RSTF.
	RCC_RSR_D2RSTF = 0x100000
	// No reset occoured for block
	RCC_RSR_D2RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_D2RSTF_ResetOccourred = 0x1
	// Position of BORRSTF field.
	RCC_RSR_BORRSTF_Pos = 0x15
	// Bit mask of BORRSTF field.
	RCC_RSR_BORRSTF_Msk = 0x200000
	// Bit BORRSTF.
	RCC_RSR_BORRSTF = 0x200000
	// No reset occoured for block
	RCC_RSR_BORRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_BORRSTF_ResetOccourred = 0x1
	// Position of PINRSTF field.
	RCC_RSR_PINRSTF_Pos = 0x16
	// Bit mask of PINRSTF field.
	RCC_RSR_PINRSTF_Msk = 0x400000
	// Bit PINRSTF.
	RCC_RSR_PINRSTF = 0x400000
	// No reset occoured for block
	RCC_RSR_PINRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_PINRSTF_ResetOccourred = 0x1
	// Position of PORRSTF field.
	RCC_RSR_PORRSTF_Pos = 0x17
	// Bit mask of PORRSTF field.
	RCC_RSR_PORRSTF_Msk = 0x800000
	// Bit PORRSTF.
	RCC_RSR_PORRSTF = 0x800000
	// No reset occoured for block
	RCC_RSR_PORRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_PORRSTF_ResetOccourred = 0x1
	// Position of SFTRSTF field.
	RCC_RSR_SFTRSTF_Pos = 0x18
	// Bit mask of SFTRSTF field.
	RCC_RSR_SFTRSTF_Msk = 0x1000000
	// Bit SFTRSTF.
	RCC_RSR_SFTRSTF = 0x1000000
	// No reset occoured for block
	RCC_RSR_SFTRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_SFTRSTF_ResetOccourred = 0x1
	// Position of IWDG1RSTF field.
	RCC_RSR_IWDG1RSTF_Pos = 0x1a
	// Bit mask of IWDG1RSTF field.
	RCC_RSR_IWDG1RSTF_Msk = 0x4000000
	// Bit IWDG1RSTF.
	RCC_RSR_IWDG1RSTF = 0x4000000
	// No reset occoured for block
	RCC_RSR_IWDG1RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_IWDG1RSTF_ResetOccourred = 0x1
	// Position of WWDG1RSTF field.
	RCC_RSR_WWDG1RSTF_Pos = 0x1c
	// Bit mask of WWDG1RSTF field.
	RCC_RSR_WWDG1RSTF_Msk = 0x10000000
	// Bit WWDG1RSTF.
	RCC_RSR_WWDG1RSTF = 0x10000000
	// No reset occoured for block
	RCC_RSR_WWDG1RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_WWDG1RSTF_ResetOccourred = 0x1
	// Position of LPWRRSTF field.
	RCC_RSR_LPWRRSTF_Pos = 0x1e
	// Bit mask of LPWRRSTF field.
	RCC_RSR_LPWRRSTF_Msk = 0x40000000
	// Bit LPWRRSTF.
	RCC_RSR_LPWRRSTF = 0x40000000
	// No reset occoured for block
	RCC_RSR_LPWRRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_RSR_LPWRRSTF_ResetOccourred = 0x1

	// AHB3ENR: RCC AHB3 Clock Register
	// Position of MDMAEN field.
	RCC_AHB3ENR_MDMAEN_Pos = 0x0
	// Bit mask of MDMAEN field.
	RCC_AHB3ENR_MDMAEN_Msk = 0x1
	// Bit MDMAEN.
	RCC_AHB3ENR_MDMAEN = 0x1
	// The selected clock is disabled
	RCC_AHB3ENR_MDMAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_MDMAEN_Enabled = 0x1
	// Position of DMA2DEN field.
	RCC_AHB3ENR_DMA2DEN_Pos = 0x4
	// Bit mask of DMA2DEN field.
	RCC_AHB3ENR_DMA2DEN_Msk = 0x10
	// Bit DMA2DEN.
	RCC_AHB3ENR_DMA2DEN = 0x10
	// The selected clock is disabled
	RCC_AHB3ENR_DMA2DEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_DMA2DEN_Enabled = 0x1
	// Position of FMCEN field.
	RCC_AHB3ENR_FMCEN_Pos = 0xc
	// Bit mask of FMCEN field.
	RCC_AHB3ENR_FMCEN_Msk = 0x1000
	// Bit FMCEN.
	RCC_AHB3ENR_FMCEN = 0x1000
	// The selected clock is disabled
	RCC_AHB3ENR_FMCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_FMCEN_Enabled = 0x1
	// Position of SDMMC1EN field.
	RCC_AHB3ENR_SDMMC1EN_Pos = 0x10
	// Bit mask of SDMMC1EN field.
	RCC_AHB3ENR_SDMMC1EN_Msk = 0x10000
	// Bit SDMMC1EN.
	RCC_AHB3ENR_SDMMC1EN = 0x10000
	// The selected clock is disabled
	RCC_AHB3ENR_SDMMC1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_SDMMC1EN_Enabled = 0x1
	// Position of OCTOSPI1EN field.
	RCC_AHB3ENR_OCTOSPI1EN_Pos = 0xe
	// Bit mask of OCTOSPI1EN field.
	RCC_AHB3ENR_OCTOSPI1EN_Msk = 0x4000
	// Bit OCTOSPI1EN.
	RCC_AHB3ENR_OCTOSPI1EN = 0x4000
	// The selected clock is disabled
	RCC_AHB3ENR_OCTOSPI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_OCTOSPI1EN_Enabled = 0x1
	// Position of OCTOSPI2EN field.
	RCC_AHB3ENR_OCTOSPI2EN_Pos = 0x13
	// Bit mask of OCTOSPI2EN field.
	RCC_AHB3ENR_OCTOSPI2EN_Msk = 0x80000
	// Bit OCTOSPI2EN.
	RCC_AHB3ENR_OCTOSPI2EN = 0x80000
	// The selected clock is disabled
	RCC_AHB3ENR_OCTOSPI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_OCTOSPI2EN_Enabled = 0x1
	// Position of IOMNGREN field.
	RCC_AHB3ENR_IOMNGREN_Pos = 0x15
	// Bit mask of IOMNGREN field.
	RCC_AHB3ENR_IOMNGREN_Msk = 0x200000
	// Bit IOMNGREN.
	RCC_AHB3ENR_IOMNGREN = 0x200000
	// The selected clock is disabled
	RCC_AHB3ENR_IOMNGREN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_IOMNGREN_Enabled = 0x1
	// Position of OTFD1EN field.
	RCC_AHB3ENR_OTFD1EN_Pos = 0x16
	// Bit mask of OTFD1EN field.
	RCC_AHB3ENR_OTFD1EN_Msk = 0x400000
	// Bit OTFD1EN.
	RCC_AHB3ENR_OTFD1EN = 0x400000
	// The selected clock is disabled
	RCC_AHB3ENR_OTFD1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_OTFD1EN_Enabled = 0x1
	// Position of OTFD2EN field.
	RCC_AHB3ENR_OTFD2EN_Pos = 0x17
	// Bit mask of OTFD2EN field.
	RCC_AHB3ENR_OTFD2EN_Msk = 0x800000
	// Bit OTFD2EN.
	RCC_AHB3ENR_OTFD2EN = 0x800000
	// The selected clock is disabled
	RCC_AHB3ENR_OTFD2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_OTFD2EN_Enabled = 0x1

	// AHB1ENR: RCC AHB1 Clock Register
	// Position of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Pos = 0x0
	// Bit mask of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Msk = 0x1
	// Bit DMA1EN.
	RCC_AHB1ENR_DMA1EN = 0x1
	// The selected clock is disabled
	RCC_AHB1ENR_DMA1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_DMA1EN_Enabled = 0x1
	// Position of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Pos = 0x1
	// Bit mask of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Msk = 0x2
	// Bit DMA2EN.
	RCC_AHB1ENR_DMA2EN = 0x2
	// The selected clock is disabled
	RCC_AHB1ENR_DMA2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_DMA2EN_Enabled = 0x1
	// Position of ADC12EN field.
	RCC_AHB1ENR_ADC12EN_Pos = 0x5
	// Bit mask of ADC12EN field.
	RCC_AHB1ENR_ADC12EN_Msk = 0x20
	// Bit ADC12EN.
	RCC_AHB1ENR_ADC12EN = 0x20
	// The selected clock is disabled
	RCC_AHB1ENR_ADC12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ADC12EN_Enabled = 0x1
	// Position of ETH1MACEN field.
	RCC_AHB1ENR_ETH1MACEN_Pos = 0xf
	// Bit mask of ETH1MACEN field.
	RCC_AHB1ENR_ETH1MACEN_Msk = 0x8000
	// Bit ETH1MACEN.
	RCC_AHB1ENR_ETH1MACEN = 0x8000
	// The selected clock is disabled
	RCC_AHB1ENR_ETH1MACEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETH1MACEN_Enabled = 0x1
	// Position of ETH1TXEN field.
	RCC_AHB1ENR_ETH1TXEN_Pos = 0x10
	// Bit mask of ETH1TXEN field.
	RCC_AHB1ENR_ETH1TXEN_Msk = 0x10000
	// Bit ETH1TXEN.
	RCC_AHB1ENR_ETH1TXEN = 0x10000
	// The selected clock is disabled
	RCC_AHB1ENR_ETH1TXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETH1TXEN_Enabled = 0x1
	// Position of ETH1RXEN field.
	RCC_AHB1ENR_ETH1RXEN_Pos = 0x11
	// Bit mask of ETH1RXEN field.
	RCC_AHB1ENR_ETH1RXEN_Msk = 0x20000
	// Bit ETH1RXEN.
	RCC_AHB1ENR_ETH1RXEN = 0x20000
	// The selected clock is disabled
	RCC_AHB1ENR_ETH1RXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETH1RXEN_Enabled = 0x1
	// Position of USB1OTGEN field.
	RCC_AHB1ENR_USB1OTGEN_Pos = 0x19
	// Bit mask of USB1OTGEN field.
	RCC_AHB1ENR_USB1OTGEN_Msk = 0x2000000
	// Bit USB1OTGEN.
	RCC_AHB1ENR_USB1OTGEN = 0x2000000
	// The selected clock is disabled
	RCC_AHB1ENR_USB1OTGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_USB1OTGEN_Enabled = 0x1
	// Position of USB1ULPIEN field.
	RCC_AHB1ENR_USB1ULPIEN_Pos = 0x1a
	// Bit mask of USB1ULPIEN field.
	RCC_AHB1ENR_USB1ULPIEN_Msk = 0x4000000
	// Bit USB1ULPIEN.
	RCC_AHB1ENR_USB1ULPIEN = 0x4000000
	// The selected clock is disabled
	RCC_AHB1ENR_USB1ULPIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_USB1ULPIEN_Enabled = 0x1

	// AHB2ENR: RCC AHB2 Clock Register
	// Position of DCMIEN field.
	RCC_AHB2ENR_DCMIEN_Pos = 0x0
	// Bit mask of DCMIEN field.
	RCC_AHB2ENR_DCMIEN_Msk = 0x1
	// Bit DCMIEN.
	RCC_AHB2ENR_DCMIEN = 0x1
	// The selected clock is disabled
	RCC_AHB2ENR_DCMIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_DCMIEN_Enabled = 0x1
	// Position of CRYPTEN field.
	RCC_AHB2ENR_CRYPTEN_Pos = 0x4
	// Bit mask of CRYPTEN field.
	RCC_AHB2ENR_CRYPTEN_Msk = 0x10
	// Bit CRYPTEN.
	RCC_AHB2ENR_CRYPTEN = 0x10
	// The selected clock is disabled
	RCC_AHB2ENR_CRYPTEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_CRYPTEN_Enabled = 0x1
	// Position of HASHEN field.
	RCC_AHB2ENR_HASHEN_Pos = 0x5
	// Bit mask of HASHEN field.
	RCC_AHB2ENR_HASHEN_Msk = 0x20
	// Bit HASHEN.
	RCC_AHB2ENR_HASHEN = 0x20
	// The selected clock is disabled
	RCC_AHB2ENR_HASHEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_HASHEN_Enabled = 0x1
	// Position of RNGEN field.
	RCC_AHB2ENR_RNGEN_Pos = 0x6
	// Bit mask of RNGEN field.
	RCC_AHB2ENR_RNGEN_Msk = 0x40
	// Bit RNGEN.
	RCC_AHB2ENR_RNGEN = 0x40
	// The selected clock is disabled
	RCC_AHB2ENR_RNGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_RNGEN_Enabled = 0x1
	// Position of SDMMC2EN field.
	RCC_AHB2ENR_SDMMC2EN_Pos = 0x9
	// Bit mask of SDMMC2EN field.
	RCC_AHB2ENR_SDMMC2EN_Msk = 0x200
	// Bit SDMMC2EN.
	RCC_AHB2ENR_SDMMC2EN = 0x200
	// The selected clock is disabled
	RCC_AHB2ENR_SDMMC2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_SDMMC2EN_Enabled = 0x1
	// Position of SRAM1EN field.
	RCC_AHB2ENR_SRAM1EN_Pos = 0x1d
	// Bit mask of SRAM1EN field.
	RCC_AHB2ENR_SRAM1EN_Msk = 0x20000000
	// Bit SRAM1EN.
	RCC_AHB2ENR_SRAM1EN = 0x20000000
	// The selected clock is disabled
	RCC_AHB2ENR_SRAM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_SRAM1EN_Enabled = 0x1
	// Position of SRAM2EN field.
	RCC_AHB2ENR_SRAM2EN_Pos = 0x1e
	// Bit mask of SRAM2EN field.
	RCC_AHB2ENR_SRAM2EN_Msk = 0x40000000
	// Bit SRAM2EN.
	RCC_AHB2ENR_SRAM2EN = 0x40000000
	// The selected clock is disabled
	RCC_AHB2ENR_SRAM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_SRAM2EN_Enabled = 0x1
	// Position of FMACEN field.
	RCC_AHB2ENR_FMACEN_Pos = 0x10
	// Bit mask of FMACEN field.
	RCC_AHB2ENR_FMACEN_Msk = 0x10000
	// Bit FMACEN.
	RCC_AHB2ENR_FMACEN = 0x10000
	// The selected clock is disabled
	RCC_AHB2ENR_FMACEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_FMACEN_Enabled = 0x1
	// Position of CORDICEN field.
	RCC_AHB2ENR_CORDICEN_Pos = 0x11
	// Bit mask of CORDICEN field.
	RCC_AHB2ENR_CORDICEN_Msk = 0x20000
	// Bit CORDICEN.
	RCC_AHB2ENR_CORDICEN = 0x20000
	// The selected clock is disabled
	RCC_AHB2ENR_CORDICEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_CORDICEN_Enabled = 0x1

	// AHB4ENR: RCC AHB4 Clock Register
	// Position of GPIOAEN field.
	RCC_AHB4ENR_GPIOAEN_Pos = 0x0
	// Bit mask of GPIOAEN field.
	RCC_AHB4ENR_GPIOAEN_Msk = 0x1
	// Bit GPIOAEN.
	RCC_AHB4ENR_GPIOAEN = 0x1
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOAEN_Enabled = 0x1
	// Position of GPIOBEN field.
	RCC_AHB4ENR_GPIOBEN_Pos = 0x1
	// Bit mask of GPIOBEN field.
	RCC_AHB4ENR_GPIOBEN_Msk = 0x2
	// Bit GPIOBEN.
	RCC_AHB4ENR_GPIOBEN = 0x2
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOBEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOBEN_Enabled = 0x1
	// Position of GPIOCEN field.
	RCC_AHB4ENR_GPIOCEN_Pos = 0x2
	// Bit mask of GPIOCEN field.
	RCC_AHB4ENR_GPIOCEN_Msk = 0x4
	// Bit GPIOCEN.
	RCC_AHB4ENR_GPIOCEN = 0x4
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOCEN_Enabled = 0x1
	// Position of GPIODEN field.
	RCC_AHB4ENR_GPIODEN_Pos = 0x3
	// Bit mask of GPIODEN field.
	RCC_AHB4ENR_GPIODEN_Msk = 0x8
	// Bit GPIODEN.
	RCC_AHB4ENR_GPIODEN = 0x8
	// The selected clock is disabled
	RCC_AHB4ENR_GPIODEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIODEN_Enabled = 0x1
	// Position of GPIOEEN field.
	RCC_AHB4ENR_GPIOEEN_Pos = 0x4
	// Bit mask of GPIOEEN field.
	RCC_AHB4ENR_GPIOEEN_Msk = 0x10
	// Bit GPIOEEN.
	RCC_AHB4ENR_GPIOEEN = 0x10
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOEEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOEEN_Enabled = 0x1
	// Position of GPIOFEN field.
	RCC_AHB4ENR_GPIOFEN_Pos = 0x5
	// Bit mask of GPIOFEN field.
	RCC_AHB4ENR_GPIOFEN_Msk = 0x20
	// Bit GPIOFEN.
	RCC_AHB4ENR_GPIOFEN = 0x20
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOFEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOFEN_Enabled = 0x1
	// Position of GPIOGEN field.
	RCC_AHB4ENR_GPIOGEN_Pos = 0x6
	// Bit mask of GPIOGEN field.
	RCC_AHB4ENR_GPIOGEN_Msk = 0x40
	// Bit GPIOGEN.
	RCC_AHB4ENR_GPIOGEN = 0x40
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOGEN_Enabled = 0x1
	// Position of GPIOHEN field.
	RCC_AHB4ENR_GPIOHEN_Pos = 0x7
	// Bit mask of GPIOHEN field.
	RCC_AHB4ENR_GPIOHEN_Msk = 0x80
	// Bit GPIOHEN.
	RCC_AHB4ENR_GPIOHEN = 0x80
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOHEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOHEN_Enabled = 0x1
	// Position of GPIOIEN field.
	RCC_AHB4ENR_GPIOIEN_Pos = 0x8
	// Bit mask of GPIOIEN field.
	RCC_AHB4ENR_GPIOIEN_Msk = 0x100
	// Bit GPIOIEN.
	RCC_AHB4ENR_GPIOIEN = 0x100
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOIEN_Enabled = 0x1
	// Position of GPIOJEN field.
	RCC_AHB4ENR_GPIOJEN_Pos = 0x9
	// Bit mask of GPIOJEN field.
	RCC_AHB4ENR_GPIOJEN_Msk = 0x200
	// Bit GPIOJEN.
	RCC_AHB4ENR_GPIOJEN = 0x200
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOJEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOJEN_Enabled = 0x1
	// Position of GPIOKEN field.
	RCC_AHB4ENR_GPIOKEN_Pos = 0xa
	// Bit mask of GPIOKEN field.
	RCC_AHB4ENR_GPIOKEN_Msk = 0x400
	// Bit GPIOKEN.
	RCC_AHB4ENR_GPIOKEN = 0x400
	// The selected clock is disabled
	RCC_AHB4ENR_GPIOKEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_GPIOKEN_Enabled = 0x1
	// Position of CRCEN field.
	RCC_AHB4ENR_CRCEN_Pos = 0x13
	// Bit mask of CRCEN field.
	RCC_AHB4ENR_CRCEN_Msk = 0x80000
	// Bit CRCEN.
	RCC_AHB4ENR_CRCEN = 0x80000
	// The selected clock is disabled
	RCC_AHB4ENR_CRCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_CRCEN_Enabled = 0x1
	// Position of BDMAEN field.
	RCC_AHB4ENR_BDMAEN_Pos = 0x15
	// Bit mask of BDMAEN field.
	RCC_AHB4ENR_BDMAEN_Msk = 0x200000
	// Bit BDMAEN.
	RCC_AHB4ENR_BDMAEN = 0x200000
	// The selected clock is disabled
	RCC_AHB4ENR_BDMAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_BDMAEN_Enabled = 0x1
	// Position of ADC3EN field.
	RCC_AHB4ENR_ADC3EN_Pos = 0x18
	// Bit mask of ADC3EN field.
	RCC_AHB4ENR_ADC3EN_Msk = 0x1000000
	// Bit ADC3EN.
	RCC_AHB4ENR_ADC3EN = 0x1000000
	// The selected clock is disabled
	RCC_AHB4ENR_ADC3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_ADC3EN_Enabled = 0x1
	// Position of HSEMEN field.
	RCC_AHB4ENR_HSEMEN_Pos = 0x19
	// Bit mask of HSEMEN field.
	RCC_AHB4ENR_HSEMEN_Msk = 0x2000000
	// Bit HSEMEN.
	RCC_AHB4ENR_HSEMEN = 0x2000000
	// The selected clock is disabled
	RCC_AHB4ENR_HSEMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_HSEMEN_Enabled = 0x1
	// Position of BKPRAMEN field.
	RCC_AHB4ENR_BKPRAMEN_Pos = 0x1c
	// Bit mask of BKPRAMEN field.
	RCC_AHB4ENR_BKPRAMEN_Msk = 0x10000000
	// Bit BKPRAMEN.
	RCC_AHB4ENR_BKPRAMEN = 0x10000000
	// The selected clock is disabled
	RCC_AHB4ENR_BKPRAMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB4ENR_BKPRAMEN_Enabled = 0x1

	// APB3ENR: RCC APB3 Clock Register
	// Position of LTDCEN field.
	RCC_APB3ENR_LTDCEN_Pos = 0x3
	// Bit mask of LTDCEN field.
	RCC_APB3ENR_LTDCEN_Msk = 0x8
	// Bit LTDCEN.
	RCC_APB3ENR_LTDCEN = 0x8
	// The selected clock is disabled
	RCC_APB3ENR_LTDCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB3ENR_LTDCEN_Enabled = 0x1
	// Position of WWDG1EN field.
	RCC_APB3ENR_WWDG1EN_Pos = 0x6
	// Bit mask of WWDG1EN field.
	RCC_APB3ENR_WWDG1EN_Msk = 0x40
	// Bit WWDG1EN.
	RCC_APB3ENR_WWDG1EN = 0x40
	// The selected clock is disabled
	RCC_APB3ENR_WWDG1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB3ENR_WWDG1EN_Enabled = 0x1

	// APB1LENR: RCC APB1 Clock Register
	// Position of TIM2EN field.
	RCC_APB1LENR_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_APB1LENR_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_APB1LENR_TIM2EN = 0x1
	// The selected clock is disabled
	RCC_APB1LENR_TIM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM2EN_Enabled = 0x1
	// Position of TIM3EN field.
	RCC_APB1LENR_TIM3EN_Pos = 0x1
	// Bit mask of TIM3EN field.
	RCC_APB1LENR_TIM3EN_Msk = 0x2
	// Bit TIM3EN.
	RCC_APB1LENR_TIM3EN = 0x2
	// The selected clock is disabled
	RCC_APB1LENR_TIM3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM3EN_Enabled = 0x1
	// Position of TIM4EN field.
	RCC_APB1LENR_TIM4EN_Pos = 0x2
	// Bit mask of TIM4EN field.
	RCC_APB1LENR_TIM4EN_Msk = 0x4
	// Bit TIM4EN.
	RCC_APB1LENR_TIM4EN = 0x4
	// The selected clock is disabled
	RCC_APB1LENR_TIM4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM4EN_Enabled = 0x1
	// Position of TIM5EN field.
	RCC_APB1LENR_TIM5EN_Pos = 0x3
	// Bit mask of TIM5EN field.
	RCC_APB1LENR_TIM5EN_Msk = 0x8
	// Bit TIM5EN.
	RCC_APB1LENR_TIM5EN = 0x8
	// The selected clock is disabled
	RCC_APB1LENR_TIM5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM5EN_Enabled = 0x1
	// Position of TIM6EN field.
	RCC_APB1LENR_TIM6EN_Pos = 0x4
	// Bit mask of TIM6EN field.
	RCC_APB1LENR_TIM6EN_Msk = 0x10
	// Bit TIM6EN.
	RCC_APB1LENR_TIM6EN = 0x10
	// The selected clock is disabled
	RCC_APB1LENR_TIM6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM6EN_Enabled = 0x1
	// Position of TIM7EN field.
	RCC_APB1LENR_TIM7EN_Pos = 0x5
	// Bit mask of TIM7EN field.
	RCC_APB1LENR_TIM7EN_Msk = 0x20
	// Bit TIM7EN.
	RCC_APB1LENR_TIM7EN = 0x20
	// The selected clock is disabled
	RCC_APB1LENR_TIM7EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM7EN_Enabled = 0x1
	// Position of TIM12EN field.
	RCC_APB1LENR_TIM12EN_Pos = 0x6
	// Bit mask of TIM12EN field.
	RCC_APB1LENR_TIM12EN_Msk = 0x40
	// Bit TIM12EN.
	RCC_APB1LENR_TIM12EN = 0x40
	// The selected clock is disabled
	RCC_APB1LENR_TIM12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM12EN_Enabled = 0x1
	// Position of TIM13EN field.
	RCC_APB1LENR_TIM13EN_Pos = 0x7
	// Bit mask of TIM13EN field.
	RCC_APB1LENR_TIM13EN_Msk = 0x80
	// Bit TIM13EN.
	RCC_APB1LENR_TIM13EN = 0x80
	// The selected clock is disabled
	RCC_APB1LENR_TIM13EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM13EN_Enabled = 0x1
	// Position of TIM14EN field.
	RCC_APB1LENR_TIM14EN_Pos = 0x8
	// Bit mask of TIM14EN field.
	RCC_APB1LENR_TIM14EN_Msk = 0x100
	// Bit TIM14EN.
	RCC_APB1LENR_TIM14EN = 0x100
	// The selected clock is disabled
	RCC_APB1LENR_TIM14EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_TIM14EN_Enabled = 0x1
	// Position of LPTIM1EN field.
	RCC_APB1LENR_LPTIM1EN_Pos = 0x9
	// Bit mask of LPTIM1EN field.
	RCC_APB1LENR_LPTIM1EN_Msk = 0x200
	// Bit LPTIM1EN.
	RCC_APB1LENR_LPTIM1EN = 0x200
	// The selected clock is disabled
	RCC_APB1LENR_LPTIM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_LPTIM1EN_Enabled = 0x1
	// Position of SPI2EN field.
	RCC_APB1LENR_SPI2EN_Pos = 0xe
	// Bit mask of SPI2EN field.
	RCC_APB1LENR_SPI2EN_Msk = 0x4000
	// Bit SPI2EN.
	RCC_APB1LENR_SPI2EN = 0x4000
	// The selected clock is disabled
	RCC_APB1LENR_SPI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_SPI2EN_Enabled = 0x1
	// Position of SPI3EN field.
	RCC_APB1LENR_SPI3EN_Pos = 0xf
	// Bit mask of SPI3EN field.
	RCC_APB1LENR_SPI3EN_Msk = 0x8000
	// Bit SPI3EN.
	RCC_APB1LENR_SPI3EN = 0x8000
	// The selected clock is disabled
	RCC_APB1LENR_SPI3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_SPI3EN_Enabled = 0x1
	// Position of SPDIFRXEN field.
	RCC_APB1LENR_SPDIFRXEN_Pos = 0x10
	// Bit mask of SPDIFRXEN field.
	RCC_APB1LENR_SPDIFRXEN_Msk = 0x10000
	// Bit SPDIFRXEN.
	RCC_APB1LENR_SPDIFRXEN = 0x10000
	// The selected clock is disabled
	RCC_APB1LENR_SPDIFRXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_SPDIFRXEN_Enabled = 0x1
	// Position of USART2EN field.
	RCC_APB1LENR_USART2EN_Pos = 0x11
	// Bit mask of USART2EN field.
	RCC_APB1LENR_USART2EN_Msk = 0x20000
	// Bit USART2EN.
	RCC_APB1LENR_USART2EN = 0x20000
	// The selected clock is disabled
	RCC_APB1LENR_USART2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_USART2EN_Enabled = 0x1
	// Position of USART3EN field.
	RCC_APB1LENR_USART3EN_Pos = 0x12
	// Bit mask of USART3EN field.
	RCC_APB1LENR_USART3EN_Msk = 0x40000
	// Bit USART3EN.
	RCC_APB1LENR_USART3EN = 0x40000
	// The selected clock is disabled
	RCC_APB1LENR_USART3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_USART3EN_Enabled = 0x1
	// Position of UART4EN field.
	RCC_APB1LENR_UART4EN_Pos = 0x13
	// Bit mask of UART4EN field.
	RCC_APB1LENR_UART4EN_Msk = 0x80000
	// Bit UART4EN.
	RCC_APB1LENR_UART4EN = 0x80000
	// The selected clock is disabled
	RCC_APB1LENR_UART4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_UART4EN_Enabled = 0x1
	// Position of UART5EN field.
	RCC_APB1LENR_UART5EN_Pos = 0x14
	// Bit mask of UART5EN field.
	RCC_APB1LENR_UART5EN_Msk = 0x100000
	// Bit UART5EN.
	RCC_APB1LENR_UART5EN = 0x100000
	// The selected clock is disabled
	RCC_APB1LENR_UART5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_UART5EN_Enabled = 0x1
	// Position of I2C1EN field.
	RCC_APB1LENR_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_APB1LENR_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_APB1LENR_I2C1EN = 0x200000
	// The selected clock is disabled
	RCC_APB1LENR_I2C1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_I2C1EN_Enabled = 0x1
	// Position of I2C2EN field.
	RCC_APB1LENR_I2C2EN_Pos = 0x16
	// Bit mask of I2C2EN field.
	RCC_APB1LENR_I2C2EN_Msk = 0x400000
	// Bit I2C2EN.
	RCC_APB1LENR_I2C2EN = 0x400000
	// The selected clock is disabled
	RCC_APB1LENR_I2C2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_I2C2EN_Enabled = 0x1
	// Position of I2C3EN field.
	RCC_APB1LENR_I2C3EN_Pos = 0x17
	// Bit mask of I2C3EN field.
	RCC_APB1LENR_I2C3EN_Msk = 0x800000
	// Bit I2C3EN.
	RCC_APB1LENR_I2C3EN = 0x800000
	// The selected clock is disabled
	RCC_APB1LENR_I2C3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_I2C3EN_Enabled = 0x1
	// Position of CECEN field.
	RCC_APB1LENR_CECEN_Pos = 0x1b
	// Bit mask of CECEN field.
	RCC_APB1LENR_CECEN_Msk = 0x8000000
	// Bit CECEN.
	RCC_APB1LENR_CECEN = 0x8000000
	// The selected clock is disabled
	RCC_APB1LENR_CECEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_CECEN_Enabled = 0x1
	// Position of DAC12EN field.
	RCC_APB1LENR_DAC12EN_Pos = 0x1d
	// Bit mask of DAC12EN field.
	RCC_APB1LENR_DAC12EN_Msk = 0x20000000
	// Bit DAC12EN.
	RCC_APB1LENR_DAC12EN = 0x20000000
	// The selected clock is disabled
	RCC_APB1LENR_DAC12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_DAC12EN_Enabled = 0x1
	// Position of UART7EN field.
	RCC_APB1LENR_UART7EN_Pos = 0x1e
	// Bit mask of UART7EN field.
	RCC_APB1LENR_UART7EN_Msk = 0x40000000
	// Bit UART7EN.
	RCC_APB1LENR_UART7EN = 0x40000000
	// The selected clock is disabled
	RCC_APB1LENR_UART7EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_UART7EN_Enabled = 0x1
	// Position of UART8EN field.
	RCC_APB1LENR_UART8EN_Pos = 0x1f
	// Bit mask of UART8EN field.
	RCC_APB1LENR_UART8EN_Msk = 0x80000000
	// Bit UART8EN.
	RCC_APB1LENR_UART8EN = 0x80000000
	// The selected clock is disabled
	RCC_APB1LENR_UART8EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_UART8EN_Enabled = 0x1
	// Position of I2C5EN field.
	RCC_APB1LENR_I2C5EN_Pos = 0x19
	// Bit mask of I2C5EN field.
	RCC_APB1LENR_I2C5EN_Msk = 0x2000000
	// Bit I2C5EN.
	RCC_APB1LENR_I2C5EN = 0x2000000
	// The selected clock is disabled
	RCC_APB1LENR_I2C5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1LENR_I2C5EN_Enabled = 0x1

	// APB1HENR: RCC APB1 Clock Register
	// Position of CRSEN field.
	RCC_APB1HENR_CRSEN_Pos = 0x1
	// Bit mask of CRSEN field.
	RCC_APB1HENR_CRSEN_Msk = 0x2
	// Bit CRSEN.
	RCC_APB1HENR_CRSEN = 0x2
	// The selected clock is disabled
	RCC_APB1HENR_CRSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_CRSEN_Enabled = 0x1
	// Position of SWPMIEN field.
	RCC_APB1HENR_SWPMIEN_Pos = 0x2
	// Bit mask of SWPMIEN field.
	RCC_APB1HENR_SWPMIEN_Msk = 0x4
	// Bit SWPMIEN.
	RCC_APB1HENR_SWPMIEN = 0x4
	// The selected clock is disabled
	RCC_APB1HENR_SWPMIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_SWPMIEN_Enabled = 0x1
	// Position of OPAMPEN field.
	RCC_APB1HENR_OPAMPEN_Pos = 0x4
	// Bit mask of OPAMPEN field.
	RCC_APB1HENR_OPAMPEN_Msk = 0x10
	// Bit OPAMPEN.
	RCC_APB1HENR_OPAMPEN = 0x10
	// The selected clock is disabled
	RCC_APB1HENR_OPAMPEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_OPAMPEN_Enabled = 0x1
	// Position of MDIOSEN field.
	RCC_APB1HENR_MDIOSEN_Pos = 0x5
	// Bit mask of MDIOSEN field.
	RCC_APB1HENR_MDIOSEN_Msk = 0x20
	// Bit MDIOSEN.
	RCC_APB1HENR_MDIOSEN = 0x20
	// The selected clock is disabled
	RCC_APB1HENR_MDIOSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_MDIOSEN_Enabled = 0x1
	// Position of FDCANEN field.
	RCC_APB1HENR_FDCANEN_Pos = 0x8
	// Bit mask of FDCANEN field.
	RCC_APB1HENR_FDCANEN_Msk = 0x100
	// Bit FDCANEN.
	RCC_APB1HENR_FDCANEN = 0x100
	// The selected clock is disabled
	RCC_APB1HENR_FDCANEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_FDCANEN_Enabled = 0x1
	// Position of TIM23EN field.
	RCC_APB1HENR_TIM23EN_Pos = 0x18
	// Bit mask of TIM23EN field.
	RCC_APB1HENR_TIM23EN_Msk = 0x1000000
	// Bit TIM23EN.
	RCC_APB1HENR_TIM23EN = 0x1000000
	// The selected clock is disabled
	RCC_APB1HENR_TIM23EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_TIM23EN_Enabled = 0x1
	// Position of TIM24EN field.
	RCC_APB1HENR_TIM24EN_Pos = 0x19
	// Bit mask of TIM24EN field.
	RCC_APB1HENR_TIM24EN_Msk = 0x2000000
	// Bit TIM24EN.
	RCC_APB1HENR_TIM24EN = 0x2000000
	// The selected clock is disabled
	RCC_APB1HENR_TIM24EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1HENR_TIM24EN_Enabled = 0x1

	// APB2ENR: RCC APB2 Clock Register
	// Position of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Pos = 0x0
	// Bit mask of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Msk = 0x1
	// Bit TIM1EN.
	RCC_APB2ENR_TIM1EN = 0x1
	// The selected clock is disabled
	RCC_APB2ENR_TIM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM1EN_Enabled = 0x1
	// Position of TIM8EN field.
	RCC_APB2ENR_TIM8EN_Pos = 0x1
	// Bit mask of TIM8EN field.
	RCC_APB2ENR_TIM8EN_Msk = 0x2
	// Bit TIM8EN.
	RCC_APB2ENR_TIM8EN = 0x2
	// The selected clock is disabled
	RCC_APB2ENR_TIM8EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM8EN_Enabled = 0x1
	// Position of USART1EN field.
	RCC_APB2ENR_USART1EN_Pos = 0x4
	// Bit mask of USART1EN field.
	RCC_APB2ENR_USART1EN_Msk = 0x10
	// Bit USART1EN.
	RCC_APB2ENR_USART1EN = 0x10
	// The selected clock is disabled
	RCC_APB2ENR_USART1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_USART1EN_Enabled = 0x1
	// Position of USART6EN field.
	RCC_APB2ENR_USART6EN_Pos = 0x5
	// Bit mask of USART6EN field.
	RCC_APB2ENR_USART6EN_Msk = 0x20
	// Bit USART6EN.
	RCC_APB2ENR_USART6EN = 0x20
	// The selected clock is disabled
	RCC_APB2ENR_USART6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_USART6EN_Enabled = 0x1
	// Position of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_APB2ENR_SPI1EN = 0x1000
	// The selected clock is disabled
	RCC_APB2ENR_SPI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI1EN_Enabled = 0x1
	// Position of SPI4EN field.
	RCC_APB2ENR_SPI4EN_Pos = 0xd
	// Bit mask of SPI4EN field.
	RCC_APB2ENR_SPI4EN_Msk = 0x2000
	// Bit SPI4EN.
	RCC_APB2ENR_SPI4EN = 0x2000
	// The selected clock is disabled
	RCC_APB2ENR_SPI4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI4EN_Enabled = 0x1
	// Position of TIM16EN field.
	RCC_APB2ENR_TIM16EN_Pos = 0x11
	// Bit mask of TIM16EN field.
	RCC_APB2ENR_TIM16EN_Msk = 0x20000
	// Bit TIM16EN.
	RCC_APB2ENR_TIM16EN = 0x20000
	// The selected clock is disabled
	RCC_APB2ENR_TIM16EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM16EN_Enabled = 0x1
	// Position of TIM15EN field.
	RCC_APB2ENR_TIM15EN_Pos = 0x10
	// Bit mask of TIM15EN field.
	RCC_APB2ENR_TIM15EN_Msk = 0x10000
	// Bit TIM15EN.
	RCC_APB2ENR_TIM15EN = 0x10000
	// The selected clock is disabled
	RCC_APB2ENR_TIM15EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM15EN_Enabled = 0x1
	// Position of TIM17EN field.
	RCC_APB2ENR_TIM17EN_Pos = 0x12
	// Bit mask of TIM17EN field.
	RCC_APB2ENR_TIM17EN_Msk = 0x40000
	// Bit TIM17EN.
	RCC_APB2ENR_TIM17EN = 0x40000
	// The selected clock is disabled
	RCC_APB2ENR_TIM17EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM17EN_Enabled = 0x1
	// Position of SPI5EN field.
	RCC_APB2ENR_SPI5EN_Pos = 0x14
	// Bit mask of SPI5EN field.
	RCC_APB2ENR_SPI5EN_Msk = 0x100000
	// Bit SPI5EN.
	RCC_APB2ENR_SPI5EN = 0x100000
	// The selected clock is disabled
	RCC_APB2ENR_SPI5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI5EN_Enabled = 0x1
	// Position of SAI1EN field.
	RCC_APB2ENR_SAI1EN_Pos = 0x16
	// Bit mask of SAI1EN field.
	RCC_APB2ENR_SAI1EN_Msk = 0x400000
	// Bit SAI1EN.
	RCC_APB2ENR_SAI1EN = 0x400000
	// The selected clock is disabled
	RCC_APB2ENR_SAI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SAI1EN_Enabled = 0x1
	// Position of SAI2EN field.
	RCC_APB2ENR_SAI2EN_Pos = 0x17
	// Bit mask of SAI2EN field.
	RCC_APB2ENR_SAI2EN_Msk = 0x800000
	// Bit SAI2EN.
	RCC_APB2ENR_SAI2EN = 0x800000
	// The selected clock is disabled
	RCC_APB2ENR_SAI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SAI2EN_Enabled = 0x1
	// Position of SAI3EN field.
	RCC_APB2ENR_SAI3EN_Pos = 0x18
	// Bit mask of SAI3EN field.
	RCC_APB2ENR_SAI3EN_Msk = 0x1000000
	// Bit SAI3EN.
	RCC_APB2ENR_SAI3EN = 0x1000000
	// The selected clock is disabled
	RCC_APB2ENR_SAI3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SAI3EN_Enabled = 0x1
	// Position of DFSDM1EN field.
	RCC_APB2ENR_DFSDM1EN_Pos = 0x1c
	// Bit mask of DFSDM1EN field.
	RCC_APB2ENR_DFSDM1EN_Msk = 0x10000000
	// Bit DFSDM1EN.
	RCC_APB2ENR_DFSDM1EN = 0x10000000
	// The selected clock is disabled
	RCC_APB2ENR_DFSDM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_DFSDM1EN_Enabled = 0x1

	// APB4ENR: RCC APB4 Clock Register
	// Position of SYSCFGEN field.
	RCC_APB4ENR_SYSCFGEN_Pos = 0x1
	// Bit mask of SYSCFGEN field.
	RCC_APB4ENR_SYSCFGEN_Msk = 0x2
	// Bit SYSCFGEN.
	RCC_APB4ENR_SYSCFGEN = 0x2
	// The selected clock is disabled
	RCC_APB4ENR_SYSCFGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_SYSCFGEN_Enabled = 0x1
	// Position of LPUART1EN field.
	RCC_APB4ENR_LPUART1EN_Pos = 0x3
	// Bit mask of LPUART1EN field.
	RCC_APB4ENR_LPUART1EN_Msk = 0x8
	// Bit LPUART1EN.
	RCC_APB4ENR_LPUART1EN = 0x8
	// The selected clock is disabled
	RCC_APB4ENR_LPUART1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_LPUART1EN_Enabled = 0x1
	// Position of SPI6EN field.
	RCC_APB4ENR_SPI6EN_Pos = 0x5
	// Bit mask of SPI6EN field.
	RCC_APB4ENR_SPI6EN_Msk = 0x20
	// Bit SPI6EN.
	RCC_APB4ENR_SPI6EN = 0x20
	// The selected clock is disabled
	RCC_APB4ENR_SPI6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_SPI6EN_Enabled = 0x1
	// Position of I2C4EN field.
	RCC_APB4ENR_I2C4EN_Pos = 0x7
	// Bit mask of I2C4EN field.
	RCC_APB4ENR_I2C4EN_Msk = 0x80
	// Bit I2C4EN.
	RCC_APB4ENR_I2C4EN = 0x80
	// The selected clock is disabled
	RCC_APB4ENR_I2C4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_I2C4EN_Enabled = 0x1
	// Position of LPTIM2EN field.
	RCC_APB4ENR_LPTIM2EN_Pos = 0x9
	// Bit mask of LPTIM2EN field.
	RCC_APB4ENR_LPTIM2EN_Msk = 0x200
	// Bit LPTIM2EN.
	RCC_APB4ENR_LPTIM2EN = 0x200
	// The selected clock is disabled
	RCC_APB4ENR_LPTIM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_LPTIM2EN_Enabled = 0x1
	// Position of LPTIM3EN field.
	RCC_APB4ENR_LPTIM3EN_Pos = 0xa
	// Bit mask of LPTIM3EN field.
	RCC_APB4ENR_LPTIM3EN_Msk = 0x400
	// Bit LPTIM3EN.
	RCC_APB4ENR_LPTIM3EN = 0x400
	// The selected clock is disabled
	RCC_APB4ENR_LPTIM3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_LPTIM3EN_Enabled = 0x1
	// Position of LPTIM4EN field.
	RCC_APB4ENR_LPTIM4EN_Pos = 0xb
	// Bit mask of LPTIM4EN field.
	RCC_APB4ENR_LPTIM4EN_Msk = 0x800
	// Bit LPTIM4EN.
	RCC_APB4ENR_LPTIM4EN = 0x800
	// The selected clock is disabled
	RCC_APB4ENR_LPTIM4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_LPTIM4EN_Enabled = 0x1
	// Position of LPTIM5EN field.
	RCC_APB4ENR_LPTIM5EN_Pos = 0xc
	// Bit mask of LPTIM5EN field.
	RCC_APB4ENR_LPTIM5EN_Msk = 0x1000
	// Bit LPTIM5EN.
	RCC_APB4ENR_LPTIM5EN = 0x1000
	// The selected clock is disabled
	RCC_APB4ENR_LPTIM5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_LPTIM5EN_Enabled = 0x1
	// Position of COMP12EN field.
	RCC_APB4ENR_COMP12EN_Pos = 0xe
	// Bit mask of COMP12EN field.
	RCC_APB4ENR_COMP12EN_Msk = 0x4000
	// Bit COMP12EN.
	RCC_APB4ENR_COMP12EN = 0x4000
	// The selected clock is disabled
	RCC_APB4ENR_COMP12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_COMP12EN_Enabled = 0x1
	// Position of VREFEN field.
	RCC_APB4ENR_VREFEN_Pos = 0xf
	// Bit mask of VREFEN field.
	RCC_APB4ENR_VREFEN_Msk = 0x8000
	// Bit VREFEN.
	RCC_APB4ENR_VREFEN = 0x8000
	// The selected clock is disabled
	RCC_APB4ENR_VREFEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_VREFEN_Enabled = 0x1
	// Position of RTCAPBEN field.
	RCC_APB4ENR_RTCAPBEN_Pos = 0x10
	// Bit mask of RTCAPBEN field.
	RCC_APB4ENR_RTCAPBEN_Msk = 0x10000
	// Bit RTCAPBEN.
	RCC_APB4ENR_RTCAPBEN = 0x10000
	// The selected clock is disabled
	RCC_APB4ENR_RTCAPBEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_RTCAPBEN_Enabled = 0x1
	// Position of SAI4EN field.
	RCC_APB4ENR_SAI4EN_Pos = 0x15
	// Bit mask of SAI4EN field.
	RCC_APB4ENR_SAI4EN_Msk = 0x200000
	// Bit SAI4EN.
	RCC_APB4ENR_SAI4EN = 0x200000
	// The selected clock is disabled
	RCC_APB4ENR_SAI4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_SAI4EN_Enabled = 0x1
	// Position of DTSEN field.
	RCC_APB4ENR_DTSEN_Pos = 0x1a
	// Bit mask of DTSEN field.
	RCC_APB4ENR_DTSEN_Msk = 0x4000000
	// Bit DTSEN.
	RCC_APB4ENR_DTSEN = 0x4000000
	// The selected clock is disabled
	RCC_APB4ENR_DTSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB4ENR_DTSEN_Enabled = 0x1

	// AHB3LPENR: RCC AHB3 Sleep Clock Register
	// Position of MDMALPEN field.
	RCC_AHB3LPENR_MDMALPEN_Pos = 0x0
	// Bit mask of MDMALPEN field.
	RCC_AHB3LPENR_MDMALPEN_Msk = 0x1
	// Bit MDMALPEN.
	RCC_AHB3LPENR_MDMALPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_MDMALPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_MDMALPEN_Enabled = 0x1
	// Position of DMA2DLPEN field.
	RCC_AHB3LPENR_DMA2DLPEN_Pos = 0x4
	// Bit mask of DMA2DLPEN field.
	RCC_AHB3LPENR_DMA2DLPEN_Msk = 0x10
	// Bit DMA2DLPEN.
	RCC_AHB3LPENR_DMA2DLPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_DMA2DLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_DMA2DLPEN_Enabled = 0x1
	// Position of FLITFLPEN field.
	RCC_AHB3LPENR_FLITFLPEN_Pos = 0x8
	// Bit mask of FLITFLPEN field.
	RCC_AHB3LPENR_FLITFLPEN_Msk = 0x100
	// Bit FLITFLPEN.
	RCC_AHB3LPENR_FLITFLPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_FLITFLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_FLITFLPEN_Enabled = 0x1
	// Position of FMCLPEN field.
	RCC_AHB3LPENR_FMCLPEN_Pos = 0xc
	// Bit mask of FMCLPEN field.
	RCC_AHB3LPENR_FMCLPEN_Msk = 0x1000
	// Bit FMCLPEN.
	RCC_AHB3LPENR_FMCLPEN = 0x1000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_FMCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_FMCLPEN_Enabled = 0x1
	// Position of SDMMC1LPEN field.
	RCC_AHB3LPENR_SDMMC1LPEN_Pos = 0x10
	// Bit mask of SDMMC1LPEN field.
	RCC_AHB3LPENR_SDMMC1LPEN_Msk = 0x10000
	// Bit SDMMC1LPEN.
	RCC_AHB3LPENR_SDMMC1LPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_SDMMC1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_SDMMC1LPEN_Enabled = 0x1
	// Position of D1DTCM1LPEN field.
	RCC_AHB3LPENR_D1DTCM1LPEN_Pos = 0x1c
	// Bit mask of D1DTCM1LPEN field.
	RCC_AHB3LPENR_D1DTCM1LPEN_Msk = 0x10000000
	// Bit D1DTCM1LPEN.
	RCC_AHB3LPENR_D1DTCM1LPEN = 0x10000000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_D1DTCM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_D1DTCM1LPEN_Enabled = 0x1
	// Position of DTCM2LPEN field.
	RCC_AHB3LPENR_DTCM2LPEN_Pos = 0x1d
	// Bit mask of DTCM2LPEN field.
	RCC_AHB3LPENR_DTCM2LPEN_Msk = 0x20000000
	// Bit DTCM2LPEN.
	RCC_AHB3LPENR_DTCM2LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_DTCM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_DTCM2LPEN_Enabled = 0x1
	// Position of ITCMLPEN field.
	RCC_AHB3LPENR_ITCMLPEN_Pos = 0x1e
	// Bit mask of ITCMLPEN field.
	RCC_AHB3LPENR_ITCMLPEN_Msk = 0x40000000
	// Bit ITCMLPEN.
	RCC_AHB3LPENR_ITCMLPEN = 0x40000000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_ITCMLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_ITCMLPEN_Enabled = 0x1
	// Position of AXISRAMLPEN field.
	RCC_AHB3LPENR_AXISRAMLPEN_Pos = 0x1f
	// Bit mask of AXISRAMLPEN field.
	RCC_AHB3LPENR_AXISRAMLPEN_Msk = 0x80000000
	// Bit AXISRAMLPEN.
	RCC_AHB3LPENR_AXISRAMLPEN = 0x80000000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_AXISRAMLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_AXISRAMLPEN_Enabled = 0x1
	// Position of OCTOSPI1LPEN field.
	RCC_AHB3LPENR_OCTOSPI1LPEN_Pos = 0xe
	// Bit mask of OCTOSPI1LPEN field.
	RCC_AHB3LPENR_OCTOSPI1LPEN_Msk = 0x4000
	// Bit OCTOSPI1LPEN.
	RCC_AHB3LPENR_OCTOSPI1LPEN = 0x4000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_OCTOSPI1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_OCTOSPI1LPEN_Enabled = 0x1
	// Position of OCTOSPI2LPEN field.
	RCC_AHB3LPENR_OCTOSPI2LPEN_Pos = 0x13
	// Bit mask of OCTOSPI2LPEN field.
	RCC_AHB3LPENR_OCTOSPI2LPEN_Msk = 0x80000
	// Bit OCTOSPI2LPEN.
	RCC_AHB3LPENR_OCTOSPI2LPEN = 0x80000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_OCTOSPI2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_OCTOSPI2LPEN_Enabled = 0x1
	// Position of IOMNGRLPEN field.
	RCC_AHB3LPENR_IOMNGRLPEN_Pos = 0x15
	// Bit mask of IOMNGRLPEN field.
	RCC_AHB3LPENR_IOMNGRLPEN_Msk = 0x200000
	// Bit IOMNGRLPEN.
	RCC_AHB3LPENR_IOMNGRLPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_IOMNGRLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_IOMNGRLPEN_Enabled = 0x1
	// Position of OTFD1LPEN field.
	RCC_AHB3LPENR_OTFD1LPEN_Pos = 0x16
	// Bit mask of OTFD1LPEN field.
	RCC_AHB3LPENR_OTFD1LPEN_Msk = 0x400000
	// Bit OTFD1LPEN.
	RCC_AHB3LPENR_OTFD1LPEN = 0x400000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_OTFD1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_OTFD1LPEN_Enabled = 0x1
	// Position of OTFD2LPEN field.
	RCC_AHB3LPENR_OTFD2LPEN_Pos = 0x17
	// Bit mask of OTFD2LPEN field.
	RCC_AHB3LPENR_OTFD2LPEN_Msk = 0x800000
	// Bit OTFD2LPEN.
	RCC_AHB3LPENR_OTFD2LPEN = 0x800000
	// The selected clock is disabled during csleep mode
	RCC_AHB3LPENR_OTFD2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB3LPENR_OTFD2LPEN_Enabled = 0x1

	// AHB1LPENR: RCC AHB1 Sleep Clock Register
	// Position of DMA1LPEN field.
	RCC_AHB1LPENR_DMA1LPEN_Pos = 0x0
	// Bit mask of DMA1LPEN field.
	RCC_AHB1LPENR_DMA1LPEN_Msk = 0x1
	// Bit DMA1LPEN.
	RCC_AHB1LPENR_DMA1LPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_DMA1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_DMA1LPEN_Enabled = 0x1
	// Position of DMA2LPEN field.
	RCC_AHB1LPENR_DMA2LPEN_Pos = 0x1
	// Bit mask of DMA2LPEN field.
	RCC_AHB1LPENR_DMA2LPEN_Msk = 0x2
	// Bit DMA2LPEN.
	RCC_AHB1LPENR_DMA2LPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_DMA2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_DMA2LPEN_Enabled = 0x1
	// Position of ADC12LPEN field.
	RCC_AHB1LPENR_ADC12LPEN_Pos = 0x5
	// Bit mask of ADC12LPEN field.
	RCC_AHB1LPENR_ADC12LPEN_Msk = 0x20
	// Bit ADC12LPEN.
	RCC_AHB1LPENR_ADC12LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_ADC12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_ADC12LPEN_Enabled = 0x1
	// Position of ETH1MACLPEN field.
	RCC_AHB1LPENR_ETH1MACLPEN_Pos = 0xf
	// Bit mask of ETH1MACLPEN field.
	RCC_AHB1LPENR_ETH1MACLPEN_Msk = 0x8000
	// Bit ETH1MACLPEN.
	RCC_AHB1LPENR_ETH1MACLPEN = 0x8000
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_ETH1MACLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_ETH1MACLPEN_Enabled = 0x1
	// Position of ETH1TXLPEN field.
	RCC_AHB1LPENR_ETH1TXLPEN_Pos = 0x10
	// Bit mask of ETH1TXLPEN field.
	RCC_AHB1LPENR_ETH1TXLPEN_Msk = 0x10000
	// Bit ETH1TXLPEN.
	RCC_AHB1LPENR_ETH1TXLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_ETH1TXLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_ETH1TXLPEN_Enabled = 0x1
	// Position of ETH1RXLPEN field.
	RCC_AHB1LPENR_ETH1RXLPEN_Pos = 0x11
	// Bit mask of ETH1RXLPEN field.
	RCC_AHB1LPENR_ETH1RXLPEN_Msk = 0x20000
	// Bit ETH1RXLPEN.
	RCC_AHB1LPENR_ETH1RXLPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_ETH1RXLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_ETH1RXLPEN_Enabled = 0x1
	// Position of USB1OTGLPEN field.
	RCC_AHB1LPENR_USB1OTGLPEN_Pos = 0x19
	// Bit mask of USB1OTGLPEN field.
	RCC_AHB1LPENR_USB1OTGLPEN_Msk = 0x2000000
	// Bit USB1OTGLPEN.
	RCC_AHB1LPENR_USB1OTGLPEN = 0x2000000
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_USB1OTGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_USB1OTGLPEN_Enabled = 0x1
	// Position of USB1ULPILPEN field.
	RCC_AHB1LPENR_USB1ULPILPEN_Pos = 0x1a
	// Bit mask of USB1ULPILPEN field.
	RCC_AHB1LPENR_USB1ULPILPEN_Msk = 0x4000000
	// Bit USB1ULPILPEN.
	RCC_AHB1LPENR_USB1ULPILPEN = 0x4000000
	// The selected clock is disabled during csleep mode
	RCC_AHB1LPENR_USB1ULPILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB1LPENR_USB1ULPILPEN_Enabled = 0x1

	// AHB2LPENR: RCC AHB2 Sleep Clock Register
	// Position of DCMILPEN field.
	RCC_AHB2LPENR_DCMILPEN_Pos = 0x0
	// Bit mask of DCMILPEN field.
	RCC_AHB2LPENR_DCMILPEN_Msk = 0x1
	// Bit DCMILPEN.
	RCC_AHB2LPENR_DCMILPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_DCMILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_DCMILPEN_Enabled = 0x1
	// Position of CRYPTLPEN field.
	RCC_AHB2LPENR_CRYPTLPEN_Pos = 0x4
	// Bit mask of CRYPTLPEN field.
	RCC_AHB2LPENR_CRYPTLPEN_Msk = 0x10
	// Bit CRYPTLPEN.
	RCC_AHB2LPENR_CRYPTLPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_CRYPTLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_CRYPTLPEN_Enabled = 0x1
	// Position of HASHLPEN field.
	RCC_AHB2LPENR_HASHLPEN_Pos = 0x5
	// Bit mask of HASHLPEN field.
	RCC_AHB2LPENR_HASHLPEN_Msk = 0x20
	// Bit HASHLPEN.
	RCC_AHB2LPENR_HASHLPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_HASHLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_HASHLPEN_Enabled = 0x1
	// Position of SDMMC2LPEN field.
	RCC_AHB2LPENR_SDMMC2LPEN_Pos = 0x9
	// Bit mask of SDMMC2LPEN field.
	RCC_AHB2LPENR_SDMMC2LPEN_Msk = 0x200
	// Bit SDMMC2LPEN.
	RCC_AHB2LPENR_SDMMC2LPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_SDMMC2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_SDMMC2LPEN_Enabled = 0x1
	// Position of RNGLPEN field.
	RCC_AHB2LPENR_RNGLPEN_Pos = 0x6
	// Bit mask of RNGLPEN field.
	RCC_AHB2LPENR_RNGLPEN_Msk = 0x40
	// Bit RNGLPEN.
	RCC_AHB2LPENR_RNGLPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_RNGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_RNGLPEN_Enabled = 0x1
	// Position of SRAM1LPEN field.
	RCC_AHB2LPENR_SRAM1LPEN_Pos = 0x1d
	// Bit mask of SRAM1LPEN field.
	RCC_AHB2LPENR_SRAM1LPEN_Msk = 0x20000000
	// Bit SRAM1LPEN.
	RCC_AHB2LPENR_SRAM1LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_SRAM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_SRAM1LPEN_Enabled = 0x1
	// Position of SRAM2LPEN field.
	RCC_AHB2LPENR_SRAM2LPEN_Pos = 0x1e
	// Bit mask of SRAM2LPEN field.
	RCC_AHB2LPENR_SRAM2LPEN_Msk = 0x40000000
	// Bit SRAM2LPEN.
	RCC_AHB2LPENR_SRAM2LPEN = 0x40000000
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_SRAM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_SRAM2LPEN_Enabled = 0x1
	// Position of FMACLPEN field.
	RCC_AHB2LPENR_FMACLPEN_Pos = 0x10
	// Bit mask of FMACLPEN field.
	RCC_AHB2LPENR_FMACLPEN_Msk = 0x10000
	// Bit FMACLPEN.
	RCC_AHB2LPENR_FMACLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_FMACLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_FMACLPEN_Enabled = 0x1
	// Position of CORDICLPEN field.
	RCC_AHB2LPENR_CORDICLPEN_Pos = 0x11
	// Bit mask of CORDICLPEN field.
	RCC_AHB2LPENR_CORDICLPEN_Msk = 0x20000
	// Bit CORDICLPEN.
	RCC_AHB2LPENR_CORDICLPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_AHB2LPENR_CORDICLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB2LPENR_CORDICLPEN_Enabled = 0x1

	// AHB4LPENR: RCC AHB4 Sleep Clock Register
	// Position of GPIOALPEN field.
	RCC_AHB4LPENR_GPIOALPEN_Pos = 0x0
	// Bit mask of GPIOALPEN field.
	RCC_AHB4LPENR_GPIOALPEN_Msk = 0x1
	// Bit GPIOALPEN.
	RCC_AHB4LPENR_GPIOALPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOALPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOALPEN_Enabled = 0x1
	// Position of GPIOBLPEN field.
	RCC_AHB4LPENR_GPIOBLPEN_Pos = 0x1
	// Bit mask of GPIOBLPEN field.
	RCC_AHB4LPENR_GPIOBLPEN_Msk = 0x2
	// Bit GPIOBLPEN.
	RCC_AHB4LPENR_GPIOBLPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOBLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOBLPEN_Enabled = 0x1
	// Position of GPIOCLPEN field.
	RCC_AHB4LPENR_GPIOCLPEN_Pos = 0x2
	// Bit mask of GPIOCLPEN field.
	RCC_AHB4LPENR_GPIOCLPEN_Msk = 0x4
	// Bit GPIOCLPEN.
	RCC_AHB4LPENR_GPIOCLPEN = 0x4
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOCLPEN_Enabled = 0x1
	// Position of GPIODLPEN field.
	RCC_AHB4LPENR_GPIODLPEN_Pos = 0x3
	// Bit mask of GPIODLPEN field.
	RCC_AHB4LPENR_GPIODLPEN_Msk = 0x8
	// Bit GPIODLPEN.
	RCC_AHB4LPENR_GPIODLPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIODLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIODLPEN_Enabled = 0x1
	// Position of GPIOELPEN field.
	RCC_AHB4LPENR_GPIOELPEN_Pos = 0x4
	// Bit mask of GPIOELPEN field.
	RCC_AHB4LPENR_GPIOELPEN_Msk = 0x10
	// Bit GPIOELPEN.
	RCC_AHB4LPENR_GPIOELPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOELPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOELPEN_Enabled = 0x1
	// Position of GPIOFLPEN field.
	RCC_AHB4LPENR_GPIOFLPEN_Pos = 0x5
	// Bit mask of GPIOFLPEN field.
	RCC_AHB4LPENR_GPIOFLPEN_Msk = 0x20
	// Bit GPIOFLPEN.
	RCC_AHB4LPENR_GPIOFLPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOFLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOFLPEN_Enabled = 0x1
	// Position of GPIOGLPEN field.
	RCC_AHB4LPENR_GPIOGLPEN_Pos = 0x6
	// Bit mask of GPIOGLPEN field.
	RCC_AHB4LPENR_GPIOGLPEN_Msk = 0x40
	// Bit GPIOGLPEN.
	RCC_AHB4LPENR_GPIOGLPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOGLPEN_Enabled = 0x1
	// Position of GPIOHLPEN field.
	RCC_AHB4LPENR_GPIOHLPEN_Pos = 0x7
	// Bit mask of GPIOHLPEN field.
	RCC_AHB4LPENR_GPIOHLPEN_Msk = 0x80
	// Bit GPIOHLPEN.
	RCC_AHB4LPENR_GPIOHLPEN = 0x80
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOHLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOHLPEN_Enabled = 0x1
	// Position of GPIOILPEN field.
	RCC_AHB4LPENR_GPIOILPEN_Pos = 0x8
	// Bit mask of GPIOILPEN field.
	RCC_AHB4LPENR_GPIOILPEN_Msk = 0x100
	// Bit GPIOILPEN.
	RCC_AHB4LPENR_GPIOILPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOILPEN_Enabled = 0x1
	// Position of GPIOJLPEN field.
	RCC_AHB4LPENR_GPIOJLPEN_Pos = 0x9
	// Bit mask of GPIOJLPEN field.
	RCC_AHB4LPENR_GPIOJLPEN_Msk = 0x200
	// Bit GPIOJLPEN.
	RCC_AHB4LPENR_GPIOJLPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOJLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOJLPEN_Enabled = 0x1
	// Position of GPIOKLPEN field.
	RCC_AHB4LPENR_GPIOKLPEN_Pos = 0xa
	// Bit mask of GPIOKLPEN field.
	RCC_AHB4LPENR_GPIOKLPEN_Msk = 0x400
	// Bit GPIOKLPEN.
	RCC_AHB4LPENR_GPIOKLPEN = 0x400
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_GPIOKLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_GPIOKLPEN_Enabled = 0x1
	// Position of CRCLPEN field.
	RCC_AHB4LPENR_CRCLPEN_Pos = 0x13
	// Bit mask of CRCLPEN field.
	RCC_AHB4LPENR_CRCLPEN_Msk = 0x80000
	// Bit CRCLPEN.
	RCC_AHB4LPENR_CRCLPEN = 0x80000
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_CRCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_CRCLPEN_Enabled = 0x1
	// Position of BDMALPEN field.
	RCC_AHB4LPENR_BDMALPEN_Pos = 0x15
	// Bit mask of BDMALPEN field.
	RCC_AHB4LPENR_BDMALPEN_Msk = 0x200000
	// Bit BDMALPEN.
	RCC_AHB4LPENR_BDMALPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_BDMALPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_BDMALPEN_Enabled = 0x1
	// Position of ADC3LPEN field.
	RCC_AHB4LPENR_ADC3LPEN_Pos = 0x18
	// Bit mask of ADC3LPEN field.
	RCC_AHB4LPENR_ADC3LPEN_Msk = 0x1000000
	// Bit ADC3LPEN.
	RCC_AHB4LPENR_ADC3LPEN = 0x1000000
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_ADC3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_ADC3LPEN_Enabled = 0x1
	// Position of BKPRAMLPEN field.
	RCC_AHB4LPENR_BKPRAMLPEN_Pos = 0x1c
	// Bit mask of BKPRAMLPEN field.
	RCC_AHB4LPENR_BKPRAMLPEN_Msk = 0x10000000
	// Bit BKPRAMLPEN.
	RCC_AHB4LPENR_BKPRAMLPEN = 0x10000000
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_BKPRAMLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_BKPRAMLPEN_Enabled = 0x1
	// Position of SRAM4LPEN field.
	RCC_AHB4LPENR_SRAM4LPEN_Pos = 0x1d
	// Bit mask of SRAM4LPEN field.
	RCC_AHB4LPENR_SRAM4LPEN_Msk = 0x20000000
	// Bit SRAM4LPEN.
	RCC_AHB4LPENR_SRAM4LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_AHB4LPENR_SRAM4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_AHB4LPENR_SRAM4LPEN_Enabled = 0x1

	// APB3LPENR: RCC APB3 Sleep Clock Register
	// Position of LTDCLPEN field.
	RCC_APB3LPENR_LTDCLPEN_Pos = 0x3
	// Bit mask of LTDCLPEN field.
	RCC_APB3LPENR_LTDCLPEN_Msk = 0x8
	// Bit LTDCLPEN.
	RCC_APB3LPENR_LTDCLPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_APB3LPENR_LTDCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB3LPENR_LTDCLPEN_Enabled = 0x1
	// Position of WWDG1LPEN field.
	RCC_APB3LPENR_WWDG1LPEN_Pos = 0x6
	// Bit mask of WWDG1LPEN field.
	RCC_APB3LPENR_WWDG1LPEN_Msk = 0x40
	// Bit WWDG1LPEN.
	RCC_APB3LPENR_WWDG1LPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_APB3LPENR_WWDG1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB3LPENR_WWDG1LPEN_Enabled = 0x1

	// APB1LLPENR: RCC APB1 Low Sleep Clock Register
	// Position of TIM2LPEN field.
	RCC_APB1LLPENR_TIM2LPEN_Pos = 0x0
	// Bit mask of TIM2LPEN field.
	RCC_APB1LLPENR_TIM2LPEN_Msk = 0x1
	// Bit TIM2LPEN.
	RCC_APB1LLPENR_TIM2LPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM2LPEN_Enabled = 0x1
	// Position of TIM3LPEN field.
	RCC_APB1LLPENR_TIM3LPEN_Pos = 0x1
	// Bit mask of TIM3LPEN field.
	RCC_APB1LLPENR_TIM3LPEN_Msk = 0x2
	// Bit TIM3LPEN.
	RCC_APB1LLPENR_TIM3LPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM3LPEN_Enabled = 0x1
	// Position of TIM4LPEN field.
	RCC_APB1LLPENR_TIM4LPEN_Pos = 0x2
	// Bit mask of TIM4LPEN field.
	RCC_APB1LLPENR_TIM4LPEN_Msk = 0x4
	// Bit TIM4LPEN.
	RCC_APB1LLPENR_TIM4LPEN = 0x4
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM4LPEN_Enabled = 0x1
	// Position of TIM5LPEN field.
	RCC_APB1LLPENR_TIM5LPEN_Pos = 0x3
	// Bit mask of TIM5LPEN field.
	RCC_APB1LLPENR_TIM5LPEN_Msk = 0x8
	// Bit TIM5LPEN.
	RCC_APB1LLPENR_TIM5LPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM5LPEN_Enabled = 0x1
	// Position of TIM6LPEN field.
	RCC_APB1LLPENR_TIM6LPEN_Pos = 0x4
	// Bit mask of TIM6LPEN field.
	RCC_APB1LLPENR_TIM6LPEN_Msk = 0x10
	// Bit TIM6LPEN.
	RCC_APB1LLPENR_TIM6LPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM6LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM6LPEN_Enabled = 0x1
	// Position of TIM7LPEN field.
	RCC_APB1LLPENR_TIM7LPEN_Pos = 0x5
	// Bit mask of TIM7LPEN field.
	RCC_APB1LLPENR_TIM7LPEN_Msk = 0x20
	// Bit TIM7LPEN.
	RCC_APB1LLPENR_TIM7LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM7LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM7LPEN_Enabled = 0x1
	// Position of TIM12LPEN field.
	RCC_APB1LLPENR_TIM12LPEN_Pos = 0x6
	// Bit mask of TIM12LPEN field.
	RCC_APB1LLPENR_TIM12LPEN_Msk = 0x40
	// Bit TIM12LPEN.
	RCC_APB1LLPENR_TIM12LPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM12LPEN_Enabled = 0x1
	// Position of TIM13LPEN field.
	RCC_APB1LLPENR_TIM13LPEN_Pos = 0x7
	// Bit mask of TIM13LPEN field.
	RCC_APB1LLPENR_TIM13LPEN_Msk = 0x80
	// Bit TIM13LPEN.
	RCC_APB1LLPENR_TIM13LPEN = 0x80
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM13LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM13LPEN_Enabled = 0x1
	// Position of TIM14LPEN field.
	RCC_APB1LLPENR_TIM14LPEN_Pos = 0x8
	// Bit mask of TIM14LPEN field.
	RCC_APB1LLPENR_TIM14LPEN_Msk = 0x100
	// Bit TIM14LPEN.
	RCC_APB1LLPENR_TIM14LPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_TIM14LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_TIM14LPEN_Enabled = 0x1
	// Position of LPTIM1LPEN field.
	RCC_APB1LLPENR_LPTIM1LPEN_Pos = 0x9
	// Bit mask of LPTIM1LPEN field.
	RCC_APB1LLPENR_LPTIM1LPEN_Msk = 0x200
	// Bit LPTIM1LPEN.
	RCC_APB1LLPENR_LPTIM1LPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_LPTIM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_LPTIM1LPEN_Enabled = 0x1
	// Position of SPI2LPEN field.
	RCC_APB1LLPENR_SPI2LPEN_Pos = 0xe
	// Bit mask of SPI2LPEN field.
	RCC_APB1LLPENR_SPI2LPEN_Msk = 0x4000
	// Bit SPI2LPEN.
	RCC_APB1LLPENR_SPI2LPEN = 0x4000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_SPI2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_SPI2LPEN_Enabled = 0x1
	// Position of SPI3LPEN field.
	RCC_APB1LLPENR_SPI3LPEN_Pos = 0xf
	// Bit mask of SPI3LPEN field.
	RCC_APB1LLPENR_SPI3LPEN_Msk = 0x8000
	// Bit SPI3LPEN.
	RCC_APB1LLPENR_SPI3LPEN = 0x8000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_SPI3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_SPI3LPEN_Enabled = 0x1
	// Position of SPDIFRXLPEN field.
	RCC_APB1LLPENR_SPDIFRXLPEN_Pos = 0x10
	// Bit mask of SPDIFRXLPEN field.
	RCC_APB1LLPENR_SPDIFRXLPEN_Msk = 0x10000
	// Bit SPDIFRXLPEN.
	RCC_APB1LLPENR_SPDIFRXLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_SPDIFRXLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_SPDIFRXLPEN_Enabled = 0x1
	// Position of USART2LPEN field.
	RCC_APB1LLPENR_USART2LPEN_Pos = 0x11
	// Bit mask of USART2LPEN field.
	RCC_APB1LLPENR_USART2LPEN_Msk = 0x20000
	// Bit USART2LPEN.
	RCC_APB1LLPENR_USART2LPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_USART2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_USART2LPEN_Enabled = 0x1
	// Position of USART3LPEN field.
	RCC_APB1LLPENR_USART3LPEN_Pos = 0x12
	// Bit mask of USART3LPEN field.
	RCC_APB1LLPENR_USART3LPEN_Msk = 0x40000
	// Bit USART3LPEN.
	RCC_APB1LLPENR_USART3LPEN = 0x40000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_USART3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_USART3LPEN_Enabled = 0x1
	// Position of UART4LPEN field.
	RCC_APB1LLPENR_UART4LPEN_Pos = 0x13
	// Bit mask of UART4LPEN field.
	RCC_APB1LLPENR_UART4LPEN_Msk = 0x80000
	// Bit UART4LPEN.
	RCC_APB1LLPENR_UART4LPEN = 0x80000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_UART4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_UART4LPEN_Enabled = 0x1
	// Position of UART5LPEN field.
	RCC_APB1LLPENR_UART5LPEN_Pos = 0x14
	// Bit mask of UART5LPEN field.
	RCC_APB1LLPENR_UART5LPEN_Msk = 0x100000
	// Bit UART5LPEN.
	RCC_APB1LLPENR_UART5LPEN = 0x100000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_UART5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_UART5LPEN_Enabled = 0x1
	// Position of I2C1LPEN field.
	RCC_APB1LLPENR_I2C1LPEN_Pos = 0x15
	// Bit mask of I2C1LPEN field.
	RCC_APB1LLPENR_I2C1LPEN_Msk = 0x200000
	// Bit I2C1LPEN.
	RCC_APB1LLPENR_I2C1LPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_I2C1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_I2C1LPEN_Enabled = 0x1
	// Position of I2C2LPEN field.
	RCC_APB1LLPENR_I2C2LPEN_Pos = 0x16
	// Bit mask of I2C2LPEN field.
	RCC_APB1LLPENR_I2C2LPEN_Msk = 0x400000
	// Bit I2C2LPEN.
	RCC_APB1LLPENR_I2C2LPEN = 0x400000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_I2C2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_I2C2LPEN_Enabled = 0x1
	// Position of I2C3LPEN field.
	RCC_APB1LLPENR_I2C3LPEN_Pos = 0x17
	// Bit mask of I2C3LPEN field.
	RCC_APB1LLPENR_I2C3LPEN_Msk = 0x800000
	// Bit I2C3LPEN.
	RCC_APB1LLPENR_I2C3LPEN = 0x800000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_I2C3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_I2C3LPEN_Enabled = 0x1
	// Position of CECLPEN field.
	RCC_APB1LLPENR_CECLPEN_Pos = 0x1b
	// Bit mask of CECLPEN field.
	RCC_APB1LLPENR_CECLPEN_Msk = 0x8000000
	// Bit CECLPEN.
	RCC_APB1LLPENR_CECLPEN = 0x8000000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_CECLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_CECLPEN_Enabled = 0x1
	// Position of DAC12LPEN field.
	RCC_APB1LLPENR_DAC12LPEN_Pos = 0x1d
	// Bit mask of DAC12LPEN field.
	RCC_APB1LLPENR_DAC12LPEN_Msk = 0x20000000
	// Bit DAC12LPEN.
	RCC_APB1LLPENR_DAC12LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_DAC12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_DAC12LPEN_Enabled = 0x1
	// Position of UART7LPEN field.
	RCC_APB1LLPENR_UART7LPEN_Pos = 0x1e
	// Bit mask of UART7LPEN field.
	RCC_APB1LLPENR_UART7LPEN_Msk = 0x40000000
	// Bit UART7LPEN.
	RCC_APB1LLPENR_UART7LPEN = 0x40000000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_UART7LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_UART7LPEN_Enabled = 0x1
	// Position of UART8LPEN field.
	RCC_APB1LLPENR_UART8LPEN_Pos = 0x1f
	// Bit mask of UART8LPEN field.
	RCC_APB1LLPENR_UART8LPEN_Msk = 0x80000000
	// Bit UART8LPEN.
	RCC_APB1LLPENR_UART8LPEN = 0x80000000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_UART8LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_UART8LPEN_Enabled = 0x1
	// Position of I2C5LPEN field.
	RCC_APB1LLPENR_I2C5LPEN_Pos = 0x19
	// Bit mask of I2C5LPEN field.
	RCC_APB1LLPENR_I2C5LPEN_Msk = 0x2000000
	// Bit I2C5LPEN.
	RCC_APB1LLPENR_I2C5LPEN = 0x2000000
	// The selected clock is disabled during csleep mode
	RCC_APB1LLPENR_I2C5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1LLPENR_I2C5LPEN_Enabled = 0x1

	// APB1HLPENR: RCC APB1 High Sleep Clock Register
	// Position of CRSLPEN field.
	RCC_APB1HLPENR_CRSLPEN_Pos = 0x1
	// Bit mask of CRSLPEN field.
	RCC_APB1HLPENR_CRSLPEN_Msk = 0x2
	// Bit CRSLPEN.
	RCC_APB1HLPENR_CRSLPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_CRSLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_CRSLPEN_Enabled = 0x1
	// Position of SWPMILPEN field.
	RCC_APB1HLPENR_SWPMILPEN_Pos = 0x2
	// Bit mask of SWPMILPEN field.
	RCC_APB1HLPENR_SWPMILPEN_Msk = 0x4
	// Bit SWPMILPEN.
	RCC_APB1HLPENR_SWPMILPEN = 0x4
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_SWPMILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_SWPMILPEN_Enabled = 0x1
	// Position of OPAMPLPEN field.
	RCC_APB1HLPENR_OPAMPLPEN_Pos = 0x4
	// Bit mask of OPAMPLPEN field.
	RCC_APB1HLPENR_OPAMPLPEN_Msk = 0x10
	// Bit OPAMPLPEN.
	RCC_APB1HLPENR_OPAMPLPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_OPAMPLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_OPAMPLPEN_Enabled = 0x1
	// Position of MDIOSLPEN field.
	RCC_APB1HLPENR_MDIOSLPEN_Pos = 0x5
	// Bit mask of MDIOSLPEN field.
	RCC_APB1HLPENR_MDIOSLPEN_Msk = 0x20
	// Bit MDIOSLPEN.
	RCC_APB1HLPENR_MDIOSLPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_MDIOSLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_MDIOSLPEN_Enabled = 0x1
	// Position of FDCANLPEN field.
	RCC_APB1HLPENR_FDCANLPEN_Pos = 0x8
	// Bit mask of FDCANLPEN field.
	RCC_APB1HLPENR_FDCANLPEN_Msk = 0x100
	// Bit FDCANLPEN.
	RCC_APB1HLPENR_FDCANLPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_FDCANLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_FDCANLPEN_Enabled = 0x1
	// Position of TIM23LPEN field.
	RCC_APB1HLPENR_TIM23LPEN_Pos = 0x18
	// Bit mask of TIM23LPEN field.
	RCC_APB1HLPENR_TIM23LPEN_Msk = 0x1000000
	// Bit TIM23LPEN.
	RCC_APB1HLPENR_TIM23LPEN = 0x1000000
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_TIM23LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_TIM23LPEN_Enabled = 0x1
	// Position of TIM24LPEN field.
	RCC_APB1HLPENR_TIM24LPEN_Pos = 0x19
	// Bit mask of TIM24LPEN field.
	RCC_APB1HLPENR_TIM24LPEN_Msk = 0x2000000
	// Bit TIM24LPEN.
	RCC_APB1HLPENR_TIM24LPEN = 0x2000000
	// The selected clock is disabled during csleep mode
	RCC_APB1HLPENR_TIM24LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB1HLPENR_TIM24LPEN_Enabled = 0x1

	// APB2LPENR: RCC APB2 Sleep Clock Register
	// Position of TIM1LPEN field.
	RCC_APB2LPENR_TIM1LPEN_Pos = 0x0
	// Bit mask of TIM1LPEN field.
	RCC_APB2LPENR_TIM1LPEN_Msk = 0x1
	// Bit TIM1LPEN.
	RCC_APB2LPENR_TIM1LPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_TIM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_TIM1LPEN_Enabled = 0x1
	// Position of TIM8LPEN field.
	RCC_APB2LPENR_TIM8LPEN_Pos = 0x1
	// Bit mask of TIM8LPEN field.
	RCC_APB2LPENR_TIM8LPEN_Msk = 0x2
	// Bit TIM8LPEN.
	RCC_APB2LPENR_TIM8LPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_TIM8LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_TIM8LPEN_Enabled = 0x1
	// Position of USART1LPEN field.
	RCC_APB2LPENR_USART1LPEN_Pos = 0x4
	// Bit mask of USART1LPEN field.
	RCC_APB2LPENR_USART1LPEN_Msk = 0x10
	// Bit USART1LPEN.
	RCC_APB2LPENR_USART1LPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_USART1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_USART1LPEN_Enabled = 0x1
	// Position of USART6LPEN field.
	RCC_APB2LPENR_USART6LPEN_Pos = 0x5
	// Bit mask of USART6LPEN field.
	RCC_APB2LPENR_USART6LPEN_Msk = 0x20
	// Bit USART6LPEN.
	RCC_APB2LPENR_USART6LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_USART6LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_USART6LPEN_Enabled = 0x1
	// Position of SPI1LPEN field.
	RCC_APB2LPENR_SPI1LPEN_Pos = 0xc
	// Bit mask of SPI1LPEN field.
	RCC_APB2LPENR_SPI1LPEN_Msk = 0x1000
	// Bit SPI1LPEN.
	RCC_APB2LPENR_SPI1LPEN = 0x1000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_SPI1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_SPI1LPEN_Enabled = 0x1
	// Position of SPI4LPEN field.
	RCC_APB2LPENR_SPI4LPEN_Pos = 0xd
	// Bit mask of SPI4LPEN field.
	RCC_APB2LPENR_SPI4LPEN_Msk = 0x2000
	// Bit SPI4LPEN.
	RCC_APB2LPENR_SPI4LPEN = 0x2000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_SPI4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_SPI4LPEN_Enabled = 0x1
	// Position of TIM15LPEN field.
	RCC_APB2LPENR_TIM15LPEN_Pos = 0x10
	// Bit mask of TIM15LPEN field.
	RCC_APB2LPENR_TIM15LPEN_Msk = 0x10000
	// Bit TIM15LPEN.
	RCC_APB2LPENR_TIM15LPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_TIM15LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_TIM15LPEN_Enabled = 0x1
	// Position of TIM16LPEN field.
	RCC_APB2LPENR_TIM16LPEN_Pos = 0x11
	// Bit mask of TIM16LPEN field.
	RCC_APB2LPENR_TIM16LPEN_Msk = 0x20000
	// Bit TIM16LPEN.
	RCC_APB2LPENR_TIM16LPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_TIM16LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_TIM16LPEN_Enabled = 0x1
	// Position of TIM17LPEN field.
	RCC_APB2LPENR_TIM17LPEN_Pos = 0x12
	// Bit mask of TIM17LPEN field.
	RCC_APB2LPENR_TIM17LPEN_Msk = 0x40000
	// Bit TIM17LPEN.
	RCC_APB2LPENR_TIM17LPEN = 0x40000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_TIM17LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_TIM17LPEN_Enabled = 0x1
	// Position of SPI5LPEN field.
	RCC_APB2LPENR_SPI5LPEN_Pos = 0x14
	// Bit mask of SPI5LPEN field.
	RCC_APB2LPENR_SPI5LPEN_Msk = 0x100000
	// Bit SPI5LPEN.
	RCC_APB2LPENR_SPI5LPEN = 0x100000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_SPI5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_SPI5LPEN_Enabled = 0x1
	// Position of SAI1LPEN field.
	RCC_APB2LPENR_SAI1LPEN_Pos = 0x16
	// Bit mask of SAI1LPEN field.
	RCC_APB2LPENR_SAI1LPEN_Msk = 0x400000
	// Bit SAI1LPEN.
	RCC_APB2LPENR_SAI1LPEN = 0x400000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_SAI1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_SAI1LPEN_Enabled = 0x1
	// Position of SAI2LPEN field.
	RCC_APB2LPENR_SAI2LPEN_Pos = 0x17
	// Bit mask of SAI2LPEN field.
	RCC_APB2LPENR_SAI2LPEN_Msk = 0x800000
	// Bit SAI2LPEN.
	RCC_APB2LPENR_SAI2LPEN = 0x800000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_SAI2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_SAI2LPEN_Enabled = 0x1
	// Position of SAI3LPEN field.
	RCC_APB2LPENR_SAI3LPEN_Pos = 0x18
	// Bit mask of SAI3LPEN field.
	RCC_APB2LPENR_SAI3LPEN_Msk = 0x1000000
	// Bit SAI3LPEN.
	RCC_APB2LPENR_SAI3LPEN = 0x1000000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_SAI3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_SAI3LPEN_Enabled = 0x1
	// Position of DFSDM1LPEN field.
	RCC_APB2LPENR_DFSDM1LPEN_Pos = 0x1c
	// Bit mask of DFSDM1LPEN field.
	RCC_APB2LPENR_DFSDM1LPEN_Msk = 0x10000000
	// Bit DFSDM1LPEN.
	RCC_APB2LPENR_DFSDM1LPEN = 0x10000000
	// The selected clock is disabled during csleep mode
	RCC_APB2LPENR_DFSDM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB2LPENR_DFSDM1LPEN_Enabled = 0x1

	// APB4LPENR: RCC APB4 Sleep Clock Register
	// Position of SYSCFGLPEN field.
	RCC_APB4LPENR_SYSCFGLPEN_Pos = 0x1
	// Bit mask of SYSCFGLPEN field.
	RCC_APB4LPENR_SYSCFGLPEN_Msk = 0x2
	// Bit SYSCFGLPEN.
	RCC_APB4LPENR_SYSCFGLPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_SYSCFGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_SYSCFGLPEN_Enabled = 0x1
	// Position of LPUART1LPEN field.
	RCC_APB4LPENR_LPUART1LPEN_Pos = 0x3
	// Bit mask of LPUART1LPEN field.
	RCC_APB4LPENR_LPUART1LPEN_Msk = 0x8
	// Bit LPUART1LPEN.
	RCC_APB4LPENR_LPUART1LPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_LPUART1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_LPUART1LPEN_Enabled = 0x1
	// Position of SPI6LPEN field.
	RCC_APB4LPENR_SPI6LPEN_Pos = 0x5
	// Bit mask of SPI6LPEN field.
	RCC_APB4LPENR_SPI6LPEN_Msk = 0x20
	// Bit SPI6LPEN.
	RCC_APB4LPENR_SPI6LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_SPI6LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_SPI6LPEN_Enabled = 0x1
	// Position of I2C4LPEN field.
	RCC_APB4LPENR_I2C4LPEN_Pos = 0x7
	// Bit mask of I2C4LPEN field.
	RCC_APB4LPENR_I2C4LPEN_Msk = 0x80
	// Bit I2C4LPEN.
	RCC_APB4LPENR_I2C4LPEN = 0x80
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_I2C4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_I2C4LPEN_Enabled = 0x1
	// Position of LPTIM2LPEN field.
	RCC_APB4LPENR_LPTIM2LPEN_Pos = 0x9
	// Bit mask of LPTIM2LPEN field.
	RCC_APB4LPENR_LPTIM2LPEN_Msk = 0x200
	// Bit LPTIM2LPEN.
	RCC_APB4LPENR_LPTIM2LPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_LPTIM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_LPTIM2LPEN_Enabled = 0x1
	// Position of LPTIM3LPEN field.
	RCC_APB4LPENR_LPTIM3LPEN_Pos = 0xa
	// Bit mask of LPTIM3LPEN field.
	RCC_APB4LPENR_LPTIM3LPEN_Msk = 0x400
	// Bit LPTIM3LPEN.
	RCC_APB4LPENR_LPTIM3LPEN = 0x400
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_LPTIM3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_LPTIM3LPEN_Enabled = 0x1
	// Position of LPTIM4LPEN field.
	RCC_APB4LPENR_LPTIM4LPEN_Pos = 0xb
	// Bit mask of LPTIM4LPEN field.
	RCC_APB4LPENR_LPTIM4LPEN_Msk = 0x800
	// Bit LPTIM4LPEN.
	RCC_APB4LPENR_LPTIM4LPEN = 0x800
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_LPTIM4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_LPTIM4LPEN_Enabled = 0x1
	// Position of LPTIM5LPEN field.
	RCC_APB4LPENR_LPTIM5LPEN_Pos = 0xc
	// Bit mask of LPTIM5LPEN field.
	RCC_APB4LPENR_LPTIM5LPEN_Msk = 0x1000
	// Bit LPTIM5LPEN.
	RCC_APB4LPENR_LPTIM5LPEN = 0x1000
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_LPTIM5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_LPTIM5LPEN_Enabled = 0x1
	// Position of COMP12LPEN field.
	RCC_APB4LPENR_COMP12LPEN_Pos = 0xe
	// Bit mask of COMP12LPEN field.
	RCC_APB4LPENR_COMP12LPEN_Msk = 0x4000
	// Bit COMP12LPEN.
	RCC_APB4LPENR_COMP12LPEN = 0x4000
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_COMP12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_COMP12LPEN_Enabled = 0x1
	// Position of VREFLPEN field.
	RCC_APB4LPENR_VREFLPEN_Pos = 0xf
	// Bit mask of VREFLPEN field.
	RCC_APB4LPENR_VREFLPEN_Msk = 0x8000
	// Bit VREFLPEN.
	RCC_APB4LPENR_VREFLPEN = 0x8000
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_VREFLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_VREFLPEN_Enabled = 0x1
	// Position of RTCAPBLPEN field.
	RCC_APB4LPENR_RTCAPBLPEN_Pos = 0x10
	// Bit mask of RTCAPBLPEN field.
	RCC_APB4LPENR_RTCAPBLPEN_Msk = 0x10000
	// Bit RTCAPBLPEN.
	RCC_APB4LPENR_RTCAPBLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_RTCAPBLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_RTCAPBLPEN_Enabled = 0x1
	// Position of SAI4LPEN field.
	RCC_APB4LPENR_SAI4LPEN_Pos = 0x15
	// Bit mask of SAI4LPEN field.
	RCC_APB4LPENR_SAI4LPEN_Msk = 0x200000
	// Bit SAI4LPEN.
	RCC_APB4LPENR_SAI4LPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_SAI4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_SAI4LPEN_Enabled = 0x1
	// Position of DTSLPEN field.
	RCC_APB4LPENR_DTSLPEN_Pos = 0x1a
	// Bit mask of DTSLPEN field.
	RCC_APB4LPENR_DTSLPEN_Msk = 0x4000000
	// Bit DTSLPEN.
	RCC_APB4LPENR_DTSLPEN = 0x4000000
	// The selected clock is disabled during csleep mode
	RCC_APB4LPENR_DTSLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_APB4LPENR_DTSLPEN_Enabled = 0x1

	// C1_RSR: RCC Reset Status Register
	// Position of RMVF field.
	RCC_C1_RSR_RMVF_Pos = 0x10
	// Bit mask of RMVF field.
	RCC_C1_RSR_RMVF_Msk = 0x10000
	// Bit RMVF.
	RCC_C1_RSR_RMVF = 0x10000
	// Not clearing the the reset flags
	RCC_C1_RSR_RMVF_NotActive = 0x0
	// Clear the reset flags
	RCC_C1_RSR_RMVF_Clear = 0x1
	// Position of CPURSTF field.
	RCC_C1_RSR_CPURSTF_Pos = 0x11
	// Bit mask of CPURSTF field.
	RCC_C1_RSR_CPURSTF_Msk = 0x20000
	// Bit CPURSTF.
	RCC_C1_RSR_CPURSTF = 0x20000
	// No reset occoured for block
	RCC_C1_RSR_CPURSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_CPURSTF_ResetOccourred = 0x1
	// Position of D1RSTF field.
	RCC_C1_RSR_D1RSTF_Pos = 0x13
	// Bit mask of D1RSTF field.
	RCC_C1_RSR_D1RSTF_Msk = 0x80000
	// Bit D1RSTF.
	RCC_C1_RSR_D1RSTF = 0x80000
	// No reset occoured for block
	RCC_C1_RSR_D1RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_D1RSTF_ResetOccourred = 0x1
	// Position of D2RSTF field.
	RCC_C1_RSR_D2RSTF_Pos = 0x14
	// Bit mask of D2RSTF field.
	RCC_C1_RSR_D2RSTF_Msk = 0x100000
	// Bit D2RSTF.
	RCC_C1_RSR_D2RSTF = 0x100000
	// No reset occoured for block
	RCC_C1_RSR_D2RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_D2RSTF_ResetOccourred = 0x1
	// Position of BORRSTF field.
	RCC_C1_RSR_BORRSTF_Pos = 0x15
	// Bit mask of BORRSTF field.
	RCC_C1_RSR_BORRSTF_Msk = 0x200000
	// Bit BORRSTF.
	RCC_C1_RSR_BORRSTF = 0x200000
	// No reset occoured for block
	RCC_C1_RSR_BORRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_BORRSTF_ResetOccourred = 0x1
	// Position of PINRSTF field.
	RCC_C1_RSR_PINRSTF_Pos = 0x16
	// Bit mask of PINRSTF field.
	RCC_C1_RSR_PINRSTF_Msk = 0x400000
	// Bit PINRSTF.
	RCC_C1_RSR_PINRSTF = 0x400000
	// No reset occoured for block
	RCC_C1_RSR_PINRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_PINRSTF_ResetOccourred = 0x1
	// Position of PORRSTF field.
	RCC_C1_RSR_PORRSTF_Pos = 0x17
	// Bit mask of PORRSTF field.
	RCC_C1_RSR_PORRSTF_Msk = 0x800000
	// Bit PORRSTF.
	RCC_C1_RSR_PORRSTF = 0x800000
	// No reset occoured for block
	RCC_C1_RSR_PORRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_PORRSTF_ResetOccourred = 0x1
	// Position of SFTRSTF field.
	RCC_C1_RSR_SFTRSTF_Pos = 0x18
	// Bit mask of SFTRSTF field.
	RCC_C1_RSR_SFTRSTF_Msk = 0x1000000
	// Bit SFTRSTF.
	RCC_C1_RSR_SFTRSTF = 0x1000000
	// No reset occoured for block
	RCC_C1_RSR_SFTRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_SFTRSTF_ResetOccourred = 0x1
	// Position of IWDG1RSTF field.
	RCC_C1_RSR_IWDG1RSTF_Pos = 0x1a
	// Bit mask of IWDG1RSTF field.
	RCC_C1_RSR_IWDG1RSTF_Msk = 0x4000000
	// Bit IWDG1RSTF.
	RCC_C1_RSR_IWDG1RSTF = 0x4000000
	// No reset occoured for block
	RCC_C1_RSR_IWDG1RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_IWDG1RSTF_ResetOccourred = 0x1
	// Position of WWDG1RSTF field.
	RCC_C1_RSR_WWDG1RSTF_Pos = 0x1c
	// Bit mask of WWDG1RSTF field.
	RCC_C1_RSR_WWDG1RSTF_Msk = 0x10000000
	// Bit WWDG1RSTF.
	RCC_C1_RSR_WWDG1RSTF = 0x10000000
	// No reset occoured for block
	RCC_C1_RSR_WWDG1RSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_WWDG1RSTF_ResetOccourred = 0x1
	// Position of LPWRRSTF field.
	RCC_C1_RSR_LPWRRSTF_Pos = 0x1e
	// Bit mask of LPWRRSTF field.
	RCC_C1_RSR_LPWRRSTF_Msk = 0x40000000
	// Bit LPWRRSTF.
	RCC_C1_RSR_LPWRRSTF = 0x40000000
	// No reset occoured for block
	RCC_C1_RSR_LPWRRSTF_NoResetOccoured = 0x0
	// Reset occoured for block
	RCC_C1_RSR_LPWRRSTF_ResetOccourred = 0x1

	// C1_AHB3ENR: RCC AHB3 Clock Register
	// Position of MDMAEN field.
	RCC_C1_AHB3ENR_MDMAEN_Pos = 0x0
	// Bit mask of MDMAEN field.
	RCC_C1_AHB3ENR_MDMAEN_Msk = 0x1
	// Bit MDMAEN.
	RCC_C1_AHB3ENR_MDMAEN = 0x1
	// The selected clock is disabled
	RCC_C1_AHB3ENR_MDMAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB3ENR_MDMAEN_Enabled = 0x1
	// Position of DMA2DEN field.
	RCC_C1_AHB3ENR_DMA2DEN_Pos = 0x4
	// Bit mask of DMA2DEN field.
	RCC_C1_AHB3ENR_DMA2DEN_Msk = 0x10
	// Bit DMA2DEN.
	RCC_C1_AHB3ENR_DMA2DEN = 0x10
	// The selected clock is disabled
	RCC_C1_AHB3ENR_DMA2DEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB3ENR_DMA2DEN_Enabled = 0x1
	// Position of JPGDECEN field.
	RCC_C1_AHB3ENR_JPGDECEN_Pos = 0x5
	// Bit mask of JPGDECEN field.
	RCC_C1_AHB3ENR_JPGDECEN_Msk = 0x20
	// Bit JPGDECEN.
	RCC_C1_AHB3ENR_JPGDECEN = 0x20
	// The selected clock is disabled
	RCC_C1_AHB3ENR_JPGDECEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB3ENR_JPGDECEN_Enabled = 0x1
	// Position of FMCEN field.
	RCC_C1_AHB3ENR_FMCEN_Pos = 0xc
	// Bit mask of FMCEN field.
	RCC_C1_AHB3ENR_FMCEN_Msk = 0x1000
	// Bit FMCEN.
	RCC_C1_AHB3ENR_FMCEN = 0x1000
	// The selected clock is disabled
	RCC_C1_AHB3ENR_FMCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB3ENR_FMCEN_Enabled = 0x1
	// Position of QSPIEN field.
	RCC_C1_AHB3ENR_QSPIEN_Pos = 0xe
	// Bit mask of QSPIEN field.
	RCC_C1_AHB3ENR_QSPIEN_Msk = 0x4000
	// Bit QSPIEN.
	RCC_C1_AHB3ENR_QSPIEN = 0x4000
	// The selected clock is disabled
	RCC_C1_AHB3ENR_QSPIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB3ENR_QSPIEN_Enabled = 0x1
	// Position of SDMMC1EN field.
	RCC_C1_AHB3ENR_SDMMC1EN_Pos = 0x10
	// Bit mask of SDMMC1EN field.
	RCC_C1_AHB3ENR_SDMMC1EN_Msk = 0x10000
	// Bit SDMMC1EN.
	RCC_C1_AHB3ENR_SDMMC1EN = 0x10000
	// The selected clock is disabled
	RCC_C1_AHB3ENR_SDMMC1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB3ENR_SDMMC1EN_Enabled = 0x1

	// C1_AHB1ENR: RCC AHB1 Clock Register
	// Position of DMA1EN field.
	RCC_C1_AHB1ENR_DMA1EN_Pos = 0x0
	// Bit mask of DMA1EN field.
	RCC_C1_AHB1ENR_DMA1EN_Msk = 0x1
	// Bit DMA1EN.
	RCC_C1_AHB1ENR_DMA1EN = 0x1
	// The selected clock is disabled
	RCC_C1_AHB1ENR_DMA1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_DMA1EN_Enabled = 0x1
	// Position of DMA2EN field.
	RCC_C1_AHB1ENR_DMA2EN_Pos = 0x1
	// Bit mask of DMA2EN field.
	RCC_C1_AHB1ENR_DMA2EN_Msk = 0x2
	// Bit DMA2EN.
	RCC_C1_AHB1ENR_DMA2EN = 0x2
	// The selected clock is disabled
	RCC_C1_AHB1ENR_DMA2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_DMA2EN_Enabled = 0x1
	// Position of ADC12EN field.
	RCC_C1_AHB1ENR_ADC12EN_Pos = 0x5
	// Bit mask of ADC12EN field.
	RCC_C1_AHB1ENR_ADC12EN_Msk = 0x20
	// Bit ADC12EN.
	RCC_C1_AHB1ENR_ADC12EN = 0x20
	// The selected clock is disabled
	RCC_C1_AHB1ENR_ADC12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_ADC12EN_Enabled = 0x1
	// Position of ETH1MACEN field.
	RCC_C1_AHB1ENR_ETH1MACEN_Pos = 0xf
	// Bit mask of ETH1MACEN field.
	RCC_C1_AHB1ENR_ETH1MACEN_Msk = 0x8000
	// Bit ETH1MACEN.
	RCC_C1_AHB1ENR_ETH1MACEN = 0x8000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_ETH1MACEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_ETH1MACEN_Enabled = 0x1
	// Position of ETH1TXEN field.
	RCC_C1_AHB1ENR_ETH1TXEN_Pos = 0x10
	// Bit mask of ETH1TXEN field.
	RCC_C1_AHB1ENR_ETH1TXEN_Msk = 0x10000
	// Bit ETH1TXEN.
	RCC_C1_AHB1ENR_ETH1TXEN = 0x10000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_ETH1TXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_ETH1TXEN_Enabled = 0x1
	// Position of ETH1RXEN field.
	RCC_C1_AHB1ENR_ETH1RXEN_Pos = 0x11
	// Bit mask of ETH1RXEN field.
	RCC_C1_AHB1ENR_ETH1RXEN_Msk = 0x20000
	// Bit ETH1RXEN.
	RCC_C1_AHB1ENR_ETH1RXEN = 0x20000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_ETH1RXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_ETH1RXEN_Enabled = 0x1
	// Position of USB1OTGEN field.
	RCC_C1_AHB1ENR_USB1OTGEN_Pos = 0x19
	// Bit mask of USB1OTGEN field.
	RCC_C1_AHB1ENR_USB1OTGEN_Msk = 0x2000000
	// Bit USB1OTGEN.
	RCC_C1_AHB1ENR_USB1OTGEN = 0x2000000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_USB1OTGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_USB1OTGEN_Enabled = 0x1
	// Position of USB1ULPIEN field.
	RCC_C1_AHB1ENR_USB1ULPIEN_Pos = 0x1a
	// Bit mask of USB1ULPIEN field.
	RCC_C1_AHB1ENR_USB1ULPIEN_Msk = 0x4000000
	// Bit USB1ULPIEN.
	RCC_C1_AHB1ENR_USB1ULPIEN = 0x4000000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_USB1ULPIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_USB1ULPIEN_Enabled = 0x1
	// Position of USB2OTGEN field.
	RCC_C1_AHB1ENR_USB2OTGEN_Pos = 0x1b
	// Bit mask of USB2OTGEN field.
	RCC_C1_AHB1ENR_USB2OTGEN_Msk = 0x8000000
	// Bit USB2OTGEN.
	RCC_C1_AHB1ENR_USB2OTGEN = 0x8000000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_USB2OTGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_USB2OTGEN_Enabled = 0x1
	// Position of USB2ULPIEN field.
	RCC_C1_AHB1ENR_USB2ULPIEN_Pos = 0x1c
	// Bit mask of USB2ULPIEN field.
	RCC_C1_AHB1ENR_USB2ULPIEN_Msk = 0x10000000
	// Bit USB2ULPIEN.
	RCC_C1_AHB1ENR_USB2ULPIEN = 0x10000000
	// The selected clock is disabled
	RCC_C1_AHB1ENR_USB2ULPIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB1ENR_USB2ULPIEN_Enabled = 0x1

	// C1_AHB2ENR: RCC AHB2 Clock Register
	// Position of DCMIEN field.
	RCC_C1_AHB2ENR_DCMIEN_Pos = 0x0
	// Bit mask of DCMIEN field.
	RCC_C1_AHB2ENR_DCMIEN_Msk = 0x1
	// Bit DCMIEN.
	RCC_C1_AHB2ENR_DCMIEN = 0x1
	// The selected clock is disabled
	RCC_C1_AHB2ENR_DCMIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_DCMIEN_Enabled = 0x1
	// Position of CRYPTEN field.
	RCC_C1_AHB2ENR_CRYPTEN_Pos = 0x4
	// Bit mask of CRYPTEN field.
	RCC_C1_AHB2ENR_CRYPTEN_Msk = 0x10
	// Bit CRYPTEN.
	RCC_C1_AHB2ENR_CRYPTEN = 0x10
	// The selected clock is disabled
	RCC_C1_AHB2ENR_CRYPTEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_CRYPTEN_Enabled = 0x1
	// Position of HASHEN field.
	RCC_C1_AHB2ENR_HASHEN_Pos = 0x5
	// Bit mask of HASHEN field.
	RCC_C1_AHB2ENR_HASHEN_Msk = 0x20
	// Bit HASHEN.
	RCC_C1_AHB2ENR_HASHEN = 0x20
	// The selected clock is disabled
	RCC_C1_AHB2ENR_HASHEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_HASHEN_Enabled = 0x1
	// Position of RNGEN field.
	RCC_C1_AHB2ENR_RNGEN_Pos = 0x6
	// Bit mask of RNGEN field.
	RCC_C1_AHB2ENR_RNGEN_Msk = 0x40
	// Bit RNGEN.
	RCC_C1_AHB2ENR_RNGEN = 0x40
	// The selected clock is disabled
	RCC_C1_AHB2ENR_RNGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_RNGEN_Enabled = 0x1
	// Position of SDMMC2EN field.
	RCC_C1_AHB2ENR_SDMMC2EN_Pos = 0x9
	// Bit mask of SDMMC2EN field.
	RCC_C1_AHB2ENR_SDMMC2EN_Msk = 0x200
	// Bit SDMMC2EN.
	RCC_C1_AHB2ENR_SDMMC2EN = 0x200
	// The selected clock is disabled
	RCC_C1_AHB2ENR_SDMMC2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_SDMMC2EN_Enabled = 0x1
	// Position of SRAM1EN field.
	RCC_C1_AHB2ENR_SRAM1EN_Pos = 0x1d
	// Bit mask of SRAM1EN field.
	RCC_C1_AHB2ENR_SRAM1EN_Msk = 0x20000000
	// Bit SRAM1EN.
	RCC_C1_AHB2ENR_SRAM1EN = 0x20000000
	// The selected clock is disabled
	RCC_C1_AHB2ENR_SRAM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_SRAM1EN_Enabled = 0x1
	// Position of SRAM2EN field.
	RCC_C1_AHB2ENR_SRAM2EN_Pos = 0x1e
	// Bit mask of SRAM2EN field.
	RCC_C1_AHB2ENR_SRAM2EN_Msk = 0x40000000
	// Bit SRAM2EN.
	RCC_C1_AHB2ENR_SRAM2EN = 0x40000000
	// The selected clock is disabled
	RCC_C1_AHB2ENR_SRAM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_SRAM2EN_Enabled = 0x1
	// Position of SRAM3EN field.
	RCC_C1_AHB2ENR_SRAM3EN_Pos = 0x1f
	// Bit mask of SRAM3EN field.
	RCC_C1_AHB2ENR_SRAM3EN_Msk = 0x80000000
	// Bit SRAM3EN.
	RCC_C1_AHB2ENR_SRAM3EN = 0x80000000
	// The selected clock is disabled
	RCC_C1_AHB2ENR_SRAM3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB2ENR_SRAM3EN_Enabled = 0x1

	// C1_AHB4ENR: RCC AHB4 Clock Register
	// Position of GPIOAEN field.
	RCC_C1_AHB4ENR_GPIOAEN_Pos = 0x0
	// Bit mask of GPIOAEN field.
	RCC_C1_AHB4ENR_GPIOAEN_Msk = 0x1
	// Bit GPIOAEN.
	RCC_C1_AHB4ENR_GPIOAEN = 0x1
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOAEN_Enabled = 0x1
	// Position of GPIOBEN field.
	RCC_C1_AHB4ENR_GPIOBEN_Pos = 0x1
	// Bit mask of GPIOBEN field.
	RCC_C1_AHB4ENR_GPIOBEN_Msk = 0x2
	// Bit GPIOBEN.
	RCC_C1_AHB4ENR_GPIOBEN = 0x2
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOBEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOBEN_Enabled = 0x1
	// Position of GPIOCEN field.
	RCC_C1_AHB4ENR_GPIOCEN_Pos = 0x2
	// Bit mask of GPIOCEN field.
	RCC_C1_AHB4ENR_GPIOCEN_Msk = 0x4
	// Bit GPIOCEN.
	RCC_C1_AHB4ENR_GPIOCEN = 0x4
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOCEN_Enabled = 0x1
	// Position of GPIODEN field.
	RCC_C1_AHB4ENR_GPIODEN_Pos = 0x3
	// Bit mask of GPIODEN field.
	RCC_C1_AHB4ENR_GPIODEN_Msk = 0x8
	// Bit GPIODEN.
	RCC_C1_AHB4ENR_GPIODEN = 0x8
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIODEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIODEN_Enabled = 0x1
	// Position of GPIOEEN field.
	RCC_C1_AHB4ENR_GPIOEEN_Pos = 0x4
	// Bit mask of GPIOEEN field.
	RCC_C1_AHB4ENR_GPIOEEN_Msk = 0x10
	// Bit GPIOEEN.
	RCC_C1_AHB4ENR_GPIOEEN = 0x10
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOEEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOEEN_Enabled = 0x1
	// Position of GPIOFEN field.
	RCC_C1_AHB4ENR_GPIOFEN_Pos = 0x5
	// Bit mask of GPIOFEN field.
	RCC_C1_AHB4ENR_GPIOFEN_Msk = 0x20
	// Bit GPIOFEN.
	RCC_C1_AHB4ENR_GPIOFEN = 0x20
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOFEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOFEN_Enabled = 0x1
	// Position of GPIOGEN field.
	RCC_C1_AHB4ENR_GPIOGEN_Pos = 0x6
	// Bit mask of GPIOGEN field.
	RCC_C1_AHB4ENR_GPIOGEN_Msk = 0x40
	// Bit GPIOGEN.
	RCC_C1_AHB4ENR_GPIOGEN = 0x40
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOGEN_Enabled = 0x1
	// Position of GPIOHEN field.
	RCC_C1_AHB4ENR_GPIOHEN_Pos = 0x7
	// Bit mask of GPIOHEN field.
	RCC_C1_AHB4ENR_GPIOHEN_Msk = 0x80
	// Bit GPIOHEN.
	RCC_C1_AHB4ENR_GPIOHEN = 0x80
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOHEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOHEN_Enabled = 0x1
	// Position of GPIOIEN field.
	RCC_C1_AHB4ENR_GPIOIEN_Pos = 0x8
	// Bit mask of GPIOIEN field.
	RCC_C1_AHB4ENR_GPIOIEN_Msk = 0x100
	// Bit GPIOIEN.
	RCC_C1_AHB4ENR_GPIOIEN = 0x100
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOIEN_Enabled = 0x1
	// Position of GPIOJEN field.
	RCC_C1_AHB4ENR_GPIOJEN_Pos = 0x9
	// Bit mask of GPIOJEN field.
	RCC_C1_AHB4ENR_GPIOJEN_Msk = 0x200
	// Bit GPIOJEN.
	RCC_C1_AHB4ENR_GPIOJEN = 0x200
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOJEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOJEN_Enabled = 0x1
	// Position of GPIOKEN field.
	RCC_C1_AHB4ENR_GPIOKEN_Pos = 0xa
	// Bit mask of GPIOKEN field.
	RCC_C1_AHB4ENR_GPIOKEN_Msk = 0x400
	// Bit GPIOKEN.
	RCC_C1_AHB4ENR_GPIOKEN = 0x400
	// The selected clock is disabled
	RCC_C1_AHB4ENR_GPIOKEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_GPIOKEN_Enabled = 0x1
	// Position of CRCEN field.
	RCC_C1_AHB4ENR_CRCEN_Pos = 0x13
	// Bit mask of CRCEN field.
	RCC_C1_AHB4ENR_CRCEN_Msk = 0x80000
	// Bit CRCEN.
	RCC_C1_AHB4ENR_CRCEN = 0x80000
	// The selected clock is disabled
	RCC_C1_AHB4ENR_CRCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_CRCEN_Enabled = 0x1
	// Position of BDMAEN field.
	RCC_C1_AHB4ENR_BDMAEN_Pos = 0x15
	// Bit mask of BDMAEN field.
	RCC_C1_AHB4ENR_BDMAEN_Msk = 0x200000
	// Bit BDMAEN.
	RCC_C1_AHB4ENR_BDMAEN = 0x200000
	// The selected clock is disabled
	RCC_C1_AHB4ENR_BDMAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_BDMAEN_Enabled = 0x1
	// Position of ADC3EN field.
	RCC_C1_AHB4ENR_ADC3EN_Pos = 0x18
	// Bit mask of ADC3EN field.
	RCC_C1_AHB4ENR_ADC3EN_Msk = 0x1000000
	// Bit ADC3EN.
	RCC_C1_AHB4ENR_ADC3EN = 0x1000000
	// The selected clock is disabled
	RCC_C1_AHB4ENR_ADC3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_ADC3EN_Enabled = 0x1
	// Position of HSEMEN field.
	RCC_C1_AHB4ENR_HSEMEN_Pos = 0x19
	// Bit mask of HSEMEN field.
	RCC_C1_AHB4ENR_HSEMEN_Msk = 0x2000000
	// Bit HSEMEN.
	RCC_C1_AHB4ENR_HSEMEN = 0x2000000
	// The selected clock is disabled
	RCC_C1_AHB4ENR_HSEMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_HSEMEN_Enabled = 0x1
	// Position of BKPRAMEN field.
	RCC_C1_AHB4ENR_BKPRAMEN_Pos = 0x1c
	// Bit mask of BKPRAMEN field.
	RCC_C1_AHB4ENR_BKPRAMEN_Msk = 0x10000000
	// Bit BKPRAMEN.
	RCC_C1_AHB4ENR_BKPRAMEN = 0x10000000
	// The selected clock is disabled
	RCC_C1_AHB4ENR_BKPRAMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_AHB4ENR_BKPRAMEN_Enabled = 0x1

	// C1_APB3ENR: RCC APB3 Clock Register
	// Position of LTDCEN field.
	RCC_C1_APB3ENR_LTDCEN_Pos = 0x3
	// Bit mask of LTDCEN field.
	RCC_C1_APB3ENR_LTDCEN_Msk = 0x8
	// Bit LTDCEN.
	RCC_C1_APB3ENR_LTDCEN = 0x8
	// The selected clock is disabled
	RCC_C1_APB3ENR_LTDCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB3ENR_LTDCEN_Enabled = 0x1
	// Position of WWDG1EN field.
	RCC_C1_APB3ENR_WWDG1EN_Pos = 0x6
	// Bit mask of WWDG1EN field.
	RCC_C1_APB3ENR_WWDG1EN_Msk = 0x40
	// Bit WWDG1EN.
	RCC_C1_APB3ENR_WWDG1EN = 0x40
	// The selected clock is disabled
	RCC_C1_APB3ENR_WWDG1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB3ENR_WWDG1EN_Enabled = 0x1

	// C1_APB1LENR: RCC APB1 Clock Register
	// Position of TIM2EN field.
	RCC_C1_APB1LENR_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_C1_APB1LENR_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_C1_APB1LENR_TIM2EN = 0x1
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM2EN_Enabled = 0x1
	// Position of TIM3EN field.
	RCC_C1_APB1LENR_TIM3EN_Pos = 0x1
	// Bit mask of TIM3EN field.
	RCC_C1_APB1LENR_TIM3EN_Msk = 0x2
	// Bit TIM3EN.
	RCC_C1_APB1LENR_TIM3EN = 0x2
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM3EN_Enabled = 0x1
	// Position of TIM4EN field.
	RCC_C1_APB1LENR_TIM4EN_Pos = 0x2
	// Bit mask of TIM4EN field.
	RCC_C1_APB1LENR_TIM4EN_Msk = 0x4
	// Bit TIM4EN.
	RCC_C1_APB1LENR_TIM4EN = 0x4
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM4EN_Enabled = 0x1
	// Position of TIM5EN field.
	RCC_C1_APB1LENR_TIM5EN_Pos = 0x3
	// Bit mask of TIM5EN field.
	RCC_C1_APB1LENR_TIM5EN_Msk = 0x8
	// Bit TIM5EN.
	RCC_C1_APB1LENR_TIM5EN = 0x8
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM5EN_Enabled = 0x1
	// Position of TIM6EN field.
	RCC_C1_APB1LENR_TIM6EN_Pos = 0x4
	// Bit mask of TIM6EN field.
	RCC_C1_APB1LENR_TIM6EN_Msk = 0x10
	// Bit TIM6EN.
	RCC_C1_APB1LENR_TIM6EN = 0x10
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM6EN_Enabled = 0x1
	// Position of TIM7EN field.
	RCC_C1_APB1LENR_TIM7EN_Pos = 0x5
	// Bit mask of TIM7EN field.
	RCC_C1_APB1LENR_TIM7EN_Msk = 0x20
	// Bit TIM7EN.
	RCC_C1_APB1LENR_TIM7EN = 0x20
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM7EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM7EN_Enabled = 0x1
	// Position of TIM12EN field.
	RCC_C1_APB1LENR_TIM12EN_Pos = 0x6
	// Bit mask of TIM12EN field.
	RCC_C1_APB1LENR_TIM12EN_Msk = 0x40
	// Bit TIM12EN.
	RCC_C1_APB1LENR_TIM12EN = 0x40
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM12EN_Enabled = 0x1
	// Position of TIM13EN field.
	RCC_C1_APB1LENR_TIM13EN_Pos = 0x7
	// Bit mask of TIM13EN field.
	RCC_C1_APB1LENR_TIM13EN_Msk = 0x80
	// Bit TIM13EN.
	RCC_C1_APB1LENR_TIM13EN = 0x80
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM13EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM13EN_Enabled = 0x1
	// Position of TIM14EN field.
	RCC_C1_APB1LENR_TIM14EN_Pos = 0x8
	// Bit mask of TIM14EN field.
	RCC_C1_APB1LENR_TIM14EN_Msk = 0x100
	// Bit TIM14EN.
	RCC_C1_APB1LENR_TIM14EN = 0x100
	// The selected clock is disabled
	RCC_C1_APB1LENR_TIM14EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_TIM14EN_Enabled = 0x1
	// Position of LPTIM1EN field.
	RCC_C1_APB1LENR_LPTIM1EN_Pos = 0x9
	// Bit mask of LPTIM1EN field.
	RCC_C1_APB1LENR_LPTIM1EN_Msk = 0x200
	// Bit LPTIM1EN.
	RCC_C1_APB1LENR_LPTIM1EN = 0x200
	// The selected clock is disabled
	RCC_C1_APB1LENR_LPTIM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_LPTIM1EN_Enabled = 0x1
	// Position of SPI2EN field.
	RCC_C1_APB1LENR_SPI2EN_Pos = 0xe
	// Bit mask of SPI2EN field.
	RCC_C1_APB1LENR_SPI2EN_Msk = 0x4000
	// Bit SPI2EN.
	RCC_C1_APB1LENR_SPI2EN = 0x4000
	// The selected clock is disabled
	RCC_C1_APB1LENR_SPI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_SPI2EN_Enabled = 0x1
	// Position of SPI3EN field.
	RCC_C1_APB1LENR_SPI3EN_Pos = 0xf
	// Bit mask of SPI3EN field.
	RCC_C1_APB1LENR_SPI3EN_Msk = 0x8000
	// Bit SPI3EN.
	RCC_C1_APB1LENR_SPI3EN = 0x8000
	// The selected clock is disabled
	RCC_C1_APB1LENR_SPI3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_SPI3EN_Enabled = 0x1
	// Position of SPDIFRXEN field.
	RCC_C1_APB1LENR_SPDIFRXEN_Pos = 0x10
	// Bit mask of SPDIFRXEN field.
	RCC_C1_APB1LENR_SPDIFRXEN_Msk = 0x10000
	// Bit SPDIFRXEN.
	RCC_C1_APB1LENR_SPDIFRXEN = 0x10000
	// The selected clock is disabled
	RCC_C1_APB1LENR_SPDIFRXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_SPDIFRXEN_Enabled = 0x1
	// Position of USART2EN field.
	RCC_C1_APB1LENR_USART2EN_Pos = 0x11
	// Bit mask of USART2EN field.
	RCC_C1_APB1LENR_USART2EN_Msk = 0x20000
	// Bit USART2EN.
	RCC_C1_APB1LENR_USART2EN = 0x20000
	// The selected clock is disabled
	RCC_C1_APB1LENR_USART2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_USART2EN_Enabled = 0x1
	// Position of USART3EN field.
	RCC_C1_APB1LENR_USART3EN_Pos = 0x12
	// Bit mask of USART3EN field.
	RCC_C1_APB1LENR_USART3EN_Msk = 0x40000
	// Bit USART3EN.
	RCC_C1_APB1LENR_USART3EN = 0x40000
	// The selected clock is disabled
	RCC_C1_APB1LENR_USART3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_USART3EN_Enabled = 0x1
	// Position of UART4EN field.
	RCC_C1_APB1LENR_UART4EN_Pos = 0x13
	// Bit mask of UART4EN field.
	RCC_C1_APB1LENR_UART4EN_Msk = 0x80000
	// Bit UART4EN.
	RCC_C1_APB1LENR_UART4EN = 0x80000
	// The selected clock is disabled
	RCC_C1_APB1LENR_UART4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_UART4EN_Enabled = 0x1
	// Position of UART5EN field.
	RCC_C1_APB1LENR_UART5EN_Pos = 0x14
	// Bit mask of UART5EN field.
	RCC_C1_APB1LENR_UART5EN_Msk = 0x100000
	// Bit UART5EN.
	RCC_C1_APB1LENR_UART5EN = 0x100000
	// The selected clock is disabled
	RCC_C1_APB1LENR_UART5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_UART5EN_Enabled = 0x1
	// Position of I2C1EN field.
	RCC_C1_APB1LENR_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_C1_APB1LENR_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_C1_APB1LENR_I2C1EN = 0x200000
	// The selected clock is disabled
	RCC_C1_APB1LENR_I2C1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_I2C1EN_Enabled = 0x1
	// Position of I2C2EN field.
	RCC_C1_APB1LENR_I2C2EN_Pos = 0x16
	// Bit mask of I2C2EN field.
	RCC_C1_APB1LENR_I2C2EN_Msk = 0x400000
	// Bit I2C2EN.
	RCC_C1_APB1LENR_I2C2EN = 0x400000
	// The selected clock is disabled
	RCC_C1_APB1LENR_I2C2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_I2C2EN_Enabled = 0x1
	// Position of I2C3EN field.
	RCC_C1_APB1LENR_I2C3EN_Pos = 0x17
	// Bit mask of I2C3EN field.
	RCC_C1_APB1LENR_I2C3EN_Msk = 0x800000
	// Bit I2C3EN.
	RCC_C1_APB1LENR_I2C3EN = 0x800000
	// The selected clock is disabled
	RCC_C1_APB1LENR_I2C3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_I2C3EN_Enabled = 0x1
	// Position of CECEN field.
	RCC_C1_APB1LENR_CECEN_Pos = 0x1b
	// Bit mask of CECEN field.
	RCC_C1_APB1LENR_CECEN_Msk = 0x8000000
	// Bit CECEN.
	RCC_C1_APB1LENR_CECEN = 0x8000000
	// The selected clock is disabled
	RCC_C1_APB1LENR_CECEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_CECEN_Enabled = 0x1
	// Position of DAC12EN field.
	RCC_C1_APB1LENR_DAC12EN_Pos = 0x1d
	// Bit mask of DAC12EN field.
	RCC_C1_APB1LENR_DAC12EN_Msk = 0x20000000
	// Bit DAC12EN.
	RCC_C1_APB1LENR_DAC12EN = 0x20000000
	// The selected clock is disabled
	RCC_C1_APB1LENR_DAC12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_DAC12EN_Enabled = 0x1
	// Position of UART7EN field.
	RCC_C1_APB1LENR_UART7EN_Pos = 0x1e
	// Bit mask of UART7EN field.
	RCC_C1_APB1LENR_UART7EN_Msk = 0x40000000
	// Bit UART7EN.
	RCC_C1_APB1LENR_UART7EN = 0x40000000
	// The selected clock is disabled
	RCC_C1_APB1LENR_UART7EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_UART7EN_Enabled = 0x1
	// Position of UART8EN field.
	RCC_C1_APB1LENR_UART8EN_Pos = 0x1f
	// Bit mask of UART8EN field.
	RCC_C1_APB1LENR_UART8EN_Msk = 0x80000000
	// Bit UART8EN.
	RCC_C1_APB1LENR_UART8EN = 0x80000000
	// The selected clock is disabled
	RCC_C1_APB1LENR_UART8EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1LENR_UART8EN_Enabled = 0x1

	// C1_APB1HENR: RCC APB1 Clock Register
	// Position of CRSEN field.
	RCC_C1_APB1HENR_CRSEN_Pos = 0x1
	// Bit mask of CRSEN field.
	RCC_C1_APB1HENR_CRSEN_Msk = 0x2
	// Bit CRSEN.
	RCC_C1_APB1HENR_CRSEN = 0x2
	// The selected clock is disabled
	RCC_C1_APB1HENR_CRSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1HENR_CRSEN_Enabled = 0x1
	// Position of SWPEN field.
	RCC_C1_APB1HENR_SWPEN_Pos = 0x2
	// Bit mask of SWPEN field.
	RCC_C1_APB1HENR_SWPEN_Msk = 0x4
	// Bit SWPEN.
	RCC_C1_APB1HENR_SWPEN = 0x4
	// The selected clock is disabled
	RCC_C1_APB1HENR_SWPEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1HENR_SWPEN_Enabled = 0x1
	// Position of OPAMPEN field.
	RCC_C1_APB1HENR_OPAMPEN_Pos = 0x4
	// Bit mask of OPAMPEN field.
	RCC_C1_APB1HENR_OPAMPEN_Msk = 0x10
	// Bit OPAMPEN.
	RCC_C1_APB1HENR_OPAMPEN = 0x10
	// The selected clock is disabled
	RCC_C1_APB1HENR_OPAMPEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1HENR_OPAMPEN_Enabled = 0x1
	// Position of MDIOSEN field.
	RCC_C1_APB1HENR_MDIOSEN_Pos = 0x5
	// Bit mask of MDIOSEN field.
	RCC_C1_APB1HENR_MDIOSEN_Msk = 0x20
	// Bit MDIOSEN.
	RCC_C1_APB1HENR_MDIOSEN = 0x20
	// The selected clock is disabled
	RCC_C1_APB1HENR_MDIOSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1HENR_MDIOSEN_Enabled = 0x1
	// Position of FDCANEN field.
	RCC_C1_APB1HENR_FDCANEN_Pos = 0x8
	// Bit mask of FDCANEN field.
	RCC_C1_APB1HENR_FDCANEN_Msk = 0x100
	// Bit FDCANEN.
	RCC_C1_APB1HENR_FDCANEN = 0x100
	// The selected clock is disabled
	RCC_C1_APB1HENR_FDCANEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB1HENR_FDCANEN_Enabled = 0x1

	// C1_APB2ENR: RCC APB2 Clock Register
	// Position of TIM1EN field.
	RCC_C1_APB2ENR_TIM1EN_Pos = 0x0
	// Bit mask of TIM1EN field.
	RCC_C1_APB2ENR_TIM1EN_Msk = 0x1
	// Bit TIM1EN.
	RCC_C1_APB2ENR_TIM1EN = 0x1
	// The selected clock is disabled
	RCC_C1_APB2ENR_TIM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_TIM1EN_Enabled = 0x1
	// Position of TIM8EN field.
	RCC_C1_APB2ENR_TIM8EN_Pos = 0x1
	// Bit mask of TIM8EN field.
	RCC_C1_APB2ENR_TIM8EN_Msk = 0x2
	// Bit TIM8EN.
	RCC_C1_APB2ENR_TIM8EN = 0x2
	// The selected clock is disabled
	RCC_C1_APB2ENR_TIM8EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_TIM8EN_Enabled = 0x1
	// Position of USART1EN field.
	RCC_C1_APB2ENR_USART1EN_Pos = 0x4
	// Bit mask of USART1EN field.
	RCC_C1_APB2ENR_USART1EN_Msk = 0x10
	// Bit USART1EN.
	RCC_C1_APB2ENR_USART1EN = 0x10
	// The selected clock is disabled
	RCC_C1_APB2ENR_USART1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_USART1EN_Enabled = 0x1
	// Position of USART6EN field.
	RCC_C1_APB2ENR_USART6EN_Pos = 0x5
	// Bit mask of USART6EN field.
	RCC_C1_APB2ENR_USART6EN_Msk = 0x20
	// Bit USART6EN.
	RCC_C1_APB2ENR_USART6EN = 0x20
	// The selected clock is disabled
	RCC_C1_APB2ENR_USART6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_USART6EN_Enabled = 0x1
	// Position of SPI1EN field.
	RCC_C1_APB2ENR_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_C1_APB2ENR_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_C1_APB2ENR_SPI1EN = 0x1000
	// The selected clock is disabled
	RCC_C1_APB2ENR_SPI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_SPI1EN_Enabled = 0x1
	// Position of SPI4EN field.
	RCC_C1_APB2ENR_SPI4EN_Pos = 0xd
	// Bit mask of SPI4EN field.
	RCC_C1_APB2ENR_SPI4EN_Msk = 0x2000
	// Bit SPI4EN.
	RCC_C1_APB2ENR_SPI4EN = 0x2000
	// The selected clock is disabled
	RCC_C1_APB2ENR_SPI4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_SPI4EN_Enabled = 0x1
	// Position of TIM16EN field.
	RCC_C1_APB2ENR_TIM16EN_Pos = 0x11
	// Bit mask of TIM16EN field.
	RCC_C1_APB2ENR_TIM16EN_Msk = 0x20000
	// Bit TIM16EN.
	RCC_C1_APB2ENR_TIM16EN = 0x20000
	// The selected clock is disabled
	RCC_C1_APB2ENR_TIM16EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_TIM16EN_Enabled = 0x1
	// Position of TIM15EN field.
	RCC_C1_APB2ENR_TIM15EN_Pos = 0x10
	// Bit mask of TIM15EN field.
	RCC_C1_APB2ENR_TIM15EN_Msk = 0x10000
	// Bit TIM15EN.
	RCC_C1_APB2ENR_TIM15EN = 0x10000
	// The selected clock is disabled
	RCC_C1_APB2ENR_TIM15EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_TIM15EN_Enabled = 0x1
	// Position of TIM17EN field.
	RCC_C1_APB2ENR_TIM17EN_Pos = 0x12
	// Bit mask of TIM17EN field.
	RCC_C1_APB2ENR_TIM17EN_Msk = 0x40000
	// Bit TIM17EN.
	RCC_C1_APB2ENR_TIM17EN = 0x40000
	// The selected clock is disabled
	RCC_C1_APB2ENR_TIM17EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_TIM17EN_Enabled = 0x1
	// Position of SPI5EN field.
	RCC_C1_APB2ENR_SPI5EN_Pos = 0x14
	// Bit mask of SPI5EN field.
	RCC_C1_APB2ENR_SPI5EN_Msk = 0x100000
	// Bit SPI5EN.
	RCC_C1_APB2ENR_SPI5EN = 0x100000
	// The selected clock is disabled
	RCC_C1_APB2ENR_SPI5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_SPI5EN_Enabled = 0x1
	// Position of SAI1EN field.
	RCC_C1_APB2ENR_SAI1EN_Pos = 0x16
	// Bit mask of SAI1EN field.
	RCC_C1_APB2ENR_SAI1EN_Msk = 0x400000
	// Bit SAI1EN.
	RCC_C1_APB2ENR_SAI1EN = 0x400000
	// The selected clock is disabled
	RCC_C1_APB2ENR_SAI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_SAI1EN_Enabled = 0x1
	// Position of SAI2EN field.
	RCC_C1_APB2ENR_SAI2EN_Pos = 0x17
	// Bit mask of SAI2EN field.
	RCC_C1_APB2ENR_SAI2EN_Msk = 0x800000
	// Bit SAI2EN.
	RCC_C1_APB2ENR_SAI2EN = 0x800000
	// The selected clock is disabled
	RCC_C1_APB2ENR_SAI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_SAI2EN_Enabled = 0x1
	// Position of SAI3EN field.
	RCC_C1_APB2ENR_SAI3EN_Pos = 0x18
	// Bit mask of SAI3EN field.
	RCC_C1_APB2ENR_SAI3EN_Msk = 0x1000000
	// Bit SAI3EN.
	RCC_C1_APB2ENR_SAI3EN = 0x1000000
	// The selected clock is disabled
	RCC_C1_APB2ENR_SAI3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_SAI3EN_Enabled = 0x1
	// Position of DFSDM1EN field.
	RCC_C1_APB2ENR_DFSDM1EN_Pos = 0x1c
	// Bit mask of DFSDM1EN field.
	RCC_C1_APB2ENR_DFSDM1EN_Msk = 0x10000000
	// Bit DFSDM1EN.
	RCC_C1_APB2ENR_DFSDM1EN = 0x10000000
	// The selected clock is disabled
	RCC_C1_APB2ENR_DFSDM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_DFSDM1EN_Enabled = 0x1
	// Position of HRTIMEN field.
	RCC_C1_APB2ENR_HRTIMEN_Pos = 0x1d
	// Bit mask of HRTIMEN field.
	RCC_C1_APB2ENR_HRTIMEN_Msk = 0x20000000
	// Bit HRTIMEN.
	RCC_C1_APB2ENR_HRTIMEN = 0x20000000
	// The selected clock is disabled
	RCC_C1_APB2ENR_HRTIMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB2ENR_HRTIMEN_Enabled = 0x1

	// C1_APB4ENR: RCC APB4 Clock Register
	// Position of SYSCFGEN field.
	RCC_C1_APB4ENR_SYSCFGEN_Pos = 0x1
	// Bit mask of SYSCFGEN field.
	RCC_C1_APB4ENR_SYSCFGEN_Msk = 0x2
	// Bit SYSCFGEN.
	RCC_C1_APB4ENR_SYSCFGEN = 0x2
	// The selected clock is disabled
	RCC_C1_APB4ENR_SYSCFGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_SYSCFGEN_Enabled = 0x1
	// Position of LPUART1EN field.
	RCC_C1_APB4ENR_LPUART1EN_Pos = 0x3
	// Bit mask of LPUART1EN field.
	RCC_C1_APB4ENR_LPUART1EN_Msk = 0x8
	// Bit LPUART1EN.
	RCC_C1_APB4ENR_LPUART1EN = 0x8
	// The selected clock is disabled
	RCC_C1_APB4ENR_LPUART1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_LPUART1EN_Enabled = 0x1
	// Position of SPI6EN field.
	RCC_C1_APB4ENR_SPI6EN_Pos = 0x5
	// Bit mask of SPI6EN field.
	RCC_C1_APB4ENR_SPI6EN_Msk = 0x20
	// Bit SPI6EN.
	RCC_C1_APB4ENR_SPI6EN = 0x20
	// The selected clock is disabled
	RCC_C1_APB4ENR_SPI6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_SPI6EN_Enabled = 0x1
	// Position of I2C4EN field.
	RCC_C1_APB4ENR_I2C4EN_Pos = 0x7
	// Bit mask of I2C4EN field.
	RCC_C1_APB4ENR_I2C4EN_Msk = 0x80
	// Bit I2C4EN.
	RCC_C1_APB4ENR_I2C4EN = 0x80
	// The selected clock is disabled
	RCC_C1_APB4ENR_I2C4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_I2C4EN_Enabled = 0x1
	// Position of LPTIM2EN field.
	RCC_C1_APB4ENR_LPTIM2EN_Pos = 0x9
	// Bit mask of LPTIM2EN field.
	RCC_C1_APB4ENR_LPTIM2EN_Msk = 0x200
	// Bit LPTIM2EN.
	RCC_C1_APB4ENR_LPTIM2EN = 0x200
	// The selected clock is disabled
	RCC_C1_APB4ENR_LPTIM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_LPTIM2EN_Enabled = 0x1
	// Position of LPTIM3EN field.
	RCC_C1_APB4ENR_LPTIM3EN_Pos = 0xa
	// Bit mask of LPTIM3EN field.
	RCC_C1_APB4ENR_LPTIM3EN_Msk = 0x400
	// Bit LPTIM3EN.
	RCC_C1_APB4ENR_LPTIM3EN = 0x400
	// The selected clock is disabled
	RCC_C1_APB4ENR_LPTIM3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_LPTIM3EN_Enabled = 0x1
	// Position of LPTIM4EN field.
	RCC_C1_APB4ENR_LPTIM4EN_Pos = 0xb
	// Bit mask of LPTIM4EN field.
	RCC_C1_APB4ENR_LPTIM4EN_Msk = 0x800
	// Bit LPTIM4EN.
	RCC_C1_APB4ENR_LPTIM4EN = 0x800
	// The selected clock is disabled
	RCC_C1_APB4ENR_LPTIM4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_LPTIM4EN_Enabled = 0x1
	// Position of LPTIM5EN field.
	RCC_C1_APB4ENR_LPTIM5EN_Pos = 0xc
	// Bit mask of LPTIM5EN field.
	RCC_C1_APB4ENR_LPTIM5EN_Msk = 0x1000
	// Bit LPTIM5EN.
	RCC_C1_APB4ENR_LPTIM5EN = 0x1000
	// The selected clock is disabled
	RCC_C1_APB4ENR_LPTIM5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_LPTIM5EN_Enabled = 0x1
	// Position of COMP12EN field.
	RCC_C1_APB4ENR_COMP12EN_Pos = 0xe
	// Bit mask of COMP12EN field.
	RCC_C1_APB4ENR_COMP12EN_Msk = 0x4000
	// Bit COMP12EN.
	RCC_C1_APB4ENR_COMP12EN = 0x4000
	// The selected clock is disabled
	RCC_C1_APB4ENR_COMP12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_COMP12EN_Enabled = 0x1
	// Position of VREFEN field.
	RCC_C1_APB4ENR_VREFEN_Pos = 0xf
	// Bit mask of VREFEN field.
	RCC_C1_APB4ENR_VREFEN_Msk = 0x8000
	// Bit VREFEN.
	RCC_C1_APB4ENR_VREFEN = 0x8000
	// The selected clock is disabled
	RCC_C1_APB4ENR_VREFEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_VREFEN_Enabled = 0x1
	// Position of RTCAPBEN field.
	RCC_C1_APB4ENR_RTCAPBEN_Pos = 0x10
	// Bit mask of RTCAPBEN field.
	RCC_C1_APB4ENR_RTCAPBEN_Msk = 0x10000
	// Bit RTCAPBEN.
	RCC_C1_APB4ENR_RTCAPBEN = 0x10000
	// The selected clock is disabled
	RCC_C1_APB4ENR_RTCAPBEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_RTCAPBEN_Enabled = 0x1
	// Position of SAI4EN field.
	RCC_C1_APB4ENR_SAI4EN_Pos = 0x15
	// Bit mask of SAI4EN field.
	RCC_C1_APB4ENR_SAI4EN_Msk = 0x200000
	// Bit SAI4EN.
	RCC_C1_APB4ENR_SAI4EN = 0x200000
	// The selected clock is disabled
	RCC_C1_APB4ENR_SAI4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_C1_APB4ENR_SAI4EN_Enabled = 0x1

	// C1_AHB3LPENR: RCC AHB3 Sleep Clock Register
	// Position of MDMALPEN field.
	RCC_C1_AHB3LPENR_MDMALPEN_Pos = 0x0
	// Bit mask of MDMALPEN field.
	RCC_C1_AHB3LPENR_MDMALPEN_Msk = 0x1
	// Bit MDMALPEN.
	RCC_C1_AHB3LPENR_MDMALPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_MDMALPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_MDMALPEN_Enabled = 0x1
	// Position of DMA2DLPEN field.
	RCC_C1_AHB3LPENR_DMA2DLPEN_Pos = 0x4
	// Bit mask of DMA2DLPEN field.
	RCC_C1_AHB3LPENR_DMA2DLPEN_Msk = 0x10
	// Bit DMA2DLPEN.
	RCC_C1_AHB3LPENR_DMA2DLPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_DMA2DLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_DMA2DLPEN_Enabled = 0x1
	// Position of FLASHPREN field.
	RCC_C1_AHB3LPENR_FLASHPREN_Pos = 0x8
	// Bit mask of FLASHPREN field.
	RCC_C1_AHB3LPENR_FLASHPREN_Msk = 0x100
	// Bit FLASHPREN.
	RCC_C1_AHB3LPENR_FLASHPREN = 0x100
	// Position of FMCLPEN field.
	RCC_C1_AHB3LPENR_FMCLPEN_Pos = 0xc
	// Bit mask of FMCLPEN field.
	RCC_C1_AHB3LPENR_FMCLPEN_Msk = 0x1000
	// Bit FMCLPEN.
	RCC_C1_AHB3LPENR_FMCLPEN = 0x1000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_FMCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_FMCLPEN_Enabled = 0x1
	// Position of SDMMC1LPEN field.
	RCC_C1_AHB3LPENR_SDMMC1LPEN_Pos = 0x10
	// Bit mask of SDMMC1LPEN field.
	RCC_C1_AHB3LPENR_SDMMC1LPEN_Msk = 0x10000
	// Bit SDMMC1LPEN.
	RCC_C1_AHB3LPENR_SDMMC1LPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_SDMMC1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_SDMMC1LPEN_Enabled = 0x1
	// Position of D1DTCM1LPEN field.
	RCC_C1_AHB3LPENR_D1DTCM1LPEN_Pos = 0x1c
	// Bit mask of D1DTCM1LPEN field.
	RCC_C1_AHB3LPENR_D1DTCM1LPEN_Msk = 0x10000000
	// Bit D1DTCM1LPEN.
	RCC_C1_AHB3LPENR_D1DTCM1LPEN = 0x10000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_D1DTCM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_D1DTCM1LPEN_Enabled = 0x1
	// Position of DTCM2LPEN field.
	RCC_C1_AHB3LPENR_DTCM2LPEN_Pos = 0x1d
	// Bit mask of DTCM2LPEN field.
	RCC_C1_AHB3LPENR_DTCM2LPEN_Msk = 0x20000000
	// Bit DTCM2LPEN.
	RCC_C1_AHB3LPENR_DTCM2LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_DTCM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_DTCM2LPEN_Enabled = 0x1
	// Position of ITCMLPEN field.
	RCC_C1_AHB3LPENR_ITCMLPEN_Pos = 0x1e
	// Bit mask of ITCMLPEN field.
	RCC_C1_AHB3LPENR_ITCMLPEN_Msk = 0x40000000
	// Bit ITCMLPEN.
	RCC_C1_AHB3LPENR_ITCMLPEN = 0x40000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_ITCMLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_ITCMLPEN_Enabled = 0x1
	// Position of AXISRAMLPEN field.
	RCC_C1_AHB3LPENR_AXISRAMLPEN_Pos = 0x1f
	// Bit mask of AXISRAMLPEN field.
	RCC_C1_AHB3LPENR_AXISRAMLPEN_Msk = 0x80000000
	// Bit AXISRAMLPEN.
	RCC_C1_AHB3LPENR_AXISRAMLPEN = 0x80000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_AXISRAMLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_AXISRAMLPEN_Enabled = 0x1
	// Position of OCTOSPI1LPEN field.
	RCC_C1_AHB3LPENR_OCTOSPI1LPEN_Pos = 0xe
	// Bit mask of OCTOSPI1LPEN field.
	RCC_C1_AHB3LPENR_OCTOSPI1LPEN_Msk = 0x4000
	// Bit OCTOSPI1LPEN.
	RCC_C1_AHB3LPENR_OCTOSPI1LPEN = 0x4000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_OCTOSPI1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_OCTOSPI1LPEN_Enabled = 0x1
	// Position of OCTOSPI2LPEN field.
	RCC_C1_AHB3LPENR_OCTOSPI2LPEN_Pos = 0x13
	// Bit mask of OCTOSPI2LPEN field.
	RCC_C1_AHB3LPENR_OCTOSPI2LPEN_Msk = 0x80000
	// Bit OCTOSPI2LPEN.
	RCC_C1_AHB3LPENR_OCTOSPI2LPEN = 0x80000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_OCTOSPI2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_OCTOSPI2LPEN_Enabled = 0x1
	// Position of IOMNGRLPEN field.
	RCC_C1_AHB3LPENR_IOMNGRLPEN_Pos = 0x15
	// Bit mask of IOMNGRLPEN field.
	RCC_C1_AHB3LPENR_IOMNGRLPEN_Msk = 0x200000
	// Bit IOMNGRLPEN.
	RCC_C1_AHB3LPENR_IOMNGRLPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_IOMNGRLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_IOMNGRLPEN_Enabled = 0x1
	// Position of OTFD1LPEN field.
	RCC_C1_AHB3LPENR_OTFD1LPEN_Pos = 0x16
	// Bit mask of OTFD1LPEN field.
	RCC_C1_AHB3LPENR_OTFD1LPEN_Msk = 0x400000
	// Bit OTFD1LPEN.
	RCC_C1_AHB3LPENR_OTFD1LPEN = 0x400000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_OTFD1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_OTFD1LPEN_Enabled = 0x1
	// Position of OTFD2LPEN field.
	RCC_C1_AHB3LPENR_OTFD2LPEN_Pos = 0x17
	// Bit mask of OTFD2LPEN field.
	RCC_C1_AHB3LPENR_OTFD2LPEN_Msk = 0x800000
	// Bit OTFD2LPEN.
	RCC_C1_AHB3LPENR_OTFD2LPEN = 0x800000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB3LPENR_OTFD2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB3LPENR_OTFD2LPEN_Enabled = 0x1

	// C1_AHB1LPENR: RCC AHB1 Sleep Clock Register
	// Position of DMA1LPEN field.
	RCC_C1_AHB1LPENR_DMA1LPEN_Pos = 0x0
	// Bit mask of DMA1LPEN field.
	RCC_C1_AHB1LPENR_DMA1LPEN_Msk = 0x1
	// Bit DMA1LPEN.
	RCC_C1_AHB1LPENR_DMA1LPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_DMA1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_DMA1LPEN_Enabled = 0x1
	// Position of DMA2LPEN field.
	RCC_C1_AHB1LPENR_DMA2LPEN_Pos = 0x1
	// Bit mask of DMA2LPEN field.
	RCC_C1_AHB1LPENR_DMA2LPEN_Msk = 0x2
	// Bit DMA2LPEN.
	RCC_C1_AHB1LPENR_DMA2LPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_DMA2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_DMA2LPEN_Enabled = 0x1
	// Position of ADC12LPEN field.
	RCC_C1_AHB1LPENR_ADC12LPEN_Pos = 0x5
	// Bit mask of ADC12LPEN field.
	RCC_C1_AHB1LPENR_ADC12LPEN_Msk = 0x20
	// Bit ADC12LPEN.
	RCC_C1_AHB1LPENR_ADC12LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_ADC12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_ADC12LPEN_Enabled = 0x1
	// Position of ETH1MACLPEN field.
	RCC_C1_AHB1LPENR_ETH1MACLPEN_Pos = 0xf
	// Bit mask of ETH1MACLPEN field.
	RCC_C1_AHB1LPENR_ETH1MACLPEN_Msk = 0x8000
	// Bit ETH1MACLPEN.
	RCC_C1_AHB1LPENR_ETH1MACLPEN = 0x8000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_ETH1MACLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_ETH1MACLPEN_Enabled = 0x1
	// Position of ETH1TXLPEN field.
	RCC_C1_AHB1LPENR_ETH1TXLPEN_Pos = 0x10
	// Bit mask of ETH1TXLPEN field.
	RCC_C1_AHB1LPENR_ETH1TXLPEN_Msk = 0x10000
	// Bit ETH1TXLPEN.
	RCC_C1_AHB1LPENR_ETH1TXLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_ETH1TXLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_ETH1TXLPEN_Enabled = 0x1
	// Position of ETH1RXLPEN field.
	RCC_C1_AHB1LPENR_ETH1RXLPEN_Pos = 0x11
	// Bit mask of ETH1RXLPEN field.
	RCC_C1_AHB1LPENR_ETH1RXLPEN_Msk = 0x20000
	// Bit ETH1RXLPEN.
	RCC_C1_AHB1LPENR_ETH1RXLPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_ETH1RXLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_ETH1RXLPEN_Enabled = 0x1
	// Position of USB1OTGLPEN field.
	RCC_C1_AHB1LPENR_USB1OTGLPEN_Pos = 0x19
	// Bit mask of USB1OTGLPEN field.
	RCC_C1_AHB1LPENR_USB1OTGLPEN_Msk = 0x2000000
	// Bit USB1OTGLPEN.
	RCC_C1_AHB1LPENR_USB1OTGLPEN = 0x2000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_USB1OTGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_USB1OTGLPEN_Enabled = 0x1
	// Position of USB1ULPILPEN field.
	RCC_C1_AHB1LPENR_USB1ULPILPEN_Pos = 0x1a
	// Bit mask of USB1ULPILPEN field.
	RCC_C1_AHB1LPENR_USB1ULPILPEN_Msk = 0x4000000
	// Bit USB1ULPILPEN.
	RCC_C1_AHB1LPENR_USB1ULPILPEN = 0x4000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB1LPENR_USB1ULPILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB1LPENR_USB1ULPILPEN_Enabled = 0x1

	// C1_AHB2LPENR: RCC AHB2 Sleep Clock Register
	// Position of DCMILPEN field.
	RCC_C1_AHB2LPENR_DCMILPEN_Pos = 0x0
	// Bit mask of DCMILPEN field.
	RCC_C1_AHB2LPENR_DCMILPEN_Msk = 0x1
	// Bit DCMILPEN.
	RCC_C1_AHB2LPENR_DCMILPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_DCMILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_DCMILPEN_Enabled = 0x1
	// Position of CRYPTLPEN field.
	RCC_C1_AHB2LPENR_CRYPTLPEN_Pos = 0x4
	// Bit mask of CRYPTLPEN field.
	RCC_C1_AHB2LPENR_CRYPTLPEN_Msk = 0x10
	// Bit CRYPTLPEN.
	RCC_C1_AHB2LPENR_CRYPTLPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_CRYPTLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_CRYPTLPEN_Enabled = 0x1
	// Position of HASHLPEN field.
	RCC_C1_AHB2LPENR_HASHLPEN_Pos = 0x5
	// Bit mask of HASHLPEN field.
	RCC_C1_AHB2LPENR_HASHLPEN_Msk = 0x20
	// Bit HASHLPEN.
	RCC_C1_AHB2LPENR_HASHLPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_HASHLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_HASHLPEN_Enabled = 0x1
	// Position of SDMMC2LPEN field.
	RCC_C1_AHB2LPENR_SDMMC2LPEN_Pos = 0x9
	// Bit mask of SDMMC2LPEN field.
	RCC_C1_AHB2LPENR_SDMMC2LPEN_Msk = 0x200
	// Bit SDMMC2LPEN.
	RCC_C1_AHB2LPENR_SDMMC2LPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_SDMMC2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_SDMMC2LPEN_Enabled = 0x1
	// Position of RNGLPEN field.
	RCC_C1_AHB2LPENR_RNGLPEN_Pos = 0x6
	// Bit mask of RNGLPEN field.
	RCC_C1_AHB2LPENR_RNGLPEN_Msk = 0x40
	// Bit RNGLPEN.
	RCC_C1_AHB2LPENR_RNGLPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_RNGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_RNGLPEN_Enabled = 0x1
	// Position of SRAM1LPEN field.
	RCC_C1_AHB2LPENR_SRAM1LPEN_Pos = 0x1d
	// Bit mask of SRAM1LPEN field.
	RCC_C1_AHB2LPENR_SRAM1LPEN_Msk = 0x20000000
	// Bit SRAM1LPEN.
	RCC_C1_AHB2LPENR_SRAM1LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_SRAM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_SRAM1LPEN_Enabled = 0x1
	// Position of SRAM2LPEN field.
	RCC_C1_AHB2LPENR_SRAM2LPEN_Pos = 0x1e
	// Bit mask of SRAM2LPEN field.
	RCC_C1_AHB2LPENR_SRAM2LPEN_Msk = 0x40000000
	// Bit SRAM2LPEN.
	RCC_C1_AHB2LPENR_SRAM2LPEN = 0x40000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_SRAM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_SRAM2LPEN_Enabled = 0x1
	// Position of FMACLPEN field.
	RCC_C1_AHB2LPENR_FMACLPEN_Pos = 0x10
	// Bit mask of FMACLPEN field.
	RCC_C1_AHB2LPENR_FMACLPEN_Msk = 0x10000
	// Bit FMACLPEN.
	RCC_C1_AHB2LPENR_FMACLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_FMACLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_FMACLPEN_Enabled = 0x1
	// Position of CORDICLPEN field.
	RCC_C1_AHB2LPENR_CORDICLPEN_Pos = 0x11
	// Bit mask of CORDICLPEN field.
	RCC_C1_AHB2LPENR_CORDICLPEN_Msk = 0x20000
	// Bit CORDICLPEN.
	RCC_C1_AHB2LPENR_CORDICLPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB2LPENR_CORDICLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB2LPENR_CORDICLPEN_Enabled = 0x1

	// C1_AHB4LPENR: RCC AHB4 Sleep Clock Register
	// Position of GPIOALPEN field.
	RCC_C1_AHB4LPENR_GPIOALPEN_Pos = 0x0
	// Bit mask of GPIOALPEN field.
	RCC_C1_AHB4LPENR_GPIOALPEN_Msk = 0x1
	// Bit GPIOALPEN.
	RCC_C1_AHB4LPENR_GPIOALPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOALPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOALPEN_Enabled = 0x1
	// Position of GPIOBLPEN field.
	RCC_C1_AHB4LPENR_GPIOBLPEN_Pos = 0x1
	// Bit mask of GPIOBLPEN field.
	RCC_C1_AHB4LPENR_GPIOBLPEN_Msk = 0x2
	// Bit GPIOBLPEN.
	RCC_C1_AHB4LPENR_GPIOBLPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOBLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOBLPEN_Enabled = 0x1
	// Position of GPIOCLPEN field.
	RCC_C1_AHB4LPENR_GPIOCLPEN_Pos = 0x2
	// Bit mask of GPIOCLPEN field.
	RCC_C1_AHB4LPENR_GPIOCLPEN_Msk = 0x4
	// Bit GPIOCLPEN.
	RCC_C1_AHB4LPENR_GPIOCLPEN = 0x4
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOCLPEN_Enabled = 0x1
	// Position of GPIODLPEN field.
	RCC_C1_AHB4LPENR_GPIODLPEN_Pos = 0x3
	// Bit mask of GPIODLPEN field.
	RCC_C1_AHB4LPENR_GPIODLPEN_Msk = 0x8
	// Bit GPIODLPEN.
	RCC_C1_AHB4LPENR_GPIODLPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIODLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIODLPEN_Enabled = 0x1
	// Position of GPIOELPEN field.
	RCC_C1_AHB4LPENR_GPIOELPEN_Pos = 0x4
	// Bit mask of GPIOELPEN field.
	RCC_C1_AHB4LPENR_GPIOELPEN_Msk = 0x10
	// Bit GPIOELPEN.
	RCC_C1_AHB4LPENR_GPIOELPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOELPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOELPEN_Enabled = 0x1
	// Position of GPIOFLPEN field.
	RCC_C1_AHB4LPENR_GPIOFLPEN_Pos = 0x5
	// Bit mask of GPIOFLPEN field.
	RCC_C1_AHB4LPENR_GPIOFLPEN_Msk = 0x20
	// Bit GPIOFLPEN.
	RCC_C1_AHB4LPENR_GPIOFLPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOFLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOFLPEN_Enabled = 0x1
	// Position of GPIOGLPEN field.
	RCC_C1_AHB4LPENR_GPIOGLPEN_Pos = 0x6
	// Bit mask of GPIOGLPEN field.
	RCC_C1_AHB4LPENR_GPIOGLPEN_Msk = 0x40
	// Bit GPIOGLPEN.
	RCC_C1_AHB4LPENR_GPIOGLPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOGLPEN_Enabled = 0x1
	// Position of GPIOHLPEN field.
	RCC_C1_AHB4LPENR_GPIOHLPEN_Pos = 0x7
	// Bit mask of GPIOHLPEN field.
	RCC_C1_AHB4LPENR_GPIOHLPEN_Msk = 0x80
	// Bit GPIOHLPEN.
	RCC_C1_AHB4LPENR_GPIOHLPEN = 0x80
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOHLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOHLPEN_Enabled = 0x1
	// Position of GPIOILPEN field.
	RCC_C1_AHB4LPENR_GPIOILPEN_Pos = 0x8
	// Bit mask of GPIOILPEN field.
	RCC_C1_AHB4LPENR_GPIOILPEN_Msk = 0x100
	// Bit GPIOILPEN.
	RCC_C1_AHB4LPENR_GPIOILPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOILPEN_Enabled = 0x1
	// Position of GPIOJLPEN field.
	RCC_C1_AHB4LPENR_GPIOJLPEN_Pos = 0x9
	// Bit mask of GPIOJLPEN field.
	RCC_C1_AHB4LPENR_GPIOJLPEN_Msk = 0x200
	// Bit GPIOJLPEN.
	RCC_C1_AHB4LPENR_GPIOJLPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOJLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOJLPEN_Enabled = 0x1
	// Position of GPIOKLPEN field.
	RCC_C1_AHB4LPENR_GPIOKLPEN_Pos = 0xa
	// Bit mask of GPIOKLPEN field.
	RCC_C1_AHB4LPENR_GPIOKLPEN_Msk = 0x400
	// Bit GPIOKLPEN.
	RCC_C1_AHB4LPENR_GPIOKLPEN = 0x400
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOKLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_GPIOKLPEN_Enabled = 0x1
	// Position of CRCLPEN field.
	RCC_C1_AHB4LPENR_CRCLPEN_Pos = 0x13
	// Bit mask of CRCLPEN field.
	RCC_C1_AHB4LPENR_CRCLPEN_Msk = 0x80000
	// Bit CRCLPEN.
	RCC_C1_AHB4LPENR_CRCLPEN = 0x80000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_CRCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_CRCLPEN_Enabled = 0x1
	// Position of BDMALPEN field.
	RCC_C1_AHB4LPENR_BDMALPEN_Pos = 0x15
	// Bit mask of BDMALPEN field.
	RCC_C1_AHB4LPENR_BDMALPEN_Msk = 0x200000
	// Bit BDMALPEN.
	RCC_C1_AHB4LPENR_BDMALPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_BDMALPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_BDMALPEN_Enabled = 0x1
	// Position of ADC3LPEN field.
	RCC_C1_AHB4LPENR_ADC3LPEN_Pos = 0x18
	// Bit mask of ADC3LPEN field.
	RCC_C1_AHB4LPENR_ADC3LPEN_Msk = 0x1000000
	// Bit ADC3LPEN.
	RCC_C1_AHB4LPENR_ADC3LPEN = 0x1000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_ADC3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_ADC3LPEN_Enabled = 0x1
	// Position of BKPRAMLPEN field.
	RCC_C1_AHB4LPENR_BKPRAMLPEN_Pos = 0x1c
	// Bit mask of BKPRAMLPEN field.
	RCC_C1_AHB4LPENR_BKPRAMLPEN_Msk = 0x10000000
	// Bit BKPRAMLPEN.
	RCC_C1_AHB4LPENR_BKPRAMLPEN = 0x10000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_BKPRAMLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_BKPRAMLPEN_Enabled = 0x1
	// Position of SRAM4LPEN field.
	RCC_C1_AHB4LPENR_SRAM4LPEN_Pos = 0x1d
	// Bit mask of SRAM4LPEN field.
	RCC_C1_AHB4LPENR_SRAM4LPEN_Msk = 0x20000000
	// Bit SRAM4LPEN.
	RCC_C1_AHB4LPENR_SRAM4LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_C1_AHB4LPENR_SRAM4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_AHB4LPENR_SRAM4LPEN_Enabled = 0x1

	// C1_APB3LPENR: RCC APB3 Sleep Clock Register
	// Position of LTDCLPEN field.
	RCC_C1_APB3LPENR_LTDCLPEN_Pos = 0x3
	// Bit mask of LTDCLPEN field.
	RCC_C1_APB3LPENR_LTDCLPEN_Msk = 0x8
	// Bit LTDCLPEN.
	RCC_C1_APB3LPENR_LTDCLPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_C1_APB3LPENR_LTDCLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB3LPENR_LTDCLPEN_Enabled = 0x1
	// Position of WWDG1LPEN field.
	RCC_C1_APB3LPENR_WWDG1LPEN_Pos = 0x6
	// Bit mask of WWDG1LPEN field.
	RCC_C1_APB3LPENR_WWDG1LPEN_Msk = 0x40
	// Bit WWDG1LPEN.
	RCC_C1_APB3LPENR_WWDG1LPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_C1_APB3LPENR_WWDG1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB3LPENR_WWDG1LPEN_Enabled = 0x1

	// C1_APB1LLPENR: RCC APB1 Low Sleep Clock Register
	// Position of TIM2LPEN field.
	RCC_C1_APB1LLPENR_TIM2LPEN_Pos = 0x0
	// Bit mask of TIM2LPEN field.
	RCC_C1_APB1LLPENR_TIM2LPEN_Msk = 0x1
	// Bit TIM2LPEN.
	RCC_C1_APB1LLPENR_TIM2LPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM2LPEN_Enabled = 0x1
	// Position of TIM3LPEN field.
	RCC_C1_APB1LLPENR_TIM3LPEN_Pos = 0x1
	// Bit mask of TIM3LPEN field.
	RCC_C1_APB1LLPENR_TIM3LPEN_Msk = 0x2
	// Bit TIM3LPEN.
	RCC_C1_APB1LLPENR_TIM3LPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM3LPEN_Enabled = 0x1
	// Position of TIM4LPEN field.
	RCC_C1_APB1LLPENR_TIM4LPEN_Pos = 0x2
	// Bit mask of TIM4LPEN field.
	RCC_C1_APB1LLPENR_TIM4LPEN_Msk = 0x4
	// Bit TIM4LPEN.
	RCC_C1_APB1LLPENR_TIM4LPEN = 0x4
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM4LPEN_Enabled = 0x1
	// Position of TIM5LPEN field.
	RCC_C1_APB1LLPENR_TIM5LPEN_Pos = 0x3
	// Bit mask of TIM5LPEN field.
	RCC_C1_APB1LLPENR_TIM5LPEN_Msk = 0x8
	// Bit TIM5LPEN.
	RCC_C1_APB1LLPENR_TIM5LPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM5LPEN_Enabled = 0x1
	// Position of TIM6LPEN field.
	RCC_C1_APB1LLPENR_TIM6LPEN_Pos = 0x4
	// Bit mask of TIM6LPEN field.
	RCC_C1_APB1LLPENR_TIM6LPEN_Msk = 0x10
	// Bit TIM6LPEN.
	RCC_C1_APB1LLPENR_TIM6LPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM6LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM6LPEN_Enabled = 0x1
	// Position of TIM7LPEN field.
	RCC_C1_APB1LLPENR_TIM7LPEN_Pos = 0x5
	// Bit mask of TIM7LPEN field.
	RCC_C1_APB1LLPENR_TIM7LPEN_Msk = 0x20
	// Bit TIM7LPEN.
	RCC_C1_APB1LLPENR_TIM7LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM7LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM7LPEN_Enabled = 0x1
	// Position of TIM12LPEN field.
	RCC_C1_APB1LLPENR_TIM12LPEN_Pos = 0x6
	// Bit mask of TIM12LPEN field.
	RCC_C1_APB1LLPENR_TIM12LPEN_Msk = 0x40
	// Bit TIM12LPEN.
	RCC_C1_APB1LLPENR_TIM12LPEN = 0x40
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM12LPEN_Enabled = 0x1
	// Position of TIM13LPEN field.
	RCC_C1_APB1LLPENR_TIM13LPEN_Pos = 0x7
	// Bit mask of TIM13LPEN field.
	RCC_C1_APB1LLPENR_TIM13LPEN_Msk = 0x80
	// Bit TIM13LPEN.
	RCC_C1_APB1LLPENR_TIM13LPEN = 0x80
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM13LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM13LPEN_Enabled = 0x1
	// Position of TIM14LPEN field.
	RCC_C1_APB1LLPENR_TIM14LPEN_Pos = 0x8
	// Bit mask of TIM14LPEN field.
	RCC_C1_APB1LLPENR_TIM14LPEN_Msk = 0x100
	// Bit TIM14LPEN.
	RCC_C1_APB1LLPENR_TIM14LPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_TIM14LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_TIM14LPEN_Enabled = 0x1
	// Position of LPTIM1LPEN field.
	RCC_C1_APB1LLPENR_LPTIM1LPEN_Pos = 0x9
	// Bit mask of LPTIM1LPEN field.
	RCC_C1_APB1LLPENR_LPTIM1LPEN_Msk = 0x200
	// Bit LPTIM1LPEN.
	RCC_C1_APB1LLPENR_LPTIM1LPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_LPTIM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_LPTIM1LPEN_Enabled = 0x1
	// Position of SPI2LPEN field.
	RCC_C1_APB1LLPENR_SPI2LPEN_Pos = 0xe
	// Bit mask of SPI2LPEN field.
	RCC_C1_APB1LLPENR_SPI2LPEN_Msk = 0x4000
	// Bit SPI2LPEN.
	RCC_C1_APB1LLPENR_SPI2LPEN = 0x4000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_SPI2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_SPI2LPEN_Enabled = 0x1
	// Position of SPI3LPEN field.
	RCC_C1_APB1LLPENR_SPI3LPEN_Pos = 0xf
	// Bit mask of SPI3LPEN field.
	RCC_C1_APB1LLPENR_SPI3LPEN_Msk = 0x8000
	// Bit SPI3LPEN.
	RCC_C1_APB1LLPENR_SPI3LPEN = 0x8000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_SPI3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_SPI3LPEN_Enabled = 0x1
	// Position of SPDIFRXLPEN field.
	RCC_C1_APB1LLPENR_SPDIFRXLPEN_Pos = 0x10
	// Bit mask of SPDIFRXLPEN field.
	RCC_C1_APB1LLPENR_SPDIFRXLPEN_Msk = 0x10000
	// Bit SPDIFRXLPEN.
	RCC_C1_APB1LLPENR_SPDIFRXLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_SPDIFRXLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_SPDIFRXLPEN_Enabled = 0x1
	// Position of USART2LPEN field.
	RCC_C1_APB1LLPENR_USART2LPEN_Pos = 0x11
	// Bit mask of USART2LPEN field.
	RCC_C1_APB1LLPENR_USART2LPEN_Msk = 0x20000
	// Bit USART2LPEN.
	RCC_C1_APB1LLPENR_USART2LPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_USART2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_USART2LPEN_Enabled = 0x1
	// Position of USART3LPEN field.
	RCC_C1_APB1LLPENR_USART3LPEN_Pos = 0x12
	// Bit mask of USART3LPEN field.
	RCC_C1_APB1LLPENR_USART3LPEN_Msk = 0x40000
	// Bit USART3LPEN.
	RCC_C1_APB1LLPENR_USART3LPEN = 0x40000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_USART3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_USART3LPEN_Enabled = 0x1
	// Position of UART4LPEN field.
	RCC_C1_APB1LLPENR_UART4LPEN_Pos = 0x13
	// Bit mask of UART4LPEN field.
	RCC_C1_APB1LLPENR_UART4LPEN_Msk = 0x80000
	// Bit UART4LPEN.
	RCC_C1_APB1LLPENR_UART4LPEN = 0x80000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_UART4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_UART4LPEN_Enabled = 0x1
	// Position of UART5LPEN field.
	RCC_C1_APB1LLPENR_UART5LPEN_Pos = 0x14
	// Bit mask of UART5LPEN field.
	RCC_C1_APB1LLPENR_UART5LPEN_Msk = 0x100000
	// Bit UART5LPEN.
	RCC_C1_APB1LLPENR_UART5LPEN = 0x100000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_UART5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_UART5LPEN_Enabled = 0x1
	// Position of I2C1LPEN field.
	RCC_C1_APB1LLPENR_I2C1LPEN_Pos = 0x15
	// Bit mask of I2C1LPEN field.
	RCC_C1_APB1LLPENR_I2C1LPEN_Msk = 0x200000
	// Bit I2C1LPEN.
	RCC_C1_APB1LLPENR_I2C1LPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_I2C1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_I2C1LPEN_Enabled = 0x1
	// Position of I2C2LPEN field.
	RCC_C1_APB1LLPENR_I2C2LPEN_Pos = 0x16
	// Bit mask of I2C2LPEN field.
	RCC_C1_APB1LLPENR_I2C2LPEN_Msk = 0x400000
	// Bit I2C2LPEN.
	RCC_C1_APB1LLPENR_I2C2LPEN = 0x400000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_I2C2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_I2C2LPEN_Enabled = 0x1
	// Position of I2C3LPEN field.
	RCC_C1_APB1LLPENR_I2C3LPEN_Pos = 0x17
	// Bit mask of I2C3LPEN field.
	RCC_C1_APB1LLPENR_I2C3LPEN_Msk = 0x800000
	// Bit I2C3LPEN.
	RCC_C1_APB1LLPENR_I2C3LPEN = 0x800000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_I2C3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_I2C3LPEN_Enabled = 0x1
	// Position of CECLPEN field.
	RCC_C1_APB1LLPENR_CECLPEN_Pos = 0x1b
	// Bit mask of CECLPEN field.
	RCC_C1_APB1LLPENR_CECLPEN_Msk = 0x8000000
	// Bit CECLPEN.
	RCC_C1_APB1LLPENR_CECLPEN = 0x8000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_CECLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_CECLPEN_Enabled = 0x1
	// Position of DAC12LPEN field.
	RCC_C1_APB1LLPENR_DAC12LPEN_Pos = 0x1d
	// Bit mask of DAC12LPEN field.
	RCC_C1_APB1LLPENR_DAC12LPEN_Msk = 0x20000000
	// Bit DAC12LPEN.
	RCC_C1_APB1LLPENR_DAC12LPEN = 0x20000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_DAC12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_DAC12LPEN_Enabled = 0x1
	// Position of UART7LPEN field.
	RCC_C1_APB1LLPENR_UART7LPEN_Pos = 0x1e
	// Bit mask of UART7LPEN field.
	RCC_C1_APB1LLPENR_UART7LPEN_Msk = 0x40000000
	// Bit UART7LPEN.
	RCC_C1_APB1LLPENR_UART7LPEN = 0x40000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_UART7LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_UART7LPEN_Enabled = 0x1
	// Position of UART8LPEN field.
	RCC_C1_APB1LLPENR_UART8LPEN_Pos = 0x1f
	// Bit mask of UART8LPEN field.
	RCC_C1_APB1LLPENR_UART8LPEN_Msk = 0x80000000
	// Bit UART8LPEN.
	RCC_C1_APB1LLPENR_UART8LPEN = 0x80000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_UART8LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_UART8LPEN_Enabled = 0x1
	// Position of I2C5LPEN field.
	RCC_C1_APB1LLPENR_I2C5LPEN_Pos = 0x19
	// Bit mask of I2C5LPEN field.
	RCC_C1_APB1LLPENR_I2C5LPEN_Msk = 0x2000000
	// Bit I2C5LPEN.
	RCC_C1_APB1LLPENR_I2C5LPEN = 0x2000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1LLPENR_I2C5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1LLPENR_I2C5LPEN_Enabled = 0x1

	// C1_APB1HLPENR: RCC APB1 High Sleep Clock Register
	// Position of CRSLPEN field.
	RCC_C1_APB1HLPENR_CRSLPEN_Pos = 0x1
	// Bit mask of CRSLPEN field.
	RCC_C1_APB1HLPENR_CRSLPEN_Msk = 0x2
	// Bit CRSLPEN.
	RCC_C1_APB1HLPENR_CRSLPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_CRSLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_CRSLPEN_Enabled = 0x1
	// Position of SWPMILPEN field.
	RCC_C1_APB1HLPENR_SWPMILPEN_Pos = 0x2
	// Bit mask of SWPMILPEN field.
	RCC_C1_APB1HLPENR_SWPMILPEN_Msk = 0x4
	// Bit SWPMILPEN.
	RCC_C1_APB1HLPENR_SWPMILPEN = 0x4
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_SWPMILPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_SWPMILPEN_Enabled = 0x1
	// Position of OPAMPLPEN field.
	RCC_C1_APB1HLPENR_OPAMPLPEN_Pos = 0x4
	// Bit mask of OPAMPLPEN field.
	RCC_C1_APB1HLPENR_OPAMPLPEN_Msk = 0x10
	// Bit OPAMPLPEN.
	RCC_C1_APB1HLPENR_OPAMPLPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_OPAMPLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_OPAMPLPEN_Enabled = 0x1
	// Position of MDIOSLPEN field.
	RCC_C1_APB1HLPENR_MDIOSLPEN_Pos = 0x5
	// Bit mask of MDIOSLPEN field.
	RCC_C1_APB1HLPENR_MDIOSLPEN_Msk = 0x20
	// Bit MDIOSLPEN.
	RCC_C1_APB1HLPENR_MDIOSLPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_MDIOSLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_MDIOSLPEN_Enabled = 0x1
	// Position of FDCANLPEN field.
	RCC_C1_APB1HLPENR_FDCANLPEN_Pos = 0x8
	// Bit mask of FDCANLPEN field.
	RCC_C1_APB1HLPENR_FDCANLPEN_Msk = 0x100
	// Bit FDCANLPEN.
	RCC_C1_APB1HLPENR_FDCANLPEN = 0x100
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_FDCANLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_FDCANLPEN_Enabled = 0x1
	// Position of TIM23LPEN field.
	RCC_C1_APB1HLPENR_TIM23LPEN_Pos = 0x18
	// Bit mask of TIM23LPEN field.
	RCC_C1_APB1HLPENR_TIM23LPEN_Msk = 0x1000000
	// Bit TIM23LPEN.
	RCC_C1_APB1HLPENR_TIM23LPEN = 0x1000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_TIM23LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_TIM23LPEN_Enabled = 0x1
	// Position of TIM24LPEN field.
	RCC_C1_APB1HLPENR_TIM24LPEN_Pos = 0x19
	// Bit mask of TIM24LPEN field.
	RCC_C1_APB1HLPENR_TIM24LPEN_Msk = 0x2000000
	// Bit TIM24LPEN.
	RCC_C1_APB1HLPENR_TIM24LPEN = 0x2000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB1HLPENR_TIM24LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB1HLPENR_TIM24LPEN_Enabled = 0x1

	// C1_APB2LPENR: RCC APB2 Sleep Clock Register
	// Position of TIM1LPEN field.
	RCC_C1_APB2LPENR_TIM1LPEN_Pos = 0x0
	// Bit mask of TIM1LPEN field.
	RCC_C1_APB2LPENR_TIM1LPEN_Msk = 0x1
	// Bit TIM1LPEN.
	RCC_C1_APB2LPENR_TIM1LPEN = 0x1
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_TIM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_TIM1LPEN_Enabled = 0x1
	// Position of TIM8LPEN field.
	RCC_C1_APB2LPENR_TIM8LPEN_Pos = 0x1
	// Bit mask of TIM8LPEN field.
	RCC_C1_APB2LPENR_TIM8LPEN_Msk = 0x2
	// Bit TIM8LPEN.
	RCC_C1_APB2LPENR_TIM8LPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_TIM8LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_TIM8LPEN_Enabled = 0x1
	// Position of USART1LPEN field.
	RCC_C1_APB2LPENR_USART1LPEN_Pos = 0x4
	// Bit mask of USART1LPEN field.
	RCC_C1_APB2LPENR_USART1LPEN_Msk = 0x10
	// Bit USART1LPEN.
	RCC_C1_APB2LPENR_USART1LPEN = 0x10
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_USART1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_USART1LPEN_Enabled = 0x1
	// Position of USART6LPEN field.
	RCC_C1_APB2LPENR_USART6LPEN_Pos = 0x5
	// Bit mask of USART6LPEN field.
	RCC_C1_APB2LPENR_USART6LPEN_Msk = 0x20
	// Bit USART6LPEN.
	RCC_C1_APB2LPENR_USART6LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_USART6LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_USART6LPEN_Enabled = 0x1
	// Position of SPI1LPEN field.
	RCC_C1_APB2LPENR_SPI1LPEN_Pos = 0xc
	// Bit mask of SPI1LPEN field.
	RCC_C1_APB2LPENR_SPI1LPEN_Msk = 0x1000
	// Bit SPI1LPEN.
	RCC_C1_APB2LPENR_SPI1LPEN = 0x1000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_SPI1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_SPI1LPEN_Enabled = 0x1
	// Position of SPI4LPEN field.
	RCC_C1_APB2LPENR_SPI4LPEN_Pos = 0xd
	// Bit mask of SPI4LPEN field.
	RCC_C1_APB2LPENR_SPI4LPEN_Msk = 0x2000
	// Bit SPI4LPEN.
	RCC_C1_APB2LPENR_SPI4LPEN = 0x2000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_SPI4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_SPI4LPEN_Enabled = 0x1
	// Position of TIM15LPEN field.
	RCC_C1_APB2LPENR_TIM15LPEN_Pos = 0x10
	// Bit mask of TIM15LPEN field.
	RCC_C1_APB2LPENR_TIM15LPEN_Msk = 0x10000
	// Bit TIM15LPEN.
	RCC_C1_APB2LPENR_TIM15LPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_TIM15LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_TIM15LPEN_Enabled = 0x1
	// Position of TIM16LPEN field.
	RCC_C1_APB2LPENR_TIM16LPEN_Pos = 0x11
	// Bit mask of TIM16LPEN field.
	RCC_C1_APB2LPENR_TIM16LPEN_Msk = 0x20000
	// Bit TIM16LPEN.
	RCC_C1_APB2LPENR_TIM16LPEN = 0x20000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_TIM16LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_TIM16LPEN_Enabled = 0x1
	// Position of TIM17LPEN field.
	RCC_C1_APB2LPENR_TIM17LPEN_Pos = 0x12
	// Bit mask of TIM17LPEN field.
	RCC_C1_APB2LPENR_TIM17LPEN_Msk = 0x40000
	// Bit TIM17LPEN.
	RCC_C1_APB2LPENR_TIM17LPEN = 0x40000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_TIM17LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_TIM17LPEN_Enabled = 0x1
	// Position of SPI5LPEN field.
	RCC_C1_APB2LPENR_SPI5LPEN_Pos = 0x14
	// Bit mask of SPI5LPEN field.
	RCC_C1_APB2LPENR_SPI5LPEN_Msk = 0x100000
	// Bit SPI5LPEN.
	RCC_C1_APB2LPENR_SPI5LPEN = 0x100000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_SPI5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_SPI5LPEN_Enabled = 0x1
	// Position of SAI1LPEN field.
	RCC_C1_APB2LPENR_SAI1LPEN_Pos = 0x16
	// Bit mask of SAI1LPEN field.
	RCC_C1_APB2LPENR_SAI1LPEN_Msk = 0x400000
	// Bit SAI1LPEN.
	RCC_C1_APB2LPENR_SAI1LPEN = 0x400000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_SAI1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_SAI1LPEN_Enabled = 0x1
	// Position of SAI2LPEN field.
	RCC_C1_APB2LPENR_SAI2LPEN_Pos = 0x17
	// Bit mask of SAI2LPEN field.
	RCC_C1_APB2LPENR_SAI2LPEN_Msk = 0x800000
	// Bit SAI2LPEN.
	RCC_C1_APB2LPENR_SAI2LPEN = 0x800000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_SAI2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_SAI2LPEN_Enabled = 0x1
	// Position of SAI3LPEN field.
	RCC_C1_APB2LPENR_SAI3LPEN_Pos = 0x18
	// Bit mask of SAI3LPEN field.
	RCC_C1_APB2LPENR_SAI3LPEN_Msk = 0x1000000
	// Bit SAI3LPEN.
	RCC_C1_APB2LPENR_SAI3LPEN = 0x1000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_SAI3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_SAI3LPEN_Enabled = 0x1
	// Position of DFSDM1LPEN field.
	RCC_C1_APB2LPENR_DFSDM1LPEN_Pos = 0x1c
	// Bit mask of DFSDM1LPEN field.
	RCC_C1_APB2LPENR_DFSDM1LPEN_Msk = 0x10000000
	// Bit DFSDM1LPEN.
	RCC_C1_APB2LPENR_DFSDM1LPEN = 0x10000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB2LPENR_DFSDM1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB2LPENR_DFSDM1LPEN_Enabled = 0x1

	// C1_APB4LPENR: RCC APB4 Sleep Clock Register
	// Position of SYSCFGLPEN field.
	RCC_C1_APB4LPENR_SYSCFGLPEN_Pos = 0x1
	// Bit mask of SYSCFGLPEN field.
	RCC_C1_APB4LPENR_SYSCFGLPEN_Msk = 0x2
	// Bit SYSCFGLPEN.
	RCC_C1_APB4LPENR_SYSCFGLPEN = 0x2
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_SYSCFGLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_SYSCFGLPEN_Enabled = 0x1
	// Position of LPUART1LPEN field.
	RCC_C1_APB4LPENR_LPUART1LPEN_Pos = 0x3
	// Bit mask of LPUART1LPEN field.
	RCC_C1_APB4LPENR_LPUART1LPEN_Msk = 0x8
	// Bit LPUART1LPEN.
	RCC_C1_APB4LPENR_LPUART1LPEN = 0x8
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_LPUART1LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_LPUART1LPEN_Enabled = 0x1
	// Position of SPI6LPEN field.
	RCC_C1_APB4LPENR_SPI6LPEN_Pos = 0x5
	// Bit mask of SPI6LPEN field.
	RCC_C1_APB4LPENR_SPI6LPEN_Msk = 0x20
	// Bit SPI6LPEN.
	RCC_C1_APB4LPENR_SPI6LPEN = 0x20
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_SPI6LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_SPI6LPEN_Enabled = 0x1
	// Position of I2C4LPEN field.
	RCC_C1_APB4LPENR_I2C4LPEN_Pos = 0x7
	// Bit mask of I2C4LPEN field.
	RCC_C1_APB4LPENR_I2C4LPEN_Msk = 0x80
	// Bit I2C4LPEN.
	RCC_C1_APB4LPENR_I2C4LPEN = 0x80
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_I2C4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_I2C4LPEN_Enabled = 0x1
	// Position of LPTIM2LPEN field.
	RCC_C1_APB4LPENR_LPTIM2LPEN_Pos = 0x9
	// Bit mask of LPTIM2LPEN field.
	RCC_C1_APB4LPENR_LPTIM2LPEN_Msk = 0x200
	// Bit LPTIM2LPEN.
	RCC_C1_APB4LPENR_LPTIM2LPEN = 0x200
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM2LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM2LPEN_Enabled = 0x1
	// Position of LPTIM3LPEN field.
	RCC_C1_APB4LPENR_LPTIM3LPEN_Pos = 0xa
	// Bit mask of LPTIM3LPEN field.
	RCC_C1_APB4LPENR_LPTIM3LPEN_Msk = 0x400
	// Bit LPTIM3LPEN.
	RCC_C1_APB4LPENR_LPTIM3LPEN = 0x400
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM3LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM3LPEN_Enabled = 0x1
	// Position of LPTIM4LPEN field.
	RCC_C1_APB4LPENR_LPTIM4LPEN_Pos = 0xb
	// Bit mask of LPTIM4LPEN field.
	RCC_C1_APB4LPENR_LPTIM4LPEN_Msk = 0x800
	// Bit LPTIM4LPEN.
	RCC_C1_APB4LPENR_LPTIM4LPEN = 0x800
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM4LPEN_Enabled = 0x1
	// Position of LPTIM5LPEN field.
	RCC_C1_APB4LPENR_LPTIM5LPEN_Pos = 0xc
	// Bit mask of LPTIM5LPEN field.
	RCC_C1_APB4LPENR_LPTIM5LPEN_Msk = 0x1000
	// Bit LPTIM5LPEN.
	RCC_C1_APB4LPENR_LPTIM5LPEN = 0x1000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM5LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_LPTIM5LPEN_Enabled = 0x1
	// Position of COMP12LPEN field.
	RCC_C1_APB4LPENR_COMP12LPEN_Pos = 0xe
	// Bit mask of COMP12LPEN field.
	RCC_C1_APB4LPENR_COMP12LPEN_Msk = 0x4000
	// Bit COMP12LPEN.
	RCC_C1_APB4LPENR_COMP12LPEN = 0x4000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_COMP12LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_COMP12LPEN_Enabled = 0x1
	// Position of VREFLPEN field.
	RCC_C1_APB4LPENR_VREFLPEN_Pos = 0xf
	// Bit mask of VREFLPEN field.
	RCC_C1_APB4LPENR_VREFLPEN_Msk = 0x8000
	// Bit VREFLPEN.
	RCC_C1_APB4LPENR_VREFLPEN = 0x8000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_VREFLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_VREFLPEN_Enabled = 0x1
	// Position of RTCAPBLPEN field.
	RCC_C1_APB4LPENR_RTCAPBLPEN_Pos = 0x10
	// Bit mask of RTCAPBLPEN field.
	RCC_C1_APB4LPENR_RTCAPBLPEN_Msk = 0x10000
	// Bit RTCAPBLPEN.
	RCC_C1_APB4LPENR_RTCAPBLPEN = 0x10000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_RTCAPBLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_RTCAPBLPEN_Enabled = 0x1
	// Position of SAI4LPEN field.
	RCC_C1_APB4LPENR_SAI4LPEN_Pos = 0x15
	// Bit mask of SAI4LPEN field.
	RCC_C1_APB4LPENR_SAI4LPEN_Msk = 0x200000
	// Bit SAI4LPEN.
	RCC_C1_APB4LPENR_SAI4LPEN = 0x200000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_SAI4LPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_SAI4LPEN_Enabled = 0x1
	// Position of DTSLPEN field.
	RCC_C1_APB4LPENR_DTSLPEN_Pos = 0x1a
	// Bit mask of DTSLPEN field.
	RCC_C1_APB4LPENR_DTSLPEN_Msk = 0x4000000
	// Bit DTSLPEN.
	RCC_C1_APB4LPENR_DTSLPEN = 0x4000000
	// The selected clock is disabled during csleep mode
	RCC_C1_APB4LPENR_DTSLPEN_Disabled = 0x0
	// The selected clock is enabled during csleep mode
	RCC_C1_APB4LPENR_DTSLPEN_Enabled = 0x1
)

// Constants for RNG: RNG
const (
	// CR: RNG control register
	// Position of RNGEN field.
	RNG_CR_RNGEN_Pos = 0x2
	// Bit mask of RNGEN field.
	RNG_CR_RNGEN_Msk = 0x4
	// Bit RNGEN.
	RNG_CR_RNGEN = 0x4
	// Random number generator is disabled
	RNG_CR_RNGEN_Disabled = 0x0
	// Random number generator is enabled
	RNG_CR_RNGEN_Enabled = 0x1
	// Position of IE field.
	RNG_CR_IE_Pos = 0x3
	// Bit mask of IE field.
	RNG_CR_IE_Msk = 0x8
	// Bit IE.
	RNG_CR_IE = 0x8
	// RNG interrupt is disabled
	RNG_CR_IE_Disabled = 0x0
	// RNG interrupt is enabled
	RNG_CR_IE_Enabled = 0x1
	// Position of CED field.
	RNG_CR_CED_Pos = 0x5
	// Bit mask of CED field.
	RNG_CR_CED_Msk = 0x20
	// Bit CED.
	RNG_CR_CED = 0x20
	// Clock error detection is enabled
	RNG_CR_CED_Enabled = 0x0
	// Clock error detection is disabled
	RNG_CR_CED_Disabled = 0x1

	// SR: RNG status register
	// Position of DRDY field.
	RNG_SR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	RNG_SR_DRDY_Msk = 0x1
	// Bit DRDY.
	RNG_SR_DRDY = 0x1
	// Position of CECS field.
	RNG_SR_CECS_Pos = 0x1
	// Bit mask of CECS field.
	RNG_SR_CECS_Msk = 0x2
	// Bit CECS.
	RNG_SR_CECS = 0x2
	// Position of SECS field.
	RNG_SR_SECS_Pos = 0x2
	// Bit mask of SECS field.
	RNG_SR_SECS_Msk = 0x4
	// Bit SECS.
	RNG_SR_SECS = 0x4
	// Position of CEIS field.
	RNG_SR_CEIS_Pos = 0x5
	// Bit mask of CEIS field.
	RNG_SR_CEIS_Msk = 0x20
	// Bit CEIS.
	RNG_SR_CEIS = 0x20
	// Position of SEIS field.
	RNG_SR_SEIS_Pos = 0x6
	// Bit mask of SEIS field.
	RNG_SR_SEIS_Msk = 0x40
	// Bit SEIS.
	RNG_SR_SEIS = 0x40

	// DR: The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.
	// Position of RNDATA field.
	RNG_DR_RNDATA_Pos = 0x0
	// Bit mask of RNDATA field.
	RNG_DR_RNDATA_Msk = 0xffffffff
)

// Constants for RTC: RTC
const (
	// TR: The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of SU field.
	RTC_TR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TR_SU_Msk = 0xf
	// Position of ST field.
	RTC_TR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TR_ST_Msk = 0x70
	// Position of MNU field.
	RTC_TR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_TR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TR_MNT_Msk = 0x7000
	// Position of HU field.
	RTC_TR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_TR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_TR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TR_PM = 0x400000
	// AM or 24-hour format
	RTC_TR_PM_AM = 0x0
	// PM
	RTC_TR_PM_PM = 0x1

	// DR: The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of DU field.
	RTC_DR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_DR_DU_Msk = 0xf
	// Position of DT field.
	RTC_DR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_DR_DT_Msk = 0x30
	// Position of MU field.
	RTC_DR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_DR_MU_Msk = 0xf00
	// Position of MT field.
	RTC_DR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_DR_MT_Msk = 0x1000
	// Bit MT.
	RTC_DR_MT = 0x1000
	// Position of WDU field.
	RTC_DR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_DR_WDU_Msk = 0xe000
	// Position of YU field.
	RTC_DR_YU_Pos = 0x10
	// Bit mask of YU field.
	RTC_DR_YU_Msk = 0xf0000
	// Position of YT field.
	RTC_DR_YT_Pos = 0x14
	// Bit mask of YT field.
	RTC_DR_YT_Msk = 0xf00000

	// CR: RTC control register
	// Position of WUCKSEL field.
	RTC_CR_WUCKSEL_Pos = 0x0
	// Bit mask of WUCKSEL field.
	RTC_CR_WUCKSEL_Msk = 0x7
	// RTC/16 clock is selected
	RTC_CR_WUCKSEL_Div16 = 0x0
	// RTC/8 clock is selected
	RTC_CR_WUCKSEL_Div8 = 0x1
	// RTC/4 clock is selected
	RTC_CR_WUCKSEL_Div4 = 0x2
	// RTC/2 clock is selected
	RTC_CR_WUCKSEL_Div2 = 0x3
	// ck_spre (usually 1 Hz) clock is selected
	RTC_CR_WUCKSEL_ClockSpare = 0x4
	// ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value
	RTC_CR_WUCKSEL_ClockSpareWithOffset = 0x6
	// Position of TSEDGE field.
	RTC_CR_TSEDGE_Pos = 0x3
	// Bit mask of TSEDGE field.
	RTC_CR_TSEDGE_Msk = 0x8
	// Bit TSEDGE.
	RTC_CR_TSEDGE = 0x8
	// RTC_TS input rising edge generates a time-stamp event
	RTC_CR_TSEDGE_RisingEdge = 0x0
	// RTC_TS input falling edge generates a time-stamp event
	RTC_CR_TSEDGE_FallingEdge = 0x1
	// Position of REFCKON field.
	RTC_CR_REFCKON_Pos = 0x4
	// Bit mask of REFCKON field.
	RTC_CR_REFCKON_Msk = 0x10
	// Bit REFCKON.
	RTC_CR_REFCKON = 0x10
	// RTC_REFIN detection disabled
	RTC_CR_REFCKON_Disabled = 0x0
	// RTC_REFIN detection enabled
	RTC_CR_REFCKON_Enabled = 0x1
	// Position of BYPSHAD field.
	RTC_CR_BYPSHAD_Pos = 0x5
	// Bit mask of BYPSHAD field.
	RTC_CR_BYPSHAD_Msk = 0x20
	// Bit BYPSHAD.
	RTC_CR_BYPSHAD = 0x20
	// Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles
	RTC_CR_BYPSHAD_ShadowReg = 0x0
	// Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters
	RTC_CR_BYPSHAD_BypassShadowReg = 0x1
	// Position of FMT field.
	RTC_CR_FMT_Pos = 0x6
	// Bit mask of FMT field.
	RTC_CR_FMT_Msk = 0x40
	// Bit FMT.
	RTC_CR_FMT = 0x40
	// 24 hour/day format
	RTC_CR_FMT_Twenty_Four_Hour = 0x0
	// AM/PM hour format
	RTC_CR_FMT_AM_PM = 0x1
	// Position of ALRAE field.
	RTC_CR_ALRAE_Pos = 0x8
	// Bit mask of ALRAE field.
	RTC_CR_ALRAE_Msk = 0x100
	// Bit ALRAE.
	RTC_CR_ALRAE = 0x100
	// Alarm A disabled
	RTC_CR_ALRAE_Disabled = 0x0
	// Alarm A enabled
	RTC_CR_ALRAE_Enabled = 0x1
	// Position of ALRBE field.
	RTC_CR_ALRBE_Pos = 0x9
	// Bit mask of ALRBE field.
	RTC_CR_ALRBE_Msk = 0x200
	// Bit ALRBE.
	RTC_CR_ALRBE = 0x200
	// Alarm B disabled
	RTC_CR_ALRBE_Disabled = 0x0
	// Alarm B enabled
	RTC_CR_ALRBE_Enabled = 0x1
	// Position of WUTE field.
	RTC_CR_WUTE_Pos = 0xa
	// Bit mask of WUTE field.
	RTC_CR_WUTE_Msk = 0x400
	// Bit WUTE.
	RTC_CR_WUTE = 0x400
	// Wakeup timer disabled
	RTC_CR_WUTE_Disabled = 0x0
	// Wakeup timer enabled
	RTC_CR_WUTE_Enabled = 0x1
	// Position of TSE field.
	RTC_CR_TSE_Pos = 0xb
	// Bit mask of TSE field.
	RTC_CR_TSE_Msk = 0x800
	// Bit TSE.
	RTC_CR_TSE = 0x800
	// Timestamp disabled
	RTC_CR_TSE_Disabled = 0x0
	// Timestamp enabled
	RTC_CR_TSE_Enabled = 0x1
	// Position of ALRAIE field.
	RTC_CR_ALRAIE_Pos = 0xc
	// Bit mask of ALRAIE field.
	RTC_CR_ALRAIE_Msk = 0x1000
	// Bit ALRAIE.
	RTC_CR_ALRAIE = 0x1000
	// Alarm A interrupt disabled
	RTC_CR_ALRAIE_Disabled = 0x0
	// Alarm A interrupt enabled
	RTC_CR_ALRAIE_Enabled = 0x1
	// Position of ALRBIE field.
	RTC_CR_ALRBIE_Pos = 0xd
	// Bit mask of ALRBIE field.
	RTC_CR_ALRBIE_Msk = 0x2000
	// Bit ALRBIE.
	RTC_CR_ALRBIE = 0x2000
	// Alarm B Interrupt disabled
	RTC_CR_ALRBIE_Disabled = 0x0
	// Alarm B Interrupt enabled
	RTC_CR_ALRBIE_Enabled = 0x1
	// Position of WUTIE field.
	RTC_CR_WUTIE_Pos = 0xe
	// Bit mask of WUTIE field.
	RTC_CR_WUTIE_Msk = 0x4000
	// Bit WUTIE.
	RTC_CR_WUTIE = 0x4000
	// Wakeup timer interrupt disabled
	RTC_CR_WUTIE_Disabled = 0x0
	// Wakeup timer interrupt enabled
	RTC_CR_WUTIE_Enabled = 0x1
	// Position of TSIE field.
	RTC_CR_TSIE_Pos = 0xf
	// Bit mask of TSIE field.
	RTC_CR_TSIE_Msk = 0x8000
	// Bit TSIE.
	RTC_CR_TSIE = 0x8000
	// Time-stamp Interrupt disabled
	RTC_CR_TSIE_Disabled = 0x0
	// Time-stamp Interrupt enabled
	RTC_CR_TSIE_Enabled = 0x1
	// Position of ADD1H field.
	RTC_CR_ADD1H_Pos = 0x10
	// Bit mask of ADD1H field.
	RTC_CR_ADD1H_Msk = 0x10000
	// Bit ADD1H.
	RTC_CR_ADD1H = 0x10000
	// Adds 1 hour to the current time. This can be used for summer time change outside initialization mode
	RTC_CR_ADD1H_Add1 = 0x1
	// Position of SUB1H field.
	RTC_CR_SUB1H_Pos = 0x11
	// Bit mask of SUB1H field.
	RTC_CR_SUB1H_Msk = 0x20000
	// Bit SUB1H.
	RTC_CR_SUB1H = 0x20000
	// Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode
	RTC_CR_SUB1H_Sub1 = 0x1
	// Position of BKP field.
	RTC_CR_BKP_Pos = 0x12
	// Bit mask of BKP field.
	RTC_CR_BKP_Msk = 0x40000
	// Bit BKP.
	RTC_CR_BKP = 0x40000
	// Daylight Saving Time change has not been performed
	RTC_CR_BKP_DST_Not_Changed = 0x0
	// Daylight Saving Time change has been performed
	RTC_CR_BKP_DST_Changed = 0x1
	// Position of COSEL field.
	RTC_CR_COSEL_Pos = 0x13
	// Bit mask of COSEL field.
	RTC_CR_COSEL_Msk = 0x80000
	// Bit COSEL.
	RTC_CR_COSEL = 0x80000
	// Calibration output is 512 Hz (with default prescaler setting)
	RTC_CR_COSEL_CalFreq_512Hz = 0x0
	// Calibration output is 1 Hz (with default prescaler setting)
	RTC_CR_COSEL_CalFreq_1Hz = 0x1
	// Position of POL field.
	RTC_CR_POL_Pos = 0x14
	// Bit mask of POL field.
	RTC_CR_POL_Msk = 0x100000
	// Bit POL.
	RTC_CR_POL = 0x100000
	// The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
	RTC_CR_POL_High = 0x0
	// The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
	RTC_CR_POL_Low = 0x1
	// Position of OSEL field.
	RTC_CR_OSEL_Pos = 0x15
	// Bit mask of OSEL field.
	RTC_CR_OSEL_Msk = 0x600000
	// Output disabled
	RTC_CR_OSEL_Disabled = 0x0
	// Alarm A output enabled
	RTC_CR_OSEL_AlarmA = 0x1
	// Alarm B output enabled
	RTC_CR_OSEL_AlarmB = 0x2
	// Wakeup output enabled
	RTC_CR_OSEL_Wakeup = 0x3
	// Position of COE field.
	RTC_CR_COE_Pos = 0x17
	// Bit mask of COE field.
	RTC_CR_COE_Msk = 0x800000
	// Bit COE.
	RTC_CR_COE = 0x800000
	// Calibration output disabled
	RTC_CR_COE_Disabled = 0x0
	// Calibration output enabled
	RTC_CR_COE_Enabled = 0x1
	// Position of ITSE field.
	RTC_CR_ITSE_Pos = 0x18
	// Bit mask of ITSE field.
	RTC_CR_ITSE_Msk = 0x1000000
	// Bit ITSE.
	RTC_CR_ITSE = 0x1000000
	// Internal event timestamp is disabled
	RTC_CR_ITSE_Disabled = 0x0
	// Internal event timestamp is enabled
	RTC_CR_ITSE_Enabled = 0x1

	// ISR: This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
	// Position of ALRAWF field.
	RTC_ISR_ALRAWF_Pos = 0x0
	// Bit mask of ALRAWF field.
	RTC_ISR_ALRAWF_Msk = 0x1
	// Bit ALRAWF.
	RTC_ISR_ALRAWF = 0x1
	// Alarm update not allowed
	RTC_ISR_ALRAWF_UpdateNotAllowed = 0x0
	// Alarm update allowed
	RTC_ISR_ALRAWF_UpdateAllowed = 0x1
	// Position of ALRBWF field.
	RTC_ISR_ALRBWF_Pos = 0x1
	// Bit mask of ALRBWF field.
	RTC_ISR_ALRBWF_Msk = 0x2
	// Bit ALRBWF.
	RTC_ISR_ALRBWF = 0x2
	// Alarm update not allowed
	RTC_ISR_ALRBWF_UpdateNotAllowed = 0x0
	// Alarm update allowed
	RTC_ISR_ALRBWF_UpdateAllowed = 0x1
	// Position of WUTWF field.
	RTC_ISR_WUTWF_Pos = 0x2
	// Bit mask of WUTWF field.
	RTC_ISR_WUTWF_Msk = 0x4
	// Bit WUTWF.
	RTC_ISR_WUTWF = 0x4
	// Wakeup timer configuration update not allowed
	RTC_ISR_WUTWF_UpdateNotAllowed = 0x0
	// Wakeup timer configuration update allowed
	RTC_ISR_WUTWF_UpdateAllowed = 0x1
	// Position of SHPF field.
	RTC_ISR_SHPF_Pos = 0x3
	// Bit mask of SHPF field.
	RTC_ISR_SHPF_Msk = 0x8
	// Bit SHPF.
	RTC_ISR_SHPF = 0x8
	// No shift operation is pending
	RTC_ISR_SHPF_NoShiftPending = 0x0
	// A shift operation is pending
	RTC_ISR_SHPF_ShiftPending = 0x1
	// Position of INITS field.
	RTC_ISR_INITS_Pos = 0x4
	// Bit mask of INITS field.
	RTC_ISR_INITS_Msk = 0x10
	// Bit INITS.
	RTC_ISR_INITS = 0x10
	// Calendar has not been initialized
	RTC_ISR_INITS_NotInitalized = 0x0
	// Calendar has been initialized
	RTC_ISR_INITS_Initalized = 0x1
	// Position of RSF field.
	RTC_ISR_RSF_Pos = 0x5
	// Bit mask of RSF field.
	RTC_ISR_RSF_Msk = 0x20
	// Bit RSF.
	RTC_ISR_RSF = 0x20
	// Calendar shadow registers not yet synchronized
	RTC_ISR_RSF_NotSynced = 0x0
	// Calendar shadow registers synchronized
	RTC_ISR_RSF_Synced = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_RSF_Clear = 0x0
	// Position of INITF field.
	RTC_ISR_INITF_Pos = 0x6
	// Bit mask of INITF field.
	RTC_ISR_INITF_Msk = 0x40
	// Bit INITF.
	RTC_ISR_INITF = 0x40
	// Calendar registers update is not allowed
	RTC_ISR_INITF_NotAllowed = 0x0
	// Calendar registers update is allowed
	RTC_ISR_INITF_Allowed = 0x1
	// Position of INIT field.
	RTC_ISR_INIT_Pos = 0x7
	// Bit mask of INIT field.
	RTC_ISR_INIT_Msk = 0x80
	// Bit INIT.
	RTC_ISR_INIT = 0x80
	// Free running mode
	RTC_ISR_INIT_FreeRunningMode = 0x0
	// Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset.
	RTC_ISR_INIT_InitMode = 0x1
	// Position of ALRAF field.
	RTC_ISR_ALRAF_Pos = 0x8
	// Bit mask of ALRAF field.
	RTC_ISR_ALRAF_Msk = 0x100
	// Bit ALRAF.
	RTC_ISR_ALRAF = 0x100
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR)
	RTC_ISR_ALRAF_Match = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_ALRAF_Clear = 0x0
	// Position of ALRBF field.
	RTC_ISR_ALRBF_Pos = 0x9
	// Bit mask of ALRBF field.
	RTC_ISR_ALRBF_Msk = 0x200
	// Bit ALRBF.
	RTC_ISR_ALRBF = 0x200
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR)
	RTC_ISR_ALRBF_Match = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_ALRBF_Clear = 0x0
	// Position of WUTF field.
	RTC_ISR_WUTF_Pos = 0xa
	// Bit mask of WUTF field.
	RTC_ISR_WUTF_Msk = 0x400
	// Bit WUTF.
	RTC_ISR_WUTF = 0x400
	// This flag is set by hardware when the wakeup auto-reload counter reaches 0
	RTC_ISR_WUTF_Zero = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_WUTF_Clear = 0x0
	// Position of TSF field.
	RTC_ISR_TSF_Pos = 0xb
	// Bit mask of TSF field.
	RTC_ISR_TSF_Msk = 0x800
	// Bit TSF.
	RTC_ISR_TSF = 0x800
	// This flag is set by hardware when a time-stamp event occurs
	RTC_ISR_TSF_TimestampEvent = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_TSF_Clear = 0x0
	// Position of TSOVF field.
	RTC_ISR_TSOVF_Pos = 0xc
	// Bit mask of TSOVF field.
	RTC_ISR_TSOVF_Msk = 0x1000
	// Bit TSOVF.
	RTC_ISR_TSOVF = 0x1000
	// This flag is set by hardware when a time-stamp event occurs while TSF is already set
	RTC_ISR_TSOVF_Overflow = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_TSOVF_Clear = 0x0
	// Position of TAMP1F field.
	RTC_ISR_TAMP1F_Pos = 0xd
	// Bit mask of TAMP1F field.
	RTC_ISR_TAMP1F_Msk = 0x2000
	// Bit TAMP1F.
	RTC_ISR_TAMP1F = 0x2000
	// This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
	RTC_ISR_TAMP1F_Tampered = 0x1
	// Flag cleared by software writing 0
	RTC_ISR_TAMP1F_Clear = 0x0
	// Position of TAMP2F field.
	RTC_ISR_TAMP2F_Pos = 0xe
	// Bit mask of TAMP2F field.
	RTC_ISR_TAMP2F_Msk = 0x4000
	// Bit TAMP2F.
	RTC_ISR_TAMP2F = 0x4000
	// This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
	RTC_ISR_TAMP2F_Tampered = 0x1
	// Flag cleared by software writing 0
	RTC_ISR_TAMP2F_Clear = 0x0
	// Position of TAMP3F field.
	RTC_ISR_TAMP3F_Pos = 0xf
	// Bit mask of TAMP3F field.
	RTC_ISR_TAMP3F_Msk = 0x8000
	// Bit TAMP3F.
	RTC_ISR_TAMP3F = 0x8000
	// This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
	RTC_ISR_TAMP3F_Tampered = 0x1
	// Flag cleared by software writing 0
	RTC_ISR_TAMP3F_Clear = 0x0
	// Position of RECALPF field.
	RTC_ISR_RECALPF_Pos = 0x10
	// Bit mask of RECALPF field.
	RTC_ISR_RECALPF_Msk = 0x10000
	// Bit RECALPF.
	RTC_ISR_RECALPF = 0x10000
	// The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0
	RTC_ISR_RECALPF_Pending = 0x1
	// Position of ITSF field.
	RTC_ISR_ITSF_Pos = 0x11
	// Bit mask of ITSF field.
	RTC_ISR_ITSF_Msk = 0x20000
	// Bit ITSF.
	RTC_ISR_ITSF = 0x20000
	// This flag is set by hardware when a time-stamp on the internal event occurs
	RTC_ISR_ITSF_Match = 0x1
	// This flag is cleared by software by writing 0, and must be cleared together with TSF bit by writing 0 in both bits
	RTC_ISR_ITSF_Clear = 0x0

	// PRER: This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of PREDIV_S field.
	RTC_PRER_PREDIV_S_Pos = 0x0
	// Bit mask of PREDIV_S field.
	RTC_PRER_PREDIV_S_Msk = 0x7fff
	// Position of PREDIV_A field.
	RTC_PRER_PREDIV_A_Pos = 0x10
	// Bit mask of PREDIV_A field.
	RTC_PRER_PREDIV_A_Msk = 0x7f0000

	// WUTR: This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of WUT field.
	RTC_WUTR_WUT_Pos = 0x0
	// Bit mask of WUT field.
	RTC_WUTR_WUT_Msk = 0xffff

	// ALRMAR: This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of SU field.
	RTC_ALRMAR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMAR_SU_Msk = 0xf
	// Position of ST field.
	RTC_ALRMAR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMAR_ST_Msk = 0x70
	// Position of MSK1 field.
	RTC_ALRMAR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMAR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMAR_MSK1 = 0x80
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK1_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK1_NotMask = 0x1
	// Position of MNU field.
	RTC_ALRMAR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMAR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_ALRMAR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMAR_MNT_Msk = 0x7000
	// Position of MSK2 field.
	RTC_ALRMAR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMAR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMAR_MSK2 = 0x8000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK2_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK2_NotMask = 0x1
	// Position of HU field.
	RTC_ALRMAR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMAR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_ALRMAR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMAR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_ALRMAR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMAR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMAR_PM = 0x400000
	// AM or 24-hour format
	RTC_ALRMAR_PM_AM = 0x0
	// PM
	RTC_ALRMAR_PM_PM = 0x1
	// Position of MSK3 field.
	RTC_ALRMAR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMAR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMAR_MSK3 = 0x800000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK3_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK3_NotMask = 0x1
	// Position of DU field.
	RTC_ALRMAR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMAR_DU_Msk = 0xf000000
	// Position of DT field.
	RTC_ALRMAR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMAR_DT_Msk = 0x30000000
	// Position of WDSEL field.
	RTC_ALRMAR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMAR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMAR_WDSEL = 0x40000000
	// DU[3:0] represents the date units
	RTC_ALRMAR_WDSEL_DateUnits = 0x0
	// DU[3:0] represents the week day. DT[1:0] is dont care.
	RTC_ALRMAR_WDSEL_WeekDay = 0x1
	// Position of MSK4 field.
	RTC_ALRMAR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMAR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMAR_MSK4 = 0x80000000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK4_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK4_NotMask = 0x1

	// ALRMBR: This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of SU field.
	RTC_ALRMBR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMBR_SU_Msk = 0xf
	// Position of ST field.
	RTC_ALRMBR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMBR_ST_Msk = 0x70
	// Position of MSK1 field.
	RTC_ALRMBR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMBR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMBR_MSK1 = 0x80
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK1_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK1_NotMask = 0x1
	// Position of MNU field.
	RTC_ALRMBR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMBR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_ALRMBR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMBR_MNT_Msk = 0x7000
	// Position of MSK2 field.
	RTC_ALRMBR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMBR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMBR_MSK2 = 0x8000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK2_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK2_NotMask = 0x1
	// Position of HU field.
	RTC_ALRMBR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMBR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_ALRMBR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMBR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_ALRMBR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMBR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMBR_PM = 0x400000
	// AM or 24-hour format
	RTC_ALRMBR_PM_AM = 0x0
	// PM
	RTC_ALRMBR_PM_PM = 0x1
	// Position of MSK3 field.
	RTC_ALRMBR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMBR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMBR_MSK3 = 0x800000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK3_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK3_NotMask = 0x1
	// Position of DU field.
	RTC_ALRMBR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMBR_DU_Msk = 0xf000000
	// Position of DT field.
	RTC_ALRMBR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMBR_DT_Msk = 0x30000000
	// Position of WDSEL field.
	RTC_ALRMBR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMBR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMBR_WDSEL = 0x40000000
	// DU[3:0] represents the date units
	RTC_ALRMBR_WDSEL_DateUnits = 0x0
	// DU[3:0] represents the week day. DT[1:0] is dont care.
	RTC_ALRMBR_WDSEL_WeekDay = 0x1
	// Position of MSK4 field.
	RTC_ALRMBR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMBR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMBR_MSK4 = 0x80000000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK4_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK4_NotMask = 0x1

	// WPR: RTC write protection register
	// Position of KEY field.
	RTC_WPR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	RTC_WPR_KEY_Msk = 0xff

	// SSR: RTC sub second register
	// Position of SS field.
	RTC_SSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_SSR_SS_Msk = 0xffff

	// SHIFTR: This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of SUBFS field.
	RTC_SHIFTR_SUBFS_Pos = 0x0
	// Bit mask of SUBFS field.
	RTC_SHIFTR_SUBFS_Msk = 0x7fff
	// Position of ADD1S field.
	RTC_SHIFTR_ADD1S_Pos = 0x1f
	// Bit mask of ADD1S field.
	RTC_SHIFTR_ADD1S_Msk = 0x80000000
	// Bit ADD1S.
	RTC_SHIFTR_ADD1S = 0x80000000
	// Add one second to the clock/calendar
	RTC_SHIFTR_ADD1S_Add1 = 0x1

	// TSTR: The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
	// Position of SU field.
	RTC_TSTR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TSTR_SU_Msk = 0xf
	// Position of ST field.
	RTC_TSTR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TSTR_ST_Msk = 0x70
	// Position of MNU field.
	RTC_TSTR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TSTR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_TSTR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TSTR_MNT_Msk = 0x7000
	// Position of HU field.
	RTC_TSTR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TSTR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_TSTR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TSTR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_TSTR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TSTR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TSTR_PM = 0x400000

	// TSDR: The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
	// Position of DU field.
	RTC_TSDR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_TSDR_DU_Msk = 0xf
	// Position of DT field.
	RTC_TSDR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_TSDR_DT_Msk = 0x30
	// Position of MU field.
	RTC_TSDR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_TSDR_MU_Msk = 0xf00
	// Position of MT field.
	RTC_TSDR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_TSDR_MT_Msk = 0x1000
	// Bit MT.
	RTC_TSDR_MT = 0x1000
	// Position of WDU field.
	RTC_TSDR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_TSDR_WDU_Msk = 0xe000

	// TSSSR: The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
	// Position of SS field.
	RTC_TSSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_TSSSR_SS_Msk = 0xffff

	// CALR: This register is write protected. The write access procedure is described in RTC register write protection on page9.
	// Position of CALM field.
	RTC_CALR_CALM_Pos = 0x0
	// Bit mask of CALM field.
	RTC_CALR_CALM_Msk = 0x1ff
	// Position of CALW16 field.
	RTC_CALR_CALW16_Pos = 0xd
	// Bit mask of CALW16 field.
	RTC_CALR_CALW16_Msk = 0x2000
	// Bit CALW16.
	RTC_CALR_CALW16 = 0x2000
	// When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1
	RTC_CALR_CALW16_Sixteen_Second = 0x1
	// Position of CALW8 field.
	RTC_CALR_CALW8_Pos = 0xe
	// Bit mask of CALW8 field.
	RTC_CALR_CALW8_Msk = 0x4000
	// Bit CALW8.
	RTC_CALR_CALW8 = 0x4000
	// When CALW8 is set to 1, the 8-second calibration cycle period is selected
	RTC_CALR_CALW8_Eight_Second = 0x1
	// Position of CALP field.
	RTC_CALR_CALP_Pos = 0xf
	// Bit mask of CALP field.
	RTC_CALR_CALP_Msk = 0x8000
	// Bit CALP.
	RTC_CALR_CALP = 0x8000
	// No RTCCLK pulses are added
	RTC_CALR_CALP_NoChange = 0x0
	// One RTCCLK pulse is effectively inserted every 2^11 pulses (frequency increased by 488.5 ppm)
	RTC_CALR_CALP_IncreaseFreq = 0x1

	// TAMPCR: RTC tamper and alternate function configuration register
	// Position of TAMP1E field.
	RTC_TAMPCR_TAMP1E_Pos = 0x0
	// Bit mask of TAMP1E field.
	RTC_TAMPCR_TAMP1E_Msk = 0x1
	// Bit TAMP1E.
	RTC_TAMPCR_TAMP1E = 0x1
	// Position of TAMP1TRG field.
	RTC_TAMPCR_TAMP1TRG_Pos = 0x1
	// Bit mask of TAMP1TRG field.
	RTC_TAMPCR_TAMP1TRG_Msk = 0x2
	// Bit TAMP1TRG.
	RTC_TAMPCR_TAMP1TRG = 0x2
	// Position of TAMPIE field.
	RTC_TAMPCR_TAMPIE_Pos = 0x2
	// Bit mask of TAMPIE field.
	RTC_TAMPCR_TAMPIE_Msk = 0x4
	// Bit TAMPIE.
	RTC_TAMPCR_TAMPIE = 0x4
	// Position of TAMP2E field.
	RTC_TAMPCR_TAMP2E_Pos = 0x3
	// Bit mask of TAMP2E field.
	RTC_TAMPCR_TAMP2E_Msk = 0x8
	// Bit TAMP2E.
	RTC_TAMPCR_TAMP2E = 0x8
	// Position of TAMP2TRG field.
	RTC_TAMPCR_TAMP2TRG_Pos = 0x4
	// Bit mask of TAMP2TRG field.
	RTC_TAMPCR_TAMP2TRG_Msk = 0x10
	// Bit TAMP2TRG.
	RTC_TAMPCR_TAMP2TRG = 0x10
	// Position of TAMP3E field.
	RTC_TAMPCR_TAMP3E_Pos = 0x5
	// Bit mask of TAMP3E field.
	RTC_TAMPCR_TAMP3E_Msk = 0x20
	// Bit TAMP3E.
	RTC_TAMPCR_TAMP3E = 0x20
	// Position of TAMP3TRG field.
	RTC_TAMPCR_TAMP3TRG_Pos = 0x6
	// Bit mask of TAMP3TRG field.
	RTC_TAMPCR_TAMP3TRG_Msk = 0x40
	// Bit TAMP3TRG.
	RTC_TAMPCR_TAMP3TRG = 0x40
	// Position of TAMPTS field.
	RTC_TAMPCR_TAMPTS_Pos = 0x7
	// Bit mask of TAMPTS field.
	RTC_TAMPCR_TAMPTS_Msk = 0x80
	// Bit TAMPTS.
	RTC_TAMPCR_TAMPTS = 0x80
	// Position of TAMPFREQ field.
	RTC_TAMPCR_TAMPFREQ_Pos = 0x8
	// Bit mask of TAMPFREQ field.
	RTC_TAMPCR_TAMPFREQ_Msk = 0x700
	// Position of TAMPFLT field.
	RTC_TAMPCR_TAMPFLT_Pos = 0xb
	// Bit mask of TAMPFLT field.
	RTC_TAMPCR_TAMPFLT_Msk = 0x1800
	// Position of TAMPPRCH field.
	RTC_TAMPCR_TAMPPRCH_Pos = 0xd
	// Bit mask of TAMPPRCH field.
	RTC_TAMPCR_TAMPPRCH_Msk = 0x6000
	// Position of TAMPPUDIS field.
	RTC_TAMPCR_TAMPPUDIS_Pos = 0xf
	// Bit mask of TAMPPUDIS field.
	RTC_TAMPCR_TAMPPUDIS_Msk = 0x8000
	// Bit TAMPPUDIS.
	RTC_TAMPCR_TAMPPUDIS = 0x8000
	// Position of TAMP1IE field.
	RTC_TAMPCR_TAMP1IE_Pos = 0x10
	// Bit mask of TAMP1IE field.
	RTC_TAMPCR_TAMP1IE_Msk = 0x10000
	// Bit TAMP1IE.
	RTC_TAMPCR_TAMP1IE = 0x10000
	// Position of TAMP1NOERASE field.
	RTC_TAMPCR_TAMP1NOERASE_Pos = 0x11
	// Bit mask of TAMP1NOERASE field.
	RTC_TAMPCR_TAMP1NOERASE_Msk = 0x20000
	// Bit TAMP1NOERASE.
	RTC_TAMPCR_TAMP1NOERASE = 0x20000
	// Position of TAMP1MF field.
	RTC_TAMPCR_TAMP1MF_Pos = 0x12
	// Bit mask of TAMP1MF field.
	RTC_TAMPCR_TAMP1MF_Msk = 0x40000
	// Bit TAMP1MF.
	RTC_TAMPCR_TAMP1MF = 0x40000
	// Position of TAMP2IE field.
	RTC_TAMPCR_TAMP2IE_Pos = 0x13
	// Bit mask of TAMP2IE field.
	RTC_TAMPCR_TAMP2IE_Msk = 0x80000
	// Bit TAMP2IE.
	RTC_TAMPCR_TAMP2IE = 0x80000
	// Position of TAMP2NOERASE field.
	RTC_TAMPCR_TAMP2NOERASE_Pos = 0x14
	// Bit mask of TAMP2NOERASE field.
	RTC_TAMPCR_TAMP2NOERASE_Msk = 0x100000
	// Bit TAMP2NOERASE.
	RTC_TAMPCR_TAMP2NOERASE = 0x100000
	// Position of TAMP2MF field.
	RTC_TAMPCR_TAMP2MF_Pos = 0x15
	// Bit mask of TAMP2MF field.
	RTC_TAMPCR_TAMP2MF_Msk = 0x200000
	// Bit TAMP2MF.
	RTC_TAMPCR_TAMP2MF = 0x200000
	// Position of TAMP3IE field.
	RTC_TAMPCR_TAMP3IE_Pos = 0x16
	// Bit mask of TAMP3IE field.
	RTC_TAMPCR_TAMP3IE_Msk = 0x400000
	// Bit TAMP3IE.
	RTC_TAMPCR_TAMP3IE = 0x400000
	// Position of TAMP3NOERASE field.
	RTC_TAMPCR_TAMP3NOERASE_Pos = 0x17
	// Bit mask of TAMP3NOERASE field.
	RTC_TAMPCR_TAMP3NOERASE_Msk = 0x800000
	// Bit TAMP3NOERASE.
	RTC_TAMPCR_TAMP3NOERASE = 0x800000
	// Position of TAMP3MF field.
	RTC_TAMPCR_TAMP3MF_Pos = 0x18
	// Bit mask of TAMP3MF field.
	RTC_TAMPCR_TAMP3MF_Msk = 0x1000000
	// Bit TAMP3MF.
	RTC_TAMPCR_TAMP3MF = 0x1000000

	// ALRMASSR: This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
	// Position of SS field.
	RTC_ALRMASSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMASSR_SS_Msk = 0x7fff
	// Position of MASKSS field.
	RTC_ALRMASSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMASSR_MASKSS_Msk = 0xf000000

	// ALRMBSSR: This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
	// Position of SS field.
	RTC_ALRMBSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMBSSR_SS_Msk = 0x7fff
	// Position of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Msk = 0xf000000

	// OR: RTC option register
	// Position of RTC_ALARM_TYPE field.
	RTC_OR_RTC_ALARM_TYPE_Pos = 0x0
	// Bit mask of RTC_ALARM_TYPE field.
	RTC_OR_RTC_ALARM_TYPE_Msk = 0x1
	// Bit RTC_ALARM_TYPE.
	RTC_OR_RTC_ALARM_TYPE = 0x1
	// Position of RTC_OUT_RMP field.
	RTC_OR_RTC_OUT_RMP_Pos = 0x1
	// Bit mask of RTC_OUT_RMP field.
	RTC_OR_RTC_OUT_RMP_Msk = 0x2
	// Bit RTC_OUT_RMP.
	RTC_OR_RTC_OUT_RMP = 0x2

	// BKP0R: RTC backup registers
	// Position of BKP field.
	RTC_BKPR_BKP_Pos = 0x0
	// Bit mask of BKP field.
	RTC_BKPR_BKP_Msk = 0xffffffff
)

// Constants for SAI1: SAI
const (
	// GCR: Global configuration register
	// Position of SYNCOUT field.
	SAI_GCR_SYNCOUT_Pos = 0x4
	// Bit mask of SYNCOUT field.
	SAI_GCR_SYNCOUT_Msk = 0x30
	// Position of SYNCIN field.
	SAI_GCR_SYNCIN_Pos = 0x0
	// Bit mask of SYNCIN field.
	SAI_GCR_SYNCIN_Msk = 0x3

	// CH.CR1: Configuration register 1
	// Position of MODE field.
	SAI_CH_CR1_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SAI_CH_CR1_MODE_Msk = 0x3
	// Master transmitter
	SAI_CH_CR1_MODE_MasterTx = 0x0
	// Master receiver
	SAI_CH_CR1_MODE_MasterRx = 0x1
	// Slave transmitter
	SAI_CH_CR1_MODE_SlaveTx = 0x2
	// Slave receiver
	SAI_CH_CR1_MODE_SlaveRx = 0x3
	// Position of PRTCFG field.
	SAI_CH_CR1_PRTCFG_Pos = 0x2
	// Bit mask of PRTCFG field.
	SAI_CH_CR1_PRTCFG_Msk = 0xc
	// Free protocol. Free protocol allows to use the powerful configuration of the audio block to address a specific audio protocol
	SAI_CH_CR1_PRTCFG_Free = 0x0
	// SPDIF protocol
	SAI_CH_CR1_PRTCFG_Spdif = 0x1
	// AC97 protocol
	SAI_CH_CR1_PRTCFG_Ac97 = 0x2
	// Position of DS field.
	SAI_CH_CR1_DS_Pos = 0x5
	// Bit mask of DS field.
	SAI_CH_CR1_DS_Msk = 0xe0
	// 8 bits
	SAI_CH_CR1_DS_Bit8 = 0x2
	// 10 bits
	SAI_CH_CR1_DS_Bit10 = 0x3
	// 16 bits
	SAI_CH_CR1_DS_Bit16 = 0x4
	// 20 bits
	SAI_CH_CR1_DS_Bit20 = 0x5
	// 24 bits
	SAI_CH_CR1_DS_Bit24 = 0x6
	// 32 bits
	SAI_CH_CR1_DS_Bit32 = 0x7
	// Position of LSBFIRST field.
	SAI_CH_CR1_LSBFIRST_Pos = 0x8
	// Bit mask of LSBFIRST field.
	SAI_CH_CR1_LSBFIRST_Msk = 0x100
	// Bit LSBFIRST.
	SAI_CH_CR1_LSBFIRST = 0x100
	// Data are transferred with MSB first
	SAI_CH_CR1_LSBFIRST_MsbFirst = 0x0
	// Data are transferred with LSB first
	SAI_CH_CR1_LSBFIRST_LsbFirst = 0x1
	// Position of CKSTR field.
	SAI_CH_CR1_CKSTR_Pos = 0x9
	// Bit mask of CKSTR field.
	SAI_CH_CR1_CKSTR_Msk = 0x200
	// Bit CKSTR.
	SAI_CH_CR1_CKSTR = 0x200
	// Data strobing edge is falling edge of SCK
	SAI_CH_CR1_CKSTR_FallingEdge = 0x0
	// Data strobing edge is rising edge of SCK
	SAI_CH_CR1_CKSTR_RisingEdge = 0x1
	// Position of SYNCEN field.
	SAI_CH_CR1_SYNCEN_Pos = 0xa
	// Bit mask of SYNCEN field.
	SAI_CH_CR1_SYNCEN_Msk = 0xc00
	// audio sub-block in asynchronous mode
	SAI_CH_CR1_SYNCEN_Asynchronous = 0x0
	// audio sub-block is synchronous with the other internal audio sub-block. In this case, the audio sub-block must be configured in slave mode
	SAI_CH_CR1_SYNCEN_Internal = 0x1
	// audio sub-block is synchronous with an external SAI embedded peripheral. In this case the audio sub-block should be configured in Slave mode
	SAI_CH_CR1_SYNCEN_External = 0x2
	// Position of MONO field.
	SAI_CH_CR1_MONO_Pos = 0xc
	// Bit mask of MONO field.
	SAI_CH_CR1_MONO_Msk = 0x1000
	// Bit MONO.
	SAI_CH_CR1_MONO = 0x1000
	// Stereo mode
	SAI_CH_CR1_MONO_Stereo = 0x0
	// Mono mode
	SAI_CH_CR1_MONO_Mono = 0x1
	// Position of OUTDRIV field.
	SAI_CH_CR1_OUTDRIV_Pos = 0xd
	// Bit mask of OUTDRIV field.
	SAI_CH_CR1_OUTDRIV_Msk = 0x2000
	// Bit OUTDRIV.
	SAI_CH_CR1_OUTDRIV = 0x2000
	// Audio block output driven when SAIEN is set
	SAI_CH_CR1_OUTDRIV_OnStart = 0x0
	// Audio block output driven immediately after the setting of this bit
	SAI_CH_CR1_OUTDRIV_Immediately = 0x1
	// Position of SAIEN field.
	SAI_CH_CR1_SAIEN_Pos = 0x10
	// Bit mask of SAIEN field.
	SAI_CH_CR1_SAIEN_Msk = 0x10000
	// Bit SAIEN.
	SAI_CH_CR1_SAIEN = 0x10000
	// SAI audio block disabled
	SAI_CH_CR1_SAIEN_Disabled = 0x0
	// SAI audio block enabled
	SAI_CH_CR1_SAIEN_Enabled = 0x1
	// Position of DMAEN field.
	SAI_CH_CR1_DMAEN_Pos = 0x11
	// Bit mask of DMAEN field.
	SAI_CH_CR1_DMAEN_Msk = 0x20000
	// Bit DMAEN.
	SAI_CH_CR1_DMAEN = 0x20000
	// DMA disabled
	SAI_CH_CR1_DMAEN_Disabled = 0x0
	// DMA enabled
	SAI_CH_CR1_DMAEN_Enabled = 0x1
	// Position of MCKDIV field.
	SAI_CH_CR1_MCKDIV_Pos = 0x14
	// Bit mask of MCKDIV field.
	SAI_CH_CR1_MCKDIV_Msk = 0x3f00000
	// Position of OSR field.
	SAI_CH_CR1_OSR_Pos = 0x1a
	// Bit mask of OSR field.
	SAI_CH_CR1_OSR_Msk = 0x4000000
	// Bit OSR.
	SAI_CH_CR1_OSR = 0x4000000
	// Position of NODIV field.
	SAI_CH_CR1_NODIV_Pos = 0x13
	// Bit mask of NODIV field.
	SAI_CH_CR1_NODIV_Msk = 0x80000
	// Bit NODIV.
	SAI_CH_CR1_NODIV = 0x80000
	// MCLK output is enabled. Forces the ratio between FS and MCLK to 256 or 512 according to the OSR value
	SAI_CH_CR1_NODIV_MasterClock = 0x0
	// MCLK output enable set by the MCKEN bit (where present, else 0). Ratio between FS and MCLK depends on FRL.
	SAI_CH_CR1_NODIV_NoDiv = 0x1
	// Position of MCKEN field.
	SAI_CH_CR1_MCKEN_Pos = 0x1b
	// Bit mask of MCKEN field.
	SAI_CH_CR1_MCKEN_Msk = 0x8000000
	// Bit MCKEN.
	SAI_CH_CR1_MCKEN = 0x8000000

	// CH.CR2: Configuration register 2
	// Position of FTH field.
	SAI_CH_CR2_FTH_Pos = 0x0
	// Bit mask of FTH field.
	SAI_CH_CR2_FTH_Msk = 0x7
	// FIFO empty
	SAI_CH_CR2_FTH_Empty = 0x0
	// 14 FIFO
	SAI_CH_CR2_FTH_Quarter1 = 0x1
	// 12 FIFO
	SAI_CH_CR2_FTH_Quarter2 = 0x2
	// 34 FIFO
	SAI_CH_CR2_FTH_Quarter3 = 0x3
	// FIFO full
	SAI_CH_CR2_FTH_Full = 0x4
	// Position of FFLUSH field.
	SAI_CH_CR2_FFLUSH_Pos = 0x3
	// Bit mask of FFLUSH field.
	SAI_CH_CR2_FFLUSH_Msk = 0x8
	// Bit FFLUSH.
	SAI_CH_CR2_FFLUSH = 0x8
	// No FIFO flush
	SAI_CH_CR2_FFLUSH_NoFlush = 0x0
	// FIFO flush. Programming this bit to 1 triggers the FIFO Flush. All the internal FIFO pointers (read and write) are cleared
	SAI_CH_CR2_FFLUSH_Flush = 0x1
	// Position of TRIS field.
	SAI_CH_CR2_TRIS_Pos = 0x4
	// Bit mask of TRIS field.
	SAI_CH_CR2_TRIS_Msk = 0x10
	// Bit TRIS.
	SAI_CH_CR2_TRIS = 0x10
	// Position of MUTE field.
	SAI_CH_CR2_MUTE_Pos = 0x5
	// Bit mask of MUTE field.
	SAI_CH_CR2_MUTE_Msk = 0x20
	// Bit MUTE.
	SAI_CH_CR2_MUTE = 0x20
	// No mute mode
	SAI_CH_CR2_MUTE_Disabled = 0x0
	// Mute mode enabled
	SAI_CH_CR2_MUTE_Enabled = 0x1
	// Position of MUTEVAL field.
	SAI_CH_CR2_MUTEVAL_Pos = 0x6
	// Bit mask of MUTEVAL field.
	SAI_CH_CR2_MUTEVAL_Msk = 0x40
	// Bit MUTEVAL.
	SAI_CH_CR2_MUTEVAL = 0x40
	// Bit value 0 is sent during the mute mode
	SAI_CH_CR2_MUTEVAL_SendZero = 0x0
	// Last values are sent during the mute mode
	SAI_CH_CR2_MUTEVAL_SendLast = 0x1
	// Position of MUTECNT field.
	SAI_CH_CR2_MUTECNT_Pos = 0x7
	// Bit mask of MUTECNT field.
	SAI_CH_CR2_MUTECNT_Msk = 0x1f80
	// Position of CPL field.
	SAI_CH_CR2_CPL_Pos = 0xd
	// Bit mask of CPL field.
	SAI_CH_CR2_CPL_Msk = 0x2000
	// Bit CPL.
	SAI_CH_CR2_CPL = 0x2000
	// 1s complement representation
	SAI_CH_CR2_CPL_OnesComplement = 0x0
	// 2s complement representation
	SAI_CH_CR2_CPL_TwosComplement = 0x1
	// Position of COMP field.
	SAI_CH_CR2_COMP_Pos = 0xe
	// Bit mask of COMP field.
	SAI_CH_CR2_COMP_Msk = 0xc000
	// No companding algorithm
	SAI_CH_CR2_COMP_NoCompanding = 0x0
	// -Law algorithm
	SAI_CH_CR2_COMP_MuLaw = 0x2
	// A-Law algorithm
	SAI_CH_CR2_COMP_ALaw = 0x3

	// CH.FRCR: This register has no meaning in AC97 and SPDIF audio protocol
	// Position of FRL field.
	SAI_CH_FRCR_FRL_Pos = 0x0
	// Bit mask of FRL field.
	SAI_CH_FRCR_FRL_Msk = 0xff
	// Position of FSALL field.
	SAI_CH_FRCR_FSALL_Pos = 0x8
	// Bit mask of FSALL field.
	SAI_CH_FRCR_FSALL_Msk = 0x7f00
	// Position of FSDEF field.
	SAI_CH_FRCR_FSDEF_Pos = 0x10
	// Bit mask of FSDEF field.
	SAI_CH_FRCR_FSDEF_Msk = 0x10000
	// Bit FSDEF.
	SAI_CH_FRCR_FSDEF = 0x10000
	// Position of FSPOL field.
	SAI_CH_FRCR_FSPOL_Pos = 0x11
	// Bit mask of FSPOL field.
	SAI_CH_FRCR_FSPOL_Msk = 0x20000
	// Bit FSPOL.
	SAI_CH_FRCR_FSPOL = 0x20000
	// FS is active low (falling edge)
	SAI_CH_FRCR_FSPOL_FallingEdge = 0x0
	// FS is active high (rising edge)
	SAI_CH_FRCR_FSPOL_RisingEdge = 0x1
	// Position of FSOFF field.
	SAI_CH_FRCR_FSOFF_Pos = 0x12
	// Bit mask of FSOFF field.
	SAI_CH_FRCR_FSOFF_Msk = 0x40000
	// Bit FSOFF.
	SAI_CH_FRCR_FSOFF = 0x40000
	// FS is asserted on the first bit of the slot 0
	SAI_CH_FRCR_FSOFF_OnFirst = 0x0
	// FS is asserted one bit before the first bit of the slot 0
	SAI_CH_FRCR_FSOFF_BeforeFirst = 0x1

	// CH.SLOTR: This register has no meaning in AC97 and SPDIF audio protocol
	// Position of FBOFF field.
	SAI_CH_SLOTR_FBOFF_Pos = 0x0
	// Bit mask of FBOFF field.
	SAI_CH_SLOTR_FBOFF_Msk = 0x1f
	// Position of SLOTSZ field.
	SAI_CH_SLOTR_SLOTSZ_Pos = 0x6
	// Bit mask of SLOTSZ field.
	SAI_CH_SLOTR_SLOTSZ_Msk = 0xc0
	// The slot size is equivalent to the data size (specified in DS[3:0] in the SAI_xCR1 register)
	SAI_CH_SLOTR_SLOTSZ_DataSize = 0x0
	// 16-bit
	SAI_CH_SLOTR_SLOTSZ_Bit16 = 0x1
	// 32-bit
	SAI_CH_SLOTR_SLOTSZ_Bit32 = 0x2
	// Position of NBSLOT field.
	SAI_CH_SLOTR_NBSLOT_Pos = 0x8
	// Bit mask of NBSLOT field.
	SAI_CH_SLOTR_NBSLOT_Msk = 0xf00
	// Position of SLOTEN field.
	SAI_CH_SLOTR_SLOTEN_Pos = 0x10
	// Bit mask of SLOTEN field.
	SAI_CH_SLOTR_SLOTEN_Msk = 0xffff0000
	// Inactive slot
	SAI_CH_SLOTR_SLOTEN_Inactive = 0x0
	// Active slot
	SAI_CH_SLOTR_SLOTEN_Active = 0x1

	// CH.IM: Interrupt mask register 2
	// Position of OVRUDRIE field.
	SAI_CH_IM_OVRUDRIE_Pos = 0x0
	// Bit mask of OVRUDRIE field.
	SAI_CH_IM_OVRUDRIE_Msk = 0x1
	// Bit OVRUDRIE.
	SAI_CH_IM_OVRUDRIE = 0x1
	// Interrupt is disabled
	SAI_CH_IM_OVRUDRIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_OVRUDRIE_Enabled = 0x1
	// Position of MUTEDETIE field.
	SAI_CH_IM_MUTEDETIE_Pos = 0x1
	// Bit mask of MUTEDETIE field.
	SAI_CH_IM_MUTEDETIE_Msk = 0x2
	// Bit MUTEDETIE.
	SAI_CH_IM_MUTEDETIE = 0x2
	// Interrupt is disabled
	SAI_CH_IM_MUTEDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_MUTEDETIE_Enabled = 0x1
	// Position of WCKCFGIE field.
	SAI_CH_IM_WCKCFGIE_Pos = 0x2
	// Bit mask of WCKCFGIE field.
	SAI_CH_IM_WCKCFGIE_Msk = 0x4
	// Bit WCKCFGIE.
	SAI_CH_IM_WCKCFGIE = 0x4
	// Interrupt is disabled
	SAI_CH_IM_WCKCFGIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_WCKCFGIE_Enabled = 0x1
	// Position of FREQIE field.
	SAI_CH_IM_FREQIE_Pos = 0x3
	// Bit mask of FREQIE field.
	SAI_CH_IM_FREQIE_Msk = 0x8
	// Bit FREQIE.
	SAI_CH_IM_FREQIE = 0x8
	// Interrupt is disabled
	SAI_CH_IM_FREQIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_FREQIE_Enabled = 0x1
	// Position of CNRDYIE field.
	SAI_CH_IM_CNRDYIE_Pos = 0x4
	// Bit mask of CNRDYIE field.
	SAI_CH_IM_CNRDYIE_Msk = 0x10
	// Bit CNRDYIE.
	SAI_CH_IM_CNRDYIE = 0x10
	// Interrupt is disabled
	SAI_CH_IM_CNRDYIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_CNRDYIE_Enabled = 0x1
	// Position of AFSDETIE field.
	SAI_CH_IM_AFSDETIE_Pos = 0x5
	// Bit mask of AFSDETIE field.
	SAI_CH_IM_AFSDETIE_Msk = 0x20
	// Bit AFSDETIE.
	SAI_CH_IM_AFSDETIE = 0x20
	// Interrupt is disabled
	SAI_CH_IM_AFSDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_AFSDETIE_Enabled = 0x1
	// Position of LFSDETIE field.
	SAI_CH_IM_LFSDETIE_Pos = 0x6
	// Bit mask of LFSDETIE field.
	SAI_CH_IM_LFSDETIE_Msk = 0x40
	// Bit LFSDETIE.
	SAI_CH_IM_LFSDETIE = 0x40
	// Interrupt is disabled
	SAI_CH_IM_LFSDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_LFSDETIE_Enabled = 0x1

	// CH.SR: Status register
	// Position of OVRUDR field.
	SAI_CH_SR_OVRUDR_Pos = 0x0
	// Bit mask of OVRUDR field.
	SAI_CH_SR_OVRUDR_Msk = 0x1
	// Bit OVRUDR.
	SAI_CH_SR_OVRUDR = 0x1
	// No overrun/underrun error
	SAI_CH_SR_OVRUDR_NoError = 0x0
	// Overrun/underrun error detection
	SAI_CH_SR_OVRUDR_Overrun = 0x1
	// Position of MUTEDET field.
	SAI_CH_SR_MUTEDET_Pos = 0x1
	// Bit mask of MUTEDET field.
	SAI_CH_SR_MUTEDET_Msk = 0x2
	// Bit MUTEDET.
	SAI_CH_SR_MUTEDET = 0x2
	// No MUTE detection on the SD input line
	SAI_CH_SR_MUTEDET_NoMute = 0x0
	// MUTE value detected on the SD input line (0 value) for a specified number of consecutive audio frame
	SAI_CH_SR_MUTEDET_Mute = 0x1
	// Position of WCKCFG field.
	SAI_CH_SR_WCKCFG_Pos = 0x2
	// Bit mask of WCKCFG field.
	SAI_CH_SR_WCKCFG_Msk = 0x4
	// Bit WCKCFG.
	SAI_CH_SR_WCKCFG = 0x4
	// Clock configuration is correct
	SAI_CH_SR_WCKCFG_Correct = 0x0
	// Clock configuration does not respect the rule concerning the frame length specification
	SAI_CH_SR_WCKCFG_Wrong = 0x1
	// Position of FREQ field.
	SAI_CH_SR_FREQ_Pos = 0x3
	// Bit mask of FREQ field.
	SAI_CH_SR_FREQ_Msk = 0x8
	// Bit FREQ.
	SAI_CH_SR_FREQ = 0x8
	// No FIFO request
	SAI_CH_SR_FREQ_NoRequest = 0x0
	// FIFO request to read or to write the SAI_xDR
	SAI_CH_SR_FREQ_Request = 0x1
	// Position of CNRDY field.
	SAI_CH_SR_CNRDY_Pos = 0x4
	// Bit mask of CNRDY field.
	SAI_CH_SR_CNRDY_Msk = 0x10
	// Bit CNRDY.
	SAI_CH_SR_CNRDY = 0x10
	// External AC97 Codec is ready
	SAI_CH_SR_CNRDY_Ready = 0x0
	// External AC97 Codec is not ready
	SAI_CH_SR_CNRDY_NotReady = 0x1
	// Position of AFSDET field.
	SAI_CH_SR_AFSDET_Pos = 0x5
	// Bit mask of AFSDET field.
	SAI_CH_SR_AFSDET_Msk = 0x20
	// Bit AFSDET.
	SAI_CH_SR_AFSDET = 0x20
	// No error
	SAI_CH_SR_AFSDET_NoError = 0x0
	// Frame synchronization signal is detected earlier than expected
	SAI_CH_SR_AFSDET_EarlySync = 0x1
	// Position of LFSDET field.
	SAI_CH_SR_LFSDET_Pos = 0x6
	// Bit mask of LFSDET field.
	SAI_CH_SR_LFSDET_Msk = 0x40
	// Bit LFSDET.
	SAI_CH_SR_LFSDET = 0x40
	// No error
	SAI_CH_SR_LFSDET_NoError = 0x0
	// Frame synchronization signal is not present at the right time
	SAI_CH_SR_LFSDET_NoSync = 0x1
	// Position of FLVL field.
	SAI_CH_SR_FLVL_Pos = 0x10
	// Bit mask of FLVL field.
	SAI_CH_SR_FLVL_Msk = 0x70000
	// FIFO empty
	SAI_CH_SR_FLVL_Empty = 0x0
	// FIFO <= 14 but not empty
	SAI_CH_SR_FLVL_Quarter1 = 0x1
	// 14 < FIFO <= 12
	SAI_CH_SR_FLVL_Quarter2 = 0x2
	// 12 < FIFO <= 34
	SAI_CH_SR_FLVL_Quarter3 = 0x3
	// 34 < FIFO but not full
	SAI_CH_SR_FLVL_Quarter4 = 0x4
	// FIFO full
	SAI_CH_SR_FLVL_Full = 0x5

	// CH.CLRFR: Clear flag register
	// Position of COVRUDR field.
	SAI_CH_CLRFR_COVRUDR_Pos = 0x0
	// Bit mask of COVRUDR field.
	SAI_CH_CLRFR_COVRUDR_Msk = 0x1
	// Bit COVRUDR.
	SAI_CH_CLRFR_COVRUDR = 0x1
	// Clears the OVRUDR flag
	SAI_CH_CLRFR_COVRUDR_Clear = 0x1
	// Position of CMUTEDET field.
	SAI_CH_CLRFR_CMUTEDET_Pos = 0x1
	// Bit mask of CMUTEDET field.
	SAI_CH_CLRFR_CMUTEDET_Msk = 0x2
	// Bit CMUTEDET.
	SAI_CH_CLRFR_CMUTEDET = 0x2
	// Clears the MUTEDET flag
	SAI_CH_CLRFR_CMUTEDET_Clear = 0x1
	// Position of CWCKCFG field.
	SAI_CH_CLRFR_CWCKCFG_Pos = 0x2
	// Bit mask of CWCKCFG field.
	SAI_CH_CLRFR_CWCKCFG_Msk = 0x4
	// Bit CWCKCFG.
	SAI_CH_CLRFR_CWCKCFG = 0x4
	// Clears the WCKCFG flag
	SAI_CH_CLRFR_CWCKCFG_Clear = 0x1
	// Position of CCNRDY field.
	SAI_CH_CLRFR_CCNRDY_Pos = 0x4
	// Bit mask of CCNRDY field.
	SAI_CH_CLRFR_CCNRDY_Msk = 0x10
	// Bit CCNRDY.
	SAI_CH_CLRFR_CCNRDY = 0x10
	// Clears the CNRDY flag
	SAI_CH_CLRFR_CCNRDY_Clear = 0x1
	// Position of CAFSDET field.
	SAI_CH_CLRFR_CAFSDET_Pos = 0x5
	// Bit mask of CAFSDET field.
	SAI_CH_CLRFR_CAFSDET_Msk = 0x20
	// Bit CAFSDET.
	SAI_CH_CLRFR_CAFSDET = 0x20
	// Clears the AFSDET flag
	SAI_CH_CLRFR_CAFSDET_Clear = 0x1
	// Position of CLFSDET field.
	SAI_CH_CLRFR_CLFSDET_Pos = 0x6
	// Bit mask of CLFSDET field.
	SAI_CH_CLRFR_CLFSDET_Msk = 0x40
	// Bit CLFSDET.
	SAI_CH_CLRFR_CLFSDET = 0x40
	// Clears the LFSDET flag
	SAI_CH_CLRFR_CLFSDET_Clear = 0x1

	// CH.DR: Data register
	// Position of DATA field.
	SAI_CH_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SAI_CH_DR_DATA_Msk = 0xffffffff

	// PDMCR: PDM control register
	// Position of PDMEN field.
	SAI_PDMCR_PDMEN_Pos = 0x0
	// Bit mask of PDMEN field.
	SAI_PDMCR_PDMEN_Msk = 0x1
	// Bit PDMEN.
	SAI_PDMCR_PDMEN = 0x1
	// Position of MICNBR field.
	SAI_PDMCR_MICNBR_Pos = 0x4
	// Bit mask of MICNBR field.
	SAI_PDMCR_MICNBR_Msk = 0x30
	// Position of CKEN1 field.
	SAI_PDMCR_CKEN1_Pos = 0x8
	// Bit mask of CKEN1 field.
	SAI_PDMCR_CKEN1_Msk = 0x100
	// Bit CKEN1.
	SAI_PDMCR_CKEN1 = 0x100
	// Position of CKEN2 field.
	SAI_PDMCR_CKEN2_Pos = 0x9
	// Bit mask of CKEN2 field.
	SAI_PDMCR_CKEN2_Msk = 0x200
	// Bit CKEN2.
	SAI_PDMCR_CKEN2 = 0x200
	// Position of CKEN3 field.
	SAI_PDMCR_CKEN3_Pos = 0xa
	// Bit mask of CKEN3 field.
	SAI_PDMCR_CKEN3_Msk = 0x400
	// Bit CKEN3.
	SAI_PDMCR_CKEN3 = 0x400
	// Position of CKEN4 field.
	SAI_PDMCR_CKEN4_Pos = 0xb
	// Bit mask of CKEN4 field.
	SAI_PDMCR_CKEN4_Msk = 0x800
	// Bit CKEN4.
	SAI_PDMCR_CKEN4 = 0x800

	// PDMDLY: PDM delay register
	// Position of DLYM1L field.
	SAI_PDMDLY_DLYM1L_Pos = 0x0
	// Bit mask of DLYM1L field.
	SAI_PDMDLY_DLYM1L_Msk = 0x7
	// Position of DLYM1R field.
	SAI_PDMDLY_DLYM1R_Pos = 0x4
	// Bit mask of DLYM1R field.
	SAI_PDMDLY_DLYM1R_Msk = 0x70
	// Position of DLYM2L field.
	SAI_PDMDLY_DLYM2L_Pos = 0x8
	// Bit mask of DLYM2L field.
	SAI_PDMDLY_DLYM2L_Msk = 0x700
	// Position of DLYM2R field.
	SAI_PDMDLY_DLYM2R_Pos = 0xc
	// Bit mask of DLYM2R field.
	SAI_PDMDLY_DLYM2R_Msk = 0x7000
	// Position of DLYM3L field.
	SAI_PDMDLY_DLYM3L_Pos = 0x10
	// Bit mask of DLYM3L field.
	SAI_PDMDLY_DLYM3L_Msk = 0x70000
	// Position of DLYM3R field.
	SAI_PDMDLY_DLYM3R_Pos = 0x14
	// Bit mask of DLYM3R field.
	SAI_PDMDLY_DLYM3R_Msk = 0x700000
	// Position of DLYM4L field.
	SAI_PDMDLY_DLYM4L_Pos = 0x18
	// Bit mask of DLYM4L field.
	SAI_PDMDLY_DLYM4L_Msk = 0x7000000
	// Position of DLYM4R field.
	SAI_PDMDLY_DLYM4R_Pos = 0x1c
	// Bit mask of DLYM4R field.
	SAI_PDMDLY_DLYM4R_Msk = 0x70000000
)

// Constants for SCB: System control block
const (
	// CPUID: CPUID base register
	// Position of Revision field.
	SCB_CPUID_Revision_Pos = 0x0
	// Bit mask of Revision field.
	SCB_CPUID_Revision_Msk = 0xf
	// Position of PartNo field.
	SCB_CPUID_PartNo_Pos = 0x4
	// Bit mask of PartNo field.
	SCB_CPUID_PartNo_Msk = 0xfff0
	// Position of Constant field.
	SCB_CPUID_Constant_Pos = 0x10
	// Bit mask of Constant field.
	SCB_CPUID_Constant_Msk = 0xf0000
	// Position of Variant field.
	SCB_CPUID_Variant_Pos = 0x14
	// Bit mask of Variant field.
	SCB_CPUID_Variant_Msk = 0xf00000
	// Position of Implementer field.
	SCB_CPUID_Implementer_Pos = 0x18
	// Bit mask of Implementer field.
	SCB_CPUID_Implementer_Msk = 0xff000000

	// ICSR: Interrupt control and state register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x7f000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000

	// VTOR: Vector table offset register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x9
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0x3ffffe00

	// AIRCR: Application interrupt and reset control register
	// Position of VECTRESET field.
	SCB_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SCB_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SCB_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// Position of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Pos = 0xf
	// Bit mask of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Msk = 0x8000
	// Bit ENDIANESS.
	SCB_AIRCR_ENDIANESS = 0x8000
	// Position of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Pos = 0x10
	// Bit mask of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Msk = 0xffff0000

	// SCR: System control register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// Position of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Pos = 0x4
	// Bit mask of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Msk = 0x10
	// Bit SEVEONPEND.
	SCB_SCR_SEVEONPEND = 0x10

	// CCR: Configuration and control register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// Position of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Pos = 0x3
	// Bit mask of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Msk = 0x8
	// Bit UNALIGN__TRP.
	SCB_CCR_UNALIGN__TRP = 0x8
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200
	// Position of DC field.
	SCB_CCR_DC_Pos = 0x10
	// Bit mask of DC field.
	SCB_CCR_DC_Msk = 0x10000
	// Bit DC.
	SCB_CCR_DC = 0x10000
	// Position of IC field.
	SCB_CCR_IC_Pos = 0x11
	// Bit mask of IC field.
	SCB_CCR_IC_Msk = 0x20000
	// Bit IC.
	SCB_CCR_IC = 0x20000
	// Position of BP field.
	SCB_CCR_BP_Pos = 0x12
	// Bit mask of BP field.
	SCB_CCR_BP_Msk = 0x40000
	// Bit BP.
	SCB_CCR_BP = 0x40000

	// SHPR1: System handler priority registers
	// Position of PRI_4 field.
	SCB_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SCB_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SCB_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SCB_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SCB_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SCB_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System handler priority registers
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System handler priority registers
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System handler control and state register
	// Position of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SCB_SHCSR_MEMFAULTACT = 0x1
	// Position of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SCB_SHCSR_BUSFAULTACT = 0x2
	// Position of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SCB_SHCSR_USGFAULTACT = 0x8
	// Position of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SCB_SHCSR_SVCALLACT = 0x80
	// Position of MONITORACT field.
	SCB_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SCB_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SCB_SHCSR_MONITORACT = 0x100
	// Position of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SCB_SHCSR_PENDSVACT = 0x400
	// Position of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SCB_SHCSR_SYSTICKACT = 0x800
	// Position of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SCB_SHCSR_USGFAULTPENDED = 0x1000
	// Position of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SCB_SHCSR_MEMFAULTPENDED = 0x2000
	// Position of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SCB_SHCSR_BUSFAULTPENDED = 0x4000
	// Position of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SCB_SHCSR_SVCALLPENDED = 0x8000
	// Position of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SCB_SHCSR_MEMFAULTENA = 0x10000
	// Position of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SCB_SHCSR_BUSFAULTENA = 0x20000
	// Position of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SCB_SHCSR_USGFAULTENA = 0x40000

	// CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
	// Position of IACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 0x1
	// Position of DACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL = 0x2
	// Position of MUNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 0x8
	// Position of MSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 0x10
	// Position of MLSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 0x20
	// Position of MMARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 0x80
	// Position of IBUSERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 0x100
	// Position of PRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 0x200
	// Position of IMPRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 0x400
	// Position of UNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 0x800
	// Position of STKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 0x1000
	// Position of LSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 0x2000
	// Position of BFARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 0x8000
	// Position of UNDEFINSTR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 0x10000
	// Position of INVSTATE field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 0x20000
	// Position of INVPC field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 0x40000
	// Position of NOCP field.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 0x80000
	// Position of UNALIGNED field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 0x1000000
	// Position of DIVBYZERO field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 0x2000000

	// HFSR: Hard fault status register
	// Position of VECTTBL field.
	SCB_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SCB_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SCB_HFSR_VECTTBL = 0x2
	// Position of FORCED field.
	SCB_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SCB_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SCB_HFSR_FORCED = 0x40000000
	// Position of DEBUG_VT field.
	SCB_HFSR_DEBUG_VT_Pos = 0x1f
	// Bit mask of DEBUG_VT field.
	SCB_HFSR_DEBUG_VT_Msk = 0x80000000
	// Bit DEBUG_VT.
	SCB_HFSR_DEBUG_VT = 0x80000000

	// MMFAR: Memory management fault address register
	// Position of ADDRESS field.
	SCB_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: Bus fault address register
	// Position of ADDRESS field.
	SCB_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_BFAR_ADDRESS_Msk = 0xffffffff
)

// Constants for SDMMC1: SDMMC1
const (
	// POWER: SDMMC power control register
	// Position of PWRCTRL field.
	SDMMC_POWER_PWRCTRL_Pos = 0x0
	// Bit mask of PWRCTRL field.
	SDMMC_POWER_PWRCTRL_Msk = 0x3
	// Position of VSWITCH field.
	SDMMC_POWER_VSWITCH_Pos = 0x2
	// Bit mask of VSWITCH field.
	SDMMC_POWER_VSWITCH_Msk = 0x4
	// Bit VSWITCH.
	SDMMC_POWER_VSWITCH = 0x4
	// Position of VSWITCHEN field.
	SDMMC_POWER_VSWITCHEN_Pos = 0x3
	// Bit mask of VSWITCHEN field.
	SDMMC_POWER_VSWITCHEN_Msk = 0x8
	// Bit VSWITCHEN.
	SDMMC_POWER_VSWITCHEN = 0x8
	// Position of DIRPOL field.
	SDMMC_POWER_DIRPOL_Pos = 0x4
	// Bit mask of DIRPOL field.
	SDMMC_POWER_DIRPOL_Msk = 0x10
	// Bit DIRPOL.
	SDMMC_POWER_DIRPOL = 0x10

	// CLKCR: The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
	// Position of CLKDIV field.
	SDMMC_CLKCR_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	SDMMC_CLKCR_CLKDIV_Msk = 0x3ff
	// Position of PWRSAV field.
	SDMMC_CLKCR_PWRSAV_Pos = 0xc
	// Bit mask of PWRSAV field.
	SDMMC_CLKCR_PWRSAV_Msk = 0x1000
	// Bit PWRSAV.
	SDMMC_CLKCR_PWRSAV = 0x1000
	// Position of WIDBUS field.
	SDMMC_CLKCR_WIDBUS_Pos = 0xe
	// Bit mask of WIDBUS field.
	SDMMC_CLKCR_WIDBUS_Msk = 0xc000
	// Position of NEGEDGE field.
	SDMMC_CLKCR_NEGEDGE_Pos = 0x10
	// Bit mask of NEGEDGE field.
	SDMMC_CLKCR_NEGEDGE_Msk = 0x10000
	// Bit NEGEDGE.
	SDMMC_CLKCR_NEGEDGE = 0x10000
	// Position of HWFC_EN field.
	SDMMC_CLKCR_HWFC_EN_Pos = 0x11
	// Bit mask of HWFC_EN field.
	SDMMC_CLKCR_HWFC_EN_Msk = 0x20000
	// Bit HWFC_EN.
	SDMMC_CLKCR_HWFC_EN = 0x20000
	// Position of DDR field.
	SDMMC_CLKCR_DDR_Pos = 0x12
	// Bit mask of DDR field.
	SDMMC_CLKCR_DDR_Msk = 0x40000
	// Bit DDR.
	SDMMC_CLKCR_DDR = 0x40000
	// Position of BUSSPEED field.
	SDMMC_CLKCR_BUSSPEED_Pos = 0x13
	// Bit mask of BUSSPEED field.
	SDMMC_CLKCR_BUSSPEED_Msk = 0x80000
	// Bit BUSSPEED.
	SDMMC_CLKCR_BUSSPEED = 0x80000
	// Position of SELCLKRX field.
	SDMMC_CLKCR_SELCLKRX_Pos = 0x14
	// Bit mask of SELCLKRX field.
	SDMMC_CLKCR_SELCLKRX_Msk = 0x300000

	// ARGR: The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
	// Position of CMDARG field.
	SDMMC_ARGR_CMDARG_Pos = 0x0
	// Bit mask of CMDARG field.
	SDMMC_ARGR_CMDARG_Msk = 0xffffffff

	// CMDR: The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
	// Position of CMDINDEX field.
	SDMMC_CMDR_CMDINDEX_Pos = 0x0
	// Bit mask of CMDINDEX field.
	SDMMC_CMDR_CMDINDEX_Msk = 0x3f
	// Position of CMDTRANS field.
	SDMMC_CMDR_CMDTRANS_Pos = 0x6
	// Bit mask of CMDTRANS field.
	SDMMC_CMDR_CMDTRANS_Msk = 0x40
	// Bit CMDTRANS.
	SDMMC_CMDR_CMDTRANS = 0x40
	// Position of CMDSTOP field.
	SDMMC_CMDR_CMDSTOP_Pos = 0x7
	// Bit mask of CMDSTOP field.
	SDMMC_CMDR_CMDSTOP_Msk = 0x80
	// Bit CMDSTOP.
	SDMMC_CMDR_CMDSTOP = 0x80
	// Position of WAITRESP field.
	SDMMC_CMDR_WAITRESP_Pos = 0x8
	// Bit mask of WAITRESP field.
	SDMMC_CMDR_WAITRESP_Msk = 0x300
	// Position of WAITINT field.
	SDMMC_CMDR_WAITINT_Pos = 0xa
	// Bit mask of WAITINT field.
	SDMMC_CMDR_WAITINT_Msk = 0x400
	// Bit WAITINT.
	SDMMC_CMDR_WAITINT = 0x400
	// Position of WAITPEND field.
	SDMMC_CMDR_WAITPEND_Pos = 0xb
	// Bit mask of WAITPEND field.
	SDMMC_CMDR_WAITPEND_Msk = 0x800
	// Bit WAITPEND.
	SDMMC_CMDR_WAITPEND = 0x800
	// Position of CPSMEN field.
	SDMMC_CMDR_CPSMEN_Pos = 0xc
	// Bit mask of CPSMEN field.
	SDMMC_CMDR_CPSMEN_Msk = 0x1000
	// Bit CPSMEN.
	SDMMC_CMDR_CPSMEN = 0x1000
	// Position of DTHOLD field.
	SDMMC_CMDR_DTHOLD_Pos = 0xd
	// Bit mask of DTHOLD field.
	SDMMC_CMDR_DTHOLD_Msk = 0x2000
	// Bit DTHOLD.
	SDMMC_CMDR_DTHOLD = 0x2000
	// Position of BOOTMODE field.
	SDMMC_CMDR_BOOTMODE_Pos = 0xe
	// Bit mask of BOOTMODE field.
	SDMMC_CMDR_BOOTMODE_Msk = 0x4000
	// Bit BOOTMODE.
	SDMMC_CMDR_BOOTMODE = 0x4000
	// Position of BOOTEN field.
	SDMMC_CMDR_BOOTEN_Pos = 0xf
	// Bit mask of BOOTEN field.
	SDMMC_CMDR_BOOTEN_Msk = 0x8000
	// Bit BOOTEN.
	SDMMC_CMDR_BOOTEN = 0x8000
	// Position of CMDSUSPEND field.
	SDMMC_CMDR_CMDSUSPEND_Pos = 0x10
	// Bit mask of CMDSUSPEND field.
	SDMMC_CMDR_CMDSUSPEND_Msk = 0x10000
	// Bit CMDSUSPEND.
	SDMMC_CMDR_CMDSUSPEND = 0x10000

	// RESPCMDR: SDMMC command response register
	// Position of RESPCMD field.
	SDMMC_RESPCMDR_RESPCMD_Pos = 0x0
	// Bit mask of RESPCMD field.
	SDMMC_RESPCMDR_RESPCMD_Msk = 0x3f

	// RESP1R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	// Position of CARDSTATUS1 field.
	SDMMC_RESP1R_CARDSTATUS1_Pos = 0x0
	// Bit mask of CARDSTATUS1 field.
	SDMMC_RESP1R_CARDSTATUS1_Msk = 0xffffffff

	// RESP2R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	// Position of CARDSTATUS2 field.
	SDMMC_RESP2R_CARDSTATUS2_Pos = 0x0
	// Bit mask of CARDSTATUS2 field.
	SDMMC_RESP2R_CARDSTATUS2_Msk = 0xffffffff

	// RESP3R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	// Position of CARDSTATUS3 field.
	SDMMC_RESP3R_CARDSTATUS3_Pos = 0x0
	// Bit mask of CARDSTATUS3 field.
	SDMMC_RESP3R_CARDSTATUS3_Msk = 0xffffffff

	// RESP4R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	// Position of CARDSTATUS4 field.
	SDMMC_RESP4R_CARDSTATUS4_Pos = 0x0
	// Bit mask of CARDSTATUS4 field.
	SDMMC_RESP4R_CARDSTATUS4_Msk = 0xffffffff

	// DTIMER: The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
	// Position of DATATIME field.
	SDMMC_DTIMER_DATATIME_Pos = 0x0
	// Bit mask of DATATIME field.
	SDMMC_DTIMER_DATATIME_Msk = 0xffffffff

	// DLENR: The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
	// Position of DATALENGTH field.
	SDMMC_DLENR_DATALENGTH_Pos = 0x0
	// Bit mask of DATALENGTH field.
	SDMMC_DLENR_DATALENGTH_Msk = 0x1ffffff

	// DCTRL: The SDMMC_DCTRL register control the data path state machine (DPSM).
	// Position of DTEN field.
	SDMMC_DCTRL_DTEN_Pos = 0x0
	// Bit mask of DTEN field.
	SDMMC_DCTRL_DTEN_Msk = 0x1
	// Bit DTEN.
	SDMMC_DCTRL_DTEN = 0x1
	// Position of DTDIR field.
	SDMMC_DCTRL_DTDIR_Pos = 0x1
	// Bit mask of DTDIR field.
	SDMMC_DCTRL_DTDIR_Msk = 0x2
	// Bit DTDIR.
	SDMMC_DCTRL_DTDIR = 0x2
	// Position of DTMODE field.
	SDMMC_DCTRL_DTMODE_Pos = 0x2
	// Bit mask of DTMODE field.
	SDMMC_DCTRL_DTMODE_Msk = 0xc
	// Position of DBLOCKSIZE field.
	SDMMC_DCTRL_DBLOCKSIZE_Pos = 0x4
	// Bit mask of DBLOCKSIZE field.
	SDMMC_DCTRL_DBLOCKSIZE_Msk = 0xf0
	// Position of RWSTART field.
	SDMMC_DCTRL_RWSTART_Pos = 0x8
	// Bit mask of RWSTART field.
	SDMMC_DCTRL_RWSTART_Msk = 0x100
	// Bit RWSTART.
	SDMMC_DCTRL_RWSTART = 0x100
	// Position of RWSTOP field.
	SDMMC_DCTRL_RWSTOP_Pos = 0x9
	// Bit mask of RWSTOP field.
	SDMMC_DCTRL_RWSTOP_Msk = 0x200
	// Bit RWSTOP.
	SDMMC_DCTRL_RWSTOP = 0x200
	// Position of RWMOD field.
	SDMMC_DCTRL_RWMOD_Pos = 0xa
	// Bit mask of RWMOD field.
	SDMMC_DCTRL_RWMOD_Msk = 0x400
	// Bit RWMOD.
	SDMMC_DCTRL_RWMOD = 0x400
	// Position of SDIOEN field.
	SDMMC_DCTRL_SDIOEN_Pos = 0xb
	// Bit mask of SDIOEN field.
	SDMMC_DCTRL_SDIOEN_Msk = 0x800
	// Bit SDIOEN.
	SDMMC_DCTRL_SDIOEN = 0x800
	// Position of BOOTACKEN field.
	SDMMC_DCTRL_BOOTACKEN_Pos = 0xc
	// Bit mask of BOOTACKEN field.
	SDMMC_DCTRL_BOOTACKEN_Msk = 0x1000
	// Bit BOOTACKEN.
	SDMMC_DCTRL_BOOTACKEN = 0x1000
	// Position of FIFORST field.
	SDMMC_DCTRL_FIFORST_Pos = 0xd
	// Bit mask of FIFORST field.
	SDMMC_DCTRL_FIFORST_Msk = 0x2000
	// Bit FIFORST.
	SDMMC_DCTRL_FIFORST = 0x2000

	// DCNTR: The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
	// Position of DATACOUNT field.
	SDMMC_DCNTR_DATACOUNT_Pos = 0x0
	// Bit mask of DATACOUNT field.
	SDMMC_DCNTR_DATACOUNT_Msk = 0x1ffffff

	// STAR: The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
	// Position of CCRCFAIL field.
	SDMMC_STAR_CCRCFAIL_Pos = 0x0
	// Bit mask of CCRCFAIL field.
	SDMMC_STAR_CCRCFAIL_Msk = 0x1
	// Bit CCRCFAIL.
	SDMMC_STAR_CCRCFAIL = 0x1
	// Position of DCRCFAIL field.
	SDMMC_STAR_DCRCFAIL_Pos = 0x1
	// Bit mask of DCRCFAIL field.
	SDMMC_STAR_DCRCFAIL_Msk = 0x2
	// Bit DCRCFAIL.
	SDMMC_STAR_DCRCFAIL = 0x2
	// Position of CTIMEOUT field.
	SDMMC_STAR_CTIMEOUT_Pos = 0x2
	// Bit mask of CTIMEOUT field.
	SDMMC_STAR_CTIMEOUT_Msk = 0x4
	// Bit CTIMEOUT.
	SDMMC_STAR_CTIMEOUT = 0x4
	// Position of DTIMEOUT field.
	SDMMC_STAR_DTIMEOUT_Pos = 0x3
	// Bit mask of DTIMEOUT field.
	SDMMC_STAR_DTIMEOUT_Msk = 0x8
	// Bit DTIMEOUT.
	SDMMC_STAR_DTIMEOUT = 0x8
	// Position of TXUNDERR field.
	SDMMC_STAR_TXUNDERR_Pos = 0x4
	// Bit mask of TXUNDERR field.
	SDMMC_STAR_TXUNDERR_Msk = 0x10
	// Bit TXUNDERR.
	SDMMC_STAR_TXUNDERR = 0x10
	// Position of RXOVERR field.
	SDMMC_STAR_RXOVERR_Pos = 0x5
	// Bit mask of RXOVERR field.
	SDMMC_STAR_RXOVERR_Msk = 0x20
	// Bit RXOVERR.
	SDMMC_STAR_RXOVERR = 0x20
	// Position of CMDREND field.
	SDMMC_STAR_CMDREND_Pos = 0x6
	// Bit mask of CMDREND field.
	SDMMC_STAR_CMDREND_Msk = 0x40
	// Bit CMDREND.
	SDMMC_STAR_CMDREND = 0x40
	// Position of CMDSENT field.
	SDMMC_STAR_CMDSENT_Pos = 0x7
	// Bit mask of CMDSENT field.
	SDMMC_STAR_CMDSENT_Msk = 0x80
	// Bit CMDSENT.
	SDMMC_STAR_CMDSENT = 0x80
	// Position of DATAEND field.
	SDMMC_STAR_DATAEND_Pos = 0x8
	// Bit mask of DATAEND field.
	SDMMC_STAR_DATAEND_Msk = 0x100
	// Bit DATAEND.
	SDMMC_STAR_DATAEND = 0x100
	// Position of DHOLD field.
	SDMMC_STAR_DHOLD_Pos = 0x9
	// Bit mask of DHOLD field.
	SDMMC_STAR_DHOLD_Msk = 0x200
	// Bit DHOLD.
	SDMMC_STAR_DHOLD = 0x200
	// Position of DBCKEND field.
	SDMMC_STAR_DBCKEND_Pos = 0xa
	// Bit mask of DBCKEND field.
	SDMMC_STAR_DBCKEND_Msk = 0x400
	// Bit DBCKEND.
	SDMMC_STAR_DBCKEND = 0x400
	// Position of DABORT field.
	SDMMC_STAR_DABORT_Pos = 0xb
	// Bit mask of DABORT field.
	SDMMC_STAR_DABORT_Msk = 0x800
	// Bit DABORT.
	SDMMC_STAR_DABORT = 0x800
	// Position of DPSMACT field.
	SDMMC_STAR_DPSMACT_Pos = 0xc
	// Bit mask of DPSMACT field.
	SDMMC_STAR_DPSMACT_Msk = 0x1000
	// Bit DPSMACT.
	SDMMC_STAR_DPSMACT = 0x1000
	// Position of CPSMACT field.
	SDMMC_STAR_CPSMACT_Pos = 0xd
	// Bit mask of CPSMACT field.
	SDMMC_STAR_CPSMACT_Msk = 0x2000
	// Bit CPSMACT.
	SDMMC_STAR_CPSMACT = 0x2000
	// Position of TXFIFOHE field.
	SDMMC_STAR_TXFIFOHE_Pos = 0xe
	// Bit mask of TXFIFOHE field.
	SDMMC_STAR_TXFIFOHE_Msk = 0x4000
	// Bit TXFIFOHE.
	SDMMC_STAR_TXFIFOHE = 0x4000
	// Position of RXFIFOHF field.
	SDMMC_STAR_RXFIFOHF_Pos = 0xf
	// Bit mask of RXFIFOHF field.
	SDMMC_STAR_RXFIFOHF_Msk = 0x8000
	// Bit RXFIFOHF.
	SDMMC_STAR_RXFIFOHF = 0x8000
	// Position of TXFIFOF field.
	SDMMC_STAR_TXFIFOF_Pos = 0x10
	// Bit mask of TXFIFOF field.
	SDMMC_STAR_TXFIFOF_Msk = 0x10000
	// Bit TXFIFOF.
	SDMMC_STAR_TXFIFOF = 0x10000
	// Position of RXFIFOF field.
	SDMMC_STAR_RXFIFOF_Pos = 0x11
	// Bit mask of RXFIFOF field.
	SDMMC_STAR_RXFIFOF_Msk = 0x20000
	// Bit RXFIFOF.
	SDMMC_STAR_RXFIFOF = 0x20000
	// Position of TXFIFOE field.
	SDMMC_STAR_TXFIFOE_Pos = 0x12
	// Bit mask of TXFIFOE field.
	SDMMC_STAR_TXFIFOE_Msk = 0x40000
	// Bit TXFIFOE.
	SDMMC_STAR_TXFIFOE = 0x40000
	// Position of RXFIFOE field.
	SDMMC_STAR_RXFIFOE_Pos = 0x13
	// Bit mask of RXFIFOE field.
	SDMMC_STAR_RXFIFOE_Msk = 0x80000
	// Bit RXFIFOE.
	SDMMC_STAR_RXFIFOE = 0x80000
	// Position of BUSYD0 field.
	SDMMC_STAR_BUSYD0_Pos = 0x14
	// Bit mask of BUSYD0 field.
	SDMMC_STAR_BUSYD0_Msk = 0x100000
	// Bit BUSYD0.
	SDMMC_STAR_BUSYD0 = 0x100000
	// Position of BUSYD0END field.
	SDMMC_STAR_BUSYD0END_Pos = 0x15
	// Bit mask of BUSYD0END field.
	SDMMC_STAR_BUSYD0END_Msk = 0x200000
	// Bit BUSYD0END.
	SDMMC_STAR_BUSYD0END = 0x200000
	// Position of SDIOIT field.
	SDMMC_STAR_SDIOIT_Pos = 0x16
	// Bit mask of SDIOIT field.
	SDMMC_STAR_SDIOIT_Msk = 0x400000
	// Bit SDIOIT.
	SDMMC_STAR_SDIOIT = 0x400000
	// Position of ACKFAIL field.
	SDMMC_STAR_ACKFAIL_Pos = 0x17
	// Bit mask of ACKFAIL field.
	SDMMC_STAR_ACKFAIL_Msk = 0x800000
	// Bit ACKFAIL.
	SDMMC_STAR_ACKFAIL = 0x800000
	// Position of ACKTIMEOUT field.
	SDMMC_STAR_ACKTIMEOUT_Pos = 0x18
	// Bit mask of ACKTIMEOUT field.
	SDMMC_STAR_ACKTIMEOUT_Msk = 0x1000000
	// Bit ACKTIMEOUT.
	SDMMC_STAR_ACKTIMEOUT = 0x1000000
	// Position of VSWEND field.
	SDMMC_STAR_VSWEND_Pos = 0x19
	// Bit mask of VSWEND field.
	SDMMC_STAR_VSWEND_Msk = 0x2000000
	// Bit VSWEND.
	SDMMC_STAR_VSWEND = 0x2000000
	// Position of CKSTOP field.
	SDMMC_STAR_CKSTOP_Pos = 0x1a
	// Bit mask of CKSTOP field.
	SDMMC_STAR_CKSTOP_Msk = 0x4000000
	// Bit CKSTOP.
	SDMMC_STAR_CKSTOP = 0x4000000
	// Position of IDMATE field.
	SDMMC_STAR_IDMATE_Pos = 0x1b
	// Bit mask of IDMATE field.
	SDMMC_STAR_IDMATE_Msk = 0x8000000
	// Bit IDMATE.
	SDMMC_STAR_IDMATE = 0x8000000
	// Position of IDMABTC field.
	SDMMC_STAR_IDMABTC_Pos = 0x1c
	// Bit mask of IDMABTC field.
	SDMMC_STAR_IDMABTC_Msk = 0x10000000
	// Bit IDMABTC.
	SDMMC_STAR_IDMABTC = 0x10000000

	// ICR: The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
	// Position of CCRCFAILC field.
	SDMMC_ICR_CCRCFAILC_Pos = 0x0
	// Bit mask of CCRCFAILC field.
	SDMMC_ICR_CCRCFAILC_Msk = 0x1
	// Bit CCRCFAILC.
	SDMMC_ICR_CCRCFAILC = 0x1
	// Position of DCRCFAILC field.
	SDMMC_ICR_DCRCFAILC_Pos = 0x1
	// Bit mask of DCRCFAILC field.
	SDMMC_ICR_DCRCFAILC_Msk = 0x2
	// Bit DCRCFAILC.
	SDMMC_ICR_DCRCFAILC = 0x2
	// Position of CTIMEOUTC field.
	SDMMC_ICR_CTIMEOUTC_Pos = 0x2
	// Bit mask of CTIMEOUTC field.
	SDMMC_ICR_CTIMEOUTC_Msk = 0x4
	// Bit CTIMEOUTC.
	SDMMC_ICR_CTIMEOUTC = 0x4
	// Position of DTIMEOUTC field.
	SDMMC_ICR_DTIMEOUTC_Pos = 0x3
	// Bit mask of DTIMEOUTC field.
	SDMMC_ICR_DTIMEOUTC_Msk = 0x8
	// Bit DTIMEOUTC.
	SDMMC_ICR_DTIMEOUTC = 0x8
	// Position of TXUNDERRC field.
	SDMMC_ICR_TXUNDERRC_Pos = 0x4
	// Bit mask of TXUNDERRC field.
	SDMMC_ICR_TXUNDERRC_Msk = 0x10
	// Bit TXUNDERRC.
	SDMMC_ICR_TXUNDERRC = 0x10
	// Position of RXOVERRC field.
	SDMMC_ICR_RXOVERRC_Pos = 0x5
	// Bit mask of RXOVERRC field.
	SDMMC_ICR_RXOVERRC_Msk = 0x20
	// Bit RXOVERRC.
	SDMMC_ICR_RXOVERRC = 0x20
	// Position of CMDRENDC field.
	SDMMC_ICR_CMDRENDC_Pos = 0x6
	// Bit mask of CMDRENDC field.
	SDMMC_ICR_CMDRENDC_Msk = 0x40
	// Bit CMDRENDC.
	SDMMC_ICR_CMDRENDC = 0x40
	// Position of CMDSENTC field.
	SDMMC_ICR_CMDSENTC_Pos = 0x7
	// Bit mask of CMDSENTC field.
	SDMMC_ICR_CMDSENTC_Msk = 0x80
	// Bit CMDSENTC.
	SDMMC_ICR_CMDSENTC = 0x80
	// Position of DATAENDC field.
	SDMMC_ICR_DATAENDC_Pos = 0x8
	// Bit mask of DATAENDC field.
	SDMMC_ICR_DATAENDC_Msk = 0x100
	// Bit DATAENDC.
	SDMMC_ICR_DATAENDC = 0x100
	// Position of DHOLDC field.
	SDMMC_ICR_DHOLDC_Pos = 0x9
	// Bit mask of DHOLDC field.
	SDMMC_ICR_DHOLDC_Msk = 0x200
	// Bit DHOLDC.
	SDMMC_ICR_DHOLDC = 0x200
	// Position of DBCKENDC field.
	SDMMC_ICR_DBCKENDC_Pos = 0xa
	// Bit mask of DBCKENDC field.
	SDMMC_ICR_DBCKENDC_Msk = 0x400
	// Bit DBCKENDC.
	SDMMC_ICR_DBCKENDC = 0x400
	// Position of DABORTC field.
	SDMMC_ICR_DABORTC_Pos = 0xb
	// Bit mask of DABORTC field.
	SDMMC_ICR_DABORTC_Msk = 0x800
	// Bit DABORTC.
	SDMMC_ICR_DABORTC = 0x800
	// Position of BUSYD0ENDC field.
	SDMMC_ICR_BUSYD0ENDC_Pos = 0x15
	// Bit mask of BUSYD0ENDC field.
	SDMMC_ICR_BUSYD0ENDC_Msk = 0x200000
	// Bit BUSYD0ENDC.
	SDMMC_ICR_BUSYD0ENDC = 0x200000
	// Position of SDIOITC field.
	SDMMC_ICR_SDIOITC_Pos = 0x16
	// Bit mask of SDIOITC field.
	SDMMC_ICR_SDIOITC_Msk = 0x400000
	// Bit SDIOITC.
	SDMMC_ICR_SDIOITC = 0x400000
	// Position of ACKFAILC field.
	SDMMC_ICR_ACKFAILC_Pos = 0x17
	// Bit mask of ACKFAILC field.
	SDMMC_ICR_ACKFAILC_Msk = 0x800000
	// Bit ACKFAILC.
	SDMMC_ICR_ACKFAILC = 0x800000
	// Position of ACKTIMEOUTC field.
	SDMMC_ICR_ACKTIMEOUTC_Pos = 0x18
	// Bit mask of ACKTIMEOUTC field.
	SDMMC_ICR_ACKTIMEOUTC_Msk = 0x1000000
	// Bit ACKTIMEOUTC.
	SDMMC_ICR_ACKTIMEOUTC = 0x1000000
	// Position of VSWENDC field.
	SDMMC_ICR_VSWENDC_Pos = 0x19
	// Bit mask of VSWENDC field.
	SDMMC_ICR_VSWENDC_Msk = 0x2000000
	// Bit VSWENDC.
	SDMMC_ICR_VSWENDC = 0x2000000
	// Position of CKSTOPC field.
	SDMMC_ICR_CKSTOPC_Pos = 0x1a
	// Bit mask of CKSTOPC field.
	SDMMC_ICR_CKSTOPC_Msk = 0x4000000
	// Bit CKSTOPC.
	SDMMC_ICR_CKSTOPC = 0x4000000
	// Position of IDMATEC field.
	SDMMC_ICR_IDMATEC_Pos = 0x1b
	// Bit mask of IDMATEC field.
	SDMMC_ICR_IDMATEC_Msk = 0x8000000
	// Bit IDMATEC.
	SDMMC_ICR_IDMATEC = 0x8000000
	// Position of IDMABTCC field.
	SDMMC_ICR_IDMABTCC_Pos = 0x1c
	// Bit mask of IDMABTCC field.
	SDMMC_ICR_IDMABTCC_Msk = 0x10000000
	// Bit IDMABTCC.
	SDMMC_ICR_IDMABTCC = 0x10000000

	// MASKR: The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
	// Position of CCRCFAILIE field.
	SDMMC_MASKR_CCRCFAILIE_Pos = 0x0
	// Bit mask of CCRCFAILIE field.
	SDMMC_MASKR_CCRCFAILIE_Msk = 0x1
	// Bit CCRCFAILIE.
	SDMMC_MASKR_CCRCFAILIE = 0x1
	// Position of DCRCFAILIE field.
	SDMMC_MASKR_DCRCFAILIE_Pos = 0x1
	// Bit mask of DCRCFAILIE field.
	SDMMC_MASKR_DCRCFAILIE_Msk = 0x2
	// Bit DCRCFAILIE.
	SDMMC_MASKR_DCRCFAILIE = 0x2
	// Position of CTIMEOUTIE field.
	SDMMC_MASKR_CTIMEOUTIE_Pos = 0x2
	// Bit mask of CTIMEOUTIE field.
	SDMMC_MASKR_CTIMEOUTIE_Msk = 0x4
	// Bit CTIMEOUTIE.
	SDMMC_MASKR_CTIMEOUTIE = 0x4
	// Position of DTIMEOUTIE field.
	SDMMC_MASKR_DTIMEOUTIE_Pos = 0x3
	// Bit mask of DTIMEOUTIE field.
	SDMMC_MASKR_DTIMEOUTIE_Msk = 0x8
	// Bit DTIMEOUTIE.
	SDMMC_MASKR_DTIMEOUTIE = 0x8
	// Position of TXUNDERRIE field.
	SDMMC_MASKR_TXUNDERRIE_Pos = 0x4
	// Bit mask of TXUNDERRIE field.
	SDMMC_MASKR_TXUNDERRIE_Msk = 0x10
	// Bit TXUNDERRIE.
	SDMMC_MASKR_TXUNDERRIE = 0x10
	// Position of RXOVERRIE field.
	SDMMC_MASKR_RXOVERRIE_Pos = 0x5
	// Bit mask of RXOVERRIE field.
	SDMMC_MASKR_RXOVERRIE_Msk = 0x20
	// Bit RXOVERRIE.
	SDMMC_MASKR_RXOVERRIE = 0x20
	// Position of CMDRENDIE field.
	SDMMC_MASKR_CMDRENDIE_Pos = 0x6
	// Bit mask of CMDRENDIE field.
	SDMMC_MASKR_CMDRENDIE_Msk = 0x40
	// Bit CMDRENDIE.
	SDMMC_MASKR_CMDRENDIE = 0x40
	// Position of CMDSENTIE field.
	SDMMC_MASKR_CMDSENTIE_Pos = 0x7
	// Bit mask of CMDSENTIE field.
	SDMMC_MASKR_CMDSENTIE_Msk = 0x80
	// Bit CMDSENTIE.
	SDMMC_MASKR_CMDSENTIE = 0x80
	// Position of DATAENDIE field.
	SDMMC_MASKR_DATAENDIE_Pos = 0x8
	// Bit mask of DATAENDIE field.
	SDMMC_MASKR_DATAENDIE_Msk = 0x100
	// Bit DATAENDIE.
	SDMMC_MASKR_DATAENDIE = 0x100
	// Position of DHOLDIE field.
	SDMMC_MASKR_DHOLDIE_Pos = 0x9
	// Bit mask of DHOLDIE field.
	SDMMC_MASKR_DHOLDIE_Msk = 0x200
	// Bit DHOLDIE.
	SDMMC_MASKR_DHOLDIE = 0x200
	// Position of DBCKENDIE field.
	SDMMC_MASKR_DBCKENDIE_Pos = 0xa
	// Bit mask of DBCKENDIE field.
	SDMMC_MASKR_DBCKENDIE_Msk = 0x400
	// Bit DBCKENDIE.
	SDMMC_MASKR_DBCKENDIE = 0x400
	// Position of DABORTIE field.
	SDMMC_MASKR_DABORTIE_Pos = 0xb
	// Bit mask of DABORTIE field.
	SDMMC_MASKR_DABORTIE_Msk = 0x800
	// Bit DABORTIE.
	SDMMC_MASKR_DABORTIE = 0x800
	// Position of TXFIFOHEIE field.
	SDMMC_MASKR_TXFIFOHEIE_Pos = 0xe
	// Bit mask of TXFIFOHEIE field.
	SDMMC_MASKR_TXFIFOHEIE_Msk = 0x4000
	// Bit TXFIFOHEIE.
	SDMMC_MASKR_TXFIFOHEIE = 0x4000
	// Position of RXFIFOHFIE field.
	SDMMC_MASKR_RXFIFOHFIE_Pos = 0xf
	// Bit mask of RXFIFOHFIE field.
	SDMMC_MASKR_RXFIFOHFIE_Msk = 0x8000
	// Bit RXFIFOHFIE.
	SDMMC_MASKR_RXFIFOHFIE = 0x8000
	// Position of RXFIFOFIE field.
	SDMMC_MASKR_RXFIFOFIE_Pos = 0x11
	// Bit mask of RXFIFOFIE field.
	SDMMC_MASKR_RXFIFOFIE_Msk = 0x20000
	// Bit RXFIFOFIE.
	SDMMC_MASKR_RXFIFOFIE = 0x20000
	// Position of TXFIFOEIE field.
	SDMMC_MASKR_TXFIFOEIE_Pos = 0x12
	// Bit mask of TXFIFOEIE field.
	SDMMC_MASKR_TXFIFOEIE_Msk = 0x40000
	// Bit TXFIFOEIE.
	SDMMC_MASKR_TXFIFOEIE = 0x40000
	// Position of BUSYD0ENDIE field.
	SDMMC_MASKR_BUSYD0ENDIE_Pos = 0x15
	// Bit mask of BUSYD0ENDIE field.
	SDMMC_MASKR_BUSYD0ENDIE_Msk = 0x200000
	// Bit BUSYD0ENDIE.
	SDMMC_MASKR_BUSYD0ENDIE = 0x200000
	// Position of SDIOITIE field.
	SDMMC_MASKR_SDIOITIE_Pos = 0x16
	// Bit mask of SDIOITIE field.
	SDMMC_MASKR_SDIOITIE_Msk = 0x400000
	// Bit SDIOITIE.
	SDMMC_MASKR_SDIOITIE = 0x400000
	// Position of ACKFAILIE field.
	SDMMC_MASKR_ACKFAILIE_Pos = 0x17
	// Bit mask of ACKFAILIE field.
	SDMMC_MASKR_ACKFAILIE_Msk = 0x800000
	// Bit ACKFAILIE.
	SDMMC_MASKR_ACKFAILIE = 0x800000
	// Position of ACKTIMEOUTIE field.
	SDMMC_MASKR_ACKTIMEOUTIE_Pos = 0x18
	// Bit mask of ACKTIMEOUTIE field.
	SDMMC_MASKR_ACKTIMEOUTIE_Msk = 0x1000000
	// Bit ACKTIMEOUTIE.
	SDMMC_MASKR_ACKTIMEOUTIE = 0x1000000
	// Position of VSWENDIE field.
	SDMMC_MASKR_VSWENDIE_Pos = 0x19
	// Bit mask of VSWENDIE field.
	SDMMC_MASKR_VSWENDIE_Msk = 0x2000000
	// Bit VSWENDIE.
	SDMMC_MASKR_VSWENDIE = 0x2000000
	// Position of CKSTOPIE field.
	SDMMC_MASKR_CKSTOPIE_Pos = 0x1a
	// Bit mask of CKSTOPIE field.
	SDMMC_MASKR_CKSTOPIE_Msk = 0x4000000
	// Bit CKSTOPIE.
	SDMMC_MASKR_CKSTOPIE = 0x4000000
	// Position of IDMABTCIE field.
	SDMMC_MASKR_IDMABTCIE_Pos = 0x1c
	// Bit mask of IDMABTCIE field.
	SDMMC_MASKR_IDMABTCIE_Msk = 0x10000000
	// Bit IDMABTCIE.
	SDMMC_MASKR_IDMABTCIE = 0x10000000

	// ACKTIMER: The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
	// Position of ACKTIME field.
	SDMMC_ACKTIMER_ACKTIME_Pos = 0x0
	// Bit mask of ACKTIME field.
	SDMMC_ACKTIMER_ACKTIME_Msk = 0x1ffffff

	// IDMACTRLR: The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
	// Position of IDMAEN field.
	SDMMC_IDMACTRLR_IDMAEN_Pos = 0x0
	// Bit mask of IDMAEN field.
	SDMMC_IDMACTRLR_IDMAEN_Msk = 0x1
	// Bit IDMAEN.
	SDMMC_IDMACTRLR_IDMAEN = 0x1
	// Position of IDMABMODE field.
	SDMMC_IDMACTRLR_IDMABMODE_Pos = 0x1
	// Bit mask of IDMABMODE field.
	SDMMC_IDMACTRLR_IDMABMODE_Msk = 0x2
	// Bit IDMABMODE.
	SDMMC_IDMACTRLR_IDMABMODE = 0x2
	// Position of IDMABACT field.
	SDMMC_IDMACTRLR_IDMABACT_Pos = 0x2
	// Bit mask of IDMABACT field.
	SDMMC_IDMACTRLR_IDMABACT_Msk = 0x4
	// Bit IDMABACT.
	SDMMC_IDMACTRLR_IDMABACT = 0x4

	// IDMABSIZER: The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
	// Position of IDMABNDT field.
	SDMMC_IDMABSIZER_IDMABNDT_Pos = 0x5
	// Bit mask of IDMABNDT field.
	SDMMC_IDMABSIZER_IDMABNDT_Msk = 0x1fe0

	// IDMABASE0R: The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
	// Position of IDMABASE0 field.
	SDMMC_IDMABASE0R_IDMABASE0_Pos = 0x0
	// Bit mask of IDMABASE0 field.
	SDMMC_IDMABASE0R_IDMABASE0_Msk = 0xffffffff

	// IDMABASE1R: The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
	// Position of IDMABASE1 field.
	SDMMC_IDMABASE1R_IDMABASE1_Pos = 0x0
	// Bit mask of IDMABASE1 field.
	SDMMC_IDMABASE1R_IDMABASE1_Msk = 0xffffffff

	// FIFOR: The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
	// Position of FIFODATA field.
	SDMMC_FIFOR_FIFODATA_Pos = 0x0
	// Bit mask of FIFODATA field.
	SDMMC_FIFOR_FIFODATA_Msk = 0xffffffff
)

// Constants for SPDIFRX: Receiver Interface
const (
	// CR: Control register
	// Position of SPDIFRXEN field.
	SPDIFRX_CR_SPDIFRXEN_Pos = 0x0
	// Bit mask of SPDIFRXEN field.
	SPDIFRX_CR_SPDIFRXEN_Msk = 0x3
	// Position of RXDMAEN field.
	SPDIFRX_CR_RXDMAEN_Pos = 0x2
	// Bit mask of RXDMAEN field.
	SPDIFRX_CR_RXDMAEN_Msk = 0x4
	// Bit RXDMAEN.
	SPDIFRX_CR_RXDMAEN = 0x4
	// Position of RXSTEO field.
	SPDIFRX_CR_RXSTEO_Pos = 0x3
	// Bit mask of RXSTEO field.
	SPDIFRX_CR_RXSTEO_Msk = 0x8
	// Bit RXSTEO.
	SPDIFRX_CR_RXSTEO = 0x8
	// Position of DRFMT field.
	SPDIFRX_CR_DRFMT_Pos = 0x4
	// Bit mask of DRFMT field.
	SPDIFRX_CR_DRFMT_Msk = 0x30
	// Position of PMSK field.
	SPDIFRX_CR_PMSK_Pos = 0x6
	// Bit mask of PMSK field.
	SPDIFRX_CR_PMSK_Msk = 0x40
	// Bit PMSK.
	SPDIFRX_CR_PMSK = 0x40
	// Position of VMSK field.
	SPDIFRX_CR_VMSK_Pos = 0x7
	// Bit mask of VMSK field.
	SPDIFRX_CR_VMSK_Msk = 0x80
	// Bit VMSK.
	SPDIFRX_CR_VMSK = 0x80
	// Position of CUMSK field.
	SPDIFRX_CR_CUMSK_Pos = 0x8
	// Bit mask of CUMSK field.
	SPDIFRX_CR_CUMSK_Msk = 0x100
	// Bit CUMSK.
	SPDIFRX_CR_CUMSK = 0x100
	// Position of PTMSK field.
	SPDIFRX_CR_PTMSK_Pos = 0x9
	// Bit mask of PTMSK field.
	SPDIFRX_CR_PTMSK_Msk = 0x200
	// Bit PTMSK.
	SPDIFRX_CR_PTMSK = 0x200
	// Position of CBDMAEN field.
	SPDIFRX_CR_CBDMAEN_Pos = 0xa
	// Bit mask of CBDMAEN field.
	SPDIFRX_CR_CBDMAEN_Msk = 0x400
	// Bit CBDMAEN.
	SPDIFRX_CR_CBDMAEN = 0x400
	// Position of CHSEL field.
	SPDIFRX_CR_CHSEL_Pos = 0xb
	// Bit mask of CHSEL field.
	SPDIFRX_CR_CHSEL_Msk = 0x800
	// Bit CHSEL.
	SPDIFRX_CR_CHSEL = 0x800
	// Position of NBTR field.
	SPDIFRX_CR_NBTR_Pos = 0xc
	// Bit mask of NBTR field.
	SPDIFRX_CR_NBTR_Msk = 0x3000
	// Position of WFA field.
	SPDIFRX_CR_WFA_Pos = 0xe
	// Bit mask of WFA field.
	SPDIFRX_CR_WFA_Msk = 0x4000
	// Bit WFA.
	SPDIFRX_CR_WFA = 0x4000
	// Position of INSEL field.
	SPDIFRX_CR_INSEL_Pos = 0x10
	// Bit mask of INSEL field.
	SPDIFRX_CR_INSEL_Msk = 0x70000
	// Position of CKSEN field.
	SPDIFRX_CR_CKSEN_Pos = 0x14
	// Bit mask of CKSEN field.
	SPDIFRX_CR_CKSEN_Msk = 0x100000
	// Bit CKSEN.
	SPDIFRX_CR_CKSEN = 0x100000
	// Position of CKSBKPEN field.
	SPDIFRX_CR_CKSBKPEN_Pos = 0x15
	// Bit mask of CKSBKPEN field.
	SPDIFRX_CR_CKSBKPEN_Msk = 0x200000
	// Bit CKSBKPEN.
	SPDIFRX_CR_CKSBKPEN = 0x200000

	// IMR: Interrupt mask register
	// Position of RXNEIE field.
	SPDIFRX_IMR_RXNEIE_Pos = 0x0
	// Bit mask of RXNEIE field.
	SPDIFRX_IMR_RXNEIE_Msk = 0x1
	// Bit RXNEIE.
	SPDIFRX_IMR_RXNEIE = 0x1
	// Position of CSRNEIE field.
	SPDIFRX_IMR_CSRNEIE_Pos = 0x1
	// Bit mask of CSRNEIE field.
	SPDIFRX_IMR_CSRNEIE_Msk = 0x2
	// Bit CSRNEIE.
	SPDIFRX_IMR_CSRNEIE = 0x2
	// Position of PERRIE field.
	SPDIFRX_IMR_PERRIE_Pos = 0x2
	// Bit mask of PERRIE field.
	SPDIFRX_IMR_PERRIE_Msk = 0x4
	// Bit PERRIE.
	SPDIFRX_IMR_PERRIE = 0x4
	// Position of OVRIE field.
	SPDIFRX_IMR_OVRIE_Pos = 0x3
	// Bit mask of OVRIE field.
	SPDIFRX_IMR_OVRIE_Msk = 0x8
	// Bit OVRIE.
	SPDIFRX_IMR_OVRIE = 0x8
	// Position of SBLKIE field.
	SPDIFRX_IMR_SBLKIE_Pos = 0x4
	// Bit mask of SBLKIE field.
	SPDIFRX_IMR_SBLKIE_Msk = 0x10
	// Bit SBLKIE.
	SPDIFRX_IMR_SBLKIE = 0x10
	// Position of SYNCDIE field.
	SPDIFRX_IMR_SYNCDIE_Pos = 0x5
	// Bit mask of SYNCDIE field.
	SPDIFRX_IMR_SYNCDIE_Msk = 0x20
	// Bit SYNCDIE.
	SPDIFRX_IMR_SYNCDIE = 0x20
	// Position of IFEIE field.
	SPDIFRX_IMR_IFEIE_Pos = 0x6
	// Bit mask of IFEIE field.
	SPDIFRX_IMR_IFEIE_Msk = 0x40
	// Bit IFEIE.
	SPDIFRX_IMR_IFEIE = 0x40

	// SR: Status register
	// Position of RXNE field.
	SPDIFRX_SR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPDIFRX_SR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPDIFRX_SR_RXNE = 0x1
	// Position of CSRNE field.
	SPDIFRX_SR_CSRNE_Pos = 0x1
	// Bit mask of CSRNE field.
	SPDIFRX_SR_CSRNE_Msk = 0x2
	// Bit CSRNE.
	SPDIFRX_SR_CSRNE = 0x2
	// Position of PERR field.
	SPDIFRX_SR_PERR_Pos = 0x2
	// Bit mask of PERR field.
	SPDIFRX_SR_PERR_Msk = 0x4
	// Bit PERR.
	SPDIFRX_SR_PERR = 0x4
	// Position of OVR field.
	SPDIFRX_SR_OVR_Pos = 0x3
	// Bit mask of OVR field.
	SPDIFRX_SR_OVR_Msk = 0x8
	// Bit OVR.
	SPDIFRX_SR_OVR = 0x8
	// Position of SBD field.
	SPDIFRX_SR_SBD_Pos = 0x4
	// Bit mask of SBD field.
	SPDIFRX_SR_SBD_Msk = 0x10
	// Bit SBD.
	SPDIFRX_SR_SBD = 0x10
	// Position of SYNCD field.
	SPDIFRX_SR_SYNCD_Pos = 0x5
	// Bit mask of SYNCD field.
	SPDIFRX_SR_SYNCD_Msk = 0x20
	// Bit SYNCD.
	SPDIFRX_SR_SYNCD = 0x20
	// Position of FERR field.
	SPDIFRX_SR_FERR_Pos = 0x6
	// Bit mask of FERR field.
	SPDIFRX_SR_FERR_Msk = 0x40
	// Bit FERR.
	SPDIFRX_SR_FERR = 0x40
	// Position of SERR field.
	SPDIFRX_SR_SERR_Pos = 0x7
	// Bit mask of SERR field.
	SPDIFRX_SR_SERR_Msk = 0x80
	// Bit SERR.
	SPDIFRX_SR_SERR = 0x80
	// Position of TERR field.
	SPDIFRX_SR_TERR_Pos = 0x8
	// Bit mask of TERR field.
	SPDIFRX_SR_TERR_Msk = 0x100
	// Bit TERR.
	SPDIFRX_SR_TERR = 0x100
	// Position of WIDTH5 field.
	SPDIFRX_SR_WIDTH5_Pos = 0x10
	// Bit mask of WIDTH5 field.
	SPDIFRX_SR_WIDTH5_Msk = 0x7fff0000

	// IFCR: Interrupt Flag Clear register
	// Position of PERRCF field.
	SPDIFRX_IFCR_PERRCF_Pos = 0x2
	// Bit mask of PERRCF field.
	SPDIFRX_IFCR_PERRCF_Msk = 0x4
	// Bit PERRCF.
	SPDIFRX_IFCR_PERRCF = 0x4
	// Position of OVRCF field.
	SPDIFRX_IFCR_OVRCF_Pos = 0x3
	// Bit mask of OVRCF field.
	SPDIFRX_IFCR_OVRCF_Msk = 0x8
	// Bit OVRCF.
	SPDIFRX_IFCR_OVRCF = 0x8
	// Position of SBDCF field.
	SPDIFRX_IFCR_SBDCF_Pos = 0x4
	// Bit mask of SBDCF field.
	SPDIFRX_IFCR_SBDCF_Msk = 0x10
	// Bit SBDCF.
	SPDIFRX_IFCR_SBDCF = 0x10
	// Position of SYNCDCF field.
	SPDIFRX_IFCR_SYNCDCF_Pos = 0x5
	// Bit mask of SYNCDCF field.
	SPDIFRX_IFCR_SYNCDCF_Msk = 0x20
	// Bit SYNCDCF.
	SPDIFRX_IFCR_SYNCDCF = 0x20

	// FMT0_DR: Data input register
	// Position of DR field.
	SPDIFRX_FMT0_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	SPDIFRX_FMT0_DR_DR_Msk = 0xffffff
	// Position of PE field.
	SPDIFRX_FMT0_DR_PE_Pos = 0x18
	// Bit mask of PE field.
	SPDIFRX_FMT0_DR_PE_Msk = 0x1000000
	// Bit PE.
	SPDIFRX_FMT0_DR_PE = 0x1000000
	// Position of V field.
	SPDIFRX_FMT0_DR_V_Pos = 0x19
	// Bit mask of V field.
	SPDIFRX_FMT0_DR_V_Msk = 0x2000000
	// Bit V.
	SPDIFRX_FMT0_DR_V = 0x2000000
	// Position of U field.
	SPDIFRX_FMT0_DR_U_Pos = 0x1a
	// Bit mask of U field.
	SPDIFRX_FMT0_DR_U_Msk = 0x4000000
	// Bit U.
	SPDIFRX_FMT0_DR_U = 0x4000000
	// Position of C field.
	SPDIFRX_FMT0_DR_C_Pos = 0x1b
	// Bit mask of C field.
	SPDIFRX_FMT0_DR_C_Msk = 0x8000000
	// Bit C.
	SPDIFRX_FMT0_DR_C = 0x8000000
	// Position of PT field.
	SPDIFRX_FMT0_DR_PT_Pos = 0x1c
	// Bit mask of PT field.
	SPDIFRX_FMT0_DR_PT_Msk = 0x30000000

	// CSR: Channel Status register
	// Position of USR field.
	SPDIFRX_CSR_USR_Pos = 0x0
	// Bit mask of USR field.
	SPDIFRX_CSR_USR_Msk = 0xffff
	// Position of CS field.
	SPDIFRX_CSR_CS_Pos = 0x10
	// Bit mask of CS field.
	SPDIFRX_CSR_CS_Msk = 0xff0000
	// Position of SOB field.
	SPDIFRX_CSR_SOB_Pos = 0x18
	// Bit mask of SOB field.
	SPDIFRX_CSR_SOB_Msk = 0x1000000
	// Bit SOB.
	SPDIFRX_CSR_SOB = 0x1000000

	// DIR: Debug Information register
	// Position of THI field.
	SPDIFRX_DIR_THI_Pos = 0x0
	// Bit mask of THI field.
	SPDIFRX_DIR_THI_Msk = 0x1fff
	// Position of TLO field.
	SPDIFRX_DIR_TLO_Pos = 0x10
	// Bit mask of TLO field.
	SPDIFRX_DIR_TLO_Msk = 0x1fff0000
)

// Constants for SPI1: Serial peripheral interface
const (
	// CR1: control register 1
	// Position of IOLOCK field.
	SPI_CR1_IOLOCK_Pos = 0x10
	// Bit mask of IOLOCK field.
	SPI_CR1_IOLOCK_Msk = 0x10000
	// Bit IOLOCK.
	SPI_CR1_IOLOCK = 0x10000
	// IO configuration unlocked
	SPI_CR1_IOLOCK_Unlocked = 0x0
	// IO configuration locked
	SPI_CR1_IOLOCK_Locked = 0x1
	// Position of TCRCINI field.
	SPI_CR1_TCRCINI_Pos = 0xf
	// Bit mask of TCRCINI field.
	SPI_CR1_TCRCINI_Msk = 0x8000
	// Bit TCRCINI.
	SPI_CR1_TCRCINI = 0x8000
	// All zeros TX CRC initialization pattern
	SPI_CR1_TCRCINI_AllZeros = 0x0
	// All ones TX CRC initialization pattern
	SPI_CR1_TCRCINI_AllOnes = 0x1
	// Position of RCRCINI field.
	SPI_CR1_RCRCINI_Pos = 0xe
	// Bit mask of RCRCINI field.
	SPI_CR1_RCRCINI_Msk = 0x4000
	// Bit RCRCINI.
	SPI_CR1_RCRCINI = 0x4000
	// All zeros RX CRC initialization pattern
	SPI_CR1_RCRCINI_AllZeros = 0x0
	// All ones RX CRC initialization pattern
	SPI_CR1_RCRCINI_AllOnes = 0x1
	// Position of CRC33_17 field.
	SPI_CR1_CRC33_17_Pos = 0xd
	// Bit mask of CRC33_17 field.
	SPI_CR1_CRC33_17_Msk = 0x2000
	// Bit CRC33_17.
	SPI_CR1_CRC33_17 = 0x2000
	// Full size (33/17 bit) CRC polynomial is not used
	SPI_CR1_CRC33_17_Disabled = 0x0
	// Full size (33/17 bit) CRC polynomial is used
	SPI_CR1_CRC33_17_Enabled = 0x1
	// Position of SSI field.
	SPI_CR1_SSI_Pos = 0xc
	// Bit mask of SSI field.
	SPI_CR1_SSI_Msk = 0x1000
	// Bit SSI.
	SPI_CR1_SSI = 0x1000
	// 0 is forced onto the SS signal and the I/O value of the SS pin is ignored
	SPI_CR1_SSI_SlaveSelected = 0x0
	// 1 is forced onto the SS signal and the I/O value of the SS pin is ignored
	SPI_CR1_SSI_SlaveNotSelected = 0x1
	// Position of HDDIR field.
	SPI_CR1_HDDIR_Pos = 0xb
	// Bit mask of HDDIR field.
	SPI_CR1_HDDIR_Msk = 0x800
	// Bit HDDIR.
	SPI_CR1_HDDIR = 0x800
	// Receiver in half duplex mode
	SPI_CR1_HDDIR_Receiver = 0x0
	// Transmitter in half duplex mode
	SPI_CR1_HDDIR_Transmitter = 0x1
	// Position of CSUSP field.
	SPI_CR1_CSUSP_Pos = 0xa
	// Bit mask of CSUSP field.
	SPI_CR1_CSUSP_Msk = 0x400
	// Bit CSUSP.
	SPI_CR1_CSUSP = 0x400
	// Do not request master suspend
	SPI_CR1_CSUSP_NotRequested = 0x0
	// Request master suspend
	SPI_CR1_CSUSP_Requested = 0x1
	// Position of CSTART field.
	SPI_CR1_CSTART_Pos = 0x9
	// Bit mask of CSTART field.
	SPI_CR1_CSTART_Msk = 0x200
	// Bit CSTART.
	SPI_CR1_CSTART = 0x200
	// Do not start master transfer
	SPI_CR1_CSTART_NotStarted = 0x0
	// Start master transfer
	SPI_CR1_CSTART_Started = 0x1
	// Position of MASRX field.
	SPI_CR1_MASRX_Pos = 0x8
	// Bit mask of MASRX field.
	SPI_CR1_MASRX_Msk = 0x100
	// Bit MASRX.
	SPI_CR1_MASRX = 0x100
	// Automatic suspend in master receive-only mode disabled
	SPI_CR1_MASRX_Disabled = 0x0
	// Automatic suspend in master receive-only mode enabled
	SPI_CR1_MASRX_Enabled = 0x1
	// Position of SPE field.
	SPI_CR1_SPE_Pos = 0x0
	// Bit mask of SPE field.
	SPI_CR1_SPE_Msk = 0x1
	// Bit SPE.
	SPI_CR1_SPE = 0x1
	// Peripheral disabled
	SPI_CR1_SPE_Disabled = 0x0
	// Peripheral enabled
	SPI_CR1_SPE_Enabled = 0x1

	// CR2: control register 2
	// Position of TSER field.
	SPI_CR2_TSER_Pos = 0x10
	// Bit mask of TSER field.
	SPI_CR2_TSER_Msk = 0xffff0000
	// Position of TSIZE field.
	SPI_CR2_TSIZE_Pos = 0x0
	// Bit mask of TSIZE field.
	SPI_CR2_TSIZE_Msk = 0xffff

	// CFG1: configuration register 1
	// Position of MBR field.
	SPI_CFG1_MBR_Pos = 0x1c
	// Bit mask of MBR field.
	SPI_CFG1_MBR_Msk = 0x70000000
	// f_spi_ker_ck / 2
	SPI_CFG1_MBR_Div2 = 0x0
	// f_spi_ker_ck / 4
	SPI_CFG1_MBR_Div4 = 0x1
	// f_spi_ker_ck / 8
	SPI_CFG1_MBR_Div8 = 0x2
	// f_spi_ker_ck / 16
	SPI_CFG1_MBR_Div16 = 0x3
	// f_spi_ker_ck / 32
	SPI_CFG1_MBR_Div32 = 0x4
	// f_spi_ker_ck / 64
	SPI_CFG1_MBR_Div64 = 0x5
	// f_spi_ker_ck / 128
	SPI_CFG1_MBR_Div128 = 0x6
	// f_spi_ker_ck / 256
	SPI_CFG1_MBR_Div256 = 0x7
	// Position of CRCEN field.
	SPI_CFG1_CRCEN_Pos = 0x16
	// Bit mask of CRCEN field.
	SPI_CFG1_CRCEN_Msk = 0x400000
	// Bit CRCEN.
	SPI_CFG1_CRCEN = 0x400000
	// CRC calculation disabled
	SPI_CFG1_CRCEN_Disabled = 0x0
	// CRC calculation enabled
	SPI_CFG1_CRCEN_Enabled = 0x1
	// Position of CRCSIZE field.
	SPI_CFG1_CRCSIZE_Pos = 0x10
	// Bit mask of CRCSIZE field.
	SPI_CFG1_CRCSIZE_Msk = 0x1f0000
	// Position of TXDMAEN field.
	SPI_CFG1_TXDMAEN_Pos = 0xf
	// Bit mask of TXDMAEN field.
	SPI_CFG1_TXDMAEN_Msk = 0x8000
	// Bit TXDMAEN.
	SPI_CFG1_TXDMAEN = 0x8000
	// Tx buffer DMA disabled
	SPI_CFG1_TXDMAEN_Disabled = 0x0
	// Tx buffer DMA enabled
	SPI_CFG1_TXDMAEN_Enabled = 0x1
	// Position of RXDMAEN field.
	SPI_CFG1_RXDMAEN_Pos = 0xe
	// Bit mask of RXDMAEN field.
	SPI_CFG1_RXDMAEN_Msk = 0x4000
	// Bit RXDMAEN.
	SPI_CFG1_RXDMAEN = 0x4000
	// Rx buffer DMA disabled
	SPI_CFG1_RXDMAEN_Disabled = 0x0
	// Rx buffer DMA enabled
	SPI_CFG1_RXDMAEN_Enabled = 0x1
	// Position of UDRDET field.
	SPI_CFG1_UDRDET_Pos = 0xb
	// Bit mask of UDRDET field.
	SPI_CFG1_UDRDET_Msk = 0x1800
	// Underrun is detected at begin of data frame
	SPI_CFG1_UDRDET_StartOfFrame = 0x0
	// Underrun is detected at end of last data frame
	SPI_CFG1_UDRDET_EndOfFrame = 0x1
	// Underrun is detected at begin of active SS signal
	SPI_CFG1_UDRDET_StartOfSlaveSelect = 0x2
	// Position of UDRCFG field.
	SPI_CFG1_UDRCFG_Pos = 0x9
	// Bit mask of UDRCFG field.
	SPI_CFG1_UDRCFG_Msk = 0x600
	// Slave sends a constant underrun pattern
	SPI_CFG1_UDRCFG_Constant = 0x0
	// Slave repeats last received data frame from master
	SPI_CFG1_UDRCFG_RepeatReceived = 0x1
	// Slave repeats last transmitted data frame
	SPI_CFG1_UDRCFG_RepeatTransmitted = 0x2
	// Position of FTHLV field.
	SPI_CFG1_FTHLV_Pos = 0x5
	// Bit mask of FTHLV field.
	SPI_CFG1_FTHLV_Msk = 0x1e0
	// 1 frame
	SPI_CFG1_FTHLV_OneFrame = 0x0
	// 2 frames
	SPI_CFG1_FTHLV_TwoFrames = 0x1
	// 3 frames
	SPI_CFG1_FTHLV_ThreeFrames = 0x2
	// 4 frames
	SPI_CFG1_FTHLV_FourFrames = 0x3
	// 5 frames
	SPI_CFG1_FTHLV_FiveFrames = 0x4
	// 6 frames
	SPI_CFG1_FTHLV_SixFrames = 0x5
	// 7 frames
	SPI_CFG1_FTHLV_SevenFrames = 0x6
	// 8 frames
	SPI_CFG1_FTHLV_EightFrames = 0x7
	// 9 frames
	SPI_CFG1_FTHLV_NineFrames = 0x8
	// 10 frames
	SPI_CFG1_FTHLV_TenFrames = 0x9
	// 11 frames
	SPI_CFG1_FTHLV_ElevenFrames = 0xa
	// 12 frames
	SPI_CFG1_FTHLV_TwelveFrames = 0xb
	// 13 frames
	SPI_CFG1_FTHLV_ThirteenFrames = 0xc
	// 14 frames
	SPI_CFG1_FTHLV_FourteenFrames = 0xd
	// 15 frames
	SPI_CFG1_FTHLV_FifteenFrames = 0xe
	// 16 frames
	SPI_CFG1_FTHLV_SixteenFrames = 0xf
	// Position of DSIZE field.
	SPI_CFG1_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	SPI_CFG1_DSIZE_Msk = 0x1f

	// CFG2: configuration register 2
	// Position of AFCNTR field.
	SPI_CFG2_AFCNTR_Pos = 0x1f
	// Bit mask of AFCNTR field.
	SPI_CFG2_AFCNTR_Msk = 0x80000000
	// Bit AFCNTR.
	SPI_CFG2_AFCNTR = 0x80000000
	// Peripheral takes no control of GPIOs while disabled
	SPI_CFG2_AFCNTR_NotControlled = 0x0
	// Peripheral controls GPIOs while disabled
	SPI_CFG2_AFCNTR_Controlled = 0x1
	// Position of SSOM field.
	SPI_CFG2_SSOM_Pos = 0x1e
	// Bit mask of SSOM field.
	SPI_CFG2_SSOM_Msk = 0x40000000
	// Bit SSOM.
	SPI_CFG2_SSOM = 0x40000000
	// SS is asserted until data transfer complete
	SPI_CFG2_SSOM_Asserted = 0x0
	// Data frames interleaved with SS not asserted during MIDI
	SPI_CFG2_SSOM_NotAsserted = 0x1
	// Position of SSOE field.
	SPI_CFG2_SSOE_Pos = 0x1d
	// Bit mask of SSOE field.
	SPI_CFG2_SSOE_Msk = 0x20000000
	// Bit SSOE.
	SPI_CFG2_SSOE = 0x20000000
	// SS output is disabled in master mode
	SPI_CFG2_SSOE_Disabled = 0x0
	// SS output is enabled in master mode
	SPI_CFG2_SSOE_Enabled = 0x1
	// Position of SSIOP field.
	SPI_CFG2_SSIOP_Pos = 0x1c
	// Bit mask of SSIOP field.
	SPI_CFG2_SSIOP_Msk = 0x10000000
	// Bit SSIOP.
	SPI_CFG2_SSIOP = 0x10000000
	// Low level is active for SS signal
	SPI_CFG2_SSIOP_ActiveLow = 0x0
	// High level is active for SS signal
	SPI_CFG2_SSIOP_ActiveHigh = 0x1
	// Position of SSM field.
	SPI_CFG2_SSM_Pos = 0x1a
	// Bit mask of SSM field.
	SPI_CFG2_SSM_Msk = 0x4000000
	// Bit SSM.
	SPI_CFG2_SSM = 0x4000000
	// Software slave management disabled
	SPI_CFG2_SSM_Disabled = 0x0
	// Software slave management enabled
	SPI_CFG2_SSM_Enabled = 0x1
	// Position of CPOL field.
	SPI_CFG2_CPOL_Pos = 0x19
	// Bit mask of CPOL field.
	SPI_CFG2_CPOL_Msk = 0x2000000
	// Bit CPOL.
	SPI_CFG2_CPOL = 0x2000000
	// CK to 0 when idle
	SPI_CFG2_CPOL_IdleLow = 0x0
	// CK to 1 when idle
	SPI_CFG2_CPOL_IdleHigh = 0x1
	// Position of CPHA field.
	SPI_CFG2_CPHA_Pos = 0x18
	// Bit mask of CPHA field.
	SPI_CFG2_CPHA_Msk = 0x1000000
	// Bit CPHA.
	SPI_CFG2_CPHA = 0x1000000
	// The first clock transition is the first data capture edge
	SPI_CFG2_CPHA_FirstEdge = 0x0
	// The second clock transition is the first data capture edge
	SPI_CFG2_CPHA_SecondEdge = 0x1
	// Position of LSBFRST field.
	SPI_CFG2_LSBFRST_Pos = 0x17
	// Bit mask of LSBFRST field.
	SPI_CFG2_LSBFRST_Msk = 0x800000
	// Bit LSBFRST.
	SPI_CFG2_LSBFRST = 0x800000
	// Data is transmitted/received with the MSB first
	SPI_CFG2_LSBFRST_MSBFirst = 0x0
	// Data is transmitted/received with the LSB first
	SPI_CFG2_LSBFRST_LSBFirst = 0x1
	// Position of MASTER field.
	SPI_CFG2_MASTER_Pos = 0x16
	// Bit mask of MASTER field.
	SPI_CFG2_MASTER_Msk = 0x400000
	// Bit MASTER.
	SPI_CFG2_MASTER = 0x400000
	// Slave configuration
	SPI_CFG2_MASTER_Slave = 0x0
	// Master configuration
	SPI_CFG2_MASTER_Master = 0x1
	// Position of SP field.
	SPI_CFG2_SP_Pos = 0x13
	// Bit mask of SP field.
	SPI_CFG2_SP_Msk = 0x380000
	// Motorola SPI protocol
	SPI_CFG2_SP_Motorola = 0x0
	// TI SPI protocol
	SPI_CFG2_SP_TI = 0x1
	// Position of COMM field.
	SPI_CFG2_COMM_Pos = 0x11
	// Bit mask of COMM field.
	SPI_CFG2_COMM_Msk = 0x60000
	// Full duplex
	SPI_CFG2_COMM_FullDuplex = 0x0
	// Simplex transmitter only
	SPI_CFG2_COMM_Transmitter = 0x1
	// Simplex receiver only
	SPI_CFG2_COMM_Receiver = 0x2
	// Half duplex
	SPI_CFG2_COMM_HalfDuplex = 0x3
	// Position of IOSWP field.
	SPI_CFG2_IOSWP_Pos = 0xf
	// Bit mask of IOSWP field.
	SPI_CFG2_IOSWP_Msk = 0x8000
	// Bit IOSWP.
	SPI_CFG2_IOSWP = 0x8000
	// MISO and MOSI not swapped
	SPI_CFG2_IOSWP_Disabled = 0x0
	// MISO and MOSI swapped
	SPI_CFG2_IOSWP_Enabled = 0x1
	// Position of MIDI field.
	SPI_CFG2_MIDI_Pos = 0x4
	// Bit mask of MIDI field.
	SPI_CFG2_MIDI_Msk = 0xf0
	// Position of MSSI field.
	SPI_CFG2_MSSI_Pos = 0x0
	// Bit mask of MSSI field.
	SPI_CFG2_MSSI_Msk = 0xf

	// IER: Interrupt Enable Register
	// Position of TSERFIE field.
	SPI_IER_TSERFIE_Pos = 0xa
	// Bit mask of TSERFIE field.
	SPI_IER_TSERFIE_Msk = 0x400
	// Bit TSERFIE.
	SPI_IER_TSERFIE = 0x400
	// TSER loaded interrupt masked
	SPI_IER_TSERFIE_Masked = 0x0
	// TSER loaded interrupt not masked
	SPI_IER_TSERFIE_NotMasked = 0x1
	// Position of MODFIE field.
	SPI_IER_MODFIE_Pos = 0x9
	// Bit mask of MODFIE field.
	SPI_IER_MODFIE_Msk = 0x200
	// Bit MODFIE.
	SPI_IER_MODFIE = 0x200
	// Mode fault interrupt masked
	SPI_IER_MODFIE_Masked = 0x0
	// Mode fault interrupt not masked
	SPI_IER_MODFIE_NotMasked = 0x1
	// Position of TIFREIE field.
	SPI_IER_TIFREIE_Pos = 0x8
	// Bit mask of TIFREIE field.
	SPI_IER_TIFREIE_Msk = 0x100
	// Bit TIFREIE.
	SPI_IER_TIFREIE = 0x100
	// TI frame format error interrupt masked
	SPI_IER_TIFREIE_Masked = 0x0
	// TI frame format error interrupt not masked
	SPI_IER_TIFREIE_NotMasked = 0x1
	// Position of CRCEIE field.
	SPI_IER_CRCEIE_Pos = 0x7
	// Bit mask of CRCEIE field.
	SPI_IER_CRCEIE_Msk = 0x80
	// Bit CRCEIE.
	SPI_IER_CRCEIE = 0x80
	// CRC error interrupt masked
	SPI_IER_CRCEIE_Masked = 0x0
	// CRC error interrupt not masked
	SPI_IER_CRCEIE_NotMasked = 0x1
	// Position of OVRIE field.
	SPI_IER_OVRIE_Pos = 0x6
	// Bit mask of OVRIE field.
	SPI_IER_OVRIE_Msk = 0x40
	// Bit OVRIE.
	SPI_IER_OVRIE = 0x40
	// Overrun interrupt masked
	SPI_IER_OVRIE_Masked = 0x0
	// Overrun interrupt not masked
	SPI_IER_OVRIE_NotMasked = 0x1
	// Position of UDRIE field.
	SPI_IER_UDRIE_Pos = 0x5
	// Bit mask of UDRIE field.
	SPI_IER_UDRIE_Msk = 0x20
	// Bit UDRIE.
	SPI_IER_UDRIE = 0x20
	// Underrun interrupt masked
	SPI_IER_UDRIE_Masked = 0x0
	// Underrun interrupt not masked
	SPI_IER_UDRIE_NotMasked = 0x1
	// Position of TXTFIE field.
	SPI_IER_TXTFIE_Pos = 0x4
	// Bit mask of TXTFIE field.
	SPI_IER_TXTFIE_Msk = 0x10
	// Bit TXTFIE.
	SPI_IER_TXTFIE = 0x10
	// Transmission transfer filled interrupt masked
	SPI_IER_TXTFIE_Masked = 0x0
	// Transmission transfer filled interrupt not masked
	SPI_IER_TXTFIE_NotMasked = 0x1
	// Position of EOTIE field.
	SPI_IER_EOTIE_Pos = 0x3
	// Bit mask of EOTIE field.
	SPI_IER_EOTIE_Msk = 0x8
	// Bit EOTIE.
	SPI_IER_EOTIE = 0x8
	// End-of-transfer interrupt masked
	SPI_IER_EOTIE_Masked = 0x0
	// End-of-transfer interrupt not masked
	SPI_IER_EOTIE_NotMasked = 0x1
	// Position of DXPIE field.
	SPI_IER_DXPIE_Pos = 0x2
	// Bit mask of DXPIE field.
	SPI_IER_DXPIE_Msk = 0x4
	// Bit DXPIE.
	SPI_IER_DXPIE = 0x4
	// Duplex transfer complete interrupt masked
	SPI_IER_DXPIE_Masked = 0x0
	// Duplex transfer complete interrupt not masked
	SPI_IER_DXPIE_NotMasked = 0x1
	// Position of TXPIE field.
	SPI_IER_TXPIE_Pos = 0x1
	// Bit mask of TXPIE field.
	SPI_IER_TXPIE_Msk = 0x2
	// Bit TXPIE.
	SPI_IER_TXPIE = 0x2
	// TX space available interrupt masked
	SPI_IER_TXPIE_Masked = 0x0
	// TX space available interrupt not masked
	SPI_IER_TXPIE_NotMasked = 0x1
	// Position of RXPIE field.
	SPI_IER_RXPIE_Pos = 0x0
	// Bit mask of RXPIE field.
	SPI_IER_RXPIE_Msk = 0x1
	// Bit RXPIE.
	SPI_IER_RXPIE = 0x1
	// RX data available interrupt masked
	SPI_IER_RXPIE_Masked = 0x0
	// RX data available interrupt not masked
	SPI_IER_RXPIE_NotMasked = 0x1

	// SR: Status Register
	// Position of CTSIZE field.
	SPI_SR_CTSIZE_Pos = 0x10
	// Bit mask of CTSIZE field.
	SPI_SR_CTSIZE_Msk = 0xffff0000
	// Position of RXWNE field.
	SPI_SR_RXWNE_Pos = 0xf
	// Bit mask of RXWNE field.
	SPI_SR_RXWNE_Msk = 0x8000
	// Bit RXWNE.
	SPI_SR_RXWNE = 0x8000
	// Less than 32-bit data frame received
	SPI_SR_RXWNE_LessThan32 = 0x0
	// At least 32-bit data frame received
	SPI_SR_RXWNE_AtLeast32 = 0x1
	// Position of RXPLVL field.
	SPI_SR_RXPLVL_Pos = 0xd
	// Bit mask of RXPLVL field.
	SPI_SR_RXPLVL_Msk = 0x6000
	// Zero frames beyond packing ratio available
	SPI_SR_RXPLVL_ZeroFrames = 0x0
	// One frame beyond packing ratio available
	SPI_SR_RXPLVL_OneFrame = 0x1
	// Two frame beyond packing ratio available
	SPI_SR_RXPLVL_TwoFrames = 0x2
	// Three frame beyond packing ratio available
	SPI_SR_RXPLVL_ThreeFrames = 0x3
	// Position of TXC field.
	SPI_SR_TXC_Pos = 0xc
	// Bit mask of TXC field.
	SPI_SR_TXC_Msk = 0x1000
	// Bit TXC.
	SPI_SR_TXC = 0x1000
	// Transmission ongoing
	SPI_SR_TXC_Ongoing = 0x0
	// Transmission completed
	SPI_SR_TXC_Completed = 0x1
	// Position of SUSP field.
	SPI_SR_SUSP_Pos = 0xb
	// Bit mask of SUSP field.
	SPI_SR_SUSP_Msk = 0x800
	// Bit SUSP.
	SPI_SR_SUSP = 0x800
	// Master not suspended
	SPI_SR_SUSP_NotSuspended = 0x0
	// Master suspended
	SPI_SR_SUSP_Suspended = 0x1
	// Position of TSERF field.
	SPI_SR_TSERF_Pos = 0xa
	// Bit mask of TSERF field.
	SPI_SR_TSERF_Msk = 0x400
	// Bit TSERF.
	SPI_SR_TSERF = 0x400
	// Additional number of SPI data to be transacted not yet loaded
	SPI_SR_TSERF_NotLoaded = 0x0
	// Additional number of SPI data to be transacted was reloaded
	SPI_SR_TSERF_Loaded = 0x1
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x9
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x200
	// Bit MODF.
	SPI_SR_MODF = 0x200
	// No mode fault detected
	SPI_SR_MODF_NoFault = 0x0
	// Mode fault detected
	SPI_SR_MODF_Fault = 0x1
	// Position of TIFRE field.
	SPI_SR_TIFRE_Pos = 0x8
	// Bit mask of TIFRE field.
	SPI_SR_TIFRE_Msk = 0x100
	// Bit TIFRE.
	SPI_SR_TIFRE = 0x100
	// TI frame format error detected
	SPI_SR_TIFRE_NoError = 0x0
	// TI frame format error detected
	SPI_SR_TIFRE_Error = 0x1
	// Position of CRCE field.
	SPI_SR_CRCE_Pos = 0x7
	// Bit mask of CRCE field.
	SPI_SR_CRCE_Msk = 0x80
	// Bit CRCE.
	SPI_SR_CRCE = 0x80
	// No CRC error detected
	SPI_SR_CRCE_NoError = 0x0
	// CRC error detected
	SPI_SR_CRCE_Error = 0x1
	// Position of OVR field.
	SPI_SR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	SPI_SR_OVR_Msk = 0x40
	// Bit OVR.
	SPI_SR_OVR = 0x40
	// No overrun occurred
	SPI_SR_OVR_NoOverrun = 0x0
	// Overrun occurred
	SPI_SR_OVR_Overrun = 0x1
	// Position of UDR field.
	SPI_SR_UDR_Pos = 0x5
	// Bit mask of UDR field.
	SPI_SR_UDR_Msk = 0x20
	// Bit UDR.
	SPI_SR_UDR = 0x20
	// No underrun occurred
	SPI_SR_UDR_NoUnderrun = 0x0
	// Underrun occurred
	SPI_SR_UDR_Underrun = 0x1
	// Position of TXTF field.
	SPI_SR_TXTF_Pos = 0x4
	// Bit mask of TXTF field.
	SPI_SR_TXTF_Msk = 0x10
	// Bit TXTF.
	SPI_SR_TXTF = 0x10
	// Transmission buffer incomplete
	SPI_SR_TXTF_NotCompleted = 0x0
	// Transmission buffer filled with at least one transfer
	SPI_SR_TXTF_Completed = 0x1
	// Position of EOT field.
	SPI_SR_EOT_Pos = 0x3
	// Bit mask of EOT field.
	SPI_SR_EOT_Msk = 0x8
	// Bit EOT.
	SPI_SR_EOT = 0x8
	// Transfer ongoing or not started
	SPI_SR_EOT_NotCompleted = 0x0
	// Transfer complete
	SPI_SR_EOT_Completed = 0x1
	// Position of DXP field.
	SPI_SR_DXP_Pos = 0x2
	// Bit mask of DXP field.
	SPI_SR_DXP_Msk = 0x4
	// Bit DXP.
	SPI_SR_DXP = 0x4
	// Duplex packet unavailable: no space for transmission and/or no data received
	SPI_SR_DXP_Unavailable = 0x0
	// Duplex packet available: space for transmission and data received
	SPI_SR_DXP_Available = 0x1
	// Position of TXP field.
	SPI_SR_TXP_Pos = 0x1
	// Bit mask of TXP field.
	SPI_SR_TXP_Msk = 0x2
	// Bit TXP.
	SPI_SR_TXP = 0x2
	// Tx buffer full
	SPI_SR_TXP_Full = 0x0
	// Tx buffer not full
	SPI_SR_TXP_NotFull = 0x1
	// Position of RXP field.
	SPI_SR_RXP_Pos = 0x0
	// Bit mask of RXP field.
	SPI_SR_RXP_Msk = 0x1
	// Bit RXP.
	SPI_SR_RXP = 0x1
	// Rx buffer empty
	SPI_SR_RXP_Empty = 0x0
	// Rx buffer not empty
	SPI_SR_RXP_NotEmpty = 0x1

	// IFCR: Interrupt/Status Flags Clear Register
	// Position of SUSPC field.
	SPI_IFCR_SUSPC_Pos = 0xb
	// Bit mask of SUSPC field.
	SPI_IFCR_SUSPC_Msk = 0x800
	// Bit SUSPC.
	SPI_IFCR_SUSPC = 0x800
	// Clear interrupt flag
	SPI_IFCR_SUSPC_Clear = 0x1
	// Position of TSERFC field.
	SPI_IFCR_TSERFC_Pos = 0xa
	// Bit mask of TSERFC field.
	SPI_IFCR_TSERFC_Msk = 0x400
	// Bit TSERFC.
	SPI_IFCR_TSERFC = 0x400
	// Clear interrupt flag
	SPI_IFCR_TSERFC_Clear = 0x1
	// Position of MODFC field.
	SPI_IFCR_MODFC_Pos = 0x9
	// Bit mask of MODFC field.
	SPI_IFCR_MODFC_Msk = 0x200
	// Bit MODFC.
	SPI_IFCR_MODFC = 0x200
	// Clear interrupt flag
	SPI_IFCR_MODFC_Clear = 0x1
	// Position of TIFREC field.
	SPI_IFCR_TIFREC_Pos = 0x8
	// Bit mask of TIFREC field.
	SPI_IFCR_TIFREC_Msk = 0x100
	// Bit TIFREC.
	SPI_IFCR_TIFREC = 0x100
	// Clear interrupt flag
	SPI_IFCR_TIFREC_Clear = 0x1
	// Position of CRCEC field.
	SPI_IFCR_CRCEC_Pos = 0x7
	// Bit mask of CRCEC field.
	SPI_IFCR_CRCEC_Msk = 0x80
	// Bit CRCEC.
	SPI_IFCR_CRCEC = 0x80
	// Clear interrupt flag
	SPI_IFCR_CRCEC_Clear = 0x1
	// Position of OVRC field.
	SPI_IFCR_OVRC_Pos = 0x6
	// Bit mask of OVRC field.
	SPI_IFCR_OVRC_Msk = 0x40
	// Bit OVRC.
	SPI_IFCR_OVRC = 0x40
	// Clear interrupt flag
	SPI_IFCR_OVRC_Clear = 0x1
	// Position of UDRC field.
	SPI_IFCR_UDRC_Pos = 0x5
	// Bit mask of UDRC field.
	SPI_IFCR_UDRC_Msk = 0x20
	// Bit UDRC.
	SPI_IFCR_UDRC = 0x20
	// Clear interrupt flag
	SPI_IFCR_UDRC_Clear = 0x1
	// Position of TXTFC field.
	SPI_IFCR_TXTFC_Pos = 0x4
	// Bit mask of TXTFC field.
	SPI_IFCR_TXTFC_Msk = 0x10
	// Bit TXTFC.
	SPI_IFCR_TXTFC = 0x10
	// Clear interrupt flag
	SPI_IFCR_TXTFC_Clear = 0x1
	// Position of EOTC field.
	SPI_IFCR_EOTC_Pos = 0x3
	// Bit mask of EOTC field.
	SPI_IFCR_EOTC_Msk = 0x8
	// Bit EOTC.
	SPI_IFCR_EOTC = 0x8
	// Clear interrupt flag
	SPI_IFCR_EOTC_Clear = 0x1

	// TXDR: Transmit Data Register
	// Position of TXDR field.
	SPI_TXDR_TXDR_Pos = 0x0
	// Bit mask of TXDR field.
	SPI_TXDR_TXDR_Msk = 0xffffffff

	// RXDR: Receive Data Register
	// Position of RXDR field.
	SPI_RXDR_RXDR_Pos = 0x0
	// Bit mask of RXDR field.
	SPI_RXDR_RXDR_Msk = 0xffffffff

	// CRCPOLY: Polynomial Register
	// Position of CRCPOLY field.
	SPI_CRCPOLY_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	SPI_CRCPOLY_CRCPOLY_Msk = 0xffffffff

	// TXCRC: Transmitter CRC Register
	// Position of TXCRC field.
	SPI_TXCRC_TXCRC_Pos = 0x0
	// Bit mask of TXCRC field.
	SPI_TXCRC_TXCRC_Msk = 0xffffffff

	// RXCRC: Receiver CRC Register
	// Position of RXCRC field.
	SPI_RXCRC_RXCRC_Pos = 0x0
	// Bit mask of RXCRC field.
	SPI_RXCRC_RXCRC_Msk = 0xffffffff

	// UDRDR: Underrun Data Register
	// Position of UDRDR field.
	SPI_UDRDR_UDRDR_Pos = 0x0
	// Bit mask of UDRDR field.
	SPI_UDRDR_UDRDR_Msk = 0xffffffff

	// I2SCFGR: configuration register
	// Position of MCKOE field.
	SPI_I2SCFGR_MCKOE_Pos = 0x19
	// Bit mask of MCKOE field.
	SPI_I2SCFGR_MCKOE_Msk = 0x2000000
	// Bit MCKOE.
	SPI_I2SCFGR_MCKOE = 0x2000000
	// Master clock output disabled
	SPI_I2SCFGR_MCKOE_Disabled = 0x0
	// Master clock output enabled
	SPI_I2SCFGR_MCKOE_Enabled = 0x1
	// Position of ODD field.
	SPI_I2SCFGR_ODD_Pos = 0x18
	// Bit mask of ODD field.
	SPI_I2SCFGR_ODD_Msk = 0x1000000
	// Bit ODD.
	SPI_I2SCFGR_ODD = 0x1000000
	// Real divider value is I2SDIV*2
	SPI_I2SCFGR_ODD_Even = 0x0
	// Real divider value is I2SDIV*2 + 1
	SPI_I2SCFGR_ODD_Odd = 0x1
	// Position of I2SDIV field.
	SPI_I2SCFGR_I2SDIV_Pos = 0x10
	// Bit mask of I2SDIV field.
	SPI_I2SCFGR_I2SDIV_Msk = 0xff0000
	// Position of DATFMT field.
	SPI_I2SCFGR_DATFMT_Pos = 0xe
	// Bit mask of DATFMT field.
	SPI_I2SCFGR_DATFMT_Msk = 0x4000
	// Bit DATFMT.
	SPI_I2SCFGR_DATFMT = 0x4000
	// The data inside RXDR and TXDR are right aligned
	SPI_I2SCFGR_DATFMT_RightAligned = 0x0
	// The data inside RXDR and TXDR are left aligned
	SPI_I2SCFGR_DATFMT_LeftAligned = 0x1
	// Position of WSINV field.
	SPI_I2SCFGR_WSINV_Pos = 0xd
	// Bit mask of WSINV field.
	SPI_I2SCFGR_WSINV_Msk = 0x2000
	// Bit WSINV.
	SPI_I2SCFGR_WSINV = 0x2000
	// Word select inversion disabled
	SPI_I2SCFGR_WSINV_Disabled = 0x0
	// Word select inversion enabled
	SPI_I2SCFGR_WSINV_Enabled = 0x1
	// Position of FIXCH field.
	SPI_I2SCFGR_FIXCH_Pos = 0xc
	// Bit mask of FIXCH field.
	SPI_I2SCFGR_FIXCH_Msk = 0x1000
	// Bit FIXCH.
	SPI_I2SCFGR_FIXCH = 0x1000
	// The channel length in slave mode is different from 16 or 32 bits (CHLEN not taken into account)
	SPI_I2SCFGR_FIXCH_NotFixed = 0x0
	// The channel length in slave mode is supposed to be 16 or 32 bits (according to CHLEN)
	SPI_I2SCFGR_FIXCH_Fixed = 0x1
	// Position of CKPOL field.
	SPI_I2SCFGR_CKPOL_Pos = 0xb
	// Bit mask of CKPOL field.
	SPI_I2SCFGR_CKPOL_Msk = 0x800
	// Bit CKPOL.
	SPI_I2SCFGR_CKPOL = 0x800
	// Signals are sampled on rising and changed on falling clock edges
	SPI_I2SCFGR_CKPOL_SampleOnRising = 0x0
	// Signals are sampled on falling and changed on rising clock edges
	SPI_I2SCFGR_CKPOL_SampleOnFalling = 0x1
	// Position of CHLEN field.
	SPI_I2SCFGR_CHLEN_Pos = 0xa
	// Bit mask of CHLEN field.
	SPI_I2SCFGR_CHLEN_Msk = 0x400
	// Bit CHLEN.
	SPI_I2SCFGR_CHLEN = 0x400
	// 16 bit per channel
	SPI_I2SCFGR_CHLEN_Bits16 = 0x0
	// 32 bit per channel
	SPI_I2SCFGR_CHLEN_Bits32 = 0x1
	// Position of DATLEN field.
	SPI_I2SCFGR_DATLEN_Pos = 0x8
	// Bit mask of DATLEN field.
	SPI_I2SCFGR_DATLEN_Msk = 0x300
	// 16 bit data length
	SPI_I2SCFGR_DATLEN_Bits16 = 0x0
	// 24 bit data length
	SPI_I2SCFGR_DATLEN_Bits24 = 0x1
	// 32 bit data length
	SPI_I2SCFGR_DATLEN_Bits32 = 0x2
	// Position of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Pos = 0x7
	// Bit mask of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Msk = 0x80
	// Bit PCMSYNC.
	SPI_I2SCFGR_PCMSYNC = 0x80
	// Short PCM frame synchronization
	SPI_I2SCFGR_PCMSYNC_Short = 0x0
	// Long PCM frame synchronization
	SPI_I2SCFGR_PCMSYNC_Long = 0x1
	// Position of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Pos = 0x4
	// Bit mask of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Msk = 0x30
	// I2S Philips standard
	SPI_I2SCFGR_I2SSTD_Philips = 0x0
	// MSB/left justified standard
	SPI_I2SCFGR_I2SSTD_LeftAligned = 0x1
	// LSB/right justified standard
	SPI_I2SCFGR_I2SSTD_RightAligned = 0x2
	// PCM standard
	SPI_I2SCFGR_I2SSTD_PCM = 0x3
	// Position of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Pos = 0x1
	// Bit mask of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Msk = 0xe
	// Slave, transmit
	SPI_I2SCFGR_I2SCFG_SlaveTransmit = 0x0
	// Slave, recteive
	SPI_I2SCFGR_I2SCFG_SlaveReceive = 0x1
	// Master, transmit
	SPI_I2SCFGR_I2SCFG_MasterTransmit = 0x2
	// Master, receive
	SPI_I2SCFGR_I2SCFG_MasterReceive = 0x3
	// Slave, full duplex
	SPI_I2SCFGR_I2SCFG_SlaveFullDuplex = 0x4
	// Master, full duplex
	SPI_I2SCFGR_I2SCFG_MasterFullDuplex = 0x5
	// Position of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Pos = 0x0
	// Bit mask of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Msk = 0x1
	// Bit I2SMOD.
	SPI_I2SCFGR_I2SMOD = 0x1
	// SPI mode selected
	SPI_I2SCFGR_I2SMOD_SPI = 0x0
	// I2S/PCM mode selected
	SPI_I2SCFGR_I2SMOD_I2S = 0x1
)

// Constants for STK: SysTick timer
const (
	// CSR: SysTick control and status register
	// Position of ENABLE field.
	STK_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	STK_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	STK_CSR_ENABLE = 0x1
	// Position of TICKINT field.
	STK_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	STK_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	STK_CSR_TICKINT = 0x2
	// Position of CLKSOURCE field.
	STK_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	STK_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	STK_CSR_CLKSOURCE = 0x4
	// Position of COUNTFLAG field.
	STK_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	STK_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	STK_CSR_COUNTFLAG = 0x10000

	// RVR: SysTick reload value register
	// Position of RELOAD field.
	STK_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	STK_RVR_RELOAD_Msk = 0xffffff

	// CVR: SysTick current value register
	// Position of CURRENT field.
	STK_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	STK_CVR_CURRENT_Msk = 0xffffff

	// CALIB: SysTick calibration value register
	// Position of TENMS field.
	STK_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	STK_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	STK_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	STK_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	STK_CALIB_SKEW = 0x40000000
	// Position of NOREF field.
	STK_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	STK_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	STK_CALIB_NOREF = 0x80000000
)

// Constants for SWPMI: Single Wire Protocol Master Interface
const (
	// CR: SWPMI Configuration/Control register
	// Position of RXDMA field.
	SWPMI_CR_RXDMA_Pos = 0x0
	// Bit mask of RXDMA field.
	SWPMI_CR_RXDMA_Msk = 0x1
	// Bit RXDMA.
	SWPMI_CR_RXDMA = 0x1
	// Position of TXDMA field.
	SWPMI_CR_TXDMA_Pos = 0x1
	// Bit mask of TXDMA field.
	SWPMI_CR_TXDMA_Msk = 0x2
	// Bit TXDMA.
	SWPMI_CR_TXDMA = 0x2
	// Position of RXMODE field.
	SWPMI_CR_RXMODE_Pos = 0x2
	// Bit mask of RXMODE field.
	SWPMI_CR_RXMODE_Msk = 0x4
	// Bit RXMODE.
	SWPMI_CR_RXMODE = 0x4
	// Position of TXMODE field.
	SWPMI_CR_TXMODE_Pos = 0x3
	// Bit mask of TXMODE field.
	SWPMI_CR_TXMODE_Msk = 0x8
	// Bit TXMODE.
	SWPMI_CR_TXMODE = 0x8
	// Position of LPBK field.
	SWPMI_CR_LPBK_Pos = 0x4
	// Bit mask of LPBK field.
	SWPMI_CR_LPBK_Msk = 0x10
	// Bit LPBK.
	SWPMI_CR_LPBK = 0x10
	// Position of SWPACT field.
	SWPMI_CR_SWPACT_Pos = 0x5
	// Bit mask of SWPACT field.
	SWPMI_CR_SWPACT_Msk = 0x20
	// Bit SWPACT.
	SWPMI_CR_SWPACT = 0x20
	// Position of DEACT field.
	SWPMI_CR_DEACT_Pos = 0xa
	// Bit mask of DEACT field.
	SWPMI_CR_DEACT_Msk = 0x400
	// Bit DEACT.
	SWPMI_CR_DEACT = 0x400
	// Position of SWPTEN field.
	SWPMI_CR_SWPTEN_Pos = 0xb
	// Bit mask of SWPTEN field.
	SWPMI_CR_SWPTEN_Msk = 0x800
	// Bit SWPTEN.
	SWPMI_CR_SWPTEN = 0x800

	// BRR: SWPMI Bitrate register
	// Position of BR field.
	SWPMI_BRR_BR_Pos = 0x0
	// Bit mask of BR field.
	SWPMI_BRR_BR_Msk = 0xff

	// ISR: SWPMI Interrupt and Status register
	// Position of RXBFF field.
	SWPMI_ISR_RXBFF_Pos = 0x0
	// Bit mask of RXBFF field.
	SWPMI_ISR_RXBFF_Msk = 0x1
	// Bit RXBFF.
	SWPMI_ISR_RXBFF = 0x1
	// Position of TXBEF field.
	SWPMI_ISR_TXBEF_Pos = 0x1
	// Bit mask of TXBEF field.
	SWPMI_ISR_TXBEF_Msk = 0x2
	// Bit TXBEF.
	SWPMI_ISR_TXBEF = 0x2
	// Position of RXBERF field.
	SWPMI_ISR_RXBERF_Pos = 0x2
	// Bit mask of RXBERF field.
	SWPMI_ISR_RXBERF_Msk = 0x4
	// Bit RXBERF.
	SWPMI_ISR_RXBERF = 0x4
	// Position of RXOVRF field.
	SWPMI_ISR_RXOVRF_Pos = 0x3
	// Bit mask of RXOVRF field.
	SWPMI_ISR_RXOVRF_Msk = 0x8
	// Bit RXOVRF.
	SWPMI_ISR_RXOVRF = 0x8
	// Position of TXUNRF field.
	SWPMI_ISR_TXUNRF_Pos = 0x4
	// Bit mask of TXUNRF field.
	SWPMI_ISR_TXUNRF_Msk = 0x10
	// Bit TXUNRF.
	SWPMI_ISR_TXUNRF = 0x10
	// Position of RXNE field.
	SWPMI_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	SWPMI_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	SWPMI_ISR_RXNE = 0x20
	// Position of TXE field.
	SWPMI_ISR_TXE_Pos = 0x6
	// Bit mask of TXE field.
	SWPMI_ISR_TXE_Msk = 0x40
	// Bit TXE.
	SWPMI_ISR_TXE = 0x40
	// Position of TCF field.
	SWPMI_ISR_TCF_Pos = 0x7
	// Bit mask of TCF field.
	SWPMI_ISR_TCF_Msk = 0x80
	// Bit TCF.
	SWPMI_ISR_TCF = 0x80
	// Position of SRF field.
	SWPMI_ISR_SRF_Pos = 0x8
	// Bit mask of SRF field.
	SWPMI_ISR_SRF_Msk = 0x100
	// Bit SRF.
	SWPMI_ISR_SRF = 0x100
	// Position of SUSP field.
	SWPMI_ISR_SUSP_Pos = 0x9
	// Bit mask of SUSP field.
	SWPMI_ISR_SUSP_Msk = 0x200
	// Bit SUSP.
	SWPMI_ISR_SUSP = 0x200
	// Position of DEACTF field.
	SWPMI_ISR_DEACTF_Pos = 0xa
	// Bit mask of DEACTF field.
	SWPMI_ISR_DEACTF_Msk = 0x400
	// Bit DEACTF.
	SWPMI_ISR_DEACTF = 0x400
	// Position of RDYF field.
	SWPMI_ISR_RDYF_Pos = 0xb
	// Bit mask of RDYF field.
	SWPMI_ISR_RDYF_Msk = 0x800
	// Bit RDYF.
	SWPMI_ISR_RDYF = 0x800

	// ICR: SWPMI Interrupt Flag Clear register
	// Position of CRXBFF field.
	SWPMI_ICR_CRXBFF_Pos = 0x0
	// Bit mask of CRXBFF field.
	SWPMI_ICR_CRXBFF_Msk = 0x1
	// Bit CRXBFF.
	SWPMI_ICR_CRXBFF = 0x1
	// Position of CTXBEF field.
	SWPMI_ICR_CTXBEF_Pos = 0x1
	// Bit mask of CTXBEF field.
	SWPMI_ICR_CTXBEF_Msk = 0x2
	// Bit CTXBEF.
	SWPMI_ICR_CTXBEF = 0x2
	// Position of CRXBERF field.
	SWPMI_ICR_CRXBERF_Pos = 0x2
	// Bit mask of CRXBERF field.
	SWPMI_ICR_CRXBERF_Msk = 0x4
	// Bit CRXBERF.
	SWPMI_ICR_CRXBERF = 0x4
	// Position of CRXOVRF field.
	SWPMI_ICR_CRXOVRF_Pos = 0x3
	// Bit mask of CRXOVRF field.
	SWPMI_ICR_CRXOVRF_Msk = 0x8
	// Bit CRXOVRF.
	SWPMI_ICR_CRXOVRF = 0x8
	// Position of CTXUNRF field.
	SWPMI_ICR_CTXUNRF_Pos = 0x4
	// Bit mask of CTXUNRF field.
	SWPMI_ICR_CTXUNRF_Msk = 0x10
	// Bit CTXUNRF.
	SWPMI_ICR_CTXUNRF = 0x10
	// Position of CTCF field.
	SWPMI_ICR_CTCF_Pos = 0x7
	// Bit mask of CTCF field.
	SWPMI_ICR_CTCF_Msk = 0x80
	// Bit CTCF.
	SWPMI_ICR_CTCF = 0x80
	// Position of CSRF field.
	SWPMI_ICR_CSRF_Pos = 0x8
	// Bit mask of CSRF field.
	SWPMI_ICR_CSRF_Msk = 0x100
	// Bit CSRF.
	SWPMI_ICR_CSRF = 0x100
	// Position of CRDYF field.
	SWPMI_ICR_CRDYF_Pos = 0xb
	// Bit mask of CRDYF field.
	SWPMI_ICR_CRDYF_Msk = 0x800
	// Bit CRDYF.
	SWPMI_ICR_CRDYF = 0x800

	// IER: SWPMI Interrupt Enable register
	// Position of RXBFIE field.
	SWPMI_IER_RXBFIE_Pos = 0x0
	// Bit mask of RXBFIE field.
	SWPMI_IER_RXBFIE_Msk = 0x1
	// Bit RXBFIE.
	SWPMI_IER_RXBFIE = 0x1
	// Position of TXBEIE field.
	SWPMI_IER_TXBEIE_Pos = 0x1
	// Bit mask of TXBEIE field.
	SWPMI_IER_TXBEIE_Msk = 0x2
	// Bit TXBEIE.
	SWPMI_IER_TXBEIE = 0x2
	// Position of RXBERIE field.
	SWPMI_IER_RXBERIE_Pos = 0x2
	// Bit mask of RXBERIE field.
	SWPMI_IER_RXBERIE_Msk = 0x4
	// Bit RXBERIE.
	SWPMI_IER_RXBERIE = 0x4
	// Position of RXOVRIE field.
	SWPMI_IER_RXOVRIE_Pos = 0x3
	// Bit mask of RXOVRIE field.
	SWPMI_IER_RXOVRIE_Msk = 0x8
	// Bit RXOVRIE.
	SWPMI_IER_RXOVRIE = 0x8
	// Position of TXUNRIE field.
	SWPMI_IER_TXUNRIE_Pos = 0x4
	// Bit mask of TXUNRIE field.
	SWPMI_IER_TXUNRIE_Msk = 0x10
	// Bit TXUNRIE.
	SWPMI_IER_TXUNRIE = 0x10
	// Position of RIE field.
	SWPMI_IER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	SWPMI_IER_RIE_Msk = 0x20
	// Bit RIE.
	SWPMI_IER_RIE = 0x20
	// Position of TIE field.
	SWPMI_IER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	SWPMI_IER_TIE_Msk = 0x40
	// Bit TIE.
	SWPMI_IER_TIE = 0x40
	// Position of TCIE field.
	SWPMI_IER_TCIE_Pos = 0x7
	// Bit mask of TCIE field.
	SWPMI_IER_TCIE_Msk = 0x80
	// Bit TCIE.
	SWPMI_IER_TCIE = 0x80
	// Position of SRIE field.
	SWPMI_IER_SRIE_Pos = 0x8
	// Bit mask of SRIE field.
	SWPMI_IER_SRIE_Msk = 0x100
	// Bit SRIE.
	SWPMI_IER_SRIE = 0x100
	// Position of RDYIE field.
	SWPMI_IER_RDYIE_Pos = 0xb
	// Bit mask of RDYIE field.
	SWPMI_IER_RDYIE_Msk = 0x800
	// Bit RDYIE.
	SWPMI_IER_RDYIE = 0x800

	// RFL: SWPMI Receive Frame Length register
	// Position of RFL field.
	SWPMI_RFL_RFL_Pos = 0x0
	// Bit mask of RFL field.
	SWPMI_RFL_RFL_Msk = 0x1f

	// TDR: SWPMI Transmit data register
	// Position of TD field.
	SWPMI_TDR_TD_Pos = 0x0
	// Bit mask of TD field.
	SWPMI_TDR_TD_Msk = 0xffffffff

	// RDR: SWPMI Receive data register
	// Position of RD field.
	SWPMI_RDR_RD_Pos = 0x0
	// Bit mask of RD field.
	SWPMI_RDR_RD_Msk = 0xffffffff

	// OR: SWPMI Option register
	// Position of SWP_TBYP field.
	SWPMI_OR_SWP_TBYP_Pos = 0x0
	// Bit mask of SWP_TBYP field.
	SWPMI_OR_SWP_TBYP_Msk = 0x1
	// Bit SWP_TBYP.
	SWPMI_OR_SWP_TBYP = 0x1
	// Position of SWP_CLASS field.
	SWPMI_OR_SWP_CLASS_Pos = 0x1
	// Bit mask of SWP_CLASS field.
	SWPMI_OR_SWP_CLASS_Msk = 0x2
	// Bit SWP_CLASS.
	SWPMI_OR_SWP_CLASS = 0x2
)

// Constants for SYSCFG: System configuration controller
const (
	// PMCR: peripheral mode configuration register
	// Position of I2C1FMP field.
	SYSCFG_PMCR_I2C1FMP_Pos = 0x0
	// Bit mask of I2C1FMP field.
	SYSCFG_PMCR_I2C1FMP_Msk = 0x1
	// Bit I2C1FMP.
	SYSCFG_PMCR_I2C1FMP = 0x1
	// Position of I2C2FMP field.
	SYSCFG_PMCR_I2C2FMP_Pos = 0x1
	// Bit mask of I2C2FMP field.
	SYSCFG_PMCR_I2C2FMP_Msk = 0x2
	// Bit I2C2FMP.
	SYSCFG_PMCR_I2C2FMP = 0x2
	// Position of I2C3FMP field.
	SYSCFG_PMCR_I2C3FMP_Pos = 0x2
	// Bit mask of I2C3FMP field.
	SYSCFG_PMCR_I2C3FMP_Msk = 0x4
	// Bit I2C3FMP.
	SYSCFG_PMCR_I2C3FMP = 0x4
	// Position of I2C4FMP field.
	SYSCFG_PMCR_I2C4FMP_Pos = 0x3
	// Bit mask of I2C4FMP field.
	SYSCFG_PMCR_I2C4FMP_Msk = 0x8
	// Bit I2C4FMP.
	SYSCFG_PMCR_I2C4FMP = 0x8
	// Position of PB6FMP field.
	SYSCFG_PMCR_PB6FMP_Pos = 0x4
	// Bit mask of PB6FMP field.
	SYSCFG_PMCR_PB6FMP_Msk = 0x10
	// Bit PB6FMP.
	SYSCFG_PMCR_PB6FMP = 0x10
	// Position of PB7FMP field.
	SYSCFG_PMCR_PB7FMP_Pos = 0x5
	// Bit mask of PB7FMP field.
	SYSCFG_PMCR_PB7FMP_Msk = 0x20
	// Bit PB7FMP.
	SYSCFG_PMCR_PB7FMP = 0x20
	// Position of PB8FMP field.
	SYSCFG_PMCR_PB8FMP_Pos = 0x6
	// Bit mask of PB8FMP field.
	SYSCFG_PMCR_PB8FMP_Msk = 0x40
	// Bit PB8FMP.
	SYSCFG_PMCR_PB8FMP = 0x40
	// Position of PB9FMP field.
	SYSCFG_PMCR_PB9FMP_Pos = 0x7
	// Bit mask of PB9FMP field.
	SYSCFG_PMCR_PB9FMP_Msk = 0x80
	// Bit PB9FMP.
	SYSCFG_PMCR_PB9FMP = 0x80
	// Position of BOOSTE field.
	SYSCFG_PMCR_BOOSTE_Pos = 0x8
	// Bit mask of BOOSTE field.
	SYSCFG_PMCR_BOOSTE_Msk = 0x100
	// Bit BOOSTE.
	SYSCFG_PMCR_BOOSTE = 0x100
	// Position of EPIS field.
	SYSCFG_PMCR_EPIS_Pos = 0x15
	// Bit mask of EPIS field.
	SYSCFG_PMCR_EPIS_Msk = 0xe00000
	// Position of PA0SO field.
	SYSCFG_PMCR_PA0SO_Pos = 0x18
	// Bit mask of PA0SO field.
	SYSCFG_PMCR_PA0SO_Msk = 0x1000000
	// Bit PA0SO.
	SYSCFG_PMCR_PA0SO = 0x1000000
	// Position of PA1SO field.
	SYSCFG_PMCR_PA1SO_Pos = 0x19
	// Bit mask of PA1SO field.
	SYSCFG_PMCR_PA1SO_Msk = 0x2000000
	// Bit PA1SO.
	SYSCFG_PMCR_PA1SO = 0x2000000
	// Position of PC2SO field.
	SYSCFG_PMCR_PC2SO_Pos = 0x1a
	// Bit mask of PC2SO field.
	SYSCFG_PMCR_PC2SO_Msk = 0x4000000
	// Bit PC2SO.
	SYSCFG_PMCR_PC2SO = 0x4000000
	// Position of PC3SO field.
	SYSCFG_PMCR_PC3SO_Pos = 0x1b
	// Bit mask of PC3SO field.
	SYSCFG_PMCR_PC3SO_Msk = 0x8000000
	// Bit PC3SO.
	SYSCFG_PMCR_PC3SO = 0x8000000
	// Position of BOOSTVDDSEL field.
	SYSCFG_PMCR_BOOSTVDDSEL_Pos = 0x9
	// Bit mask of BOOSTVDDSEL field.
	SYSCFG_PMCR_BOOSTVDDSEL_Msk = 0x200
	// Bit BOOSTVDDSEL.
	SYSCFG_PMCR_BOOSTVDDSEL = 0x200
	// Position of I2C5FMP field.
	SYSCFG_PMCR_I2C5FMP_Pos = 0xa
	// Bit mask of I2C5FMP field.
	SYSCFG_PMCR_I2C5FMP_Msk = 0x400
	// Bit I2C5FMP.
	SYSCFG_PMCR_I2C5FMP = 0x400

	// EXTICR1: external interrupt configuration register 1
	// Position of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Pos = 0xc
	// Bit mask of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Msk = 0xf000
	// Position of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Pos = 0x8
	// Bit mask of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Msk = 0xf00
	// Position of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Pos = 0x4
	// Bit mask of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Msk = 0xf0
	// Position of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Pos = 0x0
	// Bit mask of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Msk = 0xf

	// EXTICR2: external interrupt configuration register 2
	// Position of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Pos = 0xc
	// Bit mask of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Msk = 0xf000
	// Position of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Pos = 0x8
	// Bit mask of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Msk = 0xf00
	// Position of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Pos = 0x4
	// Bit mask of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Msk = 0xf0
	// Position of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Pos = 0x0
	// Bit mask of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Msk = 0xf

	// EXTICR3: external interrupt configuration register 3
	// Position of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Pos = 0xc
	// Bit mask of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Msk = 0xf000
	// Position of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Pos = 0x8
	// Bit mask of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Msk = 0xf00
	// Position of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Pos = 0x4
	// Bit mask of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Msk = 0xf0
	// Position of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Pos = 0x0
	// Bit mask of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Msk = 0xf

	// EXTICR4: external interrupt configuration register 4
	// Position of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Pos = 0xc
	// Bit mask of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Msk = 0xf000
	// Position of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Pos = 0x8
	// Bit mask of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Msk = 0xf00
	// Position of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Pos = 0x4
	// Bit mask of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Msk = 0xf0
	// Position of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Pos = 0x0
	// Bit mask of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Msk = 0xf

	// CFGR: Timer break lockup register
	// Position of PVDL field.
	SYSCFG_CFGR_PVDL_Pos = 0x2
	// Bit mask of PVDL field.
	SYSCFG_CFGR_PVDL_Msk = 0x4
	// Bit PVDL.
	SYSCFG_CFGR_PVDL = 0x4
	// Position of FLASHL field.
	SYSCFG_CFGR_FLASHL_Pos = 0x3
	// Bit mask of FLASHL field.
	SYSCFG_CFGR_FLASHL_Msk = 0x8
	// Bit FLASHL.
	SYSCFG_CFGR_FLASHL = 0x8
	// Position of CM7L field.
	SYSCFG_CFGR_CM7L_Pos = 0x6
	// Bit mask of CM7L field.
	SYSCFG_CFGR_CM7L_Msk = 0x40
	// Bit CM7L.
	SYSCFG_CFGR_CM7L = 0x40
	// Position of BKRAML field.
	SYSCFG_CFGR_BKRAML_Pos = 0x7
	// Bit mask of BKRAML field.
	SYSCFG_CFGR_BKRAML_Msk = 0x80
	// Bit BKRAML.
	SYSCFG_CFGR_BKRAML = 0x80
	// Position of SRAM4L field.
	SYSCFG_CFGR_SRAM4L_Pos = 0x9
	// Bit mask of SRAM4L field.
	SYSCFG_CFGR_SRAM4L_Msk = 0x200
	// Bit SRAM4L.
	SYSCFG_CFGR_SRAM4L = 0x200
	// Position of SRAM2L field.
	SYSCFG_CFGR_SRAM2L_Pos = 0xb
	// Bit mask of SRAM2L field.
	SYSCFG_CFGR_SRAM2L_Msk = 0x800
	// Bit SRAM2L.
	SYSCFG_CFGR_SRAM2L = 0x800
	// Position of SRAM1L field.
	SYSCFG_CFGR_SRAM1L_Pos = 0xc
	// Bit mask of SRAM1L field.
	SYSCFG_CFGR_SRAM1L_Msk = 0x1000
	// Bit SRAM1L.
	SYSCFG_CFGR_SRAM1L = 0x1000
	// Position of DTCML field.
	SYSCFG_CFGR_DTCML_Pos = 0xd
	// Bit mask of DTCML field.
	SYSCFG_CFGR_DTCML_Msk = 0x2000
	// Bit DTCML.
	SYSCFG_CFGR_DTCML = 0x2000
	// Position of ITCML field.
	SYSCFG_CFGR_ITCML_Pos = 0xe
	// Bit mask of ITCML field.
	SYSCFG_CFGR_ITCML_Msk = 0x4000
	// Bit ITCML.
	SYSCFG_CFGR_ITCML = 0x4000
	// Position of AXIRAML field.
	SYSCFG_CFGR_AXIRAML_Pos = 0xf
	// Bit mask of AXIRAML field.
	SYSCFG_CFGR_AXIRAML_Msk = 0x8000
	// Bit AXIRAML.
	SYSCFG_CFGR_AXIRAML = 0x8000

	// CCCSR: compensation cell control/status register
	// Position of EN field.
	SYSCFG_CCCSR_EN_Pos = 0x0
	// Bit mask of EN field.
	SYSCFG_CCCSR_EN_Msk = 0x1
	// Bit EN.
	SYSCFG_CCCSR_EN = 0x1
	// Position of CS field.
	SYSCFG_CCCSR_CS_Pos = 0x1
	// Bit mask of CS field.
	SYSCFG_CCCSR_CS_Msk = 0x2
	// Bit CS.
	SYSCFG_CCCSR_CS = 0x2
	// Position of READY field.
	SYSCFG_CCCSR_READY_Pos = 0x8
	// Bit mask of READY field.
	SYSCFG_CCCSR_READY_Msk = 0x100
	// Bit READY.
	SYSCFG_CCCSR_READY = 0x100
	// Position of HSLV field.
	SYSCFG_CCCSR_HSLV_Pos = 0x10
	// Bit mask of HSLV field.
	SYSCFG_CCCSR_HSLV_Msk = 0x10000
	// Bit HSLV.
	SYSCFG_CCCSR_HSLV = 0x10000

	// CCVR: SYSCFG compensation cell value register
	// Position of NCV field.
	SYSCFG_CCVR_NCV_Pos = 0x0
	// Bit mask of NCV field.
	SYSCFG_CCVR_NCV_Msk = 0xf
	// Position of PCV field.
	SYSCFG_CCVR_PCV_Pos = 0x4
	// Bit mask of PCV field.
	SYSCFG_CCVR_PCV_Msk = 0xf0

	// CCCR: SYSCFG compensation cell code register
	// Position of NCC field.
	SYSCFG_CCCR_NCC_Pos = 0x0
	// Bit mask of NCC field.
	SYSCFG_CCCR_NCC_Msk = 0xf
	// Position of PCC field.
	SYSCFG_CCCR_PCC_Pos = 0x4
	// Bit mask of PCC field.
	SYSCFG_CCCR_PCC_Msk = 0xf0

	// ADC2ALT: ADC2 internal input alternate connection
	// Position of ADC2_ROUT1 field.
	SYSCFG_ADC2ALT_ADC2_ROUT1_Pos = 0x1
	// Bit mask of ADC2_ROUT1 field.
	SYSCFG_ADC2ALT_ADC2_ROUT1_Msk = 0x2
	// Bit ADC2_ROUT1.
	SYSCFG_ADC2ALT_ADC2_ROUT1 = 0x2
	// Position of ADC2_ROUT0 field.
	SYSCFG_ADC2ALT_ADC2_ROUT0_Pos = 0x0
	// Bit mask of ADC2_ROUT0 field.
	SYSCFG_ADC2ALT_ADC2_ROUT0_Msk = 0x1
	// Bit ADC2_ROUT0.
	SYSCFG_ADC2ALT_ADC2_ROUT0 = 0x1

	// PKGR: SYSCFG package register
	// Position of PKG field.
	SYSCFG_PKGR_PKG_Pos = 0x0
	// Bit mask of PKG field.
	SYSCFG_PKGR_PKG_Msk = 0xf

	// UR0: SYSCFG user register 0
	// Position of RDP field.
	SYSCFG_UR0_RDP_Pos = 0x10
	// Bit mask of RDP field.
	SYSCFG_UR0_RDP_Msk = 0xff0000

	// UR2: SYSCFG user register 2
	// Position of BORH field.
	SYSCFG_UR2_BORH_Pos = 0x0
	// Bit mask of BORH field.
	SYSCFG_UR2_BORH_Msk = 0x3
	// Position of BOOT_ADD0 field.
	SYSCFG_UR2_BOOT_ADD0_Pos = 0x10
	// Bit mask of BOOT_ADD0 field.
	SYSCFG_UR2_BOOT_ADD0_Msk = 0xffff0000

	// UR3: SYSCFG user register 3
	// Position of BOOT_ADD1 field.
	SYSCFG_UR3_BOOT_ADD1_Pos = 0x10
	// Bit mask of BOOT_ADD1 field.
	SYSCFG_UR3_BOOT_ADD1_Msk = 0xffff0000

	// UR4: SYSCFG user register 4
	// Position of MEPAD_1 field.
	SYSCFG_UR4_MEPAD_1_Pos = 0x10
	// Bit mask of MEPAD_1 field.
	SYSCFG_UR4_MEPAD_1_Msk = 0x10000
	// Bit MEPAD_1.
	SYSCFG_UR4_MEPAD_1 = 0x10000

	// UR5: SYSCFG user register 5
	// Position of MESAD_1 field.
	SYSCFG_UR5_MESAD_1_Pos = 0x0
	// Bit mask of MESAD_1 field.
	SYSCFG_UR5_MESAD_1_Msk = 0x1
	// Bit MESAD_1.
	SYSCFG_UR5_MESAD_1 = 0x1
	// Position of WRPN_1 field.
	SYSCFG_UR5_WRPN_1_Pos = 0x10
	// Bit mask of WRPN_1 field.
	SYSCFG_UR5_WRPN_1_Msk = 0xff0000

	// UR6: SYSCFG user register 6
	// Position of PA_BEG_1 field.
	SYSCFG_UR6_PA_BEG_1_Pos = 0x0
	// Bit mask of PA_BEG_1 field.
	SYSCFG_UR6_PA_BEG_1_Msk = 0xfff
	// Position of PA_END_1 field.
	SYSCFG_UR6_PA_END_1_Pos = 0x10
	// Bit mask of PA_END_1 field.
	SYSCFG_UR6_PA_END_1_Msk = 0xfff0000

	// UR7: SYSCFG user register 7
	// Position of SA_BEG_1 field.
	SYSCFG_UR7_SA_BEG_1_Pos = 0x0
	// Bit mask of SA_BEG_1 field.
	SYSCFG_UR7_SA_BEG_1_Msk = 0xfff
	// Position of SA_END_1 field.
	SYSCFG_UR7_SA_END_1_Pos = 0x10
	// Bit mask of SA_END_1 field.
	SYSCFG_UR7_SA_END_1_Msk = 0xfff0000

	// UR11: SYSCFG user register 11
	// Position of IWDG1M field.
	SYSCFG_UR11_IWDG1M_Pos = 0x10
	// Bit mask of IWDG1M field.
	SYSCFG_UR11_IWDG1M_Msk = 0x10000
	// Bit IWDG1M.
	SYSCFG_UR11_IWDG1M = 0x10000

	// UR12: SYSCFG user register 12
	// Position of SECURE field.
	SYSCFG_UR12_SECURE_Pos = 0x10
	// Bit mask of SECURE field.
	SYSCFG_UR12_SECURE_Msk = 0x10000
	// Bit SECURE.
	SYSCFG_UR12_SECURE = 0x10000

	// UR13: SYSCFG user register 13
	// Position of SDRS field.
	SYSCFG_UR13_SDRS_Pos = 0x0
	// Bit mask of SDRS field.
	SYSCFG_UR13_SDRS_Msk = 0x3
	// Position of D1SBRST field.
	SYSCFG_UR13_D1SBRST_Pos = 0x10
	// Bit mask of D1SBRST field.
	SYSCFG_UR13_D1SBRST_Msk = 0x10000
	// Bit D1SBRST.
	SYSCFG_UR13_D1SBRST = 0x10000

	// UR14: SYSCFG user register 14
	// Position of D1STPRST field.
	SYSCFG_UR14_D1STPRST_Pos = 0x0
	// Bit mask of D1STPRST field.
	SYSCFG_UR14_D1STPRST_Msk = 0x1
	// Bit D1STPRST.
	SYSCFG_UR14_D1STPRST = 0x1

	// UR15: SYSCFG user register 15
	// Position of FZIWDGSTB field.
	SYSCFG_UR15_FZIWDGSTB_Pos = 0x10
	// Bit mask of FZIWDGSTB field.
	SYSCFG_UR15_FZIWDGSTB_Msk = 0x10000
	// Bit FZIWDGSTB.
	SYSCFG_UR15_FZIWDGSTB = 0x10000

	// UR16: SYSCFG user register 16
	// Position of FZIWDGSTP field.
	SYSCFG_UR16_FZIWDGSTP_Pos = 0x0
	// Bit mask of FZIWDGSTP field.
	SYSCFG_UR16_FZIWDGSTP_Msk = 0x1
	// Bit FZIWDGSTP.
	SYSCFG_UR16_FZIWDGSTP = 0x1
	// Position of PKP field.
	SYSCFG_UR16_PKP_Pos = 0x10
	// Bit mask of PKP field.
	SYSCFG_UR16_PKP_Msk = 0x10000
	// Bit PKP.
	SYSCFG_UR16_PKP = 0x10000

	// UR17: SYSCFG user register 17
	// Position of IO_HSLV field.
	SYSCFG_UR17_IO_HSLV_Pos = 0x0
	// Bit mask of IO_HSLV field.
	SYSCFG_UR17_IO_HSLV_Msk = 0x1
	// Bit IO_HSLV.
	SYSCFG_UR17_IO_HSLV = 0x1
	// Position of TCM_AXI_SHARED_CFG field.
	SYSCFG_UR17_TCM_AXI_SHARED_CFG_Pos = 0x10
	// Bit mask of TCM_AXI_SHARED_CFG field.
	SYSCFG_UR17_TCM_AXI_SHARED_CFG_Msk = 0x30000

	// UR18: SYSCFG user register 18
	// Position of CPU_FREQ_BOOST field.
	SYSCFG_UR18_CPU_FREQ_BOOST_Pos = 0x0
	// Bit mask of CPU_FREQ_BOOST field.
	SYSCFG_UR18_CPU_FREQ_BOOST_Msk = 0x1
	// Bit CPU_FREQ_BOOST.
	SYSCFG_UR18_CPU_FREQ_BOOST = 0x1
)

// Constants for TIM1: Advanced-timers
const (
	// CR1: control register 1
	// Position of CEN field.
	TIM_CR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIM_CR1_CEN_Msk = 0x1
	// Bit CEN.
	TIM_CR1_CEN = 0x1
	// Counter disabled
	TIM_CR1_CEN_Disabled = 0x0
	// Counter enabled
	TIM_CR1_CEN_Enabled = 0x1
	// Position of UDIS field.
	TIM_CR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIM_CR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIM_CR1_UDIS = 0x2
	// Update event enabled
	TIM_CR1_UDIS_Enabled = 0x0
	// Update event disabled
	TIM_CR1_UDIS_Disabled = 0x1
	// Position of URS field.
	TIM_CR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIM_CR1_URS_Msk = 0x4
	// Bit URS.
	TIM_CR1_URS = 0x4
	// Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
	TIM_CR1_URS_AnyEvent = 0x0
	// Only counter overflow/underflow generates an update interrupt or DMA request
	TIM_CR1_URS_CounterOnly = 0x1
	// Position of OPM field.
	TIM_CR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIM_CR1_OPM_Msk = 0x8
	// Bit OPM.
	TIM_CR1_OPM = 0x8
	// Counter is not stopped at update event
	TIM_CR1_OPM_Disabled = 0x0
	// Counter stops counting at the next update event (clearing the CEN bit)
	TIM_CR1_OPM_Enabled = 0x1
	// Position of DIR field.
	TIM_CR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	TIM_CR1_DIR_Msk = 0x10
	// Bit DIR.
	TIM_CR1_DIR = 0x10
	// Counter used as upcounter
	TIM_CR1_DIR_Up = 0x0
	// Counter used as downcounter
	TIM_CR1_DIR_Down = 0x1
	// Position of CMS field.
	TIM_CR1_CMS_Pos = 0x5
	// Bit mask of CMS field.
	TIM_CR1_CMS_Msk = 0x60
	// The counter counts up or down depending on the direction bit
	TIM_CR1_CMS_EdgeAligned = 0x0
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
	TIM_CR1_CMS_CenterAligned1 = 0x1
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
	TIM_CR1_CMS_CenterAligned2 = 0x2
	// The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
	TIM_CR1_CMS_CenterAligned3 = 0x3
	// Position of ARPE field.
	TIM_CR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIM_CR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIM_CR1_ARPE = 0x80
	// TIMx_APRR register is not buffered
	TIM_CR1_ARPE_Disabled = 0x0
	// TIMx_APRR register is buffered
	TIM_CR1_ARPE_Enabled = 0x1
	// Position of CKD field.
	TIM_CR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIM_CR1_CKD_Msk = 0x300
	// t_DTS = t_CK_INT
	TIM_CR1_CKD_Div1 = 0x0
	// t_DTS = 2  t_CK_INT
	TIM_CR1_CKD_Div2 = 0x1
	// t_DTS = 4  t_CK_INT
	TIM_CR1_CKD_Div4 = 0x2
	// Position of UIFREMAP field.
	TIM_CR1_UIFREMAP_Pos = 0xb
	// Bit mask of UIFREMAP field.
	TIM_CR1_UIFREMAP_Msk = 0x800
	// Bit UIFREMAP.
	TIM_CR1_UIFREMAP = 0x800

	// CR2: control register 2
	// Position of MMS2 field.
	TIM_CR2_MMS2_Pos = 0x14
	// Bit mask of MMS2 field.
	TIM_CR2_MMS2_Msk = 0xf00000
	// Position of OIS6 field.
	TIM_CR2_OIS6_Pos = 0x12
	// Bit mask of OIS6 field.
	TIM_CR2_OIS6_Msk = 0x40000
	// Bit OIS6.
	TIM_CR2_OIS6 = 0x40000
	// Position of OIS5 field.
	TIM_CR2_OIS5_Pos = 0x10
	// Bit mask of OIS5 field.
	TIM_CR2_OIS5_Msk = 0x10000
	// Bit OIS5.
	TIM_CR2_OIS5 = 0x10000
	// Position of OIS4 field.
	TIM_CR2_OIS4_Pos = 0xe
	// Bit mask of OIS4 field.
	TIM_CR2_OIS4_Msk = 0x4000
	// Bit OIS4.
	TIM_CR2_OIS4 = 0x4000
	// Position of OIS3N field.
	TIM_CR2_OIS3N_Pos = 0xd
	// Bit mask of OIS3N field.
	TIM_CR2_OIS3N_Msk = 0x2000
	// Bit OIS3N.
	TIM_CR2_OIS3N = 0x2000
	// Position of OIS3 field.
	TIM_CR2_OIS3_Pos = 0xc
	// Bit mask of OIS3 field.
	TIM_CR2_OIS3_Msk = 0x1000
	// Bit OIS3.
	TIM_CR2_OIS3 = 0x1000
	// Position of OIS2N field.
	TIM_CR2_OIS2N_Pos = 0xb
	// Bit mask of OIS2N field.
	TIM_CR2_OIS2N_Msk = 0x800
	// Bit OIS2N.
	TIM_CR2_OIS2N = 0x800
	// Position of OIS2 field.
	TIM_CR2_OIS2_Pos = 0xa
	// Bit mask of OIS2 field.
	TIM_CR2_OIS2_Msk = 0x400
	// Bit OIS2.
	TIM_CR2_OIS2 = 0x400
	// Position of OIS1N field.
	TIM_CR2_OIS1N_Pos = 0x9
	// Bit mask of OIS1N field.
	TIM_CR2_OIS1N_Msk = 0x200
	// Bit OIS1N.
	TIM_CR2_OIS1N = 0x200
	// Position of OIS1 field.
	TIM_CR2_OIS1_Pos = 0x8
	// Bit mask of OIS1 field.
	TIM_CR2_OIS1_Msk = 0x100
	// Bit OIS1.
	TIM_CR2_OIS1 = 0x100
	// Position of TI1S field.
	TIM_CR2_TI1S_Pos = 0x7
	// Bit mask of TI1S field.
	TIM_CR2_TI1S_Msk = 0x80
	// Bit TI1S.
	TIM_CR2_TI1S = 0x80
	// The TIMx_CH1 pin is connected to TI1 input
	TIM_CR2_TI1S_Normal = 0x0
	// The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
	TIM_CR2_TI1S_XOR = 0x1
	// Position of MMS field.
	TIM_CR2_MMS_Pos = 0x4
	// Bit mask of MMS field.
	TIM_CR2_MMS_Msk = 0x70
	// The UG bit from the TIMx_EGR register is used as trigger output
	TIM_CR2_MMS_Reset = 0x0
	// The counter enable signal, CNT_EN, is used as trigger output
	TIM_CR2_MMS_Enable = 0x1
	// The update event is selected as trigger output
	TIM_CR2_MMS_Update = 0x2
	// The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
	TIM_CR2_MMS_ComparePulse = 0x3
	// OC1REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC1 = 0x4
	// OC2REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC2 = 0x5
	// OC3REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC3 = 0x6
	// OC4REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC4 = 0x7
	// Position of CCDS field.
	TIM_CR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIM_CR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIM_CR2_CCDS = 0x8
	// CCx DMA request sent when CCx event occurs
	TIM_CR2_CCDS_OnCompare = 0x0
	// CCx DMA request sent when update event occurs
	TIM_CR2_CCDS_OnUpdate = 0x1
	// Position of CCUS field.
	TIM_CR2_CCUS_Pos = 0x2
	// Bit mask of CCUS field.
	TIM_CR2_CCUS_Msk = 0x4
	// Bit CCUS.
	TIM_CR2_CCUS = 0x4
	// Position of CCPC field.
	TIM_CR2_CCPC_Pos = 0x0
	// Bit mask of CCPC field.
	TIM_CR2_CCPC_Msk = 0x1
	// Bit CCPC.
	TIM_CR2_CCPC = 0x1

	// SMCR: slave mode control register
	// Position of SMS field.
	TIM_SMCR_SMS_Pos = 0x0
	// Bit mask of SMS field.
	TIM_SMCR_SMS_Msk = 0x7
	// Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
	TIM_SMCR_SMS_Disabled = 0x0
	// Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
	TIM_SMCR_SMS_Encoder_Mode_1 = 0x1
	// Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
	TIM_SMCR_SMS_Encoder_Mode_2 = 0x2
	// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
	TIM_SMCR_SMS_Encoder_Mode_3 = 0x3
	// Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
	TIM_SMCR_SMS_Reset_Mode = 0x4
	// Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
	TIM_SMCR_SMS_Gated_Mode = 0x5
	// Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
	TIM_SMCR_SMS_Trigger_Mode = 0x6
	// External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
	TIM_SMCR_SMS_Ext_Clock_Mode = 0x7
	// Position of TS field.
	TIM_SMCR_TS_Pos = 0x4
	// Bit mask of TS field.
	TIM_SMCR_TS_Msk = 0x70
	// Internal Trigger 0 (ITR0)
	TIM_SMCR_TS_ITR0 = 0x0
	// Internal Trigger 1 (ITR1)
	TIM_SMCR_TS_ITR1 = 0x1
	// Internal Trigger 2 (ITR2)
	TIM_SMCR_TS_ITR2 = 0x2
	// TI1 Edge Detector (TI1F_ED)
	TIM_SMCR_TS_TI1F_ED = 0x4
	// Filtered Timer Input 1 (TI1FP1)
	TIM_SMCR_TS_TI1FP1 = 0x5
	// Filtered Timer Input 2 (TI2FP2)
	TIM_SMCR_TS_TI2FP2 = 0x6
	// External Trigger input (ETRF)
	TIM_SMCR_TS_ETRF = 0x7
	// Position of MSM field.
	TIM_SMCR_MSM_Pos = 0x7
	// Bit mask of MSM field.
	TIM_SMCR_MSM_Msk = 0x80
	// Bit MSM.
	TIM_SMCR_MSM = 0x80
	// No action
	TIM_SMCR_MSM_NoSync = 0x0
	// The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
	TIM_SMCR_MSM_Sync = 0x1
	// Position of ETF field.
	TIM_SMCR_ETF_Pos = 0x8
	// Bit mask of ETF field.
	TIM_SMCR_ETF_Msk = 0xf00
	// No filter, sampling is done at fDTS
	TIM_SMCR_ETF_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_SMCR_ETF_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_SMCR_ETF_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_SMCR_ETF_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_SMCR_ETF_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_SMCR_ETF_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_SMCR_ETF_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_SMCR_ETF_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_SMCR_ETF_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_SMCR_ETF_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_SMCR_ETF_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_SMCR_ETF_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_SMCR_ETF_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_SMCR_ETF_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_SMCR_ETF_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_SMCR_ETF_FDTS_Div32_N8 = 0xf
	// Position of ETPS field.
	TIM_SMCR_ETPS_Pos = 0xc
	// Bit mask of ETPS field.
	TIM_SMCR_ETPS_Msk = 0x3000
	// Prescaler OFF
	TIM_SMCR_ETPS_Div1 = 0x0
	// ETRP frequency divided by 2
	TIM_SMCR_ETPS_Div2 = 0x1
	// ETRP frequency divided by 4
	TIM_SMCR_ETPS_Div4 = 0x2
	// ETRP frequency divided by 8
	TIM_SMCR_ETPS_Div8 = 0x3
	// Position of ECE field.
	TIM_SMCR_ECE_Pos = 0xe
	// Bit mask of ECE field.
	TIM_SMCR_ECE_Msk = 0x4000
	// Bit ECE.
	TIM_SMCR_ECE = 0x4000
	// External clock mode 2 disabled
	TIM_SMCR_ECE_Disabled = 0x0
	// External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
	TIM_SMCR_ECE_Enabled = 0x1
	// Position of ETP field.
	TIM_SMCR_ETP_Pos = 0xf
	// Bit mask of ETP field.
	TIM_SMCR_ETP_Msk = 0x8000
	// Bit ETP.
	TIM_SMCR_ETP = 0x8000
	// ETR is noninverted, active at high level or rising edge
	TIM_SMCR_ETP_NotInverted = 0x0
	// ETR is inverted, active at low level or falling edge
	TIM_SMCR_ETP_Inverted = 0x1
	// Position of SMS_3 field.
	TIM_SMCR_SMS_3_Pos = 0x10
	// Bit mask of SMS_3 field.
	TIM_SMCR_SMS_3_Msk = 0x10000
	// Bit SMS_3.
	TIM_SMCR_SMS_3 = 0x10000
	// Position of TS_4_3 field.
	TIM_SMCR_TS_4_3_Pos = 0x14
	// Bit mask of TS_4_3 field.
	TIM_SMCR_TS_4_3_Msk = 0x300000

	// DIER: DMA/Interrupt enable register
	// Position of TDE field.
	TIM_DIER_TDE_Pos = 0xe
	// Bit mask of TDE field.
	TIM_DIER_TDE_Msk = 0x4000
	// Bit TDE.
	TIM_DIER_TDE = 0x4000
	// Trigger DMA request disabled
	TIM_DIER_TDE_Disabled = 0x0
	// Trigger DMA request enabled
	TIM_DIER_TDE_Enabled = 0x1
	// Position of COMDE field.
	TIM_DIER_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIM_DIER_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIM_DIER_COMDE = 0x2000
	// Position of CC4DE field.
	TIM_DIER_CC4DE_Pos = 0xc
	// Bit mask of CC4DE field.
	TIM_DIER_CC4DE_Msk = 0x1000
	// Bit CC4DE.
	TIM_DIER_CC4DE = 0x1000
	// CCx DMA request disabled
	TIM_DIER_CC4DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC4DE_Enabled = 0x1
	// Position of CC3DE field.
	TIM_DIER_CC3DE_Pos = 0xb
	// Bit mask of CC3DE field.
	TIM_DIER_CC3DE_Msk = 0x800
	// Bit CC3DE.
	TIM_DIER_CC3DE = 0x800
	// CCx DMA request disabled
	TIM_DIER_CC3DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC3DE_Enabled = 0x1
	// Position of CC2DE field.
	TIM_DIER_CC2DE_Pos = 0xa
	// Bit mask of CC2DE field.
	TIM_DIER_CC2DE_Msk = 0x400
	// Bit CC2DE.
	TIM_DIER_CC2DE = 0x400
	// CCx DMA request disabled
	TIM_DIER_CC2DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC2DE_Enabled = 0x1
	// Position of CC1DE field.
	TIM_DIER_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIM_DIER_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIM_DIER_CC1DE = 0x200
	// CCx DMA request disabled
	TIM_DIER_CC1DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC1DE_Enabled = 0x1
	// Position of UDE field.
	TIM_DIER_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIM_DIER_UDE_Msk = 0x100
	// Bit UDE.
	TIM_DIER_UDE = 0x100
	// Update DMA request disabled
	TIM_DIER_UDE_Disabled = 0x0
	// Update DMA request enabled
	TIM_DIER_UDE_Enabled = 0x1
	// Position of TIE field.
	TIM_DIER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	TIM_DIER_TIE_Msk = 0x40
	// Bit TIE.
	TIM_DIER_TIE = 0x40
	// Trigger interrupt disabled
	TIM_DIER_TIE_Disabled = 0x0
	// Trigger interrupt enabled
	TIM_DIER_TIE_Enabled = 0x1
	// Position of CC4IE field.
	TIM_DIER_CC4IE_Pos = 0x4
	// Bit mask of CC4IE field.
	TIM_DIER_CC4IE_Msk = 0x10
	// Bit CC4IE.
	TIM_DIER_CC4IE = 0x10
	// CCx interrupt disabled
	TIM_DIER_CC4IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC4IE_Enabled = 0x1
	// Position of CC3IE field.
	TIM_DIER_CC3IE_Pos = 0x3
	// Bit mask of CC3IE field.
	TIM_DIER_CC3IE_Msk = 0x8
	// Bit CC3IE.
	TIM_DIER_CC3IE = 0x8
	// CCx interrupt disabled
	TIM_DIER_CC3IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC3IE_Enabled = 0x1
	// Position of CC2IE field.
	TIM_DIER_CC2IE_Pos = 0x2
	// Bit mask of CC2IE field.
	TIM_DIER_CC2IE_Msk = 0x4
	// Bit CC2IE.
	TIM_DIER_CC2IE = 0x4
	// CCx interrupt disabled
	TIM_DIER_CC2IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC2IE_Enabled = 0x1
	// Position of CC1IE field.
	TIM_DIER_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIM_DIER_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIM_DIER_CC1IE = 0x2
	// CCx interrupt disabled
	TIM_DIER_CC1IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC1IE_Enabled = 0x1
	// Position of UIE field.
	TIM_DIER_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIM_DIER_UIE_Msk = 0x1
	// Bit UIE.
	TIM_DIER_UIE = 0x1
	// Update interrupt disabled
	TIM_DIER_UIE_Disabled = 0x0
	// Update interrupt enabled
	TIM_DIER_UIE_Enabled = 0x1
	// Position of BIE field.
	TIM_DIER_BIE_Pos = 0x7
	// Bit mask of BIE field.
	TIM_DIER_BIE_Msk = 0x80
	// Bit BIE.
	TIM_DIER_BIE = 0x80
	// Position of COMIE field.
	TIM_DIER_COMIE_Pos = 0x5
	// Bit mask of COMIE field.
	TIM_DIER_COMIE_Msk = 0x20
	// Bit COMIE.
	TIM_DIER_COMIE = 0x20

	// SR: status register
	// Position of CC6IF field.
	TIM_SR_CC6IF_Pos = 0x11
	// Bit mask of CC6IF field.
	TIM_SR_CC6IF_Msk = 0x20000
	// Bit CC6IF.
	TIM_SR_CC6IF = 0x20000
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC6IF_Match = 0x1
	// Clear flag
	TIM_SR_CC6IF_Clear = 0x0
	// Position of CC5IF field.
	TIM_SR_CC5IF_Pos = 0x10
	// Bit mask of CC5IF field.
	TIM_SR_CC5IF_Msk = 0x10000
	// Bit CC5IF.
	TIM_SR_CC5IF = 0x10000
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC5IF_Match = 0x1
	// Clear flag
	TIM_SR_CC5IF_Clear = 0x0
	// Position of SBIF field.
	TIM_SR_SBIF_Pos = 0xd
	// Bit mask of SBIF field.
	TIM_SR_SBIF_Msk = 0x2000
	// Bit SBIF.
	TIM_SR_SBIF = 0x2000
	// Position of CC4OF field.
	TIM_SR_CC4OF_Pos = 0xc
	// Bit mask of CC4OF field.
	TIM_SR_CC4OF_Msk = 0x1000
	// Bit CC4OF.
	TIM_SR_CC4OF = 0x1000
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC4OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC4OF_Clear = 0x0
	// Position of CC3OF field.
	TIM_SR_CC3OF_Pos = 0xb
	// Bit mask of CC3OF field.
	TIM_SR_CC3OF_Msk = 0x800
	// Bit CC3OF.
	TIM_SR_CC3OF = 0x800
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC3OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC3OF_Clear = 0x0
	// Position of CC2OF field.
	TIM_SR_CC2OF_Pos = 0xa
	// Bit mask of CC2OF field.
	TIM_SR_CC2OF_Msk = 0x400
	// Bit CC2OF.
	TIM_SR_CC2OF = 0x400
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC2OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC2OF_Clear = 0x0
	// Position of CC1OF field.
	TIM_SR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIM_SR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIM_SR_CC1OF = 0x200
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC1OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC1OF_Clear = 0x0
	// Position of B2IF field.
	TIM_SR_B2IF_Pos = 0x8
	// Bit mask of B2IF field.
	TIM_SR_B2IF_Msk = 0x100
	// Bit B2IF.
	TIM_SR_B2IF = 0x100
	// Position of BIF field.
	TIM_SR_BIF_Pos = 0x7
	// Bit mask of BIF field.
	TIM_SR_BIF_Msk = 0x80
	// Bit BIF.
	TIM_SR_BIF = 0x80
	// Position of TIF field.
	TIM_SR_TIF_Pos = 0x6
	// Bit mask of TIF field.
	TIM_SR_TIF_Msk = 0x40
	// Bit TIF.
	TIM_SR_TIF = 0x40
	// No trigger event occurred
	TIM_SR_TIF_NoTrigger = 0x0
	// Trigger interrupt pending
	TIM_SR_TIF_Trigger = 0x1
	// Clear flag
	TIM_SR_TIF_Clear = 0x0
	// Position of COMIF field.
	TIM_SR_COMIF_Pos = 0x5
	// Bit mask of COMIF field.
	TIM_SR_COMIF_Msk = 0x20
	// Bit COMIF.
	TIM_SR_COMIF = 0x20
	// Position of CC4IF field.
	TIM_SR_CC4IF_Pos = 0x4
	// Bit mask of CC4IF field.
	TIM_SR_CC4IF_Msk = 0x10
	// Bit CC4IF.
	TIM_SR_CC4IF = 0x10
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC4IF_Match = 0x1
	// Clear flag
	TIM_SR_CC4IF_Clear = 0x0
	// Position of CC3IF field.
	TIM_SR_CC3IF_Pos = 0x3
	// Bit mask of CC3IF field.
	TIM_SR_CC3IF_Msk = 0x8
	// Bit CC3IF.
	TIM_SR_CC3IF = 0x8
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC3IF_Match = 0x1
	// Clear flag
	TIM_SR_CC3IF_Clear = 0x0
	// Position of CC2IF field.
	TIM_SR_CC2IF_Pos = 0x2
	// Bit mask of CC2IF field.
	TIM_SR_CC2IF_Msk = 0x4
	// Bit CC2IF.
	TIM_SR_CC2IF = 0x4
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC2IF_Match = 0x1
	// Clear flag
	TIM_SR_CC2IF_Clear = 0x0
	// Position of CC1IF field.
	TIM_SR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIM_SR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIM_SR_CC1IF = 0x2
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC1IF_Match = 0x1
	// Clear flag
	TIM_SR_CC1IF_Clear = 0x0
	// Position of UIF field.
	TIM_SR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIM_SR_UIF_Msk = 0x1
	// Bit UIF.
	TIM_SR_UIF = 0x1
	// No update occurred
	TIM_SR_UIF_Clear = 0x0
	// Update interrupt pending.
	TIM_SR_UIF_UpdatePending = 0x1

	// EGR: event generation register
	// Position of UG field.
	TIM_EGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIM_EGR_UG_Msk = 0x1
	// Bit UG.
	TIM_EGR_UG = 0x1
	// Re-initializes the timer counter and generates an update of the registers.
	TIM_EGR_UG_Update = 0x1
	// Position of CC1G field.
	TIM_EGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIM_EGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIM_EGR_CC1G = 0x2
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC1G_Trigger = 0x1
	// Position of CC2G field.
	TIM_EGR_CC2G_Pos = 0x2
	// Bit mask of CC2G field.
	TIM_EGR_CC2G_Msk = 0x4
	// Bit CC2G.
	TIM_EGR_CC2G = 0x4
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC2G_Trigger = 0x1
	// Position of CC3G field.
	TIM_EGR_CC3G_Pos = 0x3
	// Bit mask of CC3G field.
	TIM_EGR_CC3G_Msk = 0x8
	// Bit CC3G.
	TIM_EGR_CC3G = 0x8
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC3G_Trigger = 0x1
	// Position of CC4G field.
	TIM_EGR_CC4G_Pos = 0x4
	// Bit mask of CC4G field.
	TIM_EGR_CC4G_Msk = 0x10
	// Bit CC4G.
	TIM_EGR_CC4G = 0x10
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC4G_Trigger = 0x1
	// Position of COMG field.
	TIM_EGR_COMG_Pos = 0x5
	// Bit mask of COMG field.
	TIM_EGR_COMG_Msk = 0x20
	// Bit COMG.
	TIM_EGR_COMG = 0x20
	// Position of TG field.
	TIM_EGR_TG_Pos = 0x6
	// Bit mask of TG field.
	TIM_EGR_TG_Msk = 0x40
	// Bit TG.
	TIM_EGR_TG = 0x40
	// The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
	TIM_EGR_TG_Trigger = 0x1
	// Position of BG field.
	TIM_EGR_BG_Pos = 0x7
	// Bit mask of BG field.
	TIM_EGR_BG_Msk = 0x80
	// Bit BG.
	TIM_EGR_BG = 0x80
	// Position of B2G field.
	TIM_EGR_B2G_Pos = 0x8
	// Bit mask of B2G field.
	TIM_EGR_B2G_Msk = 0x100
	// Bit B2G.
	TIM_EGR_B2G = 0x100

	// CCMR1_Output: capture/compare mode register 1 (output mode)
	// Position of CC1S field.
	TIM_CCMR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Output_CC1S_Msk = 0x3
	// CC1 channel is configured as output
	TIM_CCMR1_Output_CC1S_Output = 0x0
	// Position of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIM_CCMR1_Output_OC1FE = 0x4
	// Position of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIM_CCMR1_Output_OC1PE = 0x8
	// Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
	TIM_CCMR1_Output_OC1PE_Disabled = 0x0
	// Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC1PE_Enabled = 0x1
	// Position of OC1M field.
	TIM_CCMR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIM_CCMR1_Output_OC1M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC1M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC1M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC1M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC1M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC1M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC1M_PwmMode2 = 0x7
	// Position of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Pos = 0x7
	// Bit mask of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Msk = 0x80
	// Bit OC1CE.
	TIM_CCMR1_Output_OC1CE = 0x80
	// Position of CC2S field.
	TIM_CCMR1_Output_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Output_CC2S_Msk = 0x300
	// CC2 channel is configured as output
	TIM_CCMR1_Output_CC2S_Output = 0x0
	// Position of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Pos = 0xa
	// Bit mask of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Msk = 0x400
	// Bit OC2FE.
	TIM_CCMR1_Output_OC2FE = 0x400
	// Position of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Pos = 0xb
	// Bit mask of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Msk = 0x800
	// Bit OC2PE.
	TIM_CCMR1_Output_OC2PE = 0x800
	// Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
	TIM_CCMR1_Output_OC2PE_Disabled = 0x0
	// Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC2PE_Enabled = 0x1
	// Position of OC2M field.
	TIM_CCMR1_Output_OC2M_Pos = 0xc
	// Bit mask of OC2M field.
	TIM_CCMR1_Output_OC2M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC2M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC2M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC2M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC2M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC2M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC2M_PwmMode2 = 0x7
	// Position of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Pos = 0xf
	// Bit mask of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Msk = 0x8000
	// Bit OC2CE.
	TIM_CCMR1_Output_OC2CE = 0x8000
	// Position of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Pos = 0x10
	// Bit mask of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Msk = 0x10000
	// Bit OC1M_3.
	TIM_CCMR1_Output_OC1M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC1M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC1M_3_Extended = 0x1
	// Position of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Pos = 0x18
	// Bit mask of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Msk = 0x1000000
	// Bit OC2M_3.
	TIM_CCMR1_Output_OC2M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC2M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC2M_3_Extended = 0x1

	// CCMR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC2F field.
	TIM_CCMR1_Input_IC2F_Pos = 0xc
	// Bit mask of IC2F field.
	TIM_CCMR1_Input_IC2F_Msk = 0xf000
	// Position of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Pos = 0xa
	// Bit mask of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Msk = 0xc00
	// Position of CC2S field.
	TIM_CCMR1_Input_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Input_CC2S_Msk = 0x300
	// CC2 channel is configured as input, IC2 is mapped on TI2
	TIM_CCMR1_Input_CC2S_TI2 = 0x1
	// CC2 channel is configured as input, IC2 is mapped on TI1
	TIM_CCMR1_Input_CC2S_TI1 = 0x2
	// CC2 channel is configured as input, IC2 is mapped on TRC
	TIM_CCMR1_Input_CC2S_TRC = 0x3
	// Position of IC1F field.
	TIM_CCMR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIM_CCMR1_Input_IC1F_Msk = 0xf0
	// No filter, sampling is done at fDTS
	TIM_CCMR1_Input_IC1F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR1_Input_IC1F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR1_Input_IC1F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR1_Input_IC1F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N8 = 0xf
	// Position of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Msk = 0xc
	// Position of CC1S field.
	TIM_CCMR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Input_CC1S_Msk = 0x3
	// CC1 channel is configured as input, IC1 is mapped on TI1
	TIM_CCMR1_Input_CC1S_TI1 = 0x1
	// CC1 channel is configured as input, IC1 is mapped on TI2
	TIM_CCMR1_Input_CC1S_TI2 = 0x2
	// CC1 channel is configured as input, IC1 is mapped on TRC
	TIM_CCMR1_Input_CC1S_TRC = 0x3

	// CCMR2_Output: capture/compare mode register 2 (output mode)
	// Position of CC3S field.
	TIM_CCMR2_Output_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Output_CC3S_Msk = 0x3
	// CC3 channel is configured as output
	TIM_CCMR2_Output_CC3S_Output = 0x0
	// Position of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Pos = 0x2
	// Bit mask of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Msk = 0x4
	// Bit OC3FE.
	TIM_CCMR2_Output_OC3FE = 0x4
	// Position of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Pos = 0x3
	// Bit mask of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Msk = 0x8
	// Bit OC3PE.
	TIM_CCMR2_Output_OC3PE = 0x8
	// Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
	TIM_CCMR2_Output_OC3PE_Disabled = 0x0
	// Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC3PE_Enabled = 0x1
	// Position of OC3M field.
	TIM_CCMR2_Output_OC3M_Pos = 0x4
	// Bit mask of OC3M field.
	TIM_CCMR2_Output_OC3M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC3M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC3M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC3M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC3M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC3M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC3M_PwmMode2 = 0x7
	// Position of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Pos = 0x7
	// Bit mask of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Msk = 0x80
	// Bit OC3CE.
	TIM_CCMR2_Output_OC3CE = 0x80
	// Position of CC4S field.
	TIM_CCMR2_Output_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Output_CC4S_Msk = 0x300
	// CC4 channel is configured as output
	TIM_CCMR2_Output_CC4S_Output = 0x0
	// Position of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Pos = 0xa
	// Bit mask of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Msk = 0x400
	// Bit OC4FE.
	TIM_CCMR2_Output_OC4FE = 0x400
	// Position of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Pos = 0xb
	// Bit mask of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Msk = 0x800
	// Bit OC4PE.
	TIM_CCMR2_Output_OC4PE = 0x800
	// Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
	TIM_CCMR2_Output_OC4PE_Disabled = 0x0
	// Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC4PE_Enabled = 0x1
	// Position of OC4M field.
	TIM_CCMR2_Output_OC4M_Pos = 0xc
	// Bit mask of OC4M field.
	TIM_CCMR2_Output_OC4M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC4M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC4M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC4M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC4M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC4M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC4M_PwmMode2 = 0x7
	// Position of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Pos = 0xf
	// Bit mask of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Msk = 0x8000
	// Bit OC4CE.
	TIM_CCMR2_Output_OC4CE = 0x8000
	// Position of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Pos = 0x10
	// Bit mask of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Msk = 0x10000
	// Bit OC3M_3.
	TIM_CCMR2_Output_OC3M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC3M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC3M_3_Extended = 0x1
	// Position of OC4M_4 field.
	TIM_CCMR2_Output_OC4M_4_Pos = 0x18
	// Bit mask of OC4M_4 field.
	TIM_CCMR2_Output_OC4M_4_Msk = 0x1000000
	// Bit OC4M_4.
	TIM_CCMR2_Output_OC4M_4 = 0x1000000

	// CCMR2_Input: capture/compare mode register 2 (input mode)
	// Position of IC4F field.
	TIM_CCMR2_Input_IC4F_Pos = 0xc
	// Bit mask of IC4F field.
	TIM_CCMR2_Input_IC4F_Msk = 0xf000
	// Position of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Pos = 0xa
	// Bit mask of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Msk = 0xc00
	// Position of CC4S field.
	TIM_CCMR2_Input_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Input_CC4S_Msk = 0x300
	// CC4 channel is configured as input, IC4 is mapped on TI4
	TIM_CCMR2_Input_CC4S_TI4 = 0x1
	// CC4 channel is configured as input, IC4 is mapped on TI3
	TIM_CCMR2_Input_CC4S_TI3 = 0x2
	// CC4 channel is configured as input, IC4 is mapped on TRC
	TIM_CCMR2_Input_CC4S_TRC = 0x3
	// Position of IC3F field.
	TIM_CCMR2_Input_IC3F_Pos = 0x4
	// Bit mask of IC3F field.
	TIM_CCMR2_Input_IC3F_Msk = 0xf0
	// Position of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Pos = 0x2
	// Bit mask of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Msk = 0xc
	// Position of CC3S field.
	TIM_CCMR2_Input_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Input_CC3S_Msk = 0x3
	// CC3 channel is configured as input, IC3 is mapped on TI3
	TIM_CCMR2_Input_CC3S_TI3 = 0x1
	// CC3 channel is configured as input, IC3 is mapped on TI4
	TIM_CCMR2_Input_CC3S_TI4 = 0x2
	// CC3 channel is configured as input, IC3 is mapped on TRC
	TIM_CCMR2_Input_CC3S_TRC = 0x3

	// CCER: capture/compare enable register
	// Position of CC1E field.
	TIM_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIM_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIM_CCER_CC1E = 0x1
	// Position of CC1P field.
	TIM_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIM_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIM_CCER_CC1P = 0x2
	// Position of CC1NE field.
	TIM_CCER_CC1NE_Pos = 0x2
	// Bit mask of CC1NE field.
	TIM_CCER_CC1NE_Msk = 0x4
	// Bit CC1NE.
	TIM_CCER_CC1NE = 0x4
	// Position of CC1NP field.
	TIM_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIM_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIM_CCER_CC1NP = 0x8
	// Position of CC2E field.
	TIM_CCER_CC2E_Pos = 0x4
	// Bit mask of CC2E field.
	TIM_CCER_CC2E_Msk = 0x10
	// Bit CC2E.
	TIM_CCER_CC2E = 0x10
	// Position of CC2P field.
	TIM_CCER_CC2P_Pos = 0x5
	// Bit mask of CC2P field.
	TIM_CCER_CC2P_Msk = 0x20
	// Bit CC2P.
	TIM_CCER_CC2P = 0x20
	// Position of CC2NE field.
	TIM_CCER_CC2NE_Pos = 0x6
	// Bit mask of CC2NE field.
	TIM_CCER_CC2NE_Msk = 0x40
	// Bit CC2NE.
	TIM_CCER_CC2NE = 0x40
	// Position of CC2NP field.
	TIM_CCER_CC2NP_Pos = 0x7
	// Bit mask of CC2NP field.
	TIM_CCER_CC2NP_Msk = 0x80
	// Bit CC2NP.
	TIM_CCER_CC2NP = 0x80
	// Position of CC3E field.
	TIM_CCER_CC3E_Pos = 0x8
	// Bit mask of CC3E field.
	TIM_CCER_CC3E_Msk = 0x100
	// Bit CC3E.
	TIM_CCER_CC3E = 0x100
	// Position of CC3P field.
	TIM_CCER_CC3P_Pos = 0x9
	// Bit mask of CC3P field.
	TIM_CCER_CC3P_Msk = 0x200
	// Bit CC3P.
	TIM_CCER_CC3P = 0x200
	// Position of CC3NE field.
	TIM_CCER_CC3NE_Pos = 0xa
	// Bit mask of CC3NE field.
	TIM_CCER_CC3NE_Msk = 0x400
	// Bit CC3NE.
	TIM_CCER_CC3NE = 0x400
	// Position of CC3NP field.
	TIM_CCER_CC3NP_Pos = 0xb
	// Bit mask of CC3NP field.
	TIM_CCER_CC3NP_Msk = 0x800
	// Bit CC3NP.
	TIM_CCER_CC3NP = 0x800
	// Position of CC4E field.
	TIM_CCER_CC4E_Pos = 0xc
	// Bit mask of CC4E field.
	TIM_CCER_CC4E_Msk = 0x1000
	// Bit CC4E.
	TIM_CCER_CC4E = 0x1000
	// Position of CC4P field.
	TIM_CCER_CC4P_Pos = 0xd
	// Bit mask of CC4P field.
	TIM_CCER_CC4P_Msk = 0x2000
	// Bit CC4P.
	TIM_CCER_CC4P = 0x2000
	// Position of CC4NP field.
	TIM_CCER_CC4NP_Pos = 0xf
	// Bit mask of CC4NP field.
	TIM_CCER_CC4NP_Msk = 0x8000
	// Bit CC4NP.
	TIM_CCER_CC4NP = 0x8000
	// Position of CC5E field.
	TIM_CCER_CC5E_Pos = 0x10
	// Bit mask of CC5E field.
	TIM_CCER_CC5E_Msk = 0x10000
	// Bit CC5E.
	TIM_CCER_CC5E = 0x10000
	// Position of CC5P field.
	TIM_CCER_CC5P_Pos = 0x11
	// Bit mask of CC5P field.
	TIM_CCER_CC5P_Msk = 0x20000
	// Bit CC5P.
	TIM_CCER_CC5P = 0x20000
	// Position of CC6E field.
	TIM_CCER_CC6E_Pos = 0x14
	// Bit mask of CC6E field.
	TIM_CCER_CC6E_Msk = 0x100000
	// Bit CC6E.
	TIM_CCER_CC6E = 0x100000
	// Position of CC6P field.
	TIM_CCER_CC6P_Pos = 0x15
	// Bit mask of CC6P field.
	TIM_CCER_CC6P_Msk = 0x200000
	// Bit CC6P.
	TIM_CCER_CC6P = 0x200000

	// CNT: counter
	// Position of CNT field.
	TIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIM_CNT_CNT_Msk = 0xffff
	// Position of UIFCPY field.
	TIM_CNT_UIFCPY_Pos = 0x1f
	// Bit mask of UIFCPY field.
	TIM_CNT_UIFCPY_Msk = 0x80000000
	// Bit UIFCPY.
	TIM_CNT_UIFCPY = 0x80000000

	// PSC: prescaler
	// Position of PSC field.
	TIM_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIM_PSC_PSC_Msk = 0xffff

	// ARR: auto-reload register
	// Position of ARR field.
	TIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	TIM_ARR_ARR_Msk = 0xffff

	// RCR: repetition counter register
	// Position of REP field.
	TIM_RCR_REP_Pos = 0x0
	// Bit mask of REP field.
	TIM_RCR_REP_Msk = 0xff

	// CCR1: capture/compare register
	// Position of CCR field.
	TIM_CCR_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIM_CCR_CCR_Msk = 0xffff

	// BDTR: break and dead-time register
	// Position of DTG field.
	TIM_BDTR_DTG_Pos = 0x0
	// Bit mask of DTG field.
	TIM_BDTR_DTG_Msk = 0xff
	// Position of LOCK field.
	TIM_BDTR_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	TIM_BDTR_LOCK_Msk = 0x300
	// Position of OSSI field.
	TIM_BDTR_OSSI_Pos = 0xa
	// Bit mask of OSSI field.
	TIM_BDTR_OSSI_Msk = 0x400
	// Bit OSSI.
	TIM_BDTR_OSSI = 0x400
	// When inactive, OC/OCN outputs are disabled
	TIM_BDTR_OSSI_Disabled = 0x0
	// When inactive, OC/OCN outputs are forced to idle level
	TIM_BDTR_OSSI_IdleLevel = 0x1
	// Position of OSSR field.
	TIM_BDTR_OSSR_Pos = 0xb
	// Bit mask of OSSR field.
	TIM_BDTR_OSSR_Msk = 0x800
	// Bit OSSR.
	TIM_BDTR_OSSR = 0x800
	// When inactive, OC/OCN outputs are disabled
	TIM_BDTR_OSSR_Disabled = 0x0
	// When inactive, OC/OCN outputs are enabled with their inactive level
	TIM_BDTR_OSSR_IdleLevel = 0x1
	// Position of BKE field.
	TIM_BDTR_BKE_Pos = 0xc
	// Bit mask of BKE field.
	TIM_BDTR_BKE_Msk = 0x1000
	// Bit BKE.
	TIM_BDTR_BKE = 0x1000
	// Position of BKP field.
	TIM_BDTR_BKP_Pos = 0xd
	// Bit mask of BKP field.
	TIM_BDTR_BKP_Msk = 0x2000
	// Bit BKP.
	TIM_BDTR_BKP = 0x2000
	// Position of AOE field.
	TIM_BDTR_AOE_Pos = 0xe
	// Bit mask of AOE field.
	TIM_BDTR_AOE_Msk = 0x4000
	// Bit AOE.
	TIM_BDTR_AOE = 0x4000
	// Position of MOE field.
	TIM_BDTR_MOE_Pos = 0xf
	// Bit mask of MOE field.
	TIM_BDTR_MOE_Msk = 0x8000
	// Bit MOE.
	TIM_BDTR_MOE = 0x8000
	// OC/OCN are disabled or forced idle depending on OSSI
	TIM_BDTR_MOE_DisabledIdle = 0x0
	// OC/OCN are enabled if CCxE/CCxNE are set
	TIM_BDTR_MOE_Enabled = 0x1
	// Position of BKF field.
	TIM_BDTR_BKF_Pos = 0x10
	// Bit mask of BKF field.
	TIM_BDTR_BKF_Msk = 0xf0000
	// Position of BK2F field.
	TIM_BDTR_BK2F_Pos = 0x14
	// Bit mask of BK2F field.
	TIM_BDTR_BK2F_Msk = 0xf00000
	// Position of BK2E field.
	TIM_BDTR_BK2E_Pos = 0x18
	// Bit mask of BK2E field.
	TIM_BDTR_BK2E_Msk = 0x1000000
	// Bit BK2E.
	TIM_BDTR_BK2E = 0x1000000
	// Position of BK2P field.
	TIM_BDTR_BK2P_Pos = 0x19
	// Bit mask of BK2P field.
	TIM_BDTR_BK2P_Msk = 0x2000000
	// Bit BK2P.
	TIM_BDTR_BK2P = 0x2000000

	// DCR: DMA control register
	// Position of DBL field.
	TIM_DCR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIM_DCR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIM_DCR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIM_DCR_DBA_Msk = 0x1f

	// DMAR: DMA address for full transfer
	// Position of DMAB field.
	TIM_DMAR_DMAB_Pos = 0x0
	// Bit mask of DMAB field.
	TIM_DMAR_DMAB_Msk = 0xffff

	// CCMR3_Output: capture/compare mode register 3 (output mode)
	// Position of OC5FE field.
	TIM_CCMR3_Output_OC5FE_Pos = 0x2
	// Bit mask of OC5FE field.
	TIM_CCMR3_Output_OC5FE_Msk = 0x4
	// Bit OC5FE.
	TIM_CCMR3_Output_OC5FE = 0x4
	// Position of OC5PE field.
	TIM_CCMR3_Output_OC5PE_Pos = 0x3
	// Bit mask of OC5PE field.
	TIM_CCMR3_Output_OC5PE_Msk = 0x8
	// Bit OC5PE.
	TIM_CCMR3_Output_OC5PE = 0x8
	// Position of OC5M field.
	TIM_CCMR3_Output_OC5M_Pos = 0x4
	// Bit mask of OC5M field.
	TIM_CCMR3_Output_OC5M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR3_Output_OC5M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR3_Output_OC5M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR3_Output_OC5M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR3_Output_OC5M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR3_Output_OC5M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR3_Output_OC5M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR3_Output_OC5M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR3_Output_OC5M_PwmMode2 = 0x7
	// Position of OC5CE field.
	TIM_CCMR3_Output_OC5CE_Pos = 0x7
	// Bit mask of OC5CE field.
	TIM_CCMR3_Output_OC5CE_Msk = 0x80
	// Bit OC5CE.
	TIM_CCMR3_Output_OC5CE = 0x80
	// Position of OC6FE field.
	TIM_CCMR3_Output_OC6FE_Pos = 0xa
	// Bit mask of OC6FE field.
	TIM_CCMR3_Output_OC6FE_Msk = 0x400
	// Bit OC6FE.
	TIM_CCMR3_Output_OC6FE = 0x400
	// Position of OC6PE field.
	TIM_CCMR3_Output_OC6PE_Pos = 0xb
	// Bit mask of OC6PE field.
	TIM_CCMR3_Output_OC6PE_Msk = 0x800
	// Bit OC6PE.
	TIM_CCMR3_Output_OC6PE = 0x800
	// Position of OC6M field.
	TIM_CCMR3_Output_OC6M_Pos = 0xc
	// Bit mask of OC6M field.
	TIM_CCMR3_Output_OC6M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR3_Output_OC6M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR3_Output_OC6M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR3_Output_OC6M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR3_Output_OC6M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR3_Output_OC6M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR3_Output_OC6M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR3_Output_OC6M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR3_Output_OC6M_PwmMode2 = 0x7
	// Position of OC6CE field.
	TIM_CCMR3_Output_OC6CE_Pos = 0xf
	// Bit mask of OC6CE field.
	TIM_CCMR3_Output_OC6CE_Msk = 0x8000
	// Bit OC6CE.
	TIM_CCMR3_Output_OC6CE = 0x8000
	// Position of OC5M_3 field.
	TIM_CCMR3_Output_OC5M_3_Pos = 0x10
	// Bit mask of OC5M_3 field.
	TIM_CCMR3_Output_OC5M_3_Msk = 0x10000
	// Bit OC5M_3.
	TIM_CCMR3_Output_OC5M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR3_Output_OC5M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR3_Output_OC5M_3_Extended = 0x1
	// Position of OC6M_3 field.
	TIM_CCMR3_Output_OC6M_3_Pos = 0x18
	// Bit mask of OC6M_3 field.
	TIM_CCMR3_Output_OC6M_3_Msk = 0x1000000
	// Bit OC6M_3.
	TIM_CCMR3_Output_OC6M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR3_Output_OC6M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR3_Output_OC6M_3_Extended = 0x1

	// CCR5: capture/compare register
	// Position of CCR field.
	TIM_CCR5_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIM_CCR5_CCR_Msk = 0xffff
	// Position of GC5C1 field.
	TIM_CCR5_GC5C1_Pos = 0x1d
	// Bit mask of GC5C1 field.
	TIM_CCR5_GC5C1_Msk = 0x20000000
	// Bit GC5C1.
	TIM_CCR5_GC5C1 = 0x20000000
	// Position of GC5C2 field.
	TIM_CCR5_GC5C2_Pos = 0x1e
	// Bit mask of GC5C2 field.
	TIM_CCR5_GC5C2_Msk = 0x40000000
	// Bit GC5C2.
	TIM_CCR5_GC5C2 = 0x40000000
	// Position of GC5C3 field.
	TIM_CCR5_GC5C3_Pos = 0x1f
	// Bit mask of GC5C3 field.
	TIM_CCR5_GC5C3_Msk = 0x80000000
	// Bit GC5C3.
	TIM_CCR5_GC5C3 = 0x80000000

	// CRR6: capture/compare register 6
	// Position of CCR6 field.
	TIM_CRR6_CCR6_Pos = 0x0
	// Bit mask of CCR6 field.
	TIM_CRR6_CCR6_Msk = 0xffff

	// AF1: TIM1 alternate function option register 1
	// Position of BKINE field.
	TIM_AF1_BKINE_Pos = 0x0
	// Bit mask of BKINE field.
	TIM_AF1_BKINE_Msk = 0x1
	// Bit BKINE.
	TIM_AF1_BKINE = 0x1
	// Position of BKCMP1E field.
	TIM_AF1_BKCMP1E_Pos = 0x1
	// Bit mask of BKCMP1E field.
	TIM_AF1_BKCMP1E_Msk = 0x2
	// Bit BKCMP1E.
	TIM_AF1_BKCMP1E = 0x2
	// Position of BKCMP2E field.
	TIM_AF1_BKCMP2E_Pos = 0x2
	// Bit mask of BKCMP2E field.
	TIM_AF1_BKCMP2E_Msk = 0x4
	// Bit BKCMP2E.
	TIM_AF1_BKCMP2E = 0x4
	// Position of BKDF1BK0E field.
	TIM_AF1_BKDF1BK0E_Pos = 0x8
	// Bit mask of BKDF1BK0E field.
	TIM_AF1_BKDF1BK0E_Msk = 0x100
	// Bit BKDF1BK0E.
	TIM_AF1_BKDF1BK0E = 0x100
	// Position of BKINP field.
	TIM_AF1_BKINP_Pos = 0x9
	// Bit mask of BKINP field.
	TIM_AF1_BKINP_Msk = 0x200
	// Bit BKINP.
	TIM_AF1_BKINP = 0x200
	// Position of BKCMP1P field.
	TIM_AF1_BKCMP1P_Pos = 0xa
	// Bit mask of BKCMP1P field.
	TIM_AF1_BKCMP1P_Msk = 0x400
	// Bit BKCMP1P.
	TIM_AF1_BKCMP1P = 0x400
	// Position of BKCMP2P field.
	TIM_AF1_BKCMP2P_Pos = 0xb
	// Bit mask of BKCMP2P field.
	TIM_AF1_BKCMP2P_Msk = 0x800
	// Bit BKCMP2P.
	TIM_AF1_BKCMP2P = 0x800
	// Position of ETRSEL field.
	TIM_AF1_ETRSEL_Pos = 0xe
	// Bit mask of ETRSEL field.
	TIM_AF1_ETRSEL_Msk = 0x3c000

	// AF2: TIM1 Alternate function odfsdm1_breakster 2
	// Position of BK2INE field.
	TIM_AF2_BK2INE_Pos = 0x0
	// Bit mask of BK2INE field.
	TIM_AF2_BK2INE_Msk = 0x1
	// Bit BK2INE.
	TIM_AF2_BK2INE = 0x1
	// Position of BK2CMP1E field.
	TIM_AF2_BK2CMP1E_Pos = 0x1
	// Bit mask of BK2CMP1E field.
	TIM_AF2_BK2CMP1E_Msk = 0x2
	// Bit BK2CMP1E.
	TIM_AF2_BK2CMP1E = 0x2
	// Position of BK2CMP2E field.
	TIM_AF2_BK2CMP2E_Pos = 0x2
	// Bit mask of BK2CMP2E field.
	TIM_AF2_BK2CMP2E_Msk = 0x4
	// Bit BK2CMP2E.
	TIM_AF2_BK2CMP2E = 0x4
	// Position of BK2DF1BK1E field.
	TIM_AF2_BK2DF1BK1E_Pos = 0x8
	// Bit mask of BK2DF1BK1E field.
	TIM_AF2_BK2DF1BK1E_Msk = 0x100
	// Bit BK2DF1BK1E.
	TIM_AF2_BK2DF1BK1E = 0x100
	// Position of BK2INP field.
	TIM_AF2_BK2INP_Pos = 0x9
	// Bit mask of BK2INP field.
	TIM_AF2_BK2INP_Msk = 0x200
	// Bit BK2INP.
	TIM_AF2_BK2INP = 0x200
	// Position of BK2CMP1P field.
	TIM_AF2_BK2CMP1P_Pos = 0xa
	// Bit mask of BK2CMP1P field.
	TIM_AF2_BK2CMP1P_Msk = 0x400
	// Bit BK2CMP1P.
	TIM_AF2_BK2CMP1P = 0x400
	// Position of BK2CMP2P field.
	TIM_AF2_BK2CMP2P_Pos = 0xb
	// Bit mask of BK2CMP2P field.
	TIM_AF2_BK2CMP2P_Msk = 0x800
	// Bit BK2CMP2P.
	TIM_AF2_BK2CMP2P = 0x800

	// TISEL: TIM1 timer input selection register
	// Position of TI1SEL field.
	TIM_TISEL_TI1SEL_Pos = 0x0
	// Bit mask of TI1SEL field.
	TIM_TISEL_TI1SEL_Msk = 0xf
	// Position of TI2SEL field.
	TIM_TISEL_TI2SEL_Pos = 0x8
	// Bit mask of TI2SEL field.
	TIM_TISEL_TI2SEL_Msk = 0xf00
	// Position of TI3SEL field.
	TIM_TISEL_TI3SEL_Pos = 0x10
	// Bit mask of TI3SEL field.
	TIM_TISEL_TI3SEL_Msk = 0xf0000
	// Position of TI4SEL field.
	TIM_TISEL_TI4SEL_Pos = 0x18
	// Bit mask of TI4SEL field.
	TIM_TISEL_TI4SEL_Msk = 0xf000000
)

// Constants for TIM15: General purpose timers
const (
	// CR1: control register 1
	// Position of CEN field.
	TIMs_CR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIMs_CR1_CEN_Msk = 0x1
	// Bit CEN.
	TIMs_CR1_CEN = 0x1
	// Counter disabled
	TIMs_CR1_CEN_Disabled = 0x0
	// Counter enabled
	TIMs_CR1_CEN_Enabled = 0x1
	// Position of UDIS field.
	TIMs_CR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIMs_CR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIMs_CR1_UDIS = 0x2
	// Update event enabled
	TIMs_CR1_UDIS_Enabled = 0x0
	// Update event disabled
	TIMs_CR1_UDIS_Disabled = 0x1
	// Position of URS field.
	TIMs_CR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIMs_CR1_URS_Msk = 0x4
	// Bit URS.
	TIMs_CR1_URS = 0x4
	// Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
	TIMs_CR1_URS_AnyEvent = 0x0
	// Only counter overflow/underflow generates an update interrupt or DMA request
	TIMs_CR1_URS_CounterOnly = 0x1
	// Position of OPM field.
	TIMs_CR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIMs_CR1_OPM_Msk = 0x8
	// Bit OPM.
	TIMs_CR1_OPM = 0x8
	// Position of ARPE field.
	TIMs_CR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIMs_CR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIMs_CR1_ARPE = 0x80
	// TIMx_APRR register is not buffered
	TIMs_CR1_ARPE_Disabled = 0x0
	// TIMx_APRR register is buffered
	TIMs_CR1_ARPE_Enabled = 0x1
	// Position of CKD field.
	TIMs_CR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIMs_CR1_CKD_Msk = 0x300
	// t_DTS = t_CK_INT
	TIMs_CR1_CKD_Div1 = 0x0
	// t_DTS = 2  t_CK_INT
	TIMs_CR1_CKD_Div2 = 0x1
	// t_DTS = 4  t_CK_INT
	TIMs_CR1_CKD_Div4 = 0x2
	// Position of UIFREMAP field.
	TIMs_CR1_UIFREMAP_Pos = 0xb
	// Bit mask of UIFREMAP field.
	TIMs_CR1_UIFREMAP_Msk = 0x800
	// Bit UIFREMAP.
	TIMs_CR1_UIFREMAP = 0x800

	// CR2: control register 2
	// Position of CCPC field.
	TIMs_CR2_CCPC_Pos = 0x0
	// Bit mask of CCPC field.
	TIMs_CR2_CCPC_Msk = 0x1
	// Bit CCPC.
	TIMs_CR2_CCPC = 0x1
	// Position of CCUS field.
	TIMs_CR2_CCUS_Pos = 0x2
	// Bit mask of CCUS field.
	TIMs_CR2_CCUS_Msk = 0x4
	// Bit CCUS.
	TIMs_CR2_CCUS = 0x4
	// Position of CCDS field.
	TIMs_CR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIMs_CR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIMs_CR2_CCDS = 0x8
	// Position of MMS field.
	TIMs_CR2_MMS_Pos = 0x4
	// Bit mask of MMS field.
	TIMs_CR2_MMS_Msk = 0x70
	// Position of TI1S field.
	TIMs_CR2_TI1S_Pos = 0x7
	// Bit mask of TI1S field.
	TIMs_CR2_TI1S_Msk = 0x80
	// Bit TI1S.
	TIMs_CR2_TI1S = 0x80
	// Position of OIS1 field.
	TIMs_CR2_OIS1_Pos = 0x8
	// Bit mask of OIS1 field.
	TIMs_CR2_OIS1_Msk = 0x100
	// Bit OIS1.
	TIMs_CR2_OIS1 = 0x100
	// Position of OIS1N field.
	TIMs_CR2_OIS1N_Pos = 0x9
	// Bit mask of OIS1N field.
	TIMs_CR2_OIS1N_Msk = 0x200
	// Bit OIS1N.
	TIMs_CR2_OIS1N = 0x200
	// Position of OIS2 field.
	TIMs_CR2_OIS2_Pos = 0xa
	// Bit mask of OIS2 field.
	TIMs_CR2_OIS2_Msk = 0x400
	// Bit OIS2.
	TIMs_CR2_OIS2 = 0x400

	// SMCR: slave mode control register
	// Position of SMS field.
	TIMs_SMCR_SMS_Pos = 0x0
	// Bit mask of SMS field.
	TIMs_SMCR_SMS_Msk = 0x7
	// Position of TS_2_0 field.
	TIMs_SMCR_TS_2_0_Pos = 0x4
	// Bit mask of TS_2_0 field.
	TIMs_SMCR_TS_2_0_Msk = 0x70
	// Position of MSM field.
	TIMs_SMCR_MSM_Pos = 0x7
	// Bit mask of MSM field.
	TIMs_SMCR_MSM_Msk = 0x80
	// Bit MSM.
	TIMs_SMCR_MSM = 0x80
	// Position of SMS_3 field.
	TIMs_SMCR_SMS_3_Pos = 0x10
	// Bit mask of SMS_3 field.
	TIMs_SMCR_SMS_3_Msk = 0x10000
	// Bit SMS_3.
	TIMs_SMCR_SMS_3 = 0x10000
	// Position of TS_4_3 field.
	TIMs_SMCR_TS_4_3_Pos = 0x14
	// Bit mask of TS_4_3 field.
	TIMs_SMCR_TS_4_3_Msk = 0x300000

	// DIER: DMA/Interrupt enable register
	// Position of UIE field.
	TIMs_DIER_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIMs_DIER_UIE_Msk = 0x1
	// Bit UIE.
	TIMs_DIER_UIE = 0x1
	// Update interrupt disabled
	TIMs_DIER_UIE_Disabled = 0x0
	// Update interrupt enabled
	TIMs_DIER_UIE_Enabled = 0x1
	// Position of CC1IE field.
	TIMs_DIER_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIMs_DIER_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIMs_DIER_CC1IE = 0x2
	// Position of CC2IE field.
	TIMs_DIER_CC2IE_Pos = 0x2
	// Bit mask of CC2IE field.
	TIMs_DIER_CC2IE_Msk = 0x4
	// Bit CC2IE.
	TIMs_DIER_CC2IE = 0x4
	// Position of COMIE field.
	TIMs_DIER_COMIE_Pos = 0x5
	// Bit mask of COMIE field.
	TIMs_DIER_COMIE_Msk = 0x20
	// Bit COMIE.
	TIMs_DIER_COMIE = 0x20
	// Position of TIE field.
	TIMs_DIER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	TIMs_DIER_TIE_Msk = 0x40
	// Bit TIE.
	TIMs_DIER_TIE = 0x40
	// Position of BIE field.
	TIMs_DIER_BIE_Pos = 0x7
	// Bit mask of BIE field.
	TIMs_DIER_BIE_Msk = 0x80
	// Bit BIE.
	TIMs_DIER_BIE = 0x80
	// Position of UDE field.
	TIMs_DIER_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIMs_DIER_UDE_Msk = 0x100
	// Bit UDE.
	TIMs_DIER_UDE = 0x100
	// Position of CC1DE field.
	TIMs_DIER_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIMs_DIER_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIMs_DIER_CC1DE = 0x200
	// Position of CC2DE field.
	TIMs_DIER_CC2DE_Pos = 0xa
	// Bit mask of CC2DE field.
	TIMs_DIER_CC2DE_Msk = 0x400
	// Bit CC2DE.
	TIMs_DIER_CC2DE = 0x400
	// Position of COMDE field.
	TIMs_DIER_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIMs_DIER_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIMs_DIER_COMDE = 0x2000
	// Position of TDE field.
	TIMs_DIER_TDE_Pos = 0xe
	// Bit mask of TDE field.
	TIMs_DIER_TDE_Msk = 0x4000
	// Bit TDE.
	TIMs_DIER_TDE = 0x4000

	// SR: status register
	// Position of CC2OF field.
	TIMs_SR_CC2OF_Pos = 0xa
	// Bit mask of CC2OF field.
	TIMs_SR_CC2OF_Msk = 0x400
	// Bit CC2OF.
	TIMs_SR_CC2OF = 0x400
	// Position of CC1OF field.
	TIMs_SR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIMs_SR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIMs_SR_CC1OF = 0x200
	// Position of BIF field.
	TIMs_SR_BIF_Pos = 0x7
	// Bit mask of BIF field.
	TIMs_SR_BIF_Msk = 0x80
	// Bit BIF.
	TIMs_SR_BIF = 0x80
	// Position of TIF field.
	TIMs_SR_TIF_Pos = 0x6
	// Bit mask of TIF field.
	TIMs_SR_TIF_Msk = 0x40
	// Bit TIF.
	TIMs_SR_TIF = 0x40
	// Position of COMIF field.
	TIMs_SR_COMIF_Pos = 0x5
	// Bit mask of COMIF field.
	TIMs_SR_COMIF_Msk = 0x20
	// Bit COMIF.
	TIMs_SR_COMIF = 0x20
	// Position of CC2IF field.
	TIMs_SR_CC2IF_Pos = 0x2
	// Bit mask of CC2IF field.
	TIMs_SR_CC2IF_Msk = 0x4
	// Bit CC2IF.
	TIMs_SR_CC2IF = 0x4
	// Position of CC1IF field.
	TIMs_SR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIMs_SR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIMs_SR_CC1IF = 0x2
	// Position of UIF field.
	TIMs_SR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIMs_SR_UIF_Msk = 0x1
	// Bit UIF.
	TIMs_SR_UIF = 0x1
	// No update occurred
	TIMs_SR_UIF_Clear = 0x0
	// Update interrupt pending.
	TIMs_SR_UIF_UpdatePending = 0x1

	// EGR: event generation register
	// Position of BG field.
	TIMs_EGR_BG_Pos = 0x7
	// Bit mask of BG field.
	TIMs_EGR_BG_Msk = 0x80
	// Bit BG.
	TIMs_EGR_BG = 0x80
	// Position of TG field.
	TIMs_EGR_TG_Pos = 0x6
	// Bit mask of TG field.
	TIMs_EGR_TG_Msk = 0x40
	// Bit TG.
	TIMs_EGR_TG = 0x40
	// Position of COMG field.
	TIMs_EGR_COMG_Pos = 0x5
	// Bit mask of COMG field.
	TIMs_EGR_COMG_Msk = 0x20
	// Bit COMG.
	TIMs_EGR_COMG = 0x20
	// Position of CC2G field.
	TIMs_EGR_CC2G_Pos = 0x2
	// Bit mask of CC2G field.
	TIMs_EGR_CC2G_Msk = 0x4
	// Bit CC2G.
	TIMs_EGR_CC2G = 0x4
	// Position of CC1G field.
	TIMs_EGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIMs_EGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIMs_EGR_CC1G = 0x2
	// Position of UG field.
	TIMs_EGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIMs_EGR_UG_Msk = 0x1
	// Bit UG.
	TIMs_EGR_UG = 0x1
	// Re-initializes the timer counter and generates an update of the registers.
	TIMs_EGR_UG_Update = 0x1

	// CCMR1_Output: capture/compare mode register (output mode)
	// Position of CC1S field.
	TIMs_CCMR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIMs_CCMR1_Output_CC1S_Msk = 0x3
	// CC1 channel is configured as output
	TIMs_CCMR1_Output_CC1S_Output = 0x0
	// Position of OC1FE field.
	TIMs_CCMR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIMs_CCMR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIMs_CCMR1_Output_OC1FE = 0x4
	// Position of OC1PE field.
	TIMs_CCMR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIMs_CCMR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIMs_CCMR1_Output_OC1PE = 0x8
	// Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
	TIMs_CCMR1_Output_OC1PE_Disabled = 0x0
	// Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
	TIMs_CCMR1_Output_OC1PE_Enabled = 0x1
	// Position of OC1M field.
	TIMs_CCMR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIMs_CCMR1_Output_OC1M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIMs_CCMR1_Output_OC1M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIMs_CCMR1_Output_OC1M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIMs_CCMR1_Output_OC1M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIMs_CCMR1_Output_OC1M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIMs_CCMR1_Output_OC1M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIMs_CCMR1_Output_OC1M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / Reserved
	TIMs_CCMR1_Output_OC1M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / Reserved
	TIMs_CCMR1_Output_OC1M_PwmMode2 = 0x7
	// Position of CC2S field.
	TIMs_CCMR1_Output_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIMs_CCMR1_Output_CC2S_Msk = 0x300
	// CC2 channel is configured as output
	TIMs_CCMR1_Output_CC2S_Output = 0x0
	// Position of OC2FE field.
	TIMs_CCMR1_Output_OC2FE_Pos = 0xa
	// Bit mask of OC2FE field.
	TIMs_CCMR1_Output_OC2FE_Msk = 0x400
	// Bit OC2FE.
	TIMs_CCMR1_Output_OC2FE = 0x400
	// Position of OC2PE field.
	TIMs_CCMR1_Output_OC2PE_Pos = 0xb
	// Bit mask of OC2PE field.
	TIMs_CCMR1_Output_OC2PE_Msk = 0x800
	// Bit OC2PE.
	TIMs_CCMR1_Output_OC2PE = 0x800
	// Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
	TIMs_CCMR1_Output_OC2PE_Disabled = 0x0
	// Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
	TIMs_CCMR1_Output_OC2PE_Enabled = 0x1
	// Position of OC2M field.
	TIMs_CCMR1_Output_OC2M_Pos = 0xc
	// Bit mask of OC2M field.
	TIMs_CCMR1_Output_OC2M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIMs_CCMR1_Output_OC2M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIMs_CCMR1_Output_OC2M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIMs_CCMR1_Output_OC2M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIMs_CCMR1_Output_OC2M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIMs_CCMR1_Output_OC2M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIMs_CCMR1_Output_OC2M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / Reserved
	TIMs_CCMR1_Output_OC2M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / Reserved
	TIMs_CCMR1_Output_OC2M_PwmMode2 = 0x7
	// Position of OC1M_3 field.
	TIMs_CCMR1_Output_OC1M_3_Pos = 0x10
	// Bit mask of OC1M_3 field.
	TIMs_CCMR1_Output_OC1M_3_Msk = 0x10000
	// Bit OC1M_3.
	TIMs_CCMR1_Output_OC1M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIMs_CCMR1_Output_OC1M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIMs_CCMR1_Output_OC1M_3_Extended = 0x1
	// Position of OC2M_3 field.
	TIMs_CCMR1_Output_OC2M_3_Pos = 0x18
	// Bit mask of OC2M_3 field.
	TIMs_CCMR1_Output_OC2M_3_Msk = 0x1000000
	// Bit OC2M_3.
	TIMs_CCMR1_Output_OC2M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIMs_CCMR1_Output_OC2M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIMs_CCMR1_Output_OC2M_3_Extended = 0x1

	// CCMR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC2F field.
	TIMs_CCMR1_Input_IC2F_Pos = 0xc
	// Bit mask of IC2F field.
	TIMs_CCMR1_Input_IC2F_Msk = 0xf000
	// Position of IC2PSC field.
	TIMs_CCMR1_Input_IC2PSC_Pos = 0xa
	// Bit mask of IC2PSC field.
	TIMs_CCMR1_Input_IC2PSC_Msk = 0xc00
	// Position of CC2S field.
	TIMs_CCMR1_Input_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIMs_CCMR1_Input_CC2S_Msk = 0x300
	// CC2 channel is configured as input, IC2 is mapped on TI2
	TIMs_CCMR1_Input_CC2S_TI2 = 0x1
	// CC2 channel is configured as input, IC2 is mapped on TI1
	TIMs_CCMR1_Input_CC2S_TI1 = 0x2
	// CC2 channel is configured as input, IC2 is mapped on TRC
	TIMs_CCMR1_Input_CC2S_TRC = 0x3
	// Position of IC1F field.
	TIMs_CCMR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIMs_CCMR1_Input_IC1F_Msk = 0xf0
	// No filter, sampling is done at fDTS
	TIMs_CCMR1_Input_IC1F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIMs_CCMR1_Input_IC1F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIMs_CCMR1_Input_IC1F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIMs_CCMR1_Input_IC1F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIMs_CCMR1_Input_IC1F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIMs_CCMR1_Input_IC1F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIMs_CCMR1_Input_IC1F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIMs_CCMR1_Input_IC1F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIMs_CCMR1_Input_IC1F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIMs_CCMR1_Input_IC1F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIMs_CCMR1_Input_IC1F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIMs_CCMR1_Input_IC1F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIMs_CCMR1_Input_IC1F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIMs_CCMR1_Input_IC1F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIMs_CCMR1_Input_IC1F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIMs_CCMR1_Input_IC1F_FDTS_Div32_N8 = 0xf
	// Position of IC1PSC field.
	TIMs_CCMR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIMs_CCMR1_Input_IC1PSC_Msk = 0xc
	// Position of CC1S field.
	TIMs_CCMR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIMs_CCMR1_Input_CC1S_Msk = 0x3
	// CC1 channel is configured as input, IC1 is mapped on TI1
	TIMs_CCMR1_Input_CC1S_TI1 = 0x1
	// CC1 channel is configured as input, IC1 is mapped on TI2
	TIMs_CCMR1_Input_CC1S_TI2 = 0x2
	// CC1 channel is configured as input, IC1 is mapped on TRC
	TIMs_CCMR1_Input_CC1S_TRC = 0x3

	// CCER: capture/compare enable register
	// Position of CC2NP field.
	TIMs_CCER_CC2NP_Pos = 0x7
	// Bit mask of CC2NP field.
	TIMs_CCER_CC2NP_Msk = 0x80
	// Bit CC2NP.
	TIMs_CCER_CC2NP = 0x80
	// Position of CC2P field.
	TIMs_CCER_CC2P_Pos = 0x5
	// Bit mask of CC2P field.
	TIMs_CCER_CC2P_Msk = 0x20
	// Bit CC2P.
	TIMs_CCER_CC2P = 0x20
	// Position of CC2E field.
	TIMs_CCER_CC2E_Pos = 0x4
	// Bit mask of CC2E field.
	TIMs_CCER_CC2E_Msk = 0x10
	// Bit CC2E.
	TIMs_CCER_CC2E = 0x10
	// Position of CC1NP field.
	TIMs_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIMs_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIMs_CCER_CC1NP = 0x8
	// Position of CC1NE field.
	TIMs_CCER_CC1NE_Pos = 0x2
	// Bit mask of CC1NE field.
	TIMs_CCER_CC1NE_Msk = 0x4
	// Bit CC1NE.
	TIMs_CCER_CC1NE = 0x4
	// Position of CC1P field.
	TIMs_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIMs_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIMs_CCER_CC1P = 0x2
	// Position of CC1E field.
	TIMs_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIMs_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIMs_CCER_CC1E = 0x1

	// CNT: counter
	// Position of CNT field.
	TIMs_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIMs_CNT_CNT_Msk = 0xffff
	// Position of UIFCPY field.
	TIMs_CNT_UIFCPY_Pos = 0x1f
	// Bit mask of UIFCPY field.
	TIMs_CNT_UIFCPY_Msk = 0x80000000
	// Bit UIFCPY.
	TIMs_CNT_UIFCPY = 0x80000000

	// PSC: prescaler
	// Position of PSC field.
	TIMs_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIMs_PSC_PSC_Msk = 0xffff

	// ARR: auto-reload register
	// Position of ARR field.
	TIMs_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	TIMs_ARR_ARR_Msk = 0xffff

	// RCR: repetition counter register
	// Position of REP field.
	TIMs_RCR_REP_Pos = 0x0
	// Bit mask of REP field.
	TIMs_RCR_REP_Msk = 0xff

	// CCR1: capture/compare register
	// Position of CCR field.
	TIMs_CCR_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIMs_CCR_CCR_Msk = 0xffff

	// BDTR: break and dead-time register
	// Position of MOE field.
	TIMs_BDTR_MOE_Pos = 0xf
	// Bit mask of MOE field.
	TIMs_BDTR_MOE_Msk = 0x8000
	// Bit MOE.
	TIMs_BDTR_MOE = 0x8000
	// Position of AOE field.
	TIMs_BDTR_AOE_Pos = 0xe
	// Bit mask of AOE field.
	TIMs_BDTR_AOE_Msk = 0x4000
	// Bit AOE.
	TIMs_BDTR_AOE = 0x4000
	// Position of BKP field.
	TIMs_BDTR_BKP_Pos = 0xd
	// Bit mask of BKP field.
	TIMs_BDTR_BKP_Msk = 0x2000
	// Bit BKP.
	TIMs_BDTR_BKP = 0x2000
	// Position of BKE field.
	TIMs_BDTR_BKE_Pos = 0xc
	// Bit mask of BKE field.
	TIMs_BDTR_BKE_Msk = 0x1000
	// Bit BKE.
	TIMs_BDTR_BKE = 0x1000
	// Position of OSSR field.
	TIMs_BDTR_OSSR_Pos = 0xb
	// Bit mask of OSSR field.
	TIMs_BDTR_OSSR_Msk = 0x800
	// Bit OSSR.
	TIMs_BDTR_OSSR = 0x800
	// Position of OSSI field.
	TIMs_BDTR_OSSI_Pos = 0xa
	// Bit mask of OSSI field.
	TIMs_BDTR_OSSI_Msk = 0x400
	// Bit OSSI.
	TIMs_BDTR_OSSI = 0x400
	// Position of LOCK field.
	TIMs_BDTR_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	TIMs_BDTR_LOCK_Msk = 0x300
	// Position of DTG field.
	TIMs_BDTR_DTG_Pos = 0x0
	// Bit mask of DTG field.
	TIMs_BDTR_DTG_Msk = 0xff
	// Position of BKF field.
	TIMs_BDTR_BKF_Pos = 0x10
	// Bit mask of BKF field.
	TIMs_BDTR_BKF_Msk = 0xf0000

	// DCR: DMA control register
	// Position of DBL field.
	TIMs_DCR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIMs_DCR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIMs_DCR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIMs_DCR_DBA_Msk = 0x1f

	// DMAR: DMA address for full transfer
	// Position of DMAB field.
	TIMs_DMAR_DMAB_Pos = 0x0
	// Bit mask of DMAB field.
	TIMs_DMAR_DMAB_Msk = 0xffff

	// AF1: TIM15 alternate fdfsdm1_breakon register 1
	// Position of BKINE field.
	TIMs_AF1_BKINE_Pos = 0x0
	// Bit mask of BKINE field.
	TIMs_AF1_BKINE_Msk = 0x1
	// Bit BKINE.
	TIMs_AF1_BKINE = 0x1
	// Position of BKCMP1E field.
	TIMs_AF1_BKCMP1E_Pos = 0x1
	// Bit mask of BKCMP1E field.
	TIMs_AF1_BKCMP1E_Msk = 0x2
	// Bit BKCMP1E.
	TIMs_AF1_BKCMP1E = 0x2
	// Position of BKCMP2E field.
	TIMs_AF1_BKCMP2E_Pos = 0x2
	// Bit mask of BKCMP2E field.
	TIMs_AF1_BKCMP2E_Msk = 0x4
	// Bit BKCMP2E.
	TIMs_AF1_BKCMP2E = 0x4
	// Position of BKDF1BK0E field.
	TIMs_AF1_BKDF1BK0E_Pos = 0x8
	// Bit mask of BKDF1BK0E field.
	TIMs_AF1_BKDF1BK0E_Msk = 0x100
	// Bit BKDF1BK0E.
	TIMs_AF1_BKDF1BK0E = 0x100
	// Position of BKINP field.
	TIMs_AF1_BKINP_Pos = 0x9
	// Bit mask of BKINP field.
	TIMs_AF1_BKINP_Msk = 0x200
	// Bit BKINP.
	TIMs_AF1_BKINP = 0x200
	// Position of BKCMP1P field.
	TIMs_AF1_BKCMP1P_Pos = 0xa
	// Bit mask of BKCMP1P field.
	TIMs_AF1_BKCMP1P_Msk = 0x400
	// Bit BKCMP1P.
	TIMs_AF1_BKCMP1P = 0x400
	// Position of BKCMP2P field.
	TIMs_AF1_BKCMP2P_Pos = 0xb
	// Bit mask of BKCMP2P field.
	TIMs_AF1_BKCMP2P_Msk = 0x800
	// Bit BKCMP2P.
	TIMs_AF1_BKCMP2P = 0x800

	// TISEL: TIM15 input selection register
	// Position of TI1SEL field.
	TIMs_TISEL_TI1SEL_Pos = 0x0
	// Bit mask of TI1SEL field.
	TIMs_TISEL_TI1SEL_Msk = 0xf
	// Position of TI2SEL field.
	TIMs_TISEL_TI2SEL_Pos = 0x8
	// Bit mask of TI2SEL field.
	TIMs_TISEL_TI2SEL_Msk = 0xf00
)

// Constants for USART1: Universal synchronous asynchronous receiver transmitter
const (
	// CR1: Control register 1
	// Position of RXFFIE field.
	USART_CR1_RXFFIE_Pos = 0x1f
	// Bit mask of RXFFIE field.
	USART_CR1_RXFFIE_Msk = 0x80000000
	// Bit RXFFIE.
	USART_CR1_RXFFIE = 0x80000000
	// Position of TXFEIE field.
	USART_CR1_TXFEIE_Pos = 0x1e
	// Bit mask of TXFEIE field.
	USART_CR1_TXFEIE_Msk = 0x40000000
	// Bit TXFEIE.
	USART_CR1_TXFEIE = 0x40000000
	// Position of FIFOEN field.
	USART_CR1_FIFOEN_Pos = 0x1d
	// Bit mask of FIFOEN field.
	USART_CR1_FIFOEN_Msk = 0x20000000
	// Bit FIFOEN.
	USART_CR1_FIFOEN = 0x20000000
	// Position of M1 field.
	USART_CR1_M1_Pos = 0x1c
	// Bit mask of M1 field.
	USART_CR1_M1_Msk = 0x10000000
	// Bit M1.
	USART_CR1_M1 = 0x10000000
	// Use M0 to set the data bits
	USART_CR1_M1_M0 = 0x0
	// 1 start bit, 7 data bits, n stop bits
	USART_CR1_M1_Bit7 = 0x1
	// Position of EOBIE field.
	USART_CR1_EOBIE_Pos = 0x1b
	// Bit mask of EOBIE field.
	USART_CR1_EOBIE_Msk = 0x8000000
	// Bit EOBIE.
	USART_CR1_EOBIE = 0x8000000
	// Interrupt is inhibited
	USART_CR1_EOBIE_Disabled = 0x0
	// A USART interrupt is generated when the EOBF flag is set in the ISR register
	USART_CR1_EOBIE_Enabled = 0x1
	// Position of RTOIE field.
	USART_CR1_RTOIE_Pos = 0x1a
	// Bit mask of RTOIE field.
	USART_CR1_RTOIE_Msk = 0x4000000
	// Bit RTOIE.
	USART_CR1_RTOIE = 0x4000000
	// Interrupt is inhibited
	USART_CR1_RTOIE_Disabled = 0x0
	// An USART interrupt is generated when the RTOF bit is set in the ISR register
	USART_CR1_RTOIE_Enabled = 0x1
	// Position of OVER8 field.
	USART_CR1_OVER8_Pos = 0xf
	// Bit mask of OVER8 field.
	USART_CR1_OVER8_Msk = 0x8000
	// Bit OVER8.
	USART_CR1_OVER8 = 0x8000
	// Oversampling by 16
	USART_CR1_OVER8_Oversampling16 = 0x0
	// Oversampling by 8
	USART_CR1_OVER8_Oversampling8 = 0x1
	// Position of CMIE field.
	USART_CR1_CMIE_Pos = 0xe
	// Bit mask of CMIE field.
	USART_CR1_CMIE_Msk = 0x4000
	// Bit CMIE.
	USART_CR1_CMIE = 0x4000
	// Interrupt is disabled
	USART_CR1_CMIE_Disabled = 0x0
	// Interrupt is generated when the CMF bit is set in the ISR register
	USART_CR1_CMIE_Enabled = 0x1
	// Position of MME field.
	USART_CR1_MME_Pos = 0xd
	// Bit mask of MME field.
	USART_CR1_MME_Msk = 0x2000
	// Bit MME.
	USART_CR1_MME = 0x2000
	// Receiver in active mode permanently
	USART_CR1_MME_Disabled = 0x0
	// Receiver can switch between mute mode and active mode
	USART_CR1_MME_Enabled = 0x1
	// Position of M0 field.
	USART_CR1_M0_Pos = 0xc
	// Bit mask of M0 field.
	USART_CR1_M0_Msk = 0x1000
	// Bit M0.
	USART_CR1_M0 = 0x1000
	// 1 start bit, 8 data bits, n stop bits
	USART_CR1_M0_Bit8 = 0x0
	// 1 start bit, 9 data bits, n stop bits
	USART_CR1_M0_Bit9 = 0x1
	// Position of WAKE field.
	USART_CR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	USART_CR1_WAKE_Msk = 0x800
	// Bit WAKE.
	USART_CR1_WAKE = 0x800
	// Idle line
	USART_CR1_WAKE_Idle = 0x0
	// Address mask
	USART_CR1_WAKE_Address = 0x1
	// Position of PCE field.
	USART_CR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	USART_CR1_PCE_Msk = 0x400
	// Bit PCE.
	USART_CR1_PCE = 0x400
	// Parity control disabled
	USART_CR1_PCE_Disabled = 0x0
	// Parity control enabled
	USART_CR1_PCE_Enabled = 0x1
	// Position of PS field.
	USART_CR1_PS_Pos = 0x9
	// Bit mask of PS field.
	USART_CR1_PS_Msk = 0x200
	// Bit PS.
	USART_CR1_PS = 0x200
	// Even parity
	USART_CR1_PS_Even = 0x0
	// Odd parity
	USART_CR1_PS_Odd = 0x1
	// Position of PEIE field.
	USART_CR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	USART_CR1_PEIE_Msk = 0x100
	// Bit PEIE.
	USART_CR1_PEIE = 0x100
	// Interrupt is disabled
	USART_CR1_PEIE_Disabled = 0x0
	// Interrupt is generated whenever PE=1 in the ISR register
	USART_CR1_PEIE_Enabled = 0x1
	// Position of TXEIE field.
	USART_CR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	USART_CR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	USART_CR1_TXEIE = 0x80
	// Interrupt is disabled
	USART_CR1_TXEIE_Disabled = 0x0
	// Interrupt is generated whenever TXE=1 in the ISR register
	USART_CR1_TXEIE_Enabled = 0x1
	// Position of TCIE field.
	USART_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	USART_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	USART_CR1_TCIE = 0x40
	// Interrupt is disabled
	USART_CR1_TCIE_Disabled = 0x0
	// Interrupt is generated whenever TC=1 in the ISR register
	USART_CR1_TCIE_Enabled = 0x1
	// Position of RXNEIE field.
	USART_CR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	USART_CR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	USART_CR1_RXNEIE = 0x20
	// Interrupt is disabled
	USART_CR1_RXNEIE_Disabled = 0x0
	// Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register
	USART_CR1_RXNEIE_Enabled = 0x1
	// Position of IDLEIE field.
	USART_CR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	USART_CR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	USART_CR1_IDLEIE = 0x10
	// Interrupt is disabled
	USART_CR1_IDLEIE_Disabled = 0x0
	// Interrupt is generated whenever IDLE=1 in the ISR register
	USART_CR1_IDLEIE_Enabled = 0x1
	// Position of TE field.
	USART_CR1_TE_Pos = 0x3
	// Bit mask of TE field.
	USART_CR1_TE_Msk = 0x8
	// Bit TE.
	USART_CR1_TE = 0x8
	// Transmitter is disabled
	USART_CR1_TE_Disabled = 0x0
	// Transmitter is enabled
	USART_CR1_TE_Enabled = 0x1
	// Position of RE field.
	USART_CR1_RE_Pos = 0x2
	// Bit mask of RE field.
	USART_CR1_RE_Msk = 0x4
	// Bit RE.
	USART_CR1_RE = 0x4
	// Receiver is disabled
	USART_CR1_RE_Disabled = 0x0
	// Receiver is enabled
	USART_CR1_RE_Enabled = 0x1
	// Position of UESM field.
	USART_CR1_UESM_Pos = 0x1
	// Bit mask of UESM field.
	USART_CR1_UESM_Msk = 0x2
	// Bit UESM.
	USART_CR1_UESM = 0x2
	// USART not able to wake up the MCU from Stop mode
	USART_CR1_UESM_Disabled = 0x0
	// USART able to wake up the MCU from Stop mode
	USART_CR1_UESM_Enabled = 0x1
	// Position of UE field.
	USART_CR1_UE_Pos = 0x0
	// Bit mask of UE field.
	USART_CR1_UE_Msk = 0x1
	// Bit UE.
	USART_CR1_UE = 0x1
	// UART is disabled
	USART_CR1_UE_Disabled = 0x0
	// UART is enabled
	USART_CR1_UE_Enabled = 0x1
	// Position of DEAT field.
	USART_CR1_DEAT_Pos = 0x15
	// Bit mask of DEAT field.
	USART_CR1_DEAT_Msk = 0x3e00000
	// Position of DEDT field.
	USART_CR1_DEDT_Pos = 0x10
	// Bit mask of DEDT field.
	USART_CR1_DEDT_Msk = 0x1f0000

	// CR2: Control register 2
	// Position of RTOEN field.
	USART_CR2_RTOEN_Pos = 0x17
	// Bit mask of RTOEN field.
	USART_CR2_RTOEN_Msk = 0x800000
	// Bit RTOEN.
	USART_CR2_RTOEN = 0x800000
	// Receiver timeout feature disabled
	USART_CR2_RTOEN_Disabled = 0x0
	// Receiver timeout feature enabled
	USART_CR2_RTOEN_Enabled = 0x1
	// Position of ABREN field.
	USART_CR2_ABREN_Pos = 0x14
	// Bit mask of ABREN field.
	USART_CR2_ABREN_Msk = 0x100000
	// Bit ABREN.
	USART_CR2_ABREN = 0x100000
	// Auto baud rate detection is disabled
	USART_CR2_ABREN_Disabled = 0x0
	// Auto baud rate detection is enabled
	USART_CR2_ABREN_Enabled = 0x1
	// Position of MSBFIRST field.
	USART_CR2_MSBFIRST_Pos = 0x13
	// Bit mask of MSBFIRST field.
	USART_CR2_MSBFIRST_Msk = 0x80000
	// Bit MSBFIRST.
	USART_CR2_MSBFIRST = 0x80000
	// data is transmitted/received with data bit 0 first, following the start bit
	USART_CR2_MSBFIRST_LSB = 0x0
	// data is transmitted/received with MSB (bit 7/8/9) first, following the start bit
	USART_CR2_MSBFIRST_MSB = 0x1
	// Position of DATAINV field.
	USART_CR2_DATAINV_Pos = 0x12
	// Bit mask of DATAINV field.
	USART_CR2_DATAINV_Msk = 0x40000
	// Bit DATAINV.
	USART_CR2_DATAINV = 0x40000
	// Logical data from the data register are send/received in positive/direct logic
	USART_CR2_DATAINV_Positive = 0x0
	// Logical data from the data register are send/received in negative/inverse logic
	USART_CR2_DATAINV_Negative = 0x1
	// Position of TXINV field.
	USART_CR2_TXINV_Pos = 0x11
	// Bit mask of TXINV field.
	USART_CR2_TXINV_Msk = 0x20000
	// Bit TXINV.
	USART_CR2_TXINV = 0x20000
	// TX pin signal works using the standard logic levels
	USART_CR2_TXINV_Standard = 0x0
	// TX pin signal values are inverted
	USART_CR2_TXINV_Inverted = 0x1
	// Position of RXINV field.
	USART_CR2_RXINV_Pos = 0x10
	// Bit mask of RXINV field.
	USART_CR2_RXINV_Msk = 0x10000
	// Bit RXINV.
	USART_CR2_RXINV = 0x10000
	// RX pin signal works using the standard logic levels
	USART_CR2_RXINV_Standard = 0x0
	// RX pin signal values are inverted
	USART_CR2_RXINV_Inverted = 0x1
	// Position of SWAP field.
	USART_CR2_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	USART_CR2_SWAP_Msk = 0x8000
	// Bit SWAP.
	USART_CR2_SWAP = 0x8000
	// TX/RX pins are used as defined in standard pinout
	USART_CR2_SWAP_Standard = 0x0
	// The TX and RX pins functions are swapped
	USART_CR2_SWAP_Swapped = 0x1
	// Position of LINEN field.
	USART_CR2_LINEN_Pos = 0xe
	// Bit mask of LINEN field.
	USART_CR2_LINEN_Msk = 0x4000
	// Bit LINEN.
	USART_CR2_LINEN = 0x4000
	// LIN mode disabled
	USART_CR2_LINEN_Disabled = 0x0
	// LIN mode enabled
	USART_CR2_LINEN_Enabled = 0x1
	// Position of STOP field.
	USART_CR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	USART_CR2_STOP_Msk = 0x3000
	// 1 stop bit
	USART_CR2_STOP_Stop1 = 0x0
	// 0.5 stop bit
	USART_CR2_STOP_Stop0p5 = 0x1
	// 2 stop bit
	USART_CR2_STOP_Stop2 = 0x2
	// 1.5 stop bit
	USART_CR2_STOP_Stop1p5 = 0x3
	// Position of CLKEN field.
	USART_CR2_CLKEN_Pos = 0xb
	// Bit mask of CLKEN field.
	USART_CR2_CLKEN_Msk = 0x800
	// Bit CLKEN.
	USART_CR2_CLKEN = 0x800
	// CK pin disabled
	USART_CR2_CLKEN_Disabled = 0x0
	// CK pin enabled
	USART_CR2_CLKEN_Enabled = 0x1
	// Position of CPOL field.
	USART_CR2_CPOL_Pos = 0xa
	// Bit mask of CPOL field.
	USART_CR2_CPOL_Msk = 0x400
	// Bit CPOL.
	USART_CR2_CPOL = 0x400
	// Steady low value on CK pin outside transmission window
	USART_CR2_CPOL_Low = 0x0
	// Steady high value on CK pin outside transmission window
	USART_CR2_CPOL_High = 0x1
	// Position of CPHA field.
	USART_CR2_CPHA_Pos = 0x9
	// Bit mask of CPHA field.
	USART_CR2_CPHA_Msk = 0x200
	// Bit CPHA.
	USART_CR2_CPHA = 0x200
	// The first clock transition is the first data capture edge
	USART_CR2_CPHA_First = 0x0
	// The second clock transition is the first data capture edge
	USART_CR2_CPHA_Second = 0x1
	// Position of LBCL field.
	USART_CR2_LBCL_Pos = 0x8
	// Bit mask of LBCL field.
	USART_CR2_LBCL_Msk = 0x100
	// Bit LBCL.
	USART_CR2_LBCL = 0x100
	// The clock pulse of the last data bit is not output to the CK pin
	USART_CR2_LBCL_NotOutput = 0x0
	// The clock pulse of the last data bit is output to the CK pin
	USART_CR2_LBCL_Output = 0x1
	// Position of LBDIE field.
	USART_CR2_LBDIE_Pos = 0x6
	// Bit mask of LBDIE field.
	USART_CR2_LBDIE_Msk = 0x40
	// Bit LBDIE.
	USART_CR2_LBDIE = 0x40
	// Interrupt is inhibited
	USART_CR2_LBDIE_Disabled = 0x0
	// An interrupt is generated whenever LBDF=1 in the ISR register
	USART_CR2_LBDIE_Enabled = 0x1
	// Position of LBDL field.
	USART_CR2_LBDL_Pos = 0x5
	// Bit mask of LBDL field.
	USART_CR2_LBDL_Msk = 0x20
	// Bit LBDL.
	USART_CR2_LBDL = 0x20
	// 10-bit break detection
	USART_CR2_LBDL_Bit10 = 0x0
	// 11-bit break detection
	USART_CR2_LBDL_Bit11 = 0x1
	// Position of ADDM7 field.
	USART_CR2_ADDM7_Pos = 0x4
	// Bit mask of ADDM7 field.
	USART_CR2_ADDM7_Msk = 0x10
	// Bit ADDM7.
	USART_CR2_ADDM7 = 0x10
	// 4-bit address detection
	USART_CR2_ADDM7_Bit4 = 0x0
	// 7-bit address detection
	USART_CR2_ADDM7_Bit7 = 0x1
	// Position of DIS_NSS field.
	USART_CR2_DIS_NSS_Pos = 0x3
	// Bit mask of DIS_NSS field.
	USART_CR2_DIS_NSS_Msk = 0x8
	// Bit DIS_NSS.
	USART_CR2_DIS_NSS = 0x8
	// Position of SLVEN field.
	USART_CR2_SLVEN_Pos = 0x0
	// Bit mask of SLVEN field.
	USART_CR2_SLVEN_Msk = 0x1
	// Bit SLVEN.
	USART_CR2_SLVEN = 0x1
	// Position of ABRMOD field.
	USART_CR2_ABRMOD_Pos = 0x15
	// Bit mask of ABRMOD field.
	USART_CR2_ABRMOD_Msk = 0x600000
	// Measurement of the start bit is used to detect the baud rate
	USART_CR2_ABRMOD_Start = 0x0
	// Falling edge to falling edge measurement
	USART_CR2_ABRMOD_Edge = 0x1
	// 0x7F frame detection
	USART_CR2_ABRMOD_Frame7F = 0x2
	// 0x55 frame detection
	USART_CR2_ABRMOD_Frame55 = 0x3
	// Position of ADD field.
	USART_CR2_ADD_Pos = 0x18
	// Bit mask of ADD field.
	USART_CR2_ADD_Msk = 0xff000000

	// CR3: Control register 3
	// Position of TXFTCFG field.
	USART_CR3_TXFTCFG_Pos = 0x1d
	// Bit mask of TXFTCFG field.
	USART_CR3_TXFTCFG_Msk = 0xe0000000
	// Position of RXFTIE field.
	USART_CR3_RXFTIE_Pos = 0x1c
	// Bit mask of RXFTIE field.
	USART_CR3_RXFTIE_Msk = 0x10000000
	// Bit RXFTIE.
	USART_CR3_RXFTIE = 0x10000000
	// Position of RXFTCFG field.
	USART_CR3_RXFTCFG_Pos = 0x19
	// Bit mask of RXFTCFG field.
	USART_CR3_RXFTCFG_Msk = 0xe000000
	// Position of TCBGTIE field.
	USART_CR3_TCBGTIE_Pos = 0x18
	// Bit mask of TCBGTIE field.
	USART_CR3_TCBGTIE_Msk = 0x1000000
	// Bit TCBGTIE.
	USART_CR3_TCBGTIE = 0x1000000
	// Position of TXFTIE field.
	USART_CR3_TXFTIE_Pos = 0x17
	// Bit mask of TXFTIE field.
	USART_CR3_TXFTIE_Msk = 0x800000
	// Bit TXFTIE.
	USART_CR3_TXFTIE = 0x800000
	// Position of WUFIE field.
	USART_CR3_WUFIE_Pos = 0x16
	// Bit mask of WUFIE field.
	USART_CR3_WUFIE_Msk = 0x400000
	// Bit WUFIE.
	USART_CR3_WUFIE = 0x400000
	// Interrupt is inhibited
	USART_CR3_WUFIE_Disabled = 0x0
	// An USART interrupt is generated whenever WUF=1 in the ISR register
	USART_CR3_WUFIE_Enabled = 0x1
	// Position of WUS field.
	USART_CR3_WUS_Pos = 0x14
	// Bit mask of WUS field.
	USART_CR3_WUS_Msk = 0x300000
	// WUF active on address match
	USART_CR3_WUS_Address = 0x0
	// WuF active on Start bit detection
	USART_CR3_WUS_Start = 0x2
	// WUF active on RXNE
	USART_CR3_WUS_RXNE = 0x3
	// Position of SCARCNT field.
	USART_CR3_SCARCNT_Pos = 0x11
	// Bit mask of SCARCNT field.
	USART_CR3_SCARCNT_Msk = 0xe0000
	// Position of DEP field.
	USART_CR3_DEP_Pos = 0xf
	// Bit mask of DEP field.
	USART_CR3_DEP_Msk = 0x8000
	// Bit DEP.
	USART_CR3_DEP = 0x8000
	// DE signal is active high
	USART_CR3_DEP_High = 0x0
	// DE signal is active low
	USART_CR3_DEP_Low = 0x1
	// Position of DEM field.
	USART_CR3_DEM_Pos = 0xe
	// Bit mask of DEM field.
	USART_CR3_DEM_Msk = 0x4000
	// Bit DEM.
	USART_CR3_DEM = 0x4000
	// DE function is disabled
	USART_CR3_DEM_Disabled = 0x0
	// The DE signal is output on the RTS pin
	USART_CR3_DEM_Enabled = 0x1
	// Position of DDRE field.
	USART_CR3_DDRE_Pos = 0xd
	// Bit mask of DDRE field.
	USART_CR3_DDRE_Msk = 0x2000
	// Bit DDRE.
	USART_CR3_DDRE = 0x2000
	// DMA is not disabled in case of reception error
	USART_CR3_DDRE_NotDisabled = 0x0
	// DMA is disabled following a reception error
	USART_CR3_DDRE_Disabled = 0x1
	// Position of OVRDIS field.
	USART_CR3_OVRDIS_Pos = 0xc
	// Bit mask of OVRDIS field.
	USART_CR3_OVRDIS_Msk = 0x1000
	// Bit OVRDIS.
	USART_CR3_OVRDIS = 0x1000
	// Overrun Error Flag, ORE, is set when received data is not read before receiving new data
	USART_CR3_OVRDIS_Enabled = 0x0
	// Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register
	USART_CR3_OVRDIS_Disabled = 0x1
	// Position of ONEBIT field.
	USART_CR3_ONEBIT_Pos = 0xb
	// Bit mask of ONEBIT field.
	USART_CR3_ONEBIT_Msk = 0x800
	// Bit ONEBIT.
	USART_CR3_ONEBIT = 0x800
	// Three sample bit method
	USART_CR3_ONEBIT_Sample3 = 0x0
	// One sample bit method
	USART_CR3_ONEBIT_Sample1 = 0x1
	// Position of CTSIE field.
	USART_CR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	USART_CR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	USART_CR3_CTSIE = 0x400
	// Interrupt is inhibited
	USART_CR3_CTSIE_Disabled = 0x0
	// An interrupt is generated whenever CTSIF=1 in the ISR register
	USART_CR3_CTSIE_Enabled = 0x1
	// Position of CTSE field.
	USART_CR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	USART_CR3_CTSE_Msk = 0x200
	// Bit CTSE.
	USART_CR3_CTSE = 0x200
	// CTS hardware flow control disabled
	USART_CR3_CTSE_Disabled = 0x0
	// CTS mode enabled, data is only transmitted when the CTS input is asserted
	USART_CR3_CTSE_Enabled = 0x1
	// Position of RTSE field.
	USART_CR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	USART_CR3_RTSE_Msk = 0x100
	// Bit RTSE.
	USART_CR3_RTSE = 0x100
	// RTS hardware flow control disabled
	USART_CR3_RTSE_Disabled = 0x0
	// RTS output enabled, data is only requested when there is space in the receive buffer
	USART_CR3_RTSE_Enabled = 0x1
	// Position of DMAT field.
	USART_CR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	USART_CR3_DMAT_Msk = 0x80
	// Bit DMAT.
	USART_CR3_DMAT = 0x80
	// DMA mode is disabled for transmission
	USART_CR3_DMAT_Disabled = 0x0
	// DMA mode is enabled for transmission
	USART_CR3_DMAT_Enabled = 0x1
	// Position of DMAR field.
	USART_CR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	USART_CR3_DMAR_Msk = 0x40
	// Bit DMAR.
	USART_CR3_DMAR = 0x40
	// DMA mode is disabled for reception
	USART_CR3_DMAR_Disabled = 0x0
	// DMA mode is enabled for reception
	USART_CR3_DMAR_Enabled = 0x1
	// Position of SCEN field.
	USART_CR3_SCEN_Pos = 0x5
	// Bit mask of SCEN field.
	USART_CR3_SCEN_Msk = 0x20
	// Bit SCEN.
	USART_CR3_SCEN = 0x20
	// Smartcard Mode disabled
	USART_CR3_SCEN_Disabled = 0x0
	// Smartcard Mode enabled
	USART_CR3_SCEN_Enabled = 0x1
	// Position of NACK field.
	USART_CR3_NACK_Pos = 0x4
	// Bit mask of NACK field.
	USART_CR3_NACK_Msk = 0x10
	// Bit NACK.
	USART_CR3_NACK = 0x10
	// NACK transmission in case of parity error is disabled
	USART_CR3_NACK_Disabled = 0x0
	// NACK transmission during parity error is enabled
	USART_CR3_NACK_Enabled = 0x1
	// Position of HDSEL field.
	USART_CR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	USART_CR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	USART_CR3_HDSEL = 0x8
	// Half duplex mode is not selected
	USART_CR3_HDSEL_NotSelected = 0x0
	// Half duplex mode is selected
	USART_CR3_HDSEL_Selected = 0x1
	// Position of IRLP field.
	USART_CR3_IRLP_Pos = 0x2
	// Bit mask of IRLP field.
	USART_CR3_IRLP_Msk = 0x4
	// Bit IRLP.
	USART_CR3_IRLP = 0x4
	// Normal mode
	USART_CR3_IRLP_Normal = 0x0
	// Low-power mode
	USART_CR3_IRLP_LowPower = 0x1
	// Position of IREN field.
	USART_CR3_IREN_Pos = 0x1
	// Bit mask of IREN field.
	USART_CR3_IREN_Msk = 0x2
	// Bit IREN.
	USART_CR3_IREN = 0x2
	// IrDA disabled
	USART_CR3_IREN_Disabled = 0x0
	// IrDA enabled
	USART_CR3_IREN_Enabled = 0x1
	// Position of EIE field.
	USART_CR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	USART_CR3_EIE_Msk = 0x1
	// Bit EIE.
	USART_CR3_EIE = 0x1
	// Interrupt is inhibited
	USART_CR3_EIE_Disabled = 0x0
	// An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register
	USART_CR3_EIE_Enabled = 0x1

	// BRR: Baud rate register
	// Position of BRR field.
	USART_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	USART_BRR_BRR_Msk = 0xffff

	// GTPR: Guard time and prescaler register
	// Position of GT field.
	USART_GTPR_GT_Pos = 0x8
	// Bit mask of GT field.
	USART_GTPR_GT_Msk = 0xff00
	// Position of PSC field.
	USART_GTPR_PSC_Pos = 0x0
	// Bit mask of PSC field.
	USART_GTPR_PSC_Msk = 0xff

	// RTOR: Receiver timeout register
	// Position of BLEN field.
	USART_RTOR_BLEN_Pos = 0x18
	// Bit mask of BLEN field.
	USART_RTOR_BLEN_Msk = 0xff000000
	// Position of RTO field.
	USART_RTOR_RTO_Pos = 0x0
	// Bit mask of RTO field.
	USART_RTOR_RTO_Msk = 0xffffff

	// RQR: Request register
	// Position of TXFRQ field.
	USART_RQR_TXFRQ_Pos = 0x4
	// Bit mask of TXFRQ field.
	USART_RQR_TXFRQ_Msk = 0x10
	// Bit TXFRQ.
	USART_RQR_TXFRQ = 0x10
	// Set the TXE flags. This allows to discard the transmit data
	USART_RQR_TXFRQ_Discard = 0x1
	// Position of RXFRQ field.
	USART_RQR_RXFRQ_Pos = 0x3
	// Bit mask of RXFRQ field.
	USART_RQR_RXFRQ_Msk = 0x8
	// Bit RXFRQ.
	USART_RQR_RXFRQ = 0x8
	// clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition
	USART_RQR_RXFRQ_Discard = 0x1
	// Position of MMRQ field.
	USART_RQR_MMRQ_Pos = 0x2
	// Bit mask of MMRQ field.
	USART_RQR_MMRQ_Msk = 0x4
	// Bit MMRQ.
	USART_RQR_MMRQ = 0x4
	// Puts the USART in mute mode and sets the RWU flag
	USART_RQR_MMRQ_Mute = 0x1
	// Position of SBKRQ field.
	USART_RQR_SBKRQ_Pos = 0x1
	// Bit mask of SBKRQ field.
	USART_RQR_SBKRQ_Msk = 0x2
	// Bit SBKRQ.
	USART_RQR_SBKRQ = 0x2
	// sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available
	USART_RQR_SBKRQ_Break = 0x1
	// Position of ABRRQ field.
	USART_RQR_ABRRQ_Pos = 0x0
	// Bit mask of ABRRQ field.
	USART_RQR_ABRRQ_Msk = 0x1
	// Bit ABRRQ.
	USART_RQR_ABRRQ = 0x1
	// resets the ABRF flag in the USART_ISR and request an automatic baud rate measurement on the next received data frame
	USART_RQR_ABRRQ_Request = 0x1

	// ISR: Interrupt & status register
	// Position of TXFT field.
	USART_ISR_TXFT_Pos = 0x1b
	// Bit mask of TXFT field.
	USART_ISR_TXFT_Msk = 0x8000000
	// Bit TXFT.
	USART_ISR_TXFT = 0x8000000
	// Position of RXFT field.
	USART_ISR_RXFT_Pos = 0x1a
	// Bit mask of RXFT field.
	USART_ISR_RXFT_Msk = 0x4000000
	// Bit RXFT.
	USART_ISR_RXFT = 0x4000000
	// Position of TCBGT field.
	USART_ISR_TCBGT_Pos = 0x19
	// Bit mask of TCBGT field.
	USART_ISR_TCBGT_Msk = 0x2000000
	// Bit TCBGT.
	USART_ISR_TCBGT = 0x2000000
	// Position of RXFF field.
	USART_ISR_RXFF_Pos = 0x18
	// Bit mask of RXFF field.
	USART_ISR_RXFF_Msk = 0x1000000
	// Bit RXFF.
	USART_ISR_RXFF = 0x1000000
	// Position of TXFE field.
	USART_ISR_TXFE_Pos = 0x17
	// Bit mask of TXFE field.
	USART_ISR_TXFE_Msk = 0x800000
	// Bit TXFE.
	USART_ISR_TXFE = 0x800000
	// Position of REACK field.
	USART_ISR_REACK_Pos = 0x16
	// Bit mask of REACK field.
	USART_ISR_REACK_Msk = 0x400000
	// Bit REACK.
	USART_ISR_REACK = 0x400000
	// Position of TEACK field.
	USART_ISR_TEACK_Pos = 0x15
	// Bit mask of TEACK field.
	USART_ISR_TEACK_Msk = 0x200000
	// Bit TEACK.
	USART_ISR_TEACK = 0x200000
	// Position of WUF field.
	USART_ISR_WUF_Pos = 0x14
	// Bit mask of WUF field.
	USART_ISR_WUF_Msk = 0x100000
	// Bit WUF.
	USART_ISR_WUF = 0x100000
	// Position of RWU field.
	USART_ISR_RWU_Pos = 0x13
	// Bit mask of RWU field.
	USART_ISR_RWU_Msk = 0x80000
	// Bit RWU.
	USART_ISR_RWU = 0x80000
	// Position of SBKF field.
	USART_ISR_SBKF_Pos = 0x12
	// Bit mask of SBKF field.
	USART_ISR_SBKF_Msk = 0x40000
	// Bit SBKF.
	USART_ISR_SBKF = 0x40000
	// Position of CMF field.
	USART_ISR_CMF_Pos = 0x11
	// Bit mask of CMF field.
	USART_ISR_CMF_Msk = 0x20000
	// Bit CMF.
	USART_ISR_CMF = 0x20000
	// Position of BUSY field.
	USART_ISR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	USART_ISR_BUSY_Msk = 0x10000
	// Bit BUSY.
	USART_ISR_BUSY = 0x10000
	// Position of ABRF field.
	USART_ISR_ABRF_Pos = 0xf
	// Bit mask of ABRF field.
	USART_ISR_ABRF_Msk = 0x8000
	// Bit ABRF.
	USART_ISR_ABRF = 0x8000
	// Position of ABRE field.
	USART_ISR_ABRE_Pos = 0xe
	// Bit mask of ABRE field.
	USART_ISR_ABRE_Msk = 0x4000
	// Bit ABRE.
	USART_ISR_ABRE = 0x4000
	// Position of UDR field.
	USART_ISR_UDR_Pos = 0xd
	// Bit mask of UDR field.
	USART_ISR_UDR_Msk = 0x2000
	// Bit UDR.
	USART_ISR_UDR = 0x2000
	// Position of EOBF field.
	USART_ISR_EOBF_Pos = 0xc
	// Bit mask of EOBF field.
	USART_ISR_EOBF_Msk = 0x1000
	// Bit EOBF.
	USART_ISR_EOBF = 0x1000
	// Position of RTOF field.
	USART_ISR_RTOF_Pos = 0xb
	// Bit mask of RTOF field.
	USART_ISR_RTOF_Msk = 0x800
	// Bit RTOF.
	USART_ISR_RTOF = 0x800
	// Position of CTS field.
	USART_ISR_CTS_Pos = 0xa
	// Bit mask of CTS field.
	USART_ISR_CTS_Msk = 0x400
	// Bit CTS.
	USART_ISR_CTS = 0x400
	// Position of CTSIF field.
	USART_ISR_CTSIF_Pos = 0x9
	// Bit mask of CTSIF field.
	USART_ISR_CTSIF_Msk = 0x200
	// Bit CTSIF.
	USART_ISR_CTSIF = 0x200
	// Position of LBDF field.
	USART_ISR_LBDF_Pos = 0x8
	// Bit mask of LBDF field.
	USART_ISR_LBDF_Msk = 0x100
	// Bit LBDF.
	USART_ISR_LBDF = 0x100
	// Position of TXE field.
	USART_ISR_TXE_Pos = 0x7
	// Bit mask of TXE field.
	USART_ISR_TXE_Msk = 0x80
	// Bit TXE.
	USART_ISR_TXE = 0x80
	// Position of TC field.
	USART_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	USART_ISR_TC_Msk = 0x40
	// Bit TC.
	USART_ISR_TC = 0x40
	// Position of RXNE field.
	USART_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	USART_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	USART_ISR_RXNE = 0x20
	// Position of IDLE field.
	USART_ISR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	USART_ISR_IDLE_Msk = 0x10
	// Bit IDLE.
	USART_ISR_IDLE = 0x10
	// Position of ORE field.
	USART_ISR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	USART_ISR_ORE_Msk = 0x8
	// Bit ORE.
	USART_ISR_ORE = 0x8
	// Position of NF field.
	USART_ISR_NF_Pos = 0x2
	// Bit mask of NF field.
	USART_ISR_NF_Msk = 0x4
	// Bit NF.
	USART_ISR_NF = 0x4
	// Position of FE field.
	USART_ISR_FE_Pos = 0x1
	// Bit mask of FE field.
	USART_ISR_FE_Msk = 0x2
	// Bit FE.
	USART_ISR_FE = 0x2
	// Position of PE field.
	USART_ISR_PE_Pos = 0x0
	// Bit mask of PE field.
	USART_ISR_PE_Msk = 0x1
	// Bit PE.
	USART_ISR_PE = 0x1

	// ICR: Interrupt flag clear register
	// Position of WUCF field.
	USART_ICR_WUCF_Pos = 0x14
	// Bit mask of WUCF field.
	USART_ICR_WUCF_Msk = 0x100000
	// Bit WUCF.
	USART_ICR_WUCF = 0x100000
	// Clears the WUF flag in the ISR register
	USART_ICR_WUCF_Clear = 0x1
	// Position of CMCF field.
	USART_ICR_CMCF_Pos = 0x11
	// Bit mask of CMCF field.
	USART_ICR_CMCF_Msk = 0x20000
	// Bit CMCF.
	USART_ICR_CMCF = 0x20000
	// Clears the CMF flag in the ISR register
	USART_ICR_CMCF_Clear = 0x1
	// Position of UDRCF field.
	USART_ICR_UDRCF_Pos = 0xd
	// Bit mask of UDRCF field.
	USART_ICR_UDRCF_Msk = 0x2000
	// Bit UDRCF.
	USART_ICR_UDRCF = 0x2000
	// Position of EOBCF field.
	USART_ICR_EOBCF_Pos = 0xc
	// Bit mask of EOBCF field.
	USART_ICR_EOBCF_Msk = 0x1000
	// Bit EOBCF.
	USART_ICR_EOBCF = 0x1000
	// Clears the EOBF flag in the ISR register
	USART_ICR_EOBCF_Clear = 0x1
	// Position of RTOCF field.
	USART_ICR_RTOCF_Pos = 0xb
	// Bit mask of RTOCF field.
	USART_ICR_RTOCF_Msk = 0x800
	// Bit RTOCF.
	USART_ICR_RTOCF = 0x800
	// Clears the RTOF flag in the ISR register
	USART_ICR_RTOCF_Clear = 0x1
	// Position of CTSCF field.
	USART_ICR_CTSCF_Pos = 0x9
	// Bit mask of CTSCF field.
	USART_ICR_CTSCF_Msk = 0x200
	// Bit CTSCF.
	USART_ICR_CTSCF = 0x200
	// Clears the CTSIF flag in the ISR register
	USART_ICR_CTSCF_Clear = 0x1
	// Position of LBDCF field.
	USART_ICR_LBDCF_Pos = 0x8
	// Bit mask of LBDCF field.
	USART_ICR_LBDCF_Msk = 0x100
	// Bit LBDCF.
	USART_ICR_LBDCF = 0x100
	// Clears the LBDF flag in the ISR register
	USART_ICR_LBDCF_Clear = 0x1
	// Position of TCBGTC field.
	USART_ICR_TCBGTC_Pos = 0x7
	// Bit mask of TCBGTC field.
	USART_ICR_TCBGTC_Msk = 0x80
	// Bit TCBGTC.
	USART_ICR_TCBGTC = 0x80
	// Position of TCCF field.
	USART_ICR_TCCF_Pos = 0x6
	// Bit mask of TCCF field.
	USART_ICR_TCCF_Msk = 0x40
	// Bit TCCF.
	USART_ICR_TCCF = 0x40
	// Clears the TC flag in the ISR register
	USART_ICR_TCCF_Clear = 0x1
	// Position of TXFECF field.
	USART_ICR_TXFECF_Pos = 0x5
	// Bit mask of TXFECF field.
	USART_ICR_TXFECF_Msk = 0x20
	// Bit TXFECF.
	USART_ICR_TXFECF = 0x20
	// Position of IDLECF field.
	USART_ICR_IDLECF_Pos = 0x4
	// Bit mask of IDLECF field.
	USART_ICR_IDLECF_Msk = 0x10
	// Bit IDLECF.
	USART_ICR_IDLECF = 0x10
	// Clears the IDLE flag in the ISR register
	USART_ICR_IDLECF_Clear = 0x1
	// Position of ORECF field.
	USART_ICR_ORECF_Pos = 0x3
	// Bit mask of ORECF field.
	USART_ICR_ORECF_Msk = 0x8
	// Bit ORECF.
	USART_ICR_ORECF = 0x8
	// Clears the ORE flag in the ISR register
	USART_ICR_ORECF_Clear = 0x1
	// Position of NCF field.
	USART_ICR_NCF_Pos = 0x2
	// Bit mask of NCF field.
	USART_ICR_NCF_Msk = 0x4
	// Bit NCF.
	USART_ICR_NCF = 0x4
	// Clears the NF flag in the ISR register
	USART_ICR_NCF_Clear = 0x1
	// Position of FECF field.
	USART_ICR_FECF_Pos = 0x1
	// Bit mask of FECF field.
	USART_ICR_FECF_Msk = 0x2
	// Bit FECF.
	USART_ICR_FECF = 0x2
	// Clears the FE flag in the ISR register
	USART_ICR_FECF_Clear = 0x1
	// Position of PECF field.
	USART_ICR_PECF_Pos = 0x0
	// Bit mask of PECF field.
	USART_ICR_PECF_Msk = 0x1
	// Bit PECF.
	USART_ICR_PECF = 0x1
	// Clears the PE flag in the ISR register
	USART_ICR_PECF_Clear = 0x1

	// RDR: Receive data register
	// Position of RDR field.
	USART_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	USART_RDR_RDR_Msk = 0x1ff

	// TDR: Transmit data register
	// Position of TDR field.
	USART_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	USART_TDR_TDR_Msk = 0x1ff

	// PRESC: USART prescaler register
	// Position of PRESCALER field.
	USART_PRESC_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	USART_PRESC_PRESCALER_Msk = 0xf
)

// Constants for VREFBUF: VREFBUF
const (
	// CSR: VREFBUF control and status register
	// Position of ENVR field.
	VREFBUF_CSR_ENVR_Pos = 0x0
	// Bit mask of ENVR field.
	VREFBUF_CSR_ENVR_Msk = 0x1
	// Bit ENVR.
	VREFBUF_CSR_ENVR = 0x1
	// Position of HIZ field.
	VREFBUF_CSR_HIZ_Pos = 0x1
	// Bit mask of HIZ field.
	VREFBUF_CSR_HIZ_Msk = 0x2
	// Bit HIZ.
	VREFBUF_CSR_HIZ = 0x2
	// Position of VRR field.
	VREFBUF_CSR_VRR_Pos = 0x3
	// Bit mask of VRR field.
	VREFBUF_CSR_VRR_Msk = 0x8
	// Bit VRR.
	VREFBUF_CSR_VRR = 0x8
	// Position of VRS field.
	VREFBUF_CSR_VRS_Pos = 0x4
	// Bit mask of VRS field.
	VREFBUF_CSR_VRS_Msk = 0x70

	// CCR: VREFBUF calibration control register
	// Position of TRIM field.
	VREFBUF_CCR_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	VREFBUF_CCR_TRIM_Msk = 0x3f
)

// Constants for WWDG1: WWDG
const (
	// CR: Control register
	// Position of T field.
	WWDG_CR_T_Pos = 0x0
	// Bit mask of T field.
	WWDG_CR_T_Msk = 0x7f
	// Position of WDGA field.
	WWDG_CR_WDGA_Pos = 0x7
	// Bit mask of WDGA field.
	WWDG_CR_WDGA_Msk = 0x80
	// Bit WDGA.
	WWDG_CR_WDGA = 0x80
	// Watchdog disabled
	WWDG_CR_WDGA_Disabled = 0x0
	// Watchdog enabled
	WWDG_CR_WDGA_Enabled = 0x1

	// CFR: Configuration register
	// Position of W field.
	WWDG_CFR_W_Pos = 0x0
	// Bit mask of W field.
	WWDG_CFR_W_Msk = 0x7f
	// Position of EWI field.
	WWDG_CFR_EWI_Pos = 0x9
	// Bit mask of EWI field.
	WWDG_CFR_EWI_Msk = 0x200
	// Bit EWI.
	WWDG_CFR_EWI = 0x200
	// interrupt occurs whenever the counter reaches the value 0x40
	WWDG_CFR_EWI_Enable = 0x1
	// Position of WDGTB field.
	WWDG_CFR_WDGTB_Pos = 0xb
	// Bit mask of WDGTB field.
	WWDG_CFR_WDGTB_Msk = 0x3800
	// Counter clock (PCLK1 div 4096) div 16
	WWDG_CFR_WDGTB_Div16 = 0x4
	// Counter clock (PCLK1 div 4096) div 32
	WWDG_CFR_WDGTB_Div32 = 0x5
	// Counter clock (PCLK1 div 4096) div 64
	WWDG_CFR_WDGTB_Div64 = 0x6
	// Counter clock (PCLK1 div 4096) div 128
	WWDG_CFR_WDGTB_Div128 = 0x7
	// Counter clock (PCLK1 div 4096) div 1
	WWDG_CFR_WDGTB_Div1 = 0x0
	// Counter clock (PCLK1 div 4096) div 2
	WWDG_CFR_WDGTB_Div2 = 0x1
	// Counter clock (PCLK1 div 4096) div 4
	WWDG_CFR_WDGTB_Div4 = 0x2
	// Counter clock (PCLK1 div 4096) div 8
	WWDG_CFR_WDGTB_Div8 = 0x3

	// SR: Status register
	// Position of EWIF field.
	WWDG_SR_EWIF_Pos = 0x0
	// Bit mask of EWIF field.
	WWDG_SR_EWIF_Msk = 0x1
	// Bit EWIF.
	WWDG_SR_EWIF = 0x1
	// The EWI Interrupt Service Routine has been triggered
	WWDG_SR_EWIF_Pending = 0x1
	// The EWI Interrupt Service Routine has been serviced
	WWDG_SR_EWIF_Finished = 0x0
)

// Constants for BDMA: Basic Direct Memory Access
const (
	// ISR: Interrupt status register
	// Position of TEIF7 field.
	BDMA_ISR_TEIF7_Pos = 0x1f
	// Bit mask of TEIF7 field.
	BDMA_ISR_TEIF7_Msk = 0x80000000
	// Bit TEIF7.
	BDMA_ISR_TEIF7 = 0x80000000
	// No transfer error on channel x
	BDMA_ISR_TEIF7_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF7_Error = 0x1
	// Position of HTIF7 field.
	BDMA_ISR_HTIF7_Pos = 0x1e
	// Bit mask of HTIF7 field.
	BDMA_ISR_HTIF7_Msk = 0x40000000
	// Bit HTIF7.
	BDMA_ISR_HTIF7 = 0x40000000
	// No half transfer event on channel x
	BDMA_ISR_HTIF7_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF7_Half = 0x1
	// Position of TCIF7 field.
	BDMA_ISR_TCIF7_Pos = 0x1d
	// Bit mask of TCIF7 field.
	BDMA_ISR_TCIF7_Msk = 0x20000000
	// Bit TCIF7.
	BDMA_ISR_TCIF7 = 0x20000000
	// No transfer complete event on channel x
	BDMA_ISR_TCIF7_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF7_Complete = 0x1
	// Position of GIF7 field.
	BDMA_ISR_GIF7_Pos = 0x1c
	// Bit mask of GIF7 field.
	BDMA_ISR_GIF7_Msk = 0x10000000
	// Bit GIF7.
	BDMA_ISR_GIF7 = 0x10000000
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF7_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF7_Event = 0x1
	// Position of TEIF6 field.
	BDMA_ISR_TEIF6_Pos = 0x1b
	// Bit mask of TEIF6 field.
	BDMA_ISR_TEIF6_Msk = 0x8000000
	// Bit TEIF6.
	BDMA_ISR_TEIF6 = 0x8000000
	// No transfer error on channel x
	BDMA_ISR_TEIF6_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF6_Error = 0x1
	// Position of HTIF6 field.
	BDMA_ISR_HTIF6_Pos = 0x1a
	// Bit mask of HTIF6 field.
	BDMA_ISR_HTIF6_Msk = 0x4000000
	// Bit HTIF6.
	BDMA_ISR_HTIF6 = 0x4000000
	// No half transfer event on channel x
	BDMA_ISR_HTIF6_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF6_Half = 0x1
	// Position of TCIF6 field.
	BDMA_ISR_TCIF6_Pos = 0x19
	// Bit mask of TCIF6 field.
	BDMA_ISR_TCIF6_Msk = 0x2000000
	// Bit TCIF6.
	BDMA_ISR_TCIF6 = 0x2000000
	// No transfer complete event on channel x
	BDMA_ISR_TCIF6_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF6_Complete = 0x1
	// Position of GIF6 field.
	BDMA_ISR_GIF6_Pos = 0x18
	// Bit mask of GIF6 field.
	BDMA_ISR_GIF6_Msk = 0x1000000
	// Bit GIF6.
	BDMA_ISR_GIF6 = 0x1000000
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF6_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF6_Event = 0x1
	// Position of TEIF5 field.
	BDMA_ISR_TEIF5_Pos = 0x17
	// Bit mask of TEIF5 field.
	BDMA_ISR_TEIF5_Msk = 0x800000
	// Bit TEIF5.
	BDMA_ISR_TEIF5 = 0x800000
	// No transfer error on channel x
	BDMA_ISR_TEIF5_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF5_Error = 0x1
	// Position of HTIF5 field.
	BDMA_ISR_HTIF5_Pos = 0x16
	// Bit mask of HTIF5 field.
	BDMA_ISR_HTIF5_Msk = 0x400000
	// Bit HTIF5.
	BDMA_ISR_HTIF5 = 0x400000
	// No half transfer event on channel x
	BDMA_ISR_HTIF5_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF5_Half = 0x1
	// Position of TCIF5 field.
	BDMA_ISR_TCIF5_Pos = 0x15
	// Bit mask of TCIF5 field.
	BDMA_ISR_TCIF5_Msk = 0x200000
	// Bit TCIF5.
	BDMA_ISR_TCIF5 = 0x200000
	// No transfer complete event on channel x
	BDMA_ISR_TCIF5_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF5_Complete = 0x1
	// Position of GIF5 field.
	BDMA_ISR_GIF5_Pos = 0x14
	// Bit mask of GIF5 field.
	BDMA_ISR_GIF5_Msk = 0x100000
	// Bit GIF5.
	BDMA_ISR_GIF5 = 0x100000
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF5_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF5_Event = 0x1
	// Position of TEIF4 field.
	BDMA_ISR_TEIF4_Pos = 0x13
	// Bit mask of TEIF4 field.
	BDMA_ISR_TEIF4_Msk = 0x80000
	// Bit TEIF4.
	BDMA_ISR_TEIF4 = 0x80000
	// No transfer error on channel x
	BDMA_ISR_TEIF4_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF4_Error = 0x1
	// Position of HTIF4 field.
	BDMA_ISR_HTIF4_Pos = 0x12
	// Bit mask of HTIF4 field.
	BDMA_ISR_HTIF4_Msk = 0x40000
	// Bit HTIF4.
	BDMA_ISR_HTIF4 = 0x40000
	// No half transfer event on channel x
	BDMA_ISR_HTIF4_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF4_Half = 0x1
	// Position of TCIF4 field.
	BDMA_ISR_TCIF4_Pos = 0x11
	// Bit mask of TCIF4 field.
	BDMA_ISR_TCIF4_Msk = 0x20000
	// Bit TCIF4.
	BDMA_ISR_TCIF4 = 0x20000
	// No transfer complete event on channel x
	BDMA_ISR_TCIF4_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF4_Complete = 0x1
	// Position of GIF4 field.
	BDMA_ISR_GIF4_Pos = 0x10
	// Bit mask of GIF4 field.
	BDMA_ISR_GIF4_Msk = 0x10000
	// Bit GIF4.
	BDMA_ISR_GIF4 = 0x10000
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF4_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF4_Event = 0x1
	// Position of TEIF3 field.
	BDMA_ISR_TEIF3_Pos = 0xf
	// Bit mask of TEIF3 field.
	BDMA_ISR_TEIF3_Msk = 0x8000
	// Bit TEIF3.
	BDMA_ISR_TEIF3 = 0x8000
	// No transfer error on channel x
	BDMA_ISR_TEIF3_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF3_Error = 0x1
	// Position of HTIF3 field.
	BDMA_ISR_HTIF3_Pos = 0xe
	// Bit mask of HTIF3 field.
	BDMA_ISR_HTIF3_Msk = 0x4000
	// Bit HTIF3.
	BDMA_ISR_HTIF3 = 0x4000
	// No half transfer event on channel x
	BDMA_ISR_HTIF3_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF3_Half = 0x1
	// Position of TCIF3 field.
	BDMA_ISR_TCIF3_Pos = 0xd
	// Bit mask of TCIF3 field.
	BDMA_ISR_TCIF3_Msk = 0x2000
	// Bit TCIF3.
	BDMA_ISR_TCIF3 = 0x2000
	// No transfer complete event on channel x
	BDMA_ISR_TCIF3_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF3_Complete = 0x1
	// Position of GIF3 field.
	BDMA_ISR_GIF3_Pos = 0xc
	// Bit mask of GIF3 field.
	BDMA_ISR_GIF3_Msk = 0x1000
	// Bit GIF3.
	BDMA_ISR_GIF3 = 0x1000
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF3_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF3_Event = 0x1
	// Position of TEIF2 field.
	BDMA_ISR_TEIF2_Pos = 0xb
	// Bit mask of TEIF2 field.
	BDMA_ISR_TEIF2_Msk = 0x800
	// Bit TEIF2.
	BDMA_ISR_TEIF2 = 0x800
	// No transfer error on channel x
	BDMA_ISR_TEIF2_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF2_Error = 0x1
	// Position of HTIF2 field.
	BDMA_ISR_HTIF2_Pos = 0xa
	// Bit mask of HTIF2 field.
	BDMA_ISR_HTIF2_Msk = 0x400
	// Bit HTIF2.
	BDMA_ISR_HTIF2 = 0x400
	// No half transfer event on channel x
	BDMA_ISR_HTIF2_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF2_Half = 0x1
	// Position of TCIF2 field.
	BDMA_ISR_TCIF2_Pos = 0x9
	// Bit mask of TCIF2 field.
	BDMA_ISR_TCIF2_Msk = 0x200
	// Bit TCIF2.
	BDMA_ISR_TCIF2 = 0x200
	// No transfer complete event on channel x
	BDMA_ISR_TCIF2_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF2_Complete = 0x1
	// Position of GIF2 field.
	BDMA_ISR_GIF2_Pos = 0x8
	// Bit mask of GIF2 field.
	BDMA_ISR_GIF2_Msk = 0x100
	// Bit GIF2.
	BDMA_ISR_GIF2 = 0x100
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF2_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF2_Event = 0x1
	// Position of TEIF1 field.
	BDMA_ISR_TEIF1_Pos = 0x7
	// Bit mask of TEIF1 field.
	BDMA_ISR_TEIF1_Msk = 0x80
	// Bit TEIF1.
	BDMA_ISR_TEIF1 = 0x80
	// No transfer error on channel x
	BDMA_ISR_TEIF1_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF1_Error = 0x1
	// Position of HTIF1 field.
	BDMA_ISR_HTIF1_Pos = 0x6
	// Bit mask of HTIF1 field.
	BDMA_ISR_HTIF1_Msk = 0x40
	// Bit HTIF1.
	BDMA_ISR_HTIF1 = 0x40
	// No half transfer event on channel x
	BDMA_ISR_HTIF1_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF1_Half = 0x1
	// Position of TCIF1 field.
	BDMA_ISR_TCIF1_Pos = 0x5
	// Bit mask of TCIF1 field.
	BDMA_ISR_TCIF1_Msk = 0x20
	// Bit TCIF1.
	BDMA_ISR_TCIF1 = 0x20
	// No transfer complete event on channel x
	BDMA_ISR_TCIF1_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF1_Complete = 0x1
	// Position of GIF1 field.
	BDMA_ISR_GIF1_Pos = 0x4
	// Bit mask of GIF1 field.
	BDMA_ISR_GIF1_Msk = 0x10
	// Bit GIF1.
	BDMA_ISR_GIF1 = 0x10
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF1_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF1_Event = 0x1
	// Position of TEIF0 field.
	BDMA_ISR_TEIF0_Pos = 0x3
	// Bit mask of TEIF0 field.
	BDMA_ISR_TEIF0_Msk = 0x8
	// Bit TEIF0.
	BDMA_ISR_TEIF0 = 0x8
	// No transfer error on channel x
	BDMA_ISR_TEIF0_NoError = 0x0
	// A transfer error occurred on channel x
	BDMA_ISR_TEIF0_Error = 0x1
	// Position of HTIF0 field.
	BDMA_ISR_HTIF0_Pos = 0x2
	// Bit mask of HTIF0 field.
	BDMA_ISR_HTIF0_Msk = 0x4
	// Bit HTIF0.
	BDMA_ISR_HTIF0 = 0x4
	// No half transfer event on channel x
	BDMA_ISR_HTIF0_NotHalf = 0x0
	// A half transfer event occurred on channel x
	BDMA_ISR_HTIF0_Half = 0x1
	// Position of TCIF0 field.
	BDMA_ISR_TCIF0_Pos = 0x1
	// Bit mask of TCIF0 field.
	BDMA_ISR_TCIF0_Msk = 0x2
	// Bit TCIF0.
	BDMA_ISR_TCIF0 = 0x2
	// No transfer complete event on channel x
	BDMA_ISR_TCIF0_NotComplete = 0x0
	// A transfer complete event occurred on channel x
	BDMA_ISR_TCIF0_Complete = 0x1
	// Position of GIF0 field.
	BDMA_ISR_GIF0_Pos = 0x0
	// Bit mask of GIF0 field.
	BDMA_ISR_GIF0_Msk = 0x1
	// Bit GIF0.
	BDMA_ISR_GIF0 = 0x1
	// No TE, HT or TC event on channel x
	BDMA_ISR_GIF0_NoEvent = 0x0
	// A TE, HT or TC event occurred on channel x
	BDMA_ISR_GIF0_Event = 0x1

	// IFCR: Interrupt flag clear register
	// Position of CTEIF7 field.
	BDMA_IFCR_CTEIF7_Pos = 0x1f
	// Bit mask of CTEIF7 field.
	BDMA_IFCR_CTEIF7_Msk = 0x80000000
	// Bit CTEIF7.
	BDMA_IFCR_CTEIF7 = 0x80000000
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF7_Clear = 0x1
	// Position of CHTIF7 field.
	BDMA_IFCR_CHTIF7_Pos = 0x1e
	// Bit mask of CHTIF7 field.
	BDMA_IFCR_CHTIF7_Msk = 0x40000000
	// Bit CHTIF7.
	BDMA_IFCR_CHTIF7 = 0x40000000
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF7_Clear = 0x1
	// Position of CTCIF7 field.
	BDMA_IFCR_CTCIF7_Pos = 0x1d
	// Bit mask of CTCIF7 field.
	BDMA_IFCR_CTCIF7_Msk = 0x20000000
	// Bit CTCIF7.
	BDMA_IFCR_CTCIF7 = 0x20000000
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF7_Clear = 0x1
	// Position of CGIF7 field.
	BDMA_IFCR_CGIF7_Pos = 0x1c
	// Bit mask of CGIF7 field.
	BDMA_IFCR_CGIF7_Msk = 0x10000000
	// Bit CGIF7.
	BDMA_IFCR_CGIF7 = 0x10000000
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF7_Clear = 0x1
	// Position of CTEIF6 field.
	BDMA_IFCR_CTEIF6_Pos = 0x1b
	// Bit mask of CTEIF6 field.
	BDMA_IFCR_CTEIF6_Msk = 0x8000000
	// Bit CTEIF6.
	BDMA_IFCR_CTEIF6 = 0x8000000
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF6_Clear = 0x1
	// Position of CHTIF6 field.
	BDMA_IFCR_CHTIF6_Pos = 0x1a
	// Bit mask of CHTIF6 field.
	BDMA_IFCR_CHTIF6_Msk = 0x4000000
	// Bit CHTIF6.
	BDMA_IFCR_CHTIF6 = 0x4000000
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF6_Clear = 0x1
	// Position of CTCIF6 field.
	BDMA_IFCR_CTCIF6_Pos = 0x19
	// Bit mask of CTCIF6 field.
	BDMA_IFCR_CTCIF6_Msk = 0x2000000
	// Bit CTCIF6.
	BDMA_IFCR_CTCIF6 = 0x2000000
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF6_Clear = 0x1
	// Position of CGIF6 field.
	BDMA_IFCR_CGIF6_Pos = 0x18
	// Bit mask of CGIF6 field.
	BDMA_IFCR_CGIF6_Msk = 0x1000000
	// Bit CGIF6.
	BDMA_IFCR_CGIF6 = 0x1000000
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF6_Clear = 0x1
	// Position of CTEIF5 field.
	BDMA_IFCR_CTEIF5_Pos = 0x17
	// Bit mask of CTEIF5 field.
	BDMA_IFCR_CTEIF5_Msk = 0x800000
	// Bit CTEIF5.
	BDMA_IFCR_CTEIF5 = 0x800000
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF5_Clear = 0x1
	// Position of CHTIF5 field.
	BDMA_IFCR_CHTIF5_Pos = 0x16
	// Bit mask of CHTIF5 field.
	BDMA_IFCR_CHTIF5_Msk = 0x400000
	// Bit CHTIF5.
	BDMA_IFCR_CHTIF5 = 0x400000
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF5_Clear = 0x1
	// Position of CTCIF5 field.
	BDMA_IFCR_CTCIF5_Pos = 0x15
	// Bit mask of CTCIF5 field.
	BDMA_IFCR_CTCIF5_Msk = 0x200000
	// Bit CTCIF5.
	BDMA_IFCR_CTCIF5 = 0x200000
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF5_Clear = 0x1
	// Position of CGIF5 field.
	BDMA_IFCR_CGIF5_Pos = 0x14
	// Bit mask of CGIF5 field.
	BDMA_IFCR_CGIF5_Msk = 0x100000
	// Bit CGIF5.
	BDMA_IFCR_CGIF5 = 0x100000
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF5_Clear = 0x1
	// Position of CTEIF4 field.
	BDMA_IFCR_CTEIF4_Pos = 0x13
	// Bit mask of CTEIF4 field.
	BDMA_IFCR_CTEIF4_Msk = 0x80000
	// Bit CTEIF4.
	BDMA_IFCR_CTEIF4 = 0x80000
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF4_Clear = 0x1
	// Position of CHTIF4 field.
	BDMA_IFCR_CHTIF4_Pos = 0x12
	// Bit mask of CHTIF4 field.
	BDMA_IFCR_CHTIF4_Msk = 0x40000
	// Bit CHTIF4.
	BDMA_IFCR_CHTIF4 = 0x40000
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF4_Clear = 0x1
	// Position of CTCIF4 field.
	BDMA_IFCR_CTCIF4_Pos = 0x11
	// Bit mask of CTCIF4 field.
	BDMA_IFCR_CTCIF4_Msk = 0x20000
	// Bit CTCIF4.
	BDMA_IFCR_CTCIF4 = 0x20000
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF4_Clear = 0x1
	// Position of CGIF4 field.
	BDMA_IFCR_CGIF4_Pos = 0x10
	// Bit mask of CGIF4 field.
	BDMA_IFCR_CGIF4_Msk = 0x10000
	// Bit CGIF4.
	BDMA_IFCR_CGIF4 = 0x10000
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF4_Clear = 0x1
	// Position of CTEIF3 field.
	BDMA_IFCR_CTEIF3_Pos = 0xf
	// Bit mask of CTEIF3 field.
	BDMA_IFCR_CTEIF3_Msk = 0x8000
	// Bit CTEIF3.
	BDMA_IFCR_CTEIF3 = 0x8000
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF3_Clear = 0x1
	// Position of CHTIF3 field.
	BDMA_IFCR_CHTIF3_Pos = 0xe
	// Bit mask of CHTIF3 field.
	BDMA_IFCR_CHTIF3_Msk = 0x4000
	// Bit CHTIF3.
	BDMA_IFCR_CHTIF3 = 0x4000
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF3_Clear = 0x1
	// Position of CTCIF3 field.
	BDMA_IFCR_CTCIF3_Pos = 0xd
	// Bit mask of CTCIF3 field.
	BDMA_IFCR_CTCIF3_Msk = 0x2000
	// Bit CTCIF3.
	BDMA_IFCR_CTCIF3 = 0x2000
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF3_Clear = 0x1
	// Position of CGIF3 field.
	BDMA_IFCR_CGIF3_Pos = 0xc
	// Bit mask of CGIF3 field.
	BDMA_IFCR_CGIF3_Msk = 0x1000
	// Bit CGIF3.
	BDMA_IFCR_CGIF3 = 0x1000
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF3_Clear = 0x1
	// Position of CTEIF2 field.
	BDMA_IFCR_CTEIF2_Pos = 0xb
	// Bit mask of CTEIF2 field.
	BDMA_IFCR_CTEIF2_Msk = 0x800
	// Bit CTEIF2.
	BDMA_IFCR_CTEIF2 = 0x800
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF2_Clear = 0x1
	// Position of CHTIF2 field.
	BDMA_IFCR_CHTIF2_Pos = 0xa
	// Bit mask of CHTIF2 field.
	BDMA_IFCR_CHTIF2_Msk = 0x400
	// Bit CHTIF2.
	BDMA_IFCR_CHTIF2 = 0x400
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF2_Clear = 0x1
	// Position of CTCIF2 field.
	BDMA_IFCR_CTCIF2_Pos = 0x9
	// Bit mask of CTCIF2 field.
	BDMA_IFCR_CTCIF2_Msk = 0x200
	// Bit CTCIF2.
	BDMA_IFCR_CTCIF2 = 0x200
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF2_Clear = 0x1
	// Position of CGIF2 field.
	BDMA_IFCR_CGIF2_Pos = 0x8
	// Bit mask of CGIF2 field.
	BDMA_IFCR_CGIF2_Msk = 0x100
	// Bit CGIF2.
	BDMA_IFCR_CGIF2 = 0x100
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF2_Clear = 0x1
	// Position of CTEIF1 field.
	BDMA_IFCR_CTEIF1_Pos = 0x7
	// Bit mask of CTEIF1 field.
	BDMA_IFCR_CTEIF1_Msk = 0x80
	// Bit CTEIF1.
	BDMA_IFCR_CTEIF1 = 0x80
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF1_Clear = 0x1
	// Position of CHTIF1 field.
	BDMA_IFCR_CHTIF1_Pos = 0x6
	// Bit mask of CHTIF1 field.
	BDMA_IFCR_CHTIF1_Msk = 0x40
	// Bit CHTIF1.
	BDMA_IFCR_CHTIF1 = 0x40
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF1_Clear = 0x1
	// Position of CTCIF1 field.
	BDMA_IFCR_CTCIF1_Pos = 0x5
	// Bit mask of CTCIF1 field.
	BDMA_IFCR_CTCIF1_Msk = 0x20
	// Bit CTCIF1.
	BDMA_IFCR_CTCIF1 = 0x20
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF1_Clear = 0x1
	// Position of CGIF1 field.
	BDMA_IFCR_CGIF1_Pos = 0x4
	// Bit mask of CGIF1 field.
	BDMA_IFCR_CGIF1_Msk = 0x10
	// Bit CGIF1.
	BDMA_IFCR_CGIF1 = 0x10
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF1_Clear = 0x1
	// Position of CTEIF0 field.
	BDMA_IFCR_CTEIF0_Pos = 0x3
	// Bit mask of CTEIF0 field.
	BDMA_IFCR_CTEIF0_Msk = 0x8
	// Bit CTEIF0.
	BDMA_IFCR_CTEIF0 = 0x8
	// Clear the corresponding TEIFx flag
	BDMA_IFCR_CTEIF0_Clear = 0x1
	// Position of CHTIF0 field.
	BDMA_IFCR_CHTIF0_Pos = 0x2
	// Bit mask of CHTIF0 field.
	BDMA_IFCR_CHTIF0_Msk = 0x4
	// Bit CHTIF0.
	BDMA_IFCR_CHTIF0 = 0x4
	// Clear the corresponding HTIFx flag
	BDMA_IFCR_CHTIF0_Clear = 0x1
	// Position of CTCIF0 field.
	BDMA_IFCR_CTCIF0_Pos = 0x1
	// Bit mask of CTCIF0 field.
	BDMA_IFCR_CTCIF0_Msk = 0x2
	// Bit CTCIF0.
	BDMA_IFCR_CTCIF0 = 0x2
	// Clear the corresponding TCIFx flag
	BDMA_IFCR_CTCIF0_Clear = 0x1
	// Position of CGIF0 field.
	BDMA_IFCR_CGIF0_Pos = 0x0
	// Bit mask of CGIF0 field.
	BDMA_IFCR_CGIF0_Msk = 0x1
	// Bit CGIF0.
	BDMA_IFCR_CGIF0 = 0x1
	// Clear the corresponding CGIFx flag
	BDMA_IFCR_CGIF0_Clear = 0x1

	// CH.CR: Channel x configuration register
	// Position of CT field.
	BDMA_CH_CR_CT_Pos = 0x10
	// Bit mask of CT field.
	BDMA_CH_CR_CT_Msk = 0x10000
	// Bit CT.
	BDMA_CH_CR_CT = 0x10000
	// The current target memory is Memory 0
	BDMA_CH_CR_CT_Memory0 = 0x0
	// The current target memory is Memory 1
	BDMA_CH_CR_CT_Memory1 = 0x1
	// Position of DBM field.
	BDMA_CH_CR_DBM_Pos = 0xf
	// Bit mask of DBM field.
	BDMA_CH_CR_DBM_Msk = 0x8000
	// Bit DBM.
	BDMA_CH_CR_DBM = 0x8000
	// No buffer switching at the end of transfer
	BDMA_CH_CR_DBM_Disabled = 0x0
	// Memory target switched at the end of the DMA transfer
	BDMA_CH_CR_DBM_Enabled = 0x1
	// Position of MEM2MEM field.
	BDMA_CH_CR_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	BDMA_CH_CR_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	BDMA_CH_CR_MEM2MEM = 0x4000
	// Memory-to-memory mode disabled
	BDMA_CH_CR_MEM2MEM_Disabled = 0x0
	// Memory-to-memory mode enabled
	BDMA_CH_CR_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	BDMA_CH_CR_PL_Pos = 0xc
	// Bit mask of PL field.
	BDMA_CH_CR_PL_Msk = 0x3000
	// Low
	BDMA_CH_CR_PL_Low = 0x0
	// Medium
	BDMA_CH_CR_PL_Medium = 0x1
	// High
	BDMA_CH_CR_PL_High = 0x2
	// Very high
	BDMA_CH_CR_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	BDMA_CH_CR_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	BDMA_CH_CR_MSIZE_Msk = 0xc00
	// Byte (8-bit)
	BDMA_CH_CR_MSIZE_Bits8 = 0x0
	// Half-word (16-bit)
	BDMA_CH_CR_MSIZE_Bits16 = 0x1
	// Word (32-bit)
	BDMA_CH_CR_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	BDMA_CH_CR_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	BDMA_CH_CR_PSIZE_Msk = 0x300
	// Byte (8-bit)
	BDMA_CH_CR_PSIZE_Bits8 = 0x0
	// Half-word (16-bit)
	BDMA_CH_CR_PSIZE_Bits16 = 0x1
	// Word (32-bit)
	BDMA_CH_CR_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	BDMA_CH_CR_MINC_Pos = 0x7
	// Bit mask of MINC field.
	BDMA_CH_CR_MINC_Msk = 0x80
	// Bit MINC.
	BDMA_CH_CR_MINC = 0x80
	// Address pointer is fixed
	BDMA_CH_CR_MINC_Fixed = 0x0
	// Address pointer is incremented after each data transfer
	BDMA_CH_CR_MINC_Incremented = 0x1
	// Position of PINC field.
	BDMA_CH_CR_PINC_Pos = 0x6
	// Bit mask of PINC field.
	BDMA_CH_CR_PINC_Msk = 0x40
	// Bit PINC.
	BDMA_CH_CR_PINC = 0x40
	// Address pointer is fixed
	BDMA_CH_CR_PINC_Fixed = 0x0
	// Address pointer is incremented after each data transfer
	BDMA_CH_CR_PINC_Incremented = 0x1
	// Position of CIRC field.
	BDMA_CH_CR_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	BDMA_CH_CR_CIRC_Msk = 0x20
	// Bit CIRC.
	BDMA_CH_CR_CIRC = 0x20
	// Circular mode disabled
	BDMA_CH_CR_CIRC_Disabled = 0x0
	// Circular mode enabled
	BDMA_CH_CR_CIRC_Enabled = 0x1
	// Position of DIR field.
	BDMA_CH_CR_DIR_Pos = 0x4
	// Bit mask of DIR field.
	BDMA_CH_CR_DIR_Msk = 0x10
	// Bit DIR.
	BDMA_CH_CR_DIR = 0x10
	// Peripheral-to-memory
	BDMA_CH_CR_DIR_PeripheralToMemory = 0x0
	// Memory-to-peripheral
	BDMA_CH_CR_DIR_MemoryToPeripheral = 0x1
	// Position of TEIE field.
	BDMA_CH_CR_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	BDMA_CH_CR_TEIE_Msk = 0x8
	// Bit TEIE.
	BDMA_CH_CR_TEIE = 0x8
	// TE interrupt disabled
	BDMA_CH_CR_TEIE_Disabled = 0x0
	// TE interrupt enabled
	BDMA_CH_CR_TEIE_Enabled = 0x1
	// Position of HTIE field.
	BDMA_CH_CR_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	BDMA_CH_CR_HTIE_Msk = 0x4
	// Bit HTIE.
	BDMA_CH_CR_HTIE = 0x4
	// HT interrupt disabled
	BDMA_CH_CR_HTIE_Disabled = 0x0
	// HT interrupt enabled
	BDMA_CH_CR_HTIE_Enabled = 0x1
	// Position of TCIE field.
	BDMA_CH_CR_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	BDMA_CH_CR_TCIE_Msk = 0x2
	// Bit TCIE.
	BDMA_CH_CR_TCIE = 0x2
	// TC interrupt disabled
	BDMA_CH_CR_TCIE_Disabled = 0x0
	// TC interrupt enabled
	BDMA_CH_CR_TCIE_Enabled = 0x1
	// Position of EN field.
	BDMA_CH_CR_EN_Pos = 0x1
	// Bit mask of EN field.
	BDMA_CH_CR_EN_Msk = 0x2
	// Bit EN.
	BDMA_CH_CR_EN = 0x2
	// Channel disabled
	BDMA_CH_CR_EN_Disabled = 0x0
	// Channel enabled
	BDMA_CH_CR_EN_Enabled = 0x1

	// CH.NDTR: Channel x number of data to transfer register
	// Position of NDT field.
	BDMA_CH_NDTR_NDT_Pos = 0x0
	// Bit mask of NDT field.
	BDMA_CH_NDTR_NDT_Msk = 0xffff

	// CH.PAR: Channel x peripheral address register
	// Position of PA field.
	BDMA_CH_PAR_PA_Pos = 0x0
	// Bit mask of PA field.
	BDMA_CH_PAR_PA_Msk = 0xffffffff

	// CH.M0AR: Channel x memory 0 address register
	// Position of MA field.
	BDMA_CH_M0AR_MA_Pos = 0x0
	// Bit mask of MA field.
	BDMA_CH_M0AR_MA_Msk = 0xffffffff

	// CH.M1AR: Channel x memory 1 address register
	// Position of MA field.
	BDMA_CH_M1AR_MA_Pos = 0x0
	// Bit mask of MA field.
	BDMA_CH_M1AR_MA_Msk = 0xffffffff
)

// Constants for Ethernet_DMA: Ethernet DMA
const (
	// DMAMR: DMA mode register
	// Position of INTM field.
	Ethernet_DMA_DMAMR_INTM_Pos = 0x10
	// Bit mask of INTM field.
	Ethernet_DMA_DMAMR_INTM_Msk = 0x30000
	// Position of PR field.
	Ethernet_DMA_DMAMR_PR_Pos = 0xc
	// Bit mask of PR field.
	Ethernet_DMA_DMAMR_PR_Msk = 0x7000
	// Position of TXPR field.
	Ethernet_DMA_DMAMR_TXPR_Pos = 0xb
	// Bit mask of TXPR field.
	Ethernet_DMA_DMAMR_TXPR_Msk = 0x800
	// Bit TXPR.
	Ethernet_DMA_DMAMR_TXPR = 0x800
	// Position of DA field.
	Ethernet_DMA_DMAMR_DA_Pos = 0x1
	// Bit mask of DA field.
	Ethernet_DMA_DMAMR_DA_Msk = 0x2
	// Bit DA.
	Ethernet_DMA_DMAMR_DA = 0x2
	// Position of SWR field.
	Ethernet_DMA_DMAMR_SWR_Pos = 0x0
	// Bit mask of SWR field.
	Ethernet_DMA_DMAMR_SWR_Msk = 0x1
	// Bit SWR.
	Ethernet_DMA_DMAMR_SWR = 0x1

	// DMASBMR: System bus mode register
	// Position of RB field.
	Ethernet_DMA_DMASBMR_RB_Pos = 0xf
	// Bit mask of RB field.
	Ethernet_DMA_DMASBMR_RB_Msk = 0x8000
	// Bit RB.
	Ethernet_DMA_DMASBMR_RB = 0x8000
	// Position of MB field.
	Ethernet_DMA_DMASBMR_MB_Pos = 0xe
	// Bit mask of MB field.
	Ethernet_DMA_DMASBMR_MB_Msk = 0x4000
	// Bit MB.
	Ethernet_DMA_DMASBMR_MB = 0x4000
	// Position of AAL field.
	Ethernet_DMA_DMASBMR_AAL_Pos = 0xc
	// Bit mask of AAL field.
	Ethernet_DMA_DMASBMR_AAL_Msk = 0x1000
	// Bit AAL.
	Ethernet_DMA_DMASBMR_AAL = 0x1000
	// Position of FB field.
	Ethernet_DMA_DMASBMR_FB_Pos = 0x0
	// Bit mask of FB field.
	Ethernet_DMA_DMASBMR_FB_Msk = 0x1
	// Bit FB.
	Ethernet_DMA_DMASBMR_FB = 0x1

	// DMAISR: Interrupt status register
	// Position of MACIS field.
	Ethernet_DMA_DMAISR_MACIS_Pos = 0x11
	// Bit mask of MACIS field.
	Ethernet_DMA_DMAISR_MACIS_Msk = 0x20000
	// Bit MACIS.
	Ethernet_DMA_DMAISR_MACIS = 0x20000
	// Position of MTLIS field.
	Ethernet_DMA_DMAISR_MTLIS_Pos = 0x10
	// Bit mask of MTLIS field.
	Ethernet_DMA_DMAISR_MTLIS_Msk = 0x10000
	// Bit MTLIS.
	Ethernet_DMA_DMAISR_MTLIS = 0x10000
	// Position of DC0IS field.
	Ethernet_DMA_DMAISR_DC0IS_Pos = 0x0
	// Bit mask of DC0IS field.
	Ethernet_DMA_DMAISR_DC0IS_Msk = 0x1
	// Bit DC0IS.
	Ethernet_DMA_DMAISR_DC0IS = 0x1

	// DMADSR: Debug status register
	// Position of TPS0 field.
	Ethernet_DMA_DMADSR_TPS0_Pos = 0xc
	// Bit mask of TPS0 field.
	Ethernet_DMA_DMADSR_TPS0_Msk = 0xf000
	// Position of RPS0 field.
	Ethernet_DMA_DMADSR_RPS0_Pos = 0x8
	// Bit mask of RPS0 field.
	Ethernet_DMA_DMADSR_RPS0_Msk = 0xf00
	// Position of AXWHSTS field.
	Ethernet_DMA_DMADSR_AXWHSTS_Pos = 0x0
	// Bit mask of AXWHSTS field.
	Ethernet_DMA_DMADSR_AXWHSTS_Msk = 0x1
	// Bit AXWHSTS.
	Ethernet_DMA_DMADSR_AXWHSTS = 0x1

	// DMACCR: Channel control register
	// Position of DSL field.
	Ethernet_DMA_DMACCR_DSL_Pos = 0x12
	// Bit mask of DSL field.
	Ethernet_DMA_DMACCR_DSL_Msk = 0x1c0000
	// Position of PBLX8 field.
	Ethernet_DMA_DMACCR_PBLX8_Pos = 0x10
	// Bit mask of PBLX8 field.
	Ethernet_DMA_DMACCR_PBLX8_Msk = 0x10000
	// Bit PBLX8.
	Ethernet_DMA_DMACCR_PBLX8 = 0x10000
	// Position of MSS field.
	Ethernet_DMA_DMACCR_MSS_Pos = 0x0
	// Bit mask of MSS field.
	Ethernet_DMA_DMACCR_MSS_Msk = 0x3fff

	// DMACTxCR: Channel transmit control register
	// Position of TXPBL field.
	Ethernet_DMA_DMACTxCR_TXPBL_Pos = 0x10
	// Bit mask of TXPBL field.
	Ethernet_DMA_DMACTxCR_TXPBL_Msk = 0x3f0000
	// Position of TSE field.
	Ethernet_DMA_DMACTxCR_TSE_Pos = 0xc
	// Bit mask of TSE field.
	Ethernet_DMA_DMACTxCR_TSE_Msk = 0x1000
	// Bit TSE.
	Ethernet_DMA_DMACTxCR_TSE = 0x1000
	// Position of OSF field.
	Ethernet_DMA_DMACTxCR_OSF_Pos = 0x4
	// Bit mask of OSF field.
	Ethernet_DMA_DMACTxCR_OSF_Msk = 0x10
	// Bit OSF.
	Ethernet_DMA_DMACTxCR_OSF = 0x10
	// Position of ST field.
	Ethernet_DMA_DMACTxCR_ST_Pos = 0x0
	// Bit mask of ST field.
	Ethernet_DMA_DMACTxCR_ST_Msk = 0x1
	// Bit ST.
	Ethernet_DMA_DMACTxCR_ST = 0x1

	// DMACRxCR: Channel receive control register
	// Position of RPF field.
	Ethernet_DMA_DMACRxCR_RPF_Pos = 0x1f
	// Bit mask of RPF field.
	Ethernet_DMA_DMACRxCR_RPF_Msk = 0x80000000
	// Bit RPF.
	Ethernet_DMA_DMACRxCR_RPF = 0x80000000
	// Position of RXPBL field.
	Ethernet_DMA_DMACRxCR_RXPBL_Pos = 0x10
	// Bit mask of RXPBL field.
	Ethernet_DMA_DMACRxCR_RXPBL_Msk = 0x3f0000
	// Position of RBSZ field.
	Ethernet_DMA_DMACRxCR_RBSZ_Pos = 0x1
	// Bit mask of RBSZ field.
	Ethernet_DMA_DMACRxCR_RBSZ_Msk = 0x7ffe
	// Position of SR field.
	Ethernet_DMA_DMACRxCR_SR_Pos = 0x0
	// Bit mask of SR field.
	Ethernet_DMA_DMACRxCR_SR_Msk = 0x1
	// Bit SR.
	Ethernet_DMA_DMACRxCR_SR = 0x1

	// DMACTxDLAR: Channel Tx descriptor list address register
	// Position of TDESLA field.
	Ethernet_DMA_DMACTxDLAR_TDESLA_Pos = 0x2
	// Bit mask of TDESLA field.
	Ethernet_DMA_DMACTxDLAR_TDESLA_Msk = 0xfffffffc

	// DMACRxDLAR: Channel Rx descriptor list address register
	// Position of RDESLA field.
	Ethernet_DMA_DMACRxDLAR_RDESLA_Pos = 0x2
	// Bit mask of RDESLA field.
	Ethernet_DMA_DMACRxDLAR_RDESLA_Msk = 0xfffffffc

	// DMACTxDTPR: Channel Tx descriptor tail pointer register
	// Position of TDT field.
	Ethernet_DMA_DMACTxDTPR_TDT_Pos = 0x2
	// Bit mask of TDT field.
	Ethernet_DMA_DMACTxDTPR_TDT_Msk = 0xfffffffc

	// DMACRxDTPR: Channel Rx descriptor tail pointer register
	// Position of RDT field.
	Ethernet_DMA_DMACRxDTPR_RDT_Pos = 0x2
	// Bit mask of RDT field.
	Ethernet_DMA_DMACRxDTPR_RDT_Msk = 0xfffffffc

	// DMACTxRLR: Channel Tx descriptor ring length register
	// Position of TDRL field.
	Ethernet_DMA_DMACTxRLR_TDRL_Pos = 0x0
	// Bit mask of TDRL field.
	Ethernet_DMA_DMACTxRLR_TDRL_Msk = 0x3ff

	// DMACRxRLR: Channel Rx descriptor ring length register
	// Position of RDRL field.
	Ethernet_DMA_DMACRxRLR_RDRL_Pos = 0x0
	// Bit mask of RDRL field.
	Ethernet_DMA_DMACRxRLR_RDRL_Msk = 0x3ff

	// DMACIER: Channel interrupt enable register
	// Position of NIE field.
	Ethernet_DMA_DMACIER_NIE_Pos = 0xf
	// Bit mask of NIE field.
	Ethernet_DMA_DMACIER_NIE_Msk = 0x8000
	// Bit NIE.
	Ethernet_DMA_DMACIER_NIE = 0x8000
	// Position of AIE field.
	Ethernet_DMA_DMACIER_AIE_Pos = 0xe
	// Bit mask of AIE field.
	Ethernet_DMA_DMACIER_AIE_Msk = 0x4000
	// Bit AIE.
	Ethernet_DMA_DMACIER_AIE = 0x4000
	// Position of CDEE field.
	Ethernet_DMA_DMACIER_CDEE_Pos = 0xd
	// Bit mask of CDEE field.
	Ethernet_DMA_DMACIER_CDEE_Msk = 0x2000
	// Bit CDEE.
	Ethernet_DMA_DMACIER_CDEE = 0x2000
	// Position of FBEE field.
	Ethernet_DMA_DMACIER_FBEE_Pos = 0xc
	// Bit mask of FBEE field.
	Ethernet_DMA_DMACIER_FBEE_Msk = 0x1000
	// Bit FBEE.
	Ethernet_DMA_DMACIER_FBEE = 0x1000
	// Position of ERIE field.
	Ethernet_DMA_DMACIER_ERIE_Pos = 0xb
	// Bit mask of ERIE field.
	Ethernet_DMA_DMACIER_ERIE_Msk = 0x800
	// Bit ERIE.
	Ethernet_DMA_DMACIER_ERIE = 0x800
	// Position of ETIE field.
	Ethernet_DMA_DMACIER_ETIE_Pos = 0xa
	// Bit mask of ETIE field.
	Ethernet_DMA_DMACIER_ETIE_Msk = 0x400
	// Bit ETIE.
	Ethernet_DMA_DMACIER_ETIE = 0x400
	// Position of RWTE field.
	Ethernet_DMA_DMACIER_RWTE_Pos = 0x9
	// Bit mask of RWTE field.
	Ethernet_DMA_DMACIER_RWTE_Msk = 0x200
	// Bit RWTE.
	Ethernet_DMA_DMACIER_RWTE = 0x200
	// Position of RSE field.
	Ethernet_DMA_DMACIER_RSE_Pos = 0x8
	// Bit mask of RSE field.
	Ethernet_DMA_DMACIER_RSE_Msk = 0x100
	// Bit RSE.
	Ethernet_DMA_DMACIER_RSE = 0x100
	// Position of RBUE field.
	Ethernet_DMA_DMACIER_RBUE_Pos = 0x7
	// Bit mask of RBUE field.
	Ethernet_DMA_DMACIER_RBUE_Msk = 0x80
	// Bit RBUE.
	Ethernet_DMA_DMACIER_RBUE = 0x80
	// Position of RIE field.
	Ethernet_DMA_DMACIER_RIE_Pos = 0x6
	// Bit mask of RIE field.
	Ethernet_DMA_DMACIER_RIE_Msk = 0x40
	// Bit RIE.
	Ethernet_DMA_DMACIER_RIE = 0x40
	// Position of TBUE field.
	Ethernet_DMA_DMACIER_TBUE_Pos = 0x2
	// Bit mask of TBUE field.
	Ethernet_DMA_DMACIER_TBUE_Msk = 0x4
	// Bit TBUE.
	Ethernet_DMA_DMACIER_TBUE = 0x4
	// Position of TXSE field.
	Ethernet_DMA_DMACIER_TXSE_Pos = 0x1
	// Bit mask of TXSE field.
	Ethernet_DMA_DMACIER_TXSE_Msk = 0x2
	// Bit TXSE.
	Ethernet_DMA_DMACIER_TXSE = 0x2
	// Position of TIE field.
	Ethernet_DMA_DMACIER_TIE_Pos = 0x0
	// Bit mask of TIE field.
	Ethernet_DMA_DMACIER_TIE_Msk = 0x1
	// Bit TIE.
	Ethernet_DMA_DMACIER_TIE = 0x1

	// DMACRxIWTR: Channel Rx interrupt watchdog timer register
	// Position of RWT field.
	Ethernet_DMA_DMACRxIWTR_RWT_Pos = 0x0
	// Bit mask of RWT field.
	Ethernet_DMA_DMACRxIWTR_RWT_Msk = 0xff

	// DMACCATxDR: Channel current application transmit descriptor register
	// Position of CURTDESAPTR field.
	Ethernet_DMA_DMACCATxDR_CURTDESAPTR_Pos = 0x0
	// Bit mask of CURTDESAPTR field.
	Ethernet_DMA_DMACCATxDR_CURTDESAPTR_Msk = 0xffffffff

	// DMACCARxDR: Channel current application receive descriptor register
	// Position of CURRDESAPTR field.
	Ethernet_DMA_DMACCARxDR_CURRDESAPTR_Pos = 0x0
	// Bit mask of CURRDESAPTR field.
	Ethernet_DMA_DMACCARxDR_CURRDESAPTR_Msk = 0xffffffff

	// DMACCATxBR: Channel current application transmit buffer register
	// Position of CURTBUFAPTR field.
	Ethernet_DMA_DMACCATxBR_CURTBUFAPTR_Pos = 0x0
	// Bit mask of CURTBUFAPTR field.
	Ethernet_DMA_DMACCATxBR_CURTBUFAPTR_Msk = 0xffffffff

	// DMACCARxBR: Channel current application receive buffer register
	// Position of CURRBUFAPTR field.
	Ethernet_DMA_DMACCARxBR_CURRBUFAPTR_Pos = 0x0
	// Bit mask of CURRBUFAPTR field.
	Ethernet_DMA_DMACCARxBR_CURRBUFAPTR_Msk = 0xffffffff

	// DMACSR: Channel status register
	// Position of REB field.
	Ethernet_DMA_DMACSR_REB_Pos = 0x13
	// Bit mask of REB field.
	Ethernet_DMA_DMACSR_REB_Msk = 0x380000
	// Position of TEB field.
	Ethernet_DMA_DMACSR_TEB_Pos = 0x10
	// Bit mask of TEB field.
	Ethernet_DMA_DMACSR_TEB_Msk = 0x70000
	// Position of NIS field.
	Ethernet_DMA_DMACSR_NIS_Pos = 0xf
	// Bit mask of NIS field.
	Ethernet_DMA_DMACSR_NIS_Msk = 0x8000
	// Bit NIS.
	Ethernet_DMA_DMACSR_NIS = 0x8000
	// Position of AIS field.
	Ethernet_DMA_DMACSR_AIS_Pos = 0xe
	// Bit mask of AIS field.
	Ethernet_DMA_DMACSR_AIS_Msk = 0x4000
	// Bit AIS.
	Ethernet_DMA_DMACSR_AIS = 0x4000
	// Position of CDE field.
	Ethernet_DMA_DMACSR_CDE_Pos = 0xd
	// Bit mask of CDE field.
	Ethernet_DMA_DMACSR_CDE_Msk = 0x2000
	// Bit CDE.
	Ethernet_DMA_DMACSR_CDE = 0x2000
	// Position of FBE field.
	Ethernet_DMA_DMACSR_FBE_Pos = 0xc
	// Bit mask of FBE field.
	Ethernet_DMA_DMACSR_FBE_Msk = 0x1000
	// Bit FBE.
	Ethernet_DMA_DMACSR_FBE = 0x1000
	// Position of ERI field.
	Ethernet_DMA_DMACSR_ERI_Pos = 0xb
	// Bit mask of ERI field.
	Ethernet_DMA_DMACSR_ERI_Msk = 0x800
	// Bit ERI.
	Ethernet_DMA_DMACSR_ERI = 0x800
	// Position of ETI field.
	Ethernet_DMA_DMACSR_ETI_Pos = 0xa
	// Bit mask of ETI field.
	Ethernet_DMA_DMACSR_ETI_Msk = 0x400
	// Bit ETI.
	Ethernet_DMA_DMACSR_ETI = 0x400
	// Position of RWT field.
	Ethernet_DMA_DMACSR_RWT_Pos = 0x9
	// Bit mask of RWT field.
	Ethernet_DMA_DMACSR_RWT_Msk = 0x200
	// Bit RWT.
	Ethernet_DMA_DMACSR_RWT = 0x200
	// Position of RPS field.
	Ethernet_DMA_DMACSR_RPS_Pos = 0x8
	// Bit mask of RPS field.
	Ethernet_DMA_DMACSR_RPS_Msk = 0x100
	// Bit RPS.
	Ethernet_DMA_DMACSR_RPS = 0x100
	// Position of RBU field.
	Ethernet_DMA_DMACSR_RBU_Pos = 0x7
	// Bit mask of RBU field.
	Ethernet_DMA_DMACSR_RBU_Msk = 0x80
	// Bit RBU.
	Ethernet_DMA_DMACSR_RBU = 0x80
	// Position of RI field.
	Ethernet_DMA_DMACSR_RI_Pos = 0x6
	// Bit mask of RI field.
	Ethernet_DMA_DMACSR_RI_Msk = 0x40
	// Bit RI.
	Ethernet_DMA_DMACSR_RI = 0x40
	// Position of TBU field.
	Ethernet_DMA_DMACSR_TBU_Pos = 0x2
	// Bit mask of TBU field.
	Ethernet_DMA_DMACSR_TBU_Msk = 0x4
	// Bit TBU.
	Ethernet_DMA_DMACSR_TBU = 0x4
	// Position of TPS field.
	Ethernet_DMA_DMACSR_TPS_Pos = 0x1
	// Bit mask of TPS field.
	Ethernet_DMA_DMACSR_TPS_Msk = 0x2
	// Bit TPS.
	Ethernet_DMA_DMACSR_TPS = 0x2
	// Position of TI field.
	Ethernet_DMA_DMACSR_TI_Pos = 0x0
	// Bit mask of TI field.
	Ethernet_DMA_DMACSR_TI_Msk = 0x1
	// Bit TI.
	Ethernet_DMA_DMACSR_TI = 0x1

	// DMACMFCR: Channel missed frame count register
	// Position of MFCO field.
	Ethernet_DMA_DMACMFCR_MFCO_Pos = 0xf
	// Bit mask of MFCO field.
	Ethernet_DMA_DMACMFCR_MFCO_Msk = 0x8000
	// Bit MFCO.
	Ethernet_DMA_DMACMFCR_MFCO = 0x8000
	// Position of MFC field.
	Ethernet_DMA_DMACMFCR_MFC_Pos = 0x0
	// Bit mask of MFC field.
	Ethernet_DMA_DMACMFCR_MFC_Msk = 0x7ff
)

// Constants for Ethernet_MTL: Ethernet MTL
const (
	// MTLOMR: Operating mode Register
	// Position of CNTCLR field.
	Ethernet_MTL_MTLOMR_CNTCLR_Pos = 0x9
	// Bit mask of CNTCLR field.
	Ethernet_MTL_MTLOMR_CNTCLR_Msk = 0x200
	// Bit CNTCLR.
	Ethernet_MTL_MTLOMR_CNTCLR = 0x200
	// Position of CNTPRST field.
	Ethernet_MTL_MTLOMR_CNTPRST_Pos = 0x8
	// Bit mask of CNTPRST field.
	Ethernet_MTL_MTLOMR_CNTPRST_Msk = 0x100
	// Bit CNTPRST.
	Ethernet_MTL_MTLOMR_CNTPRST = 0x100
	// Position of DTXSTS field.
	Ethernet_MTL_MTLOMR_DTXSTS_Pos = 0x1
	// Bit mask of DTXSTS field.
	Ethernet_MTL_MTLOMR_DTXSTS_Msk = 0x2
	// Bit DTXSTS.
	Ethernet_MTL_MTLOMR_DTXSTS = 0x2

	// MTLISR: Interrupt status Register
	// Position of Q0IS field.
	Ethernet_MTL_MTLISR_Q0IS_Pos = 0x0
	// Bit mask of Q0IS field.
	Ethernet_MTL_MTLISR_Q0IS_Msk = 0x1
	// Bit Q0IS.
	Ethernet_MTL_MTLISR_Q0IS = 0x1

	// MTLTxQOMR: Tx queue operating mode Register
	// Position of TQS field.
	Ethernet_MTL_MTLTxQOMR_TQS_Pos = 0x10
	// Bit mask of TQS field.
	Ethernet_MTL_MTLTxQOMR_TQS_Msk = 0x1ff0000
	// Position of TTC field.
	Ethernet_MTL_MTLTxQOMR_TTC_Pos = 0x4
	// Bit mask of TTC field.
	Ethernet_MTL_MTLTxQOMR_TTC_Msk = 0x70
	// Position of TXQEN field.
	Ethernet_MTL_MTLTxQOMR_TXQEN_Pos = 0x2
	// Bit mask of TXQEN field.
	Ethernet_MTL_MTLTxQOMR_TXQEN_Msk = 0xc
	// Position of TSF field.
	Ethernet_MTL_MTLTxQOMR_TSF_Pos = 0x1
	// Bit mask of TSF field.
	Ethernet_MTL_MTLTxQOMR_TSF_Msk = 0x2
	// Bit TSF.
	Ethernet_MTL_MTLTxQOMR_TSF = 0x2
	// Position of FTQ field.
	Ethernet_MTL_MTLTxQOMR_FTQ_Pos = 0x0
	// Bit mask of FTQ field.
	Ethernet_MTL_MTLTxQOMR_FTQ_Msk = 0x1
	// Bit FTQ.
	Ethernet_MTL_MTLTxQOMR_FTQ = 0x1

	// MTLTxQUR: Tx queue underflow register
	// Position of UFCNTOVF field.
	Ethernet_MTL_MTLTxQUR_UFCNTOVF_Pos = 0xb
	// Bit mask of UFCNTOVF field.
	Ethernet_MTL_MTLTxQUR_UFCNTOVF_Msk = 0x800
	// Bit UFCNTOVF.
	Ethernet_MTL_MTLTxQUR_UFCNTOVF = 0x800
	// Position of UFFRMCNT field.
	Ethernet_MTL_MTLTxQUR_UFFRMCNT_Pos = 0x0
	// Bit mask of UFFRMCNT field.
	Ethernet_MTL_MTLTxQUR_UFFRMCNT_Msk = 0x7ff

	// MTLTxQDR: Tx queue debug Register
	// Position of STXSTSF field.
	Ethernet_MTL_MTLTxQDR_STXSTSF_Pos = 0x14
	// Bit mask of STXSTSF field.
	Ethernet_MTL_MTLTxQDR_STXSTSF_Msk = 0x700000
	// Position of PTXQ field.
	Ethernet_MTL_MTLTxQDR_PTXQ_Pos = 0x10
	// Bit mask of PTXQ field.
	Ethernet_MTL_MTLTxQDR_PTXQ_Msk = 0x70000
	// Position of TXSTSFSTS field.
	Ethernet_MTL_MTLTxQDR_TXSTSFSTS_Pos = 0x5
	// Bit mask of TXSTSFSTS field.
	Ethernet_MTL_MTLTxQDR_TXSTSFSTS_Msk = 0x20
	// Bit TXSTSFSTS.
	Ethernet_MTL_MTLTxQDR_TXSTSFSTS = 0x20
	// Position of TXQSTS field.
	Ethernet_MTL_MTLTxQDR_TXQSTS_Pos = 0x4
	// Bit mask of TXQSTS field.
	Ethernet_MTL_MTLTxQDR_TXQSTS_Msk = 0x10
	// Bit TXQSTS.
	Ethernet_MTL_MTLTxQDR_TXQSTS = 0x10
	// Position of TWCSTS field.
	Ethernet_MTL_MTLTxQDR_TWCSTS_Pos = 0x3
	// Bit mask of TWCSTS field.
	Ethernet_MTL_MTLTxQDR_TWCSTS_Msk = 0x8
	// Bit TWCSTS.
	Ethernet_MTL_MTLTxQDR_TWCSTS = 0x8
	// Position of TRCSTS field.
	Ethernet_MTL_MTLTxQDR_TRCSTS_Pos = 0x1
	// Bit mask of TRCSTS field.
	Ethernet_MTL_MTLTxQDR_TRCSTS_Msk = 0x6
	// Position of TXQPAUSED field.
	Ethernet_MTL_MTLTxQDR_TXQPAUSED_Pos = 0x0
	// Bit mask of TXQPAUSED field.
	Ethernet_MTL_MTLTxQDR_TXQPAUSED_Msk = 0x1
	// Bit TXQPAUSED.
	Ethernet_MTL_MTLTxQDR_TXQPAUSED = 0x1

	// MTLQICSR: Queue interrupt control status Register
	// Position of RXOIE field.
	Ethernet_MTL_MTLQICSR_RXOIE_Pos = 0x18
	// Bit mask of RXOIE field.
	Ethernet_MTL_MTLQICSR_RXOIE_Msk = 0x1000000
	// Bit RXOIE.
	Ethernet_MTL_MTLQICSR_RXOIE = 0x1000000
	// Position of RXOVFIS field.
	Ethernet_MTL_MTLQICSR_RXOVFIS_Pos = 0x10
	// Bit mask of RXOVFIS field.
	Ethernet_MTL_MTLQICSR_RXOVFIS_Msk = 0x10000
	// Bit RXOVFIS.
	Ethernet_MTL_MTLQICSR_RXOVFIS = 0x10000
	// Position of TXUIE field.
	Ethernet_MTL_MTLQICSR_TXUIE_Pos = 0x8
	// Bit mask of TXUIE field.
	Ethernet_MTL_MTLQICSR_TXUIE_Msk = 0x100
	// Bit TXUIE.
	Ethernet_MTL_MTLQICSR_TXUIE = 0x100
	// Position of TXUNFIS field.
	Ethernet_MTL_MTLQICSR_TXUNFIS_Pos = 0x0
	// Bit mask of TXUNFIS field.
	Ethernet_MTL_MTLQICSR_TXUNFIS_Msk = 0x1
	// Bit TXUNFIS.
	Ethernet_MTL_MTLQICSR_TXUNFIS = 0x1

	// MTLRxQOMR: Rx queue operating mode register
	// Position of RQS field.
	Ethernet_MTL_MTLRxQOMR_RQS_Pos = 0x14
	// Bit mask of RQS field.
	Ethernet_MTL_MTLRxQOMR_RQS_Msk = 0x700000
	// Position of RFD field.
	Ethernet_MTL_MTLRxQOMR_RFD_Pos = 0xe
	// Bit mask of RFD field.
	Ethernet_MTL_MTLRxQOMR_RFD_Msk = 0x1c000
	// Position of RFA field.
	Ethernet_MTL_MTLRxQOMR_RFA_Pos = 0x8
	// Bit mask of RFA field.
	Ethernet_MTL_MTLRxQOMR_RFA_Msk = 0x700
	// Position of EHFC field.
	Ethernet_MTL_MTLRxQOMR_EHFC_Pos = 0x7
	// Bit mask of EHFC field.
	Ethernet_MTL_MTLRxQOMR_EHFC_Msk = 0x80
	// Bit EHFC.
	Ethernet_MTL_MTLRxQOMR_EHFC = 0x80
	// Position of DIS_TCP_EF field.
	Ethernet_MTL_MTLRxQOMR_DIS_TCP_EF_Pos = 0x6
	// Bit mask of DIS_TCP_EF field.
	Ethernet_MTL_MTLRxQOMR_DIS_TCP_EF_Msk = 0x40
	// Bit DIS_TCP_EF.
	Ethernet_MTL_MTLRxQOMR_DIS_TCP_EF = 0x40
	// Position of RSF field.
	Ethernet_MTL_MTLRxQOMR_RSF_Pos = 0x5
	// Bit mask of RSF field.
	Ethernet_MTL_MTLRxQOMR_RSF_Msk = 0x20
	// Bit RSF.
	Ethernet_MTL_MTLRxQOMR_RSF = 0x20
	// Position of FEP field.
	Ethernet_MTL_MTLRxQOMR_FEP_Pos = 0x4
	// Bit mask of FEP field.
	Ethernet_MTL_MTLRxQOMR_FEP_Msk = 0x10
	// Bit FEP.
	Ethernet_MTL_MTLRxQOMR_FEP = 0x10
	// Position of FUP field.
	Ethernet_MTL_MTLRxQOMR_FUP_Pos = 0x3
	// Bit mask of FUP field.
	Ethernet_MTL_MTLRxQOMR_FUP_Msk = 0x8
	// Bit FUP.
	Ethernet_MTL_MTLRxQOMR_FUP = 0x8
	// Position of RTC field.
	Ethernet_MTL_MTLRxQOMR_RTC_Pos = 0x0
	// Bit mask of RTC field.
	Ethernet_MTL_MTLRxQOMR_RTC_Msk = 0x3

	// MTLRxQMPOCR: Rx queue missed packet and overflow counter register
	// Position of MISCNTOVF field.
	Ethernet_MTL_MTLRxQMPOCR_MISCNTOVF_Pos = 0x1b
	// Bit mask of MISCNTOVF field.
	Ethernet_MTL_MTLRxQMPOCR_MISCNTOVF_Msk = 0x8000000
	// Bit MISCNTOVF.
	Ethernet_MTL_MTLRxQMPOCR_MISCNTOVF = 0x8000000
	// Position of MISPKTCNT field.
	Ethernet_MTL_MTLRxQMPOCR_MISPKTCNT_Pos = 0x10
	// Bit mask of MISPKTCNT field.
	Ethernet_MTL_MTLRxQMPOCR_MISPKTCNT_Msk = 0x7ff0000
	// Position of OVFCNTOVF field.
	Ethernet_MTL_MTLRxQMPOCR_OVFCNTOVF_Pos = 0xb
	// Bit mask of OVFCNTOVF field.
	Ethernet_MTL_MTLRxQMPOCR_OVFCNTOVF_Msk = 0x800
	// Bit OVFCNTOVF.
	Ethernet_MTL_MTLRxQMPOCR_OVFCNTOVF = 0x800
	// Position of OVFPKTCNT field.
	Ethernet_MTL_MTLRxQMPOCR_OVFPKTCNT_Pos = 0x0
	// Bit mask of OVFPKTCNT field.
	Ethernet_MTL_MTLRxQMPOCR_OVFPKTCNT_Msk = 0x7ff

	// MTLRxQDR: Rx queue debug register
	// Position of PRXQ field.
	Ethernet_MTL_MTLRxQDR_PRXQ_Pos = 0x10
	// Bit mask of PRXQ field.
	Ethernet_MTL_MTLRxQDR_PRXQ_Msk = 0x3fff0000
	// Position of RXQSTS field.
	Ethernet_MTL_MTLRxQDR_RXQSTS_Pos = 0x4
	// Bit mask of RXQSTS field.
	Ethernet_MTL_MTLRxQDR_RXQSTS_Msk = 0x30
	// Position of RRCSTS field.
	Ethernet_MTL_MTLRxQDR_RRCSTS_Pos = 0x1
	// Bit mask of RRCSTS field.
	Ethernet_MTL_MTLRxQDR_RRCSTS_Msk = 0x6
	// Position of RWCSTS field.
	Ethernet_MTL_MTLRxQDR_RWCSTS_Pos = 0x0
	// Bit mask of RWCSTS field.
	Ethernet_MTL_MTLRxQDR_RWCSTS_Msk = 0x1
	// Bit RWCSTS.
	Ethernet_MTL_MTLRxQDR_RWCSTS = 0x1
)
