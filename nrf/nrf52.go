// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from nrf52.svd, see https://github.com/NordicSemiconductor/nrfx/tree/master/mdk

//go:build nrf && nrf52
// +build nrf,nrf52

// nRF52832 reference description for radio MCU with ARM 32-bit Cortex-M4 Microcontroller
//
//     Copyright (c) 2010 - 2020, Nordic Semiconductor ASA All rights reserved.
//
//     Redistribution and use in source and binary forms, with or without
//     modification, are permitted provided that the following conditions are met:
//
//     1. Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//
//     2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
//     3. Neither the name of Nordic Semiconductor ASA nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
//
//     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//     IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
//     ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
//     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
//     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
//     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//     POSSIBILITY OF SUCH DAMAGE.
package nrf

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "nrf52"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Power control // Clock control
	IRQ_POWER_CLOCK = 0

	// Power control
	IRQ_POWER = 0

	// Clock control
	IRQ_CLOCK = 0

	// 2.4 GHz Radio
	IRQ_RADIO = 1

	// UART with EasyDMA // Universal Asynchronous Receiver/Transmitter
	IRQ_UARTE0_UART0 = 2

	// UART with EasyDMA
	IRQ_UARTE0 = 2

	// Universal Asynchronous Receiver/Transmitter
	IRQ_UART0 = 2

	// Serial Peripheral Interface Master with EasyDMA 0 // SPI Slave 0 // I2C compatible Two-Wire Master Interface with EasyDMA 0 // I2C compatible Two-Wire Slave Interface with EasyDMA 0 // Serial Peripheral Interface 0 // I2C compatible Two-Wire Interface 0
	IRQ_SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0 = 3

	// Serial Peripheral Interface Master with EasyDMA 0
	IRQ_SPIM0 = 3

	// SPI Slave 0
	IRQ_SPIS0 = 3

	// I2C compatible Two-Wire Master Interface with EasyDMA 0
	IRQ_TWIM0 = 3

	// I2C compatible Two-Wire Slave Interface with EasyDMA 0
	IRQ_TWIS0 = 3

	// Serial Peripheral Interface 0
	IRQ_SPI0 = 3

	// I2C compatible Two-Wire Interface 0
	IRQ_TWI0 = 3

	// Serial Peripheral Interface Master with EasyDMA 1 // SPI Slave 1 // I2C compatible Two-Wire Master Interface with EasyDMA 1 // I2C compatible Two-Wire Slave Interface with EasyDMA 1 // Serial Peripheral Interface 1 // I2C compatible Two-Wire Interface 1
	IRQ_SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1 = 4

	// Serial Peripheral Interface Master with EasyDMA 1
	IRQ_SPIM1 = 4

	// SPI Slave 1
	IRQ_SPIS1 = 4

	// I2C compatible Two-Wire Master Interface with EasyDMA 1
	IRQ_TWIM1 = 4

	// I2C compatible Two-Wire Slave Interface with EasyDMA 1
	IRQ_TWIS1 = 4

	// Serial Peripheral Interface 1
	IRQ_SPI1 = 4

	// I2C compatible Two-Wire Interface 1
	IRQ_TWI1 = 4

	// NFC-A compatible radio
	IRQ_NFCT = 5

	// GPIO Tasks and Events
	IRQ_GPIOTE = 6

	// Analog to Digital Converter
	IRQ_SAADC = 7

	// Timer/Counter 0
	IRQ_TIMER0 = 8

	// Timer/Counter 1
	IRQ_TIMER1 = 9

	// Timer/Counter 2
	IRQ_TIMER2 = 10

	// Real time counter 0
	IRQ_RTC0 = 11

	// Temperature Sensor
	IRQ_TEMP = 12

	// Random Number Generator
	IRQ_RNG = 13

	// AES ECB Mode Encryption
	IRQ_ECB = 14

	// AES CCM Mode Encryption // Accelerated Address Resolver
	IRQ_CCM_AAR = 15

	// AES CCM Mode Encryption
	IRQ_CCM = 15

	// Accelerated Address Resolver
	IRQ_AAR = 15

	// Watchdog Timer
	IRQ_WDT = 16

	// Real time counter 1
	IRQ_RTC1 = 17

	// Quadrature Decoder
	IRQ_QDEC = 18

	// Comparator // Low Power Comparator
	IRQ_COMP_LPCOMP = 19

	// Comparator
	IRQ_COMP = 19

	// Low Power Comparator
	IRQ_LPCOMP = 19

	// Software interrupt 0 // Event Generator Unit 0
	IRQ_SWI0_EGU0 = 20

	// Software interrupt 0
	IRQ_SWI0 = 20

	// Event Generator Unit 0
	IRQ_EGU0 = 20

	// Software interrupt 1 // Event Generator Unit 1
	IRQ_SWI1_EGU1 = 21

	// Software interrupt 1
	IRQ_SWI1 = 21

	// Event Generator Unit 1
	IRQ_EGU1 = 21

	// Software interrupt 2 // Event Generator Unit 2
	IRQ_SWI2_EGU2 = 22

	// Software interrupt 2
	IRQ_SWI2 = 22

	// Event Generator Unit 2
	IRQ_EGU2 = 22

	// Software interrupt 3 // Event Generator Unit 3
	IRQ_SWI3_EGU3 = 23

	// Software interrupt 3
	IRQ_SWI3 = 23

	// Event Generator Unit 3
	IRQ_EGU3 = 23

	// Software interrupt 4 // Event Generator Unit 4
	IRQ_SWI4_EGU4 = 24

	// Software interrupt 4
	IRQ_SWI4 = 24

	// Event Generator Unit 4
	IRQ_EGU4 = 24

	// Software interrupt 5 // Event Generator Unit 5
	IRQ_SWI5_EGU5 = 25

	// Software interrupt 5
	IRQ_SWI5 = 25

	// Event Generator Unit 5
	IRQ_EGU5 = 25

	// Timer/Counter 3
	IRQ_TIMER3 = 26

	// Timer/Counter 4
	IRQ_TIMER4 = 27

	// Pulse Width Modulation Unit 0
	IRQ_PWM0 = 28

	// Pulse Density Modulation (Digital Microphone) Interface
	IRQ_PDM = 29

	// Memory Watch Unit
	IRQ_MWU = 32

	// Pulse Width Modulation Unit 1
	IRQ_PWM1 = 33

	// Pulse Width Modulation Unit 2
	IRQ_PWM2 = 34

	// Serial Peripheral Interface Master with EasyDMA 2 // SPI Slave 2 // Serial Peripheral Interface 2
	IRQ_SPIM2_SPIS2_SPI2 = 35

	// Serial Peripheral Interface Master with EasyDMA 2
	IRQ_SPIM2 = 35

	// SPI Slave 2
	IRQ_SPIS2 = 35

	// Serial Peripheral Interface 2
	IRQ_SPI2 = 35

	// Real time counter 2
	IRQ_RTC2 = 36

	// Inter-IC Sound
	IRQ_I2S = 37

	// FPU
	IRQ_FPU = 38

	// Highest interrupt number on this device.
	IRQ_max = 38
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export POWER_CLOCK_IRQHandler
func interruptPOWER_CLOCK() {
	callHandlers(IRQ_POWER_CLOCK)
}

//export RADIO_IRQHandler
func interruptRADIO() {
	callHandlers(IRQ_RADIO)
}

//export UARTE0_UART0_IRQHandler
func interruptUARTE0_UART0() {
	callHandlers(IRQ_UARTE0_UART0)
}

//export SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
func interruptSPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0() {
	callHandlers(IRQ_SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0)
}

//export SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
func interruptSPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1() {
	callHandlers(IRQ_SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1)
}

//export NFCT_IRQHandler
func interruptNFCT() {
	callHandlers(IRQ_NFCT)
}

//export GPIOTE_IRQHandler
func interruptGPIOTE() {
	callHandlers(IRQ_GPIOTE)
}

//export SAADC_IRQHandler
func interruptSAADC() {
	callHandlers(IRQ_SAADC)
}

//export TIMER0_IRQHandler
func interruptTIMER0() {
	callHandlers(IRQ_TIMER0)
}

//export TIMER1_IRQHandler
func interruptTIMER1() {
	callHandlers(IRQ_TIMER1)
}

//export TIMER2_IRQHandler
func interruptTIMER2() {
	callHandlers(IRQ_TIMER2)
}

//export RTC0_IRQHandler
func interruptRTC0() {
	callHandlers(IRQ_RTC0)
}

//export TEMP_IRQHandler
func interruptTEMP() {
	callHandlers(IRQ_TEMP)
}

//export RNG_IRQHandler
func interruptRNG() {
	callHandlers(IRQ_RNG)
}

//export ECB_IRQHandler
func interruptECB() {
	callHandlers(IRQ_ECB)
}

//export CCM_AAR_IRQHandler
func interruptCCM_AAR() {
	callHandlers(IRQ_CCM_AAR)
}

//export WDT_IRQHandler
func interruptWDT() {
	callHandlers(IRQ_WDT)
}

//export RTC1_IRQHandler
func interruptRTC1() {
	callHandlers(IRQ_RTC1)
}

//export QDEC_IRQHandler
func interruptQDEC() {
	callHandlers(IRQ_QDEC)
}

//export COMP_LPCOMP_IRQHandler
func interruptCOMP_LPCOMP() {
	callHandlers(IRQ_COMP_LPCOMP)
}

//export SWI0_EGU0_IRQHandler
func interruptSWI0_EGU0() {
	callHandlers(IRQ_SWI0_EGU0)
}

//export SWI1_EGU1_IRQHandler
func interruptSWI1_EGU1() {
	callHandlers(IRQ_SWI1_EGU1)
}

//export SWI2_EGU2_IRQHandler
func interruptSWI2_EGU2() {
	callHandlers(IRQ_SWI2_EGU2)
}

//export SWI3_EGU3_IRQHandler
func interruptSWI3_EGU3() {
	callHandlers(IRQ_SWI3_EGU3)
}

//export SWI4_EGU4_IRQHandler
func interruptSWI4_EGU4() {
	callHandlers(IRQ_SWI4_EGU4)
}

//export SWI5_EGU5_IRQHandler
func interruptSWI5_EGU5() {
	callHandlers(IRQ_SWI5_EGU5)
}

//export TIMER3_IRQHandler
func interruptTIMER3() {
	callHandlers(IRQ_TIMER3)
}

//export TIMER4_IRQHandler
func interruptTIMER4() {
	callHandlers(IRQ_TIMER4)
}

//export PWM0_IRQHandler
func interruptPWM0() {
	callHandlers(IRQ_PWM0)
}

//export PDM_IRQHandler
func interruptPDM() {
	callHandlers(IRQ_PDM)
}

//export MWU_IRQHandler
func interruptMWU() {
	callHandlers(IRQ_MWU)
}

//export PWM1_IRQHandler
func interruptPWM1() {
	callHandlers(IRQ_PWM1)
}

//export PWM2_IRQHandler
func interruptPWM2() {
	callHandlers(IRQ_PWM2)
}

//export SPIM2_SPIS2_SPI2_IRQHandler
func interruptSPIM2_SPIS2_SPI2() {
	callHandlers(IRQ_SPIM2_SPIS2_SPI2)
}

//export RTC2_IRQHandler
func interruptRTC2() {
	callHandlers(IRQ_RTC2)
}

//export I2S_IRQHandler
func interruptI2S() {
	callHandlers(IRQ_I2S)
}

//export FPU_IRQHandler
func interruptFPU() {
	callHandlers(IRQ_FPU)
}

// Peripherals.
var (
	// Factory Information Configuration Registers
	FICR = (*FICR_Type)(unsafe.Pointer(uintptr(0x10000000)))

	// User Information Configuration Registers
	UICR = (*UICR_Type)(unsafe.Pointer(uintptr(0x10001000)))

	// Block Protect
	BPROT = (*BPROT_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Power control
	POWER = (*POWER_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Clock control
	CLOCK = (*CLOCK_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// 2.4 GHz Radio
	RADIO = (*RADIO_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// UART with EasyDMA
	UARTE0 = (*UARTE_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Universal Asynchronous Receiver/Transmitter
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Serial Peripheral Interface Master with EasyDMA 0
	SPIM0 = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// SPI Slave 0
	SPIS0 = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 0
	TWIM0 = (*TWIM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 0
	TWIS0 = (*TWIS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// I2C compatible Two-Wire Interface 0
	TWI0 = (*TWI_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// NFC-A compatible radio
	NFCT = (*NFCT_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// GPIO Tasks and Events
	GPIOTE = (*GPIOTE_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Analog to Digital Converter
	SAADC = (*SAADC_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// Timer/Counter 0
	TIMER0 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// Real time counter 0
	RTC0 = (*RTC_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// Temperature Sensor
	TEMP = (*TEMP_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// Random Number Generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x4000d000)))

	// AES ECB Mode Encryption
	ECB = (*ECB_Type)(unsafe.Pointer(uintptr(0x4000e000)))

	// AES CCM Mode Encryption
	CCM = (*CCM_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// Accelerated Address Resolver
	AAR = (*AAR_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Quadrature Decoder
	QDEC = (*QDEC_Type)(unsafe.Pointer(uintptr(0x40012000)))

	// Comparator
	COMP = (*COMP_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Low Power Comparator
	LPCOMP = (*LPCOMP_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Software interrupt 0
	SWI0 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Event Generator Unit 0
	EGU0 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Pulse Width Modulation Unit 0
	PWM0 = (*PWM_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// Pulse Density Modulation (Digital Microphone) Interface
	PDM = (*PDM_Type)(unsafe.Pointer(uintptr(0x4001d000)))

	// Non Volatile Memory Controller
	NVMC = (*NVMC_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Programmable Peripheral Interconnect
	PPI = (*PPI_Type)(unsafe.Pointer(uintptr(0x4001f000)))

	// Memory Watch Unit
	MWU = (*MWU_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// Inter-IC Sound
	I2S = (*I2S_Type)(unsafe.Pointer(uintptr(0x40025000)))

	// FPU
	FPU = (*FPU_Type)(unsafe.Pointer(uintptr(0x40026000)))

	// GPIO Port 1
	P0 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// Serial Peripheral Interface Master with EasyDMA 1
	SPIM1 = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// SPI Slave 1
	SPIS1 = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 1
	TWIM1 = (*TWIM_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 1
	TWIS1 = (*TWIS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// I2C compatible Two-Wire Interface 1
	TWI1 = (*TWI_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Timer/Counter 1
	TIMER1 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// Timer/Counter 2
	TIMER2 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x4000a000)))

	// Real time counter 1
	RTC1 = (*RTC_Type)(unsafe.Pointer(uintptr(0x40011000)))

	// Software interrupt 1
	SWI1 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Event Generator Unit 1
	EGU1 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Software interrupt 2
	SWI2 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40016000)))

	// Event Generator Unit 2
	EGU2 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40016000)))

	// Software interrupt 3
	SWI3 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40017000)))

	// Event Generator Unit 3
	EGU3 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40017000)))

	// Software interrupt 4
	SWI4 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// Event Generator Unit 4
	EGU4 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// Software interrupt 5
	SWI5 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40019000)))

	// Event Generator Unit 5
	EGU5 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40019000)))

	// Timer/Counter 3
	TIMER3 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x4001a000)))

	// Timer/Counter 4
	TIMER4 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// Pulse Width Modulation Unit 1
	PWM1 = (*PWM_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Pulse Width Modulation Unit 2
	PWM2 = (*PWM_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// Serial Peripheral Interface Master with EasyDMA 2
	SPIM2 = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// SPI Slave 2
	SPIS2 = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// Serial Peripheral Interface 2
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// Real time counter 2
	RTC2 = (*RTC_Type)(unsafe.Pointer(uintptr(0x40024000)))
)

// Factory Information Configuration Registers
type FICR_Type struct {
	_              [16]byte
	CODEPAGESIZE   volatile.Register32 // 0x10
	CODESIZE       volatile.Register32 // 0x14
	_              [72]byte
	DEVICEID       [2]volatile.Register32 // 0x60
	_              [24]byte
	ER             [4]volatile.Register32 // 0x80
	IR             [4]volatile.Register32 // 0x90
	DEVICEADDRTYPE volatile.Register32    // 0xA0
	DEVICEADDR     [2]volatile.Register32 // 0xA4
	_              [84]byte
	INFO           FICR_INFO_Type // 0x100
	_              [740]byte
	TEMP           FICR_TEMP_Type // 0x404
	_              [8]byte
	NFC            FICR_NFC_Type // 0x450
}

// FICR.CODEPAGESIZE: Code memory page size
func (o *FICR_Type) SetCODEPAGESIZE(value uint32) {
	volatile.StoreUint32(&o.CODEPAGESIZE.Reg, value)
}
func (o *FICR_Type) GetCODEPAGESIZE() uint32 {
	return volatile.LoadUint32(&o.CODEPAGESIZE.Reg)
}

// FICR.CODESIZE: Code memory size
func (o *FICR_Type) SetCODESIZE(value uint32) {
	volatile.StoreUint32(&o.CODESIZE.Reg, value)
}
func (o *FICR_Type) GetCODESIZE() uint32 {
	return volatile.LoadUint32(&o.CODESIZE.Reg)
}

// FICR.DEVICEID: Description collection[0]: Device identifier
func (o *FICR_Type) SetDEVICEID(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVICEID[idx].Reg, value)
}
func (o *FICR_Type) GetDEVICEID(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVICEID[idx].Reg)
}

// FICR.ER: Description collection[0]: Encryption Root, word 0
func (o *FICR_Type) SetER(idx int, value uint32) {
	volatile.StoreUint32(&o.ER[idx].Reg, value)
}
func (o *FICR_Type) GetER(idx int) uint32 {
	return volatile.LoadUint32(&o.ER[idx].Reg)
}

// FICR.IR: Description collection[0]: Identity Root, word 0
func (o *FICR_Type) SetIR(idx int, value uint32) {
	volatile.StoreUint32(&o.IR[idx].Reg, value)
}
func (o *FICR_Type) GetIR(idx int) uint32 {
	return volatile.LoadUint32(&o.IR[idx].Reg)
}

// FICR.DEVICEADDRTYPE: Device address type
func (o *FICR_Type) SetDEVICEADDRTYPE(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDRTYPE.Reg, volatile.LoadUint32(&o.DEVICEADDRTYPE.Reg)&^(0x1)|value)
}
func (o *FICR_Type) GetDEVICEADDRTYPE() uint32 {
	return volatile.LoadUint32(&o.DEVICEADDRTYPE.Reg) & 0x1
}

// FICR.DEVICEADDR: Description collection[0]: Device address 0
func (o *FICR_Type) SetDEVICEADDR(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR[idx].Reg, value)
}
func (o *FICR_Type) GetDEVICEADDR(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVICEADDR[idx].Reg)
}

type FICR_INFO_Type struct {
	PART    volatile.Register32    // 0x100
	VARIANT volatile.Register32    // 0x104
	PACKAGE volatile.Register32    // 0x108
	RAM     volatile.Register32    // 0x10C
	FLASH   volatile.Register32    // 0x110
	UNUSED0 [3]volatile.Register32 // 0x114
}

// FICR_INFO.PART: Part code
func (o *FICR_INFO_Type) SetPART(value uint32) {
	volatile.StoreUint32(&o.PART.Reg, value)
}
func (o *FICR_INFO_Type) GetPART() uint32 {
	return volatile.LoadUint32(&o.PART.Reg)
}

// FICR_INFO.VARIANT: Part Variant, Hardware version and Production configuration
func (o *FICR_INFO_Type) SetVARIANT(value uint32) {
	volatile.StoreUint32(&o.VARIANT.Reg, value)
}
func (o *FICR_INFO_Type) GetVARIANT() uint32 {
	return volatile.LoadUint32(&o.VARIANT.Reg)
}

// FICR_INFO.PACKAGE: Package option
func (o *FICR_INFO_Type) SetPACKAGE(value uint32) {
	volatile.StoreUint32(&o.PACKAGE.Reg, value)
}
func (o *FICR_INFO_Type) GetPACKAGE() uint32 {
	return volatile.LoadUint32(&o.PACKAGE.Reg)
}

// FICR_INFO.RAM: RAM variant
func (o *FICR_INFO_Type) SetRAM(value uint32) {
	volatile.StoreUint32(&o.RAM.Reg, value)
}
func (o *FICR_INFO_Type) GetRAM() uint32 {
	return volatile.LoadUint32(&o.RAM.Reg)
}

// FICR_INFO.FLASH: Flash variant
func (o *FICR_INFO_Type) SetFLASH(value uint32) {
	volatile.StoreUint32(&o.FLASH.Reg, value)
}
func (o *FICR_INFO_Type) GetFLASH() uint32 {
	return volatile.LoadUint32(&o.FLASH.Reg)
}

type FICR_TEMP_Type struct {
	A0 volatile.Register32 // 0x404
	A1 volatile.Register32 // 0x408
	A2 volatile.Register32 // 0x40C
	A3 volatile.Register32 // 0x410
	A4 volatile.Register32 // 0x414
	A5 volatile.Register32 // 0x418
	B0 volatile.Register32 // 0x41C
	B1 volatile.Register32 // 0x420
	B2 volatile.Register32 // 0x424
	B3 volatile.Register32 // 0x428
	B4 volatile.Register32 // 0x42C
	B5 volatile.Register32 // 0x430
	T0 volatile.Register32 // 0x434
	T1 volatile.Register32 // 0x438
	T2 volatile.Register32 // 0x43C
	T3 volatile.Register32 // 0x440
	T4 volatile.Register32 // 0x444
}

// FICR_TEMP.A0: Slope definition A0.
func (o *FICR_TEMP_Type) SetA0_A(value uint32) {
	volatile.StoreUint32(&o.A0.Reg, volatile.LoadUint32(&o.A0.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA0_A() uint32 {
	return volatile.LoadUint32(&o.A0.Reg) & 0xfff
}

// FICR_TEMP.A1: Slope definition A1.
func (o *FICR_TEMP_Type) SetA1_A(value uint32) {
	volatile.StoreUint32(&o.A1.Reg, volatile.LoadUint32(&o.A1.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA1_A() uint32 {
	return volatile.LoadUint32(&o.A1.Reg) & 0xfff
}

// FICR_TEMP.A2: Slope definition A2.
func (o *FICR_TEMP_Type) SetA2_A(value uint32) {
	volatile.StoreUint32(&o.A2.Reg, volatile.LoadUint32(&o.A2.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA2_A() uint32 {
	return volatile.LoadUint32(&o.A2.Reg) & 0xfff
}

// FICR_TEMP.A3: Slope definition A3.
func (o *FICR_TEMP_Type) SetA3_A(value uint32) {
	volatile.StoreUint32(&o.A3.Reg, volatile.LoadUint32(&o.A3.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA3_A() uint32 {
	return volatile.LoadUint32(&o.A3.Reg) & 0xfff
}

// FICR_TEMP.A4: Slope definition A4.
func (o *FICR_TEMP_Type) SetA4_A(value uint32) {
	volatile.StoreUint32(&o.A4.Reg, volatile.LoadUint32(&o.A4.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA4_A() uint32 {
	return volatile.LoadUint32(&o.A4.Reg) & 0xfff
}

// FICR_TEMP.A5: Slope definition A5.
func (o *FICR_TEMP_Type) SetA5_A(value uint32) {
	volatile.StoreUint32(&o.A5.Reg, volatile.LoadUint32(&o.A5.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA5_A() uint32 {
	return volatile.LoadUint32(&o.A5.Reg) & 0xfff
}

// FICR_TEMP.B0: y-intercept B0.
func (o *FICR_TEMP_Type) SetB0_B(value uint32) {
	volatile.StoreUint32(&o.B0.Reg, volatile.LoadUint32(&o.B0.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB0_B() uint32 {
	return volatile.LoadUint32(&o.B0.Reg) & 0x3fff
}

// FICR_TEMP.B1: y-intercept B1.
func (o *FICR_TEMP_Type) SetB1_B(value uint32) {
	volatile.StoreUint32(&o.B1.Reg, volatile.LoadUint32(&o.B1.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB1_B() uint32 {
	return volatile.LoadUint32(&o.B1.Reg) & 0x3fff
}

// FICR_TEMP.B2: y-intercept B2.
func (o *FICR_TEMP_Type) SetB2_B(value uint32) {
	volatile.StoreUint32(&o.B2.Reg, volatile.LoadUint32(&o.B2.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB2_B() uint32 {
	return volatile.LoadUint32(&o.B2.Reg) & 0x3fff
}

// FICR_TEMP.B3: y-intercept B3.
func (o *FICR_TEMP_Type) SetB3_B(value uint32) {
	volatile.StoreUint32(&o.B3.Reg, volatile.LoadUint32(&o.B3.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB3_B() uint32 {
	return volatile.LoadUint32(&o.B3.Reg) & 0x3fff
}

// FICR_TEMP.B4: y-intercept B4.
func (o *FICR_TEMP_Type) SetB4_B(value uint32) {
	volatile.StoreUint32(&o.B4.Reg, volatile.LoadUint32(&o.B4.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB4_B() uint32 {
	return volatile.LoadUint32(&o.B4.Reg) & 0x3fff
}

// FICR_TEMP.B5: y-intercept B5.
func (o *FICR_TEMP_Type) SetB5_B(value uint32) {
	volatile.StoreUint32(&o.B5.Reg, volatile.LoadUint32(&o.B5.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB5_B() uint32 {
	return volatile.LoadUint32(&o.B5.Reg) & 0x3fff
}

// FICR_TEMP.T0: Segment end T0.
func (o *FICR_TEMP_Type) SetT0_T(value uint32) {
	volatile.StoreUint32(&o.T0.Reg, volatile.LoadUint32(&o.T0.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT0_T() uint32 {
	return volatile.LoadUint32(&o.T0.Reg) & 0xff
}

// FICR_TEMP.T1: Segment end T1.
func (o *FICR_TEMP_Type) SetT1_T(value uint32) {
	volatile.StoreUint32(&o.T1.Reg, volatile.LoadUint32(&o.T1.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT1_T() uint32 {
	return volatile.LoadUint32(&o.T1.Reg) & 0xff
}

// FICR_TEMP.T2: Segment end T2.
func (o *FICR_TEMP_Type) SetT2_T(value uint32) {
	volatile.StoreUint32(&o.T2.Reg, volatile.LoadUint32(&o.T2.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT2_T() uint32 {
	return volatile.LoadUint32(&o.T2.Reg) & 0xff
}

// FICR_TEMP.T3: Segment end T3.
func (o *FICR_TEMP_Type) SetT3_T(value uint32) {
	volatile.StoreUint32(&o.T3.Reg, volatile.LoadUint32(&o.T3.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT3_T() uint32 {
	return volatile.LoadUint32(&o.T3.Reg) & 0xff
}

// FICR_TEMP.T4: Segment end T4.
func (o *FICR_TEMP_Type) SetT4_T(value uint32) {
	volatile.StoreUint32(&o.T4.Reg, volatile.LoadUint32(&o.T4.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT4_T() uint32 {
	return volatile.LoadUint32(&o.T4.Reg) & 0xff
}

type FICR_NFC_Type struct {
	TAGHEADER0 volatile.Register32 // 0x450
	TAGHEADER1 volatile.Register32 // 0x454
	TAGHEADER2 volatile.Register32 // 0x458
	TAGHEADER3 volatile.Register32 // 0x45C
}

// FICR_NFC.TAGHEADER0: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER0_MFGID(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_MFGID() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER0_UD1(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_UD1() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER0_UD2(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_UD2() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER0_UD3(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_UD3() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff000000) >> 24
}

// FICR_NFC.TAGHEADER1: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER1_UD4(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD4() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER1_UD5(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD5() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER1_UD6(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD6() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER1_UD7(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD7() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff000000) >> 24
}

// FICR_NFC.TAGHEADER2: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER2_UD8(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD8() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER2_UD9(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD9() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER2_UD10(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD10() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER2_UD11(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD11() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff000000) >> 24
}

// FICR_NFC.TAGHEADER3: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER3_UD12(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD12() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER3_UD13(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD13() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER3_UD14(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD14() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER3_UD15(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD15() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff000000) >> 24
}

// User Information Configuration Registers
type UICR_Type struct {
	UNUSED0   volatile.Register32 // 0x0
	UNUSED1   volatile.Register32 // 0x4
	UNUSED2   volatile.Register32 // 0x8
	_         [4]byte
	UNUSED3   volatile.Register32     // 0x10
	NRFFW     [15]volatile.Register32 // 0x14
	NRFHW     [12]volatile.Register32 // 0x50
	CUSTOMER  [32]volatile.Register32 // 0x80
	_         [256]byte
	PSELRESET [2]volatile.Register32 // 0x200
	APPROTECT volatile.Register32    // 0x208
	NFCPINS   volatile.Register32    // 0x20C
}

// UICR.NRFFW: Description collection[0]: Reserved for Nordic firmware design
func (o *UICR_Type) SetNRFFW(idx int, value uint32) {
	volatile.StoreUint32(&o.NRFFW[idx].Reg, value)
}
func (o *UICR_Type) GetNRFFW(idx int) uint32 {
	return volatile.LoadUint32(&o.NRFFW[idx].Reg)
}

// UICR.NRFHW: Description collection[0]: Reserved for Nordic hardware design
func (o *UICR_Type) SetNRFHW(idx int, value uint32) {
	volatile.StoreUint32(&o.NRFHW[idx].Reg, value)
}
func (o *UICR_Type) GetNRFHW(idx int) uint32 {
	return volatile.LoadUint32(&o.NRFHW[idx].Reg)
}

// UICR.CUSTOMER: Description collection[0]: Reserved for customer
func (o *UICR_Type) SetCUSTOMER(idx int, value uint32) {
	volatile.StoreUint32(&o.CUSTOMER[idx].Reg, value)
}
func (o *UICR_Type) GetCUSTOMER(idx int) uint32 {
	return volatile.LoadUint32(&o.CUSTOMER[idx].Reg)
}

// UICR.PSELRESET: Description collection[0]: Mapping of the nRESET function (see POWER chapter for details)
func (o *UICR_Type) SetPSELRESET_PIN(idx int, value uint32) {
	volatile.StoreUint32(&o.PSELRESET[idx].Reg, volatile.LoadUint32(&o.PSELRESET[idx].Reg)&^(0x3f)|value)
}
func (o *UICR_Type) GetPSELRESET_PIN(idx int) uint32 {
	return volatile.LoadUint32(&o.PSELRESET[idx].Reg) & 0x3f
}
func (o *UICR_Type) SetPSELRESET_CONNECT(idx int, value uint32) {
	volatile.StoreUint32(&o.PSELRESET[idx].Reg, volatile.LoadUint32(&o.PSELRESET[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *UICR_Type) GetPSELRESET_CONNECT(idx int) uint32 {
	return (volatile.LoadUint32(&o.PSELRESET[idx].Reg) & 0x80000000) >> 31
}

// UICR.APPROTECT: Access Port protection
func (o *UICR_Type) SetAPPROTECT_PALL(value uint32) {
	volatile.StoreUint32(&o.APPROTECT.Reg, volatile.LoadUint32(&o.APPROTECT.Reg)&^(0xff)|value)
}
func (o *UICR_Type) GetAPPROTECT_PALL() uint32 {
	return volatile.LoadUint32(&o.APPROTECT.Reg) & 0xff
}

// UICR.NFCPINS: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
func (o *UICR_Type) SetNFCPINS_PROTECT(value uint32) {
	volatile.StoreUint32(&o.NFCPINS.Reg, volatile.LoadUint32(&o.NFCPINS.Reg)&^(0x1)|value)
}
func (o *UICR_Type) GetNFCPINS_PROTECT() uint32 {
	return volatile.LoadUint32(&o.NFCPINS.Reg) & 0x1
}

// Block Protect
type BPROT_Type struct {
	_              [1536]byte
	CONFIG0        volatile.Register32 // 0x600
	CONFIG1        volatile.Register32 // 0x604
	DISABLEINDEBUG volatile.Register32 // 0x608
	UNUSED0        volatile.Register32 // 0x60C
	CONFIG2        volatile.Register32 // 0x610
	CONFIG3        volatile.Register32 // 0x614
}

// BPROT.CONFIG0: Block protect configuration register 0
func (o *BPROT_Type) SetCONFIG0_REGION0(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x1)|value)
}
func (o *BPROT_Type) GetCONFIG0_REGION0() uint32 {
	return volatile.LoadUint32(&o.CONFIG0.Reg) & 0x1
}
func (o *BPROT_Type) SetCONFIG0_REGION1(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x2)|value<<1)
}
func (o *BPROT_Type) GetCONFIG0_REGION1() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x2) >> 1
}
func (o *BPROT_Type) SetCONFIG0_REGION2(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x4)|value<<2)
}
func (o *BPROT_Type) GetCONFIG0_REGION2() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x4) >> 2
}
func (o *BPROT_Type) SetCONFIG0_REGION3(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x8)|value<<3)
}
func (o *BPROT_Type) GetCONFIG0_REGION3() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x8) >> 3
}
func (o *BPROT_Type) SetCONFIG0_REGION4(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x10)|value<<4)
}
func (o *BPROT_Type) GetCONFIG0_REGION4() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x10) >> 4
}
func (o *BPROT_Type) SetCONFIG0_REGION5(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x20)|value<<5)
}
func (o *BPROT_Type) GetCONFIG0_REGION5() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x20) >> 5
}
func (o *BPROT_Type) SetCONFIG0_REGION6(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x40)|value<<6)
}
func (o *BPROT_Type) GetCONFIG0_REGION6() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x40) >> 6
}
func (o *BPROT_Type) SetCONFIG0_REGION7(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x80)|value<<7)
}
func (o *BPROT_Type) GetCONFIG0_REGION7() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x80) >> 7
}
func (o *BPROT_Type) SetCONFIG0_REGION8(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x100)|value<<8)
}
func (o *BPROT_Type) GetCONFIG0_REGION8() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x100) >> 8
}
func (o *BPROT_Type) SetCONFIG0_REGION9(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x200)|value<<9)
}
func (o *BPROT_Type) GetCONFIG0_REGION9() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x200) >> 9
}
func (o *BPROT_Type) SetCONFIG0_REGION10(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x400)|value<<10)
}
func (o *BPROT_Type) GetCONFIG0_REGION10() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x400) >> 10
}
func (o *BPROT_Type) SetCONFIG0_REGION11(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x800)|value<<11)
}
func (o *BPROT_Type) GetCONFIG0_REGION11() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x800) >> 11
}
func (o *BPROT_Type) SetCONFIG0_REGION12(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *BPROT_Type) GetCONFIG0_REGION12() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x1000) >> 12
}
func (o *BPROT_Type) SetCONFIG0_REGION13(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x2000)|value<<13)
}
func (o *BPROT_Type) GetCONFIG0_REGION13() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x2000) >> 13
}
func (o *BPROT_Type) SetCONFIG0_REGION14(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *BPROT_Type) GetCONFIG0_REGION14() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x4000) >> 14
}
func (o *BPROT_Type) SetCONFIG0_REGION15(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x8000)|value<<15)
}
func (o *BPROT_Type) GetCONFIG0_REGION15() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x8000) >> 15
}
func (o *BPROT_Type) SetCONFIG0_REGION16(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x10000)|value<<16)
}
func (o *BPROT_Type) GetCONFIG0_REGION16() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x10000) >> 16
}
func (o *BPROT_Type) SetCONFIG0_REGION17(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x20000)|value<<17)
}
func (o *BPROT_Type) GetCONFIG0_REGION17() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x20000) >> 17
}
func (o *BPROT_Type) SetCONFIG0_REGION18(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x40000)|value<<18)
}
func (o *BPROT_Type) GetCONFIG0_REGION18() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x40000) >> 18
}
func (o *BPROT_Type) SetCONFIG0_REGION19(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x80000)|value<<19)
}
func (o *BPROT_Type) GetCONFIG0_REGION19() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x80000) >> 19
}
func (o *BPROT_Type) SetCONFIG0_REGION20(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x100000)|value<<20)
}
func (o *BPROT_Type) GetCONFIG0_REGION20() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x100000) >> 20
}
func (o *BPROT_Type) SetCONFIG0_REGION21(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x200000)|value<<21)
}
func (o *BPROT_Type) GetCONFIG0_REGION21() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x200000) >> 21
}
func (o *BPROT_Type) SetCONFIG0_REGION22(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x400000)|value<<22)
}
func (o *BPROT_Type) GetCONFIG0_REGION22() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x400000) >> 22
}
func (o *BPROT_Type) SetCONFIG0_REGION23(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x800000)|value<<23)
}
func (o *BPROT_Type) GetCONFIG0_REGION23() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x800000) >> 23
}
func (o *BPROT_Type) SetCONFIG0_REGION24(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x1000000)|value<<24)
}
func (o *BPROT_Type) GetCONFIG0_REGION24() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x1000000) >> 24
}
func (o *BPROT_Type) SetCONFIG0_REGION25(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x2000000)|value<<25)
}
func (o *BPROT_Type) GetCONFIG0_REGION25() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x2000000) >> 25
}
func (o *BPROT_Type) SetCONFIG0_REGION26(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x4000000)|value<<26)
}
func (o *BPROT_Type) GetCONFIG0_REGION26() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x4000000) >> 26
}
func (o *BPROT_Type) SetCONFIG0_REGION27(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x8000000)|value<<27)
}
func (o *BPROT_Type) GetCONFIG0_REGION27() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x8000000) >> 27
}
func (o *BPROT_Type) SetCONFIG0_REGION28(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x10000000)|value<<28)
}
func (o *BPROT_Type) GetCONFIG0_REGION28() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x10000000) >> 28
}
func (o *BPROT_Type) SetCONFIG0_REGION29(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x20000000)|value<<29)
}
func (o *BPROT_Type) GetCONFIG0_REGION29() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x20000000) >> 29
}
func (o *BPROT_Type) SetCONFIG0_REGION30(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x40000000)|value<<30)
}
func (o *BPROT_Type) GetCONFIG0_REGION30() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x40000000) >> 30
}
func (o *BPROT_Type) SetCONFIG0_REGION31(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *BPROT_Type) GetCONFIG0_REGION31() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x80000000) >> 31
}

// BPROT.CONFIG1: Block protect configuration register 1
func (o *BPROT_Type) SetCONFIG1_REGION32(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x1)|value)
}
func (o *BPROT_Type) GetCONFIG1_REGION32() uint32 {
	return volatile.LoadUint32(&o.CONFIG1.Reg) & 0x1
}
func (o *BPROT_Type) SetCONFIG1_REGION33(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x2)|value<<1)
}
func (o *BPROT_Type) GetCONFIG1_REGION33() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x2) >> 1
}
func (o *BPROT_Type) SetCONFIG1_REGION34(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x4)|value<<2)
}
func (o *BPROT_Type) GetCONFIG1_REGION34() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x4) >> 2
}
func (o *BPROT_Type) SetCONFIG1_REGION35(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x8)|value<<3)
}
func (o *BPROT_Type) GetCONFIG1_REGION35() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x8) >> 3
}
func (o *BPROT_Type) SetCONFIG1_REGION36(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x10)|value<<4)
}
func (o *BPROT_Type) GetCONFIG1_REGION36() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x10) >> 4
}
func (o *BPROT_Type) SetCONFIG1_REGION37(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x20)|value<<5)
}
func (o *BPROT_Type) GetCONFIG1_REGION37() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x20) >> 5
}
func (o *BPROT_Type) SetCONFIG1_REGION38(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x40)|value<<6)
}
func (o *BPROT_Type) GetCONFIG1_REGION38() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x40) >> 6
}
func (o *BPROT_Type) SetCONFIG1_REGION39(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x80)|value<<7)
}
func (o *BPROT_Type) GetCONFIG1_REGION39() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x80) >> 7
}
func (o *BPROT_Type) SetCONFIG1_REGION40(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x100)|value<<8)
}
func (o *BPROT_Type) GetCONFIG1_REGION40() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x100) >> 8
}
func (o *BPROT_Type) SetCONFIG1_REGION41(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x200)|value<<9)
}
func (o *BPROT_Type) GetCONFIG1_REGION41() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x200) >> 9
}
func (o *BPROT_Type) SetCONFIG1_REGION42(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x400)|value<<10)
}
func (o *BPROT_Type) GetCONFIG1_REGION42() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x400) >> 10
}
func (o *BPROT_Type) SetCONFIG1_REGION43(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x800)|value<<11)
}
func (o *BPROT_Type) GetCONFIG1_REGION43() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x800) >> 11
}
func (o *BPROT_Type) SetCONFIG1_REGION44(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x1000)|value<<12)
}
func (o *BPROT_Type) GetCONFIG1_REGION44() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x1000) >> 12
}
func (o *BPROT_Type) SetCONFIG1_REGION45(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x2000)|value<<13)
}
func (o *BPROT_Type) GetCONFIG1_REGION45() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x2000) >> 13
}
func (o *BPROT_Type) SetCONFIG1_REGION46(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x4000)|value<<14)
}
func (o *BPROT_Type) GetCONFIG1_REGION46() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x4000) >> 14
}
func (o *BPROT_Type) SetCONFIG1_REGION47(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x8000)|value<<15)
}
func (o *BPROT_Type) GetCONFIG1_REGION47() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x8000) >> 15
}
func (o *BPROT_Type) SetCONFIG1_REGION48(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x10000)|value<<16)
}
func (o *BPROT_Type) GetCONFIG1_REGION48() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x10000) >> 16
}
func (o *BPROT_Type) SetCONFIG1_REGION49(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x20000)|value<<17)
}
func (o *BPROT_Type) GetCONFIG1_REGION49() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x20000) >> 17
}
func (o *BPROT_Type) SetCONFIG1_REGION50(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x40000)|value<<18)
}
func (o *BPROT_Type) GetCONFIG1_REGION50() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x40000) >> 18
}
func (o *BPROT_Type) SetCONFIG1_REGION51(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x80000)|value<<19)
}
func (o *BPROT_Type) GetCONFIG1_REGION51() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x80000) >> 19
}
func (o *BPROT_Type) SetCONFIG1_REGION52(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x100000)|value<<20)
}
func (o *BPROT_Type) GetCONFIG1_REGION52() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x100000) >> 20
}
func (o *BPROT_Type) SetCONFIG1_REGION53(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x200000)|value<<21)
}
func (o *BPROT_Type) GetCONFIG1_REGION53() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x200000) >> 21
}
func (o *BPROT_Type) SetCONFIG1_REGION54(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x400000)|value<<22)
}
func (o *BPROT_Type) GetCONFIG1_REGION54() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x400000) >> 22
}
func (o *BPROT_Type) SetCONFIG1_REGION55(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x800000)|value<<23)
}
func (o *BPROT_Type) GetCONFIG1_REGION55() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x800000) >> 23
}
func (o *BPROT_Type) SetCONFIG1_REGION56(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x1000000)|value<<24)
}
func (o *BPROT_Type) GetCONFIG1_REGION56() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x1000000) >> 24
}
func (o *BPROT_Type) SetCONFIG1_REGION57(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x2000000)|value<<25)
}
func (o *BPROT_Type) GetCONFIG1_REGION57() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x2000000) >> 25
}
func (o *BPROT_Type) SetCONFIG1_REGION58(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x4000000)|value<<26)
}
func (o *BPROT_Type) GetCONFIG1_REGION58() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x4000000) >> 26
}
func (o *BPROT_Type) SetCONFIG1_REGION59(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x8000000)|value<<27)
}
func (o *BPROT_Type) GetCONFIG1_REGION59() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x8000000) >> 27
}
func (o *BPROT_Type) SetCONFIG1_REGION60(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x10000000)|value<<28)
}
func (o *BPROT_Type) GetCONFIG1_REGION60() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x10000000) >> 28
}
func (o *BPROT_Type) SetCONFIG1_REGION61(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x20000000)|value<<29)
}
func (o *BPROT_Type) GetCONFIG1_REGION61() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x20000000) >> 29
}
func (o *BPROT_Type) SetCONFIG1_REGION62(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x40000000)|value<<30)
}
func (o *BPROT_Type) GetCONFIG1_REGION62() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x40000000) >> 30
}
func (o *BPROT_Type) SetCONFIG1_REGION63(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x80000000)|value<<31)
}
func (o *BPROT_Type) GetCONFIG1_REGION63() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x80000000) >> 31
}

// BPROT.DISABLEINDEBUG: Disable protection mechanism in debug interface mode
func (o *BPROT_Type) SetDISABLEINDEBUG(value uint32) {
	volatile.StoreUint32(&o.DISABLEINDEBUG.Reg, volatile.LoadUint32(&o.DISABLEINDEBUG.Reg)&^(0x1)|value)
}
func (o *BPROT_Type) GetDISABLEINDEBUG() uint32 {
	return volatile.LoadUint32(&o.DISABLEINDEBUG.Reg) & 0x1
}

// BPROT.CONFIG2: Block protect configuration register 2
func (o *BPROT_Type) SetCONFIG2_REGION64(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x1)|value)
}
func (o *BPROT_Type) GetCONFIG2_REGION64() uint32 {
	return volatile.LoadUint32(&o.CONFIG2.Reg) & 0x1
}
func (o *BPROT_Type) SetCONFIG2_REGION65(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x2)|value<<1)
}
func (o *BPROT_Type) GetCONFIG2_REGION65() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x2) >> 1
}
func (o *BPROT_Type) SetCONFIG2_REGION66(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x4)|value<<2)
}
func (o *BPROT_Type) GetCONFIG2_REGION66() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x4) >> 2
}
func (o *BPROT_Type) SetCONFIG2_REGION67(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x8)|value<<3)
}
func (o *BPROT_Type) GetCONFIG2_REGION67() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x8) >> 3
}
func (o *BPROT_Type) SetCONFIG2_REGION68(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x10)|value<<4)
}
func (o *BPROT_Type) GetCONFIG2_REGION68() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x10) >> 4
}
func (o *BPROT_Type) SetCONFIG2_REGION69(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x20)|value<<5)
}
func (o *BPROT_Type) GetCONFIG2_REGION69() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x20) >> 5
}
func (o *BPROT_Type) SetCONFIG2_REGION70(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x40)|value<<6)
}
func (o *BPROT_Type) GetCONFIG2_REGION70() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x40) >> 6
}
func (o *BPROT_Type) SetCONFIG2_REGION71(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x80)|value<<7)
}
func (o *BPROT_Type) GetCONFIG2_REGION71() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x80) >> 7
}
func (o *BPROT_Type) SetCONFIG2_REGION72(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x100)|value<<8)
}
func (o *BPROT_Type) GetCONFIG2_REGION72() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x100) >> 8
}
func (o *BPROT_Type) SetCONFIG2_REGION73(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x200)|value<<9)
}
func (o *BPROT_Type) GetCONFIG2_REGION73() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x200) >> 9
}
func (o *BPROT_Type) SetCONFIG2_REGION74(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x400)|value<<10)
}
func (o *BPROT_Type) GetCONFIG2_REGION74() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x400) >> 10
}
func (o *BPROT_Type) SetCONFIG2_REGION75(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x800)|value<<11)
}
func (o *BPROT_Type) GetCONFIG2_REGION75() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x800) >> 11
}
func (o *BPROT_Type) SetCONFIG2_REGION76(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x1000)|value<<12)
}
func (o *BPROT_Type) GetCONFIG2_REGION76() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x1000) >> 12
}
func (o *BPROT_Type) SetCONFIG2_REGION77(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x2000)|value<<13)
}
func (o *BPROT_Type) GetCONFIG2_REGION77() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x2000) >> 13
}
func (o *BPROT_Type) SetCONFIG2_REGION78(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x4000)|value<<14)
}
func (o *BPROT_Type) GetCONFIG2_REGION78() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x4000) >> 14
}
func (o *BPROT_Type) SetCONFIG2_REGION79(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x8000)|value<<15)
}
func (o *BPROT_Type) GetCONFIG2_REGION79() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x8000) >> 15
}
func (o *BPROT_Type) SetCONFIG2_REGION80(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x10000)|value<<16)
}
func (o *BPROT_Type) GetCONFIG2_REGION80() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x10000) >> 16
}
func (o *BPROT_Type) SetCONFIG2_REGION81(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x20000)|value<<17)
}
func (o *BPROT_Type) GetCONFIG2_REGION81() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x20000) >> 17
}
func (o *BPROT_Type) SetCONFIG2_REGION82(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x40000)|value<<18)
}
func (o *BPROT_Type) GetCONFIG2_REGION82() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x40000) >> 18
}
func (o *BPROT_Type) SetCONFIG2_REGION83(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x80000)|value<<19)
}
func (o *BPROT_Type) GetCONFIG2_REGION83() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x80000) >> 19
}
func (o *BPROT_Type) SetCONFIG2_REGION84(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x100000)|value<<20)
}
func (o *BPROT_Type) GetCONFIG2_REGION84() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x100000) >> 20
}
func (o *BPROT_Type) SetCONFIG2_REGION85(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x200000)|value<<21)
}
func (o *BPROT_Type) GetCONFIG2_REGION85() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x200000) >> 21
}
func (o *BPROT_Type) SetCONFIG2_REGION86(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x400000)|value<<22)
}
func (o *BPROT_Type) GetCONFIG2_REGION86() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x400000) >> 22
}
func (o *BPROT_Type) SetCONFIG2_REGION87(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x800000)|value<<23)
}
func (o *BPROT_Type) GetCONFIG2_REGION87() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x800000) >> 23
}
func (o *BPROT_Type) SetCONFIG2_REGION88(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x1000000)|value<<24)
}
func (o *BPROT_Type) GetCONFIG2_REGION88() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x1000000) >> 24
}
func (o *BPROT_Type) SetCONFIG2_REGION89(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x2000000)|value<<25)
}
func (o *BPROT_Type) GetCONFIG2_REGION89() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x2000000) >> 25
}
func (o *BPROT_Type) SetCONFIG2_REGION90(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x4000000)|value<<26)
}
func (o *BPROT_Type) GetCONFIG2_REGION90() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x4000000) >> 26
}
func (o *BPROT_Type) SetCONFIG2_REGION91(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x8000000)|value<<27)
}
func (o *BPROT_Type) GetCONFIG2_REGION91() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x8000000) >> 27
}
func (o *BPROT_Type) SetCONFIG2_REGION92(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x10000000)|value<<28)
}
func (o *BPROT_Type) GetCONFIG2_REGION92() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x10000000) >> 28
}
func (o *BPROT_Type) SetCONFIG2_REGION93(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x20000000)|value<<29)
}
func (o *BPROT_Type) GetCONFIG2_REGION93() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x20000000) >> 29
}
func (o *BPROT_Type) SetCONFIG2_REGION94(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x40000000)|value<<30)
}
func (o *BPROT_Type) GetCONFIG2_REGION94() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x40000000) >> 30
}
func (o *BPROT_Type) SetCONFIG2_REGION95(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x80000000)|value<<31)
}
func (o *BPROT_Type) GetCONFIG2_REGION95() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x80000000) >> 31
}

// BPROT.CONFIG3: Block protect configuration register 3
func (o *BPROT_Type) SetCONFIG3_REGION96(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x1)|value)
}
func (o *BPROT_Type) GetCONFIG3_REGION96() uint32 {
	return volatile.LoadUint32(&o.CONFIG3.Reg) & 0x1
}
func (o *BPROT_Type) SetCONFIG3_REGION97(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x2)|value<<1)
}
func (o *BPROT_Type) GetCONFIG3_REGION97() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x2) >> 1
}
func (o *BPROT_Type) SetCONFIG3_REGION98(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x4)|value<<2)
}
func (o *BPROT_Type) GetCONFIG3_REGION98() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x4) >> 2
}
func (o *BPROT_Type) SetCONFIG3_REGION99(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x8)|value<<3)
}
func (o *BPROT_Type) GetCONFIG3_REGION99() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x8) >> 3
}
func (o *BPROT_Type) SetCONFIG3_REGION100(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x10)|value<<4)
}
func (o *BPROT_Type) GetCONFIG3_REGION100() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x10) >> 4
}
func (o *BPROT_Type) SetCONFIG3_REGION101(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x20)|value<<5)
}
func (o *BPROT_Type) GetCONFIG3_REGION101() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x20) >> 5
}
func (o *BPROT_Type) SetCONFIG3_REGION102(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x40)|value<<6)
}
func (o *BPROT_Type) GetCONFIG3_REGION102() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x40) >> 6
}
func (o *BPROT_Type) SetCONFIG3_REGION103(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x80)|value<<7)
}
func (o *BPROT_Type) GetCONFIG3_REGION103() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x80) >> 7
}
func (o *BPROT_Type) SetCONFIG3_REGION104(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x100)|value<<8)
}
func (o *BPROT_Type) GetCONFIG3_REGION104() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x100) >> 8
}
func (o *BPROT_Type) SetCONFIG3_REGION105(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x200)|value<<9)
}
func (o *BPROT_Type) GetCONFIG3_REGION105() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x200) >> 9
}
func (o *BPROT_Type) SetCONFIG3_REGION106(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x400)|value<<10)
}
func (o *BPROT_Type) GetCONFIG3_REGION106() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x400) >> 10
}
func (o *BPROT_Type) SetCONFIG3_REGION107(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x800)|value<<11)
}
func (o *BPROT_Type) GetCONFIG3_REGION107() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x800) >> 11
}
func (o *BPROT_Type) SetCONFIG3_REGION108(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x1000)|value<<12)
}
func (o *BPROT_Type) GetCONFIG3_REGION108() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x1000) >> 12
}
func (o *BPROT_Type) SetCONFIG3_REGION109(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x2000)|value<<13)
}
func (o *BPROT_Type) GetCONFIG3_REGION109() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x2000) >> 13
}
func (o *BPROT_Type) SetCONFIG3_REGION110(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x4000)|value<<14)
}
func (o *BPROT_Type) GetCONFIG3_REGION110() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x4000) >> 14
}
func (o *BPROT_Type) SetCONFIG3_REGION111(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x8000)|value<<15)
}
func (o *BPROT_Type) GetCONFIG3_REGION111() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x8000) >> 15
}
func (o *BPROT_Type) SetCONFIG3_REGION112(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x10000)|value<<16)
}
func (o *BPROT_Type) GetCONFIG3_REGION112() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x10000) >> 16
}
func (o *BPROT_Type) SetCONFIG3_REGION113(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x20000)|value<<17)
}
func (o *BPROT_Type) GetCONFIG3_REGION113() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x20000) >> 17
}
func (o *BPROT_Type) SetCONFIG3_REGION114(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x40000)|value<<18)
}
func (o *BPROT_Type) GetCONFIG3_REGION114() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x40000) >> 18
}
func (o *BPROT_Type) SetCONFIG3_REGION115(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x80000)|value<<19)
}
func (o *BPROT_Type) GetCONFIG3_REGION115() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x80000) >> 19
}
func (o *BPROT_Type) SetCONFIG3_REGION116(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x100000)|value<<20)
}
func (o *BPROT_Type) GetCONFIG3_REGION116() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x100000) >> 20
}
func (o *BPROT_Type) SetCONFIG3_REGION117(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x200000)|value<<21)
}
func (o *BPROT_Type) GetCONFIG3_REGION117() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x200000) >> 21
}
func (o *BPROT_Type) SetCONFIG3_REGION118(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x400000)|value<<22)
}
func (o *BPROT_Type) GetCONFIG3_REGION118() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x400000) >> 22
}
func (o *BPROT_Type) SetCONFIG3_REGION119(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x800000)|value<<23)
}
func (o *BPROT_Type) GetCONFIG3_REGION119() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x800000) >> 23
}
func (o *BPROT_Type) SetCONFIG3_REGION120(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x1000000)|value<<24)
}
func (o *BPROT_Type) GetCONFIG3_REGION120() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x1000000) >> 24
}
func (o *BPROT_Type) SetCONFIG3_REGION121(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x2000000)|value<<25)
}
func (o *BPROT_Type) GetCONFIG3_REGION121() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x2000000) >> 25
}
func (o *BPROT_Type) SetCONFIG3_REGION122(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x4000000)|value<<26)
}
func (o *BPROT_Type) GetCONFIG3_REGION122() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x4000000) >> 26
}
func (o *BPROT_Type) SetCONFIG3_REGION123(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x8000000)|value<<27)
}
func (o *BPROT_Type) GetCONFIG3_REGION123() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x8000000) >> 27
}
func (o *BPROT_Type) SetCONFIG3_REGION124(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x10000000)|value<<28)
}
func (o *BPROT_Type) GetCONFIG3_REGION124() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x10000000) >> 28
}
func (o *BPROT_Type) SetCONFIG3_REGION125(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x20000000)|value<<29)
}
func (o *BPROT_Type) GetCONFIG3_REGION125() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x20000000) >> 29
}
func (o *BPROT_Type) SetCONFIG3_REGION126(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x40000000)|value<<30)
}
func (o *BPROT_Type) GetCONFIG3_REGION126() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x40000000) >> 30
}
func (o *BPROT_Type) SetCONFIG3_REGION127(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x80000000)|value<<31)
}
func (o *BPROT_Type) GetCONFIG3_REGION127() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x80000000) >> 31
}

// Power control
type POWER_Type struct {
	_                 [120]byte
	TASKS_CONSTLAT    volatile.Register32 // 0x78
	TASKS_LOWPWR      volatile.Register32 // 0x7C
	_                 [136]byte
	EVENTS_POFWARN    volatile.Register32 // 0x108
	_                 [8]byte
	EVENTS_SLEEPENTER volatile.Register32 // 0x114
	EVENTS_SLEEPEXIT  volatile.Register32 // 0x118
	_                 [488]byte
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
	_                 [244]byte
	RESETREAS         volatile.Register32 // 0x400
	_                 [36]byte
	RAMSTATUS         volatile.Register32 // 0x428
	_                 [212]byte
	SYSTEMOFF         volatile.Register32 // 0x500
	_                 [12]byte
	POFCON            volatile.Register32 // 0x510
	_                 [8]byte
	GPREGRET          volatile.Register32 // 0x51C
	GPREGRET2         volatile.Register32 // 0x520
	RAMON             volatile.Register32 // 0x524
	_                 [44]byte
	RAMONB            volatile.Register32 // 0x554
	_                 [32]byte
	DCDCEN            volatile.Register32 // 0x578
	_                 [900]byte
	RAM               [8]POWER_RAM_Type // 0x900
}

// POWER.INTENSET: Enable interrupt
func (o *POWER_Type) SetINTENSET_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTENSET_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTENSET_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTENSET_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTENSET_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTENSET_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}

// POWER.INTENCLR: Disable interrupt
func (o *POWER_Type) SetINTENCLR_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTENCLR_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTENCLR_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTENCLR_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTENCLR_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTENCLR_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}

// POWER.RESETREAS: Reset reason
func (o *POWER_Type) SetRESETREAS_RESETPIN(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetRESETREAS_RESETPIN() uint32 {
	return volatile.LoadUint32(&o.RESETREAS.Reg) & 0x1
}
func (o *POWER_Type) SetRESETREAS_DOG(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetRESETREAS_DOG() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x2) >> 1
}
func (o *POWER_Type) SetRESETREAS_SREQ(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetRESETREAS_SREQ() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetRESETREAS_LOCKUP(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x8)|value<<3)
}
func (o *POWER_Type) GetRESETREAS_LOCKUP() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x8) >> 3
}
func (o *POWER_Type) SetRESETREAS_OFF(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_Type) GetRESETREAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x10000) >> 16
}
func (o *POWER_Type) SetRESETREAS_LPCOMP(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_Type) GetRESETREAS_LPCOMP() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x20000) >> 17
}
func (o *POWER_Type) SetRESETREAS_DIF(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x40000)|value<<18)
}
func (o *POWER_Type) GetRESETREAS_DIF() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x40000) >> 18
}
func (o *POWER_Type) SetRESETREAS_NFC(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x80000)|value<<19)
}
func (o *POWER_Type) GetRESETREAS_NFC() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x80000) >> 19
}

// POWER.RAMSTATUS: Deprecated register - RAM status register
func (o *POWER_Type) SetRAMSTATUS_RAMBLOCK0(value uint32) {
	volatile.StoreUint32(&o.RAMSTATUS.Reg, volatile.LoadUint32(&o.RAMSTATUS.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetRAMSTATUS_RAMBLOCK0() uint32 {
	return volatile.LoadUint32(&o.RAMSTATUS.Reg) & 0x1
}
func (o *POWER_Type) SetRAMSTATUS_RAMBLOCK1(value uint32) {
	volatile.StoreUint32(&o.RAMSTATUS.Reg, volatile.LoadUint32(&o.RAMSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetRAMSTATUS_RAMBLOCK1() uint32 {
	return (volatile.LoadUint32(&o.RAMSTATUS.Reg) & 0x2) >> 1
}
func (o *POWER_Type) SetRAMSTATUS_RAMBLOCK2(value uint32) {
	volatile.StoreUint32(&o.RAMSTATUS.Reg, volatile.LoadUint32(&o.RAMSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetRAMSTATUS_RAMBLOCK2() uint32 {
	return (volatile.LoadUint32(&o.RAMSTATUS.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetRAMSTATUS_RAMBLOCK3(value uint32) {
	volatile.StoreUint32(&o.RAMSTATUS.Reg, volatile.LoadUint32(&o.RAMSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *POWER_Type) GetRAMSTATUS_RAMBLOCK3() uint32 {
	return (volatile.LoadUint32(&o.RAMSTATUS.Reg) & 0x8) >> 3
}

// POWER.SYSTEMOFF: System OFF register
func (o *POWER_Type) SetSYSTEMOFF(value uint32) {
	volatile.StoreUint32(&o.SYSTEMOFF.Reg, volatile.LoadUint32(&o.SYSTEMOFF.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetSYSTEMOFF() uint32 {
	return volatile.LoadUint32(&o.SYSTEMOFF.Reg) & 0x1
}

// POWER.POFCON: Power failure comparator configuration
func (o *POWER_Type) SetPOFCON_POF(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetPOFCON_POF() uint32 {
	return volatile.LoadUint32(&o.POFCON.Reg) & 0x1
}
func (o *POWER_Type) SetPOFCON_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0x1e)|value<<1)
}
func (o *POWER_Type) GetPOFCON_THRESHOLD() uint32 {
	return (volatile.LoadUint32(&o.POFCON.Reg) & 0x1e) >> 1
}

// POWER.GPREGRET: General purpose retention register
func (o *POWER_Type) SetGPREGRET(value uint32) {
	volatile.StoreUint32(&o.GPREGRET.Reg, volatile.LoadUint32(&o.GPREGRET.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetGPREGRET() uint32 {
	return volatile.LoadUint32(&o.GPREGRET.Reg) & 0xff
}

// POWER.GPREGRET2: General purpose retention register
func (o *POWER_Type) SetGPREGRET2_GPREGRET(value uint32) {
	volatile.StoreUint32(&o.GPREGRET2.Reg, volatile.LoadUint32(&o.GPREGRET2.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetGPREGRET2_GPREGRET() uint32 {
	return volatile.LoadUint32(&o.GPREGRET2.Reg) & 0xff
}

// POWER.RAMON: Deprecated register - RAM on/off register (this register is retained)
func (o *POWER_Type) SetRAMON_ONRAM0(value uint32) {
	volatile.StoreUint32(&o.RAMON.Reg, volatile.LoadUint32(&o.RAMON.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetRAMON_ONRAM0() uint32 {
	return volatile.LoadUint32(&o.RAMON.Reg) & 0x1
}
func (o *POWER_Type) SetRAMON_ONRAM1(value uint32) {
	volatile.StoreUint32(&o.RAMON.Reg, volatile.LoadUint32(&o.RAMON.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetRAMON_ONRAM1() uint32 {
	return (volatile.LoadUint32(&o.RAMON.Reg) & 0x2) >> 1
}
func (o *POWER_Type) SetRAMON_OFFRAM0(value uint32) {
	volatile.StoreUint32(&o.RAMON.Reg, volatile.LoadUint32(&o.RAMON.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_Type) GetRAMON_OFFRAM0() uint32 {
	return (volatile.LoadUint32(&o.RAMON.Reg) & 0x10000) >> 16
}
func (o *POWER_Type) SetRAMON_OFFRAM1(value uint32) {
	volatile.StoreUint32(&o.RAMON.Reg, volatile.LoadUint32(&o.RAMON.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_Type) GetRAMON_OFFRAM1() uint32 {
	return (volatile.LoadUint32(&o.RAMON.Reg) & 0x20000) >> 17
}

// POWER.RAMONB: Deprecated register - RAM on/off register (this register is retained)
func (o *POWER_Type) SetRAMONB_ONRAM2(value uint32) {
	volatile.StoreUint32(&o.RAMONB.Reg, volatile.LoadUint32(&o.RAMONB.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetRAMONB_ONRAM2() uint32 {
	return volatile.LoadUint32(&o.RAMONB.Reg) & 0x1
}
func (o *POWER_Type) SetRAMONB_ONRAM3(value uint32) {
	volatile.StoreUint32(&o.RAMONB.Reg, volatile.LoadUint32(&o.RAMONB.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetRAMONB_ONRAM3() uint32 {
	return (volatile.LoadUint32(&o.RAMONB.Reg) & 0x2) >> 1
}
func (o *POWER_Type) SetRAMONB_OFFRAM2(value uint32) {
	volatile.StoreUint32(&o.RAMONB.Reg, volatile.LoadUint32(&o.RAMONB.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_Type) GetRAMONB_OFFRAM2() uint32 {
	return (volatile.LoadUint32(&o.RAMONB.Reg) & 0x10000) >> 16
}
func (o *POWER_Type) SetRAMONB_OFFRAM3(value uint32) {
	volatile.StoreUint32(&o.RAMONB.Reg, volatile.LoadUint32(&o.RAMONB.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_Type) GetRAMONB_OFFRAM3() uint32 {
	return (volatile.LoadUint32(&o.RAMONB.Reg) & 0x20000) >> 17
}

// POWER.DCDCEN: DC/DC enable register
func (o *POWER_Type) SetDCDCEN(value uint32) {
	volatile.StoreUint32(&o.DCDCEN.Reg, volatile.LoadUint32(&o.DCDCEN.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetDCDCEN() uint32 {
	return volatile.LoadUint32(&o.DCDCEN.Reg) & 0x1
}

type POWER_RAM_Type struct {
	POWER    volatile.Register32 // 0x900
	POWERSET volatile.Register32 // 0x904
	POWERCLR volatile.Register32 // 0x908
	_        [4]byte
}

// POWER_RAM.POWER: Description cluster[0]: RAM0 power control register
func (o *POWER_RAM_Type) SetPOWER_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1)|value)
}
func (o *POWER_RAM_Type) GetPOWER_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x1
}
func (o *POWER_RAM_Type) SetPOWER_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x2)|value<<1)
}
func (o *POWER_RAM_Type) GetPOWER_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x2) >> 1
}
func (o *POWER_RAM_Type) SetPOWER_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_RAM_Type) GetPOWER_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x10000) >> 16
}
func (o *POWER_RAM_Type) SetPOWER_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_RAM_Type) GetPOWER_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x20000) >> 17
}

// POWER_RAM.POWERSET: Description cluster[0]: RAM0 power control set register
func (o *POWER_RAM_Type) SetPOWERSET_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x1)|value)
}
func (o *POWER_RAM_Type) GetPOWERSET_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWERSET.Reg) & 0x1
}
func (o *POWER_RAM_Type) SetPOWERSET_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x2)|value<<1)
}
func (o *POWER_RAM_Type) GetPOWERSET_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x2) >> 1
}
func (o *POWER_RAM_Type) SetPOWERSET_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_RAM_Type) GetPOWERSET_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x10000) >> 16
}
func (o *POWER_RAM_Type) SetPOWERSET_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_RAM_Type) GetPOWERSET_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x20000) >> 17
}

// POWER_RAM.POWERCLR: Description cluster[0]: RAM0 power control clear register
func (o *POWER_RAM_Type) SetPOWERCLR_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x1)|value)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWERCLR.Reg) & 0x1
}
func (o *POWER_RAM_Type) SetPOWERCLR_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x2)|value<<1)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x2) >> 1
}
func (o *POWER_RAM_Type) SetPOWERCLR_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x10000) >> 16
}
func (o *POWER_RAM_Type) SetPOWERCLR_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x20000) >> 17
}

// Clock control
type CLOCK_Type struct {
	TASKS_HFCLKSTART    volatile.Register32 // 0x0
	TASKS_HFCLKSTOP     volatile.Register32 // 0x4
	TASKS_LFCLKSTART    volatile.Register32 // 0x8
	TASKS_LFCLKSTOP     volatile.Register32 // 0xC
	TASKS_CAL           volatile.Register32 // 0x10
	TASKS_CTSTART       volatile.Register32 // 0x14
	TASKS_CTSTOP        volatile.Register32 // 0x18
	_                   [228]byte
	EVENTS_HFCLKSTARTED volatile.Register32 // 0x100
	EVENTS_LFCLKSTARTED volatile.Register32 // 0x104
	_                   [4]byte
	EVENTS_DONE         volatile.Register32 // 0x10C
	EVENTS_CTTO         volatile.Register32 // 0x110
	_                   [496]byte
	INTENSET            volatile.Register32 // 0x304
	INTENCLR            volatile.Register32 // 0x308
	_                   [252]byte
	HFCLKRUN            volatile.Register32 // 0x408
	HFCLKSTAT           volatile.Register32 // 0x40C
	_                   [4]byte
	LFCLKRUN            volatile.Register32 // 0x414
	LFCLKSTAT           volatile.Register32 // 0x418
	LFCLKSRCCOPY        volatile.Register32 // 0x41C
	_                   [248]byte
	LFCLKSRC            volatile.Register32 // 0x518
	_                   [28]byte
	CTIV                volatile.Register32 // 0x538
	_                   [32]byte
	TRACECONFIG         volatile.Register32 // 0x55C
}

// CLOCK.INTENSET: Enable interrupt
func (o *CLOCK_Type) SetINTENSET_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTENSET_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTENSET_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTENSET_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTENSET_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *CLOCK_Type) GetINTENSET_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *CLOCK_Type) SetINTENSET_CTTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetINTENSET_CTTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}

// CLOCK.INTENCLR: Disable interrupt
func (o *CLOCK_Type) SetINTENCLR_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTENCLR_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTENCLR_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTENCLR_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTENCLR_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *CLOCK_Type) GetINTENCLR_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *CLOCK_Type) SetINTENCLR_CTTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetINTENCLR_CTTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}

// CLOCK.HFCLKRUN: Status indicating that HFCLKSTART task has been triggered
func (o *CLOCK_Type) SetHFCLKRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.HFCLKRUN.Reg, volatile.LoadUint32(&o.HFCLKRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.HFCLKRUN.Reg) & 0x1
}

// CLOCK.HFCLKSTAT: HFCLK status
func (o *CLOCK_Type) SetHFCLKSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x1
}
func (o *CLOCK_Type) SetHFCLKSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetHFCLKSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.LFCLKRUN: Status indicating that LFCLKSTART task has been triggered
func (o *CLOCK_Type) SetLFCLKRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.LFCLKRUN.Reg, volatile.LoadUint32(&o.LFCLKRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetLFCLKRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.LFCLKRUN.Reg) & 0x1
}

// CLOCK.LFCLKSTAT: LFCLK status
func (o *CLOCK_Type) SetLFCLKSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x3
}
func (o *CLOCK_Type) SetLFCLKSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetLFCLKSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.LFCLKSRCCOPY: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
func (o *CLOCK_Type) SetLFCLKSRCCOPY_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRCCOPY.Reg, volatile.LoadUint32(&o.LFCLKSRCCOPY.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSRCCOPY_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSRCCOPY.Reg) & 0x3
}

// CLOCK.LFCLKSRC: Clock source for the LFCLK
func (o *CLOCK_Type) SetLFCLKSRC_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSRC_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x3
}
func (o *CLOCK_Type) SetLFCLKSRC_BYPASS(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetLFCLKSRC_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x10000) >> 16
}
func (o *CLOCK_Type) SetLFCLKSRC_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x20000)|value<<17)
}
func (o *CLOCK_Type) GetLFCLKSRC_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x20000) >> 17
}

// CLOCK.CTIV: Calibration timer interval
func (o *CLOCK_Type) SetCTIV(value uint32) {
	volatile.StoreUint32(&o.CTIV.Reg, volatile.LoadUint32(&o.CTIV.Reg)&^(0x7f)|value)
}
func (o *CLOCK_Type) GetCTIV() uint32 {
	return volatile.LoadUint32(&o.CTIV.Reg) & 0x7f
}

// CLOCK.TRACECONFIG: Clocking options for the Trace Port debug interface
func (o *CLOCK_Type) SetTRACECONFIG_TRACEPORTSPEED(value uint32) {
	volatile.StoreUint32(&o.TRACECONFIG.Reg, volatile.LoadUint32(&o.TRACECONFIG.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetTRACECONFIG_TRACEPORTSPEED() uint32 {
	return volatile.LoadUint32(&o.TRACECONFIG.Reg) & 0x3
}
func (o *CLOCK_Type) SetTRACECONFIG_TRACEMUX(value uint32) {
	volatile.StoreUint32(&o.TRACECONFIG.Reg, volatile.LoadUint32(&o.TRACECONFIG.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCK_Type) GetTRACECONFIG_TRACEMUX() uint32 {
	return (volatile.LoadUint32(&o.TRACECONFIG.Reg) & 0x30000) >> 16
}

// 2.4 GHz Radio
type RADIO_Type struct {
	TASKS_TXEN      volatile.Register32 // 0x0
	TASKS_RXEN      volatile.Register32 // 0x4
	TASKS_START     volatile.Register32 // 0x8
	TASKS_STOP      volatile.Register32 // 0xC
	TASKS_DISABLE   volatile.Register32 // 0x10
	TASKS_RSSISTART volatile.Register32 // 0x14
	TASKS_RSSISTOP  volatile.Register32 // 0x18
	TASKS_BCSTART   volatile.Register32 // 0x1C
	TASKS_BCSTOP    volatile.Register32 // 0x20
	_               [220]byte
	EVENTS_READY    volatile.Register32 // 0x100
	EVENTS_ADDRESS  volatile.Register32 // 0x104
	EVENTS_PAYLOAD  volatile.Register32 // 0x108
	EVENTS_END      volatile.Register32 // 0x10C
	EVENTS_DISABLED volatile.Register32 // 0x110
	EVENTS_DEVMATCH volatile.Register32 // 0x114
	EVENTS_DEVMISS  volatile.Register32 // 0x118
	EVENTS_RSSIEND  volatile.Register32 // 0x11C
	_               [8]byte
	EVENTS_BCMATCH  volatile.Register32 // 0x128
	_               [4]byte
	EVENTS_CRCOK    volatile.Register32 // 0x130
	EVENTS_CRCERROR volatile.Register32 // 0x134
	_               [200]byte
	SHORTS          volatile.Register32 // 0x200
	_               [256]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [244]byte
	CRCSTATUS       volatile.Register32 // 0x400
	_               [4]byte
	RXMATCH         volatile.Register32 // 0x408
	RXCRC           volatile.Register32 // 0x40C
	DAI             volatile.Register32 // 0x410
	_               [240]byte
	PACKETPTR       volatile.Register32 // 0x504
	FREQUENCY       volatile.Register32 // 0x508
	TXPOWER         volatile.Register32 // 0x50C
	MODE            volatile.Register32 // 0x510
	PCNF0           volatile.Register32 // 0x514
	PCNF1           volatile.Register32 // 0x518
	BASE0           volatile.Register32 // 0x51C
	BASE1           volatile.Register32 // 0x520
	PREFIX0         volatile.Register32 // 0x524
	PREFIX1         volatile.Register32 // 0x528
	TXADDRESS       volatile.Register32 // 0x52C
	RXADDRESSES     volatile.Register32 // 0x530
	CRCCNF          volatile.Register32 // 0x534
	CRCPOLY         volatile.Register32 // 0x538
	CRCINIT         volatile.Register32 // 0x53C
	UNUSED0         volatile.Register32 // 0x540
	TIFS            volatile.Register32 // 0x544
	RSSISAMPLE      volatile.Register32 // 0x548
	_               [4]byte
	STATE           volatile.Register32 // 0x550
	DATAWHITEIV     volatile.Register32 // 0x554
	_               [8]byte
	BCC             volatile.Register32 // 0x560
	_               [156]byte
	DAB             [8]volatile.Register32 // 0x600
	DAP             [8]volatile.Register32 // 0x620
	DACNF           volatile.Register32    // 0x640
	_               [12]byte
	MODECNF0        volatile.Register32 // 0x650
	_               [2472]byte
	POWER           volatile.Register32 // 0xFFC
}

// RADIO.SHORTS: Shortcut register
func (o *RADIO_Type) SetSHORTS_READY_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetSHORTS_READY_START() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *RADIO_Type) SetSHORTS_END_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetSHORTS_END_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetSHORTS_DISABLED_TXEN(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetSHORTS_DISABLED_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetSHORTS_DISABLED_RXEN(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetSHORTS_DISABLED_RXEN() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetSHORTS_ADDRESS_RSSISTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetSHORTS_ADDRESS_RSSISTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetSHORTS_END_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetSHORTS_END_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetSHORTS_ADDRESS_BCSTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetSHORTS_ADDRESS_BCSTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetSHORTS_DISABLED_RSSISTOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetSHORTS_DISABLED_RSSISTOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}

// RADIO.INTENSET: Enable interrupt
func (o *RADIO_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *RADIO_Type) SetINTENSET_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetINTENSET_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetINTENSET_PAYLOAD(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetINTENSET_PAYLOAD() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetINTENSET_DISABLED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetINTENSET_DISABLED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetINTENSET_DEVMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetINTENSET_DEVMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetINTENSET_DEVMISS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetINTENSET_DEVMISS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetINTENSET_RSSIEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetINTENSET_RSSIEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetINTENSET_BCMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *RADIO_Type) GetINTENSET_BCMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *RADIO_Type) SetINTENSET_CRCOK(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetINTENSET_CRCOK() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetINTENSET_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetINTENSET_CRCERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}

// RADIO.INTENCLR: Disable interrupt
func (o *RADIO_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *RADIO_Type) SetINTENCLR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetINTENCLR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetINTENCLR_PAYLOAD(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetINTENCLR_PAYLOAD() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetINTENCLR_DISABLED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetINTENCLR_DISABLED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetINTENCLR_DEVMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetINTENCLR_DEVMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetINTENCLR_DEVMISS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetINTENCLR_DEVMISS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetINTENCLR_RSSIEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetINTENCLR_RSSIEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetINTENCLR_BCMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *RADIO_Type) GetINTENCLR_BCMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *RADIO_Type) SetINTENCLR_CRCOK(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetINTENCLR_CRCOK() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetINTENCLR_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetINTENCLR_CRCERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}

// RADIO.CRCSTATUS: CRC status
func (o *RADIO_Type) SetCRCSTATUS(value uint32) {
	volatile.StoreUint32(&o.CRCSTATUS.Reg, volatile.LoadUint32(&o.CRCSTATUS.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetCRCSTATUS() uint32 {
	return volatile.LoadUint32(&o.CRCSTATUS.Reg) & 0x1
}

// RADIO.RXMATCH: Received address
func (o *RADIO_Type) SetRXMATCH(value uint32) {
	volatile.StoreUint32(&o.RXMATCH.Reg, volatile.LoadUint32(&o.RXMATCH.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetRXMATCH() uint32 {
	return volatile.LoadUint32(&o.RXMATCH.Reg) & 0x7
}

// RADIO.RXCRC: CRC field of previously received packet
func (o *RADIO_Type) SetRXCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRC.Reg, volatile.LoadUint32(&o.RXCRC.Reg)&^(0xffffff)|value)
}
func (o *RADIO_Type) GetRXCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRC.Reg) & 0xffffff
}

// RADIO.DAI: Device address match index
func (o *RADIO_Type) SetDAI(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetDAI() uint32 {
	return volatile.LoadUint32(&o.DAI.Reg) & 0x7
}

// RADIO.PACKETPTR: Packet pointer
func (o *RADIO_Type) SetPACKETPTR(value uint32) {
	volatile.StoreUint32(&o.PACKETPTR.Reg, value)
}
func (o *RADIO_Type) GetPACKETPTR() uint32 {
	return volatile.LoadUint32(&o.PACKETPTR.Reg)
}

// RADIO.FREQUENCY: Frequency
func (o *RADIO_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, volatile.LoadUint32(&o.FREQUENCY.Reg)&^(0x7f)|value)
}
func (o *RADIO_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg) & 0x7f
}
func (o *RADIO_Type) SetFREQUENCY_MAP(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, volatile.LoadUint32(&o.FREQUENCY.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetFREQUENCY_MAP() uint32 {
	return (volatile.LoadUint32(&o.FREQUENCY.Reg) & 0x100) >> 8
}

// RADIO.TXPOWER: Output power
func (o *RADIO_Type) SetTXPOWER(value uint32) {
	volatile.StoreUint32(&o.TXPOWER.Reg, volatile.LoadUint32(&o.TXPOWER.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetTXPOWER() uint32 {
	return volatile.LoadUint32(&o.TXPOWER.Reg) & 0xff
}

// RADIO.MODE: Data rate and modulation
func (o *RADIO_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0xf)|value)
}
func (o *RADIO_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0xf
}

// RADIO.PCNF0: Packet configuration register 0
func (o *RADIO_Type) SetPCNF0_LFLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0xf)|value)
}
func (o *RADIO_Type) GetPCNF0_LFLEN() uint32 {
	return volatile.LoadUint32(&o.PCNF0.Reg) & 0xf
}
func (o *RADIO_Type) SetPCNF0_S0LEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetPCNF0_S0LEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x100) >> 8
}
func (o *RADIO_Type) SetPCNF0_S1LEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0xf0000)|value<<16)
}
func (o *RADIO_Type) GetPCNF0_S1LEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0xf0000) >> 16
}
func (o *RADIO_Type) SetPCNF0_S1INCL(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x100000)|value<<20)
}
func (o *RADIO_Type) GetPCNF0_S1INCL() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x100000) >> 20
}
func (o *RADIO_Type) SetPCNF0_PLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x1000000)|value<<24)
}
func (o *RADIO_Type) GetPCNF0_PLEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x1000000) >> 24
}

// RADIO.PCNF1: Packet configuration register 1
func (o *RADIO_Type) SetPCNF1_MAXLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetPCNF1_MAXLEN() uint32 {
	return volatile.LoadUint32(&o.PCNF1.Reg) & 0xff
}
func (o *RADIO_Type) SetPCNF1_STATLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetPCNF1_STATLEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetPCNF1_BALEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0x70000)|value<<16)
}
func (o *RADIO_Type) GetPCNF1_BALEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0x70000) >> 16
}
func (o *RADIO_Type) SetPCNF1_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0x1000000)|value<<24)
}
func (o *RADIO_Type) GetPCNF1_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0x1000000) >> 24
}
func (o *RADIO_Type) SetPCNF1_WHITEEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0x2000000)|value<<25)
}
func (o *RADIO_Type) GetPCNF1_WHITEEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0x2000000) >> 25
}

// RADIO.BASE0: Base address 0
func (o *RADIO_Type) SetBASE0(value uint32) {
	volatile.StoreUint32(&o.BASE0.Reg, value)
}
func (o *RADIO_Type) GetBASE0() uint32 {
	return volatile.LoadUint32(&o.BASE0.Reg)
}

// RADIO.BASE1: Base address 1
func (o *RADIO_Type) SetBASE1(value uint32) {
	volatile.StoreUint32(&o.BASE1.Reg, value)
}
func (o *RADIO_Type) GetBASE1() uint32 {
	return volatile.LoadUint32(&o.BASE1.Reg)
}

// RADIO.PREFIX0: Prefixes bytes for logical addresses 0-3
func (o *RADIO_Type) SetPREFIX0_AP0(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetPREFIX0_AP0() uint32 {
	return volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff
}
func (o *RADIO_Type) SetPREFIX0_AP1(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetPREFIX0_AP1() uint32 {
	return (volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetPREFIX0_AP2(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff0000)|value<<16)
}
func (o *RADIO_Type) GetPREFIX0_AP2() uint32 {
	return (volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff0000) >> 16
}
func (o *RADIO_Type) SetPREFIX0_AP3(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff000000)|value<<24)
}
func (o *RADIO_Type) GetPREFIX0_AP3() uint32 {
	return (volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff000000) >> 24
}

// RADIO.PREFIX1: Prefixes bytes for logical addresses 4-7
func (o *RADIO_Type) SetPREFIX1_AP4(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetPREFIX1_AP4() uint32 {
	return volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff
}
func (o *RADIO_Type) SetPREFIX1_AP5(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetPREFIX1_AP5() uint32 {
	return (volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetPREFIX1_AP6(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff0000)|value<<16)
}
func (o *RADIO_Type) GetPREFIX1_AP6() uint32 {
	return (volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff0000) >> 16
}
func (o *RADIO_Type) SetPREFIX1_AP7(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff000000)|value<<24)
}
func (o *RADIO_Type) GetPREFIX1_AP7() uint32 {
	return (volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff000000) >> 24
}

// RADIO.TXADDRESS: Transmit address select
func (o *RADIO_Type) SetTXADDRESS(value uint32) {
	volatile.StoreUint32(&o.TXADDRESS.Reg, volatile.LoadUint32(&o.TXADDRESS.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetTXADDRESS() uint32 {
	return volatile.LoadUint32(&o.TXADDRESS.Reg) & 0x7
}

// RADIO.RXADDRESSES: Receive address select
func (o *RADIO_Type) SetRXADDRESSES_ADDR0(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR0() uint32 {
	return volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x1
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR1(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR1() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR2(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR2() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR3(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR3() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR4(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR4() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR5(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR5() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR6(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR6() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR7(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR7() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x80) >> 7
}

// RADIO.CRCCNF: CRC configuration
func (o *RADIO_Type) SetCRCCNF_LEN(value uint32) {
	volatile.StoreUint32(&o.CRCCNF.Reg, volatile.LoadUint32(&o.CRCCNF.Reg)&^(0x3)|value)
}
func (o *RADIO_Type) GetCRCCNF_LEN() uint32 {
	return volatile.LoadUint32(&o.CRCCNF.Reg) & 0x3
}
func (o *RADIO_Type) SetCRCCNF_SKIPADDR(value uint32) {
	volatile.StoreUint32(&o.CRCCNF.Reg, volatile.LoadUint32(&o.CRCCNF.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetCRCCNF_SKIPADDR() uint32 {
	return (volatile.LoadUint32(&o.CRCCNF.Reg) & 0x100) >> 8
}

// RADIO.CRCPOLY: CRC polynomial
func (o *RADIO_Type) SetCRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPOLY.Reg, volatile.LoadUint32(&o.CRCPOLY.Reg)&^(0xffffff)|value)
}
func (o *RADIO_Type) GetCRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPOLY.Reg) & 0xffffff
}

// RADIO.CRCINIT: CRC initial value
func (o *RADIO_Type) SetCRCINIT(value uint32) {
	volatile.StoreUint32(&o.CRCINIT.Reg, volatile.LoadUint32(&o.CRCINIT.Reg)&^(0xffffff)|value)
}
func (o *RADIO_Type) GetCRCINIT() uint32 {
	return volatile.LoadUint32(&o.CRCINIT.Reg) & 0xffffff
}

// RADIO.TIFS: Inter Frame Spacing in us
func (o *RADIO_Type) SetTIFS(value uint32) {
	volatile.StoreUint32(&o.TIFS.Reg, volatile.LoadUint32(&o.TIFS.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetTIFS() uint32 {
	return volatile.LoadUint32(&o.TIFS.Reg) & 0xff
}

// RADIO.RSSISAMPLE: RSSI sample
func (o *RADIO_Type) SetRSSISAMPLE(value uint32) {
	volatile.StoreUint32(&o.RSSISAMPLE.Reg, volatile.LoadUint32(&o.RSSISAMPLE.Reg)&^(0x7f)|value)
}
func (o *RADIO_Type) GetRSSISAMPLE() uint32 {
	return volatile.LoadUint32(&o.RSSISAMPLE.Reg) & 0x7f
}

// RADIO.STATE: Current radio state
func (o *RADIO_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf)|value)
}
func (o *RADIO_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0xf
}

// RADIO.DATAWHITEIV: Data whitening initial value
func (o *RADIO_Type) SetDATAWHITEIV(value uint32) {
	volatile.StoreUint32(&o.DATAWHITEIV.Reg, volatile.LoadUint32(&o.DATAWHITEIV.Reg)&^(0x7f)|value)
}
func (o *RADIO_Type) GetDATAWHITEIV() uint32 {
	return volatile.LoadUint32(&o.DATAWHITEIV.Reg) & 0x7f
}

// RADIO.BCC: Bit counter compare
func (o *RADIO_Type) SetBCC(value uint32) {
	volatile.StoreUint32(&o.BCC.Reg, value)
}
func (o *RADIO_Type) GetBCC() uint32 {
	return volatile.LoadUint32(&o.BCC.Reg)
}

// RADIO.DAB: Description collection[0]: Device address base segment 0
func (o *RADIO_Type) SetDAB(idx int, value uint32) {
	volatile.StoreUint32(&o.DAB[idx].Reg, value)
}
func (o *RADIO_Type) GetDAB(idx int) uint32 {
	return volatile.LoadUint32(&o.DAB[idx].Reg)
}

// RADIO.DAP: Description collection[0]: Device address prefix 0
func (o *RADIO_Type) SetDAP(idx int, value uint32) {
	volatile.StoreUint32(&o.DAP[idx].Reg, volatile.LoadUint32(&o.DAP[idx].Reg)&^(0xffff)|value)
}
func (o *RADIO_Type) GetDAP(idx int) uint32 {
	return volatile.LoadUint32(&o.DAP[idx].Reg) & 0xffff
}

// RADIO.DACNF: Device address match configuration
func (o *RADIO_Type) SetDACNF_ENA0(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetDACNF_ENA0() uint32 {
	return volatile.LoadUint32(&o.DACNF.Reg) & 0x1
}
func (o *RADIO_Type) SetDACNF_ENA1(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetDACNF_ENA1() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetDACNF_ENA2(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetDACNF_ENA2() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetDACNF_ENA3(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetDACNF_ENA3() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetDACNF_ENA4(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetDACNF_ENA4() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetDACNF_ENA5(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetDACNF_ENA5() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetDACNF_ENA6(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetDACNF_ENA6() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetDACNF_ENA7(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetDACNF_ENA7() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetDACNF_TXADD0(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetDACNF_TXADD0() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x100) >> 8
}
func (o *RADIO_Type) SetDACNF_TXADD1(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x200)|value<<9)
}
func (o *RADIO_Type) GetDACNF_TXADD1() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x200) >> 9
}
func (o *RADIO_Type) SetDACNF_TXADD2(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x400)|value<<10)
}
func (o *RADIO_Type) GetDACNF_TXADD2() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x400) >> 10
}
func (o *RADIO_Type) SetDACNF_TXADD3(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x800)|value<<11)
}
func (o *RADIO_Type) GetDACNF_TXADD3() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x800) >> 11
}
func (o *RADIO_Type) SetDACNF_TXADD4(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetDACNF_TXADD4() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetDACNF_TXADD5(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetDACNF_TXADD5() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x2000) >> 13
}
func (o *RADIO_Type) SetDACNF_TXADD6(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x4000)|value<<14)
}
func (o *RADIO_Type) GetDACNF_TXADD6() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x4000) >> 14
}
func (o *RADIO_Type) SetDACNF_TXADD7(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x8000)|value<<15)
}
func (o *RADIO_Type) GetDACNF_TXADD7() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x8000) >> 15
}

// RADIO.MODECNF0: Radio mode configuration register 0
func (o *RADIO_Type) SetMODECNF0_RU(value uint32) {
	volatile.StoreUint32(&o.MODECNF0.Reg, volatile.LoadUint32(&o.MODECNF0.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetMODECNF0_RU() uint32 {
	return volatile.LoadUint32(&o.MODECNF0.Reg) & 0x1
}
func (o *RADIO_Type) SetMODECNF0_DTX(value uint32) {
	volatile.StoreUint32(&o.MODECNF0.Reg, volatile.LoadUint32(&o.MODECNF0.Reg)&^(0x300)|value<<8)
}
func (o *RADIO_Type) GetMODECNF0_DTX() uint32 {
	return (volatile.LoadUint32(&o.MODECNF0.Reg) & 0x300) >> 8
}

// RADIO.POWER: Peripheral power control
func (o *RADIO_Type) SetPOWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetPOWER() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x1
}

// UART with EasyDMA
type UARTE_Type struct {
	TASKS_STARTRX    volatile.Register32 // 0x0
	TASKS_STOPRX     volatile.Register32 // 0x4
	TASKS_STARTTX    volatile.Register32 // 0x8
	TASKS_STOPTX     volatile.Register32 // 0xC
	_                [28]byte
	TASKS_FLUSHRX    volatile.Register32 // 0x2C
	_                [208]byte
	EVENTS_CTS       volatile.Register32 // 0x100
	EVENTS_NCTS      volatile.Register32 // 0x104
	EVENTS_RXDRDY    volatile.Register32 // 0x108
	_                [4]byte
	EVENTS_ENDRX     volatile.Register32 // 0x110
	_                [8]byte
	EVENTS_TXDRDY    volatile.Register32 // 0x11C
	EVENTS_ENDTX     volatile.Register32 // 0x120
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [28]byte
	EVENTS_RXTO      volatile.Register32 // 0x144
	_                [4]byte
	EVENTS_RXSTARTED volatile.Register32 // 0x14C
	EVENTS_TXSTARTED volatile.Register32 // 0x150
	_                [4]byte
	EVENTS_TXSTOPPED volatile.Register32 // 0x158
	_                [164]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [372]byte
	ERRORSRC         volatile.Register32 // 0x480
	_                [124]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             UARTE_PSEL_Type // 0x508
	_                [12]byte
	BAUDRATE         volatile.Register32 // 0x524
	_                [12]byte
	RXD              UARTE_RXD_Type // 0x534
	_                [4]byte
	TXD              UARTE_TXD_Type // 0x544
	_                [28]byte
	CONFIG           volatile.Register32 // 0x56C
}

// UARTE.SHORTS: Shortcut register
func (o *UARTE_Type) SetSHORTS_ENDRX_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_Type) GetSHORTS_ENDRX_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *UARTE_Type) SetSHORTS_ENDRX_STOPRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *UARTE_Type) GetSHORTS_ENDRX_STOPRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}

// UARTE.INTEN: Enable or disable interrupt
func (o *UARTE_Type) SetINTEN_CTS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTEN_CTS() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *UARTE_Type) SetINTEN_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTEN_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTEN_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTEN_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTEN_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTEN_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTEN_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTEN_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTEN_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTEN_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTEN_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTEN_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTEN_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTEN_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400000) >> 22
}

// UARTE.INTENSET: Enable interrupt
func (o *UARTE_Type) SetINTENSET_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTENSET_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *UARTE_Type) SetINTENSET_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTENSET_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTENSET_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTENSET_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTENSET_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTENSET_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTENSET_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTENSET_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTENSET_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTENSET_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400000) >> 22
}

// UARTE.INTENCLR: Disable interrupt
func (o *UARTE_Type) SetINTENCLR_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTENCLR_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *UARTE_Type) SetINTENCLR_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTENCLR_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTENCLR_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTENCLR_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTENCLR_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTENCLR_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTENCLR_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTENCLR_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTENCLR_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTENCLR_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400000) >> 22
}

// UARTE.ERRORSRC: Error source
func (o *UARTE_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *UARTE_Type) SetERRORSRC_PARITY(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetERRORSRC_PARITY() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetERRORSRC_FRAMING(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetERRORSRC_FRAMING() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetERRORSRC_BREAK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *UARTE_Type) GetERRORSRC_BREAK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// UARTE.ENABLE: Enable UART
func (o *UARTE_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *UARTE_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// UARTE.BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
func (o *UARTE_Type) SetBAUDRATE(value uint32) {
	volatile.StoreUint32(&o.BAUDRATE.Reg, value)
}
func (o *UARTE_Type) GetBAUDRATE() uint32 {
	return volatile.LoadUint32(&o.BAUDRATE.Reg)
}

// UARTE.CONFIG: Configuration of parity and hardware flow control
func (o *UARTE_Type) SetCONFIG_HWFC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetCONFIG_HWFC() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *UARTE_Type) SetCONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xe)|value<<1)
}
func (o *UARTE_Type) GetCONFIG_PARITY() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xe) >> 1
}

type UARTE_PSEL_Type struct {
	RTS volatile.Register32 // 0x508
	TXD volatile.Register32 // 0x50C
	CTS volatile.Register32 // 0x510
	RXD volatile.Register32 // 0x514
}

// UARTE_PSEL.RTS: Pin select for RTS signal
func (o *UARTE_PSEL_Type) SetRTS_PIN(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetRTS_PIN() uint32 {
	return volatile.LoadUint32(&o.RTS.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetRTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetRTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RTS.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.TXD: Pin select for TXD signal
func (o *UARTE_PSEL_Type) SetTXD_PIN(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetTXD_PIN() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetTXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetTXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TXD.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.CTS: Pin select for CTS signal
func (o *UARTE_PSEL_Type) SetCTS_PIN(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetCTS_PIN() uint32 {
	return volatile.LoadUint32(&o.CTS.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetCTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetCTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CTS.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.RXD: Pin select for RXD signal
func (o *UARTE_PSEL_Type) SetRXD_PIN(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetRXD_PIN() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetRXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetRXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RXD.Reg) & 0x80000000) >> 31
}

type UARTE_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
}

// UARTE_RXD.PTR: Data pointer
func (o *UARTE_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *UARTE_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// UARTE_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *UARTE_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *UARTE_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// UARTE_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *UARTE_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *UARTE_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

type UARTE_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
}

// UARTE_TXD.PTR: Data pointer
func (o *UARTE_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *UARTE_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// UARTE_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *UARTE_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *UARTE_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// UARTE_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *UARTE_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *UARTE_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// Universal Asynchronous Receiver/Transmitter
type UART_Type struct {
	TASKS_STARTRX volatile.Register32 // 0x0
	TASKS_STOPRX  volatile.Register32 // 0x4
	TASKS_STARTTX volatile.Register32 // 0x8
	TASKS_STOPTX  volatile.Register32 // 0xC
	_             [12]byte
	TASKS_SUSPEND volatile.Register32 // 0x1C
	_             [224]byte
	EVENTS_CTS    volatile.Register32 // 0x100
	EVENTS_NCTS   volatile.Register32 // 0x104
	EVENTS_RXDRDY volatile.Register32 // 0x108
	_             [16]byte
	EVENTS_TXDRDY volatile.Register32 // 0x11C
	_             [4]byte
	EVENTS_ERROR  volatile.Register32 // 0x124
	_             [28]byte
	EVENTS_RXTO   volatile.Register32 // 0x144
	_             [184]byte
	SHORTS        volatile.Register32 // 0x200
	_             [256]byte
	INTENSET      volatile.Register32 // 0x304
	INTENCLR      volatile.Register32 // 0x308
	_             [372]byte
	ERRORSRC      volatile.Register32 // 0x480
	_             [124]byte
	ENABLE        volatile.Register32 // 0x500
	_             [4]byte
	PSELRTS       volatile.Register32 // 0x508
	PSELTXD       volatile.Register32 // 0x50C
	PSELCTS       volatile.Register32 // 0x510
	PSELRXD       volatile.Register32 // 0x514
	RXD           volatile.Register32 // 0x518
	TXD           volatile.Register32 // 0x51C
	_             [4]byte
	BAUDRATE      volatile.Register32 // 0x524
	_             [68]byte
	CONFIG        volatile.Register32 // 0x56C
}

// UART.SHORTS: Shortcut register
func (o *UART_Type) SetSHORTS_CTS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetSHORTS_CTS_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetSHORTS_NCTS_STOPRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetSHORTS_NCTS_STOPRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// UART.INTENSET: Enable interrupt
func (o *UART_Type) SetINTENSET_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINTENSET_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *UART_Type) SetINTENSET_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINTENSET_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINTENSET_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINTENSET_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINTENSET_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINTENSET_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINTENSET_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINTENSET_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}

// UART.INTENCLR: Disable interrupt
func (o *UART_Type) SetINTENCLR_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINTENCLR_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *UART_Type) SetINTENCLR_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINTENCLR_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINTENCLR_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINTENCLR_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINTENCLR_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINTENCLR_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINTENCLR_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINTENCLR_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}

// UART.ERRORSRC: Error source
func (o *UART_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *UART_Type) SetERRORSRC_PARITY(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetERRORSRC_PARITY() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetERRORSRC_FRAMING(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetERRORSRC_FRAMING() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetERRORSRC_BREAK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetERRORSRC_BREAK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// UART.ENABLE: Enable UART
func (o *UART_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// UART.PSELRTS: Pin select for RTS
func (o *UART_Type) SetPSELRTS(value uint32) {
	volatile.StoreUint32(&o.PSELRTS.Reg, value)
}
func (o *UART_Type) GetPSELRTS() uint32 {
	return volatile.LoadUint32(&o.PSELRTS.Reg)
}

// UART.PSELTXD: Pin select for TXD
func (o *UART_Type) SetPSELTXD(value uint32) {
	volatile.StoreUint32(&o.PSELTXD.Reg, value)
}
func (o *UART_Type) GetPSELTXD() uint32 {
	return volatile.LoadUint32(&o.PSELTXD.Reg)
}

// UART.PSELCTS: Pin select for CTS
func (o *UART_Type) SetPSELCTS(value uint32) {
	volatile.StoreUint32(&o.PSELCTS.Reg, value)
}
func (o *UART_Type) GetPSELCTS() uint32 {
	return volatile.LoadUint32(&o.PSELCTS.Reg)
}

// UART.PSELRXD: Pin select for RXD
func (o *UART_Type) SetPSELRXD(value uint32) {
	volatile.StoreUint32(&o.PSELRXD.Reg, value)
}
func (o *UART_Type) GetPSELRXD() uint32 {
	return volatile.LoadUint32(&o.PSELRXD.Reg)
}

// UART.RXD: RXD register
func (o *UART_Type) SetRXD(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRXD() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0xff
}

// UART.TXD: TXD register
func (o *UART_Type) SetTXD(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetTXD() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0xff
}

// UART.BAUDRATE: Baud rate
func (o *UART_Type) SetBAUDRATE(value uint32) {
	volatile.StoreUint32(&o.BAUDRATE.Reg, value)
}
func (o *UART_Type) GetBAUDRATE() uint32 {
	return volatile.LoadUint32(&o.BAUDRATE.Reg)
}

// UART.CONFIG: Configuration of parity and hardware flow control
func (o *UART_Type) SetCONFIG_HWFC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetCONFIG_HWFC() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *UART_Type) SetCONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xe)|value<<1)
}
func (o *UART_Type) GetCONFIG_PARITY() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xe) >> 1
}

// Serial Peripheral Interface Master with EasyDMA 0
type SPIM_Type struct {
	_              [16]byte
	TASKS_START    volatile.Register32 // 0x10
	TASKS_STOP     volatile.Register32 // 0x14
	_              [4]byte
	TASKS_SUSPEND  volatile.Register32 // 0x1C
	TASKS_RESUME   volatile.Register32 // 0x20
	_              [224]byte
	EVENTS_STOPPED volatile.Register32 // 0x104
	_              [8]byte
	EVENTS_ENDRX   volatile.Register32 // 0x110
	_              [4]byte
	EVENTS_END     volatile.Register32 // 0x118
	_              [4]byte
	EVENTS_ENDTX   volatile.Register32 // 0x120
	_              [40]byte
	EVENTS_STARTED volatile.Register32 // 0x14C
	_              [176]byte
	SHORTS         volatile.Register32 // 0x200
	_              [256]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [500]byte
	ENABLE         volatile.Register32 // 0x500
	_              [4]byte
	PSEL           SPIM_PSEL_Type // 0x508
	_              [16]byte
	FREQUENCY      volatile.Register32 // 0x524
	_              [12]byte
	RXD            SPIM_RXD_Type       // 0x534
	TXD            SPIM_TXD_Type       // 0x544
	CONFIG         volatile.Register32 // 0x554
	_              [104]byte
	ORC            volatile.Register32 // 0x5C0
}

// SPIM.SHORTS: Shortcut register
func (o *SPIM_Type) SetSHORTS_END_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20000)|value<<17)
}
func (o *SPIM_Type) GetSHORTS_END_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20000) >> 17
}

// SPIM.INTENSET: Enable interrupt
func (o *SPIM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPIM_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPIM_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *SPIM_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *SPIM_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SPIM_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *SPIM_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *SPIM_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}

// SPIM.INTENCLR: Disable interrupt
func (o *SPIM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPIM_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPIM_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *SPIM_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *SPIM_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SPIM_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *SPIM_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *SPIM_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}

// SPIM.ENABLE: Enable SPIM
func (o *SPIM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPIM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPIM.FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
func (o *SPIM_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *SPIM_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// SPIM.CONFIG: Configuration register
func (o *SPIM_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPIM_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPIM_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// SPIM.ORC: Over-read character. Character clocked out in case and over-read of the TXD buffer.
func (o *SPIM_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

type SPIM_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MOSI volatile.Register32 // 0x50C
	MISO volatile.Register32 // 0x510
}

// SPIM_PSEL.SCK: Pin select for SCK
func (o *SPIM_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.MOSI: Pin select for MOSI signal
func (o *SPIM_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.MISO: Pin select for MISO signal
func (o *SPIM_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

type SPIM_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// SPIM_RXD.PTR: Data pointer
func (o *SPIM_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIM_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIM_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *SPIM_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *SPIM_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// SPIM_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *SPIM_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *SPIM_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// SPIM_RXD.LIST: EasyDMA list type
func (o *SPIM_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *SPIM_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

type SPIM_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// SPIM_TXD.PTR: Data pointer
func (o *SPIM_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIM_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIM_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *SPIM_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *SPIM_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// SPIM_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *SPIM_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *SPIM_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// SPIM_TXD.LIST: EasyDMA list type
func (o *SPIM_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *SPIM_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

// SPI Slave 0
type SPIS_Type struct {
	_               [36]byte
	TASKS_ACQUIRE   volatile.Register32 // 0x24
	TASKS_RELEASE   volatile.Register32 // 0x28
	_               [216]byte
	EVENTS_END      volatile.Register32 // 0x104
	_               [8]byte
	EVENTS_ENDRX    volatile.Register32 // 0x110
	_               [20]byte
	EVENTS_ACQUIRED volatile.Register32 // 0x128
	_               [212]byte
	SHORTS          volatile.Register32 // 0x200
	_               [256]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [244]byte
	SEMSTAT         volatile.Register32 // 0x400
	_               [60]byte
	STATUS          volatile.Register32 // 0x440
	_               [188]byte
	ENABLE          volatile.Register32 // 0x500
	_               [4]byte
	PSEL            SPIS_PSEL_Type // 0x508
	_               [28]byte
	RXD             SPIS_RXD_Type // 0x534
	_               [4]byte
	TXD             SPIS_TXD_Type // 0x544
	_               [4]byte
	CONFIG          volatile.Register32 // 0x554
	_               [4]byte
	DEF             volatile.Register32 // 0x55C
	_               [96]byte
	ORC             volatile.Register32 // 0x5C0
}

// SPIS.SHORTS: Shortcut register
func (o *SPIS_Type) SetSHORTS_END_ACQUIRE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *SPIS_Type) GetSHORTS_END_ACQUIRE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}

// SPIS.INTENSET: Enable interrupt
func (o *SPIS_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPIS_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPIS_Type) SetINTENSET_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *SPIS_Type) GetINTENSET_ACQUIRED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}

// SPIS.INTENCLR: Disable interrupt
func (o *SPIS_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPIS_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPIS_Type) SetINTENCLR_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *SPIS_Type) GetINTENCLR_ACQUIRED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}

// SPIS.SEMSTAT: Semaphore status register
func (o *SPIS_Type) SetSEMSTAT(value uint32) {
	volatile.StoreUint32(&o.SEMSTAT.Reg, volatile.LoadUint32(&o.SEMSTAT.Reg)&^(0x3)|value)
}
func (o *SPIS_Type) GetSEMSTAT() uint32 {
	return volatile.LoadUint32(&o.SEMSTAT.Reg) & 0x3
}

// SPIS.STATUS: Status from last transaction
func (o *SPIS_Type) SetSTATUS_OVERREAD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetSTATUS_OVERREAD() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *SPIS_Type) SetSTATUS_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetSTATUS_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}

// SPIS.ENABLE: Enable SPI slave
func (o *SPIS_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPIS_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPIS.CONFIG: Configuration register
func (o *SPIS_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPIS_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPIS_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// SPIS.DEF: Default character. Character clocked out in case of an ignored transaction.
func (o *SPIS_Type) SetDEF(value uint32) {
	volatile.StoreUint32(&o.DEF.Reg, volatile.LoadUint32(&o.DEF.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetDEF() uint32 {
	return volatile.LoadUint32(&o.DEF.Reg) & 0xff
}

// SPIS.ORC: Over-read character
func (o *SPIS_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

type SPIS_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MISO volatile.Register32 // 0x50C
	MOSI volatile.Register32 // 0x510
	CSN  volatile.Register32 // 0x514
}

// SPIS_PSEL.SCK: Pin select for SCK
func (o *SPIS_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.MISO: Pin select for MISO signal
func (o *SPIS_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.MOSI: Pin select for MOSI signal
func (o *SPIS_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.CSN: Pin select for CSN signal
func (o *SPIS_PSEL_Type) SetCSN_PIN(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetCSN_PIN() uint32 {
	return volatile.LoadUint32(&o.CSN.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetCSN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetCSN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x80000000) >> 31
}

type SPIS_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
}

// SPIS_RXD.PTR: RXD data pointer
func (o *SPIS_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIS_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIS_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *SPIS_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *SPIS_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// SPIS_RXD.AMOUNT: Number of bytes received in last granted transaction
func (o *SPIS_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *SPIS_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

type SPIS_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
}

// SPIS_TXD.PTR: TXD data pointer
func (o *SPIS_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIS_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIS_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *SPIS_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *SPIS_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// SPIS_TXD.AMOUNT: Number of bytes transmitted in last granted transaction
func (o *SPIS_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *SPIS_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// I2C compatible Two-Wire Master Interface with EasyDMA 0
type TWIM_Type struct {
	TASKS_STARTRX    volatile.Register32 // 0x0
	_                [4]byte
	TASKS_STARTTX    volatile.Register32 // 0x8
	_                [8]byte
	TASKS_STOP       volatile.Register32 // 0x14
	_                [4]byte
	TASKS_SUSPEND    volatile.Register32 // 0x1C
	TASKS_RESUME     volatile.Register32 // 0x20
	_                [224]byte
	EVENTS_STOPPED   volatile.Register32 // 0x104
	_                [28]byte
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [32]byte
	EVENTS_SUSPENDED volatile.Register32 // 0x148
	EVENTS_RXSTARTED volatile.Register32 // 0x14C
	EVENTS_TXSTARTED volatile.Register32 // 0x150
	_                [8]byte
	EVENTS_LASTRX    volatile.Register32 // 0x15C
	EVENTS_LASTTX    volatile.Register32 // 0x160
	_                [156]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [440]byte
	ERRORSRC         volatile.Register32 // 0x4C4
	_                [56]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             TWIM_PSEL_Type // 0x508
	_                [20]byte
	FREQUENCY        volatile.Register32 // 0x524
	_                [12]byte
	RXD              TWIM_RXD_Type // 0x534
	TXD              TWIM_TXD_Type // 0x544
	_                [52]byte
	ADDRESS          volatile.Register32 // 0x588
}

// TWIM.SHORTS: Shortcut register
func (o *TWIM_Type) SetSHORTS_LASTTX_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x80)|value<<7)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x80) >> 7
}
func (o *TWIM_Type) SetSHORTS_LASTTX_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}
func (o *TWIM_Type) SetSHORTS_LASTTX_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetSHORTS_LASTRX_STARTTX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x400)|value<<10)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_STARTTX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x400) >> 10
}
func (o *TWIM_Type) SetSHORTS_LASTRX_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1000)|value<<12)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x1000) >> 12
}

// TWIM.INTEN: Enable or disable interrupt
func (o *TWIM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTEN_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTEN_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTEN_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTEN_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTEN_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTEN_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}

// TWIM.INTENSET: Enable interrupt
func (o *TWIM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTENSET_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTENSET_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTENSET_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTENSET_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTENSET_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTENSET_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}

// TWIM.INTENCLR: Disable interrupt
func (o *TWIM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTENCLR_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTENCLR_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTENCLR_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTENCLR_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTENCLR_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTENCLR_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}

// TWIM.ERRORSRC: Error source
func (o *TWIM_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWIM_Type) SetERRORSRC_ANACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetERRORSRC_ANACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWIM_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}

// TWIM.ENABLE: Enable TWIM
func (o *TWIM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWIM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWIM.FREQUENCY: TWI frequency
func (o *TWIM_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *TWIM_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// TWIM.ADDRESS: Address used in the TWI transfer
func (o *TWIM_Type) SetADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDRESS.Reg, volatile.LoadUint32(&o.ADDRESS.Reg)&^(0x7f)|value)
}
func (o *TWIM_Type) GetADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDRESS.Reg) & 0x7f
}

type TWIM_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWIM_PSEL.SCL: Pin select for SCL signal
func (o *TWIM_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWIM_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWIM_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWIM_PSEL.SDA: Pin select for SDA signal
func (o *TWIM_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWIM_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWIM_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

type TWIM_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// TWIM_RXD.PTR: Data pointer
func (o *TWIM_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIM_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIM_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *TWIM_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *TWIM_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// TWIM_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *TWIM_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *TWIM_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// TWIM_RXD.LIST: EasyDMA list type
func (o *TWIM_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *TWIM_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

type TWIM_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// TWIM_TXD.PTR: Data pointer
func (o *TWIM_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIM_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIM_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *TWIM_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *TWIM_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// TWIM_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *TWIM_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *TWIM_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// TWIM_TXD.LIST: EasyDMA list type
func (o *TWIM_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *TWIM_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

// I2C compatible Two-Wire Slave Interface with EasyDMA 0
type TWIS_Type struct {
	_                [20]byte
	TASKS_STOP       volatile.Register32 // 0x14
	_                [4]byte
	TASKS_SUSPEND    volatile.Register32 // 0x1C
	TASKS_RESUME     volatile.Register32 // 0x20
	_                [12]byte
	TASKS_PREPARERX  volatile.Register32 // 0x30
	TASKS_PREPARETX  volatile.Register32 // 0x34
	_                [204]byte
	EVENTS_STOPPED   volatile.Register32 // 0x104
	_                [28]byte
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [36]byte
	EVENTS_RXSTARTED volatile.Register32 // 0x14C
	EVENTS_TXSTARTED volatile.Register32 // 0x150
	_                [16]byte
	EVENTS_WRITE     volatile.Register32 // 0x164
	EVENTS_READ      volatile.Register32 // 0x168
	_                [148]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [452]byte
	ERRORSRC         volatile.Register32 // 0x4D0
	MATCH            volatile.Register32 // 0x4D4
	_                [40]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             TWIS_PSEL_Type // 0x508
	_                [36]byte
	RXD              TWIS_RXD_Type // 0x534
	_                [4]byte
	TXD              TWIS_TXD_Type // 0x544
	_                [56]byte
	ADDRESS          [2]volatile.Register32 // 0x588
	_                [4]byte
	CONFIG           volatile.Register32 // 0x594
	_                [40]byte
	ORC              volatile.Register32 // 0x5C0
}

// TWIS.SHORTS: Shortcut register
func (o *TWIS_Type) SetSHORTS_WRITE_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2000)|value<<13)
}
func (o *TWIS_Type) GetSHORTS_WRITE_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2000) >> 13
}
func (o *TWIS_Type) SetSHORTS_READ_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4000)|value<<14)
}
func (o *TWIS_Type) GetSHORTS_READ_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4000) >> 14
}

// TWIS.INTEN: Enable or disable interrupt
func (o *TWIS_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTEN_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTEN_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTEN_READ(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTEN_READ() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000000) >> 26
}

// TWIS.INTENSET: Enable interrupt
func (o *TWIS_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTENSET_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTENSET_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTENSET_READ(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTENSET_READ() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000000) >> 26
}

// TWIS.INTENCLR: Disable interrupt
func (o *TWIS_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTENCLR_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTENCLR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTENCLR_READ(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTENCLR_READ() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000000) >> 26
}

// TWIS.ERRORSRC: Error source
func (o *TWIS_Type) SetERRORSRC_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetERRORSRC_OVERFLOW() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWIS_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWIS_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *TWIS_Type) SetERRORSRC_OVERREAD(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *TWIS_Type) GetERRORSRC_OVERREAD() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// TWIS.MATCH: Status register indicating which address had a match
func (o *TWIS_Type) SetMATCH(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetMATCH() uint32 {
	return volatile.LoadUint32(&o.MATCH.Reg) & 0x1
}

// TWIS.ENABLE: Enable TWIS
func (o *TWIS_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWIS_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWIS.ADDRESS: Description collection[0]: TWI slave address 0
func (o *TWIS_Type) SetADDRESS(idx int, value uint32) {
	volatile.StoreUint32(&o.ADDRESS[idx].Reg, volatile.LoadUint32(&o.ADDRESS[idx].Reg)&^(0x7f)|value)
}
func (o *TWIS_Type) GetADDRESS(idx int) uint32 {
	return volatile.LoadUint32(&o.ADDRESS[idx].Reg) & 0x7f
}

// TWIS.CONFIG: Configuration register for the address match mechanism
func (o *TWIS_Type) SetCONFIG_ADDRESS0(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetCONFIG_ADDRESS0() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *TWIS_Type) SetCONFIG_ADDRESS1(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetCONFIG_ADDRESS1() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}

// TWIS.ORC: Over-read character. Character sent out in case of an over-read of the transmit buffer.
func (o *TWIS_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

type TWIS_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWIS_PSEL.SCL: Pin select for SCL signal
func (o *TWIS_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWIS_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWIS_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWIS_PSEL.SDA: Pin select for SDA signal
func (o *TWIS_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWIS_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWIS_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

type TWIS_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
}

// TWIS_RXD.PTR: RXD Data pointer
func (o *TWIS_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIS_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIS_RXD.MAXCNT: Maximum number of bytes in RXD buffer
func (o *TWIS_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *TWIS_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// TWIS_RXD.AMOUNT: Number of bytes transferred in the last RXD transaction
func (o *TWIS_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *TWIS_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

type TWIS_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
}

// TWIS_TXD.PTR: TXD Data pointer
func (o *TWIS_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIS_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIS_TXD.MAXCNT: Maximum number of bytes in TXD buffer
func (o *TWIS_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xff)|value)
}
func (o *TWIS_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xff
}

// TWIS_TXD.AMOUNT: Number of bytes transferred in the last TXD transaction
func (o *TWIS_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff)|value)
}
func (o *TWIS_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff
}

// Serial Peripheral Interface 0
type SPI_Type struct {
	_            [264]byte
	EVENTS_READY volatile.Register32 // 0x108
	_            [504]byte
	INTENSET     volatile.Register32 // 0x304
	INTENCLR     volatile.Register32 // 0x308
	_            [500]byte
	ENABLE       volatile.Register32 // 0x500
	_            [4]byte
	PSEL         SPI_PSEL_Type // 0x508
	_            [4]byte
	RXD          volatile.Register32 // 0x518
	TXD          volatile.Register32 // 0x51C
	_            [4]byte
	FREQUENCY    volatile.Register32 // 0x524
	_            [44]byte
	CONFIG       volatile.Register32 // 0x554
}

// SPI.INTENSET: Enable interrupt
func (o *SPI_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetINTENSET_READY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// SPI.INTENCLR: Disable interrupt
func (o *SPI_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetINTENCLR_READY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// SPI.ENABLE: Enable SPI
func (o *SPI_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPI.RXD: RXD register
func (o *SPI_Type) SetRXD(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetRXD() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0xff
}

// SPI.TXD: TXD register
func (o *SPI_Type) SetTXD(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetTXD() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0xff
}

// SPI.FREQUENCY: SPI frequency
func (o *SPI_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *SPI_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// SPI.CONFIG: Configuration register
func (o *SPI_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPI_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

type SPI_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MOSI volatile.Register32 // 0x50C
	MISO volatile.Register32 // 0x510
}

// SPI_PSEL.SCK: Pin select for SCK
func (o *SPI_PSEL_Type) SetSCK(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, value)
}
func (o *SPI_PSEL_Type) GetSCK() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg)
}

// SPI_PSEL.MOSI: Pin select for MOSI
func (o *SPI_PSEL_Type) SetMOSI(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, value)
}
func (o *SPI_PSEL_Type) GetMOSI() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg)
}

// SPI_PSEL.MISO: Pin select for MISO
func (o *SPI_PSEL_Type) SetMISO(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, value)
}
func (o *SPI_PSEL_Type) GetMISO() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg)
}

// I2C compatible Two-Wire Interface 0
type TWI_Type struct {
	TASKS_STARTRX    volatile.Register32 // 0x0
	_                [4]byte
	TASKS_STARTTX    volatile.Register32 // 0x8
	_                [8]byte
	TASKS_STOP       volatile.Register32 // 0x14
	_                [4]byte
	TASKS_SUSPEND    volatile.Register32 // 0x1C
	TASKS_RESUME     volatile.Register32 // 0x20
	_                [224]byte
	EVENTS_STOPPED   volatile.Register32 // 0x104
	EVENTS_RXDREADY  volatile.Register32 // 0x108
	_                [16]byte
	EVENTS_TXDSENT   volatile.Register32 // 0x11C
	_                [4]byte
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [16]byte
	EVENTS_BB        volatile.Register32 // 0x138
	_                [12]byte
	EVENTS_SUSPENDED volatile.Register32 // 0x148
	_                [180]byte
	SHORTS           volatile.Register32 // 0x200
	_                [256]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [440]byte
	ERRORSRC         volatile.Register32 // 0x4C4
	_                [56]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSELSCL          volatile.Register32 // 0x508
	PSELSDA          volatile.Register32 // 0x50C
	_                [8]byte
	RXD              volatile.Register32 // 0x518
	TXD              volatile.Register32 // 0x51C
	_                [4]byte
	FREQUENCY        volatile.Register32 // 0x524
	_                [96]byte
	ADDRESS          volatile.Register32 // 0x588
}

// TWI.SHORTS: Shortcut register
func (o *TWI_Type) SetSHORTS_BB_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetSHORTS_BB_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *TWI_Type) SetSHORTS_BB_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetSHORTS_BB_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}

// TWI.INTENSET: Enable interrupt
func (o *TWI_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetINTENSET_RXDREADY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetINTENSET_RXDREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetINTENSET_TXDSENT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetINTENSET_TXDSENT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *TWI_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetINTENSET_BB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *TWI_Type) GetINTENSET_BB() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *TWI_Type) SetINTENSET_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TWI_Type) GetINTENSET_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}

// TWI.INTENCLR: Disable interrupt
func (o *TWI_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetINTENCLR_RXDREADY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetINTENCLR_RXDREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetINTENCLR_TXDSENT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetINTENCLR_TXDSENT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *TWI_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetINTENCLR_BB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *TWI_Type) GetINTENCLR_BB() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *TWI_Type) SetINTENCLR_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TWI_Type) GetINTENCLR_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}

// TWI.ERRORSRC: Error source
func (o *TWI_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWI_Type) SetERRORSRC_ANACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetERRORSRC_ANACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}

// TWI.ENABLE: Enable TWI
func (o *TWI_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWI_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWI.PSELSCL: Pin select for SCL
func (o *TWI_Type) SetPSELSCL(value uint32) {
	volatile.StoreUint32(&o.PSELSCL.Reg, value)
}
func (o *TWI_Type) GetPSELSCL() uint32 {
	return volatile.LoadUint32(&o.PSELSCL.Reg)
}

// TWI.PSELSDA: Pin select for SDA
func (o *TWI_Type) SetPSELSDA(value uint32) {
	volatile.StoreUint32(&o.PSELSDA.Reg, value)
}
func (o *TWI_Type) GetPSELSDA() uint32 {
	return volatile.LoadUint32(&o.PSELSDA.Reg)
}

// TWI.RXD: RXD register
func (o *TWI_Type) SetRXD(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetRXD() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0xff
}

// TWI.TXD: TXD register
func (o *TWI_Type) SetTXD(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetTXD() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0xff
}

// TWI.FREQUENCY: TWI frequency
func (o *TWI_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *TWI_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// TWI.ADDRESS: Address used in the TWI transfer
func (o *TWI_Type) SetADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDRESS.Reg, volatile.LoadUint32(&o.ADDRESS.Reg)&^(0x7f)|value)
}
func (o *TWI_Type) GetADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDRESS.Reg) & 0x7f
}

// NFC-A compatible radio
type NFCT_Type struct {
	TASKS_ACTIVATE           volatile.Register32 // 0x0
	TASKS_DISABLE            volatile.Register32 // 0x4
	TASKS_SENSE              volatile.Register32 // 0x8
	TASKS_STARTTX            volatile.Register32 // 0xC
	_                        [12]byte
	TASKS_ENABLERXDATA       volatile.Register32 // 0x1C
	_                        [4]byte
	TASKS_GOIDLE             volatile.Register32 // 0x24
	TASKS_GOSLEEP            volatile.Register32 // 0x28
	_                        [212]byte
	EVENTS_READY             volatile.Register32 // 0x100
	EVENTS_FIELDDETECTED     volatile.Register32 // 0x104
	EVENTS_FIELDLOST         volatile.Register32 // 0x108
	EVENTS_TXFRAMESTART      volatile.Register32 // 0x10C
	EVENTS_TXFRAMEEND        volatile.Register32 // 0x110
	EVENTS_RXFRAMESTART      volatile.Register32 // 0x114
	EVENTS_RXFRAMEEND        volatile.Register32 // 0x118
	EVENTS_ERROR             volatile.Register32 // 0x11C
	_                        [8]byte
	EVENTS_RXERROR           volatile.Register32 // 0x128
	EVENTS_ENDRX             volatile.Register32 // 0x12C
	EVENTS_ENDTX             volatile.Register32 // 0x130
	_                        [4]byte
	EVENTS_AUTOCOLRESSTARTED volatile.Register32 // 0x138
	_                        [12]byte
	EVENTS_COLLISION         volatile.Register32 // 0x148
	EVENTS_SELECTED          volatile.Register32 // 0x14C
	EVENTS_STARTED           volatile.Register32 // 0x150
	_                        [172]byte
	SHORTS                   volatile.Register32 // 0x200
	_                        [252]byte
	INTEN                    volatile.Register32 // 0x300
	INTENSET                 volatile.Register32 // 0x304
	INTENCLR                 volatile.Register32 // 0x308
	_                        [248]byte
	ERRORSTATUS              volatile.Register32 // 0x404
	_                        [4]byte
	FRAMESTATUS              NFCT_FRAMESTATUS_Type // 0x40C
	_                        [32]byte
	CURRENTLOADCTRL          volatile.Register32 // 0x430
	_                        [8]byte
	FIELDPRESENT             volatile.Register32 // 0x43C
	_                        [196]byte
	FRAMEDELAYMIN            volatile.Register32 // 0x504
	FRAMEDELAYMAX            volatile.Register32 // 0x508
	FRAMEDELAYMODE           volatile.Register32 // 0x50C
	PACKETPTR                volatile.Register32 // 0x510
	MAXLEN                   volatile.Register32 // 0x514
	TXD                      NFCT_TXD_Type       // 0x518
	RXD                      NFCT_RXD_Type       // 0x520
	_                        [104]byte
	NFCID1_LAST              volatile.Register32 // 0x590
	NFCID1_2ND_LAST          volatile.Register32 // 0x594
	NFCID1_3RD_LAST          volatile.Register32 // 0x598
	_                        [4]byte
	SENSRES                  volatile.Register32 // 0x5A0
	SELRES                   volatile.Register32 // 0x5A4
}

// NFCT.SHORTS: Shortcut register
func (o *NFCT_Type) SetSHORTS_FIELDDETECTED_ACTIVATE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetSHORTS_FIELDDETECTED_ACTIVATE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *NFCT_Type) SetSHORTS_FIELDLOST_SENSE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetSHORTS_FIELDLOST_SENSE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}

// NFCT.INTEN: Enable or disable interrupt
func (o *NFCT_Type) SetINTEN_READY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetINTEN_READY() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *NFCT_Type) SetINTEN_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetINTEN_FIELDDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetINTEN_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetINTEN_FIELDLOST() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetINTEN_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetINTEN_TXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *NFCT_Type) SetINTEN_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_Type) GetINTEN_TXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *NFCT_Type) SetINTEN_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetINTEN_RXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetINTEN_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *NFCT_Type) GetINTEN_RXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *NFCT_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *NFCT_Type) SetINTEN_RXERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *NFCT_Type) GetINTEN_RXERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *NFCT_Type) SetINTEN_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *NFCT_Type) GetINTEN_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *NFCT_Type) SetINTEN_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *NFCT_Type) GetINTEN_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *NFCT_Type) SetINTEN_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *NFCT_Type) GetINTEN_AUTOCOLRESSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *NFCT_Type) SetINTEN_COLLISION(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *NFCT_Type) GetINTEN_COLLISION() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *NFCT_Type) SetINTEN_SELECTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *NFCT_Type) GetINTEN_SELECTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *NFCT_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *NFCT_Type) GetINTEN_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}

// NFCT.INTENSET: Enable interrupt
func (o *NFCT_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *NFCT_Type) SetINTENSET_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetINTENSET_FIELDDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetINTENSET_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetINTENSET_FIELDLOST() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetINTENSET_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetINTENSET_TXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *NFCT_Type) SetINTENSET_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_Type) GetINTENSET_TXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *NFCT_Type) SetINTENSET_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetINTENSET_RXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetINTENSET_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *NFCT_Type) GetINTENSET_RXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *NFCT_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *NFCT_Type) SetINTENSET_RXERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *NFCT_Type) GetINTENSET_RXERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *NFCT_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *NFCT_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *NFCT_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *NFCT_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *NFCT_Type) SetINTENSET_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *NFCT_Type) GetINTENSET_AUTOCOLRESSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *NFCT_Type) SetINTENSET_COLLISION(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *NFCT_Type) GetINTENSET_COLLISION() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *NFCT_Type) SetINTENSET_SELECTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *NFCT_Type) GetINTENSET_SELECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *NFCT_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *NFCT_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}

// NFCT.INTENCLR: Disable interrupt
func (o *NFCT_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *NFCT_Type) SetINTENCLR_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetINTENCLR_FIELDDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetINTENCLR_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetINTENCLR_FIELDLOST() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetINTENCLR_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetINTENCLR_TXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *NFCT_Type) SetINTENCLR_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_Type) GetINTENCLR_TXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *NFCT_Type) SetINTENCLR_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetINTENCLR_RXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetINTENCLR_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *NFCT_Type) GetINTENCLR_RXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *NFCT_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *NFCT_Type) SetINTENCLR_RXERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *NFCT_Type) GetINTENCLR_RXERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *NFCT_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *NFCT_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *NFCT_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *NFCT_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *NFCT_Type) SetINTENCLR_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *NFCT_Type) GetINTENCLR_AUTOCOLRESSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *NFCT_Type) SetINTENCLR_COLLISION(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *NFCT_Type) GetINTENCLR_COLLISION() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *NFCT_Type) SetINTENCLR_SELECTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *NFCT_Type) GetINTENCLR_SELECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *NFCT_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *NFCT_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}

// NFCT.ERRORSTATUS: NFC Error Status register
func (o *NFCT_Type) SetERRORSTATUS_FRAMEDELAYTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ERRORSTATUS.Reg, volatile.LoadUint32(&o.ERRORSTATUS.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetERRORSTATUS_FRAMEDELAYTIMEOUT() uint32 {
	return volatile.LoadUint32(&o.ERRORSTATUS.Reg) & 0x1
}
func (o *NFCT_Type) SetERRORSTATUS_NFCFIELDTOOSTRONG(value uint32) {
	volatile.StoreUint32(&o.ERRORSTATUS.Reg, volatile.LoadUint32(&o.ERRORSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetERRORSTATUS_NFCFIELDTOOSTRONG() uint32 {
	return (volatile.LoadUint32(&o.ERRORSTATUS.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetERRORSTATUS_NFCFIELDTOOWEAK(value uint32) {
	volatile.StoreUint32(&o.ERRORSTATUS.Reg, volatile.LoadUint32(&o.ERRORSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetERRORSTATUS_NFCFIELDTOOWEAK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSTATUS.Reg) & 0x8) >> 3
}

// NFCT.CURRENTLOADCTRL: Current value driven to the NFC Load Control
func (o *NFCT_Type) SetCURRENTLOADCTRL(value uint32) {
	volatile.StoreUint32(&o.CURRENTLOADCTRL.Reg, volatile.LoadUint32(&o.CURRENTLOADCTRL.Reg)&^(0x3f)|value)
}
func (o *NFCT_Type) GetCURRENTLOADCTRL() uint32 {
	return volatile.LoadUint32(&o.CURRENTLOADCTRL.Reg) & 0x3f
}

// NFCT.FIELDPRESENT: Indicates the presence or not of a valid field
func (o *NFCT_Type) SetFIELDPRESENT(value uint32) {
	volatile.StoreUint32(&o.FIELDPRESENT.Reg, volatile.LoadUint32(&o.FIELDPRESENT.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetFIELDPRESENT() uint32 {
	return volatile.LoadUint32(&o.FIELDPRESENT.Reg) & 0x1
}
func (o *NFCT_Type) SetFIELDPRESENT_LOCKDETECT(value uint32) {
	volatile.StoreUint32(&o.FIELDPRESENT.Reg, volatile.LoadUint32(&o.FIELDPRESENT.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetFIELDPRESENT_LOCKDETECT() uint32 {
	return (volatile.LoadUint32(&o.FIELDPRESENT.Reg) & 0x2) >> 1
}

// NFCT.FRAMEDELAYMIN: Minimum frame delay
func (o *NFCT_Type) SetFRAMEDELAYMIN(value uint32) {
	volatile.StoreUint32(&o.FRAMEDELAYMIN.Reg, volatile.LoadUint32(&o.FRAMEDELAYMIN.Reg)&^(0xffff)|value)
}
func (o *NFCT_Type) GetFRAMEDELAYMIN() uint32 {
	return volatile.LoadUint32(&o.FRAMEDELAYMIN.Reg) & 0xffff
}

// NFCT.FRAMEDELAYMAX: Maximum frame delay
func (o *NFCT_Type) SetFRAMEDELAYMAX(value uint32) {
	volatile.StoreUint32(&o.FRAMEDELAYMAX.Reg, volatile.LoadUint32(&o.FRAMEDELAYMAX.Reg)&^(0xffff)|value)
}
func (o *NFCT_Type) GetFRAMEDELAYMAX() uint32 {
	return volatile.LoadUint32(&o.FRAMEDELAYMAX.Reg) & 0xffff
}

// NFCT.FRAMEDELAYMODE: Configuration register for the Frame Delay Timer
func (o *NFCT_Type) SetFRAMEDELAYMODE(value uint32) {
	volatile.StoreUint32(&o.FRAMEDELAYMODE.Reg, volatile.LoadUint32(&o.FRAMEDELAYMODE.Reg)&^(0x3)|value)
}
func (o *NFCT_Type) GetFRAMEDELAYMODE() uint32 {
	return volatile.LoadUint32(&o.FRAMEDELAYMODE.Reg) & 0x3
}

// NFCT.PACKETPTR: Packet pointer for TXD and RXD data storage in Data RAM
func (o *NFCT_Type) SetPACKETPTR(value uint32) {
	volatile.StoreUint32(&o.PACKETPTR.Reg, value)
}
func (o *NFCT_Type) GetPACKETPTR() uint32 {
	return volatile.LoadUint32(&o.PACKETPTR.Reg)
}

// NFCT.MAXLEN: Size of allocated for TXD and RXD data storage buffer in Data RAM
func (o *NFCT_Type) SetMAXLEN(value uint32) {
	volatile.StoreUint32(&o.MAXLEN.Reg, volatile.LoadUint32(&o.MAXLEN.Reg)&^(0x1ff)|value)
}
func (o *NFCT_Type) GetMAXLEN() uint32 {
	return volatile.LoadUint32(&o.MAXLEN.Reg) & 0x1ff
}

// NFCT.NFCID1_LAST: Last NFCID1 part (4, 7 or 10 bytes ID)
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_Z(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_Z() uint32 {
	return volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff
}
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_Y(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff00)|value<<8)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_Y() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff00) >> 8
}
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_X(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff0000)|value<<16)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_X() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff0000) >> 16
}
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_W(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff000000)|value<<24)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_W() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff000000) >> 24
}

// NFCT.NFCID1_2ND_LAST: Second last NFCID1 part (7 or 10 bytes ID)
func (o *NFCT_Type) SetNFCID1_2ND_LAST_NFCID1_V(value uint32) {
	volatile.StoreUint32(&o.NFCID1_2ND_LAST.Reg, volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetNFCID1_2ND_LAST_NFCID1_V() uint32 {
	return volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg) & 0xff
}
func (o *NFCT_Type) SetNFCID1_2ND_LAST_NFCID1_U(value uint32) {
	volatile.StoreUint32(&o.NFCID1_2ND_LAST.Reg, volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg)&^(0xff00)|value<<8)
}
func (o *NFCT_Type) GetNFCID1_2ND_LAST_NFCID1_U() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg) & 0xff00) >> 8
}
func (o *NFCT_Type) SetNFCID1_2ND_LAST_NFCID1_T(value uint32) {
	volatile.StoreUint32(&o.NFCID1_2ND_LAST.Reg, volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg)&^(0xff0000)|value<<16)
}
func (o *NFCT_Type) GetNFCID1_2ND_LAST_NFCID1_T() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg) & 0xff0000) >> 16
}

// NFCT.NFCID1_3RD_LAST: Third last NFCID1 part (10 bytes ID)
func (o *NFCT_Type) SetNFCID1_3RD_LAST_NFCID1_S(value uint32) {
	volatile.StoreUint32(&o.NFCID1_3RD_LAST.Reg, volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetNFCID1_3RD_LAST_NFCID1_S() uint32 {
	return volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg) & 0xff
}
func (o *NFCT_Type) SetNFCID1_3RD_LAST_NFCID1_R(value uint32) {
	volatile.StoreUint32(&o.NFCID1_3RD_LAST.Reg, volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg)&^(0xff00)|value<<8)
}
func (o *NFCT_Type) GetNFCID1_3RD_LAST_NFCID1_R() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg) & 0xff00) >> 8
}
func (o *NFCT_Type) SetNFCID1_3RD_LAST_NFCID1_Q(value uint32) {
	volatile.StoreUint32(&o.NFCID1_3RD_LAST.Reg, volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg)&^(0xff0000)|value<<16)
}
func (o *NFCT_Type) GetNFCID1_3RD_LAST_NFCID1_Q() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg) & 0xff0000) >> 16
}

// NFCT.SENSRES: NFC-A SENS_RES auto-response settings
func (o *NFCT_Type) SetSENSRES_BITFRAMESDD(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0x1f)|value)
}
func (o *NFCT_Type) GetSENSRES_BITFRAMESDD() uint32 {
	return volatile.LoadUint32(&o.SENSRES.Reg) & 0x1f
}
func (o *NFCT_Type) SetSENSRES_RFU5(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetSENSRES_RFU5() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetSENSRES_NFCIDSIZE(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0xc0)|value<<6)
}
func (o *NFCT_Type) GetSENSRES_NFCIDSIZE() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0xc0) >> 6
}
func (o *NFCT_Type) SetSENSRES_PLATFCONFIG(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0xf00)|value<<8)
}
func (o *NFCT_Type) GetSENSRES_PLATFCONFIG() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0xf00) >> 8
}
func (o *NFCT_Type) SetSENSRES_RFU74(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0xf000)|value<<12)
}
func (o *NFCT_Type) GetSENSRES_RFU74() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0xf000) >> 12
}

// NFCT.SELRES: NFC-A SEL_RES auto-response settings
func (o *NFCT_Type) SetSELRES_RFU10(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x3)|value)
}
func (o *NFCT_Type) GetSELRES_RFU10() uint32 {
	return volatile.LoadUint32(&o.SELRES.Reg) & 0x3
}
func (o *NFCT_Type) SetSELRES_CASCADE(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetSELRES_CASCADE() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetSELRES_RFU43(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x18)|value<<3)
}
func (o *NFCT_Type) GetSELRES_RFU43() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x18) >> 3
}
func (o *NFCT_Type) SetSELRES_PROTOCOL(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x60)|value<<5)
}
func (o *NFCT_Type) GetSELRES_PROTOCOL() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x60) >> 5
}
func (o *NFCT_Type) SetSELRES_RFU7(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetSELRES_RFU7() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x80) >> 7
}

type NFCT_FRAMESTATUS_Type struct {
	RX volatile.Register32 // 0x40C
}

// NFCT_FRAMESTATUS.RX: Result of last incoming frames
func (o *NFCT_FRAMESTATUS_Type) SetRX_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x1)|value)
}
func (o *NFCT_FRAMESTATUS_Type) GetRX_CRCERROR() uint32 {
	return volatile.LoadUint32(&o.RX.Reg) & 0x1
}
func (o *NFCT_FRAMESTATUS_Type) SetRX_PARITYSTATUS(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_FRAMESTATUS_Type) GetRX_PARITYSTATUS() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x4) >> 2
}
func (o *NFCT_FRAMESTATUS_Type) SetRX_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_FRAMESTATUS_Type) GetRX_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x8) >> 3
}

type NFCT_TXD_Type struct {
	FRAMECONFIG volatile.Register32 // 0x518
	AMOUNT      volatile.Register32 // 0x51C
}

// NFCT_TXD.FRAMECONFIG: Configuration of outgoing frames
func (o *NFCT_TXD_Type) SetFRAMECONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x1)|value)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_PARITY() uint32 {
	return volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x1
}
func (o *NFCT_TXD_Type) SetFRAMECONFIG_DISCARDMODE(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_DISCARDMODE() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x2) >> 1
}
func (o *NFCT_TXD_Type) SetFRAMECONFIG_SOF(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_SOF() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x4) >> 2
}
func (o *NFCT_TXD_Type) SetFRAMECONFIG_CRCMODETX(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_CRCMODETX() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x10) >> 4
}

// NFCT_TXD.AMOUNT: Size of outgoing frame
func (o *NFCT_TXD_Type) SetAMOUNT_TXDATABITS(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7)|value)
}
func (o *NFCT_TXD_Type) GetAMOUNT_TXDATABITS() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7
}
func (o *NFCT_TXD_Type) SetAMOUNT_TXDATABYTES(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff8)|value<<3)
}
func (o *NFCT_TXD_Type) GetAMOUNT_TXDATABYTES() uint32 {
	return (volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff8) >> 3
}

type NFCT_RXD_Type struct {
	FRAMECONFIG volatile.Register32 // 0x520
	AMOUNT      volatile.Register32 // 0x524
}

// NFCT_RXD.FRAMECONFIG: Configuration of incoming frames
func (o *NFCT_RXD_Type) SetFRAMECONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x1)|value)
}
func (o *NFCT_RXD_Type) GetFRAMECONFIG_PARITY() uint32 {
	return volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x1
}
func (o *NFCT_RXD_Type) SetFRAMECONFIG_SOF(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_RXD_Type) GetFRAMECONFIG_SOF() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x4) >> 2
}
func (o *NFCT_RXD_Type) SetFRAMECONFIG_CRCMODERX(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_RXD_Type) GetFRAMECONFIG_CRCMODERX() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x10) >> 4
}

// NFCT_RXD.AMOUNT: Size of last incoming frame
func (o *NFCT_RXD_Type) SetAMOUNT_RXDATABITS(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7)|value)
}
func (o *NFCT_RXD_Type) GetAMOUNT_RXDATABITS() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7
}
func (o *NFCT_RXD_Type) SetAMOUNT_RXDATABYTES(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff8)|value<<3)
}
func (o *NFCT_RXD_Type) GetAMOUNT_RXDATABYTES() uint32 {
	return (volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff8) >> 3
}

// GPIO Tasks and Events
type GPIOTE_Type struct {
	TASKS_OUT   [8]volatile.Register32 // 0x0
	_           [16]byte
	TASKS_SET   [8]volatile.Register32 // 0x30
	_           [16]byte
	TASKS_CLR   [8]volatile.Register32 // 0x60
	_           [128]byte
	EVENTS_IN   [8]volatile.Register32 // 0x100
	_           [92]byte
	EVENTS_PORT volatile.Register32 // 0x17C
	_           [388]byte
	INTENSET    volatile.Register32 // 0x304
	INTENCLR    volatile.Register32 // 0x308
	_           [516]byte
	CONFIG      [8]volatile.Register32 // 0x510
}

// GPIOTE.INTENSET: Enable interrupt
func (o *GPIOTE_Type) SetINTENSET_IN0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetINTENSET_IN0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *GPIOTE_Type) SetINTENSET_IN1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIOTE_Type) GetINTENSET_IN1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *GPIOTE_Type) SetINTENSET_IN2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIOTE_Type) GetINTENSET_IN2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *GPIOTE_Type) SetINTENSET_IN3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIOTE_Type) GetINTENSET_IN3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *GPIOTE_Type) SetINTENSET_IN4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIOTE_Type) GetINTENSET_IN4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *GPIOTE_Type) SetINTENSET_IN5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIOTE_Type) GetINTENSET_IN5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *GPIOTE_Type) SetINTENSET_IN6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIOTE_Type) GetINTENSET_IN6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *GPIOTE_Type) SetINTENSET_IN7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIOTE_Type) GetINTENSET_IN7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *GPIOTE_Type) SetINTENSET_PORT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetINTENSET_PORT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000000) >> 31
}

// GPIOTE.INTENCLR: Disable interrupt
func (o *GPIOTE_Type) SetINTENCLR_IN0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetINTENCLR_IN0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *GPIOTE_Type) SetINTENCLR_IN1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIOTE_Type) GetINTENCLR_IN1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *GPIOTE_Type) SetINTENCLR_IN2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIOTE_Type) GetINTENCLR_IN2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *GPIOTE_Type) SetINTENCLR_IN3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIOTE_Type) GetINTENCLR_IN3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *GPIOTE_Type) SetINTENCLR_IN4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIOTE_Type) GetINTENCLR_IN4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *GPIOTE_Type) SetINTENCLR_IN5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIOTE_Type) GetINTENCLR_IN5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *GPIOTE_Type) SetINTENCLR_IN6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIOTE_Type) GetINTENCLR_IN6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *GPIOTE_Type) SetINTENCLR_IN7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIOTE_Type) GetINTENCLR_IN7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *GPIOTE_Type) SetINTENCLR_PORT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetINTENCLR_PORT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000000) >> 31
}

// GPIOTE.CONFIG: Description collection[0]: Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event
func (o *GPIOTE_Type) SetCONFIG_MODE(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x3)|value)
}
func (o *GPIOTE_Type) GetCONFIG_MODE(idx int) uint32 {
	return volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x3
}
func (o *GPIOTE_Type) SetCONFIG_PSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x1f00)|value<<8)
}
func (o *GPIOTE_Type) GetCONFIG_PSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x1f00) >> 8
}
func (o *GPIOTE_Type) SetCONFIG_POLARITY(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *GPIOTE_Type) GetCONFIG_POLARITY(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x30000) >> 16
}
func (o *GPIOTE_Type) SetCONFIG_OUTINIT(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x100000)|value<<20)
}
func (o *GPIOTE_Type) GetCONFIG_OUTINIT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x100000) >> 20
}

// Analog to Digital Converter
type SAADC_Type struct {
	TASKS_START           volatile.Register32 // 0x0
	TASKS_SAMPLE          volatile.Register32 // 0x4
	TASKS_STOP            volatile.Register32 // 0x8
	TASKS_CALIBRATEOFFSET volatile.Register32 // 0xC
	_                     [240]byte
	EVENTS_STARTED        volatile.Register32     // 0x100
	EVENTS_END            volatile.Register32     // 0x104
	EVENTS_DONE           volatile.Register32     // 0x108
	EVENTS_RESULTDONE     volatile.Register32     // 0x10C
	EVENTS_CALIBRATEDONE  volatile.Register32     // 0x110
	EVENTS_STOPPED        volatile.Register32     // 0x114
	EVENTS_CH             [8]SAADC_EVENTS_CH_Type // 0x118
	_                     [424]byte
	INTEN                 volatile.Register32 // 0x300
	INTENSET              volatile.Register32 // 0x304
	INTENCLR              volatile.Register32 // 0x308
	_                     [244]byte
	STATUS                volatile.Register32 // 0x400
	_                     [252]byte
	ENABLE                volatile.Register32 // 0x500
	_                     [12]byte
	CH                    [8]SAADC_CH_Type // 0x510
	_                     [96]byte
	RESOLUTION            volatile.Register32 // 0x5F0
	OVERSAMPLE            volatile.Register32 // 0x5F4
	SAMPLERATE            volatile.Register32 // 0x5F8
	_                     [48]byte
	RESULT                SAADC_RESULT_Type // 0x62C
}

// SAADC.INTEN: Enable or disable interrupt
func (o *SAADC_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetINTEN_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *SAADC_Type) SetINTEN_END(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *SAADC_Type) GetINTEN_END() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *SAADC_Type) SetINTEN_DONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *SAADC_Type) GetINTEN_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *SAADC_Type) SetINTEN_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *SAADC_Type) GetINTEN_RESULTDONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *SAADC_Type) SetINTEN_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *SAADC_Type) GetINTEN_CALIBRATEDONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *SAADC_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *SAADC_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *SAADC_Type) SetINTEN_CH0LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *SAADC_Type) GetINTEN_CH0LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *SAADC_Type) SetINTEN_CH0LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *SAADC_Type) GetINTEN_CH0LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *SAADC_Type) SetINTEN_CH1LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *SAADC_Type) GetINTEN_CH1LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *SAADC_Type) SetINTEN_CH1LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *SAADC_Type) GetINTEN_CH1LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *SAADC_Type) SetINTEN_CH2LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *SAADC_Type) GetINTEN_CH2LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *SAADC_Type) SetINTEN_CH2LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *SAADC_Type) GetINTEN_CH2LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *SAADC_Type) SetINTEN_CH3LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetINTEN_CH3LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *SAADC_Type) SetINTEN_CH3LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *SAADC_Type) GetINTEN_CH3LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *SAADC_Type) SetINTEN_CH4LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *SAADC_Type) GetINTEN_CH4LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *SAADC_Type) SetINTEN_CH4LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *SAADC_Type) GetINTEN_CH4LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}
func (o *SAADC_Type) SetINTEN_CH5LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000)|value<<16)
}
func (o *SAADC_Type) GetINTEN_CH5LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000) >> 16
}
func (o *SAADC_Type) SetINTEN_CH5LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *SAADC_Type) GetINTEN_CH5LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *SAADC_Type) SetINTEN_CH6LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *SAADC_Type) GetINTEN_CH6LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *SAADC_Type) SetINTEN_CH6LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *SAADC_Type) GetINTEN_CH6LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *SAADC_Type) SetINTEN_CH7LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_Type) GetINTEN_CH7LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *SAADC_Type) SetINTEN_CH7LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200000)|value<<21)
}
func (o *SAADC_Type) GetINTEN_CH7LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200000) >> 21
}

// SAADC.INTENSET: Enable interrupt
func (o *SAADC_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetINTENSET_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *SAADC_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SAADC_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SAADC_Type) SetINTENSET_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SAADC_Type) GetINTENSET_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SAADC_Type) SetINTENSET_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SAADC_Type) GetINTENSET_RESULTDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *SAADC_Type) SetINTENSET_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SAADC_Type) GetINTENSET_CALIBRATEDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SAADC_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *SAADC_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *SAADC_Type) SetINTENSET_CH0LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *SAADC_Type) GetINTENSET_CH0LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *SAADC_Type) SetINTENSET_CH0LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SAADC_Type) GetINTENSET_CH0LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *SAADC_Type) SetINTENSET_CH1LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SAADC_Type) GetINTENSET_CH1LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *SAADC_Type) SetINTENSET_CH1LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *SAADC_Type) GetINTENSET_CH1LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *SAADC_Type) SetINTENSET_CH2LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *SAADC_Type) GetINTENSET_CH2LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *SAADC_Type) SetINTENSET_CH2LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *SAADC_Type) GetINTENSET_CH2LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *SAADC_Type) SetINTENSET_CH3LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetINTENSET_CH3LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *SAADC_Type) SetINTENSET_CH3LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *SAADC_Type) GetINTENSET_CH3LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *SAADC_Type) SetINTENSET_CH4LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *SAADC_Type) GetINTENSET_CH4LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *SAADC_Type) SetINTENSET_CH4LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *SAADC_Type) GetINTENSET_CH4LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *SAADC_Type) SetINTENSET_CH5LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *SAADC_Type) GetINTENSET_CH5LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *SAADC_Type) SetINTENSET_CH5LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *SAADC_Type) GetINTENSET_CH5LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *SAADC_Type) SetINTENSET_CH6LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *SAADC_Type) GetINTENSET_CH6LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *SAADC_Type) SetINTENSET_CH6LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *SAADC_Type) GetINTENSET_CH6LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *SAADC_Type) SetINTENSET_CH7LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_Type) GetINTENSET_CH7LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *SAADC_Type) SetINTENSET_CH7LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *SAADC_Type) GetINTENSET_CH7LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}

// SAADC.INTENCLR: Disable interrupt
func (o *SAADC_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetINTENCLR_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *SAADC_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SAADC_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SAADC_Type) SetINTENCLR_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SAADC_Type) GetINTENCLR_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SAADC_Type) SetINTENCLR_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SAADC_Type) GetINTENCLR_RESULTDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *SAADC_Type) SetINTENCLR_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SAADC_Type) GetINTENCLR_CALIBRATEDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SAADC_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *SAADC_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *SAADC_Type) SetINTENCLR_CH0LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *SAADC_Type) GetINTENCLR_CH0LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *SAADC_Type) SetINTENCLR_CH0LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SAADC_Type) GetINTENCLR_CH0LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *SAADC_Type) SetINTENCLR_CH1LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SAADC_Type) GetINTENCLR_CH1LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *SAADC_Type) SetINTENCLR_CH1LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *SAADC_Type) GetINTENCLR_CH1LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *SAADC_Type) SetINTENCLR_CH2LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *SAADC_Type) GetINTENCLR_CH2LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *SAADC_Type) SetINTENCLR_CH2LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *SAADC_Type) GetINTENCLR_CH2LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *SAADC_Type) SetINTENCLR_CH3LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetINTENCLR_CH3LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *SAADC_Type) SetINTENCLR_CH3LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *SAADC_Type) GetINTENCLR_CH3LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *SAADC_Type) SetINTENCLR_CH4LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *SAADC_Type) GetINTENCLR_CH4LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *SAADC_Type) SetINTENCLR_CH4LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *SAADC_Type) GetINTENCLR_CH4LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *SAADC_Type) SetINTENCLR_CH5LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *SAADC_Type) GetINTENCLR_CH5LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *SAADC_Type) SetINTENCLR_CH5LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *SAADC_Type) GetINTENCLR_CH5LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *SAADC_Type) SetINTENCLR_CH6LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *SAADC_Type) GetINTENCLR_CH6LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *SAADC_Type) SetINTENCLR_CH6LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *SAADC_Type) GetINTENCLR_CH6LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *SAADC_Type) SetINTENCLR_CH7LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_Type) GetINTENCLR_CH7LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *SAADC_Type) SetINTENCLR_CH7LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *SAADC_Type) GetINTENCLR_CH7LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}

// SAADC.STATUS: Status
func (o *SAADC_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}

// SAADC.ENABLE: Enable or disable ADC
func (o *SAADC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// SAADC.RESOLUTION: Resolution configuration
func (o *SAADC_Type) SetRESOLUTION_VAL(value uint32) {
	volatile.StoreUint32(&o.RESOLUTION.Reg, volatile.LoadUint32(&o.RESOLUTION.Reg)&^(0x7)|value)
}
func (o *SAADC_Type) GetRESOLUTION_VAL() uint32 {
	return volatile.LoadUint32(&o.RESOLUTION.Reg) & 0x7
}

// SAADC.OVERSAMPLE: Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
func (o *SAADC_Type) SetOVERSAMPLE(value uint32) {
	volatile.StoreUint32(&o.OVERSAMPLE.Reg, volatile.LoadUint32(&o.OVERSAMPLE.Reg)&^(0xf)|value)
}
func (o *SAADC_Type) GetOVERSAMPLE() uint32 {
	return volatile.LoadUint32(&o.OVERSAMPLE.Reg) & 0xf
}

// SAADC.SAMPLERATE: Controls normal or continuous sample rate
func (o *SAADC_Type) SetSAMPLERATE_CC(value uint32) {
	volatile.StoreUint32(&o.SAMPLERATE.Reg, volatile.LoadUint32(&o.SAMPLERATE.Reg)&^(0x7ff)|value)
}
func (o *SAADC_Type) GetSAMPLERATE_CC() uint32 {
	return volatile.LoadUint32(&o.SAMPLERATE.Reg) & 0x7ff
}
func (o *SAADC_Type) SetSAMPLERATE_MODE(value uint32) {
	volatile.StoreUint32(&o.SAMPLERATE.Reg, volatile.LoadUint32(&o.SAMPLERATE.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetSAMPLERATE_MODE() uint32 {
	return (volatile.LoadUint32(&o.SAMPLERATE.Reg) & 0x1000) >> 12
}

type SAADC_EVENTS_CH_Type struct {
	LIMITH volatile.Register32 // 0x118
	LIMITL volatile.Register32 // 0x11C
}

type SAADC_CH_Type struct {
	PSELP  volatile.Register32 // 0x510
	PSELN  volatile.Register32 // 0x514
	CONFIG volatile.Register32 // 0x518
	LIMIT  volatile.Register32 // 0x51C
}

// SAADC_CH.PSELP: Description cluster[0]: Input positive pin selection for CH[0]
func (o *SAADC_CH_Type) SetPSELP(value uint32) {
	volatile.StoreUint32(&o.PSELP.Reg, volatile.LoadUint32(&o.PSELP.Reg)&^(0x1f)|value)
}
func (o *SAADC_CH_Type) GetPSELP() uint32 {
	return volatile.LoadUint32(&o.PSELP.Reg) & 0x1f
}

// SAADC_CH.PSELN: Description cluster[0]: Input negative pin selection for CH[0]
func (o *SAADC_CH_Type) SetPSELN(value uint32) {
	volatile.StoreUint32(&o.PSELN.Reg, volatile.LoadUint32(&o.PSELN.Reg)&^(0x1f)|value)
}
func (o *SAADC_CH_Type) GetPSELN() uint32 {
	return volatile.LoadUint32(&o.PSELN.Reg) & 0x1f
}

// SAADC_CH.CONFIG: Description cluster[0]: Input configuration for CH[0]
func (o *SAADC_CH_Type) SetCONFIG_RESP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x3)|value)
}
func (o *SAADC_CH_Type) GetCONFIG_RESP() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x3
}
func (o *SAADC_CH_Type) SetCONFIG_RESN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x30)|value<<4)
}
func (o *SAADC_CH_Type) GetCONFIG_RESN() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x30) >> 4
}
func (o *SAADC_CH_Type) SetCONFIG_GAIN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x700)|value<<8)
}
func (o *SAADC_CH_Type) GetCONFIG_GAIN() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x700) >> 8
}
func (o *SAADC_CH_Type) SetCONFIG_REFSEL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_CH_Type) GetCONFIG_REFSEL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x1000) >> 12
}
func (o *SAADC_CH_Type) SetCONFIG_TACQ(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x70000)|value<<16)
}
func (o *SAADC_CH_Type) GetCONFIG_TACQ() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x70000) >> 16
}
func (o *SAADC_CH_Type) SetCONFIG_MODE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_CH_Type) GetCONFIG_MODE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100000) >> 20
}
func (o *SAADC_CH_Type) SetCONFIG_BURST(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1000000)|value<<24)
}
func (o *SAADC_CH_Type) GetCONFIG_BURST() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x1000000) >> 24
}

// SAADC_CH.LIMIT: Description cluster[0]: High/low limits for event monitoring a channel
func (o *SAADC_CH_Type) SetLIMIT_LOW(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff)|value)
}
func (o *SAADC_CH_Type) GetLIMIT_LOW() uint32 {
	return volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff
}
func (o *SAADC_CH_Type) SetLIMIT_HIGH(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SAADC_CH_Type) GetLIMIT_HIGH() uint32 {
	return (volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff0000) >> 16
}

type SAADC_RESULT_Type struct {
	PTR    volatile.Register32 // 0x62C
	MAXCNT volatile.Register32 // 0x630
	AMOUNT volatile.Register32 // 0x634
}

// SAADC_RESULT.PTR: Data pointer
func (o *SAADC_RESULT_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SAADC_RESULT_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SAADC_RESULT.MAXCNT: Maximum number of buffer words to transfer
func (o *SAADC_RESULT_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *SAADC_RESULT_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// SAADC_RESULT.AMOUNT: Number of buffer words transferred since last START
func (o *SAADC_RESULT_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *SAADC_RESULT_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// Timer/Counter 0
type TIMER_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	TASKS_STOP     volatile.Register32 // 0x4
	TASKS_COUNT    volatile.Register32 // 0x8
	TASKS_CLEAR    volatile.Register32 // 0xC
	TASKS_SHUTDOWN volatile.Register32 // 0x10
	_              [44]byte
	TASKS_CAPTURE  [6]volatile.Register32 // 0x40
	_              [232]byte
	EVENTS_COMPARE [6]volatile.Register32 // 0x140
	_              [168]byte
	SHORTS         volatile.Register32 // 0x200
	_              [256]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [504]byte
	MODE           volatile.Register32 // 0x504
	BITMODE        volatile.Register32 // 0x508
	_              [4]byte
	PRESCALER      volatile.Register32 // 0x510
	_              [44]byte
	CC             [6]volatile.Register32 // 0x540
}

// TIMER.SHORTS: Shortcut register
func (o *TIMER_Type) SetSHORTS_COMPARE0_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetSHORTS_COMPARE0_CLEAR() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *TIMER_Type) SetSHORTS_COMPARE1_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetSHORTS_COMPARE1_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetSHORTS_COMPARE2_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetSHORTS_COMPARE2_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetSHORTS_COMPARE3_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetSHORTS_COMPARE3_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetSHORTS_COMPARE4_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *TIMER_Type) GetSHORTS_COMPARE4_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *TIMER_Type) SetSHORTS_COMPARE5_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *TIMER_Type) GetSHORTS_COMPARE5_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *TIMER_Type) SetSHORTS_COMPARE0_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *TIMER_Type) GetSHORTS_COMPARE0_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}
func (o *TIMER_Type) SetSHORTS_COMPARE1_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200)|value<<9)
}
func (o *TIMER_Type) GetSHORTS_COMPARE1_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200) >> 9
}
func (o *TIMER_Type) SetSHORTS_COMPARE2_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x400)|value<<10)
}
func (o *TIMER_Type) GetSHORTS_COMPARE2_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x400) >> 10
}
func (o *TIMER_Type) SetSHORTS_COMPARE3_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x800)|value<<11)
}
func (o *TIMER_Type) GetSHORTS_COMPARE3_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x800) >> 11
}
func (o *TIMER_Type) SetSHORTS_COMPARE4_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1000)|value<<12)
}
func (o *TIMER_Type) GetSHORTS_COMPARE4_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x1000) >> 12
}
func (o *TIMER_Type) SetSHORTS_COMPARE5_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2000)|value<<13)
}
func (o *TIMER_Type) GetSHORTS_COMPARE5_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2000) >> 13
}

// TIMER.INTENSET: Enable interrupt
func (o *TIMER_Type) SetINTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTENSET_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTENSET_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTENSET_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTENSET_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}

// TIMER.INTENCLR: Disable interrupt
func (o *TIMER_Type) SetINTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTENCLR_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTENCLR_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}

// TIMER.MODE: Timer mode selection
func (o *TIMER_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}

// TIMER.BITMODE: Configure the number of bits used by the TIMER
func (o *TIMER_Type) SetBITMODE(value uint32) {
	volatile.StoreUint32(&o.BITMODE.Reg, volatile.LoadUint32(&o.BITMODE.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetBITMODE() uint32 {
	return volatile.LoadUint32(&o.BITMODE.Reg) & 0x3
}

// TIMER.PRESCALER: Timer prescaler register
func (o *TIMER_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0xf)|value)
}
func (o *TIMER_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0xf
}

// TIMER.CC: Description collection[0]: Capture/Compare register 0
func (o *TIMER_Type) SetCC(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, value)
}
func (o *TIMER_Type) GetCC(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg)
}

// Real time counter 0
type RTC_Type struct {
	TASKS_START      volatile.Register32 // 0x0
	TASKS_STOP       volatile.Register32 // 0x4
	TASKS_CLEAR      volatile.Register32 // 0x8
	TASKS_TRIGOVRFLW volatile.Register32 // 0xC
	_                [240]byte
	EVENTS_TICK      volatile.Register32 // 0x100
	EVENTS_OVRFLW    volatile.Register32 // 0x104
	_                [56]byte
	EVENTS_COMPARE   [4]volatile.Register32 // 0x140
	_                [436]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [52]byte
	EVTEN            volatile.Register32 // 0x340
	EVTENSET         volatile.Register32 // 0x344
	EVTENCLR         volatile.Register32 // 0x348
	_                [440]byte
	COUNTER          volatile.Register32 // 0x504
	PRESCALER        volatile.Register32 // 0x508
	_                [52]byte
	CC               [4]volatile.Register32 // 0x540
}

// RTC.INTENSET: Enable interrupt
func (o *RTC_Type) SetINTENSET_TICK(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTENSET_TICK() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *RTC_Type) SetINTENSET_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetINTENSET_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetINTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetINTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetINTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetINTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetINTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetINTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetINTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetINTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}

// RTC.INTENCLR: Disable interrupt
func (o *RTC_Type) SetINTENCLR_TICK(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTENCLR_TICK() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *RTC_Type) SetINTENCLR_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetINTENCLR_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetINTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetINTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetINTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetINTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetINTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetINTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetINTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetINTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}

// RTC.EVTEN: Enable or disable event routing
func (o *RTC_Type) SetEVTEN_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTEN_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTEN.Reg) & 0x1
}
func (o *RTC_Type) SetEVTEN_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTEN_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTEN_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTEN_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTEN_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTEN_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTEN_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTEN_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTEN_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTEN_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x80000) >> 19
}

// RTC.EVTENSET: Enable event routing
func (o *RTC_Type) SetEVTENSET_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTENSET_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTENSET.Reg) & 0x1
}
func (o *RTC_Type) SetEVTENSET_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTENSET_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x80000) >> 19
}

// RTC.EVTENCLR: Disable event routing
func (o *RTC_Type) SetEVTENCLR_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTENCLR_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x1
}
func (o *RTC_Type) SetEVTENCLR_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTENCLR_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x80000) >> 19
}

// RTC.COUNTER: Current COUNTER value
func (o *RTC_Type) SetCOUNTER(value uint32) {
	volatile.StoreUint32(&o.COUNTER.Reg, volatile.LoadUint32(&o.COUNTER.Reg)&^(0xffffff)|value)
}
func (o *RTC_Type) GetCOUNTER() uint32 {
	return volatile.LoadUint32(&o.COUNTER.Reg) & 0xffffff
}

// RTC.PRESCALER: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
func (o *RTC_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0xfff
}

// RTC.CC: Description collection[0]: Compare register 0
func (o *RTC_Type) SetCC_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, volatile.LoadUint32(&o.CC[idx].Reg)&^(0xffffff)|value)
}
func (o *RTC_Type) GetCC_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg) & 0xffffff
}

// Temperature Sensor
type TEMP_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	TASKS_STOP     volatile.Register32 // 0x4
	_              [248]byte
	EVENTS_DATARDY volatile.Register32 // 0x100
	_              [512]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [508]byte
	TEMP           volatile.Register32 // 0x508
	_              [20]byte
	A0             volatile.Register32 // 0x520
	A1             volatile.Register32 // 0x524
	A2             volatile.Register32 // 0x528
	A3             volatile.Register32 // 0x52C
	A4             volatile.Register32 // 0x530
	A5             volatile.Register32 // 0x534
	_              [8]byte
	B0             volatile.Register32 // 0x540
	B1             volatile.Register32 // 0x544
	B2             volatile.Register32 // 0x548
	B3             volatile.Register32 // 0x54C
	B4             volatile.Register32 // 0x550
	B5             volatile.Register32 // 0x554
	_              [8]byte
	T0             volatile.Register32 // 0x560
	T1             volatile.Register32 // 0x564
	T2             volatile.Register32 // 0x568
	T3             volatile.Register32 // 0x56C
	T4             volatile.Register32 // 0x570
}

// TEMP.INTENSET: Enable interrupt
func (o *TEMP_Type) SetINTENSET_DATARDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetINTENSET_DATARDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// TEMP.INTENCLR: Disable interrupt
func (o *TEMP_Type) SetINTENCLR_DATARDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetINTENCLR_DATARDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// TEMP.TEMP: Temperature in degC (0.25deg steps)
func (o *TEMP_Type) SetTEMP(value uint32) {
	volatile.StoreUint32(&o.TEMP.Reg, value)
}
func (o *TEMP_Type) GetTEMP() uint32 {
	return volatile.LoadUint32(&o.TEMP.Reg)
}

// TEMP.A0: Slope of 1st piece wise linear function
func (o *TEMP_Type) SetA0(value uint32) {
	volatile.StoreUint32(&o.A0.Reg, volatile.LoadUint32(&o.A0.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA0() uint32 {
	return volatile.LoadUint32(&o.A0.Reg) & 0xfff
}

// TEMP.A1: Slope of 2nd piece wise linear function
func (o *TEMP_Type) SetA1(value uint32) {
	volatile.StoreUint32(&o.A1.Reg, volatile.LoadUint32(&o.A1.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA1() uint32 {
	return volatile.LoadUint32(&o.A1.Reg) & 0xfff
}

// TEMP.A2: Slope of 3rd piece wise linear function
func (o *TEMP_Type) SetA2(value uint32) {
	volatile.StoreUint32(&o.A2.Reg, volatile.LoadUint32(&o.A2.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA2() uint32 {
	return volatile.LoadUint32(&o.A2.Reg) & 0xfff
}

// TEMP.A3: Slope of 4th piece wise linear function
func (o *TEMP_Type) SetA3(value uint32) {
	volatile.StoreUint32(&o.A3.Reg, volatile.LoadUint32(&o.A3.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA3() uint32 {
	return volatile.LoadUint32(&o.A3.Reg) & 0xfff
}

// TEMP.A4: Slope of 5th piece wise linear function
func (o *TEMP_Type) SetA4(value uint32) {
	volatile.StoreUint32(&o.A4.Reg, volatile.LoadUint32(&o.A4.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA4() uint32 {
	return volatile.LoadUint32(&o.A4.Reg) & 0xfff
}

// TEMP.A5: Slope of 6th piece wise linear function
func (o *TEMP_Type) SetA5(value uint32) {
	volatile.StoreUint32(&o.A5.Reg, volatile.LoadUint32(&o.A5.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA5() uint32 {
	return volatile.LoadUint32(&o.A5.Reg) & 0xfff
}

// TEMP.B0: y-intercept of 1st piece wise linear function
func (o *TEMP_Type) SetB0(value uint32) {
	volatile.StoreUint32(&o.B0.Reg, volatile.LoadUint32(&o.B0.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB0() uint32 {
	return volatile.LoadUint32(&o.B0.Reg) & 0x3fff
}

// TEMP.B1: y-intercept of 2nd piece wise linear function
func (o *TEMP_Type) SetB1(value uint32) {
	volatile.StoreUint32(&o.B1.Reg, volatile.LoadUint32(&o.B1.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB1() uint32 {
	return volatile.LoadUint32(&o.B1.Reg) & 0x3fff
}

// TEMP.B2: y-intercept of 3rd piece wise linear function
func (o *TEMP_Type) SetB2(value uint32) {
	volatile.StoreUint32(&o.B2.Reg, volatile.LoadUint32(&o.B2.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB2() uint32 {
	return volatile.LoadUint32(&o.B2.Reg) & 0x3fff
}

// TEMP.B3: y-intercept of 4th piece wise linear function
func (o *TEMP_Type) SetB3(value uint32) {
	volatile.StoreUint32(&o.B3.Reg, volatile.LoadUint32(&o.B3.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB3() uint32 {
	return volatile.LoadUint32(&o.B3.Reg) & 0x3fff
}

// TEMP.B4: y-intercept of 5th piece wise linear function
func (o *TEMP_Type) SetB4(value uint32) {
	volatile.StoreUint32(&o.B4.Reg, volatile.LoadUint32(&o.B4.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB4() uint32 {
	return volatile.LoadUint32(&o.B4.Reg) & 0x3fff
}

// TEMP.B5: y-intercept of 6th piece wise linear function
func (o *TEMP_Type) SetB5(value uint32) {
	volatile.StoreUint32(&o.B5.Reg, volatile.LoadUint32(&o.B5.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB5() uint32 {
	return volatile.LoadUint32(&o.B5.Reg) & 0x3fff
}

// TEMP.T0: End point of 1st piece wise linear function
func (o *TEMP_Type) SetT0(value uint32) {
	volatile.StoreUint32(&o.T0.Reg, volatile.LoadUint32(&o.T0.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT0() uint32 {
	return volatile.LoadUint32(&o.T0.Reg) & 0xff
}

// TEMP.T1: End point of 2nd piece wise linear function
func (o *TEMP_Type) SetT1(value uint32) {
	volatile.StoreUint32(&o.T1.Reg, volatile.LoadUint32(&o.T1.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT1() uint32 {
	return volatile.LoadUint32(&o.T1.Reg) & 0xff
}

// TEMP.T2: End point of 3rd piece wise linear function
func (o *TEMP_Type) SetT2(value uint32) {
	volatile.StoreUint32(&o.T2.Reg, volatile.LoadUint32(&o.T2.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT2() uint32 {
	return volatile.LoadUint32(&o.T2.Reg) & 0xff
}

// TEMP.T3: End point of 4th piece wise linear function
func (o *TEMP_Type) SetT3(value uint32) {
	volatile.StoreUint32(&o.T3.Reg, volatile.LoadUint32(&o.T3.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT3() uint32 {
	return volatile.LoadUint32(&o.T3.Reg) & 0xff
}

// TEMP.T4: End point of 5th piece wise linear function
func (o *TEMP_Type) SetT4(value uint32) {
	volatile.StoreUint32(&o.T4.Reg, volatile.LoadUint32(&o.T4.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT4() uint32 {
	return volatile.LoadUint32(&o.T4.Reg) & 0xff
}

// Random Number Generator
type RNG_Type struct {
	TASKS_START   volatile.Register32 // 0x0
	TASKS_STOP    volatile.Register32 // 0x4
	_             [248]byte
	EVENTS_VALRDY volatile.Register32 // 0x100
	_             [252]byte
	SHORTS        volatile.Register32 // 0x200
	_             [256]byte
	INTENSET      volatile.Register32 // 0x304
	INTENCLR      volatile.Register32 // 0x308
	_             [504]byte
	CONFIG        volatile.Register32 // 0x504
	VALUE         volatile.Register32 // 0x508
}

// RNG.SHORTS: Shortcut register
func (o *RNG_Type) SetSHORTS_VALRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSHORTS_VALRDY_STOP() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}

// RNG.INTENSET: Enable interrupt
func (o *RNG_Type) SetINTENSET_VALRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetINTENSET_VALRDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// RNG.INTENCLR: Disable interrupt
func (o *RNG_Type) SetINTENCLR_VALRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetINTENCLR_VALRDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// RNG.CONFIG: Configuration register
func (o *RNG_Type) SetCONFIG_DERCEN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetCONFIG_DERCEN() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}

// RNG.VALUE: Output random number
func (o *RNG_Type) SetVALUE(value uint32) {
	volatile.StoreUint32(&o.VALUE.Reg, volatile.LoadUint32(&o.VALUE.Reg)&^(0xff)|value)
}
func (o *RNG_Type) GetVALUE() uint32 {
	return volatile.LoadUint32(&o.VALUE.Reg) & 0xff
}

// AES ECB Mode Encryption
type ECB_Type struct {
	TASKS_STARTECB  volatile.Register32 // 0x0
	TASKS_STOPECB   volatile.Register32 // 0x4
	_               [248]byte
	EVENTS_ENDECB   volatile.Register32 // 0x100
	EVENTS_ERRORECB volatile.Register32 // 0x104
	_               [508]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [504]byte
	ECBDATAPTR      volatile.Register32 // 0x504
}

// ECB.INTENSET: Enable interrupt
func (o *ECB_Type) SetINTENSET_ENDECB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetINTENSET_ENDECB() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *ECB_Type) SetINTENSET_ERRORECB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *ECB_Type) GetINTENSET_ERRORECB() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}

// ECB.INTENCLR: Disable interrupt
func (o *ECB_Type) SetINTENCLR_ENDECB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetINTENCLR_ENDECB() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *ECB_Type) SetINTENCLR_ERRORECB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *ECB_Type) GetINTENCLR_ERRORECB() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}

// ECB.ECBDATAPTR: ECB block encrypt memory pointers
func (o *ECB_Type) SetECBDATAPTR(value uint32) {
	volatile.StoreUint32(&o.ECBDATAPTR.Reg, value)
}
func (o *ECB_Type) GetECBDATAPTR() uint32 {
	return volatile.LoadUint32(&o.ECBDATAPTR.Reg)
}

// AES CCM Mode Encryption
type CCM_Type struct {
	TASKS_KSGEN     volatile.Register32 // 0x0
	TASKS_CRYPT     volatile.Register32 // 0x4
	TASKS_STOP      volatile.Register32 // 0x8
	_               [244]byte
	EVENTS_ENDKSGEN volatile.Register32 // 0x100
	EVENTS_ENDCRYPT volatile.Register32 // 0x104
	EVENTS_ERROR    volatile.Register32 // 0x108
	_               [244]byte
	SHORTS          volatile.Register32 // 0x200
	_               [256]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [244]byte
	MICSTATUS       volatile.Register32 // 0x400
	_               [252]byte
	ENABLE          volatile.Register32 // 0x500
	MODE            volatile.Register32 // 0x504
	CNFPTR          volatile.Register32 // 0x508
	INPTR           volatile.Register32 // 0x50C
	OUTPTR          volatile.Register32 // 0x510
	SCRATCHPTR      volatile.Register32 // 0x514
}

// CCM.SHORTS: Shortcut register
func (o *CCM_Type) SetSHORTS_ENDKSGEN_CRYPT(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetSHORTS_ENDKSGEN_CRYPT() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}

// CCM.INTENSET: Enable interrupt
func (o *CCM_Type) SetINTENSET_ENDKSGEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetINTENSET_ENDKSGEN() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *CCM_Type) SetINTENSET_ENDCRYPT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *CCM_Type) GetINTENSET_ENDCRYPT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *CCM_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *CCM_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// CCM.INTENCLR: Disable interrupt
func (o *CCM_Type) SetINTENCLR_ENDKSGEN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetINTENCLR_ENDKSGEN() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *CCM_Type) SetINTENCLR_ENDCRYPT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *CCM_Type) GetINTENCLR_ENDCRYPT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *CCM_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *CCM_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// CCM.MICSTATUS: MIC check result
func (o *CCM_Type) SetMICSTATUS(value uint32) {
	volatile.StoreUint32(&o.MICSTATUS.Reg, volatile.LoadUint32(&o.MICSTATUS.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetMICSTATUS() uint32 {
	return volatile.LoadUint32(&o.MICSTATUS.Reg) & 0x1
}

// CCM.ENABLE: Enable
func (o *CCM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// CCM.MODE: Operation mode
func (o *CCM_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *CCM_Type) SetMODE_DATARATE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_Type) GetMODE_DATARATE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x10000) >> 16
}
func (o *CCM_Type) SetMODE_LENGTH(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1000000)|value<<24)
}
func (o *CCM_Type) GetMODE_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x1000000) >> 24
}

// CCM.CNFPTR: Pointer to data structure holding AES key and NONCE vector
func (o *CCM_Type) SetCNFPTR(value uint32) {
	volatile.StoreUint32(&o.CNFPTR.Reg, value)
}
func (o *CCM_Type) GetCNFPTR() uint32 {
	return volatile.LoadUint32(&o.CNFPTR.Reg)
}

// CCM.INPTR: Input pointer
func (o *CCM_Type) SetINPTR(value uint32) {
	volatile.StoreUint32(&o.INPTR.Reg, value)
}
func (o *CCM_Type) GetINPTR() uint32 {
	return volatile.LoadUint32(&o.INPTR.Reg)
}

// CCM.OUTPTR: Output pointer
func (o *CCM_Type) SetOUTPTR(value uint32) {
	volatile.StoreUint32(&o.OUTPTR.Reg, value)
}
func (o *CCM_Type) GetOUTPTR() uint32 {
	return volatile.LoadUint32(&o.OUTPTR.Reg)
}

// CCM.SCRATCHPTR: Pointer to data area used for temporary storage
func (o *CCM_Type) SetSCRATCHPTR(value uint32) {
	volatile.StoreUint32(&o.SCRATCHPTR.Reg, value)
}
func (o *CCM_Type) GetSCRATCHPTR() uint32 {
	return volatile.LoadUint32(&o.SCRATCHPTR.Reg)
}

// Accelerated Address Resolver
type AAR_Type struct {
	TASKS_START        volatile.Register32 // 0x0
	_                  [4]byte
	TASKS_STOP         volatile.Register32 // 0x8
	_                  [244]byte
	EVENTS_END         volatile.Register32 // 0x100
	EVENTS_RESOLVED    volatile.Register32 // 0x104
	EVENTS_NOTRESOLVED volatile.Register32 // 0x108
	_                  [504]byte
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [244]byte
	STATUS             volatile.Register32 // 0x400
	_                  [252]byte
	ENABLE             volatile.Register32 // 0x500
	NIRK               volatile.Register32 // 0x504
	IRKPTR             volatile.Register32 // 0x508
	_                  [4]byte
	ADDRPTR            volatile.Register32 // 0x510
	SCRATCHPTR         volatile.Register32 // 0x514
}

// AAR.INTENSET: Enable interrupt
func (o *AAR_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetINTENSET_END() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *AAR_Type) SetINTENSET_RESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *AAR_Type) GetINTENSET_RESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *AAR_Type) SetINTENSET_NOTRESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *AAR_Type) GetINTENSET_NOTRESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// AAR.INTENCLR: Disable interrupt
func (o *AAR_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetINTENCLR_END() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *AAR_Type) SetINTENCLR_RESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *AAR_Type) GetINTENCLR_RESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *AAR_Type) SetINTENCLR_NOTRESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *AAR_Type) GetINTENCLR_NOTRESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// AAR.STATUS: Resolution status
func (o *AAR_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf)|value)
}
func (o *AAR_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0xf
}

// AAR.ENABLE: Enable AAR
func (o *AAR_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *AAR_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// AAR.NIRK: Number of IRKs
func (o *AAR_Type) SetNIRK(value uint32) {
	volatile.StoreUint32(&o.NIRK.Reg, volatile.LoadUint32(&o.NIRK.Reg)&^(0x1f)|value)
}
func (o *AAR_Type) GetNIRK() uint32 {
	return volatile.LoadUint32(&o.NIRK.Reg) & 0x1f
}

// AAR.IRKPTR: Pointer to IRK data structure
func (o *AAR_Type) SetIRKPTR(value uint32) {
	volatile.StoreUint32(&o.IRKPTR.Reg, value)
}
func (o *AAR_Type) GetIRKPTR() uint32 {
	return volatile.LoadUint32(&o.IRKPTR.Reg)
}

// AAR.ADDRPTR: Pointer to the resolvable address
func (o *AAR_Type) SetADDRPTR(value uint32) {
	volatile.StoreUint32(&o.ADDRPTR.Reg, value)
}
func (o *AAR_Type) GetADDRPTR() uint32 {
	return volatile.LoadUint32(&o.ADDRPTR.Reg)
}

// AAR.SCRATCHPTR: Pointer to data area used for temporary storage
func (o *AAR_Type) SetSCRATCHPTR(value uint32) {
	volatile.StoreUint32(&o.SCRATCHPTR.Reg, value)
}
func (o *AAR_Type) GetSCRATCHPTR() uint32 {
	return volatile.LoadUint32(&o.SCRATCHPTR.Reg)
}

// Watchdog Timer
type WDT_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	_              [252]byte
	EVENTS_TIMEOUT volatile.Register32 // 0x100
	_              [512]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [244]byte
	RUNSTATUS      volatile.Register32 // 0x400
	REQSTATUS      volatile.Register32 // 0x404
	_              [252]byte
	CRV            volatile.Register32 // 0x504
	RREN           volatile.Register32 // 0x508
	CONFIG         volatile.Register32 // 0x50C
	_              [240]byte
	RR             [8]volatile.Register32 // 0x600
}

// WDT.INTENSET: Enable interrupt
func (o *WDT_Type) SetINTENSET_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENSET_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// WDT.INTENCLR: Disable interrupt
func (o *WDT_Type) SetINTENCLR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENCLR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// WDT.RUNSTATUS: Run status
func (o *WDT_Type) SetRUNSTATUS(value uint32) {
	volatile.StoreUint32(&o.RUNSTATUS.Reg, volatile.LoadUint32(&o.RUNSTATUS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetRUNSTATUS() uint32 {
	return volatile.LoadUint32(&o.RUNSTATUS.Reg) & 0x1
}

// WDT.REQSTATUS: Request status
func (o *WDT_Type) SetREQSTATUS_RR0(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetREQSTATUS_RR0() uint32 {
	return volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x1
}
func (o *WDT_Type) SetREQSTATUS_RR1(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetREQSTATUS_RR1() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetREQSTATUS_RR2(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetREQSTATUS_RR2() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetREQSTATUS_RR3(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetREQSTATUS_RR3() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetREQSTATUS_RR4(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetREQSTATUS_RR4() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x10) >> 4
}
func (o *WDT_Type) SetREQSTATUS_RR5(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *WDT_Type) GetREQSTATUS_RR5() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x20) >> 5
}
func (o *WDT_Type) SetREQSTATUS_RR6(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetREQSTATUS_RR6() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x40) >> 6
}
func (o *WDT_Type) SetREQSTATUS_RR7(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetREQSTATUS_RR7() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x80) >> 7
}

// WDT.CRV: Counter reload value
func (o *WDT_Type) SetCRV(value uint32) {
	volatile.StoreUint32(&o.CRV.Reg, value)
}
func (o *WDT_Type) GetCRV() uint32 {
	return volatile.LoadUint32(&o.CRV.Reg)
}

// WDT.RREN: Enable register for reload request registers
func (o *WDT_Type) SetRREN_RR0(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetRREN_RR0() uint32 {
	return volatile.LoadUint32(&o.RREN.Reg) & 0x1
}
func (o *WDT_Type) SetRREN_RR1(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetRREN_RR1() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetRREN_RR2(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetRREN_RR2() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetRREN_RR3(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetRREN_RR3() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetRREN_RR4(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetRREN_RR4() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x10) >> 4
}
func (o *WDT_Type) SetRREN_RR5(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x20)|value<<5)
}
func (o *WDT_Type) GetRREN_RR5() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x20) >> 5
}
func (o *WDT_Type) SetRREN_RR6(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetRREN_RR6() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x40) >> 6
}
func (o *WDT_Type) SetRREN_RR7(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetRREN_RR7() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x80) >> 7
}

// WDT.CONFIG: Configuration register
func (o *WDT_Type) SetCONFIG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetCONFIG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *WDT_Type) SetCONFIG_HALT(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetCONFIG_HALT() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x8) >> 3
}

// WDT.RR: Description collection[0]: Reload request 0
func (o *WDT_Type) SetRR(idx int, value uint32) {
	volatile.StoreUint32(&o.RR[idx].Reg, value)
}
func (o *WDT_Type) GetRR(idx int) uint32 {
	return volatile.LoadUint32(&o.RR[idx].Reg)
}

// Quadrature Decoder
type QDEC_Type struct {
	TASKS_START      volatile.Register32 // 0x0
	TASKS_STOP       volatile.Register32 // 0x4
	TASKS_READCLRACC volatile.Register32 // 0x8
	TASKS_RDCLRACC   volatile.Register32 // 0xC
	TASKS_RDCLRDBL   volatile.Register32 // 0x10
	_                [236]byte
	EVENTS_SAMPLERDY volatile.Register32 // 0x100
	EVENTS_REPORTRDY volatile.Register32 // 0x104
	EVENTS_ACCOF     volatile.Register32 // 0x108
	EVENTS_DBLRDY    volatile.Register32 // 0x10C
	EVENTS_STOPPED   volatile.Register32 // 0x110
	_                [236]byte
	SHORTS           volatile.Register32 // 0x200
	_                [256]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [500]byte
	ENABLE           volatile.Register32 // 0x500
	LEDPOL           volatile.Register32 // 0x504
	SAMPLEPER        volatile.Register32 // 0x508
	SAMPLE           volatile.Register32 // 0x50C
	REPORTPER        volatile.Register32 // 0x510
	ACC              volatile.Register32 // 0x514
	ACCREAD          volatile.Register32 // 0x518
	PSEL             QDEC_PSEL_Type      // 0x51C
	DBFEN            volatile.Register32 // 0x528
	_                [20]byte
	LEDPRE           volatile.Register32 // 0x540
	ACCDBL           volatile.Register32 // 0x544
	ACCDBLREAD       volatile.Register32 // 0x548
}

// QDEC.SHORTS: Shortcut register
func (o *QDEC_Type) SetSHORTS_REPORTRDY_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_READCLRACC() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *QDEC_Type) SetSHORTS_SAMPLERDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetSHORTS_SAMPLERDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetSHORTS_REPORTRDY_RDCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_RDCLRACC() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetSHORTS_REPORTRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetSHORTS_DBLRDY_RDCLRDBL(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetSHORTS_DBLRDY_RDCLRDBL() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *QDEC_Type) SetSHORTS_DBLRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_Type) GetSHORTS_DBLRDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *QDEC_Type) SetSHORTS_SAMPLERDY_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *QDEC_Type) GetSHORTS_SAMPLERDY_READCLRACC() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}

// QDEC.INTENSET: Enable interrupt
func (o *QDEC_Type) SetINTENSET_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTENSET_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *QDEC_Type) SetINTENSET_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTENSET_REPORTRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTENSET_ACCOF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTENSET_ACCOF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTENSET_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTENSET_DBLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}

// QDEC.INTENCLR: Disable interrupt
func (o *QDEC_Type) SetINTENCLR_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTENCLR_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *QDEC_Type) SetINTENCLR_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTENCLR_REPORTRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTENCLR_ACCOF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTENCLR_ACCOF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTENCLR_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTENCLR_DBLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}

// QDEC.ENABLE: Enable the quadrature decoder
func (o *QDEC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// QDEC.LEDPOL: LED output pin polarity
func (o *QDEC_Type) SetLEDPOL(value uint32) {
	volatile.StoreUint32(&o.LEDPOL.Reg, volatile.LoadUint32(&o.LEDPOL.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetLEDPOL() uint32 {
	return volatile.LoadUint32(&o.LEDPOL.Reg) & 0x1
}

// QDEC.SAMPLEPER: Sample period
func (o *QDEC_Type) SetSAMPLEPER(value uint32) {
	volatile.StoreUint32(&o.SAMPLEPER.Reg, volatile.LoadUint32(&o.SAMPLEPER.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetSAMPLEPER() uint32 {
	return volatile.LoadUint32(&o.SAMPLEPER.Reg) & 0xf
}

// QDEC.SAMPLE: Motion sample value
func (o *QDEC_Type) SetSAMPLE(value uint32) {
	volatile.StoreUint32(&o.SAMPLE.Reg, value)
}
func (o *QDEC_Type) GetSAMPLE() uint32 {
	return volatile.LoadUint32(&o.SAMPLE.Reg)
}

// QDEC.REPORTPER: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
func (o *QDEC_Type) SetREPORTPER(value uint32) {
	volatile.StoreUint32(&o.REPORTPER.Reg, volatile.LoadUint32(&o.REPORTPER.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetREPORTPER() uint32 {
	return volatile.LoadUint32(&o.REPORTPER.Reg) & 0xf
}

// QDEC.ACC: Register accumulating the valid transitions
func (o *QDEC_Type) SetACC(value uint32) {
	volatile.StoreUint32(&o.ACC.Reg, value)
}
func (o *QDEC_Type) GetACC() uint32 {
	return volatile.LoadUint32(&o.ACC.Reg)
}

// QDEC.ACCREAD: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
func (o *QDEC_Type) SetACCREAD(value uint32) {
	volatile.StoreUint32(&o.ACCREAD.Reg, value)
}
func (o *QDEC_Type) GetACCREAD() uint32 {
	return volatile.LoadUint32(&o.ACCREAD.Reg)
}

// QDEC.DBFEN: Enable input debounce filters
func (o *QDEC_Type) SetDBFEN(value uint32) {
	volatile.StoreUint32(&o.DBFEN.Reg, volatile.LoadUint32(&o.DBFEN.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetDBFEN() uint32 {
	return volatile.LoadUint32(&o.DBFEN.Reg) & 0x1
}

// QDEC.LEDPRE: Time period the LED is switched ON prior to sampling
func (o *QDEC_Type) SetLEDPRE(value uint32) {
	volatile.StoreUint32(&o.LEDPRE.Reg, volatile.LoadUint32(&o.LEDPRE.Reg)&^(0x1ff)|value)
}
func (o *QDEC_Type) GetLEDPRE() uint32 {
	return volatile.LoadUint32(&o.LEDPRE.Reg) & 0x1ff
}

// QDEC.ACCDBL: Register accumulating the number of detected double transitions
func (o *QDEC_Type) SetACCDBL(value uint32) {
	volatile.StoreUint32(&o.ACCDBL.Reg, volatile.LoadUint32(&o.ACCDBL.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetACCDBL() uint32 {
	return volatile.LoadUint32(&o.ACCDBL.Reg) & 0xf
}

// QDEC.ACCDBLREAD: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
func (o *QDEC_Type) SetACCDBLREAD(value uint32) {
	volatile.StoreUint32(&o.ACCDBLREAD.Reg, volatile.LoadUint32(&o.ACCDBLREAD.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetACCDBLREAD() uint32 {
	return volatile.LoadUint32(&o.ACCDBLREAD.Reg) & 0xf
}

type QDEC_PSEL_Type struct {
	LED volatile.Register32 // 0x51C
	A   volatile.Register32 // 0x520
	B   volatile.Register32 // 0x524
}

// QDEC_PSEL.LED: Pin select for LED signal
func (o *QDEC_PSEL_Type) SetLED_PIN(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetLED_PIN() uint32 {
	return volatile.LoadUint32(&o.LED.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetLED_CONNECT(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetLED_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.LED.Reg) & 0x80000000) >> 31
}

// QDEC_PSEL.A: Pin select for A signal
func (o *QDEC_PSEL_Type) SetA_PIN(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetA_PIN() uint32 {
	return volatile.LoadUint32(&o.A.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.A.Reg) & 0x80000000) >> 31
}

// QDEC_PSEL.B: Pin select for B signal
func (o *QDEC_PSEL_Type) SetB_PIN(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetB_PIN() uint32 {
	return volatile.LoadUint32(&o.B.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetB_CONNECT(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetB_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.B.Reg) & 0x80000000) >> 31
}

// Comparator
type COMP_Type struct {
	TASKS_START  volatile.Register32 // 0x0
	TASKS_STOP   volatile.Register32 // 0x4
	TASKS_SAMPLE volatile.Register32 // 0x8
	_            [244]byte
	EVENTS_READY volatile.Register32 // 0x100
	EVENTS_DOWN  volatile.Register32 // 0x104
	EVENTS_UP    volatile.Register32 // 0x108
	EVENTS_CROSS volatile.Register32 // 0x10C
	_            [240]byte
	SHORTS       volatile.Register32 // 0x200
	_            [252]byte
	INTEN        volatile.Register32 // 0x300
	INTENSET     volatile.Register32 // 0x304
	INTENCLR     volatile.Register32 // 0x308
	_            [244]byte
	RESULT       volatile.Register32 // 0x400
	_            [252]byte
	ENABLE       volatile.Register32 // 0x500
	PSEL         volatile.Register32 // 0x504
	REFSEL       volatile.Register32 // 0x508
	EXTREFSEL    volatile.Register32 // 0x50C
	_            [32]byte
	TH           volatile.Register32 // 0x530
	MODE         volatile.Register32 // 0x534
	HYST         volatile.Register32 // 0x538
	ISOURCE      volatile.Register32 // 0x53C
}

// COMP.SHORTS: Shortcut register
func (o *COMP_Type) SetSHORTS_READY_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetSHORTS_READY_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *COMP_Type) SetSHORTS_READY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetSHORTS_READY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetSHORTS_DOWN_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetSHORTS_DOWN_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetSHORTS_UP_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetSHORTS_UP_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *COMP_Type) SetSHORTS_CROSS_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *COMP_Type) GetSHORTS_CROSS_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// COMP.INTEN: Enable or disable interrupt
func (o *COMP_Type) SetINTEN_READY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTEN_READY() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *COMP_Type) SetINTEN_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTEN_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTEN_UP(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTEN_UP() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTEN_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTEN_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}

// COMP.INTENSET: Enable interrupt
func (o *COMP_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *COMP_Type) SetINTENSET_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTENSET_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTENSET_UP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTENSET_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTENSET_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTENSET_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}

// COMP.INTENCLR: Disable interrupt
func (o *COMP_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *COMP_Type) SetINTENCLR_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTENCLR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTENCLR_UP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTENCLR_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTENCLR_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTENCLR_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}

// COMP.RESULT: Compare result
func (o *COMP_Type) SetRESULT(value uint32) {
	volatile.StoreUint32(&o.RESULT.Reg, volatile.LoadUint32(&o.RESULT.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetRESULT() uint32 {
	return volatile.LoadUint32(&o.RESULT.Reg) & 0x1
}

// COMP.ENABLE: COMP enable
func (o *COMP_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// COMP.PSEL: Pin select
func (o *COMP_Type) SetPSEL(value uint32) {
	volatile.StoreUint32(&o.PSEL.Reg, volatile.LoadUint32(&o.PSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetPSEL() uint32 {
	return volatile.LoadUint32(&o.PSEL.Reg) & 0x7
}

// COMP.REFSEL: Reference source select for single-ended mode
func (o *COMP_Type) SetREFSEL(value uint32) {
	volatile.StoreUint32(&o.REFSEL.Reg, volatile.LoadUint32(&o.REFSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetREFSEL() uint32 {
	return volatile.LoadUint32(&o.REFSEL.Reg) & 0x7
}

// COMP.EXTREFSEL: External reference select
func (o *COMP_Type) SetEXTREFSEL(value uint32) {
	volatile.StoreUint32(&o.EXTREFSEL.Reg, volatile.LoadUint32(&o.EXTREFSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetEXTREFSEL() uint32 {
	return volatile.LoadUint32(&o.EXTREFSEL.Reg) & 0x7
}

// COMP.TH: Threshold configuration for hysteresis unit
func (o *COMP_Type) SetTH_THDOWN(value uint32) {
	volatile.StoreUint32(&o.TH.Reg, volatile.LoadUint32(&o.TH.Reg)&^(0x3f)|value)
}
func (o *COMP_Type) GetTH_THDOWN() uint32 {
	return volatile.LoadUint32(&o.TH.Reg) & 0x3f
}
func (o *COMP_Type) SetTH_THUP(value uint32) {
	volatile.StoreUint32(&o.TH.Reg, volatile.LoadUint32(&o.TH.Reg)&^(0x3f00)|value<<8)
}
func (o *COMP_Type) GetTH_THUP() uint32 {
	return (volatile.LoadUint32(&o.TH.Reg) & 0x3f00) >> 8
}

// COMP.MODE: Mode configuration
func (o *COMP_Type) SetMODE_SP(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetMODE_SP() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}
func (o *COMP_Type) SetMODE_MAIN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x100)|value<<8)
}
func (o *COMP_Type) GetMODE_MAIN() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x100) >> 8
}

// COMP.HYST: Comparator hysteresis enable
func (o *COMP_Type) SetHYST(value uint32) {
	volatile.StoreUint32(&o.HYST.Reg, volatile.LoadUint32(&o.HYST.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetHYST() uint32 {
	return volatile.LoadUint32(&o.HYST.Reg) & 0x1
}

// COMP.ISOURCE: Current source select on analog input
func (o *COMP_Type) SetISOURCE(value uint32) {
	volatile.StoreUint32(&o.ISOURCE.Reg, volatile.LoadUint32(&o.ISOURCE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetISOURCE() uint32 {
	return volatile.LoadUint32(&o.ISOURCE.Reg) & 0x3
}

// Low Power Comparator
type LPCOMP_Type struct {
	TASKS_START  volatile.Register32 // 0x0
	TASKS_STOP   volatile.Register32 // 0x4
	TASKS_SAMPLE volatile.Register32 // 0x8
	_            [244]byte
	EVENTS_READY volatile.Register32 // 0x100
	EVENTS_DOWN  volatile.Register32 // 0x104
	EVENTS_UP    volatile.Register32 // 0x108
	EVENTS_CROSS volatile.Register32 // 0x10C
	_            [240]byte
	SHORTS       volatile.Register32 // 0x200
	_            [256]byte
	INTENSET     volatile.Register32 // 0x304
	INTENCLR     volatile.Register32 // 0x308
	_            [244]byte
	RESULT       volatile.Register32 // 0x400
	_            [252]byte
	ENABLE       volatile.Register32 // 0x500
	PSEL         volatile.Register32 // 0x504
	REFSEL       volatile.Register32 // 0x508
	EXTREFSEL    volatile.Register32 // 0x50C
	_            [16]byte
	ANADETECT    volatile.Register32 // 0x520
	_            [20]byte
	HYST         volatile.Register32 // 0x538
}

// LPCOMP.SHORTS: Shortcut register
func (o *LPCOMP_Type) SetSHORTS_READY_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetSHORTS_READY_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *LPCOMP_Type) SetSHORTS_READY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *LPCOMP_Type) GetSHORTS_READY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *LPCOMP_Type) SetSHORTS_DOWN_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *LPCOMP_Type) GetSHORTS_DOWN_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *LPCOMP_Type) SetSHORTS_UP_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *LPCOMP_Type) GetSHORTS_UP_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *LPCOMP_Type) SetSHORTS_CROSS_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *LPCOMP_Type) GetSHORTS_CROSS_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// LPCOMP.INTENSET: Enable interrupt
func (o *LPCOMP_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *LPCOMP_Type) SetINTENSET_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *LPCOMP_Type) GetINTENSET_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *LPCOMP_Type) SetINTENSET_UP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *LPCOMP_Type) GetINTENSET_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *LPCOMP_Type) SetINTENSET_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *LPCOMP_Type) GetINTENSET_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}

// LPCOMP.INTENCLR: Disable interrupt
func (o *LPCOMP_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *LPCOMP_Type) SetINTENCLR_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *LPCOMP_Type) GetINTENCLR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *LPCOMP_Type) SetINTENCLR_UP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *LPCOMP_Type) GetINTENCLR_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *LPCOMP_Type) SetINTENCLR_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *LPCOMP_Type) GetINTENCLR_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}

// LPCOMP.RESULT: Compare result
func (o *LPCOMP_Type) SetRESULT(value uint32) {
	volatile.StoreUint32(&o.RESULT.Reg, volatile.LoadUint32(&o.RESULT.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetRESULT() uint32 {
	return volatile.LoadUint32(&o.RESULT.Reg) & 0x1
}

// LPCOMP.ENABLE: Enable LPCOMP
func (o *LPCOMP_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *LPCOMP_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// LPCOMP.PSEL: Input pin select
func (o *LPCOMP_Type) SetPSEL(value uint32) {
	volatile.StoreUint32(&o.PSEL.Reg, volatile.LoadUint32(&o.PSEL.Reg)&^(0x7)|value)
}
func (o *LPCOMP_Type) GetPSEL() uint32 {
	return volatile.LoadUint32(&o.PSEL.Reg) & 0x7
}

// LPCOMP.REFSEL: Reference select
func (o *LPCOMP_Type) SetREFSEL(value uint32) {
	volatile.StoreUint32(&o.REFSEL.Reg, volatile.LoadUint32(&o.REFSEL.Reg)&^(0xf)|value)
}
func (o *LPCOMP_Type) GetREFSEL() uint32 {
	return volatile.LoadUint32(&o.REFSEL.Reg) & 0xf
}

// LPCOMP.EXTREFSEL: External reference select
func (o *LPCOMP_Type) SetEXTREFSEL(value uint32) {
	volatile.StoreUint32(&o.EXTREFSEL.Reg, volatile.LoadUint32(&o.EXTREFSEL.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetEXTREFSEL() uint32 {
	return volatile.LoadUint32(&o.EXTREFSEL.Reg) & 0x1
}

// LPCOMP.ANADETECT: Analog detect configuration
func (o *LPCOMP_Type) SetANADETECT(value uint32) {
	volatile.StoreUint32(&o.ANADETECT.Reg, volatile.LoadUint32(&o.ANADETECT.Reg)&^(0x3)|value)
}
func (o *LPCOMP_Type) GetANADETECT() uint32 {
	return volatile.LoadUint32(&o.ANADETECT.Reg) & 0x3
}

// LPCOMP.HYST: Comparator hysteresis enable
func (o *LPCOMP_Type) SetHYST(value uint32) {
	volatile.StoreUint32(&o.HYST.Reg, volatile.LoadUint32(&o.HYST.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetHYST() uint32 {
	return volatile.LoadUint32(&o.HYST.Reg) & 0x1
}

// Software interrupt 0
type SWI_Type struct {
	UNUSED volatile.Register32 // 0x0
}

// Event Generator Unit 0
type EGU_Type struct {
	TASKS_TRIGGER    [16]volatile.Register32 // 0x0
	_                [192]byte
	EVENTS_TRIGGERED [16]volatile.Register32 // 0x100
	_                [448]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
}

// EGU.INTEN: Enable or disable interrupt
func (o *EGU_Type) SetINTEN_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTEN_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *EGU_Type) SetINTEN_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTEN_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTEN_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTEN_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTEN_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTEN_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTEN_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTEN_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTEN_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTEN_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTEN_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTEN_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTEN_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTEN_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTEN_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTEN_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTEN_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTEN_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTEN_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTEN_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTEN_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTEN_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTEN_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTEN_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTEN_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTEN_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTEN_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTEN_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTEN_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTEN_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}

// EGU.INTENSET: Enable interrupt
func (o *EGU_Type) SetINTENSET_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *EGU_Type) SetINTENSET_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTENSET_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTENSET_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTENSET_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTENSET_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTENSET_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTENSET_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTENSET_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTENSET_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTENSET_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTENSET_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTENSET_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTENSET_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTENSET_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTENSET_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}

// EGU.INTENCLR: Disable interrupt
func (o *EGU_Type) SetINTENCLR_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// Pulse Width Modulation Unit 0
type PWM_Type struct {
	_                   [4]byte
	TASKS_STOP          volatile.Register32    // 0x4
	TASKS_SEQSTART      [2]volatile.Register32 // 0x8
	TASKS_NEXTSTEP      volatile.Register32    // 0x10
	_                   [240]byte
	EVENTS_STOPPED      volatile.Register32    // 0x104
	EVENTS_SEQSTARTED   [2]volatile.Register32 // 0x108
	EVENTS_SEQEND       [2]volatile.Register32 // 0x110
	EVENTS_PWMPERIODEND volatile.Register32    // 0x118
	EVENTS_LOOPSDONE    volatile.Register32    // 0x11C
	_                   [224]byte
	SHORTS              volatile.Register32 // 0x200
	_                   [252]byte
	INTEN               volatile.Register32 // 0x300
	INTENSET            volatile.Register32 // 0x304
	INTENCLR            volatile.Register32 // 0x308
	_                   [500]byte
	ENABLE              volatile.Register32 // 0x500
	MODE                volatile.Register32 // 0x504
	COUNTERTOP          volatile.Register32 // 0x508
	PRESCALER           volatile.Register32 // 0x50C
	DECODER             volatile.Register32 // 0x510
	LOOP                volatile.Register32 // 0x514
	_                   [8]byte
	SEQ                 [2]PWM_SEQ_Type // 0x520
	PSEL                PWM_PSEL_Type   // 0x560
}

// PWM.SHORTS: Shortcut register
func (o *PWM_Type) SetSHORTS_SEQEND0_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSHORTS_SEQEND0_STOP() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *PWM_Type) SetSHORTS_SEQEND1_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSHORTS_SEQEND1_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSHORTS_LOOPSDONE_SEQSTART0(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSHORTS_LOOPSDONE_SEQSTART0() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSHORTS_LOOPSDONE_SEQSTART1(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSHORTS_LOOPSDONE_SEQSTART1() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSHORTS_LOOPSDONE_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSHORTS_LOOPSDONE_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// PWM.INTEN: Enable or disable interrupt
func (o *PWM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTEN_SEQSTARTED0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTEN_SEQSTARTED0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTEN_SEQSTARTED1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTEN_SEQSTARTED1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTEN_SEQEND0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTEN_SEQEND0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTEN_SEQEND1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTEN_SEQEND1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTEN_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTEN_PWMPERIODEND() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTEN_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTEN_LOOPSDONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}

// PWM.INTENSET: Enable interrupt
func (o *PWM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTENSET_SEQSTARTED0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTENSET_SEQSTARTED0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTENSET_SEQSTARTED1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTENSET_SEQSTARTED1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTENSET_SEQEND0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTENSET_SEQEND0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTENSET_SEQEND1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTENSET_SEQEND1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTENSET_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTENSET_PWMPERIODEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTENSET_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTENSET_LOOPSDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}

// PWM.INTENCLR: Disable interrupt
func (o *PWM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTENCLR_SEQSTARTED0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTENCLR_SEQSTARTED0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTENCLR_SEQSTARTED1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTENCLR_SEQSTARTED1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTENCLR_SEQEND0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTENCLR_SEQEND0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTENCLR_SEQEND1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTENCLR_SEQEND1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTENCLR_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTENCLR_PWMPERIODEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTENCLR_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTENCLR_LOOPSDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}

// PWM.ENABLE: PWM module enable register
func (o *PWM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// PWM.MODE: Selects operating mode of the wave counter
func (o *PWM_Type) SetMODE_UPDOWN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetMODE_UPDOWN() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}

// PWM.COUNTERTOP: Value up to which the pulse generator counter counts
func (o *PWM_Type) SetCOUNTERTOP(value uint32) {
	volatile.StoreUint32(&o.COUNTERTOP.Reg, volatile.LoadUint32(&o.COUNTERTOP.Reg)&^(0x7fff)|value)
}
func (o *PWM_Type) GetCOUNTERTOP() uint32 {
	return volatile.LoadUint32(&o.COUNTERTOP.Reg) & 0x7fff
}

// PWM.PRESCALER: Configuration for PWM_CLK
func (o *PWM_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0x7)|value)
}
func (o *PWM_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0x7
}

// PWM.DECODER: Configuration of the decoder
func (o *PWM_Type) SetDECODER_LOAD(value uint32) {
	volatile.StoreUint32(&o.DECODER.Reg, volatile.LoadUint32(&o.DECODER.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetDECODER_LOAD() uint32 {
	return volatile.LoadUint32(&o.DECODER.Reg) & 0x3
}
func (o *PWM_Type) SetDECODER_MODE(value uint32) {
	volatile.StoreUint32(&o.DECODER.Reg, volatile.LoadUint32(&o.DECODER.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetDECODER_MODE() uint32 {
	return (volatile.LoadUint32(&o.DECODER.Reg) & 0x100) >> 8
}

// PWM.LOOP: Amount of playback of a loop
func (o *PWM_Type) SetLOOP_CNT(value uint32) {
	volatile.StoreUint32(&o.LOOP.Reg, volatile.LoadUint32(&o.LOOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetLOOP_CNT() uint32 {
	return volatile.LoadUint32(&o.LOOP.Reg) & 0xffff
}

type PWM_SEQ_Type struct {
	PTR      volatile.Register32 // 0x520
	CNT      volatile.Register32 // 0x524
	REFRESH  volatile.Register32 // 0x528
	ENDDELAY volatile.Register32 // 0x52C
	_        [16]byte
}

// PWM_SEQ.PTR: Description cluster[0]: Beginning address in Data RAM of this sequence
func (o *PWM_SEQ_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *PWM_SEQ_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// PWM_SEQ.CNT: Description cluster[0]: Amount of values (duty cycles) in this sequence
func (o *PWM_SEQ_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x7fff)|value)
}
func (o *PWM_SEQ_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0x7fff
}

// PWM_SEQ.REFRESH: Description cluster[0]: Amount of additional PWM periods between samples loaded into compare register
func (o *PWM_SEQ_Type) SetREFRESH_CNT(value uint32) {
	volatile.StoreUint32(&o.REFRESH.Reg, volatile.LoadUint32(&o.REFRESH.Reg)&^(0xffffff)|value)
}
func (o *PWM_SEQ_Type) GetREFRESH_CNT() uint32 {
	return volatile.LoadUint32(&o.REFRESH.Reg) & 0xffffff
}

// PWM_SEQ.ENDDELAY: Description cluster[0]: Time added after the sequence
func (o *PWM_SEQ_Type) SetENDDELAY_CNT(value uint32) {
	volatile.StoreUint32(&o.ENDDELAY.Reg, volatile.LoadUint32(&o.ENDDELAY.Reg)&^(0xffffff)|value)
}
func (o *PWM_SEQ_Type) GetENDDELAY_CNT() uint32 {
	return volatile.LoadUint32(&o.ENDDELAY.Reg) & 0xffffff
}

type PWM_PSEL_Type struct {
	OUT [4]volatile.Register32 // 0x560
}

// Pulse Density Modulation (Digital Microphone) Interface
type PDM_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	TASKS_STOP     volatile.Register32 // 0x4
	_              [248]byte
	EVENTS_STARTED volatile.Register32 // 0x100
	EVENTS_STOPPED volatile.Register32 // 0x104
	EVENTS_END     volatile.Register32 // 0x108
	_              [500]byte
	INTEN          volatile.Register32 // 0x300
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [500]byte
	ENABLE         volatile.Register32 // 0x500
	PDMCLKCTRL     volatile.Register32 // 0x504
	MODE           volatile.Register32 // 0x508
	_              [12]byte
	GAINL          volatile.Register32 // 0x518
	GAINR          volatile.Register32 // 0x51C
	_              [32]byte
	PSEL           PDM_PSEL_Type // 0x540
	_              [24]byte
	SAMPLE         PDM_SAMPLE_Type // 0x560
}

// PDM.INTEN: Enable or disable interrupt
func (o *PDM_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetINTEN_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *PDM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *PDM_Type) SetINTEN_END(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *PDM_Type) GetINTEN_END() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}

// PDM.INTENSET: Enable interrupt
func (o *PDM_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetINTENSET_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *PDM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *PDM_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *PDM_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// PDM.INTENCLR: Disable interrupt
func (o *PDM_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetINTENCLR_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *PDM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *PDM_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PDM_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// PDM.ENABLE: PDM module enable register
func (o *PDM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// PDM.PDMCLKCTRL: PDM clock generator control
func (o *PDM_Type) SetPDMCLKCTRL(value uint32) {
	volatile.StoreUint32(&o.PDMCLKCTRL.Reg, value)
}
func (o *PDM_Type) GetPDMCLKCTRL() uint32 {
	return volatile.LoadUint32(&o.PDMCLKCTRL.Reg)
}

// PDM.MODE: Defines the routing of the connected PDM microphones' signals
func (o *PDM_Type) SetMODE_OPERATION(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetMODE_OPERATION() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *PDM_Type) SetMODE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetMODE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x2) >> 1
}

// PDM.GAINL: Left output gain adjustment
func (o *PDM_Type) SetGAINL(value uint32) {
	volatile.StoreUint32(&o.GAINL.Reg, volatile.LoadUint32(&o.GAINL.Reg)&^(0x7f)|value)
}
func (o *PDM_Type) GetGAINL() uint32 {
	return volatile.LoadUint32(&o.GAINL.Reg) & 0x7f
}

// PDM.GAINR: Right output gain adjustment
func (o *PDM_Type) SetGAINR(value uint32) {
	volatile.StoreUint32(&o.GAINR.Reg, volatile.LoadUint32(&o.GAINR.Reg)&^(0xff)|value)
}
func (o *PDM_Type) GetGAINR() uint32 {
	return volatile.LoadUint32(&o.GAINR.Reg) & 0xff
}

type PDM_PSEL_Type struct {
	CLK volatile.Register32 // 0x540
	DIN volatile.Register32 // 0x544
}

// PDM_PSEL.CLK: Pin number configuration for PDM CLK signal
func (o *PDM_PSEL_Type) SetCLK_PIN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1f)|value)
}
func (o *PDM_PSEL_Type) GetCLK_PIN() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1f
}
func (o *PDM_PSEL_Type) SetCLK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_PSEL_Type) GetCLK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x80000000) >> 31
}

// PDM_PSEL.DIN: Pin number configuration for PDM DIN signal
func (o *PDM_PSEL_Type) SetDIN_PIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, volatile.LoadUint32(&o.DIN.Reg)&^(0x1f)|value)
}
func (o *PDM_PSEL_Type) GetDIN_PIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg) & 0x1f
}
func (o *PDM_PSEL_Type) SetDIN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, volatile.LoadUint32(&o.DIN.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_PSEL_Type) GetDIN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.DIN.Reg) & 0x80000000) >> 31
}

type PDM_SAMPLE_Type struct {
	PTR    volatile.Register32 // 0x560
	MAXCNT volatile.Register32 // 0x564
}

// PDM_SAMPLE.PTR: RAM address pointer to write samples to with EasyDMA
func (o *PDM_SAMPLE_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *PDM_SAMPLE_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// PDM_SAMPLE.MAXCNT: Number of samples to allocate memory for in EasyDMA mode
func (o *PDM_SAMPLE_Type) SetMAXCNT_BUFFSIZE(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *PDM_SAMPLE_Type) GetMAXCNT_BUFFSIZE() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// Non Volatile Memory Controller
type NVMC_Type struct {
	_         [1024]byte
	READY     volatile.Register32 // 0x400
	_         [256]byte
	CONFIG    volatile.Register32 // 0x504
	ERASEPAGE volatile.Register32 // 0x508
	ERASEALL  volatile.Register32 // 0x50C
	ERASEPCR0 volatile.Register32 // 0x510
	ERASEUICR volatile.Register32 // 0x514
	_         [40]byte
	ICACHECNF volatile.Register32 // 0x540
	_         [4]byte
	IHIT      volatile.Register32 // 0x548
	IMISS     volatile.Register32 // 0x54C
}

// NVMC.READY: Ready flag
func (o *NVMC_Type) SetREADY(value uint32) {
	volatile.StoreUint32(&o.READY.Reg, volatile.LoadUint32(&o.READY.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetREADY() uint32 {
	return volatile.LoadUint32(&o.READY.Reg) & 0x1
}

// NVMC.CONFIG: Configuration register
func (o *NVMC_Type) SetCONFIG_WEN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x3)|value)
}
func (o *NVMC_Type) GetCONFIG_WEN() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x3
}

// NVMC.ERASEPAGE: Register for erasing a page in Code area
func (o *NVMC_Type) SetERASEPAGE(value uint32) {
	volatile.StoreUint32(&o.ERASEPAGE.Reg, value)
}
func (o *NVMC_Type) GetERASEPAGE() uint32 {
	return volatile.LoadUint32(&o.ERASEPAGE.Reg)
}

// NVMC.ERASEALL: Register for erasing all non-volatile user memory
func (o *NVMC_Type) SetERASEALL(value uint32) {
	volatile.StoreUint32(&o.ERASEALL.Reg, volatile.LoadUint32(&o.ERASEALL.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetERASEALL() uint32 {
	return volatile.LoadUint32(&o.ERASEALL.Reg) & 0x1
}

// NVMC.ERASEPCR0: Deprecated register - Register for erasing a page in Code area. Equivalent to ERASEPAGE.
func (o *NVMC_Type) SetERASEPCR0(value uint32) {
	volatile.StoreUint32(&o.ERASEPCR0.Reg, value)
}
func (o *NVMC_Type) GetERASEPCR0() uint32 {
	return volatile.LoadUint32(&o.ERASEPCR0.Reg)
}

// NVMC.ERASEUICR: Register for erasing User Information Configuration Registers
func (o *NVMC_Type) SetERASEUICR(value uint32) {
	volatile.StoreUint32(&o.ERASEUICR.Reg, volatile.LoadUint32(&o.ERASEUICR.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetERASEUICR() uint32 {
	return volatile.LoadUint32(&o.ERASEUICR.Reg) & 0x1
}

// NVMC.ICACHECNF: I-Code cache configuration register.
func (o *NVMC_Type) SetICACHECNF_CACHEEN(value uint32) {
	volatile.StoreUint32(&o.ICACHECNF.Reg, volatile.LoadUint32(&o.ICACHECNF.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetICACHECNF_CACHEEN() uint32 {
	return volatile.LoadUint32(&o.ICACHECNF.Reg) & 0x1
}
func (o *NVMC_Type) SetICACHECNF_CACHEPROFEN(value uint32) {
	volatile.StoreUint32(&o.ICACHECNF.Reg, volatile.LoadUint32(&o.ICACHECNF.Reg)&^(0x100)|value<<8)
}
func (o *NVMC_Type) GetICACHECNF_CACHEPROFEN() uint32 {
	return (volatile.LoadUint32(&o.ICACHECNF.Reg) & 0x100) >> 8
}

// NVMC.IHIT: I-Code cache hit counter.
func (o *NVMC_Type) SetIHIT(value uint32) {
	volatile.StoreUint32(&o.IHIT.Reg, value)
}
func (o *NVMC_Type) GetIHIT() uint32 {
	return volatile.LoadUint32(&o.IHIT.Reg)
}

// NVMC.IMISS: I-Code cache miss counter.
func (o *NVMC_Type) SetIMISS(value uint32) {
	volatile.StoreUint32(&o.IMISS.Reg, value)
}
func (o *NVMC_Type) GetIMISS() uint32 {
	return volatile.LoadUint32(&o.IMISS.Reg)
}

// Programmable Peripheral Interconnect
type PPI_Type struct {
	TASKS_CHG [6]PPI_TASKS_CHG_Type // 0x0
	_         [1232]byte
	CHEN      volatile.Register32 // 0x500
	CHENSET   volatile.Register32 // 0x504
	CHENCLR   volatile.Register32 // 0x508
	_         [4]byte
	CH        [20]PPI_CH_Type // 0x510
	_         [592]byte
	CHG       [6]volatile.Register32 // 0x800
	_         [248]byte
	FORK      [32]PPI_FORK_Type // 0x910
}

// PPI.CHEN: Channel enable register
func (o *PPI_Type) SetCHEN_CH0(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHEN_CH0() uint32 {
	return volatile.LoadUint32(&o.CHEN.Reg) & 0x1
}
func (o *PPI_Type) SetCHEN_CH1(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHEN_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHEN_CH2(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHEN_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHEN_CH3(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHEN_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHEN_CH4(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHEN_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHEN_CH5(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHEN_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHEN_CH6(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHEN_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHEN_CH7(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHEN_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHEN_CH8(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHEN_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHEN_CH9(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHEN_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHEN_CH10(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHEN_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHEN_CH11(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHEN_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHEN_CH12(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHEN_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHEN_CH13(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHEN_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHEN_CH14(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHEN_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHEN_CH15(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHEN_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHEN_CH16(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHEN_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHEN_CH17(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHEN_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHEN_CH18(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHEN_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHEN_CH19(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHEN_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHEN_CH20(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHEN_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHEN_CH21(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHEN_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHEN_CH22(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHEN_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHEN_CH23(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHEN_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHEN_CH24(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHEN_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHEN_CH25(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHEN_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHEN_CH26(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHEN_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHEN_CH27(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHEN_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHEN_CH28(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHEN_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHEN_CH29(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHEN_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHEN_CH30(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHEN_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHEN_CH31(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHEN_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80000000) >> 31
}

// PPI.CHENSET: Channel enable set register
func (o *PPI_Type) SetCHENSET_CH0(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHENSET_CH0() uint32 {
	return volatile.LoadUint32(&o.CHENSET.Reg) & 0x1
}
func (o *PPI_Type) SetCHENSET_CH1(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHENSET_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHENSET_CH2(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHENSET_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHENSET_CH3(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHENSET_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHENSET_CH4(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHENSET_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHENSET_CH5(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHENSET_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHENSET_CH6(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHENSET_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHENSET_CH7(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHENSET_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHENSET_CH8(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHENSET_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHENSET_CH9(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHENSET_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHENSET_CH10(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHENSET_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHENSET_CH11(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHENSET_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHENSET_CH12(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHENSET_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHENSET_CH13(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHENSET_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHENSET_CH14(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHENSET_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHENSET_CH15(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHENSET_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHENSET_CH16(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHENSET_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHENSET_CH17(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHENSET_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHENSET_CH18(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHENSET_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHENSET_CH19(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHENSET_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHENSET_CH20(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHENSET_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHENSET_CH21(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHENSET_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHENSET_CH22(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHENSET_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHENSET_CH23(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHENSET_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHENSET_CH24(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHENSET_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHENSET_CH25(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHENSET_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHENSET_CH26(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHENSET_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHENSET_CH27(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHENSET_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHENSET_CH28(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHENSET_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHENSET_CH29(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHENSET_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHENSET_CH30(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHENSET_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHENSET_CH31(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHENSET_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80000000) >> 31
}

// PPI.CHENCLR: Channel enable clear register
func (o *PPI_Type) SetCHENCLR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHENCLR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1
}
func (o *PPI_Type) SetCHENCLR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHENCLR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHENCLR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHENCLR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHENCLR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHENCLR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHENCLR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHENCLR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHENCLR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHENCLR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHENCLR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHENCLR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHENCLR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHENCLR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHENCLR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHENCLR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHENCLR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHENCLR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHENCLR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHENCLR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHENCLR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHENCLR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHENCLR_CH12(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHENCLR_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHENCLR_CH13(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHENCLR_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHENCLR_CH14(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHENCLR_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHENCLR_CH15(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHENCLR_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHENCLR_CH16(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHENCLR_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHENCLR_CH17(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHENCLR_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHENCLR_CH18(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHENCLR_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHENCLR_CH19(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHENCLR_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHENCLR_CH20(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHENCLR_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHENCLR_CH21(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHENCLR_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHENCLR_CH22(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHENCLR_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHENCLR_CH23(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHENCLR_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHENCLR_CH24(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHENCLR_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHENCLR_CH25(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHENCLR_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHENCLR_CH26(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHENCLR_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHENCLR_CH27(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHENCLR_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHENCLR_CH28(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHENCLR_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHENCLR_CH29(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHENCLR_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHENCLR_CH30(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHENCLR_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHENCLR_CH31(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHENCLR_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80000000) >> 31
}

// PPI.CHG: Description collection[0]: Channel group 0
func (o *PPI_Type) SetCHG_CH0(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHG_CH0(idx int) uint32 {
	return volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1
}
func (o *PPI_Type) SetCHG_CH1(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHG_CH1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHG_CH2(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHG_CH2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHG_CH3(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHG_CH3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHG_CH4(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHG_CH4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHG_CH5(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHG_CH5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHG_CH6(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHG_CH6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHG_CH7(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHG_CH7(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHG_CH8(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHG_CH8(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHG_CH9(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHG_CH9(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHG_CH10(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHG_CH10(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHG_CH11(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHG_CH11(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHG_CH12(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHG_CH12(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHG_CH13(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHG_CH13(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHG_CH14(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHG_CH14(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHG_CH15(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHG_CH15(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHG_CH16(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHG_CH16(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHG_CH17(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHG_CH17(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHG_CH18(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHG_CH18(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHG_CH19(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHG_CH19(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHG_CH20(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHG_CH20(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHG_CH21(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHG_CH21(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHG_CH22(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHG_CH22(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHG_CH23(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHG_CH23(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHG_CH24(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHG_CH24(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHG_CH25(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHG_CH25(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHG_CH26(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHG_CH26(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHG_CH27(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHG_CH27(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHG_CH28(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHG_CH28(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHG_CH29(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHG_CH29(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHG_CH30(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHG_CH30(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHG_CH31(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHG_CH31(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80000000) >> 31
}

type PPI_TASKS_CHG_Type struct {
	EN  volatile.Register32 // 0x0
	DIS volatile.Register32 // 0x4
}

type PPI_CH_Type struct {
	EEP volatile.Register32 // 0x510
	TEP volatile.Register32 // 0x514
}

// PPI_CH.EEP: Description cluster[0]: Channel 0 event end-point
func (o *PPI_CH_Type) SetEEP(value uint32) {
	volatile.StoreUint32(&o.EEP.Reg, value)
}
func (o *PPI_CH_Type) GetEEP() uint32 {
	return volatile.LoadUint32(&o.EEP.Reg)
}

// PPI_CH.TEP: Description cluster[0]: Channel 0 task end-point
func (o *PPI_CH_Type) SetTEP(value uint32) {
	volatile.StoreUint32(&o.TEP.Reg, value)
}
func (o *PPI_CH_Type) GetTEP() uint32 {
	return volatile.LoadUint32(&o.TEP.Reg)
}

type PPI_FORK_Type struct {
	TEP volatile.Register32 // 0x910
}

// PPI_FORK.TEP: Description cluster[0]: Channel 0 task end-point
func (o *PPI_FORK_Type) SetTEP(value uint32) {
	volatile.StoreUint32(&o.TEP.Reg, value)
}
func (o *PPI_FORK_Type) GetTEP() uint32 {
	return volatile.LoadUint32(&o.TEP.Reg)
}

// Memory Watch Unit
type MWU_Type struct {
	_              [256]byte
	EVENTS_REGION  [4]MWU_EVENTS_REGION_Type // 0x100
	_              [64]byte
	EVENTS_PREGION [2]MWU_EVENTS_PREGION_Type // 0x160
	_              [400]byte
	INTEN          volatile.Register32 // 0x300
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [20]byte
	NMIEN          volatile.Register32 // 0x320
	NMIENSET       volatile.Register32 // 0x324
	NMIENCLR       volatile.Register32 // 0x328
	_              [212]byte
	PERREGION      [2]MWU_PERREGION_Type // 0x400
	_              [256]byte
	REGIONEN       volatile.Register32 // 0x510
	REGIONENSET    volatile.Register32 // 0x514
	REGIONENCLR    volatile.Register32 // 0x518
	_              [228]byte
	REGION         [4]MWU_REGION_Type // 0x600
	_              [128]byte
	PREGION        [2]MWU_PREGION_Type // 0x6C0
}

// MWU.INTEN: Enable or disable interrupt
func (o *MWU_Type) SetINTEN_REGION0WA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetINTEN_REGION0WA() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *MWU_Type) SetINTEN_REGION0RA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetINTEN_REGION0RA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetINTEN_REGION1WA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetINTEN_REGION1WA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetINTEN_REGION1RA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetINTEN_REGION1RA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetINTEN_REGION2WA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetINTEN_REGION2WA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetINTEN_REGION2RA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetINTEN_REGION2RA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetINTEN_REGION3WA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetINTEN_REGION3WA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetINTEN_REGION3RA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetINTEN_REGION3RA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetINTEN_PREGION0WA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetINTEN_PREGION0WA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetINTEN_PREGION0RA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetINTEN_PREGION0RA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetINTEN_PREGION1WA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetINTEN_PREGION1WA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetINTEN_PREGION1RA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetINTEN_PREGION1RA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000000) >> 27
}

// MWU.INTENSET: Enable interrupt
func (o *MWU_Type) SetINTENSET_REGION0WA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetINTENSET_REGION0WA() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *MWU_Type) SetINTENSET_REGION0RA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetINTENSET_REGION0RA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetINTENSET_REGION1WA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetINTENSET_REGION1WA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetINTENSET_REGION1RA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetINTENSET_REGION1RA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetINTENSET_REGION2WA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetINTENSET_REGION2WA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetINTENSET_REGION2RA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetINTENSET_REGION2RA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetINTENSET_REGION3WA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetINTENSET_REGION3WA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetINTENSET_REGION3RA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetINTENSET_REGION3RA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetINTENSET_PREGION0WA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetINTENSET_PREGION0WA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetINTENSET_PREGION0RA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetINTENSET_PREGION0RA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetINTENSET_PREGION1WA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetINTENSET_PREGION1WA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetINTENSET_PREGION1RA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetINTENSET_PREGION1RA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000000) >> 27
}

// MWU.INTENCLR: Disable interrupt
func (o *MWU_Type) SetINTENCLR_REGION0WA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetINTENCLR_REGION0WA() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *MWU_Type) SetINTENCLR_REGION0RA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetINTENCLR_REGION0RA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetINTENCLR_REGION1WA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetINTENCLR_REGION1WA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetINTENCLR_REGION1RA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetINTENCLR_REGION1RA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetINTENCLR_REGION2WA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetINTENCLR_REGION2WA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetINTENCLR_REGION2RA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetINTENCLR_REGION2RA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetINTENCLR_REGION3WA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetINTENCLR_REGION3WA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetINTENCLR_REGION3RA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetINTENCLR_REGION3RA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetINTENCLR_PREGION0WA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetINTENCLR_PREGION0WA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetINTENCLR_PREGION0RA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetINTENCLR_PREGION0RA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetINTENCLR_PREGION1WA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetINTENCLR_PREGION1WA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetINTENCLR_PREGION1RA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetINTENCLR_PREGION1RA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000000) >> 27
}

// MWU.NMIEN: Enable or disable non-maskable interrupt
func (o *MWU_Type) SetNMIEN_REGION0WA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetNMIEN_REGION0WA() uint32 {
	return volatile.LoadUint32(&o.NMIEN.Reg) & 0x1
}
func (o *MWU_Type) SetNMIEN_REGION0RA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetNMIEN_REGION0RA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetNMIEN_REGION1WA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetNMIEN_REGION1WA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetNMIEN_REGION1RA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetNMIEN_REGION1RA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetNMIEN_REGION2WA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetNMIEN_REGION2WA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetNMIEN_REGION2RA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetNMIEN_REGION2RA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetNMIEN_REGION3WA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetNMIEN_REGION3WA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetNMIEN_REGION3RA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetNMIEN_REGION3RA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetNMIEN_PREGION0WA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetNMIEN_PREGION0WA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetNMIEN_PREGION0RA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetNMIEN_PREGION0RA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetNMIEN_PREGION1WA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetNMIEN_PREGION1WA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetNMIEN_PREGION1RA(value uint32) {
	volatile.StoreUint32(&o.NMIEN.Reg, volatile.LoadUint32(&o.NMIEN.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetNMIEN_PREGION1RA() uint32 {
	return (volatile.LoadUint32(&o.NMIEN.Reg) & 0x8000000) >> 27
}

// MWU.NMIENSET: Enable non-maskable interrupt
func (o *MWU_Type) SetNMIENSET_REGION0WA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetNMIENSET_REGION0WA() uint32 {
	return volatile.LoadUint32(&o.NMIENSET.Reg) & 0x1
}
func (o *MWU_Type) SetNMIENSET_REGION0RA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetNMIENSET_REGION0RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetNMIENSET_REGION1WA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetNMIENSET_REGION1WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetNMIENSET_REGION1RA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetNMIENSET_REGION1RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetNMIENSET_REGION2WA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetNMIENSET_REGION2WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetNMIENSET_REGION2RA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetNMIENSET_REGION2RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetNMIENSET_REGION3WA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetNMIENSET_REGION3WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetNMIENSET_REGION3RA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetNMIENSET_REGION3RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetNMIENSET_PREGION0WA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetNMIENSET_PREGION0WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetNMIENSET_PREGION0RA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetNMIENSET_PREGION0RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetNMIENSET_PREGION1WA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetNMIENSET_PREGION1WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetNMIENSET_PREGION1RA(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetNMIENSET_PREGION1RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x8000000) >> 27
}

// MWU.NMIENCLR: Disable non-maskable interrupt
func (o *MWU_Type) SetNMIENCLR_REGION0WA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetNMIENCLR_REGION0WA() uint32 {
	return volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x1
}
func (o *MWU_Type) SetNMIENCLR_REGION0RA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetNMIENCLR_REGION0RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetNMIENCLR_REGION1WA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetNMIENCLR_REGION1WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetNMIENCLR_REGION1RA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetNMIENCLR_REGION1RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetNMIENCLR_REGION2WA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetNMIENCLR_REGION2WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetNMIENCLR_REGION2RA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetNMIENCLR_REGION2RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetNMIENCLR_REGION3WA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetNMIENCLR_REGION3WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetNMIENCLR_REGION3RA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetNMIENCLR_REGION3RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetNMIENCLR_PREGION0WA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetNMIENCLR_PREGION0WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetNMIENCLR_PREGION0RA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetNMIENCLR_PREGION0RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetNMIENCLR_PREGION1WA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetNMIENCLR_PREGION1WA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetNMIENCLR_PREGION1RA(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetNMIENCLR_PREGION1RA() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x8000000) >> 27
}

// MWU.REGIONEN: Enable/disable regions watch
func (o *MWU_Type) SetREGIONEN_RGN0WA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetREGIONEN_RGN0WA() uint32 {
	return volatile.LoadUint32(&o.REGIONEN.Reg) & 0x1
}
func (o *MWU_Type) SetREGIONEN_RGN0RA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetREGIONEN_RGN0RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetREGIONEN_RGN1WA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetREGIONEN_RGN1WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetREGIONEN_RGN1RA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetREGIONEN_RGN1RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetREGIONEN_RGN2WA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetREGIONEN_RGN2WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetREGIONEN_RGN2RA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetREGIONEN_RGN2RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetREGIONEN_RGN3WA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetREGIONEN_RGN3WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetREGIONEN_RGN3RA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetREGIONEN_RGN3RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetREGIONEN_PRGN0WA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetREGIONEN_PRGN0WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetREGIONEN_PRGN0RA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetREGIONEN_PRGN0RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetREGIONEN_PRGN1WA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetREGIONEN_PRGN1WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetREGIONEN_PRGN1RA(value uint32) {
	volatile.StoreUint32(&o.REGIONEN.Reg, volatile.LoadUint32(&o.REGIONEN.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetREGIONEN_PRGN1RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONEN.Reg) & 0x8000000) >> 27
}

// MWU.REGIONENSET: Enable regions watch
func (o *MWU_Type) SetREGIONENSET_RGN0WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetREGIONENSET_RGN0WA() uint32 {
	return volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x1
}
func (o *MWU_Type) SetREGIONENSET_RGN0RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetREGIONENSET_RGN0RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetREGIONENSET_RGN1WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetREGIONENSET_RGN1WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetREGIONENSET_RGN1RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetREGIONENSET_RGN1RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetREGIONENSET_RGN2WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetREGIONENSET_RGN2WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetREGIONENSET_RGN2RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetREGIONENSET_RGN2RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetREGIONENSET_RGN3WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetREGIONENSET_RGN3WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetREGIONENSET_RGN3RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetREGIONENSET_RGN3RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetREGIONENSET_PRGN0WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetREGIONENSET_PRGN0WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetREGIONENSET_PRGN0RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetREGIONENSET_PRGN0RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetREGIONENSET_PRGN1WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetREGIONENSET_PRGN1WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetREGIONENSET_PRGN1RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENSET.Reg, volatile.LoadUint32(&o.REGIONENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetREGIONENSET_PRGN1RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENSET.Reg) & 0x8000000) >> 27
}

// MWU.REGIONENCLR: Disable regions watch
func (o *MWU_Type) SetREGIONENCLR_RGN0WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x1)|value)
}
func (o *MWU_Type) GetREGIONENCLR_RGN0WA() uint32 {
	return volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x1
}
func (o *MWU_Type) SetREGIONENCLR_RGN0RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x2)|value<<1)
}
func (o *MWU_Type) GetREGIONENCLR_RGN0RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x2) >> 1
}
func (o *MWU_Type) SetREGIONENCLR_RGN1WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x4)|value<<2)
}
func (o *MWU_Type) GetREGIONENCLR_RGN1WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x4) >> 2
}
func (o *MWU_Type) SetREGIONENCLR_RGN1RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x8)|value<<3)
}
func (o *MWU_Type) GetREGIONENCLR_RGN1RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x8) >> 3
}
func (o *MWU_Type) SetREGIONENCLR_RGN2WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x10)|value<<4)
}
func (o *MWU_Type) GetREGIONENCLR_RGN2WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x10) >> 4
}
func (o *MWU_Type) SetREGIONENCLR_RGN2RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x20)|value<<5)
}
func (o *MWU_Type) GetREGIONENCLR_RGN2RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x20) >> 5
}
func (o *MWU_Type) SetREGIONENCLR_RGN3WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x40)|value<<6)
}
func (o *MWU_Type) GetREGIONENCLR_RGN3WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x40) >> 6
}
func (o *MWU_Type) SetREGIONENCLR_RGN3RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x80)|value<<7)
}
func (o *MWU_Type) GetREGIONENCLR_RGN3RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x80) >> 7
}
func (o *MWU_Type) SetREGIONENCLR_PRGN0WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_Type) GetREGIONENCLR_PRGN0WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x1000000) >> 24
}
func (o *MWU_Type) SetREGIONENCLR_PRGN0RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_Type) GetREGIONENCLR_PRGN0RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x2000000) >> 25
}
func (o *MWU_Type) SetREGIONENCLR_PRGN1WA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_Type) GetREGIONENCLR_PRGN1WA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x4000000) >> 26
}
func (o *MWU_Type) SetREGIONENCLR_PRGN1RA(value uint32) {
	volatile.StoreUint32(&o.REGIONENCLR.Reg, volatile.LoadUint32(&o.REGIONENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_Type) GetREGIONENCLR_PRGN1RA() uint32 {
	return (volatile.LoadUint32(&o.REGIONENCLR.Reg) & 0x8000000) >> 27
}

type MWU_EVENTS_REGION_Type struct {
	WA volatile.Register32 // 0x100
	RA volatile.Register32 // 0x104
}

type MWU_EVENTS_PREGION_Type struct {
	WA volatile.Register32 // 0x160
	RA volatile.Register32 // 0x164
}

type MWU_PERREGION_Type struct {
	SUBSTATWA volatile.Register32 // 0x400
	SUBSTATRA volatile.Register32 // 0x404
}

// MWU_PERREGION.SUBSTATWA: Description cluster[0]: Source of event/interrupt in region 0, write access detected while corresponding subregion was enabled for watching
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR0(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x1)|value)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR0() uint32 {
	return volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x1
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR1(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x2)|value<<1)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR1() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x2) >> 1
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR2(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x4)|value<<2)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR2() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x4) >> 2
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR3(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x8)|value<<3)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR3() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x8) >> 3
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR4(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x10)|value<<4)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR4() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x10) >> 4
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR5(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x20)|value<<5)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR5() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x20) >> 5
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR6(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x40)|value<<6)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR6() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x40) >> 6
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR7(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x80)|value<<7)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR7() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x80) >> 7
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR8(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x100)|value<<8)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR8() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x100) >> 8
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR9(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x200)|value<<9)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR9() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x200) >> 9
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR10(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x400)|value<<10)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR10() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x400) >> 10
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR11(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x800)|value<<11)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR11() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x800) >> 11
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR12(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x1000)|value<<12)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR12() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x1000) >> 12
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR13(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x2000)|value<<13)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR13() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x2000) >> 13
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR14(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x4000)|value<<14)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR14() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x4000) >> 14
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR15(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x8000)|value<<15)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR15() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x8000) >> 15
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR16(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x10000)|value<<16)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR16() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x10000) >> 16
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR17(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x20000)|value<<17)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR17() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x20000) >> 17
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR18(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x40000)|value<<18)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR18() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x40000) >> 18
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR19(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x80000)|value<<19)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR19() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x80000) >> 19
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR20(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x100000)|value<<20)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR20() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x100000) >> 20
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR21(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x200000)|value<<21)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR21() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x200000) >> 21
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR22(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x400000)|value<<22)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR22() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x400000) >> 22
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR23(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x800000)|value<<23)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR23() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x800000) >> 23
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR24(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR24() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x1000000) >> 24
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR25(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR25() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x2000000) >> 25
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR26(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR26() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x4000000) >> 26
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR27(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR27() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x8000000) >> 27
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR28(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x10000000)|value<<28)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR28() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x10000000) >> 28
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR29(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x20000000)|value<<29)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR29() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x20000000) >> 29
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR30(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x40000000)|value<<30)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR30() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x40000000) >> 30
}
func (o *MWU_PERREGION_Type) SetSUBSTATWA_SR31(value uint32) {
	volatile.StoreUint32(&o.SUBSTATWA.Reg, volatile.LoadUint32(&o.SUBSTATWA.Reg)&^(0x80000000)|value<<31)
}
func (o *MWU_PERREGION_Type) GetSUBSTATWA_SR31() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATWA.Reg) & 0x80000000) >> 31
}

// MWU_PERREGION.SUBSTATRA: Description cluster[0]: Source of event/interrupt in region 0, read access detected while corresponding subregion was enabled for watching
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR0(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x1)|value)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR0() uint32 {
	return volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x1
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR1(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x2)|value<<1)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR1() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x2) >> 1
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR2(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x4)|value<<2)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR2() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x4) >> 2
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR3(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x8)|value<<3)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR3() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x8) >> 3
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR4(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x10)|value<<4)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR4() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x10) >> 4
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR5(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x20)|value<<5)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR5() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x20) >> 5
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR6(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x40)|value<<6)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR6() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x40) >> 6
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR7(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x80)|value<<7)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR7() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x80) >> 7
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR8(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x100)|value<<8)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR8() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x100) >> 8
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR9(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x200)|value<<9)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR9() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x200) >> 9
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR10(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x400)|value<<10)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR10() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x400) >> 10
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR11(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x800)|value<<11)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR11() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x800) >> 11
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR12(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x1000)|value<<12)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR12() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x1000) >> 12
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR13(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x2000)|value<<13)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR13() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x2000) >> 13
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR14(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x4000)|value<<14)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR14() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x4000) >> 14
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR15(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x8000)|value<<15)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR15() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x8000) >> 15
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR16(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x10000)|value<<16)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR16() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x10000) >> 16
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR17(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x20000)|value<<17)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR17() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x20000) >> 17
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR18(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x40000)|value<<18)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR18() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x40000) >> 18
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR19(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x80000)|value<<19)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR19() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x80000) >> 19
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR20(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x100000)|value<<20)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR20() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x100000) >> 20
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR21(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x200000)|value<<21)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR21() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x200000) >> 21
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR22(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x400000)|value<<22)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR22() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x400000) >> 22
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR23(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x800000)|value<<23)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR23() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x800000) >> 23
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR24(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR24() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x1000000) >> 24
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR25(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR25() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x2000000) >> 25
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR26(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR26() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x4000000) >> 26
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR27(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR27() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x8000000) >> 27
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR28(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x10000000)|value<<28)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR28() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x10000000) >> 28
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR29(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x20000000)|value<<29)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR29() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x20000000) >> 29
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR30(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x40000000)|value<<30)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR30() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x40000000) >> 30
}
func (o *MWU_PERREGION_Type) SetSUBSTATRA_SR31(value uint32) {
	volatile.StoreUint32(&o.SUBSTATRA.Reg, volatile.LoadUint32(&o.SUBSTATRA.Reg)&^(0x80000000)|value<<31)
}
func (o *MWU_PERREGION_Type) GetSUBSTATRA_SR31() uint32 {
	return (volatile.LoadUint32(&o.SUBSTATRA.Reg) & 0x80000000) >> 31
}

type MWU_REGION_Type struct {
	START volatile.Register32 // 0x600
	END   volatile.Register32 // 0x604
	_     [8]byte
}

// MWU_REGION.START: Description cluster[0]: Start address for region 0
func (o *MWU_REGION_Type) SetSTART(value uint32) {
	volatile.StoreUint32(&o.START.Reg, value)
}
func (o *MWU_REGION_Type) GetSTART() uint32 {
	return volatile.LoadUint32(&o.START.Reg)
}

// MWU_REGION.END: Description cluster[0]: End address of region 0
func (o *MWU_REGION_Type) SetEND(value uint32) {
	volatile.StoreUint32(&o.END.Reg, value)
}
func (o *MWU_REGION_Type) GetEND() uint32 {
	return volatile.LoadUint32(&o.END.Reg)
}

type MWU_PREGION_Type struct {
	START volatile.Register32 // 0x6C0
	END   volatile.Register32 // 0x6C4
	SUBS  volatile.Register32 // 0x6C8
	_     [4]byte
}

// MWU_PREGION.START: Description cluster[0]: Reserved for future use
func (o *MWU_PREGION_Type) SetSTART(value uint32) {
	volatile.StoreUint32(&o.START.Reg, value)
}
func (o *MWU_PREGION_Type) GetSTART() uint32 {
	return volatile.LoadUint32(&o.START.Reg)
}

// MWU_PREGION.END: Description cluster[0]: Reserved for future use
func (o *MWU_PREGION_Type) SetEND(value uint32) {
	volatile.StoreUint32(&o.END.Reg, value)
}
func (o *MWU_PREGION_Type) GetEND() uint32 {
	return volatile.LoadUint32(&o.END.Reg)
}

// MWU_PREGION.SUBS: Description cluster[0]: Subregions of region 0
func (o *MWU_PREGION_Type) SetSUBS_SR0(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x1)|value)
}
func (o *MWU_PREGION_Type) GetSUBS_SR0() uint32 {
	return volatile.LoadUint32(&o.SUBS.Reg) & 0x1
}
func (o *MWU_PREGION_Type) SetSUBS_SR1(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x2)|value<<1)
}
func (o *MWU_PREGION_Type) GetSUBS_SR1() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x2) >> 1
}
func (o *MWU_PREGION_Type) SetSUBS_SR2(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x4)|value<<2)
}
func (o *MWU_PREGION_Type) GetSUBS_SR2() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x4) >> 2
}
func (o *MWU_PREGION_Type) SetSUBS_SR3(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x8)|value<<3)
}
func (o *MWU_PREGION_Type) GetSUBS_SR3() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x8) >> 3
}
func (o *MWU_PREGION_Type) SetSUBS_SR4(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x10)|value<<4)
}
func (o *MWU_PREGION_Type) GetSUBS_SR4() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x10) >> 4
}
func (o *MWU_PREGION_Type) SetSUBS_SR5(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x20)|value<<5)
}
func (o *MWU_PREGION_Type) GetSUBS_SR5() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x20) >> 5
}
func (o *MWU_PREGION_Type) SetSUBS_SR6(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x40)|value<<6)
}
func (o *MWU_PREGION_Type) GetSUBS_SR6() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x40) >> 6
}
func (o *MWU_PREGION_Type) SetSUBS_SR7(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x80)|value<<7)
}
func (o *MWU_PREGION_Type) GetSUBS_SR7() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x80) >> 7
}
func (o *MWU_PREGION_Type) SetSUBS_SR8(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x100)|value<<8)
}
func (o *MWU_PREGION_Type) GetSUBS_SR8() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x100) >> 8
}
func (o *MWU_PREGION_Type) SetSUBS_SR9(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x200)|value<<9)
}
func (o *MWU_PREGION_Type) GetSUBS_SR9() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x200) >> 9
}
func (o *MWU_PREGION_Type) SetSUBS_SR10(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x400)|value<<10)
}
func (o *MWU_PREGION_Type) GetSUBS_SR10() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x400) >> 10
}
func (o *MWU_PREGION_Type) SetSUBS_SR11(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x800)|value<<11)
}
func (o *MWU_PREGION_Type) GetSUBS_SR11() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x800) >> 11
}
func (o *MWU_PREGION_Type) SetSUBS_SR12(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x1000)|value<<12)
}
func (o *MWU_PREGION_Type) GetSUBS_SR12() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x1000) >> 12
}
func (o *MWU_PREGION_Type) SetSUBS_SR13(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x2000)|value<<13)
}
func (o *MWU_PREGION_Type) GetSUBS_SR13() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x2000) >> 13
}
func (o *MWU_PREGION_Type) SetSUBS_SR14(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x4000)|value<<14)
}
func (o *MWU_PREGION_Type) GetSUBS_SR14() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x4000) >> 14
}
func (o *MWU_PREGION_Type) SetSUBS_SR15(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x8000)|value<<15)
}
func (o *MWU_PREGION_Type) GetSUBS_SR15() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x8000) >> 15
}
func (o *MWU_PREGION_Type) SetSUBS_SR16(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x10000)|value<<16)
}
func (o *MWU_PREGION_Type) GetSUBS_SR16() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x10000) >> 16
}
func (o *MWU_PREGION_Type) SetSUBS_SR17(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x20000)|value<<17)
}
func (o *MWU_PREGION_Type) GetSUBS_SR17() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x20000) >> 17
}
func (o *MWU_PREGION_Type) SetSUBS_SR18(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x40000)|value<<18)
}
func (o *MWU_PREGION_Type) GetSUBS_SR18() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x40000) >> 18
}
func (o *MWU_PREGION_Type) SetSUBS_SR19(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x80000)|value<<19)
}
func (o *MWU_PREGION_Type) GetSUBS_SR19() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x80000) >> 19
}
func (o *MWU_PREGION_Type) SetSUBS_SR20(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x100000)|value<<20)
}
func (o *MWU_PREGION_Type) GetSUBS_SR20() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x100000) >> 20
}
func (o *MWU_PREGION_Type) SetSUBS_SR21(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x200000)|value<<21)
}
func (o *MWU_PREGION_Type) GetSUBS_SR21() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x200000) >> 21
}
func (o *MWU_PREGION_Type) SetSUBS_SR22(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x400000)|value<<22)
}
func (o *MWU_PREGION_Type) GetSUBS_SR22() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x400000) >> 22
}
func (o *MWU_PREGION_Type) SetSUBS_SR23(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x800000)|value<<23)
}
func (o *MWU_PREGION_Type) GetSUBS_SR23() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x800000) >> 23
}
func (o *MWU_PREGION_Type) SetSUBS_SR24(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x1000000)|value<<24)
}
func (o *MWU_PREGION_Type) GetSUBS_SR24() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x1000000) >> 24
}
func (o *MWU_PREGION_Type) SetSUBS_SR25(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x2000000)|value<<25)
}
func (o *MWU_PREGION_Type) GetSUBS_SR25() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x2000000) >> 25
}
func (o *MWU_PREGION_Type) SetSUBS_SR26(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x4000000)|value<<26)
}
func (o *MWU_PREGION_Type) GetSUBS_SR26() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x4000000) >> 26
}
func (o *MWU_PREGION_Type) SetSUBS_SR27(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x8000000)|value<<27)
}
func (o *MWU_PREGION_Type) GetSUBS_SR27() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x8000000) >> 27
}
func (o *MWU_PREGION_Type) SetSUBS_SR28(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x10000000)|value<<28)
}
func (o *MWU_PREGION_Type) GetSUBS_SR28() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x10000000) >> 28
}
func (o *MWU_PREGION_Type) SetSUBS_SR29(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x20000000)|value<<29)
}
func (o *MWU_PREGION_Type) GetSUBS_SR29() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x20000000) >> 29
}
func (o *MWU_PREGION_Type) SetSUBS_SR30(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x40000000)|value<<30)
}
func (o *MWU_PREGION_Type) GetSUBS_SR30() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x40000000) >> 30
}
func (o *MWU_PREGION_Type) SetSUBS_SR31(value uint32) {
	volatile.StoreUint32(&o.SUBS.Reg, volatile.LoadUint32(&o.SUBS.Reg)&^(0x80000000)|value<<31)
}
func (o *MWU_PREGION_Type) GetSUBS_SR31() uint32 {
	return (volatile.LoadUint32(&o.SUBS.Reg) & 0x80000000) >> 31
}

// Inter-IC Sound
type I2S_Type struct {
	TASKS_START     volatile.Register32 // 0x0
	TASKS_STOP      volatile.Register32 // 0x4
	_               [252]byte
	EVENTS_RXPTRUPD volatile.Register32 // 0x104
	EVENTS_STOPPED  volatile.Register32 // 0x108
	_               [8]byte
	EVENTS_TXPTRUPD volatile.Register32 // 0x114
	_               [488]byte
	INTEN           volatile.Register32 // 0x300
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [500]byte
	ENABLE          volatile.Register32 // 0x500
	CONFIG          I2S_CONFIG_Type     // 0x504
	_               [12]byte
	RXD             I2S_RXD_Type // 0x538
	_               [4]byte
	TXD             I2S_TXD_Type // 0x540
	_               [12]byte
	RXTXD           I2S_RXTXD_Type // 0x550
	_               [12]byte
	PSEL            I2S_PSEL_Type // 0x560
}

// I2S.INTEN: Enable or disable interrupt
func (o *I2S_Type) SetINTEN_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTEN_RXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINTEN_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTEN_TXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}

// I2S.INTENSET: Enable interrupt
func (o *I2S_Type) SetINTENSET_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTENSET_RXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINTENSET_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTENSET_TXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}

// I2S.INTENCLR: Disable interrupt
func (o *I2S_Type) SetINTENCLR_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTENCLR_RXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINTENCLR_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTENCLR_TXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}

// I2S.ENABLE: Enable I2S module.
func (o *I2S_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

type I2S_CONFIG_Type struct {
	MODE     volatile.Register32 // 0x504
	RXEN     volatile.Register32 // 0x508
	TXEN     volatile.Register32 // 0x50C
	MCKEN    volatile.Register32 // 0x510
	MCKFREQ  volatile.Register32 // 0x514
	RATIO    volatile.Register32 // 0x518
	SWIDTH   volatile.Register32 // 0x51C
	ALIGN    volatile.Register32 // 0x520
	FORMAT   volatile.Register32 // 0x524
	CHANNELS volatile.Register32 // 0x528
}

// I2S_CONFIG.MODE: I2S mode.
func (o *I2S_CONFIG_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}

// I2S_CONFIG.RXEN: Reception (RX) enable.
func (o *I2S_CONFIG_Type) SetRXEN(value uint32) {
	volatile.StoreUint32(&o.RXEN.Reg, volatile.LoadUint32(&o.RXEN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetRXEN() uint32 {
	return volatile.LoadUint32(&o.RXEN.Reg) & 0x1
}

// I2S_CONFIG.TXEN: Transmission (TX) enable.
func (o *I2S_CONFIG_Type) SetTXEN(value uint32) {
	volatile.StoreUint32(&o.TXEN.Reg, volatile.LoadUint32(&o.TXEN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetTXEN() uint32 {
	return volatile.LoadUint32(&o.TXEN.Reg) & 0x1
}

// I2S_CONFIG.MCKEN: Master clock generator enable.
func (o *I2S_CONFIG_Type) SetMCKEN(value uint32) {
	volatile.StoreUint32(&o.MCKEN.Reg, volatile.LoadUint32(&o.MCKEN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetMCKEN() uint32 {
	return volatile.LoadUint32(&o.MCKEN.Reg) & 0x1
}

// I2S_CONFIG.MCKFREQ: Master clock generator frequency.
func (o *I2S_CONFIG_Type) SetMCKFREQ(value uint32) {
	volatile.StoreUint32(&o.MCKFREQ.Reg, value)
}
func (o *I2S_CONFIG_Type) GetMCKFREQ() uint32 {
	return volatile.LoadUint32(&o.MCKFREQ.Reg)
}

// I2S_CONFIG.RATIO: MCK / LRCK ratio.
func (o *I2S_CONFIG_Type) SetRATIO(value uint32) {
	volatile.StoreUint32(&o.RATIO.Reg, volatile.LoadUint32(&o.RATIO.Reg)&^(0xf)|value)
}
func (o *I2S_CONFIG_Type) GetRATIO() uint32 {
	return volatile.LoadUint32(&o.RATIO.Reg) & 0xf
}

// I2S_CONFIG.SWIDTH: Sample width.
func (o *I2S_CONFIG_Type) SetSWIDTH(value uint32) {
	volatile.StoreUint32(&o.SWIDTH.Reg, volatile.LoadUint32(&o.SWIDTH.Reg)&^(0x3)|value)
}
func (o *I2S_CONFIG_Type) GetSWIDTH() uint32 {
	return volatile.LoadUint32(&o.SWIDTH.Reg) & 0x3
}

// I2S_CONFIG.ALIGN: Alignment of sample within a frame.
func (o *I2S_CONFIG_Type) SetALIGN(value uint32) {
	volatile.StoreUint32(&o.ALIGN.Reg, volatile.LoadUint32(&o.ALIGN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetALIGN() uint32 {
	return volatile.LoadUint32(&o.ALIGN.Reg) & 0x1
}

// I2S_CONFIG.FORMAT: Frame format.
func (o *I2S_CONFIG_Type) SetFORMAT(value uint32) {
	volatile.StoreUint32(&o.FORMAT.Reg, volatile.LoadUint32(&o.FORMAT.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetFORMAT() uint32 {
	return volatile.LoadUint32(&o.FORMAT.Reg) & 0x1
}

// I2S_CONFIG.CHANNELS: Enable channels.
func (o *I2S_CONFIG_Type) SetCHANNELS(value uint32) {
	volatile.StoreUint32(&o.CHANNELS.Reg, volatile.LoadUint32(&o.CHANNELS.Reg)&^(0x3)|value)
}
func (o *I2S_CONFIG_Type) GetCHANNELS() uint32 {
	return volatile.LoadUint32(&o.CHANNELS.Reg) & 0x3
}

type I2S_RXD_Type struct {
	PTR volatile.Register32 // 0x538
}

// I2S_RXD.PTR: Receive buffer RAM start address.
func (o *I2S_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *I2S_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

type I2S_TXD_Type struct {
	PTR volatile.Register32 // 0x540
}

// I2S_TXD.PTR: Transmit buffer RAM start address.
func (o *I2S_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *I2S_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

type I2S_RXTXD_Type struct {
	MAXCNT volatile.Register32 // 0x550
}

// I2S_RXTXD.MAXCNT: Size of RXD and TXD buffers.
func (o *I2S_RXTXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3fff)|value)
}
func (o *I2S_RXTXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3fff
}

type I2S_PSEL_Type struct {
	MCK   volatile.Register32 // 0x560
	SCK   volatile.Register32 // 0x564
	LRCK  volatile.Register32 // 0x568
	SDIN  volatile.Register32 // 0x56C
	SDOUT volatile.Register32 // 0x570
}

// I2S_PSEL.MCK: Pin select for MCK signal.
func (o *I2S_PSEL_Type) SetMCK_PIN(value uint32) {
	volatile.StoreUint32(&o.MCK.Reg, volatile.LoadUint32(&o.MCK.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetMCK_PIN() uint32 {
	return volatile.LoadUint32(&o.MCK.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetMCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MCK.Reg, volatile.LoadUint32(&o.MCK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetMCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MCK.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.SCK: Pin select for SCK signal.
func (o *I2S_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.LRCK: Pin select for LRCK signal.
func (o *I2S_PSEL_Type) SetLRCK_PIN(value uint32) {
	volatile.StoreUint32(&o.LRCK.Reg, volatile.LoadUint32(&o.LRCK.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetLRCK_PIN() uint32 {
	return volatile.LoadUint32(&o.LRCK.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetLRCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.LRCK.Reg, volatile.LoadUint32(&o.LRCK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetLRCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.LRCK.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.SDIN: Pin select for SDIN signal.
func (o *I2S_PSEL_Type) SetSDIN_PIN(value uint32) {
	volatile.StoreUint32(&o.SDIN.Reg, volatile.LoadUint32(&o.SDIN.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetSDIN_PIN() uint32 {
	return volatile.LoadUint32(&o.SDIN.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetSDIN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDIN.Reg, volatile.LoadUint32(&o.SDIN.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetSDIN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDIN.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.SDOUT: Pin select for SDOUT signal.
func (o *I2S_PSEL_Type) SetSDOUT_PIN(value uint32) {
	volatile.StoreUint32(&o.SDOUT.Reg, volatile.LoadUint32(&o.SDOUT.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetSDOUT_PIN() uint32 {
	return volatile.LoadUint32(&o.SDOUT.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetSDOUT_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDOUT.Reg, volatile.LoadUint32(&o.SDOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetSDOUT_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDOUT.Reg) & 0x80000000) >> 31
}

// FPU
type FPU_Type struct {
	UNUSED volatile.Register32 // 0x0
}

// GPIO Port 1
type GPIO_Type struct {
	_          [1284]byte
	OUT        volatile.Register32 // 0x504
	OUTSET     volatile.Register32 // 0x508
	OUTCLR     volatile.Register32 // 0x50C
	IN         volatile.Register32 // 0x510
	DIR        volatile.Register32 // 0x514
	DIRSET     volatile.Register32 // 0x518
	DIRCLR     volatile.Register32 // 0x51C
	LATCH      volatile.Register32 // 0x520
	DETECTMODE volatile.Register32 // 0x524
	_          [472]byte
	PIN_CNF    [32]volatile.Register32 // 0x700
}

// GPIO.OUT: Write GPIO port
func (o *GPIO_Type) SetOUT_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUT_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg) & 0x1
}
func (o *GPIO_Type) SetOUT_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUT_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUT_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUT_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUT_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUT_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUT_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUT_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUT_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUT_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUT_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUT_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUT_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUT_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUT_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUT_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUT_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUT_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUT_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUT_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUT_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUT_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUT_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUT_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUT_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUT_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUT_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUT_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUT_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUT_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUT_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUT_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUT_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUT_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUT_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUT_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUT_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUT_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUT_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUT_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUT_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUT_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUT_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUT_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUT_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUT_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUT_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUT_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUT_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUT_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUT_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUT_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUT_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUT_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUT_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUT_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUT_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUT_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUT_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUT_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUT_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUT_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80000000) >> 31
}

// GPIO.OUTSET: Set individual bits in GPIO port
func (o *GPIO_Type) SetOUTSET_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTSET_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUTSET.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTSET_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTSET_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTSET_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTSET_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTSET_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTSET_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTSET_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTSET_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTSET_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTSET_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTSET_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTSET_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTSET_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTSET_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUTSET_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUTSET_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUTSET_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUTSET_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUTSET_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUTSET_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUTSET_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUTSET_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUTSET_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUTSET_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUTSET_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUTSET_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUTSET_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUTSET_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUTSET_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUTSET_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUTSET_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUTSET_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUTSET_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUTSET_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUTSET_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUTSET_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUTSET_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUTSET_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUTSET_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUTSET_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUTSET_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUTSET_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUTSET_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUTSET_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUTSET_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUTSET_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUTSET_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUTSET_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUTSET_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUTSET_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUTSET_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUTSET_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUTSET_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUTSET_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUTSET_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUTSET_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUTSET_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUTSET_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUTSET_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUTSET_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUTSET_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUTSET_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80000000) >> 31
}

// GPIO.OUTCLR: Clear individual bits in GPIO port
func (o *GPIO_Type) SetOUTCLR_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTCLR_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTCLR_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTCLR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTCLR_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTCLR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTCLR_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTCLR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTCLR_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTCLR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTCLR_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTCLR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTCLR_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTCLR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTCLR_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTCLR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUTCLR_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUTCLR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUTCLR_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUTCLR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUTCLR_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUTCLR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUTCLR_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUTCLR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUTCLR_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUTCLR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUTCLR_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUTCLR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUTCLR_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUTCLR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUTCLR_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUTCLR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUTCLR_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUTCLR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUTCLR_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUTCLR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUTCLR_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUTCLR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUTCLR_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUTCLR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUTCLR_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUTCLR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUTCLR_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUTCLR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUTCLR_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUTCLR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUTCLR_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUTCLR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUTCLR_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUTCLR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUTCLR_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUTCLR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUTCLR_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUTCLR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUTCLR_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUTCLR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUTCLR_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUTCLR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUTCLR_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUTCLR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUTCLR_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUTCLR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUTCLR_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUTCLR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80000000) >> 31
}

// GPIO.IN: Read GPIO port
func (o *GPIO_Type) SetIN_PIN0(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIN_PIN0() uint32 {
	return volatile.LoadUint32(&o.IN.Reg) & 0x1
}
func (o *GPIO_Type) SetIN_PIN1(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIN_PIN1() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIN_PIN2(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIN_PIN2() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIN_PIN3(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIN_PIN3() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIN_PIN4(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIN_PIN4() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIN_PIN5(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIN_PIN5() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIN_PIN6(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIN_PIN6() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIN_PIN7(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIN_PIN7() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIN_PIN8(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIN_PIN8() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIN_PIN9(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIN_PIN9() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIN_PIN10(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIN_PIN10() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIN_PIN11(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIN_PIN11() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIN_PIN12(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIN_PIN12() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIN_PIN13(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIN_PIN13() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIN_PIN14(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIN_PIN14() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIN_PIN15(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIN_PIN15() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIN_PIN16(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetIN_PIN16() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetIN_PIN17(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetIN_PIN17() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetIN_PIN18(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetIN_PIN18() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetIN_PIN19(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetIN_PIN19() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetIN_PIN20(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetIN_PIN20() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetIN_PIN21(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetIN_PIN21() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetIN_PIN22(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetIN_PIN22() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetIN_PIN23(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetIN_PIN23() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetIN_PIN24(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetIN_PIN24() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetIN_PIN25(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetIN_PIN25() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetIN_PIN26(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetIN_PIN26() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetIN_PIN27(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetIN_PIN27() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetIN_PIN28(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetIN_PIN28() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetIN_PIN29(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetIN_PIN29() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetIN_PIN30(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetIN_PIN30() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetIN_PIN31(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetIN_PIN31() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80000000) >> 31
}

// GPIO.DIR: Direction of GPIO pins
func (o *GPIO_Type) SetDIR_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80000000) >> 31
}

// GPIO.DIRSET: DIR set register
func (o *GPIO_Type) SetDIRSET_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIRSET_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIRSET.Reg) & 0x1
}
func (o *GPIO_Type) SetDIRSET_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIRSET_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIRSET_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIRSET_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIRSET_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIRSET_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIRSET_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIRSET_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIRSET_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIRSET_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIRSET_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIRSET_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIRSET_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIRSET_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIRSET_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIRSET_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIRSET_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIRSET_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIRSET_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIRSET_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIRSET_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIRSET_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIRSET_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIRSET_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIRSET_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIRSET_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIRSET_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIRSET_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIRSET_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIRSET_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIRSET_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIRSET_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIRSET_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIRSET_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIRSET_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIRSET_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIRSET_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIRSET_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIRSET_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIRSET_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIRSET_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIRSET_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIRSET_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIRSET_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIRSET_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIRSET_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIRSET_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIRSET_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIRSET_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIRSET_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIRSET_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIRSET_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIRSET_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIRSET_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIRSET_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIRSET_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIRSET_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIRSET_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIRSET_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIRSET_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIRSET_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIRSET_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80000000) >> 31
}

// GPIO.DIRCLR: DIR clear register
func (o *GPIO_Type) SetDIRCLR_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIRCLR_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIRCLR_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIRCLR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIRCLR_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIRCLR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIRCLR_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIRCLR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIRCLR_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIRCLR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIRCLR_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIRCLR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIRCLR_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIRCLR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIRCLR_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIRCLR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIRCLR_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIRCLR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIRCLR_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIRCLR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIRCLR_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIRCLR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIRCLR_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIRCLR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIRCLR_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIRCLR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIRCLR_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIRCLR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIRCLR_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIRCLR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIRCLR_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIRCLR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIRCLR_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIRCLR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIRCLR_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIRCLR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIRCLR_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIRCLR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIRCLR_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIRCLR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIRCLR_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIRCLR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIRCLR_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIRCLR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIRCLR_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIRCLR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIRCLR_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIRCLR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIRCLR_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIRCLR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIRCLR_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIRCLR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIRCLR_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIRCLR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIRCLR_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIRCLR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIRCLR_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIRCLR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIRCLR_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIRCLR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIRCLR_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIRCLR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIRCLR_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIRCLR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80000000) >> 31
}

// GPIO.LATCH: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
func (o *GPIO_Type) SetLATCH_PIN0(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLATCH_PIN0() uint32 {
	return volatile.LoadUint32(&o.LATCH.Reg) & 0x1
}
func (o *GPIO_Type) SetLATCH_PIN1(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLATCH_PIN1() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLATCH_PIN2(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLATCH_PIN2() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLATCH_PIN3(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLATCH_PIN3() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLATCH_PIN4(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLATCH_PIN4() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLATCH_PIN5(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLATCH_PIN5() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLATCH_PIN6(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLATCH_PIN6() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLATCH_PIN7(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLATCH_PIN7() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLATCH_PIN8(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLATCH_PIN8() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLATCH_PIN9(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLATCH_PIN9() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLATCH_PIN10(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLATCH_PIN10() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLATCH_PIN11(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLATCH_PIN11() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLATCH_PIN12(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLATCH_PIN12() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLATCH_PIN13(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLATCH_PIN13() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLATCH_PIN14(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLATCH_PIN14() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLATCH_PIN15(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLATCH_PIN15() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLATCH_PIN16(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLATCH_PIN16() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLATCH_PIN17(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetLATCH_PIN17() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetLATCH_PIN18(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetLATCH_PIN18() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetLATCH_PIN19(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetLATCH_PIN19() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetLATCH_PIN20(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetLATCH_PIN20() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetLATCH_PIN21(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetLATCH_PIN21() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetLATCH_PIN22(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetLATCH_PIN22() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetLATCH_PIN23(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetLATCH_PIN23() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetLATCH_PIN24(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetLATCH_PIN24() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetLATCH_PIN25(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetLATCH_PIN25() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetLATCH_PIN26(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetLATCH_PIN26() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetLATCH_PIN27(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetLATCH_PIN27() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetLATCH_PIN28(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetLATCH_PIN28() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetLATCH_PIN29(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetLATCH_PIN29() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetLATCH_PIN30(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetLATCH_PIN30() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetLATCH_PIN31(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetLATCH_PIN31() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80000000) >> 31
}

// GPIO.DETECTMODE: Select between default DETECT signal behaviour and LDETECT mode
func (o *GPIO_Type) SetDETECTMODE(value uint32) {
	volatile.StoreUint32(&o.DETECTMODE.Reg, volatile.LoadUint32(&o.DETECTMODE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDETECTMODE() uint32 {
	return volatile.LoadUint32(&o.DETECTMODE.Reg) & 0x1
}

// GPIO.PIN_CNF: Description collection[0]: Configuration of GPIO pins
func (o *GPIO_Type) SetPIN_CNF_DIR(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN_CNF_DIR(idx int) uint32 {
	return volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x1
}
func (o *GPIO_Type) SetPIN_CNF_INPUT(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN_CNF_INPUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN_CNF_PULL(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPIN_CNF_PULL(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPIN_CNF_DRIVE(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x700)|value<<8)
}
func (o *GPIO_Type) GetPIN_CNF_DRIVE(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x700) >> 8
}
func (o *GPIO_Type) SetPIN_CNF_SENSE(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPIN_CNF_SENSE(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x30000) >> 16
}

// Constants for FICR: Factory Information Configuration Registers
const (
	// CODEPAGESIZE: Code memory page size
	// Position of CODEPAGESIZE field.
	FICR_CODEPAGESIZE_CODEPAGESIZE_Pos = 0x0
	// Bit mask of CODEPAGESIZE field.
	FICR_CODEPAGESIZE_CODEPAGESIZE_Msk = 0xffffffff

	// CODESIZE: Code memory size
	// Position of CODESIZE field.
	FICR_CODESIZE_CODESIZE_Pos = 0x0
	// Bit mask of CODESIZE field.
	FICR_CODESIZE_CODESIZE_Msk = 0xffffffff

	// DEVICEID: Description collection[0]: Device identifier
	// Position of DEVICEID field.
	FICR_DEVICEID_DEVICEID_Pos = 0x0
	// Bit mask of DEVICEID field.
	FICR_DEVICEID_DEVICEID_Msk = 0xffffffff

	// ER: Description collection[0]: Encryption Root, word 0
	// Position of ER field.
	FICR_ER_ER_Pos = 0x0
	// Bit mask of ER field.
	FICR_ER_ER_Msk = 0xffffffff

	// IR: Description collection[0]: Identity Root, word 0
	// Position of IR field.
	FICR_IR_IR_Pos = 0x0
	// Bit mask of IR field.
	FICR_IR_IR_Msk = 0xffffffff

	// DEVICEADDRTYPE: Device address type
	// Position of DEVICEADDRTYPE field.
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos = 0x0
	// Bit mask of DEVICEADDRTYPE field.
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk = 0x1
	// Bit DEVICEADDRTYPE.
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE = 0x1
	// Public address
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public = 0x0
	// Random address
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random = 0x1

	// DEVICEADDR: Description collection[0]: Device address 0
	// Position of DEVICEADDR field.
	FICR_DEVICEADDR_DEVICEADDR_Pos = 0x0
	// Bit mask of DEVICEADDR field.
	FICR_DEVICEADDR_DEVICEADDR_Msk = 0xffffffff

	// INFO.PART: Part code
	// Position of PART field.
	FICR_INFO_PART_PART_Pos = 0x0
	// Bit mask of PART field.
	FICR_INFO_PART_PART_Msk = 0xffffffff
	// nRF52832
	FICR_INFO_PART_PART_N52832 = 0x52832
	// Unspecified
	FICR_INFO_PART_PART_Unspecified = 0xffffffff

	// INFO.VARIANT: Part Variant, Hardware version and Production configuration
	// Position of VARIANT field.
	FICR_INFO_VARIANT_VARIANT_Pos = 0x0
	// Bit mask of VARIANT field.
	FICR_INFO_VARIANT_VARIANT_Msk = 0xffffffff
	// AAAA
	FICR_INFO_VARIANT_VARIANT_AAAA = 0x41414141
	// AAAB
	FICR_INFO_VARIANT_VARIANT_AAAB = 0x41414142
	// AABA
	FICR_INFO_VARIANT_VARIANT_AABA = 0x41414241
	// AABB
	FICR_INFO_VARIANT_VARIANT_AABB = 0x41414242
	// AAB0
	FICR_INFO_VARIANT_VARIANT_AAB0 = 0x41414230
	// AAE0
	FICR_INFO_VARIANT_VARIANT_AAE0 = 0x41414530
	// Unspecified
	FICR_INFO_VARIANT_VARIANT_Unspecified = 0xffffffff

	// INFO.PACKAGE: Package option
	// Position of PACKAGE field.
	FICR_INFO_PACKAGE_PACKAGE_Pos = 0x0
	// Bit mask of PACKAGE field.
	FICR_INFO_PACKAGE_PACKAGE_Msk = 0xffffffff
	// QFxx - 48-pin QFN
	FICR_INFO_PACKAGE_PACKAGE_QF = 0x2000
	// CHxx - 7x8 WLCSP 56 balls
	FICR_INFO_PACKAGE_PACKAGE_CH = 0x2001
	// CIxx - 7x8 WLCSP 56 balls
	FICR_INFO_PACKAGE_PACKAGE_CI = 0x2002
	// CKxx - 7x8 WLCSP 56 balls with backside coating for light protection
	FICR_INFO_PACKAGE_PACKAGE_CK = 0x2005
	// Unspecified
	FICR_INFO_PACKAGE_PACKAGE_Unspecified = 0xffffffff

	// INFO.RAM: RAM variant
	// Position of RAM field.
	FICR_INFO_RAM_RAM_Pos = 0x0
	// Bit mask of RAM field.
	FICR_INFO_RAM_RAM_Msk = 0xffffffff
	// 16 kByte RAM
	FICR_INFO_RAM_RAM_K16 = 0x10
	// 32 kByte RAM
	FICR_INFO_RAM_RAM_K32 = 0x20
	// 64 kByte RAM
	FICR_INFO_RAM_RAM_K64 = 0x40
	// Unspecified
	FICR_INFO_RAM_RAM_Unspecified = 0xffffffff

	// INFO.FLASH: Flash variant
	// Position of FLASH field.
	FICR_INFO_FLASH_FLASH_Pos = 0x0
	// Bit mask of FLASH field.
	FICR_INFO_FLASH_FLASH_Msk = 0xffffffff
	// 128 kByte FLASH
	FICR_INFO_FLASH_FLASH_K128 = 0x80
	// 256 kByte FLASH
	FICR_INFO_FLASH_FLASH_K256 = 0x100
	// 512 kByte FLASH
	FICR_INFO_FLASH_FLASH_K512 = 0x200
	// Unspecified
	FICR_INFO_FLASH_FLASH_Unspecified = 0xffffffff

	// INFO.UNUSED0: Description collection[0]: Unspecified

	// TEMP.A0: Slope definition A0.
	// Position of A field.
	FICR_TEMP_A0_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A0_A_Msk = 0xfff

	// TEMP.A1: Slope definition A1.
	// Position of A field.
	FICR_TEMP_A1_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A1_A_Msk = 0xfff

	// TEMP.A2: Slope definition A2.
	// Position of A field.
	FICR_TEMP_A2_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A2_A_Msk = 0xfff

	// TEMP.A3: Slope definition A3.
	// Position of A field.
	FICR_TEMP_A3_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A3_A_Msk = 0xfff

	// TEMP.A4: Slope definition A4.
	// Position of A field.
	FICR_TEMP_A4_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A4_A_Msk = 0xfff

	// TEMP.A5: Slope definition A5.
	// Position of A field.
	FICR_TEMP_A5_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A5_A_Msk = 0xfff

	// TEMP.B0: y-intercept B0.
	// Position of B field.
	FICR_TEMP_B0_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B0_B_Msk = 0x3fff

	// TEMP.B1: y-intercept B1.
	// Position of B field.
	FICR_TEMP_B1_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B1_B_Msk = 0x3fff

	// TEMP.B2: y-intercept B2.
	// Position of B field.
	FICR_TEMP_B2_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B2_B_Msk = 0x3fff

	// TEMP.B3: y-intercept B3.
	// Position of B field.
	FICR_TEMP_B3_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B3_B_Msk = 0x3fff

	// TEMP.B4: y-intercept B4.
	// Position of B field.
	FICR_TEMP_B4_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B4_B_Msk = 0x3fff

	// TEMP.B5: y-intercept B5.
	// Position of B field.
	FICR_TEMP_B5_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B5_B_Msk = 0x3fff

	// TEMP.T0: Segment end T0.
	// Position of T field.
	FICR_TEMP_T0_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T0_T_Msk = 0xff

	// TEMP.T1: Segment end T1.
	// Position of T field.
	FICR_TEMP_T1_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T1_T_Msk = 0xff

	// TEMP.T2: Segment end T2.
	// Position of T field.
	FICR_TEMP_T2_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T2_T_Msk = 0xff

	// TEMP.T3: Segment end T3.
	// Position of T field.
	FICR_TEMP_T3_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T3_T_Msk = 0xff

	// TEMP.T4: Segment end T4.
	// Position of T field.
	FICR_TEMP_T4_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T4_T_Msk = 0xff

	// NFC.TAGHEADER0: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of MFGID field.
	FICR_NFC_TAGHEADER0_MFGID_Pos = 0x0
	// Bit mask of MFGID field.
	FICR_NFC_TAGHEADER0_MFGID_Msk = 0xff
	// Position of UD1 field.
	FICR_NFC_TAGHEADER0_UD1_Pos = 0x8
	// Bit mask of UD1 field.
	FICR_NFC_TAGHEADER0_UD1_Msk = 0xff00
	// Position of UD2 field.
	FICR_NFC_TAGHEADER0_UD2_Pos = 0x10
	// Bit mask of UD2 field.
	FICR_NFC_TAGHEADER0_UD2_Msk = 0xff0000
	// Position of UD3 field.
	FICR_NFC_TAGHEADER0_UD3_Pos = 0x18
	// Bit mask of UD3 field.
	FICR_NFC_TAGHEADER0_UD3_Msk = 0xff000000

	// NFC.TAGHEADER1: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of UD4 field.
	FICR_NFC_TAGHEADER1_UD4_Pos = 0x0
	// Bit mask of UD4 field.
	FICR_NFC_TAGHEADER1_UD4_Msk = 0xff
	// Position of UD5 field.
	FICR_NFC_TAGHEADER1_UD5_Pos = 0x8
	// Bit mask of UD5 field.
	FICR_NFC_TAGHEADER1_UD5_Msk = 0xff00
	// Position of UD6 field.
	FICR_NFC_TAGHEADER1_UD6_Pos = 0x10
	// Bit mask of UD6 field.
	FICR_NFC_TAGHEADER1_UD6_Msk = 0xff0000
	// Position of UD7 field.
	FICR_NFC_TAGHEADER1_UD7_Pos = 0x18
	// Bit mask of UD7 field.
	FICR_NFC_TAGHEADER1_UD7_Msk = 0xff000000

	// NFC.TAGHEADER2: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of UD8 field.
	FICR_NFC_TAGHEADER2_UD8_Pos = 0x0
	// Bit mask of UD8 field.
	FICR_NFC_TAGHEADER2_UD8_Msk = 0xff
	// Position of UD9 field.
	FICR_NFC_TAGHEADER2_UD9_Pos = 0x8
	// Bit mask of UD9 field.
	FICR_NFC_TAGHEADER2_UD9_Msk = 0xff00
	// Position of UD10 field.
	FICR_NFC_TAGHEADER2_UD10_Pos = 0x10
	// Bit mask of UD10 field.
	FICR_NFC_TAGHEADER2_UD10_Msk = 0xff0000
	// Position of UD11 field.
	FICR_NFC_TAGHEADER2_UD11_Pos = 0x18
	// Bit mask of UD11 field.
	FICR_NFC_TAGHEADER2_UD11_Msk = 0xff000000

	// NFC.TAGHEADER3: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of UD12 field.
	FICR_NFC_TAGHEADER3_UD12_Pos = 0x0
	// Bit mask of UD12 field.
	FICR_NFC_TAGHEADER3_UD12_Msk = 0xff
	// Position of UD13 field.
	FICR_NFC_TAGHEADER3_UD13_Pos = 0x8
	// Bit mask of UD13 field.
	FICR_NFC_TAGHEADER3_UD13_Msk = 0xff00
	// Position of UD14 field.
	FICR_NFC_TAGHEADER3_UD14_Pos = 0x10
	// Bit mask of UD14 field.
	FICR_NFC_TAGHEADER3_UD14_Msk = 0xff0000
	// Position of UD15 field.
	FICR_NFC_TAGHEADER3_UD15_Pos = 0x18
	// Bit mask of UD15 field.
	FICR_NFC_TAGHEADER3_UD15_Msk = 0xff000000
)

// Constants for UICR: User Information Configuration Registers
const (
	// NRFFW: Description collection[0]: Reserved for Nordic firmware design
	// Position of NRFFW field.
	UICR_NRFFW_NRFFW_Pos = 0x0
	// Bit mask of NRFFW field.
	UICR_NRFFW_NRFFW_Msk = 0xffffffff

	// NRFHW: Description collection[0]: Reserved for Nordic hardware design
	// Position of NRFHW field.
	UICR_NRFHW_NRFHW_Pos = 0x0
	// Bit mask of NRFHW field.
	UICR_NRFHW_NRFHW_Msk = 0xffffffff

	// CUSTOMER: Description collection[0]: Reserved for customer
	// Position of CUSTOMER field.
	UICR_CUSTOMER_CUSTOMER_Pos = 0x0
	// Bit mask of CUSTOMER field.
	UICR_CUSTOMER_CUSTOMER_Msk = 0xffffffff

	// PSELRESET: Description collection[0]: Mapping of the nRESET function (see POWER chapter for details)
	// Position of PIN field.
	UICR_PSELRESET_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UICR_PSELRESET_PIN_Msk = 0x3f
	// Position of CONNECT field.
	UICR_PSELRESET_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UICR_PSELRESET_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UICR_PSELRESET_CONNECT = 0x80000000
	// Disconnect
	UICR_PSELRESET_CONNECT_Disconnected = 0x1
	// Connect
	UICR_PSELRESET_CONNECT_Connected = 0x0

	// APPROTECT: Access Port protection
	// Position of PALL field.
	UICR_APPROTECT_PALL_Pos = 0x0
	// Bit mask of PALL field.
	UICR_APPROTECT_PALL_Msk = 0xff
	// Disable
	UICR_APPROTECT_PALL_Disabled = 0xff
	// Enable
	UICR_APPROTECT_PALL_Enabled = 0x0

	// NFCPINS: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
	// Position of PROTECT field.
	UICR_NFCPINS_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	UICR_NFCPINS_PROTECT_Msk = 0x1
	// Bit PROTECT.
	UICR_NFCPINS_PROTECT = 0x1
	// Operation as GPIO pins. Same protection as normal GPIO pins
	UICR_NFCPINS_PROTECT_Disabled = 0x0
	// Operation as NFC antenna pins. Configures the protection for NFC operation
	UICR_NFCPINS_PROTECT_NFC = 0x1
)

// Constants for BPROT: Block Protect
const (
	// CONFIG0: Block protect configuration register 0
	// Position of REGION0 field.
	BPROT_CONFIG0_REGION0_Pos = 0x0
	// Bit mask of REGION0 field.
	BPROT_CONFIG0_REGION0_Msk = 0x1
	// Bit REGION0.
	BPROT_CONFIG0_REGION0 = 0x1
	// Protection disabled
	BPROT_CONFIG0_REGION0_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION0_Enabled = 0x1
	// Position of REGION1 field.
	BPROT_CONFIG0_REGION1_Pos = 0x1
	// Bit mask of REGION1 field.
	BPROT_CONFIG0_REGION1_Msk = 0x2
	// Bit REGION1.
	BPROT_CONFIG0_REGION1 = 0x2
	// Protection disabled
	BPROT_CONFIG0_REGION1_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION1_Enabled = 0x1
	// Position of REGION2 field.
	BPROT_CONFIG0_REGION2_Pos = 0x2
	// Bit mask of REGION2 field.
	BPROT_CONFIG0_REGION2_Msk = 0x4
	// Bit REGION2.
	BPROT_CONFIG0_REGION2 = 0x4
	// Protection disabled
	BPROT_CONFIG0_REGION2_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION2_Enabled = 0x1
	// Position of REGION3 field.
	BPROT_CONFIG0_REGION3_Pos = 0x3
	// Bit mask of REGION3 field.
	BPROT_CONFIG0_REGION3_Msk = 0x8
	// Bit REGION3.
	BPROT_CONFIG0_REGION3 = 0x8
	// Protection disabled
	BPROT_CONFIG0_REGION3_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION3_Enabled = 0x1
	// Position of REGION4 field.
	BPROT_CONFIG0_REGION4_Pos = 0x4
	// Bit mask of REGION4 field.
	BPROT_CONFIG0_REGION4_Msk = 0x10
	// Bit REGION4.
	BPROT_CONFIG0_REGION4 = 0x10
	// Protection disabled
	BPROT_CONFIG0_REGION4_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION4_Enabled = 0x1
	// Position of REGION5 field.
	BPROT_CONFIG0_REGION5_Pos = 0x5
	// Bit mask of REGION5 field.
	BPROT_CONFIG0_REGION5_Msk = 0x20
	// Bit REGION5.
	BPROT_CONFIG0_REGION5 = 0x20
	// Protection disabled
	BPROT_CONFIG0_REGION5_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION5_Enabled = 0x1
	// Position of REGION6 field.
	BPROT_CONFIG0_REGION6_Pos = 0x6
	// Bit mask of REGION6 field.
	BPROT_CONFIG0_REGION6_Msk = 0x40
	// Bit REGION6.
	BPROT_CONFIG0_REGION6 = 0x40
	// Protection disabled
	BPROT_CONFIG0_REGION6_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION6_Enabled = 0x1
	// Position of REGION7 field.
	BPROT_CONFIG0_REGION7_Pos = 0x7
	// Bit mask of REGION7 field.
	BPROT_CONFIG0_REGION7_Msk = 0x80
	// Bit REGION7.
	BPROT_CONFIG0_REGION7 = 0x80
	// Protection disabled
	BPROT_CONFIG0_REGION7_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION7_Enabled = 0x1
	// Position of REGION8 field.
	BPROT_CONFIG0_REGION8_Pos = 0x8
	// Bit mask of REGION8 field.
	BPROT_CONFIG0_REGION8_Msk = 0x100
	// Bit REGION8.
	BPROT_CONFIG0_REGION8 = 0x100
	// Protection disabled
	BPROT_CONFIG0_REGION8_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION8_Enabled = 0x1
	// Position of REGION9 field.
	BPROT_CONFIG0_REGION9_Pos = 0x9
	// Bit mask of REGION9 field.
	BPROT_CONFIG0_REGION9_Msk = 0x200
	// Bit REGION9.
	BPROT_CONFIG0_REGION9 = 0x200
	// Protection disabled
	BPROT_CONFIG0_REGION9_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION9_Enabled = 0x1
	// Position of REGION10 field.
	BPROT_CONFIG0_REGION10_Pos = 0xa
	// Bit mask of REGION10 field.
	BPROT_CONFIG0_REGION10_Msk = 0x400
	// Bit REGION10.
	BPROT_CONFIG0_REGION10 = 0x400
	// Protection disabled
	BPROT_CONFIG0_REGION10_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION10_Enabled = 0x1
	// Position of REGION11 field.
	BPROT_CONFIG0_REGION11_Pos = 0xb
	// Bit mask of REGION11 field.
	BPROT_CONFIG0_REGION11_Msk = 0x800
	// Bit REGION11.
	BPROT_CONFIG0_REGION11 = 0x800
	// Protection disabled
	BPROT_CONFIG0_REGION11_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION11_Enabled = 0x1
	// Position of REGION12 field.
	BPROT_CONFIG0_REGION12_Pos = 0xc
	// Bit mask of REGION12 field.
	BPROT_CONFIG0_REGION12_Msk = 0x1000
	// Bit REGION12.
	BPROT_CONFIG0_REGION12 = 0x1000
	// Protection disabled
	BPROT_CONFIG0_REGION12_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION12_Enabled = 0x1
	// Position of REGION13 field.
	BPROT_CONFIG0_REGION13_Pos = 0xd
	// Bit mask of REGION13 field.
	BPROT_CONFIG0_REGION13_Msk = 0x2000
	// Bit REGION13.
	BPROT_CONFIG0_REGION13 = 0x2000
	// Protection disabled
	BPROT_CONFIG0_REGION13_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION13_Enabled = 0x1
	// Position of REGION14 field.
	BPROT_CONFIG0_REGION14_Pos = 0xe
	// Bit mask of REGION14 field.
	BPROT_CONFIG0_REGION14_Msk = 0x4000
	// Bit REGION14.
	BPROT_CONFIG0_REGION14 = 0x4000
	// Protection disabled
	BPROT_CONFIG0_REGION14_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION14_Enabled = 0x1
	// Position of REGION15 field.
	BPROT_CONFIG0_REGION15_Pos = 0xf
	// Bit mask of REGION15 field.
	BPROT_CONFIG0_REGION15_Msk = 0x8000
	// Bit REGION15.
	BPROT_CONFIG0_REGION15 = 0x8000
	// Protection disabled
	BPROT_CONFIG0_REGION15_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION15_Enabled = 0x1
	// Position of REGION16 field.
	BPROT_CONFIG0_REGION16_Pos = 0x10
	// Bit mask of REGION16 field.
	BPROT_CONFIG0_REGION16_Msk = 0x10000
	// Bit REGION16.
	BPROT_CONFIG0_REGION16 = 0x10000
	// Protection disabled
	BPROT_CONFIG0_REGION16_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION16_Enabled = 0x1
	// Position of REGION17 field.
	BPROT_CONFIG0_REGION17_Pos = 0x11
	// Bit mask of REGION17 field.
	BPROT_CONFIG0_REGION17_Msk = 0x20000
	// Bit REGION17.
	BPROT_CONFIG0_REGION17 = 0x20000
	// Protection disabled
	BPROT_CONFIG0_REGION17_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION17_Enabled = 0x1
	// Position of REGION18 field.
	BPROT_CONFIG0_REGION18_Pos = 0x12
	// Bit mask of REGION18 field.
	BPROT_CONFIG0_REGION18_Msk = 0x40000
	// Bit REGION18.
	BPROT_CONFIG0_REGION18 = 0x40000
	// Protection disabled
	BPROT_CONFIG0_REGION18_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION18_Enabled = 0x1
	// Position of REGION19 field.
	BPROT_CONFIG0_REGION19_Pos = 0x13
	// Bit mask of REGION19 field.
	BPROT_CONFIG0_REGION19_Msk = 0x80000
	// Bit REGION19.
	BPROT_CONFIG0_REGION19 = 0x80000
	// Protection disabled
	BPROT_CONFIG0_REGION19_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION19_Enabled = 0x1
	// Position of REGION20 field.
	BPROT_CONFIG0_REGION20_Pos = 0x14
	// Bit mask of REGION20 field.
	BPROT_CONFIG0_REGION20_Msk = 0x100000
	// Bit REGION20.
	BPROT_CONFIG0_REGION20 = 0x100000
	// Protection disabled
	BPROT_CONFIG0_REGION20_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION20_Enabled = 0x1
	// Position of REGION21 field.
	BPROT_CONFIG0_REGION21_Pos = 0x15
	// Bit mask of REGION21 field.
	BPROT_CONFIG0_REGION21_Msk = 0x200000
	// Bit REGION21.
	BPROT_CONFIG0_REGION21 = 0x200000
	// Protection disabled
	BPROT_CONFIG0_REGION21_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION21_Enabled = 0x1
	// Position of REGION22 field.
	BPROT_CONFIG0_REGION22_Pos = 0x16
	// Bit mask of REGION22 field.
	BPROT_CONFIG0_REGION22_Msk = 0x400000
	// Bit REGION22.
	BPROT_CONFIG0_REGION22 = 0x400000
	// Protection disabled
	BPROT_CONFIG0_REGION22_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION22_Enabled = 0x1
	// Position of REGION23 field.
	BPROT_CONFIG0_REGION23_Pos = 0x17
	// Bit mask of REGION23 field.
	BPROT_CONFIG0_REGION23_Msk = 0x800000
	// Bit REGION23.
	BPROT_CONFIG0_REGION23 = 0x800000
	// Protection disabled
	BPROT_CONFIG0_REGION23_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION23_Enabled = 0x1
	// Position of REGION24 field.
	BPROT_CONFIG0_REGION24_Pos = 0x18
	// Bit mask of REGION24 field.
	BPROT_CONFIG0_REGION24_Msk = 0x1000000
	// Bit REGION24.
	BPROT_CONFIG0_REGION24 = 0x1000000
	// Protection disabled
	BPROT_CONFIG0_REGION24_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION24_Enabled = 0x1
	// Position of REGION25 field.
	BPROT_CONFIG0_REGION25_Pos = 0x19
	// Bit mask of REGION25 field.
	BPROT_CONFIG0_REGION25_Msk = 0x2000000
	// Bit REGION25.
	BPROT_CONFIG0_REGION25 = 0x2000000
	// Protection disabled
	BPROT_CONFIG0_REGION25_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION25_Enabled = 0x1
	// Position of REGION26 field.
	BPROT_CONFIG0_REGION26_Pos = 0x1a
	// Bit mask of REGION26 field.
	BPROT_CONFIG0_REGION26_Msk = 0x4000000
	// Bit REGION26.
	BPROT_CONFIG0_REGION26 = 0x4000000
	// Protection disabled
	BPROT_CONFIG0_REGION26_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION26_Enabled = 0x1
	// Position of REGION27 field.
	BPROT_CONFIG0_REGION27_Pos = 0x1b
	// Bit mask of REGION27 field.
	BPROT_CONFIG0_REGION27_Msk = 0x8000000
	// Bit REGION27.
	BPROT_CONFIG0_REGION27 = 0x8000000
	// Protection disabled
	BPROT_CONFIG0_REGION27_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION27_Enabled = 0x1
	// Position of REGION28 field.
	BPROT_CONFIG0_REGION28_Pos = 0x1c
	// Bit mask of REGION28 field.
	BPROT_CONFIG0_REGION28_Msk = 0x10000000
	// Bit REGION28.
	BPROT_CONFIG0_REGION28 = 0x10000000
	// Protection disabled
	BPROT_CONFIG0_REGION28_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION28_Enabled = 0x1
	// Position of REGION29 field.
	BPROT_CONFIG0_REGION29_Pos = 0x1d
	// Bit mask of REGION29 field.
	BPROT_CONFIG0_REGION29_Msk = 0x20000000
	// Bit REGION29.
	BPROT_CONFIG0_REGION29 = 0x20000000
	// Protection disabled
	BPROT_CONFIG0_REGION29_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION29_Enabled = 0x1
	// Position of REGION30 field.
	BPROT_CONFIG0_REGION30_Pos = 0x1e
	// Bit mask of REGION30 field.
	BPROT_CONFIG0_REGION30_Msk = 0x40000000
	// Bit REGION30.
	BPROT_CONFIG0_REGION30 = 0x40000000
	// Protection disabled
	BPROT_CONFIG0_REGION30_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION30_Enabled = 0x1
	// Position of REGION31 field.
	BPROT_CONFIG0_REGION31_Pos = 0x1f
	// Bit mask of REGION31 field.
	BPROT_CONFIG0_REGION31_Msk = 0x80000000
	// Bit REGION31.
	BPROT_CONFIG0_REGION31 = 0x80000000
	// Protection disabled
	BPROT_CONFIG0_REGION31_Disabled = 0x0
	// Protection enable
	BPROT_CONFIG0_REGION31_Enabled = 0x1

	// CONFIG1: Block protect configuration register 1
	// Position of REGION32 field.
	BPROT_CONFIG1_REGION32_Pos = 0x0
	// Bit mask of REGION32 field.
	BPROT_CONFIG1_REGION32_Msk = 0x1
	// Bit REGION32.
	BPROT_CONFIG1_REGION32 = 0x1
	// Protection disabled
	BPROT_CONFIG1_REGION32_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION32_Enabled = 0x1
	// Position of REGION33 field.
	BPROT_CONFIG1_REGION33_Pos = 0x1
	// Bit mask of REGION33 field.
	BPROT_CONFIG1_REGION33_Msk = 0x2
	// Bit REGION33.
	BPROT_CONFIG1_REGION33 = 0x2
	// Protection disabled
	BPROT_CONFIG1_REGION33_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION33_Enabled = 0x1
	// Position of REGION34 field.
	BPROT_CONFIG1_REGION34_Pos = 0x2
	// Bit mask of REGION34 field.
	BPROT_CONFIG1_REGION34_Msk = 0x4
	// Bit REGION34.
	BPROT_CONFIG1_REGION34 = 0x4
	// Protection disabled
	BPROT_CONFIG1_REGION34_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION34_Enabled = 0x1
	// Position of REGION35 field.
	BPROT_CONFIG1_REGION35_Pos = 0x3
	// Bit mask of REGION35 field.
	BPROT_CONFIG1_REGION35_Msk = 0x8
	// Bit REGION35.
	BPROT_CONFIG1_REGION35 = 0x8
	// Protection disabled
	BPROT_CONFIG1_REGION35_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION35_Enabled = 0x1
	// Position of REGION36 field.
	BPROT_CONFIG1_REGION36_Pos = 0x4
	// Bit mask of REGION36 field.
	BPROT_CONFIG1_REGION36_Msk = 0x10
	// Bit REGION36.
	BPROT_CONFIG1_REGION36 = 0x10
	// Protection disabled
	BPROT_CONFIG1_REGION36_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION36_Enabled = 0x1
	// Position of REGION37 field.
	BPROT_CONFIG1_REGION37_Pos = 0x5
	// Bit mask of REGION37 field.
	BPROT_CONFIG1_REGION37_Msk = 0x20
	// Bit REGION37.
	BPROT_CONFIG1_REGION37 = 0x20
	// Protection disabled
	BPROT_CONFIG1_REGION37_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION37_Enabled = 0x1
	// Position of REGION38 field.
	BPROT_CONFIG1_REGION38_Pos = 0x6
	// Bit mask of REGION38 field.
	BPROT_CONFIG1_REGION38_Msk = 0x40
	// Bit REGION38.
	BPROT_CONFIG1_REGION38 = 0x40
	// Protection disabled
	BPROT_CONFIG1_REGION38_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION38_Enabled = 0x1
	// Position of REGION39 field.
	BPROT_CONFIG1_REGION39_Pos = 0x7
	// Bit mask of REGION39 field.
	BPROT_CONFIG1_REGION39_Msk = 0x80
	// Bit REGION39.
	BPROT_CONFIG1_REGION39 = 0x80
	// Protection disabled
	BPROT_CONFIG1_REGION39_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION39_Enabled = 0x1
	// Position of REGION40 field.
	BPROT_CONFIG1_REGION40_Pos = 0x8
	// Bit mask of REGION40 field.
	BPROT_CONFIG1_REGION40_Msk = 0x100
	// Bit REGION40.
	BPROT_CONFIG1_REGION40 = 0x100
	// Protection disabled
	BPROT_CONFIG1_REGION40_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION40_Enabled = 0x1
	// Position of REGION41 field.
	BPROT_CONFIG1_REGION41_Pos = 0x9
	// Bit mask of REGION41 field.
	BPROT_CONFIG1_REGION41_Msk = 0x200
	// Bit REGION41.
	BPROT_CONFIG1_REGION41 = 0x200
	// Protection disabled
	BPROT_CONFIG1_REGION41_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION41_Enabled = 0x1
	// Position of REGION42 field.
	BPROT_CONFIG1_REGION42_Pos = 0xa
	// Bit mask of REGION42 field.
	BPROT_CONFIG1_REGION42_Msk = 0x400
	// Bit REGION42.
	BPROT_CONFIG1_REGION42 = 0x400
	// Protection disabled
	BPROT_CONFIG1_REGION42_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION42_Enabled = 0x1
	// Position of REGION43 field.
	BPROT_CONFIG1_REGION43_Pos = 0xb
	// Bit mask of REGION43 field.
	BPROT_CONFIG1_REGION43_Msk = 0x800
	// Bit REGION43.
	BPROT_CONFIG1_REGION43 = 0x800
	// Protection disabled
	BPROT_CONFIG1_REGION43_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION43_Enabled = 0x1
	// Position of REGION44 field.
	BPROT_CONFIG1_REGION44_Pos = 0xc
	// Bit mask of REGION44 field.
	BPROT_CONFIG1_REGION44_Msk = 0x1000
	// Bit REGION44.
	BPROT_CONFIG1_REGION44 = 0x1000
	// Protection disabled
	BPROT_CONFIG1_REGION44_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION44_Enabled = 0x1
	// Position of REGION45 field.
	BPROT_CONFIG1_REGION45_Pos = 0xd
	// Bit mask of REGION45 field.
	BPROT_CONFIG1_REGION45_Msk = 0x2000
	// Bit REGION45.
	BPROT_CONFIG1_REGION45 = 0x2000
	// Protection disabled
	BPROT_CONFIG1_REGION45_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION45_Enabled = 0x1
	// Position of REGION46 field.
	BPROT_CONFIG1_REGION46_Pos = 0xe
	// Bit mask of REGION46 field.
	BPROT_CONFIG1_REGION46_Msk = 0x4000
	// Bit REGION46.
	BPROT_CONFIG1_REGION46 = 0x4000
	// Protection disabled
	BPROT_CONFIG1_REGION46_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION46_Enabled = 0x1
	// Position of REGION47 field.
	BPROT_CONFIG1_REGION47_Pos = 0xf
	// Bit mask of REGION47 field.
	BPROT_CONFIG1_REGION47_Msk = 0x8000
	// Bit REGION47.
	BPROT_CONFIG1_REGION47 = 0x8000
	// Protection disabled
	BPROT_CONFIG1_REGION47_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION47_Enabled = 0x1
	// Position of REGION48 field.
	BPROT_CONFIG1_REGION48_Pos = 0x10
	// Bit mask of REGION48 field.
	BPROT_CONFIG1_REGION48_Msk = 0x10000
	// Bit REGION48.
	BPROT_CONFIG1_REGION48 = 0x10000
	// Protection disabled
	BPROT_CONFIG1_REGION48_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION48_Enabled = 0x1
	// Position of REGION49 field.
	BPROT_CONFIG1_REGION49_Pos = 0x11
	// Bit mask of REGION49 field.
	BPROT_CONFIG1_REGION49_Msk = 0x20000
	// Bit REGION49.
	BPROT_CONFIG1_REGION49 = 0x20000
	// Protection disabled
	BPROT_CONFIG1_REGION49_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION49_Enabled = 0x1
	// Position of REGION50 field.
	BPROT_CONFIG1_REGION50_Pos = 0x12
	// Bit mask of REGION50 field.
	BPROT_CONFIG1_REGION50_Msk = 0x40000
	// Bit REGION50.
	BPROT_CONFIG1_REGION50 = 0x40000
	// Protection disabled
	BPROT_CONFIG1_REGION50_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION50_Enabled = 0x1
	// Position of REGION51 field.
	BPROT_CONFIG1_REGION51_Pos = 0x13
	// Bit mask of REGION51 field.
	BPROT_CONFIG1_REGION51_Msk = 0x80000
	// Bit REGION51.
	BPROT_CONFIG1_REGION51 = 0x80000
	// Protection disabled
	BPROT_CONFIG1_REGION51_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION51_Enabled = 0x1
	// Position of REGION52 field.
	BPROT_CONFIG1_REGION52_Pos = 0x14
	// Bit mask of REGION52 field.
	BPROT_CONFIG1_REGION52_Msk = 0x100000
	// Bit REGION52.
	BPROT_CONFIG1_REGION52 = 0x100000
	// Protection disabled
	BPROT_CONFIG1_REGION52_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION52_Enabled = 0x1
	// Position of REGION53 field.
	BPROT_CONFIG1_REGION53_Pos = 0x15
	// Bit mask of REGION53 field.
	BPROT_CONFIG1_REGION53_Msk = 0x200000
	// Bit REGION53.
	BPROT_CONFIG1_REGION53 = 0x200000
	// Protection disabled
	BPROT_CONFIG1_REGION53_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION53_Enabled = 0x1
	// Position of REGION54 field.
	BPROT_CONFIG1_REGION54_Pos = 0x16
	// Bit mask of REGION54 field.
	BPROT_CONFIG1_REGION54_Msk = 0x400000
	// Bit REGION54.
	BPROT_CONFIG1_REGION54 = 0x400000
	// Protection disabled
	BPROT_CONFIG1_REGION54_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION54_Enabled = 0x1
	// Position of REGION55 field.
	BPROT_CONFIG1_REGION55_Pos = 0x17
	// Bit mask of REGION55 field.
	BPROT_CONFIG1_REGION55_Msk = 0x800000
	// Bit REGION55.
	BPROT_CONFIG1_REGION55 = 0x800000
	// Protection disabled
	BPROT_CONFIG1_REGION55_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION55_Enabled = 0x1
	// Position of REGION56 field.
	BPROT_CONFIG1_REGION56_Pos = 0x18
	// Bit mask of REGION56 field.
	BPROT_CONFIG1_REGION56_Msk = 0x1000000
	// Bit REGION56.
	BPROT_CONFIG1_REGION56 = 0x1000000
	// Protection disabled
	BPROT_CONFIG1_REGION56_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION56_Enabled = 0x1
	// Position of REGION57 field.
	BPROT_CONFIG1_REGION57_Pos = 0x19
	// Bit mask of REGION57 field.
	BPROT_CONFIG1_REGION57_Msk = 0x2000000
	// Bit REGION57.
	BPROT_CONFIG1_REGION57 = 0x2000000
	// Protection disabled
	BPROT_CONFIG1_REGION57_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION57_Enabled = 0x1
	// Position of REGION58 field.
	BPROT_CONFIG1_REGION58_Pos = 0x1a
	// Bit mask of REGION58 field.
	BPROT_CONFIG1_REGION58_Msk = 0x4000000
	// Bit REGION58.
	BPROT_CONFIG1_REGION58 = 0x4000000
	// Protection disabled
	BPROT_CONFIG1_REGION58_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION58_Enabled = 0x1
	// Position of REGION59 field.
	BPROT_CONFIG1_REGION59_Pos = 0x1b
	// Bit mask of REGION59 field.
	BPROT_CONFIG1_REGION59_Msk = 0x8000000
	// Bit REGION59.
	BPROT_CONFIG1_REGION59 = 0x8000000
	// Protection disabled
	BPROT_CONFIG1_REGION59_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION59_Enabled = 0x1
	// Position of REGION60 field.
	BPROT_CONFIG1_REGION60_Pos = 0x1c
	// Bit mask of REGION60 field.
	BPROT_CONFIG1_REGION60_Msk = 0x10000000
	// Bit REGION60.
	BPROT_CONFIG1_REGION60 = 0x10000000
	// Protection disabled
	BPROT_CONFIG1_REGION60_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION60_Enabled = 0x1
	// Position of REGION61 field.
	BPROT_CONFIG1_REGION61_Pos = 0x1d
	// Bit mask of REGION61 field.
	BPROT_CONFIG1_REGION61_Msk = 0x20000000
	// Bit REGION61.
	BPROT_CONFIG1_REGION61 = 0x20000000
	// Protection disabled
	BPROT_CONFIG1_REGION61_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION61_Enabled = 0x1
	// Position of REGION62 field.
	BPROT_CONFIG1_REGION62_Pos = 0x1e
	// Bit mask of REGION62 field.
	BPROT_CONFIG1_REGION62_Msk = 0x40000000
	// Bit REGION62.
	BPROT_CONFIG1_REGION62 = 0x40000000
	// Protection disabled
	BPROT_CONFIG1_REGION62_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION62_Enabled = 0x1
	// Position of REGION63 field.
	BPROT_CONFIG1_REGION63_Pos = 0x1f
	// Bit mask of REGION63 field.
	BPROT_CONFIG1_REGION63_Msk = 0x80000000
	// Bit REGION63.
	BPROT_CONFIG1_REGION63 = 0x80000000
	// Protection disabled
	BPROT_CONFIG1_REGION63_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG1_REGION63_Enabled = 0x1

	// DISABLEINDEBUG: Disable protection mechanism in debug interface mode
	// Position of DISABLEINDEBUG field.
	BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos = 0x0
	// Bit mask of DISABLEINDEBUG field.
	BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Msk = 0x1
	// Bit DISABLEINDEBUG.
	BPROT_DISABLEINDEBUG_DISABLEINDEBUG = 0x1
	// Disable in debug
	BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Disabled = 0x1
	// Enable in debug
	BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Enabled = 0x0

	// CONFIG2: Block protect configuration register 2
	// Position of REGION64 field.
	BPROT_CONFIG2_REGION64_Pos = 0x0
	// Bit mask of REGION64 field.
	BPROT_CONFIG2_REGION64_Msk = 0x1
	// Bit REGION64.
	BPROT_CONFIG2_REGION64 = 0x1
	// Protection disabled
	BPROT_CONFIG2_REGION64_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION64_Enabled = 0x1
	// Position of REGION65 field.
	BPROT_CONFIG2_REGION65_Pos = 0x1
	// Bit mask of REGION65 field.
	BPROT_CONFIG2_REGION65_Msk = 0x2
	// Bit REGION65.
	BPROT_CONFIG2_REGION65 = 0x2
	// Protection disabled
	BPROT_CONFIG2_REGION65_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION65_Enabled = 0x1
	// Position of REGION66 field.
	BPROT_CONFIG2_REGION66_Pos = 0x2
	// Bit mask of REGION66 field.
	BPROT_CONFIG2_REGION66_Msk = 0x4
	// Bit REGION66.
	BPROT_CONFIG2_REGION66 = 0x4
	// Protection disabled
	BPROT_CONFIG2_REGION66_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION66_Enabled = 0x1
	// Position of REGION67 field.
	BPROT_CONFIG2_REGION67_Pos = 0x3
	// Bit mask of REGION67 field.
	BPROT_CONFIG2_REGION67_Msk = 0x8
	// Bit REGION67.
	BPROT_CONFIG2_REGION67 = 0x8
	// Protection disabled
	BPROT_CONFIG2_REGION67_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION67_Enabled = 0x1
	// Position of REGION68 field.
	BPROT_CONFIG2_REGION68_Pos = 0x4
	// Bit mask of REGION68 field.
	BPROT_CONFIG2_REGION68_Msk = 0x10
	// Bit REGION68.
	BPROT_CONFIG2_REGION68 = 0x10
	// Protection disabled
	BPROT_CONFIG2_REGION68_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION68_Enabled = 0x1
	// Position of REGION69 field.
	BPROT_CONFIG2_REGION69_Pos = 0x5
	// Bit mask of REGION69 field.
	BPROT_CONFIG2_REGION69_Msk = 0x20
	// Bit REGION69.
	BPROT_CONFIG2_REGION69 = 0x20
	// Protection disabled
	BPROT_CONFIG2_REGION69_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION69_Enabled = 0x1
	// Position of REGION70 field.
	BPROT_CONFIG2_REGION70_Pos = 0x6
	// Bit mask of REGION70 field.
	BPROT_CONFIG2_REGION70_Msk = 0x40
	// Bit REGION70.
	BPROT_CONFIG2_REGION70 = 0x40
	// Protection disabled
	BPROT_CONFIG2_REGION70_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION70_Enabled = 0x1
	// Position of REGION71 field.
	BPROT_CONFIG2_REGION71_Pos = 0x7
	// Bit mask of REGION71 field.
	BPROT_CONFIG2_REGION71_Msk = 0x80
	// Bit REGION71.
	BPROT_CONFIG2_REGION71 = 0x80
	// Protection disabled
	BPROT_CONFIG2_REGION71_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION71_Enabled = 0x1
	// Position of REGION72 field.
	BPROT_CONFIG2_REGION72_Pos = 0x8
	// Bit mask of REGION72 field.
	BPROT_CONFIG2_REGION72_Msk = 0x100
	// Bit REGION72.
	BPROT_CONFIG2_REGION72 = 0x100
	// Protection disabled
	BPROT_CONFIG2_REGION72_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION72_Enabled = 0x1
	// Position of REGION73 field.
	BPROT_CONFIG2_REGION73_Pos = 0x9
	// Bit mask of REGION73 field.
	BPROT_CONFIG2_REGION73_Msk = 0x200
	// Bit REGION73.
	BPROT_CONFIG2_REGION73 = 0x200
	// Protection disabled
	BPROT_CONFIG2_REGION73_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION73_Enabled = 0x1
	// Position of REGION74 field.
	BPROT_CONFIG2_REGION74_Pos = 0xa
	// Bit mask of REGION74 field.
	BPROT_CONFIG2_REGION74_Msk = 0x400
	// Bit REGION74.
	BPROT_CONFIG2_REGION74 = 0x400
	// Protection disabled
	BPROT_CONFIG2_REGION74_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION74_Enabled = 0x1
	// Position of REGION75 field.
	BPROT_CONFIG2_REGION75_Pos = 0xb
	// Bit mask of REGION75 field.
	BPROT_CONFIG2_REGION75_Msk = 0x800
	// Bit REGION75.
	BPROT_CONFIG2_REGION75 = 0x800
	// Protection disabled
	BPROT_CONFIG2_REGION75_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION75_Enabled = 0x1
	// Position of REGION76 field.
	BPROT_CONFIG2_REGION76_Pos = 0xc
	// Bit mask of REGION76 field.
	BPROT_CONFIG2_REGION76_Msk = 0x1000
	// Bit REGION76.
	BPROT_CONFIG2_REGION76 = 0x1000
	// Protection disabled
	BPROT_CONFIG2_REGION76_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION76_Enabled = 0x1
	// Position of REGION77 field.
	BPROT_CONFIG2_REGION77_Pos = 0xd
	// Bit mask of REGION77 field.
	BPROT_CONFIG2_REGION77_Msk = 0x2000
	// Bit REGION77.
	BPROT_CONFIG2_REGION77 = 0x2000
	// Protection disabled
	BPROT_CONFIG2_REGION77_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION77_Enabled = 0x1
	// Position of REGION78 field.
	BPROT_CONFIG2_REGION78_Pos = 0xe
	// Bit mask of REGION78 field.
	BPROT_CONFIG2_REGION78_Msk = 0x4000
	// Bit REGION78.
	BPROT_CONFIG2_REGION78 = 0x4000
	// Protection disabled
	BPROT_CONFIG2_REGION78_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION78_Enabled = 0x1
	// Position of REGION79 field.
	BPROT_CONFIG2_REGION79_Pos = 0xf
	// Bit mask of REGION79 field.
	BPROT_CONFIG2_REGION79_Msk = 0x8000
	// Bit REGION79.
	BPROT_CONFIG2_REGION79 = 0x8000
	// Protection disabled
	BPROT_CONFIG2_REGION79_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION79_Enabled = 0x1
	// Position of REGION80 field.
	BPROT_CONFIG2_REGION80_Pos = 0x10
	// Bit mask of REGION80 field.
	BPROT_CONFIG2_REGION80_Msk = 0x10000
	// Bit REGION80.
	BPROT_CONFIG2_REGION80 = 0x10000
	// Protection disabled
	BPROT_CONFIG2_REGION80_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION80_Enabled = 0x1
	// Position of REGION81 field.
	BPROT_CONFIG2_REGION81_Pos = 0x11
	// Bit mask of REGION81 field.
	BPROT_CONFIG2_REGION81_Msk = 0x20000
	// Bit REGION81.
	BPROT_CONFIG2_REGION81 = 0x20000
	// Protection disabled
	BPROT_CONFIG2_REGION81_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION81_Enabled = 0x1
	// Position of REGION82 field.
	BPROT_CONFIG2_REGION82_Pos = 0x12
	// Bit mask of REGION82 field.
	BPROT_CONFIG2_REGION82_Msk = 0x40000
	// Bit REGION82.
	BPROT_CONFIG2_REGION82 = 0x40000
	// Protection disabled
	BPROT_CONFIG2_REGION82_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION82_Enabled = 0x1
	// Position of REGION83 field.
	BPROT_CONFIG2_REGION83_Pos = 0x13
	// Bit mask of REGION83 field.
	BPROT_CONFIG2_REGION83_Msk = 0x80000
	// Bit REGION83.
	BPROT_CONFIG2_REGION83 = 0x80000
	// Protection disabled
	BPROT_CONFIG2_REGION83_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION83_Enabled = 0x1
	// Position of REGION84 field.
	BPROT_CONFIG2_REGION84_Pos = 0x14
	// Bit mask of REGION84 field.
	BPROT_CONFIG2_REGION84_Msk = 0x100000
	// Bit REGION84.
	BPROT_CONFIG2_REGION84 = 0x100000
	// Protection disabled
	BPROT_CONFIG2_REGION84_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION84_Enabled = 0x1
	// Position of REGION85 field.
	BPROT_CONFIG2_REGION85_Pos = 0x15
	// Bit mask of REGION85 field.
	BPROT_CONFIG2_REGION85_Msk = 0x200000
	// Bit REGION85.
	BPROT_CONFIG2_REGION85 = 0x200000
	// Protection disabled
	BPROT_CONFIG2_REGION85_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION85_Enabled = 0x1
	// Position of REGION86 field.
	BPROT_CONFIG2_REGION86_Pos = 0x16
	// Bit mask of REGION86 field.
	BPROT_CONFIG2_REGION86_Msk = 0x400000
	// Bit REGION86.
	BPROT_CONFIG2_REGION86 = 0x400000
	// Protection disabled
	BPROT_CONFIG2_REGION86_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION86_Enabled = 0x1
	// Position of REGION87 field.
	BPROT_CONFIG2_REGION87_Pos = 0x17
	// Bit mask of REGION87 field.
	BPROT_CONFIG2_REGION87_Msk = 0x800000
	// Bit REGION87.
	BPROT_CONFIG2_REGION87 = 0x800000
	// Protection disabled
	BPROT_CONFIG2_REGION87_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION87_Enabled = 0x1
	// Position of REGION88 field.
	BPROT_CONFIG2_REGION88_Pos = 0x18
	// Bit mask of REGION88 field.
	BPROT_CONFIG2_REGION88_Msk = 0x1000000
	// Bit REGION88.
	BPROT_CONFIG2_REGION88 = 0x1000000
	// Protection disabled
	BPROT_CONFIG2_REGION88_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION88_Enabled = 0x1
	// Position of REGION89 field.
	BPROT_CONFIG2_REGION89_Pos = 0x19
	// Bit mask of REGION89 field.
	BPROT_CONFIG2_REGION89_Msk = 0x2000000
	// Bit REGION89.
	BPROT_CONFIG2_REGION89 = 0x2000000
	// Protection disabled
	BPROT_CONFIG2_REGION89_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION89_Enabled = 0x1
	// Position of REGION90 field.
	BPROT_CONFIG2_REGION90_Pos = 0x1a
	// Bit mask of REGION90 field.
	BPROT_CONFIG2_REGION90_Msk = 0x4000000
	// Bit REGION90.
	BPROT_CONFIG2_REGION90 = 0x4000000
	// Protection disabled
	BPROT_CONFIG2_REGION90_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION90_Enabled = 0x1
	// Position of REGION91 field.
	BPROT_CONFIG2_REGION91_Pos = 0x1b
	// Bit mask of REGION91 field.
	BPROT_CONFIG2_REGION91_Msk = 0x8000000
	// Bit REGION91.
	BPROT_CONFIG2_REGION91 = 0x8000000
	// Protection disabled
	BPROT_CONFIG2_REGION91_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION91_Enabled = 0x1
	// Position of REGION92 field.
	BPROT_CONFIG2_REGION92_Pos = 0x1c
	// Bit mask of REGION92 field.
	BPROT_CONFIG2_REGION92_Msk = 0x10000000
	// Bit REGION92.
	BPROT_CONFIG2_REGION92 = 0x10000000
	// Protection disabled
	BPROT_CONFIG2_REGION92_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION92_Enabled = 0x1
	// Position of REGION93 field.
	BPROT_CONFIG2_REGION93_Pos = 0x1d
	// Bit mask of REGION93 field.
	BPROT_CONFIG2_REGION93_Msk = 0x20000000
	// Bit REGION93.
	BPROT_CONFIG2_REGION93 = 0x20000000
	// Protection disabled
	BPROT_CONFIG2_REGION93_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION93_Enabled = 0x1
	// Position of REGION94 field.
	BPROT_CONFIG2_REGION94_Pos = 0x1e
	// Bit mask of REGION94 field.
	BPROT_CONFIG2_REGION94_Msk = 0x40000000
	// Bit REGION94.
	BPROT_CONFIG2_REGION94 = 0x40000000
	// Protection disabled
	BPROT_CONFIG2_REGION94_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION94_Enabled = 0x1
	// Position of REGION95 field.
	BPROT_CONFIG2_REGION95_Pos = 0x1f
	// Bit mask of REGION95 field.
	BPROT_CONFIG2_REGION95_Msk = 0x80000000
	// Bit REGION95.
	BPROT_CONFIG2_REGION95 = 0x80000000
	// Protection disabled
	BPROT_CONFIG2_REGION95_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG2_REGION95_Enabled = 0x1

	// CONFIG3: Block protect configuration register 3
	// Position of REGION96 field.
	BPROT_CONFIG3_REGION96_Pos = 0x0
	// Bit mask of REGION96 field.
	BPROT_CONFIG3_REGION96_Msk = 0x1
	// Bit REGION96.
	BPROT_CONFIG3_REGION96 = 0x1
	// Protection disabled
	BPROT_CONFIG3_REGION96_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION96_Enabled = 0x1
	// Position of REGION97 field.
	BPROT_CONFIG3_REGION97_Pos = 0x1
	// Bit mask of REGION97 field.
	BPROT_CONFIG3_REGION97_Msk = 0x2
	// Bit REGION97.
	BPROT_CONFIG3_REGION97 = 0x2
	// Protection disabled
	BPROT_CONFIG3_REGION97_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION97_Enabled = 0x1
	// Position of REGION98 field.
	BPROT_CONFIG3_REGION98_Pos = 0x2
	// Bit mask of REGION98 field.
	BPROT_CONFIG3_REGION98_Msk = 0x4
	// Bit REGION98.
	BPROT_CONFIG3_REGION98 = 0x4
	// Protection disabled
	BPROT_CONFIG3_REGION98_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION98_Enabled = 0x1
	// Position of REGION99 field.
	BPROT_CONFIG3_REGION99_Pos = 0x3
	// Bit mask of REGION99 field.
	BPROT_CONFIG3_REGION99_Msk = 0x8
	// Bit REGION99.
	BPROT_CONFIG3_REGION99 = 0x8
	// Protection disabled
	BPROT_CONFIG3_REGION99_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION99_Enabled = 0x1
	// Position of REGION100 field.
	BPROT_CONFIG3_REGION100_Pos = 0x4
	// Bit mask of REGION100 field.
	BPROT_CONFIG3_REGION100_Msk = 0x10
	// Bit REGION100.
	BPROT_CONFIG3_REGION100 = 0x10
	// Protection disabled
	BPROT_CONFIG3_REGION100_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION100_Enabled = 0x1
	// Position of REGION101 field.
	BPROT_CONFIG3_REGION101_Pos = 0x5
	// Bit mask of REGION101 field.
	BPROT_CONFIG3_REGION101_Msk = 0x20
	// Bit REGION101.
	BPROT_CONFIG3_REGION101 = 0x20
	// Protection disabled
	BPROT_CONFIG3_REGION101_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION101_Enabled = 0x1
	// Position of REGION102 field.
	BPROT_CONFIG3_REGION102_Pos = 0x6
	// Bit mask of REGION102 field.
	BPROT_CONFIG3_REGION102_Msk = 0x40
	// Bit REGION102.
	BPROT_CONFIG3_REGION102 = 0x40
	// Protection disabled
	BPROT_CONFIG3_REGION102_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION102_Enabled = 0x1
	// Position of REGION103 field.
	BPROT_CONFIG3_REGION103_Pos = 0x7
	// Bit mask of REGION103 field.
	BPROT_CONFIG3_REGION103_Msk = 0x80
	// Bit REGION103.
	BPROT_CONFIG3_REGION103 = 0x80
	// Protection disabled
	BPROT_CONFIG3_REGION103_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION103_Enabled = 0x1
	// Position of REGION104 field.
	BPROT_CONFIG3_REGION104_Pos = 0x8
	// Bit mask of REGION104 field.
	BPROT_CONFIG3_REGION104_Msk = 0x100
	// Bit REGION104.
	BPROT_CONFIG3_REGION104 = 0x100
	// Protection disabled
	BPROT_CONFIG3_REGION104_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION104_Enabled = 0x1
	// Position of REGION105 field.
	BPROT_CONFIG3_REGION105_Pos = 0x9
	// Bit mask of REGION105 field.
	BPROT_CONFIG3_REGION105_Msk = 0x200
	// Bit REGION105.
	BPROT_CONFIG3_REGION105 = 0x200
	// Protection disabled
	BPROT_CONFIG3_REGION105_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION105_Enabled = 0x1
	// Position of REGION106 field.
	BPROT_CONFIG3_REGION106_Pos = 0xa
	// Bit mask of REGION106 field.
	BPROT_CONFIG3_REGION106_Msk = 0x400
	// Bit REGION106.
	BPROT_CONFIG3_REGION106 = 0x400
	// Protection disabled
	BPROT_CONFIG3_REGION106_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION106_Enabled = 0x1
	// Position of REGION107 field.
	BPROT_CONFIG3_REGION107_Pos = 0xb
	// Bit mask of REGION107 field.
	BPROT_CONFIG3_REGION107_Msk = 0x800
	// Bit REGION107.
	BPROT_CONFIG3_REGION107 = 0x800
	// Protection disabled
	BPROT_CONFIG3_REGION107_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION107_Enabled = 0x1
	// Position of REGION108 field.
	BPROT_CONFIG3_REGION108_Pos = 0xc
	// Bit mask of REGION108 field.
	BPROT_CONFIG3_REGION108_Msk = 0x1000
	// Bit REGION108.
	BPROT_CONFIG3_REGION108 = 0x1000
	// Protection disabled
	BPROT_CONFIG3_REGION108_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION108_Enabled = 0x1
	// Position of REGION109 field.
	BPROT_CONFIG3_REGION109_Pos = 0xd
	// Bit mask of REGION109 field.
	BPROT_CONFIG3_REGION109_Msk = 0x2000
	// Bit REGION109.
	BPROT_CONFIG3_REGION109 = 0x2000
	// Protection disabled
	BPROT_CONFIG3_REGION109_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION109_Enabled = 0x1
	// Position of REGION110 field.
	BPROT_CONFIG3_REGION110_Pos = 0xe
	// Bit mask of REGION110 field.
	BPROT_CONFIG3_REGION110_Msk = 0x4000
	// Bit REGION110.
	BPROT_CONFIG3_REGION110 = 0x4000
	// Protection disabled
	BPROT_CONFIG3_REGION110_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION110_Enabled = 0x1
	// Position of REGION111 field.
	BPROT_CONFIG3_REGION111_Pos = 0xf
	// Bit mask of REGION111 field.
	BPROT_CONFIG3_REGION111_Msk = 0x8000
	// Bit REGION111.
	BPROT_CONFIG3_REGION111 = 0x8000
	// Protection disabled
	BPROT_CONFIG3_REGION111_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION111_Enabled = 0x1
	// Position of REGION112 field.
	BPROT_CONFIG3_REGION112_Pos = 0x10
	// Bit mask of REGION112 field.
	BPROT_CONFIG3_REGION112_Msk = 0x10000
	// Bit REGION112.
	BPROT_CONFIG3_REGION112 = 0x10000
	// Protection disabled
	BPROT_CONFIG3_REGION112_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION112_Enabled = 0x1
	// Position of REGION113 field.
	BPROT_CONFIG3_REGION113_Pos = 0x11
	// Bit mask of REGION113 field.
	BPROT_CONFIG3_REGION113_Msk = 0x20000
	// Bit REGION113.
	BPROT_CONFIG3_REGION113 = 0x20000
	// Protection disabled
	BPROT_CONFIG3_REGION113_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION113_Enabled = 0x1
	// Position of REGION114 field.
	BPROT_CONFIG3_REGION114_Pos = 0x12
	// Bit mask of REGION114 field.
	BPROT_CONFIG3_REGION114_Msk = 0x40000
	// Bit REGION114.
	BPROT_CONFIG3_REGION114 = 0x40000
	// Protection disabled
	BPROT_CONFIG3_REGION114_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION114_Enabled = 0x1
	// Position of REGION115 field.
	BPROT_CONFIG3_REGION115_Pos = 0x13
	// Bit mask of REGION115 field.
	BPROT_CONFIG3_REGION115_Msk = 0x80000
	// Bit REGION115.
	BPROT_CONFIG3_REGION115 = 0x80000
	// Protection disabled
	BPROT_CONFIG3_REGION115_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION115_Enabled = 0x1
	// Position of REGION116 field.
	BPROT_CONFIG3_REGION116_Pos = 0x14
	// Bit mask of REGION116 field.
	BPROT_CONFIG3_REGION116_Msk = 0x100000
	// Bit REGION116.
	BPROT_CONFIG3_REGION116 = 0x100000
	// Protection disabled
	BPROT_CONFIG3_REGION116_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION116_Enabled = 0x1
	// Position of REGION117 field.
	BPROT_CONFIG3_REGION117_Pos = 0x15
	// Bit mask of REGION117 field.
	BPROT_CONFIG3_REGION117_Msk = 0x200000
	// Bit REGION117.
	BPROT_CONFIG3_REGION117 = 0x200000
	// Protection disabled
	BPROT_CONFIG3_REGION117_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION117_Enabled = 0x1
	// Position of REGION118 field.
	BPROT_CONFIG3_REGION118_Pos = 0x16
	// Bit mask of REGION118 field.
	BPROT_CONFIG3_REGION118_Msk = 0x400000
	// Bit REGION118.
	BPROT_CONFIG3_REGION118 = 0x400000
	// Protection disabled
	BPROT_CONFIG3_REGION118_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION118_Enabled = 0x1
	// Position of REGION119 field.
	BPROT_CONFIG3_REGION119_Pos = 0x17
	// Bit mask of REGION119 field.
	BPROT_CONFIG3_REGION119_Msk = 0x800000
	// Bit REGION119.
	BPROT_CONFIG3_REGION119 = 0x800000
	// Protection disabled
	BPROT_CONFIG3_REGION119_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION119_Enabled = 0x1
	// Position of REGION120 field.
	BPROT_CONFIG3_REGION120_Pos = 0x18
	// Bit mask of REGION120 field.
	BPROT_CONFIG3_REGION120_Msk = 0x1000000
	// Bit REGION120.
	BPROT_CONFIG3_REGION120 = 0x1000000
	// Protection disabled
	BPROT_CONFIG3_REGION120_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION120_Enabled = 0x1
	// Position of REGION121 field.
	BPROT_CONFIG3_REGION121_Pos = 0x19
	// Bit mask of REGION121 field.
	BPROT_CONFIG3_REGION121_Msk = 0x2000000
	// Bit REGION121.
	BPROT_CONFIG3_REGION121 = 0x2000000
	// Protection disabled
	BPROT_CONFIG3_REGION121_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION121_Enabled = 0x1
	// Position of REGION122 field.
	BPROT_CONFIG3_REGION122_Pos = 0x1a
	// Bit mask of REGION122 field.
	BPROT_CONFIG3_REGION122_Msk = 0x4000000
	// Bit REGION122.
	BPROT_CONFIG3_REGION122 = 0x4000000
	// Protection disabled
	BPROT_CONFIG3_REGION122_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION122_Enabled = 0x1
	// Position of REGION123 field.
	BPROT_CONFIG3_REGION123_Pos = 0x1b
	// Bit mask of REGION123 field.
	BPROT_CONFIG3_REGION123_Msk = 0x8000000
	// Bit REGION123.
	BPROT_CONFIG3_REGION123 = 0x8000000
	// Protection disabled
	BPROT_CONFIG3_REGION123_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION123_Enabled = 0x1
	// Position of REGION124 field.
	BPROT_CONFIG3_REGION124_Pos = 0x1c
	// Bit mask of REGION124 field.
	BPROT_CONFIG3_REGION124_Msk = 0x10000000
	// Bit REGION124.
	BPROT_CONFIG3_REGION124 = 0x10000000
	// Protection disabled
	BPROT_CONFIG3_REGION124_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION124_Enabled = 0x1
	// Position of REGION125 field.
	BPROT_CONFIG3_REGION125_Pos = 0x1d
	// Bit mask of REGION125 field.
	BPROT_CONFIG3_REGION125_Msk = 0x20000000
	// Bit REGION125.
	BPROT_CONFIG3_REGION125 = 0x20000000
	// Protection disabled
	BPROT_CONFIG3_REGION125_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION125_Enabled = 0x1
	// Position of REGION126 field.
	BPROT_CONFIG3_REGION126_Pos = 0x1e
	// Bit mask of REGION126 field.
	BPROT_CONFIG3_REGION126_Msk = 0x40000000
	// Bit REGION126.
	BPROT_CONFIG3_REGION126 = 0x40000000
	// Protection disabled
	BPROT_CONFIG3_REGION126_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION126_Enabled = 0x1
	// Position of REGION127 field.
	BPROT_CONFIG3_REGION127_Pos = 0x1f
	// Bit mask of REGION127 field.
	BPROT_CONFIG3_REGION127_Msk = 0x80000000
	// Bit REGION127.
	BPROT_CONFIG3_REGION127 = 0x80000000
	// Protection disabled
	BPROT_CONFIG3_REGION127_Disabled = 0x0
	// Protection enabled
	BPROT_CONFIG3_REGION127_Enabled = 0x1
)

// Constants for POWER: Power control
const (
	// INTENSET: Enable interrupt
	// Position of POFWARN field.
	POWER_INTENSET_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTENSET_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTENSET_POFWARN = 0x4
	// Read: Disabled
	POWER_INTENSET_POFWARN_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_POFWARN_Enabled = 0x1
	// Enable
	POWER_INTENSET_POFWARN_Set = 0x1
	// Position of SLEEPENTER field.
	POWER_INTENSET_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTENSET_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTENSET_SLEEPENTER = 0x20
	// Read: Disabled
	POWER_INTENSET_SLEEPENTER_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_SLEEPENTER_Enabled = 0x1
	// Enable
	POWER_INTENSET_SLEEPENTER_Set = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTENSET_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTENSET_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTENSET_SLEEPEXIT = 0x40
	// Read: Disabled
	POWER_INTENSET_SLEEPEXIT_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_SLEEPEXIT_Enabled = 0x1
	// Enable
	POWER_INTENSET_SLEEPEXIT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of POFWARN field.
	POWER_INTENCLR_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTENCLR_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTENCLR_POFWARN = 0x4
	// Read: Disabled
	POWER_INTENCLR_POFWARN_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_POFWARN_Enabled = 0x1
	// Disable
	POWER_INTENCLR_POFWARN_Clear = 0x1
	// Position of SLEEPENTER field.
	POWER_INTENCLR_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTENCLR_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTENCLR_SLEEPENTER = 0x20
	// Read: Disabled
	POWER_INTENCLR_SLEEPENTER_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_SLEEPENTER_Enabled = 0x1
	// Disable
	POWER_INTENCLR_SLEEPENTER_Clear = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTENCLR_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTENCLR_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTENCLR_SLEEPEXIT = 0x40
	// Read: Disabled
	POWER_INTENCLR_SLEEPEXIT_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_SLEEPEXIT_Enabled = 0x1
	// Disable
	POWER_INTENCLR_SLEEPEXIT_Clear = 0x1

	// RESETREAS: Reset reason
	// Position of RESETPIN field.
	POWER_RESETREAS_RESETPIN_Pos = 0x0
	// Bit mask of RESETPIN field.
	POWER_RESETREAS_RESETPIN_Msk = 0x1
	// Bit RESETPIN.
	POWER_RESETREAS_RESETPIN = 0x1
	// Not detected
	POWER_RESETREAS_RESETPIN_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_RESETPIN_Detected = 0x1
	// Position of DOG field.
	POWER_RESETREAS_DOG_Pos = 0x1
	// Bit mask of DOG field.
	POWER_RESETREAS_DOG_Msk = 0x2
	// Bit DOG.
	POWER_RESETREAS_DOG = 0x2
	// Not detected
	POWER_RESETREAS_DOG_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_DOG_Detected = 0x1
	// Position of SREQ field.
	POWER_RESETREAS_SREQ_Pos = 0x2
	// Bit mask of SREQ field.
	POWER_RESETREAS_SREQ_Msk = 0x4
	// Bit SREQ.
	POWER_RESETREAS_SREQ = 0x4
	// Not detected
	POWER_RESETREAS_SREQ_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_SREQ_Detected = 0x1
	// Position of LOCKUP field.
	POWER_RESETREAS_LOCKUP_Pos = 0x3
	// Bit mask of LOCKUP field.
	POWER_RESETREAS_LOCKUP_Msk = 0x8
	// Bit LOCKUP.
	POWER_RESETREAS_LOCKUP = 0x8
	// Not detected
	POWER_RESETREAS_LOCKUP_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_LOCKUP_Detected = 0x1
	// Position of OFF field.
	POWER_RESETREAS_OFF_Pos = 0x10
	// Bit mask of OFF field.
	POWER_RESETREAS_OFF_Msk = 0x10000
	// Bit OFF.
	POWER_RESETREAS_OFF = 0x10000
	// Not detected
	POWER_RESETREAS_OFF_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_OFF_Detected = 0x1
	// Position of LPCOMP field.
	POWER_RESETREAS_LPCOMP_Pos = 0x11
	// Bit mask of LPCOMP field.
	POWER_RESETREAS_LPCOMP_Msk = 0x20000
	// Bit LPCOMP.
	POWER_RESETREAS_LPCOMP = 0x20000
	// Not detected
	POWER_RESETREAS_LPCOMP_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_LPCOMP_Detected = 0x1
	// Position of DIF field.
	POWER_RESETREAS_DIF_Pos = 0x12
	// Bit mask of DIF field.
	POWER_RESETREAS_DIF_Msk = 0x40000
	// Bit DIF.
	POWER_RESETREAS_DIF = 0x40000
	// Not detected
	POWER_RESETREAS_DIF_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_DIF_Detected = 0x1
	// Position of NFC field.
	POWER_RESETREAS_NFC_Pos = 0x13
	// Bit mask of NFC field.
	POWER_RESETREAS_NFC_Msk = 0x80000
	// Bit NFC.
	POWER_RESETREAS_NFC = 0x80000
	// Not detected
	POWER_RESETREAS_NFC_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_NFC_Detected = 0x1

	// RAMSTATUS: Deprecated register - RAM status register
	// Position of RAMBLOCK0 field.
	POWER_RAMSTATUS_RAMBLOCK0_Pos = 0x0
	// Bit mask of RAMBLOCK0 field.
	POWER_RAMSTATUS_RAMBLOCK0_Msk = 0x1
	// Bit RAMBLOCK0.
	POWER_RAMSTATUS_RAMBLOCK0 = 0x1
	// Off
	POWER_RAMSTATUS_RAMBLOCK0_Off = 0x0
	// On
	POWER_RAMSTATUS_RAMBLOCK0_On = 0x1
	// Position of RAMBLOCK1 field.
	POWER_RAMSTATUS_RAMBLOCK1_Pos = 0x1
	// Bit mask of RAMBLOCK1 field.
	POWER_RAMSTATUS_RAMBLOCK1_Msk = 0x2
	// Bit RAMBLOCK1.
	POWER_RAMSTATUS_RAMBLOCK1 = 0x2
	// Off
	POWER_RAMSTATUS_RAMBLOCK1_Off = 0x0
	// On
	POWER_RAMSTATUS_RAMBLOCK1_On = 0x1
	// Position of RAMBLOCK2 field.
	POWER_RAMSTATUS_RAMBLOCK2_Pos = 0x2
	// Bit mask of RAMBLOCK2 field.
	POWER_RAMSTATUS_RAMBLOCK2_Msk = 0x4
	// Bit RAMBLOCK2.
	POWER_RAMSTATUS_RAMBLOCK2 = 0x4
	// Off
	POWER_RAMSTATUS_RAMBLOCK2_Off = 0x0
	// On
	POWER_RAMSTATUS_RAMBLOCK2_On = 0x1
	// Position of RAMBLOCK3 field.
	POWER_RAMSTATUS_RAMBLOCK3_Pos = 0x3
	// Bit mask of RAMBLOCK3 field.
	POWER_RAMSTATUS_RAMBLOCK3_Msk = 0x8
	// Bit RAMBLOCK3.
	POWER_RAMSTATUS_RAMBLOCK3 = 0x8
	// Off
	POWER_RAMSTATUS_RAMBLOCK3_Off = 0x0
	// On
	POWER_RAMSTATUS_RAMBLOCK3_On = 0x1

	// SYSTEMOFF: System OFF register
	// Position of SYSTEMOFF field.
	POWER_SYSTEMOFF_SYSTEMOFF_Pos = 0x0
	// Bit mask of SYSTEMOFF field.
	POWER_SYSTEMOFF_SYSTEMOFF_Msk = 0x1
	// Bit SYSTEMOFF.
	POWER_SYSTEMOFF_SYSTEMOFF = 0x1
	// Enable System OFF mode
	POWER_SYSTEMOFF_SYSTEMOFF_Enter = 0x1

	// POFCON: Power failure comparator configuration
	// Position of POF field.
	POWER_POFCON_POF_Pos = 0x0
	// Bit mask of POF field.
	POWER_POFCON_POF_Msk = 0x1
	// Bit POF.
	POWER_POFCON_POF = 0x1
	// Disable
	POWER_POFCON_POF_Disabled = 0x0
	// Enable
	POWER_POFCON_POF_Enabled = 0x1
	// Position of THRESHOLD field.
	POWER_POFCON_THRESHOLD_Pos = 0x1
	// Bit mask of THRESHOLD field.
	POWER_POFCON_THRESHOLD_Msk = 0x1e
	// Set threshold to 1.7 V
	POWER_POFCON_THRESHOLD_V17 = 0x4
	// Set threshold to 1.8 V
	POWER_POFCON_THRESHOLD_V18 = 0x5
	// Set threshold to 1.9 V
	POWER_POFCON_THRESHOLD_V19 = 0x6
	// Set threshold to 2.0 V
	POWER_POFCON_THRESHOLD_V20 = 0x7
	// Set threshold to 2.1 V
	POWER_POFCON_THRESHOLD_V21 = 0x8
	// Set threshold to 2.2 V
	POWER_POFCON_THRESHOLD_V22 = 0x9
	// Set threshold to 2.3 V
	POWER_POFCON_THRESHOLD_V23 = 0xa
	// Set threshold to 2.4 V
	POWER_POFCON_THRESHOLD_V24 = 0xb
	// Set threshold to 2.5 V
	POWER_POFCON_THRESHOLD_V25 = 0xc
	// Set threshold to 2.6 V
	POWER_POFCON_THRESHOLD_V26 = 0xd
	// Set threshold to 2.7 V
	POWER_POFCON_THRESHOLD_V27 = 0xe
	// Set threshold to 2.8 V
	POWER_POFCON_THRESHOLD_V28 = 0xf

	// GPREGRET: General purpose retention register
	// Position of GPREGRET field.
	POWER_GPREGRET_GPREGRET_Pos = 0x0
	// Bit mask of GPREGRET field.
	POWER_GPREGRET_GPREGRET_Msk = 0xff

	// GPREGRET2: General purpose retention register
	// Position of GPREGRET field.
	POWER_GPREGRET2_GPREGRET_Pos = 0x0
	// Bit mask of GPREGRET field.
	POWER_GPREGRET2_GPREGRET_Msk = 0xff

	// RAMON: Deprecated register - RAM on/off register (this register is retained)
	// Position of ONRAM0 field.
	POWER_RAMON_ONRAM0_Pos = 0x0
	// Bit mask of ONRAM0 field.
	POWER_RAMON_ONRAM0_Msk = 0x1
	// Bit ONRAM0.
	POWER_RAMON_ONRAM0 = 0x1
	// Off
	POWER_RAMON_ONRAM0_RAM0Off = 0x0
	// On
	POWER_RAMON_ONRAM0_RAM0On = 0x1
	// Position of ONRAM1 field.
	POWER_RAMON_ONRAM1_Pos = 0x1
	// Bit mask of ONRAM1 field.
	POWER_RAMON_ONRAM1_Msk = 0x2
	// Bit ONRAM1.
	POWER_RAMON_ONRAM1 = 0x2
	// Off
	POWER_RAMON_ONRAM1_RAM1Off = 0x0
	// On
	POWER_RAMON_ONRAM1_RAM1On = 0x1
	// Position of OFFRAM0 field.
	POWER_RAMON_OFFRAM0_Pos = 0x10
	// Bit mask of OFFRAM0 field.
	POWER_RAMON_OFFRAM0_Msk = 0x10000
	// Bit OFFRAM0.
	POWER_RAMON_OFFRAM0 = 0x10000
	// Off
	POWER_RAMON_OFFRAM0_RAM0Off = 0x0
	// On
	POWER_RAMON_OFFRAM0_RAM0On = 0x1
	// Position of OFFRAM1 field.
	POWER_RAMON_OFFRAM1_Pos = 0x11
	// Bit mask of OFFRAM1 field.
	POWER_RAMON_OFFRAM1_Msk = 0x20000
	// Bit OFFRAM1.
	POWER_RAMON_OFFRAM1 = 0x20000
	// Off
	POWER_RAMON_OFFRAM1_RAM1Off = 0x0
	// On
	POWER_RAMON_OFFRAM1_RAM1On = 0x1

	// RAMONB: Deprecated register - RAM on/off register (this register is retained)
	// Position of ONRAM2 field.
	POWER_RAMONB_ONRAM2_Pos = 0x0
	// Bit mask of ONRAM2 field.
	POWER_RAMONB_ONRAM2_Msk = 0x1
	// Bit ONRAM2.
	POWER_RAMONB_ONRAM2 = 0x1
	// Off
	POWER_RAMONB_ONRAM2_RAM2Off = 0x0
	// On
	POWER_RAMONB_ONRAM2_RAM2On = 0x1
	// Position of ONRAM3 field.
	POWER_RAMONB_ONRAM3_Pos = 0x1
	// Bit mask of ONRAM3 field.
	POWER_RAMONB_ONRAM3_Msk = 0x2
	// Bit ONRAM3.
	POWER_RAMONB_ONRAM3 = 0x2
	// Off
	POWER_RAMONB_ONRAM3_RAM3Off = 0x0
	// On
	POWER_RAMONB_ONRAM3_RAM3On = 0x1
	// Position of OFFRAM2 field.
	POWER_RAMONB_OFFRAM2_Pos = 0x10
	// Bit mask of OFFRAM2 field.
	POWER_RAMONB_OFFRAM2_Msk = 0x10000
	// Bit OFFRAM2.
	POWER_RAMONB_OFFRAM2 = 0x10000
	// Off
	POWER_RAMONB_OFFRAM2_RAM2Off = 0x0
	// On
	POWER_RAMONB_OFFRAM2_RAM2On = 0x1
	// Position of OFFRAM3 field.
	POWER_RAMONB_OFFRAM3_Pos = 0x11
	// Bit mask of OFFRAM3 field.
	POWER_RAMONB_OFFRAM3_Msk = 0x20000
	// Bit OFFRAM3.
	POWER_RAMONB_OFFRAM3 = 0x20000
	// Off
	POWER_RAMONB_OFFRAM3_RAM3Off = 0x0
	// On
	POWER_RAMONB_OFFRAM3_RAM3On = 0x1

	// DCDCEN: DC/DC enable register
	// Position of DCDCEN field.
	POWER_DCDCEN_DCDCEN_Pos = 0x0
	// Bit mask of DCDCEN field.
	POWER_DCDCEN_DCDCEN_Msk = 0x1
	// Bit DCDCEN.
	POWER_DCDCEN_DCDCEN = 0x1
	// Disable
	POWER_DCDCEN_DCDCEN_Disabled = 0x0
	// Enable
	POWER_DCDCEN_DCDCEN_Enabled = 0x1

	// RAM.POWER: Description cluster[0]: RAM0 power control register
	// Position of S0POWER field.
	POWER_RAM_POWER_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	POWER_RAM_POWER_S0POWER_Msk = 0x1
	// Bit S0POWER.
	POWER_RAM_POWER_S0POWER = 0x1
	// Off
	POWER_RAM_POWER_S0POWER_Off = 0x0
	// On
	POWER_RAM_POWER_S0POWER_On = 0x1
	// Position of S1POWER field.
	POWER_RAM_POWER_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	POWER_RAM_POWER_S1POWER_Msk = 0x2
	// Bit S1POWER.
	POWER_RAM_POWER_S1POWER = 0x2
	// Off
	POWER_RAM_POWER_S1POWER_Off = 0x0
	// On
	POWER_RAM_POWER_S1POWER_On = 0x1
	// Position of S0RETENTION field.
	POWER_RAM_POWER_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	POWER_RAM_POWER_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	POWER_RAM_POWER_S0RETENTION = 0x10000
	// Off
	POWER_RAM_POWER_S0RETENTION_Off = 0x0
	// On
	POWER_RAM_POWER_S0RETENTION_On = 0x1
	// Position of S1RETENTION field.
	POWER_RAM_POWER_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	POWER_RAM_POWER_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	POWER_RAM_POWER_S1RETENTION = 0x20000
	// Off
	POWER_RAM_POWER_S1RETENTION_Off = 0x0
	// On
	POWER_RAM_POWER_S1RETENTION_On = 0x1

	// RAM.POWERSET: Description cluster[0]: RAM0 power control set register
	// Position of S0POWER field.
	POWER_RAM_POWERSET_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	POWER_RAM_POWERSET_S0POWER_Msk = 0x1
	// Bit S0POWER.
	POWER_RAM_POWERSET_S0POWER = 0x1
	// On
	POWER_RAM_POWERSET_S0POWER_On = 0x1
	// Position of S1POWER field.
	POWER_RAM_POWERSET_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	POWER_RAM_POWERSET_S1POWER_Msk = 0x2
	// Bit S1POWER.
	POWER_RAM_POWERSET_S1POWER = 0x2
	// On
	POWER_RAM_POWERSET_S1POWER_On = 0x1
	// Position of S0RETENTION field.
	POWER_RAM_POWERSET_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	POWER_RAM_POWERSET_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	POWER_RAM_POWERSET_S0RETENTION = 0x10000
	// On
	POWER_RAM_POWERSET_S0RETENTION_On = 0x1
	// Position of S1RETENTION field.
	POWER_RAM_POWERSET_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	POWER_RAM_POWERSET_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	POWER_RAM_POWERSET_S1RETENTION = 0x20000
	// On
	POWER_RAM_POWERSET_S1RETENTION_On = 0x1

	// RAM.POWERCLR: Description cluster[0]: RAM0 power control clear register
	// Position of S0POWER field.
	POWER_RAM_POWERCLR_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	POWER_RAM_POWERCLR_S0POWER_Msk = 0x1
	// Bit S0POWER.
	POWER_RAM_POWERCLR_S0POWER = 0x1
	// Off
	POWER_RAM_POWERCLR_S0POWER_Off = 0x1
	// Position of S1POWER field.
	POWER_RAM_POWERCLR_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	POWER_RAM_POWERCLR_S1POWER_Msk = 0x2
	// Bit S1POWER.
	POWER_RAM_POWERCLR_S1POWER = 0x2
	// Off
	POWER_RAM_POWERCLR_S1POWER_Off = 0x1
	// Position of S0RETENTION field.
	POWER_RAM_POWERCLR_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	POWER_RAM_POWERCLR_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	POWER_RAM_POWERCLR_S0RETENTION = 0x10000
	// Off
	POWER_RAM_POWERCLR_S0RETENTION_Off = 0x1
	// Position of S1RETENTION field.
	POWER_RAM_POWERCLR_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	POWER_RAM_POWERCLR_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	POWER_RAM_POWERCLR_S1RETENTION = 0x20000
	// Off
	POWER_RAM_POWERCLR_S1RETENTION_Off = 0x1
)

// Constants for CLOCK: Clock control
const (
	// INTENSET: Enable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTENSET_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTENSET_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTENSET_HFCLKSTARTED = 0x1
	// Read: Disabled
	CLOCK_INTENSET_HFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_HFCLKSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_HFCLKSTARTED_Set = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTENSET_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTENSET_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTENSET_LFCLKSTARTED = 0x2
	// Read: Disabled
	CLOCK_INTENSET_LFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_LFCLKSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_LFCLKSTARTED_Set = 0x1
	// Position of DONE field.
	CLOCK_INTENSET_DONE_Pos = 0x3
	// Bit mask of DONE field.
	CLOCK_INTENSET_DONE_Msk = 0x8
	// Bit DONE.
	CLOCK_INTENSET_DONE = 0x8
	// Read: Disabled
	CLOCK_INTENSET_DONE_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_DONE_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_DONE_Set = 0x1
	// Position of CTTO field.
	CLOCK_INTENSET_CTTO_Pos = 0x4
	// Bit mask of CTTO field.
	CLOCK_INTENSET_CTTO_Msk = 0x10
	// Bit CTTO.
	CLOCK_INTENSET_CTTO = 0x10
	// Read: Disabled
	CLOCK_INTENSET_CTTO_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_CTTO_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_CTTO_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTENCLR_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTENCLR_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTENCLR_HFCLKSTARTED = 0x1
	// Read: Disabled
	CLOCK_INTENCLR_HFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_HFCLKSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_HFCLKSTARTED_Clear = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTENCLR_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTENCLR_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTENCLR_LFCLKSTARTED = 0x2
	// Read: Disabled
	CLOCK_INTENCLR_LFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_LFCLKSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_LFCLKSTARTED_Clear = 0x1
	// Position of DONE field.
	CLOCK_INTENCLR_DONE_Pos = 0x3
	// Bit mask of DONE field.
	CLOCK_INTENCLR_DONE_Msk = 0x8
	// Bit DONE.
	CLOCK_INTENCLR_DONE = 0x8
	// Read: Disabled
	CLOCK_INTENCLR_DONE_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_DONE_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_DONE_Clear = 0x1
	// Position of CTTO field.
	CLOCK_INTENCLR_CTTO_Pos = 0x4
	// Bit mask of CTTO field.
	CLOCK_INTENCLR_CTTO_Msk = 0x10
	// Bit CTTO.
	CLOCK_INTENCLR_CTTO = 0x10
	// Read: Disabled
	CLOCK_INTENCLR_CTTO_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_CTTO_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_CTTO_Clear = 0x1

	// HFCLKRUN: Status indicating that HFCLKSTART task has been triggered
	// Position of STATUS field.
	CLOCK_HFCLKRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_HFCLKRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_HFCLKRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_HFCLKRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_HFCLKRUN_STATUS_Triggered = 0x1

	// HFCLKSTAT: HFCLK status
	// Position of SRC field.
	CLOCK_HFCLKSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_HFCLKSTAT_SRC_Msk = 0x1
	// Bit SRC.
	CLOCK_HFCLKSTAT_SRC = 0x1
	// 64 MHz internal oscillator (HFINT)
	CLOCK_HFCLKSTAT_SRC_RC = 0x0
	// 64 MHz crystal oscillator (HFXO)
	CLOCK_HFCLKSTAT_SRC_Xtal = 0x1
	// Position of STATE field.
	CLOCK_HFCLKSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_HFCLKSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_HFCLKSTAT_STATE = 0x10000
	// HFCLK not running
	CLOCK_HFCLKSTAT_STATE_NotRunning = 0x0
	// HFCLK running
	CLOCK_HFCLKSTAT_STATE_Running = 0x1

	// LFCLKRUN: Status indicating that LFCLKSTART task has been triggered
	// Position of STATUS field.
	CLOCK_LFCLKRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_LFCLKRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_LFCLKRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_LFCLKRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_LFCLKRUN_STATUS_Triggered = 0x1

	// LFCLKSTAT: LFCLK status
	// Position of SRC field.
	CLOCK_LFCLKSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSTAT_SRC_Msk = 0x3
	// 32.768 kHz RC oscillator
	CLOCK_LFCLKSTAT_SRC_RC = 0x0
	// 32.768 kHz crystal oscillator
	CLOCK_LFCLKSTAT_SRC_Xtal = 0x1
	// 32.768 kHz synthesized from HFCLK
	CLOCK_LFCLKSTAT_SRC_Synth = 0x2
	// Position of STATE field.
	CLOCK_LFCLKSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_LFCLKSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_LFCLKSTAT_STATE = 0x10000
	// LFCLK not running
	CLOCK_LFCLKSTAT_STATE_NotRunning = 0x0
	// LFCLK running
	CLOCK_LFCLKSTAT_STATE_Running = 0x1

	// LFCLKSRCCOPY: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
	// Position of SRC field.
	CLOCK_LFCLKSRCCOPY_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSRCCOPY_SRC_Msk = 0x3
	// 32.768 kHz RC oscillator
	CLOCK_LFCLKSRCCOPY_SRC_RC = 0x0
	// 32.768 kHz crystal oscillator
	CLOCK_LFCLKSRCCOPY_SRC_Xtal = 0x1
	// 32.768 kHz synthesized from HFCLK
	CLOCK_LFCLKSRCCOPY_SRC_Synth = 0x2

	// LFCLKSRC: Clock source for the LFCLK
	// Position of SRC field.
	CLOCK_LFCLKSRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSRC_SRC_Msk = 0x3
	// 32.768 kHz RC oscillator
	CLOCK_LFCLKSRC_SRC_RC = 0x0
	// 32.768 kHz crystal oscillator
	CLOCK_LFCLKSRC_SRC_Xtal = 0x1
	// 32.768 kHz synthesized from HFCLK
	CLOCK_LFCLKSRC_SRC_Synth = 0x2
	// Position of BYPASS field.
	CLOCK_LFCLKSRC_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CLOCK_LFCLKSRC_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CLOCK_LFCLKSRC_BYPASS = 0x10000
	// Disable (use with Xtal or low-swing external source)
	CLOCK_LFCLKSRC_BYPASS_Disabled = 0x0
	// Enable (use with rail-to-rail external source)
	CLOCK_LFCLKSRC_BYPASS_Enabled = 0x1
	// Position of EXTERNAL field.
	CLOCK_LFCLKSRC_EXTERNAL_Pos = 0x11
	// Bit mask of EXTERNAL field.
	CLOCK_LFCLKSRC_EXTERNAL_Msk = 0x20000
	// Bit EXTERNAL.
	CLOCK_LFCLKSRC_EXTERNAL = 0x20000
	// Disable external source (use with Xtal)
	CLOCK_LFCLKSRC_EXTERNAL_Disabled = 0x0
	// Enable use of external source instead of Xtal (SRC needs to be set to Xtal)
	CLOCK_LFCLKSRC_EXTERNAL_Enabled = 0x1

	// CTIV: Calibration timer interval
	// Position of CTIV field.
	CLOCK_CTIV_CTIV_Pos = 0x0
	// Bit mask of CTIV field.
	CLOCK_CTIV_CTIV_Msk = 0x7f

	// TRACECONFIG: Clocking options for the Trace Port debug interface
	// Position of TRACEPORTSPEED field.
	CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos = 0x0
	// Bit mask of TRACEPORTSPEED field.
	CLOCK_TRACECONFIG_TRACEPORTSPEED_Msk = 0x3
	// 32 MHz Trace Port clock (TRACECLK = 16 MHz)
	CLOCK_TRACECONFIG_TRACEPORTSPEED_32MHz = 0x0
	// 16 MHz Trace Port clock (TRACECLK = 8 MHz)
	CLOCK_TRACECONFIG_TRACEPORTSPEED_16MHz = 0x1
	// 8 MHz Trace Port clock (TRACECLK = 4 MHz)
	CLOCK_TRACECONFIG_TRACEPORTSPEED_8MHz = 0x2
	// 4 MHz Trace Port clock (TRACECLK = 2 MHz)
	CLOCK_TRACECONFIG_TRACEPORTSPEED_4MHz = 0x3
	// Position of TRACEMUX field.
	CLOCK_TRACECONFIG_TRACEMUX_Pos = 0x10
	// Bit mask of TRACEMUX field.
	CLOCK_TRACECONFIG_TRACEMUX_Msk = 0x30000
	// GPIOs multiplexed onto all trace-pins
	CLOCK_TRACECONFIG_TRACEMUX_GPIO = 0x0
	// SWO multiplexed onto P0.18, GPIO multiplexed onto other trace pins
	CLOCK_TRACECONFIG_TRACEMUX_Serial = 0x1
	// TRACECLK and TRACEDATA multiplexed onto P0.20, P0.18, P0.16, P0.15 and P0.14.
	CLOCK_TRACECONFIG_TRACEMUX_Parallel = 0x2
)

// Constants for RADIO: 2.4 GHz Radio
const (
	// SHORTS: Shortcut register
	// Position of READY_START field.
	RADIO_SHORTS_READY_START_Pos = 0x0
	// Bit mask of READY_START field.
	RADIO_SHORTS_READY_START_Msk = 0x1
	// Bit READY_START.
	RADIO_SHORTS_READY_START = 0x1
	// Disable shortcut
	RADIO_SHORTS_READY_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_READY_START_Enabled = 0x1
	// Position of END_DISABLE field.
	RADIO_SHORTS_END_DISABLE_Pos = 0x1
	// Bit mask of END_DISABLE field.
	RADIO_SHORTS_END_DISABLE_Msk = 0x2
	// Bit END_DISABLE.
	RADIO_SHORTS_END_DISABLE = 0x2
	// Disable shortcut
	RADIO_SHORTS_END_DISABLE_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_END_DISABLE_Enabled = 0x1
	// Position of DISABLED_TXEN field.
	RADIO_SHORTS_DISABLED_TXEN_Pos = 0x2
	// Bit mask of DISABLED_TXEN field.
	RADIO_SHORTS_DISABLED_TXEN_Msk = 0x4
	// Bit DISABLED_TXEN.
	RADIO_SHORTS_DISABLED_TXEN = 0x4
	// Disable shortcut
	RADIO_SHORTS_DISABLED_TXEN_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_DISABLED_TXEN_Enabled = 0x1
	// Position of DISABLED_RXEN field.
	RADIO_SHORTS_DISABLED_RXEN_Pos = 0x3
	// Bit mask of DISABLED_RXEN field.
	RADIO_SHORTS_DISABLED_RXEN_Msk = 0x8
	// Bit DISABLED_RXEN.
	RADIO_SHORTS_DISABLED_RXEN = 0x8
	// Disable shortcut
	RADIO_SHORTS_DISABLED_RXEN_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_DISABLED_RXEN_Enabled = 0x1
	// Position of ADDRESS_RSSISTART field.
	RADIO_SHORTS_ADDRESS_RSSISTART_Pos = 0x4
	// Bit mask of ADDRESS_RSSISTART field.
	RADIO_SHORTS_ADDRESS_RSSISTART_Msk = 0x10
	// Bit ADDRESS_RSSISTART.
	RADIO_SHORTS_ADDRESS_RSSISTART = 0x10
	// Disable shortcut
	RADIO_SHORTS_ADDRESS_RSSISTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_ADDRESS_RSSISTART_Enabled = 0x1
	// Position of END_START field.
	RADIO_SHORTS_END_START_Pos = 0x5
	// Bit mask of END_START field.
	RADIO_SHORTS_END_START_Msk = 0x20
	// Bit END_START.
	RADIO_SHORTS_END_START = 0x20
	// Disable shortcut
	RADIO_SHORTS_END_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_END_START_Enabled = 0x1
	// Position of ADDRESS_BCSTART field.
	RADIO_SHORTS_ADDRESS_BCSTART_Pos = 0x6
	// Bit mask of ADDRESS_BCSTART field.
	RADIO_SHORTS_ADDRESS_BCSTART_Msk = 0x40
	// Bit ADDRESS_BCSTART.
	RADIO_SHORTS_ADDRESS_BCSTART = 0x40
	// Disable shortcut
	RADIO_SHORTS_ADDRESS_BCSTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_ADDRESS_BCSTART_Enabled = 0x1
	// Position of DISABLED_RSSISTOP field.
	RADIO_SHORTS_DISABLED_RSSISTOP_Pos = 0x8
	// Bit mask of DISABLED_RSSISTOP field.
	RADIO_SHORTS_DISABLED_RSSISTOP_Msk = 0x100
	// Bit DISABLED_RSSISTOP.
	RADIO_SHORTS_DISABLED_RSSISTOP = 0x100
	// Disable shortcut
	RADIO_SHORTS_DISABLED_RSSISTOP_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_DISABLED_RSSISTOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	RADIO_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	RADIO_INTENSET_READY_Msk = 0x1
	// Bit READY.
	RADIO_INTENSET_READY = 0x1
	// Read: Disabled
	RADIO_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_READY_Enabled = 0x1
	// Enable
	RADIO_INTENSET_READY_Set = 0x1
	// Position of ADDRESS field.
	RADIO_INTENSET_ADDRESS_Pos = 0x1
	// Bit mask of ADDRESS field.
	RADIO_INTENSET_ADDRESS_Msk = 0x2
	// Bit ADDRESS.
	RADIO_INTENSET_ADDRESS = 0x2
	// Read: Disabled
	RADIO_INTENSET_ADDRESS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_ADDRESS_Enabled = 0x1
	// Enable
	RADIO_INTENSET_ADDRESS_Set = 0x1
	// Position of PAYLOAD field.
	RADIO_INTENSET_PAYLOAD_Pos = 0x2
	// Bit mask of PAYLOAD field.
	RADIO_INTENSET_PAYLOAD_Msk = 0x4
	// Bit PAYLOAD.
	RADIO_INTENSET_PAYLOAD = 0x4
	// Read: Disabled
	RADIO_INTENSET_PAYLOAD_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_PAYLOAD_Enabled = 0x1
	// Enable
	RADIO_INTENSET_PAYLOAD_Set = 0x1
	// Position of END field.
	RADIO_INTENSET_END_Pos = 0x3
	// Bit mask of END field.
	RADIO_INTENSET_END_Msk = 0x8
	// Bit END.
	RADIO_INTENSET_END = 0x8
	// Read: Disabled
	RADIO_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_END_Enabled = 0x1
	// Enable
	RADIO_INTENSET_END_Set = 0x1
	// Position of DISABLED field.
	RADIO_INTENSET_DISABLED_Pos = 0x4
	// Bit mask of DISABLED field.
	RADIO_INTENSET_DISABLED_Msk = 0x10
	// Bit DISABLED.
	RADIO_INTENSET_DISABLED = 0x10
	// Read: Disabled
	RADIO_INTENSET_DISABLED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_DISABLED_Enabled = 0x1
	// Enable
	RADIO_INTENSET_DISABLED_Set = 0x1
	// Position of DEVMATCH field.
	RADIO_INTENSET_DEVMATCH_Pos = 0x5
	// Bit mask of DEVMATCH field.
	RADIO_INTENSET_DEVMATCH_Msk = 0x20
	// Bit DEVMATCH.
	RADIO_INTENSET_DEVMATCH = 0x20
	// Read: Disabled
	RADIO_INTENSET_DEVMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_DEVMATCH_Enabled = 0x1
	// Enable
	RADIO_INTENSET_DEVMATCH_Set = 0x1
	// Position of DEVMISS field.
	RADIO_INTENSET_DEVMISS_Pos = 0x6
	// Bit mask of DEVMISS field.
	RADIO_INTENSET_DEVMISS_Msk = 0x40
	// Bit DEVMISS.
	RADIO_INTENSET_DEVMISS = 0x40
	// Read: Disabled
	RADIO_INTENSET_DEVMISS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_DEVMISS_Enabled = 0x1
	// Enable
	RADIO_INTENSET_DEVMISS_Set = 0x1
	// Position of RSSIEND field.
	RADIO_INTENSET_RSSIEND_Pos = 0x7
	// Bit mask of RSSIEND field.
	RADIO_INTENSET_RSSIEND_Msk = 0x80
	// Bit RSSIEND.
	RADIO_INTENSET_RSSIEND = 0x80
	// Read: Disabled
	RADIO_INTENSET_RSSIEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_RSSIEND_Enabled = 0x1
	// Enable
	RADIO_INTENSET_RSSIEND_Set = 0x1
	// Position of BCMATCH field.
	RADIO_INTENSET_BCMATCH_Pos = 0xa
	// Bit mask of BCMATCH field.
	RADIO_INTENSET_BCMATCH_Msk = 0x400
	// Bit BCMATCH.
	RADIO_INTENSET_BCMATCH = 0x400
	// Read: Disabled
	RADIO_INTENSET_BCMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_BCMATCH_Enabled = 0x1
	// Enable
	RADIO_INTENSET_BCMATCH_Set = 0x1
	// Position of CRCOK field.
	RADIO_INTENSET_CRCOK_Pos = 0xc
	// Bit mask of CRCOK field.
	RADIO_INTENSET_CRCOK_Msk = 0x1000
	// Bit CRCOK.
	RADIO_INTENSET_CRCOK = 0x1000
	// Read: Disabled
	RADIO_INTENSET_CRCOK_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CRCOK_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CRCOK_Set = 0x1
	// Position of CRCERROR field.
	RADIO_INTENSET_CRCERROR_Pos = 0xd
	// Bit mask of CRCERROR field.
	RADIO_INTENSET_CRCERROR_Msk = 0x2000
	// Bit CRCERROR.
	RADIO_INTENSET_CRCERROR = 0x2000
	// Read: Disabled
	RADIO_INTENSET_CRCERROR_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CRCERROR_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CRCERROR_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	RADIO_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	RADIO_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	RADIO_INTENCLR_READY = 0x1
	// Read: Disabled
	RADIO_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_READY_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_READY_Clear = 0x1
	// Position of ADDRESS field.
	RADIO_INTENCLR_ADDRESS_Pos = 0x1
	// Bit mask of ADDRESS field.
	RADIO_INTENCLR_ADDRESS_Msk = 0x2
	// Bit ADDRESS.
	RADIO_INTENCLR_ADDRESS = 0x2
	// Read: Disabled
	RADIO_INTENCLR_ADDRESS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_ADDRESS_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_ADDRESS_Clear = 0x1
	// Position of PAYLOAD field.
	RADIO_INTENCLR_PAYLOAD_Pos = 0x2
	// Bit mask of PAYLOAD field.
	RADIO_INTENCLR_PAYLOAD_Msk = 0x4
	// Bit PAYLOAD.
	RADIO_INTENCLR_PAYLOAD = 0x4
	// Read: Disabled
	RADIO_INTENCLR_PAYLOAD_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_PAYLOAD_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_PAYLOAD_Clear = 0x1
	// Position of END field.
	RADIO_INTENCLR_END_Pos = 0x3
	// Bit mask of END field.
	RADIO_INTENCLR_END_Msk = 0x8
	// Bit END.
	RADIO_INTENCLR_END = 0x8
	// Read: Disabled
	RADIO_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_END_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_END_Clear = 0x1
	// Position of DISABLED field.
	RADIO_INTENCLR_DISABLED_Pos = 0x4
	// Bit mask of DISABLED field.
	RADIO_INTENCLR_DISABLED_Msk = 0x10
	// Bit DISABLED.
	RADIO_INTENCLR_DISABLED = 0x10
	// Read: Disabled
	RADIO_INTENCLR_DISABLED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_DISABLED_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_DISABLED_Clear = 0x1
	// Position of DEVMATCH field.
	RADIO_INTENCLR_DEVMATCH_Pos = 0x5
	// Bit mask of DEVMATCH field.
	RADIO_INTENCLR_DEVMATCH_Msk = 0x20
	// Bit DEVMATCH.
	RADIO_INTENCLR_DEVMATCH = 0x20
	// Read: Disabled
	RADIO_INTENCLR_DEVMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_DEVMATCH_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_DEVMATCH_Clear = 0x1
	// Position of DEVMISS field.
	RADIO_INTENCLR_DEVMISS_Pos = 0x6
	// Bit mask of DEVMISS field.
	RADIO_INTENCLR_DEVMISS_Msk = 0x40
	// Bit DEVMISS.
	RADIO_INTENCLR_DEVMISS = 0x40
	// Read: Disabled
	RADIO_INTENCLR_DEVMISS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_DEVMISS_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_DEVMISS_Clear = 0x1
	// Position of RSSIEND field.
	RADIO_INTENCLR_RSSIEND_Pos = 0x7
	// Bit mask of RSSIEND field.
	RADIO_INTENCLR_RSSIEND_Msk = 0x80
	// Bit RSSIEND.
	RADIO_INTENCLR_RSSIEND = 0x80
	// Read: Disabled
	RADIO_INTENCLR_RSSIEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_RSSIEND_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_RSSIEND_Clear = 0x1
	// Position of BCMATCH field.
	RADIO_INTENCLR_BCMATCH_Pos = 0xa
	// Bit mask of BCMATCH field.
	RADIO_INTENCLR_BCMATCH_Msk = 0x400
	// Bit BCMATCH.
	RADIO_INTENCLR_BCMATCH = 0x400
	// Read: Disabled
	RADIO_INTENCLR_BCMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_BCMATCH_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_BCMATCH_Clear = 0x1
	// Position of CRCOK field.
	RADIO_INTENCLR_CRCOK_Pos = 0xc
	// Bit mask of CRCOK field.
	RADIO_INTENCLR_CRCOK_Msk = 0x1000
	// Bit CRCOK.
	RADIO_INTENCLR_CRCOK = 0x1000
	// Read: Disabled
	RADIO_INTENCLR_CRCOK_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CRCOK_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CRCOK_Clear = 0x1
	// Position of CRCERROR field.
	RADIO_INTENCLR_CRCERROR_Pos = 0xd
	// Bit mask of CRCERROR field.
	RADIO_INTENCLR_CRCERROR_Msk = 0x2000
	// Bit CRCERROR.
	RADIO_INTENCLR_CRCERROR = 0x2000
	// Read: Disabled
	RADIO_INTENCLR_CRCERROR_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CRCERROR_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CRCERROR_Clear = 0x1

	// CRCSTATUS: CRC status
	// Position of CRCSTATUS field.
	RADIO_CRCSTATUS_CRCSTATUS_Pos = 0x0
	// Bit mask of CRCSTATUS field.
	RADIO_CRCSTATUS_CRCSTATUS_Msk = 0x1
	// Bit CRCSTATUS.
	RADIO_CRCSTATUS_CRCSTATUS = 0x1
	// Packet received with CRC error
	RADIO_CRCSTATUS_CRCSTATUS_CRCError = 0x0
	// Packet received with CRC ok
	RADIO_CRCSTATUS_CRCSTATUS_CRCOk = 0x1

	// RXMATCH: Received address
	// Position of RXMATCH field.
	RADIO_RXMATCH_RXMATCH_Pos = 0x0
	// Bit mask of RXMATCH field.
	RADIO_RXMATCH_RXMATCH_Msk = 0x7

	// RXCRC: CRC field of previously received packet
	// Position of RXCRC field.
	RADIO_RXCRC_RXCRC_Pos = 0x0
	// Bit mask of RXCRC field.
	RADIO_RXCRC_RXCRC_Msk = 0xffffff

	// DAI: Device address match index
	// Position of DAI field.
	RADIO_DAI_DAI_Pos = 0x0
	// Bit mask of DAI field.
	RADIO_DAI_DAI_Msk = 0x7

	// PACKETPTR: Packet pointer
	// Position of PACKETPTR field.
	RADIO_PACKETPTR_PACKETPTR_Pos = 0x0
	// Bit mask of PACKETPTR field.
	RADIO_PACKETPTR_PACKETPTR_Msk = 0xffffffff

	// FREQUENCY: Frequency
	// Position of FREQUENCY field.
	RADIO_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	RADIO_FREQUENCY_FREQUENCY_Msk = 0x7f
	// Position of MAP field.
	RADIO_FREQUENCY_MAP_Pos = 0x8
	// Bit mask of MAP field.
	RADIO_FREQUENCY_MAP_Msk = 0x100
	// Bit MAP.
	RADIO_FREQUENCY_MAP = 0x100
	// Channel map between 2400 MHZ .. 2500 MHz
	RADIO_FREQUENCY_MAP_Default = 0x0
	// Channel map between 2360 MHZ .. 2460 MHz
	RADIO_FREQUENCY_MAP_Low = 0x1

	// TXPOWER: Output power
	// Position of TXPOWER field.
	RADIO_TXPOWER_TXPOWER_Pos = 0x0
	// Bit mask of TXPOWER field.
	RADIO_TXPOWER_TXPOWER_Msk = 0xff
	// +4 dBm
	RADIO_TXPOWER_TXPOWER_Pos4dBm = 0x4
	// +3 dBm
	RADIO_TXPOWER_TXPOWER_Pos3dBm = 0x3
	// 0 dBm
	RADIO_TXPOWER_TXPOWER_0dBm = 0x0
	// -4 dBm
	RADIO_TXPOWER_TXPOWER_Neg4dBm = 0xfc
	// -8 dBm
	RADIO_TXPOWER_TXPOWER_Neg8dBm = 0xf8
	// -12 dBm
	RADIO_TXPOWER_TXPOWER_Neg12dBm = 0xf4
	// -16 dBm
	RADIO_TXPOWER_TXPOWER_Neg16dBm = 0xf0
	// -20 dBm
	RADIO_TXPOWER_TXPOWER_Neg20dBm = 0xec
	// Deprecated enumerator - -40 dBm
	RADIO_TXPOWER_TXPOWER_Neg30dBm = 0xff
	// -40 dBm
	RADIO_TXPOWER_TXPOWER_Neg40dBm = 0xd8

	// MODE: Data rate and modulation
	// Position of MODE field.
	RADIO_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	RADIO_MODE_MODE_Msk = 0xf
	// 1 Mbit/s Nordic proprietary radio mode
	RADIO_MODE_MODE_Nrf_1Mbit = 0x0
	// 2 Mbit/s Nordic proprietary radio mode
	RADIO_MODE_MODE_Nrf_2Mbit = 0x1
	// Deprecated enumerator - 250 kbit/s Nordic proprietary radio mode
	RADIO_MODE_MODE_Nrf_250Kbit = 0x2
	// 1 Mbit/s Bluetooth Low Energy
	RADIO_MODE_MODE_Ble_1Mbit = 0x3
	// 2 Mbit/s Bluetooth Low Energy
	RADIO_MODE_MODE_Ble_2Mbit = 0x4

	// PCNF0: Packet configuration register 0
	// Position of LFLEN field.
	RADIO_PCNF0_LFLEN_Pos = 0x0
	// Bit mask of LFLEN field.
	RADIO_PCNF0_LFLEN_Msk = 0xf
	// Position of S0LEN field.
	RADIO_PCNF0_S0LEN_Pos = 0x8
	// Bit mask of S0LEN field.
	RADIO_PCNF0_S0LEN_Msk = 0x100
	// Bit S0LEN.
	RADIO_PCNF0_S0LEN = 0x100
	// Position of S1LEN field.
	RADIO_PCNF0_S1LEN_Pos = 0x10
	// Bit mask of S1LEN field.
	RADIO_PCNF0_S1LEN_Msk = 0xf0000
	// Position of S1INCL field.
	RADIO_PCNF0_S1INCL_Pos = 0x14
	// Bit mask of S1INCL field.
	RADIO_PCNF0_S1INCL_Msk = 0x100000
	// Bit S1INCL.
	RADIO_PCNF0_S1INCL = 0x100000
	// Include S1 field in RAM only if S1LEN &gt; 0
	RADIO_PCNF0_S1INCL_Automatic = 0x0
	// Always include S1 field in RAM independent of S1LEN
	RADIO_PCNF0_S1INCL_Include = 0x1
	// Position of PLEN field.
	RADIO_PCNF0_PLEN_Pos = 0x18
	// Bit mask of PLEN field.
	RADIO_PCNF0_PLEN_Msk = 0x1000000
	// Bit PLEN.
	RADIO_PCNF0_PLEN = 0x1000000
	// 8-bit preamble
	RADIO_PCNF0_PLEN_8bit = 0x0
	// 16-bit preamble
	RADIO_PCNF0_PLEN_16bit = 0x1

	// PCNF1: Packet configuration register 1
	// Position of MAXLEN field.
	RADIO_PCNF1_MAXLEN_Pos = 0x0
	// Bit mask of MAXLEN field.
	RADIO_PCNF1_MAXLEN_Msk = 0xff
	// Position of STATLEN field.
	RADIO_PCNF1_STATLEN_Pos = 0x8
	// Bit mask of STATLEN field.
	RADIO_PCNF1_STATLEN_Msk = 0xff00
	// Position of BALEN field.
	RADIO_PCNF1_BALEN_Pos = 0x10
	// Bit mask of BALEN field.
	RADIO_PCNF1_BALEN_Msk = 0x70000
	// Position of ENDIAN field.
	RADIO_PCNF1_ENDIAN_Pos = 0x18
	// Bit mask of ENDIAN field.
	RADIO_PCNF1_ENDIAN_Msk = 0x1000000
	// Bit ENDIAN.
	RADIO_PCNF1_ENDIAN = 0x1000000
	// Least Significant bit on air first
	RADIO_PCNF1_ENDIAN_Little = 0x0
	// Most significant bit on air first
	RADIO_PCNF1_ENDIAN_Big = 0x1
	// Position of WHITEEN field.
	RADIO_PCNF1_WHITEEN_Pos = 0x19
	// Bit mask of WHITEEN field.
	RADIO_PCNF1_WHITEEN_Msk = 0x2000000
	// Bit WHITEEN.
	RADIO_PCNF1_WHITEEN = 0x2000000
	// Disable
	RADIO_PCNF1_WHITEEN_Disabled = 0x0
	// Enable
	RADIO_PCNF1_WHITEEN_Enabled = 0x1

	// BASE0: Base address 0
	// Position of BASE0 field.
	RADIO_BASE0_BASE0_Pos = 0x0
	// Bit mask of BASE0 field.
	RADIO_BASE0_BASE0_Msk = 0xffffffff

	// BASE1: Base address 1
	// Position of BASE1 field.
	RADIO_BASE1_BASE1_Pos = 0x0
	// Bit mask of BASE1 field.
	RADIO_BASE1_BASE1_Msk = 0xffffffff

	// PREFIX0: Prefixes bytes for logical addresses 0-3
	// Position of AP0 field.
	RADIO_PREFIX0_AP0_Pos = 0x0
	// Bit mask of AP0 field.
	RADIO_PREFIX0_AP0_Msk = 0xff
	// Position of AP1 field.
	RADIO_PREFIX0_AP1_Pos = 0x8
	// Bit mask of AP1 field.
	RADIO_PREFIX0_AP1_Msk = 0xff00
	// Position of AP2 field.
	RADIO_PREFIX0_AP2_Pos = 0x10
	// Bit mask of AP2 field.
	RADIO_PREFIX0_AP2_Msk = 0xff0000
	// Position of AP3 field.
	RADIO_PREFIX0_AP3_Pos = 0x18
	// Bit mask of AP3 field.
	RADIO_PREFIX0_AP3_Msk = 0xff000000

	// PREFIX1: Prefixes bytes for logical addresses 4-7
	// Position of AP4 field.
	RADIO_PREFIX1_AP4_Pos = 0x0
	// Bit mask of AP4 field.
	RADIO_PREFIX1_AP4_Msk = 0xff
	// Position of AP5 field.
	RADIO_PREFIX1_AP5_Pos = 0x8
	// Bit mask of AP5 field.
	RADIO_PREFIX1_AP5_Msk = 0xff00
	// Position of AP6 field.
	RADIO_PREFIX1_AP6_Pos = 0x10
	// Bit mask of AP6 field.
	RADIO_PREFIX1_AP6_Msk = 0xff0000
	// Position of AP7 field.
	RADIO_PREFIX1_AP7_Pos = 0x18
	// Bit mask of AP7 field.
	RADIO_PREFIX1_AP7_Msk = 0xff000000

	// TXADDRESS: Transmit address select
	// Position of TXADDRESS field.
	RADIO_TXADDRESS_TXADDRESS_Pos = 0x0
	// Bit mask of TXADDRESS field.
	RADIO_TXADDRESS_TXADDRESS_Msk = 0x7

	// RXADDRESSES: Receive address select
	// Position of ADDR0 field.
	RADIO_RXADDRESSES_ADDR0_Pos = 0x0
	// Bit mask of ADDR0 field.
	RADIO_RXADDRESSES_ADDR0_Msk = 0x1
	// Bit ADDR0.
	RADIO_RXADDRESSES_ADDR0 = 0x1
	// Disable
	RADIO_RXADDRESSES_ADDR0_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR0_Enabled = 0x1
	// Position of ADDR1 field.
	RADIO_RXADDRESSES_ADDR1_Pos = 0x1
	// Bit mask of ADDR1 field.
	RADIO_RXADDRESSES_ADDR1_Msk = 0x2
	// Bit ADDR1.
	RADIO_RXADDRESSES_ADDR1 = 0x2
	// Disable
	RADIO_RXADDRESSES_ADDR1_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR1_Enabled = 0x1
	// Position of ADDR2 field.
	RADIO_RXADDRESSES_ADDR2_Pos = 0x2
	// Bit mask of ADDR2 field.
	RADIO_RXADDRESSES_ADDR2_Msk = 0x4
	// Bit ADDR2.
	RADIO_RXADDRESSES_ADDR2 = 0x4
	// Disable
	RADIO_RXADDRESSES_ADDR2_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR2_Enabled = 0x1
	// Position of ADDR3 field.
	RADIO_RXADDRESSES_ADDR3_Pos = 0x3
	// Bit mask of ADDR3 field.
	RADIO_RXADDRESSES_ADDR3_Msk = 0x8
	// Bit ADDR3.
	RADIO_RXADDRESSES_ADDR3 = 0x8
	// Disable
	RADIO_RXADDRESSES_ADDR3_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR3_Enabled = 0x1
	// Position of ADDR4 field.
	RADIO_RXADDRESSES_ADDR4_Pos = 0x4
	// Bit mask of ADDR4 field.
	RADIO_RXADDRESSES_ADDR4_Msk = 0x10
	// Bit ADDR4.
	RADIO_RXADDRESSES_ADDR4 = 0x10
	// Disable
	RADIO_RXADDRESSES_ADDR4_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR4_Enabled = 0x1
	// Position of ADDR5 field.
	RADIO_RXADDRESSES_ADDR5_Pos = 0x5
	// Bit mask of ADDR5 field.
	RADIO_RXADDRESSES_ADDR5_Msk = 0x20
	// Bit ADDR5.
	RADIO_RXADDRESSES_ADDR5 = 0x20
	// Disable
	RADIO_RXADDRESSES_ADDR5_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR5_Enabled = 0x1
	// Position of ADDR6 field.
	RADIO_RXADDRESSES_ADDR6_Pos = 0x6
	// Bit mask of ADDR6 field.
	RADIO_RXADDRESSES_ADDR6_Msk = 0x40
	// Bit ADDR6.
	RADIO_RXADDRESSES_ADDR6 = 0x40
	// Disable
	RADIO_RXADDRESSES_ADDR6_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR6_Enabled = 0x1
	// Position of ADDR7 field.
	RADIO_RXADDRESSES_ADDR7_Pos = 0x7
	// Bit mask of ADDR7 field.
	RADIO_RXADDRESSES_ADDR7_Msk = 0x80
	// Bit ADDR7.
	RADIO_RXADDRESSES_ADDR7 = 0x80
	// Disable
	RADIO_RXADDRESSES_ADDR7_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR7_Enabled = 0x1

	// CRCCNF: CRC configuration
	// Position of LEN field.
	RADIO_CRCCNF_LEN_Pos = 0x0
	// Bit mask of LEN field.
	RADIO_CRCCNF_LEN_Msk = 0x3
	// CRC length is zero and CRC calculation is disabled
	RADIO_CRCCNF_LEN_Disabled = 0x0
	// CRC length is one byte and CRC calculation is enabled
	RADIO_CRCCNF_LEN_One = 0x1
	// CRC length is two bytes and CRC calculation is enabled
	RADIO_CRCCNF_LEN_Two = 0x2
	// CRC length is three bytes and CRC calculation is enabled
	RADIO_CRCCNF_LEN_Three = 0x3
	// Position of SKIPADDR field.
	RADIO_CRCCNF_SKIPADDR_Pos = 0x8
	// Bit mask of SKIPADDR field.
	RADIO_CRCCNF_SKIPADDR_Msk = 0x100
	// Bit SKIPADDR.
	RADIO_CRCCNF_SKIPADDR = 0x100
	// CRC calculation includes address field
	RADIO_CRCCNF_SKIPADDR_Include = 0x0
	// CRC calculation does not include address field. The CRC calculation will start at the first byte after the address.
	RADIO_CRCCNF_SKIPADDR_Skip = 0x1

	// CRCPOLY: CRC polynomial
	// Position of CRCPOLY field.
	RADIO_CRCPOLY_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	RADIO_CRCPOLY_CRCPOLY_Msk = 0xffffff

	// CRCINIT: CRC initial value
	// Position of CRCINIT field.
	RADIO_CRCINIT_CRCINIT_Pos = 0x0
	// Bit mask of CRCINIT field.
	RADIO_CRCINIT_CRCINIT_Msk = 0xffffff

	// TIFS: Inter Frame Spacing in us
	// Position of TIFS field.
	RADIO_TIFS_TIFS_Pos = 0x0
	// Bit mask of TIFS field.
	RADIO_TIFS_TIFS_Msk = 0xff

	// RSSISAMPLE: RSSI sample
	// Position of RSSISAMPLE field.
	RADIO_RSSISAMPLE_RSSISAMPLE_Pos = 0x0
	// Bit mask of RSSISAMPLE field.
	RADIO_RSSISAMPLE_RSSISAMPLE_Msk = 0x7f

	// STATE: Current radio state
	// Position of STATE field.
	RADIO_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	RADIO_STATE_STATE_Msk = 0xf
	// RADIO is in the Disabled state
	RADIO_STATE_STATE_Disabled = 0x0
	// RADIO is in the RXRU state
	RADIO_STATE_STATE_RxRu = 0x1
	// RADIO is in the RXIDLE state
	RADIO_STATE_STATE_RxIdle = 0x2
	// RADIO is in the RX state
	RADIO_STATE_STATE_Rx = 0x3
	// RADIO is in the RXDISABLED state
	RADIO_STATE_STATE_RxDisable = 0x4
	// RADIO is in the TXRU state
	RADIO_STATE_STATE_TxRu = 0x9
	// RADIO is in the TXIDLE state
	RADIO_STATE_STATE_TxIdle = 0xa
	// RADIO is in the TX state
	RADIO_STATE_STATE_Tx = 0xb
	// RADIO is in the TXDISABLED state
	RADIO_STATE_STATE_TxDisable = 0xc

	// DATAWHITEIV: Data whitening initial value
	// Position of DATAWHITEIV field.
	RADIO_DATAWHITEIV_DATAWHITEIV_Pos = 0x0
	// Bit mask of DATAWHITEIV field.
	RADIO_DATAWHITEIV_DATAWHITEIV_Msk = 0x7f

	// BCC: Bit counter compare
	// Position of BCC field.
	RADIO_BCC_BCC_Pos = 0x0
	// Bit mask of BCC field.
	RADIO_BCC_BCC_Msk = 0xffffffff

	// DAB: Description collection[0]: Device address base segment 0
	// Position of DAB field.
	RADIO_DAB_DAB_Pos = 0x0
	// Bit mask of DAB field.
	RADIO_DAB_DAB_Msk = 0xffffffff

	// DAP: Description collection[0]: Device address prefix 0
	// Position of DAP field.
	RADIO_DAP_DAP_Pos = 0x0
	// Bit mask of DAP field.
	RADIO_DAP_DAP_Msk = 0xffff

	// DACNF: Device address match configuration
	// Position of ENA0 field.
	RADIO_DACNF_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	RADIO_DACNF_ENA0_Msk = 0x1
	// Bit ENA0.
	RADIO_DACNF_ENA0 = 0x1
	// Disabled
	RADIO_DACNF_ENA0_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA0_Enabled = 0x1
	// Position of ENA1 field.
	RADIO_DACNF_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	RADIO_DACNF_ENA1_Msk = 0x2
	// Bit ENA1.
	RADIO_DACNF_ENA1 = 0x2
	// Disabled
	RADIO_DACNF_ENA1_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA1_Enabled = 0x1
	// Position of ENA2 field.
	RADIO_DACNF_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	RADIO_DACNF_ENA2_Msk = 0x4
	// Bit ENA2.
	RADIO_DACNF_ENA2 = 0x4
	// Disabled
	RADIO_DACNF_ENA2_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA2_Enabled = 0x1
	// Position of ENA3 field.
	RADIO_DACNF_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	RADIO_DACNF_ENA3_Msk = 0x8
	// Bit ENA3.
	RADIO_DACNF_ENA3 = 0x8
	// Disabled
	RADIO_DACNF_ENA3_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA3_Enabled = 0x1
	// Position of ENA4 field.
	RADIO_DACNF_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	RADIO_DACNF_ENA4_Msk = 0x10
	// Bit ENA4.
	RADIO_DACNF_ENA4 = 0x10
	// Disabled
	RADIO_DACNF_ENA4_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA4_Enabled = 0x1
	// Position of ENA5 field.
	RADIO_DACNF_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	RADIO_DACNF_ENA5_Msk = 0x20
	// Bit ENA5.
	RADIO_DACNF_ENA5 = 0x20
	// Disabled
	RADIO_DACNF_ENA5_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA5_Enabled = 0x1
	// Position of ENA6 field.
	RADIO_DACNF_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	RADIO_DACNF_ENA6_Msk = 0x40
	// Bit ENA6.
	RADIO_DACNF_ENA6 = 0x40
	// Disabled
	RADIO_DACNF_ENA6_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA6_Enabled = 0x1
	// Position of ENA7 field.
	RADIO_DACNF_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	RADIO_DACNF_ENA7_Msk = 0x80
	// Bit ENA7.
	RADIO_DACNF_ENA7 = 0x80
	// Disabled
	RADIO_DACNF_ENA7_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA7_Enabled = 0x1
	// Position of TXADD0 field.
	RADIO_DACNF_TXADD0_Pos = 0x8
	// Bit mask of TXADD0 field.
	RADIO_DACNF_TXADD0_Msk = 0x100
	// Bit TXADD0.
	RADIO_DACNF_TXADD0 = 0x100
	// Position of TXADD1 field.
	RADIO_DACNF_TXADD1_Pos = 0x9
	// Bit mask of TXADD1 field.
	RADIO_DACNF_TXADD1_Msk = 0x200
	// Bit TXADD1.
	RADIO_DACNF_TXADD1 = 0x200
	// Position of TXADD2 field.
	RADIO_DACNF_TXADD2_Pos = 0xa
	// Bit mask of TXADD2 field.
	RADIO_DACNF_TXADD2_Msk = 0x400
	// Bit TXADD2.
	RADIO_DACNF_TXADD2 = 0x400
	// Position of TXADD3 field.
	RADIO_DACNF_TXADD3_Pos = 0xb
	// Bit mask of TXADD3 field.
	RADIO_DACNF_TXADD3_Msk = 0x800
	// Bit TXADD3.
	RADIO_DACNF_TXADD3 = 0x800
	// Position of TXADD4 field.
	RADIO_DACNF_TXADD4_Pos = 0xc
	// Bit mask of TXADD4 field.
	RADIO_DACNF_TXADD4_Msk = 0x1000
	// Bit TXADD4.
	RADIO_DACNF_TXADD4 = 0x1000
	// Position of TXADD5 field.
	RADIO_DACNF_TXADD5_Pos = 0xd
	// Bit mask of TXADD5 field.
	RADIO_DACNF_TXADD5_Msk = 0x2000
	// Bit TXADD5.
	RADIO_DACNF_TXADD5 = 0x2000
	// Position of TXADD6 field.
	RADIO_DACNF_TXADD6_Pos = 0xe
	// Bit mask of TXADD6 field.
	RADIO_DACNF_TXADD6_Msk = 0x4000
	// Bit TXADD6.
	RADIO_DACNF_TXADD6 = 0x4000
	// Position of TXADD7 field.
	RADIO_DACNF_TXADD7_Pos = 0xf
	// Bit mask of TXADD7 field.
	RADIO_DACNF_TXADD7_Msk = 0x8000
	// Bit TXADD7.
	RADIO_DACNF_TXADD7 = 0x8000

	// MODECNF0: Radio mode configuration register 0
	// Position of RU field.
	RADIO_MODECNF0_RU_Pos = 0x0
	// Bit mask of RU field.
	RADIO_MODECNF0_RU_Msk = 0x1
	// Bit RU.
	RADIO_MODECNF0_RU = 0x1
	// Default ramp-up time (tRXEN), compatible with firmware written for nRF51
	RADIO_MODECNF0_RU_Default = 0x0
	// Fast ramp-up (tRXEN,FAST), see electrical specification for more information
	RADIO_MODECNF0_RU_Fast = 0x1
	// Position of DTX field.
	RADIO_MODECNF0_DTX_Pos = 0x8
	// Bit mask of DTX field.
	RADIO_MODECNF0_DTX_Msk = 0x300
	// Transmit '1'
	RADIO_MODECNF0_DTX_B1 = 0x0
	// Transmit '0'
	RADIO_MODECNF0_DTX_B0 = 0x1
	// Transmit center frequency
	RADIO_MODECNF0_DTX_Center = 0x2

	// POWER: Peripheral power control
	// Position of POWER field.
	RADIO_POWER_POWER_Pos = 0x0
	// Bit mask of POWER field.
	RADIO_POWER_POWER_Msk = 0x1
	// Bit POWER.
	RADIO_POWER_POWER = 0x1
	// Peripheral is powered off
	RADIO_POWER_POWER_Disabled = 0x0
	// Peripheral is powered on
	RADIO_POWER_POWER_Enabled = 0x1
)

// Constants for UARTE0: UART with EasyDMA
const (
	// SHORTS: Shortcut register
	// Position of ENDRX_STARTRX field.
	UARTE_SHORTS_ENDRX_STARTRX_Pos = 0x5
	// Bit mask of ENDRX_STARTRX field.
	UARTE_SHORTS_ENDRX_STARTRX_Msk = 0x20
	// Bit ENDRX_STARTRX.
	UARTE_SHORTS_ENDRX_STARTRX = 0x20
	// Disable shortcut
	UARTE_SHORTS_ENDRX_STARTRX_Disabled = 0x0
	// Enable shortcut
	UARTE_SHORTS_ENDRX_STARTRX_Enabled = 0x1
	// Position of ENDRX_STOPRX field.
	UARTE_SHORTS_ENDRX_STOPRX_Pos = 0x6
	// Bit mask of ENDRX_STOPRX field.
	UARTE_SHORTS_ENDRX_STOPRX_Msk = 0x40
	// Bit ENDRX_STOPRX.
	UARTE_SHORTS_ENDRX_STOPRX = 0x40
	// Disable shortcut
	UARTE_SHORTS_ENDRX_STOPRX_Disabled = 0x0
	// Enable shortcut
	UARTE_SHORTS_ENDRX_STOPRX_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of CTS field.
	UARTE_INTEN_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTEN_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTEN_CTS = 0x1
	// Disable
	UARTE_INTEN_CTS_Disabled = 0x0
	// Enable
	UARTE_INTEN_CTS_Enabled = 0x1
	// Position of NCTS field.
	UARTE_INTEN_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTEN_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTEN_NCTS = 0x2
	// Disable
	UARTE_INTEN_NCTS_Disabled = 0x0
	// Enable
	UARTE_INTEN_NCTS_Enabled = 0x1
	// Position of RXDRDY field.
	UARTE_INTEN_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTEN_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTEN_RXDRDY = 0x4
	// Disable
	UARTE_INTEN_RXDRDY_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXDRDY_Enabled = 0x1
	// Position of ENDRX field.
	UARTE_INTEN_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTEN_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTEN_ENDRX = 0x10
	// Disable
	UARTE_INTEN_ENDRX_Disabled = 0x0
	// Enable
	UARTE_INTEN_ENDRX_Enabled = 0x1
	// Position of TXDRDY field.
	UARTE_INTEN_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTEN_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTEN_TXDRDY = 0x80
	// Disable
	UARTE_INTEN_TXDRDY_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXDRDY_Enabled = 0x1
	// Position of ENDTX field.
	UARTE_INTEN_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTEN_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTEN_ENDTX = 0x100
	// Disable
	UARTE_INTEN_ENDTX_Disabled = 0x0
	// Enable
	UARTE_INTEN_ENDTX_Enabled = 0x1
	// Position of ERROR field.
	UARTE_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTEN_ERROR = 0x200
	// Disable
	UARTE_INTEN_ERROR_Disabled = 0x0
	// Enable
	UARTE_INTEN_ERROR_Enabled = 0x1
	// Position of RXTO field.
	UARTE_INTEN_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTEN_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTEN_RXTO = 0x20000
	// Disable
	UARTE_INTEN_RXTO_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXTO_Enabled = 0x1
	// Position of RXSTARTED field.
	UARTE_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTEN_RXSTARTED = 0x80000
	// Disable
	UARTE_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	UARTE_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTEN_TXSTARTED = 0x100000
	// Disable
	UARTE_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXSTARTED_Enabled = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTEN_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTEN_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTEN_TXSTOPPED = 0x400000
	// Disable
	UARTE_INTEN_TXSTOPPED_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXSTOPPED_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of CTS field.
	UARTE_INTENSET_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTENSET_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTENSET_CTS = 0x1
	// Read: Disabled
	UARTE_INTENSET_CTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_CTS_Enabled = 0x1
	// Enable
	UARTE_INTENSET_CTS_Set = 0x1
	// Position of NCTS field.
	UARTE_INTENSET_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTENSET_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTENSET_NCTS = 0x2
	// Read: Disabled
	UARTE_INTENSET_NCTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_NCTS_Enabled = 0x1
	// Enable
	UARTE_INTENSET_NCTS_Set = 0x1
	// Position of RXDRDY field.
	UARTE_INTENSET_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTENSET_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTENSET_RXDRDY = 0x4
	// Read: Disabled
	UARTE_INTENSET_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXDRDY_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXDRDY_Set = 0x1
	// Position of ENDRX field.
	UARTE_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTENSET_ENDRX = 0x10
	// Read: Disabled
	UARTE_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ENDRX_Set = 0x1
	// Position of TXDRDY field.
	UARTE_INTENSET_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTENSET_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTENSET_TXDRDY = 0x80
	// Read: Disabled
	UARTE_INTENSET_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXDRDY_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXDRDY_Set = 0x1
	// Position of ENDTX field.
	UARTE_INTENSET_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTENSET_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTENSET_ENDTX = 0x100
	// Read: Disabled
	UARTE_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ENDTX_Set = 0x1
	// Position of ERROR field.
	UARTE_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTENSET_ERROR = 0x200
	// Read: Disabled
	UARTE_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ERROR_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ERROR_Set = 0x1
	// Position of RXTO field.
	UARTE_INTENSET_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTENSET_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTENSET_RXTO = 0x20000
	// Read: Disabled
	UARTE_INTENSET_RXTO_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXTO_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXTO_Set = 0x1
	// Position of RXSTARTED field.
	UARTE_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	UARTE_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	UARTE_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	UARTE_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXSTARTED_Set = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTENSET_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTENSET_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTENSET_TXSTOPPED = 0x400000
	// Read: Disabled
	UARTE_INTENSET_TXSTOPPED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXSTOPPED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXSTOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of CTS field.
	UARTE_INTENCLR_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTENCLR_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTENCLR_CTS = 0x1
	// Read: Disabled
	UARTE_INTENCLR_CTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_CTS_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_CTS_Clear = 0x1
	// Position of NCTS field.
	UARTE_INTENCLR_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTENCLR_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTENCLR_NCTS = 0x2
	// Read: Disabled
	UARTE_INTENCLR_NCTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_NCTS_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_NCTS_Clear = 0x1
	// Position of RXDRDY field.
	UARTE_INTENCLR_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTENCLR_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTENCLR_RXDRDY = 0x4
	// Read: Disabled
	UARTE_INTENCLR_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXDRDY_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXDRDY_Clear = 0x1
	// Position of ENDRX field.
	UARTE_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	UARTE_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ENDRX_Clear = 0x1
	// Position of TXDRDY field.
	UARTE_INTENCLR_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTENCLR_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTENCLR_TXDRDY = 0x80
	// Read: Disabled
	UARTE_INTENCLR_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXDRDY_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXDRDY_Clear = 0x1
	// Position of ENDTX field.
	UARTE_INTENCLR_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTENCLR_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTENCLR_ENDTX = 0x100
	// Read: Disabled
	UARTE_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ENDTX_Clear = 0x1
	// Position of ERROR field.
	UARTE_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTENCLR_ERROR = 0x200
	// Read: Disabled
	UARTE_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ERROR_Clear = 0x1
	// Position of RXTO field.
	UARTE_INTENCLR_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTENCLR_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTENCLR_RXTO = 0x20000
	// Read: Disabled
	UARTE_INTENCLR_RXTO_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXTO_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXTO_Clear = 0x1
	// Position of RXSTARTED field.
	UARTE_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	UARTE_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	UARTE_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	UARTE_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTENCLR_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTENCLR_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTENCLR_TXSTOPPED = 0x400000
	// Read: Disabled
	UARTE_INTENCLR_TXSTOPPED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXSTOPPED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXSTOPPED_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	UARTE_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	UARTE_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	UARTE_ERRORSRC_OVERRUN = 0x1
	// Read: error not present
	UARTE_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_OVERRUN_Present = 0x1
	// Position of PARITY field.
	UARTE_ERRORSRC_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UARTE_ERRORSRC_PARITY_Msk = 0x2
	// Bit PARITY.
	UARTE_ERRORSRC_PARITY = 0x2
	// Read: error not present
	UARTE_ERRORSRC_PARITY_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_PARITY_Present = 0x1
	// Position of FRAMING field.
	UARTE_ERRORSRC_FRAMING_Pos = 0x2
	// Bit mask of FRAMING field.
	UARTE_ERRORSRC_FRAMING_Msk = 0x4
	// Bit FRAMING.
	UARTE_ERRORSRC_FRAMING = 0x4
	// Read: error not present
	UARTE_ERRORSRC_FRAMING_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_FRAMING_Present = 0x1
	// Position of BREAK field.
	UARTE_ERRORSRC_BREAK_Pos = 0x3
	// Bit mask of BREAK field.
	UARTE_ERRORSRC_BREAK_Msk = 0x8
	// Bit BREAK.
	UARTE_ERRORSRC_BREAK = 0x8
	// Read: error not present
	UARTE_ERRORSRC_BREAK_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_BREAK_Present = 0x1

	// ENABLE: Enable UART
	// Position of ENABLE field.
	UARTE_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	UARTE_ENABLE_ENABLE_Msk = 0xf
	// Disable UARTE
	UARTE_ENABLE_ENABLE_Disabled = 0x0
	// Enable UARTE
	UARTE_ENABLE_ENABLE_Enabled = 0x8

	// PSEL.RTS: Pin select for RTS signal
	// Position of PIN field.
	UARTE_PSEL_RTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_RTS_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_RTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_RTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_RTS_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_RTS_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_RTS_CONNECT_Connected = 0x0

	// PSEL.TXD: Pin select for TXD signal
	// Position of PIN field.
	UARTE_PSEL_TXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_TXD_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_TXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_TXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_TXD_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_TXD_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_TXD_CONNECT_Connected = 0x0

	// PSEL.CTS: Pin select for CTS signal
	// Position of PIN field.
	UARTE_PSEL_CTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_CTS_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_CTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_CTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_CTS_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_CTS_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_CTS_CONNECT_Connected = 0x0

	// PSEL.RXD: Pin select for RXD signal
	// Position of PIN field.
	UARTE_PSEL_RXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_RXD_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_RXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_RXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_RXD_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_RXD_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_RXD_CONNECT_Connected = 0x0

	// BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
	// Position of BAUDRATE field.
	UARTE_BAUDRATE_BAUDRATE_Pos = 0x0
	// Bit mask of BAUDRATE field.
	UARTE_BAUDRATE_BAUDRATE_Msk = 0xffffffff
	// 1200 baud (actual rate: 1205)
	UARTE_BAUDRATE_BAUDRATE_Baud1200 = 0x4f000
	// 2400 baud (actual rate: 2396)
	UARTE_BAUDRATE_BAUDRATE_Baud2400 = 0x9d000
	// 4800 baud (actual rate: 4808)
	UARTE_BAUDRATE_BAUDRATE_Baud4800 = 0x13b000
	// 9600 baud (actual rate: 9598)
	UARTE_BAUDRATE_BAUDRATE_Baud9600 = 0x275000
	// 14400 baud (actual rate: 14401)
	UARTE_BAUDRATE_BAUDRATE_Baud14400 = 0x3af000
	// 19200 baud (actual rate: 19208)
	UARTE_BAUDRATE_BAUDRATE_Baud19200 = 0x4ea000
	// 28800 baud (actual rate: 28777)
	UARTE_BAUDRATE_BAUDRATE_Baud28800 = 0x75c000
	// 31250 baud
	UARTE_BAUDRATE_BAUDRATE_Baud31250 = 0x800000
	// 38400 baud (actual rate: 38369)
	UARTE_BAUDRATE_BAUDRATE_Baud38400 = 0x9d0000
	// 56000 baud (actual rate: 55944)
	UARTE_BAUDRATE_BAUDRATE_Baud56000 = 0xe50000
	// 57600 baud (actual rate: 57554)
	UARTE_BAUDRATE_BAUDRATE_Baud57600 = 0xeb0000
	// 76800 baud (actual rate: 76923)
	UARTE_BAUDRATE_BAUDRATE_Baud76800 = 0x13a9000
	// 115200 baud (actual rate: 115108)
	UARTE_BAUDRATE_BAUDRATE_Baud115200 = 0x1d60000
	// 230400 baud (actual rate: 231884)
	UARTE_BAUDRATE_BAUDRATE_Baud230400 = 0x3b00000
	// 250000 baud
	UARTE_BAUDRATE_BAUDRATE_Baud250000 = 0x4000000
	// 460800 baud (actual rate: 457143)
	UARTE_BAUDRATE_BAUDRATE_Baud460800 = 0x7400000
	// 921600 baud (actual rate: 941176)
	UARTE_BAUDRATE_BAUDRATE_Baud921600 = 0xf000000
	// 1Mega baud
	UARTE_BAUDRATE_BAUDRATE_Baud1M = 0x10000000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	UARTE_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	UARTE_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	UARTE_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	UARTE_RXD_MAXCNT_MAXCNT_Msk = 0xff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	UARTE_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	UARTE_RXD_AMOUNT_AMOUNT_Msk = 0xff

	// TXD.PTR: Data pointer
	// Position of PTR field.
	UARTE_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	UARTE_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	UARTE_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	UARTE_TXD_MAXCNT_MAXCNT_Msk = 0xff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	UARTE_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	UARTE_TXD_AMOUNT_AMOUNT_Msk = 0xff

	// CONFIG: Configuration of parity and hardware flow control
	// Position of HWFC field.
	UARTE_CONFIG_HWFC_Pos = 0x0
	// Bit mask of HWFC field.
	UARTE_CONFIG_HWFC_Msk = 0x1
	// Bit HWFC.
	UARTE_CONFIG_HWFC = 0x1
	// Disabled
	UARTE_CONFIG_HWFC_Disabled = 0x0
	// Enabled
	UARTE_CONFIG_HWFC_Enabled = 0x1
	// Position of PARITY field.
	UARTE_CONFIG_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UARTE_CONFIG_PARITY_Msk = 0xe
	// Exclude parity bit
	UARTE_CONFIG_PARITY_Excluded = 0x0
	// Include parity bit
	UARTE_CONFIG_PARITY_Included = 0x7
)

// Constants for UART0: Universal Asynchronous Receiver/Transmitter
const (
	// SHORTS: Shortcut register
	// Position of CTS_STARTRX field.
	UART_SHORTS_CTS_STARTRX_Pos = 0x3
	// Bit mask of CTS_STARTRX field.
	UART_SHORTS_CTS_STARTRX_Msk = 0x8
	// Bit CTS_STARTRX.
	UART_SHORTS_CTS_STARTRX = 0x8
	// Disable shortcut
	UART_SHORTS_CTS_STARTRX_Disabled = 0x0
	// Enable shortcut
	UART_SHORTS_CTS_STARTRX_Enabled = 0x1
	// Position of NCTS_STOPRX field.
	UART_SHORTS_NCTS_STOPRX_Pos = 0x4
	// Bit mask of NCTS_STOPRX field.
	UART_SHORTS_NCTS_STOPRX_Msk = 0x10
	// Bit NCTS_STOPRX.
	UART_SHORTS_NCTS_STOPRX = 0x10
	// Disable shortcut
	UART_SHORTS_NCTS_STOPRX_Disabled = 0x0
	// Enable shortcut
	UART_SHORTS_NCTS_STOPRX_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of CTS field.
	UART_INTENSET_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UART_INTENSET_CTS_Msk = 0x1
	// Bit CTS.
	UART_INTENSET_CTS = 0x1
	// Read: Disabled
	UART_INTENSET_CTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_CTS_Enabled = 0x1
	// Enable
	UART_INTENSET_CTS_Set = 0x1
	// Position of NCTS field.
	UART_INTENSET_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UART_INTENSET_NCTS_Msk = 0x2
	// Bit NCTS.
	UART_INTENSET_NCTS = 0x2
	// Read: Disabled
	UART_INTENSET_NCTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_NCTS_Enabled = 0x1
	// Enable
	UART_INTENSET_NCTS_Set = 0x1
	// Position of RXDRDY field.
	UART_INTENSET_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UART_INTENSET_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UART_INTENSET_RXDRDY = 0x4
	// Read: Disabled
	UART_INTENSET_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_RXDRDY_Enabled = 0x1
	// Enable
	UART_INTENSET_RXDRDY_Set = 0x1
	// Position of TXDRDY field.
	UART_INTENSET_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UART_INTENSET_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UART_INTENSET_TXDRDY = 0x80
	// Read: Disabled
	UART_INTENSET_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_TXDRDY_Enabled = 0x1
	// Enable
	UART_INTENSET_TXDRDY_Set = 0x1
	// Position of ERROR field.
	UART_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UART_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	UART_INTENSET_ERROR = 0x200
	// Read: Disabled
	UART_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_ERROR_Enabled = 0x1
	// Enable
	UART_INTENSET_ERROR_Set = 0x1
	// Position of RXTO field.
	UART_INTENSET_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UART_INTENSET_RXTO_Msk = 0x20000
	// Bit RXTO.
	UART_INTENSET_RXTO = 0x20000
	// Read: Disabled
	UART_INTENSET_RXTO_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_RXTO_Enabled = 0x1
	// Enable
	UART_INTENSET_RXTO_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of CTS field.
	UART_INTENCLR_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UART_INTENCLR_CTS_Msk = 0x1
	// Bit CTS.
	UART_INTENCLR_CTS = 0x1
	// Read: Disabled
	UART_INTENCLR_CTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_CTS_Enabled = 0x1
	// Disable
	UART_INTENCLR_CTS_Clear = 0x1
	// Position of NCTS field.
	UART_INTENCLR_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UART_INTENCLR_NCTS_Msk = 0x2
	// Bit NCTS.
	UART_INTENCLR_NCTS = 0x2
	// Read: Disabled
	UART_INTENCLR_NCTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_NCTS_Enabled = 0x1
	// Disable
	UART_INTENCLR_NCTS_Clear = 0x1
	// Position of RXDRDY field.
	UART_INTENCLR_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UART_INTENCLR_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UART_INTENCLR_RXDRDY = 0x4
	// Read: Disabled
	UART_INTENCLR_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_RXDRDY_Enabled = 0x1
	// Disable
	UART_INTENCLR_RXDRDY_Clear = 0x1
	// Position of TXDRDY field.
	UART_INTENCLR_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UART_INTENCLR_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UART_INTENCLR_TXDRDY = 0x80
	// Read: Disabled
	UART_INTENCLR_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_TXDRDY_Enabled = 0x1
	// Disable
	UART_INTENCLR_TXDRDY_Clear = 0x1
	// Position of ERROR field.
	UART_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UART_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	UART_INTENCLR_ERROR = 0x200
	// Read: Disabled
	UART_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	UART_INTENCLR_ERROR_Clear = 0x1
	// Position of RXTO field.
	UART_INTENCLR_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UART_INTENCLR_RXTO_Msk = 0x20000
	// Bit RXTO.
	UART_INTENCLR_RXTO = 0x20000
	// Read: Disabled
	UART_INTENCLR_RXTO_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_RXTO_Enabled = 0x1
	// Disable
	UART_INTENCLR_RXTO_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	UART_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	UART_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	UART_ERRORSRC_OVERRUN = 0x1
	// Read: error not present
	UART_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_OVERRUN_Present = 0x1
	// Position of PARITY field.
	UART_ERRORSRC_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UART_ERRORSRC_PARITY_Msk = 0x2
	// Bit PARITY.
	UART_ERRORSRC_PARITY = 0x2
	// Read: error not present
	UART_ERRORSRC_PARITY_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_PARITY_Present = 0x1
	// Position of FRAMING field.
	UART_ERRORSRC_FRAMING_Pos = 0x2
	// Bit mask of FRAMING field.
	UART_ERRORSRC_FRAMING_Msk = 0x4
	// Bit FRAMING.
	UART_ERRORSRC_FRAMING = 0x4
	// Read: error not present
	UART_ERRORSRC_FRAMING_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_FRAMING_Present = 0x1
	// Position of BREAK field.
	UART_ERRORSRC_BREAK_Pos = 0x3
	// Bit mask of BREAK field.
	UART_ERRORSRC_BREAK_Msk = 0x8
	// Bit BREAK.
	UART_ERRORSRC_BREAK = 0x8
	// Read: error not present
	UART_ERRORSRC_BREAK_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_BREAK_Present = 0x1

	// ENABLE: Enable UART
	// Position of ENABLE field.
	UART_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	UART_ENABLE_ENABLE_Msk = 0xf
	// Disable UART
	UART_ENABLE_ENABLE_Disabled = 0x0
	// Enable UART
	UART_ENABLE_ENABLE_Enabled = 0x4

	// PSELRTS: Pin select for RTS
	// Position of PSELRTS field.
	UART_PSELRTS_PSELRTS_Pos = 0x0
	// Bit mask of PSELRTS field.
	UART_PSELRTS_PSELRTS_Msk = 0xffffffff
	// Disconnect
	UART_PSELRTS_PSELRTS_Disconnected = 0xffffffff

	// PSELTXD: Pin select for TXD
	// Position of PSELTXD field.
	UART_PSELTXD_PSELTXD_Pos = 0x0
	// Bit mask of PSELTXD field.
	UART_PSELTXD_PSELTXD_Msk = 0xffffffff
	// Disconnect
	UART_PSELTXD_PSELTXD_Disconnected = 0xffffffff

	// PSELCTS: Pin select for CTS
	// Position of PSELCTS field.
	UART_PSELCTS_PSELCTS_Pos = 0x0
	// Bit mask of PSELCTS field.
	UART_PSELCTS_PSELCTS_Msk = 0xffffffff
	// Disconnect
	UART_PSELCTS_PSELCTS_Disconnected = 0xffffffff

	// PSELRXD: Pin select for RXD
	// Position of PSELRXD field.
	UART_PSELRXD_PSELRXD_Pos = 0x0
	// Bit mask of PSELRXD field.
	UART_PSELRXD_PSELRXD_Msk = 0xffffffff
	// Disconnect
	UART_PSELRXD_PSELRXD_Disconnected = 0xffffffff

	// RXD: RXD register
	// Position of RXD field.
	UART_RXD_RXD_Pos = 0x0
	// Bit mask of RXD field.
	UART_RXD_RXD_Msk = 0xff

	// TXD: TXD register
	// Position of TXD field.
	UART_TXD_TXD_Pos = 0x0
	// Bit mask of TXD field.
	UART_TXD_TXD_Msk = 0xff

	// BAUDRATE: Baud rate
	// Position of BAUDRATE field.
	UART_BAUDRATE_BAUDRATE_Pos = 0x0
	// Bit mask of BAUDRATE field.
	UART_BAUDRATE_BAUDRATE_Msk = 0xffffffff
	// 1200 baud (actual rate: 1205)
	UART_BAUDRATE_BAUDRATE_Baud1200 = 0x4f000
	// 2400 baud (actual rate: 2396)
	UART_BAUDRATE_BAUDRATE_Baud2400 = 0x9d000
	// 4800 baud (actual rate: 4808)
	UART_BAUDRATE_BAUDRATE_Baud4800 = 0x13b000
	// 9600 baud (actual rate: 9598)
	UART_BAUDRATE_BAUDRATE_Baud9600 = 0x275000
	// 14400 baud (actual rate: 14414)
	UART_BAUDRATE_BAUDRATE_Baud14400 = 0x3b0000
	// 19200 baud (actual rate: 19208)
	UART_BAUDRATE_BAUDRATE_Baud19200 = 0x4ea000
	// 28800 baud (actual rate: 28829)
	UART_BAUDRATE_BAUDRATE_Baud28800 = 0x75f000
	// 31250 baud
	UART_BAUDRATE_BAUDRATE_Baud31250 = 0x800000
	// 38400 baud (actual rate: 38462)
	UART_BAUDRATE_BAUDRATE_Baud38400 = 0x9d5000
	// 56000 baud (actual rate: 55944)
	UART_BAUDRATE_BAUDRATE_Baud56000 = 0xe50000
	// 57600 baud (actual rate: 57762)
	UART_BAUDRATE_BAUDRATE_Baud57600 = 0xebf000
	// 76800 baud (actual rate: 76923)
	UART_BAUDRATE_BAUDRATE_Baud76800 = 0x13a9000
	// 115200 baud (actual rate: 115942)
	UART_BAUDRATE_BAUDRATE_Baud115200 = 0x1d7e000
	// 230400 baud (actual rate: 231884)
	UART_BAUDRATE_BAUDRATE_Baud230400 = 0x3afb000
	// 250000 baud
	UART_BAUDRATE_BAUDRATE_Baud250000 = 0x4000000
	// 460800 baud (actual rate: 470588)
	UART_BAUDRATE_BAUDRATE_Baud460800 = 0x75f7000
	// 921600 baud (actual rate: 941176)
	UART_BAUDRATE_BAUDRATE_Baud921600 = 0xebed000
	// 1Mega baud
	UART_BAUDRATE_BAUDRATE_Baud1M = 0x10000000

	// CONFIG: Configuration of parity and hardware flow control
	// Position of HWFC field.
	UART_CONFIG_HWFC_Pos = 0x0
	// Bit mask of HWFC field.
	UART_CONFIG_HWFC_Msk = 0x1
	// Bit HWFC.
	UART_CONFIG_HWFC = 0x1
	// Disabled
	UART_CONFIG_HWFC_Disabled = 0x0
	// Enabled
	UART_CONFIG_HWFC_Enabled = 0x1
	// Position of PARITY field.
	UART_CONFIG_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UART_CONFIG_PARITY_Msk = 0xe
	// Exclude parity bit
	UART_CONFIG_PARITY_Excluded = 0x0
	// Include parity bit
	UART_CONFIG_PARITY_Included = 0x7
)

// Constants for SPIM0: Serial Peripheral Interface Master with EasyDMA 0
const (
	// SHORTS: Shortcut register
	// Position of END_START field.
	SPIM_SHORTS_END_START_Pos = 0x11
	// Bit mask of END_START field.
	SPIM_SHORTS_END_START_Msk = 0x20000
	// Bit END_START.
	SPIM_SHORTS_END_START = 0x20000
	// Disable shortcut
	SPIM_SHORTS_END_START_Disabled = 0x0
	// Enable shortcut
	SPIM_SHORTS_END_START_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	SPIM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	SPIM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	SPIM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	SPIM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	SPIM_INTENSET_STOPPED_Set = 0x1
	// Position of ENDRX field.
	SPIM_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIM_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIM_INTENSET_ENDRX = 0x10
	// Read: Disabled
	SPIM_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	SPIM_INTENSET_ENDRX_Set = 0x1
	// Position of END field.
	SPIM_INTENSET_END_Pos = 0x6
	// Bit mask of END field.
	SPIM_INTENSET_END_Msk = 0x40
	// Bit END.
	SPIM_INTENSET_END = 0x40
	// Read: Disabled
	SPIM_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_END_Enabled = 0x1
	// Enable
	SPIM_INTENSET_END_Set = 0x1
	// Position of ENDTX field.
	SPIM_INTENSET_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	SPIM_INTENSET_ENDTX_Msk = 0x100
	// Bit ENDTX.
	SPIM_INTENSET_ENDTX = 0x100
	// Read: Disabled
	SPIM_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	SPIM_INTENSET_ENDTX_Set = 0x1
	// Position of STARTED field.
	SPIM_INTENSET_STARTED_Pos = 0x13
	// Bit mask of STARTED field.
	SPIM_INTENSET_STARTED_Msk = 0x80000
	// Bit STARTED.
	SPIM_INTENSET_STARTED = 0x80000
	// Read: Disabled
	SPIM_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_STARTED_Enabled = 0x1
	// Enable
	SPIM_INTENSET_STARTED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	SPIM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	SPIM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	SPIM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	SPIM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_STOPPED_Clear = 0x1
	// Position of ENDRX field.
	SPIM_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIM_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIM_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	SPIM_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_ENDRX_Clear = 0x1
	// Position of END field.
	SPIM_INTENCLR_END_Pos = 0x6
	// Bit mask of END field.
	SPIM_INTENCLR_END_Msk = 0x40
	// Bit END.
	SPIM_INTENCLR_END = 0x40
	// Read: Disabled
	SPIM_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_END_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_END_Clear = 0x1
	// Position of ENDTX field.
	SPIM_INTENCLR_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	SPIM_INTENCLR_ENDTX_Msk = 0x100
	// Bit ENDTX.
	SPIM_INTENCLR_ENDTX = 0x100
	// Read: Disabled
	SPIM_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_ENDTX_Clear = 0x1
	// Position of STARTED field.
	SPIM_INTENCLR_STARTED_Pos = 0x13
	// Bit mask of STARTED field.
	SPIM_INTENCLR_STARTED_Msk = 0x80000
	// Bit STARTED.
	SPIM_INTENCLR_STARTED = 0x80000
	// Read: Disabled
	SPIM_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_STARTED_Clear = 0x1

	// ENABLE: Enable SPIM
	// Position of ENABLE field.
	SPIM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPIM_ENABLE_ENABLE_Msk = 0xf
	// Disable SPIM
	SPIM_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPIM
	SPIM_ENABLE_ENABLE_Enabled = 0x7

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPIM_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_SCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIM_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPIM_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIM_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPIM_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_MISO_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIM_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_MISO_CONNECT_Connected = 0x0

	// FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	SPIM_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	SPIM_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 125 kbps
	SPIM_FREQUENCY_FREQUENCY_K125 = 0x2000000
	// 250 kbps
	SPIM_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 500 kbps
	SPIM_FREQUENCY_FREQUENCY_K500 = 0x8000000
	// 1 Mbps
	SPIM_FREQUENCY_FREQUENCY_M1 = 0x10000000
	// 2 Mbps
	SPIM_FREQUENCY_FREQUENCY_M2 = 0x20000000
	// 4 Mbps
	SPIM_FREQUENCY_FREQUENCY_M4 = 0x40000000
	// 8 Mbps
	SPIM_FREQUENCY_FREQUENCY_M8 = 0x80000000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	SPIM_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIM_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	SPIM_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIM_RXD_MAXCNT_MAXCNT_Msk = 0xff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	SPIM_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIM_RXD_AMOUNT_AMOUNT_Msk = 0xff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIM_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIM_RXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	SPIM_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIM_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: Data pointer
	// Position of PTR field.
	SPIM_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIM_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	SPIM_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIM_TXD_MAXCNT_MAXCNT_Msk = 0xff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	SPIM_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIM_TXD_AMOUNT_AMOUNT_Msk = 0xff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIM_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIM_TXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	SPIM_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIM_TXD_LIST_LIST_ArrayList = 0x1

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPIM_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPIM_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPIM_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPIM_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPIM_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPIM_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPIM_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPIM_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPIM_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPIM_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPIM_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPIM_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPIM_CONFIG_CPOL = 0x4
	// Active high
	SPIM_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPIM_CONFIG_CPOL_ActiveLow = 0x1

	// ORC: Over-read character. Character clocked out in case and over-read of the TXD buffer.
	// Position of ORC field.
	SPIM_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	SPIM_ORC_ORC_Msk = 0xff
)

// Constants for SPIS0: SPI Slave 0
const (
	// SHORTS: Shortcut register
	// Position of END_ACQUIRE field.
	SPIS_SHORTS_END_ACQUIRE_Pos = 0x2
	// Bit mask of END_ACQUIRE field.
	SPIS_SHORTS_END_ACQUIRE_Msk = 0x4
	// Bit END_ACQUIRE.
	SPIS_SHORTS_END_ACQUIRE = 0x4
	// Disable shortcut
	SPIS_SHORTS_END_ACQUIRE_Disabled = 0x0
	// Enable shortcut
	SPIS_SHORTS_END_ACQUIRE_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of END field.
	SPIS_INTENSET_END_Pos = 0x1
	// Bit mask of END field.
	SPIS_INTENSET_END_Msk = 0x2
	// Bit END.
	SPIS_INTENSET_END = 0x2
	// Read: Disabled
	SPIS_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_END_Enabled = 0x1
	// Enable
	SPIS_INTENSET_END_Set = 0x1
	// Position of ENDRX field.
	SPIS_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIS_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIS_INTENSET_ENDRX = 0x10
	// Read: Disabled
	SPIS_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	SPIS_INTENSET_ENDRX_Set = 0x1
	// Position of ACQUIRED field.
	SPIS_INTENSET_ACQUIRED_Pos = 0xa
	// Bit mask of ACQUIRED field.
	SPIS_INTENSET_ACQUIRED_Msk = 0x400
	// Bit ACQUIRED.
	SPIS_INTENSET_ACQUIRED = 0x400
	// Read: Disabled
	SPIS_INTENSET_ACQUIRED_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_ACQUIRED_Enabled = 0x1
	// Enable
	SPIS_INTENSET_ACQUIRED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of END field.
	SPIS_INTENCLR_END_Pos = 0x1
	// Bit mask of END field.
	SPIS_INTENCLR_END_Msk = 0x2
	// Bit END.
	SPIS_INTENCLR_END = 0x2
	// Read: Disabled
	SPIS_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_END_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_END_Clear = 0x1
	// Position of ENDRX field.
	SPIS_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIS_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIS_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	SPIS_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_ENDRX_Clear = 0x1
	// Position of ACQUIRED field.
	SPIS_INTENCLR_ACQUIRED_Pos = 0xa
	// Bit mask of ACQUIRED field.
	SPIS_INTENCLR_ACQUIRED_Msk = 0x400
	// Bit ACQUIRED.
	SPIS_INTENCLR_ACQUIRED = 0x400
	// Read: Disabled
	SPIS_INTENCLR_ACQUIRED_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_ACQUIRED_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_ACQUIRED_Clear = 0x1

	// SEMSTAT: Semaphore status register
	// Position of SEMSTAT field.
	SPIS_SEMSTAT_SEMSTAT_Pos = 0x0
	// Bit mask of SEMSTAT field.
	SPIS_SEMSTAT_SEMSTAT_Msk = 0x3
	// Semaphore is free
	SPIS_SEMSTAT_SEMSTAT_Free = 0x0
	// Semaphore is assigned to CPU
	SPIS_SEMSTAT_SEMSTAT_CPU = 0x1
	// Semaphore is assigned to SPI slave
	SPIS_SEMSTAT_SEMSTAT_SPIS = 0x2
	// Semaphore is assigned to SPI but a handover to the CPU is pending
	SPIS_SEMSTAT_SEMSTAT_CPUPending = 0x3

	// STATUS: Status from last transaction
	// Position of OVERREAD field.
	SPIS_STATUS_OVERREAD_Pos = 0x0
	// Bit mask of OVERREAD field.
	SPIS_STATUS_OVERREAD_Msk = 0x1
	// Bit OVERREAD.
	SPIS_STATUS_OVERREAD = 0x1
	// Read: error not present
	SPIS_STATUS_OVERREAD_NotPresent = 0x0
	// Read: error present
	SPIS_STATUS_OVERREAD_Present = 0x1
	// Write: clear error on writing '1'
	SPIS_STATUS_OVERREAD_Clear = 0x1
	// Position of OVERFLOW field.
	SPIS_STATUS_OVERFLOW_Pos = 0x1
	// Bit mask of OVERFLOW field.
	SPIS_STATUS_OVERFLOW_Msk = 0x2
	// Bit OVERFLOW.
	SPIS_STATUS_OVERFLOW = 0x2
	// Read: error not present
	SPIS_STATUS_OVERFLOW_NotPresent = 0x0
	// Read: error present
	SPIS_STATUS_OVERFLOW_Present = 0x1
	// Write: clear error on writing '1'
	SPIS_STATUS_OVERFLOW_Clear = 0x1

	// ENABLE: Enable SPI slave
	// Position of ENABLE field.
	SPIS_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPIS_ENABLE_ENABLE_Msk = 0xf
	// Disable SPI slave
	SPIS_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPI slave
	SPIS_ENABLE_ENABLE_Enabled = 0x2

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPIS_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_SCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPIS_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_MISO_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_MISO_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPIS_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.CSN: Pin select for CSN signal
	// Position of PIN field.
	SPIS_PSEL_CSN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_CSN_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_CSN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_CSN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_CSN_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_CSN_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_CSN_CONNECT_Connected = 0x0

	// RXD.PTR: RXD data pointer
	// Position of PTR field.
	SPIS_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIS_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	SPIS_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIS_RXD_MAXCNT_MAXCNT_Msk = 0xff

	// RXD.AMOUNT: Number of bytes received in last granted transaction
	// Position of AMOUNT field.
	SPIS_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIS_RXD_AMOUNT_AMOUNT_Msk = 0xff

	// TXD.PTR: TXD data pointer
	// Position of PTR field.
	SPIS_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIS_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	SPIS_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIS_TXD_MAXCNT_MAXCNT_Msk = 0xff

	// TXD.AMOUNT: Number of bytes transmitted in last granted transaction
	// Position of AMOUNT field.
	SPIS_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIS_TXD_AMOUNT_AMOUNT_Msk = 0xff

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPIS_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPIS_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPIS_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPIS_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPIS_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPIS_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPIS_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPIS_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPIS_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPIS_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPIS_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPIS_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPIS_CONFIG_CPOL = 0x4
	// Active high
	SPIS_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPIS_CONFIG_CPOL_ActiveLow = 0x1

	// DEF: Default character. Character clocked out in case of an ignored transaction.
	// Position of DEF field.
	SPIS_DEF_DEF_Pos = 0x0
	// Bit mask of DEF field.
	SPIS_DEF_DEF_Msk = 0xff

	// ORC: Over-read character
	// Position of ORC field.
	SPIS_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	SPIS_ORC_ORC_Msk = 0xff
)

// Constants for TWIM0: I2C compatible Two-Wire Master Interface with EasyDMA 0
const (
	// SHORTS: Shortcut register
	// Position of LASTTX_STARTRX field.
	TWIM_SHORTS_LASTTX_STARTRX_Pos = 0x7
	// Bit mask of LASTTX_STARTRX field.
	TWIM_SHORTS_LASTTX_STARTRX_Msk = 0x80
	// Bit LASTTX_STARTRX.
	TWIM_SHORTS_LASTTX_STARTRX = 0x80
	// Disable shortcut
	TWIM_SHORTS_LASTTX_STARTRX_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_STARTRX_Enabled = 0x1
	// Position of LASTTX_SUSPEND field.
	TWIM_SHORTS_LASTTX_SUSPEND_Pos = 0x8
	// Bit mask of LASTTX_SUSPEND field.
	TWIM_SHORTS_LASTTX_SUSPEND_Msk = 0x100
	// Bit LASTTX_SUSPEND.
	TWIM_SHORTS_LASTTX_SUSPEND = 0x100
	// Disable shortcut
	TWIM_SHORTS_LASTTX_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_SUSPEND_Enabled = 0x1
	// Position of LASTTX_STOP field.
	TWIM_SHORTS_LASTTX_STOP_Pos = 0x9
	// Bit mask of LASTTX_STOP field.
	TWIM_SHORTS_LASTTX_STOP_Msk = 0x200
	// Bit LASTTX_STOP.
	TWIM_SHORTS_LASTTX_STOP = 0x200
	// Disable shortcut
	TWIM_SHORTS_LASTTX_STOP_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_STOP_Enabled = 0x1
	// Position of LASTRX_STARTTX field.
	TWIM_SHORTS_LASTRX_STARTTX_Pos = 0xa
	// Bit mask of LASTRX_STARTTX field.
	TWIM_SHORTS_LASTRX_STARTTX_Msk = 0x400
	// Bit LASTRX_STARTTX.
	TWIM_SHORTS_LASTRX_STARTTX = 0x400
	// Disable shortcut
	TWIM_SHORTS_LASTRX_STARTTX_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_STARTTX_Enabled = 0x1
	// Position of LASTRX_STOP field.
	TWIM_SHORTS_LASTRX_STOP_Pos = 0xc
	// Bit mask of LASTRX_STOP field.
	TWIM_SHORTS_LASTRX_STOP_Msk = 0x1000
	// Bit LASTRX_STOP.
	TWIM_SHORTS_LASTRX_STOP = 0x1000
	// Disable shortcut
	TWIM_SHORTS_LASTRX_STOP_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	TWIM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTEN_STOPPED = 0x2
	// Disable
	TWIM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	TWIM_INTEN_STOPPED_Enabled = 0x1
	// Position of ERROR field.
	TWIM_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTEN_ERROR = 0x200
	// Disable
	TWIM_INTEN_ERROR_Disabled = 0x0
	// Enable
	TWIM_INTEN_ERROR_Enabled = 0x1
	// Position of SUSPENDED field.
	TWIM_INTEN_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTEN_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTEN_SUSPENDED = 0x40000
	// Disable
	TWIM_INTEN_SUSPENDED_Disabled = 0x0
	// Enable
	TWIM_INTEN_SUSPENDED_Enabled = 0x1
	// Position of RXSTARTED field.
	TWIM_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTEN_RXSTARTED = 0x80000
	// Disable
	TWIM_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	TWIM_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	TWIM_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTEN_TXSTARTED = 0x100000
	// Disable
	TWIM_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	TWIM_INTEN_TXSTARTED_Enabled = 0x1
	// Position of LASTRX field.
	TWIM_INTEN_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTEN_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTEN_LASTRX = 0x800000
	// Disable
	TWIM_INTEN_LASTRX_Disabled = 0x0
	// Enable
	TWIM_INTEN_LASTRX_Enabled = 0x1
	// Position of LASTTX field.
	TWIM_INTEN_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTEN_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTEN_LASTTX = 0x1000000
	// Disable
	TWIM_INTEN_LASTTX_Disabled = 0x0
	// Enable
	TWIM_INTEN_LASTTX_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWIM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWIM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_STOPPED_Set = 0x1
	// Position of ERROR field.
	TWIM_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWIM_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWIM_INTENSET_ERROR_Set = 0x1
	// Position of SUSPENDED field.
	TWIM_INTENSET_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTENSET_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTENSET_SUSPENDED = 0x40000
	// Read: Disabled
	TWIM_INTENSET_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_SUSPENDED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_SUSPENDED_Set = 0x1
	// Position of RXSTARTED field.
	TWIM_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	TWIM_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	TWIM_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	TWIM_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_TXSTARTED_Set = 0x1
	// Position of LASTRX field.
	TWIM_INTENSET_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTENSET_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTENSET_LASTRX = 0x800000
	// Read: Disabled
	TWIM_INTENSET_LASTRX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_LASTRX_Enabled = 0x1
	// Enable
	TWIM_INTENSET_LASTRX_Set = 0x1
	// Position of LASTTX field.
	TWIM_INTENSET_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTENSET_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTENSET_LASTTX = 0x1000000
	// Read: Disabled
	TWIM_INTENSET_LASTTX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_LASTTX_Enabled = 0x1
	// Enable
	TWIM_INTENSET_LASTTX_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWIM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWIM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_STOPPED_Clear = 0x1
	// Position of ERROR field.
	TWIM_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWIM_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_ERROR_Clear = 0x1
	// Position of SUSPENDED field.
	TWIM_INTENCLR_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTENCLR_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTENCLR_SUSPENDED = 0x40000
	// Read: Disabled
	TWIM_INTENCLR_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_SUSPENDED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_SUSPENDED_Clear = 0x1
	// Position of RXSTARTED field.
	TWIM_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	TWIM_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	TWIM_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	TWIM_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of LASTRX field.
	TWIM_INTENCLR_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTENCLR_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTENCLR_LASTRX = 0x800000
	// Read: Disabled
	TWIM_INTENCLR_LASTRX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_LASTRX_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_LASTRX_Clear = 0x1
	// Position of LASTTX field.
	TWIM_INTENCLR_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTENCLR_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTENCLR_LASTTX = 0x1000000
	// Read: Disabled
	TWIM_INTENCLR_LASTTX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_LASTTX_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_LASTTX_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	TWIM_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	TWIM_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	TWIM_ERRORSRC_OVERRUN = 0x1
	// Error did not occur
	TWIM_ERRORSRC_OVERRUN_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_OVERRUN_Received = 0x1
	// Position of ANACK field.
	TWIM_ERRORSRC_ANACK_Pos = 0x1
	// Bit mask of ANACK field.
	TWIM_ERRORSRC_ANACK_Msk = 0x2
	// Bit ANACK.
	TWIM_ERRORSRC_ANACK = 0x2
	// Error did not occur
	TWIM_ERRORSRC_ANACK_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_ANACK_Received = 0x1
	// Position of DNACK field.
	TWIM_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWIM_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWIM_ERRORSRC_DNACK = 0x4
	// Error did not occur
	TWIM_ERRORSRC_DNACK_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_DNACK_Received = 0x1

	// ENABLE: Enable TWIM
	// Position of ENABLE field.
	TWIM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWIM_ENABLE_ENABLE_Msk = 0xf
	// Disable TWIM
	TWIM_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWIM
	TWIM_ENABLE_ENABLE_Enabled = 0x6

	// PSEL.SCL: Pin select for SCL signal
	// Position of PIN field.
	TWIM_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIM_PSEL_SCL_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIM_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIM_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIM_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWIM_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWIM_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA signal
	// Position of PIN field.
	TWIM_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIM_PSEL_SDA_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIM_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIM_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIM_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWIM_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWIM_PSEL_SDA_CONNECT_Connected = 0x0

	// FREQUENCY: TWI frequency
	// Position of FREQUENCY field.
	TWIM_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	TWIM_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 100 kbps
	TWIM_FREQUENCY_FREQUENCY_K100 = 0x1980000
	// 250 kbps
	TWIM_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 400 kbps
	TWIM_FREQUENCY_FREQUENCY_K400 = 0x6400000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	TWIM_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIM_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	TWIM_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIM_RXD_MAXCNT_MAXCNT_Msk = 0xff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	TWIM_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIM_RXD_AMOUNT_AMOUNT_Msk = 0xff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIM_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIM_RXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	TWIM_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIM_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: Data pointer
	// Position of PTR field.
	TWIM_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIM_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	TWIM_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIM_TXD_MAXCNT_MAXCNT_Msk = 0xff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	TWIM_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIM_TXD_AMOUNT_AMOUNT_Msk = 0xff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIM_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIM_TXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	TWIM_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIM_TXD_LIST_LIST_ArrayList = 0x1

	// ADDRESS: Address used in the TWI transfer
	// Position of ADDRESS field.
	TWIM_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWIM_ADDRESS_ADDRESS_Msk = 0x7f
)

// Constants for TWIS0: I2C compatible Two-Wire Slave Interface with EasyDMA 0
const (
	// SHORTS: Shortcut register
	// Position of WRITE_SUSPEND field.
	TWIS_SHORTS_WRITE_SUSPEND_Pos = 0xd
	// Bit mask of WRITE_SUSPEND field.
	TWIS_SHORTS_WRITE_SUSPEND_Msk = 0x2000
	// Bit WRITE_SUSPEND.
	TWIS_SHORTS_WRITE_SUSPEND = 0x2000
	// Disable shortcut
	TWIS_SHORTS_WRITE_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIS_SHORTS_WRITE_SUSPEND_Enabled = 0x1
	// Position of READ_SUSPEND field.
	TWIS_SHORTS_READ_SUSPEND_Pos = 0xe
	// Bit mask of READ_SUSPEND field.
	TWIS_SHORTS_READ_SUSPEND_Msk = 0x4000
	// Bit READ_SUSPEND.
	TWIS_SHORTS_READ_SUSPEND = 0x4000
	// Disable shortcut
	TWIS_SHORTS_READ_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIS_SHORTS_READ_SUSPEND_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	TWIS_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTEN_STOPPED = 0x2
	// Disable
	TWIS_INTEN_STOPPED_Disabled = 0x0
	// Enable
	TWIS_INTEN_STOPPED_Enabled = 0x1
	// Position of ERROR field.
	TWIS_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTEN_ERROR = 0x200
	// Disable
	TWIS_INTEN_ERROR_Disabled = 0x0
	// Enable
	TWIS_INTEN_ERROR_Enabled = 0x1
	// Position of RXSTARTED field.
	TWIS_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTEN_RXSTARTED = 0x80000
	// Disable
	TWIS_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	TWIS_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	TWIS_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTEN_TXSTARTED = 0x100000
	// Disable
	TWIS_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	TWIS_INTEN_TXSTARTED_Enabled = 0x1
	// Position of WRITE field.
	TWIS_INTEN_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTEN_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTEN_WRITE = 0x2000000
	// Disable
	TWIS_INTEN_WRITE_Disabled = 0x0
	// Enable
	TWIS_INTEN_WRITE_Enabled = 0x1
	// Position of READ field.
	TWIS_INTEN_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTEN_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTEN_READ = 0x4000000
	// Disable
	TWIS_INTEN_READ_Disabled = 0x0
	// Enable
	TWIS_INTEN_READ_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWIS_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWIS_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_STOPPED_Set = 0x1
	// Position of ERROR field.
	TWIS_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWIS_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWIS_INTENSET_ERROR_Set = 0x1
	// Position of RXSTARTED field.
	TWIS_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	TWIS_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	TWIS_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	TWIS_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_TXSTARTED_Set = 0x1
	// Position of WRITE field.
	TWIS_INTENSET_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTENSET_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTENSET_WRITE = 0x2000000
	// Read: Disabled
	TWIS_INTENSET_WRITE_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_WRITE_Enabled = 0x1
	// Enable
	TWIS_INTENSET_WRITE_Set = 0x1
	// Position of READ field.
	TWIS_INTENSET_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTENSET_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTENSET_READ = 0x4000000
	// Read: Disabled
	TWIS_INTENSET_READ_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_READ_Enabled = 0x1
	// Enable
	TWIS_INTENSET_READ_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWIS_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWIS_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_STOPPED_Clear = 0x1
	// Position of ERROR field.
	TWIS_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWIS_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_ERROR_Clear = 0x1
	// Position of RXSTARTED field.
	TWIS_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	TWIS_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	TWIS_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	TWIS_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of WRITE field.
	TWIS_INTENCLR_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTENCLR_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTENCLR_WRITE = 0x2000000
	// Read: Disabled
	TWIS_INTENCLR_WRITE_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_WRITE_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_WRITE_Clear = 0x1
	// Position of READ field.
	TWIS_INTENCLR_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTENCLR_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTENCLR_READ = 0x4000000
	// Read: Disabled
	TWIS_INTENCLR_READ_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_READ_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_READ_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERFLOW field.
	TWIS_ERRORSRC_OVERFLOW_Pos = 0x0
	// Bit mask of OVERFLOW field.
	TWIS_ERRORSRC_OVERFLOW_Msk = 0x1
	// Bit OVERFLOW.
	TWIS_ERRORSRC_OVERFLOW = 0x1
	// Error did not occur
	TWIS_ERRORSRC_OVERFLOW_NotDetected = 0x0
	// Error occurred
	TWIS_ERRORSRC_OVERFLOW_Detected = 0x1
	// Position of DNACK field.
	TWIS_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWIS_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWIS_ERRORSRC_DNACK = 0x4
	// Error did not occur
	TWIS_ERRORSRC_DNACK_NotReceived = 0x0
	// Error occurred
	TWIS_ERRORSRC_DNACK_Received = 0x1
	// Position of OVERREAD field.
	TWIS_ERRORSRC_OVERREAD_Pos = 0x3
	// Bit mask of OVERREAD field.
	TWIS_ERRORSRC_OVERREAD_Msk = 0x8
	// Bit OVERREAD.
	TWIS_ERRORSRC_OVERREAD = 0x8
	// Error did not occur
	TWIS_ERRORSRC_OVERREAD_NotDetected = 0x0
	// Error occurred
	TWIS_ERRORSRC_OVERREAD_Detected = 0x1

	// MATCH: Status register indicating which address had a match
	// Position of MATCH field.
	TWIS_MATCH_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	TWIS_MATCH_MATCH_Msk = 0x1
	// Bit MATCH.
	TWIS_MATCH_MATCH = 0x1

	// ENABLE: Enable TWIS
	// Position of ENABLE field.
	TWIS_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWIS_ENABLE_ENABLE_Msk = 0xf
	// Disable TWIS
	TWIS_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWIS
	TWIS_ENABLE_ENABLE_Enabled = 0x9

	// PSEL.SCL: Pin select for SCL signal
	// Position of PIN field.
	TWIS_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIS_PSEL_SCL_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIS_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIS_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIS_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWIS_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWIS_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA signal
	// Position of PIN field.
	TWIS_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIS_PSEL_SDA_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIS_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIS_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIS_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWIS_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWIS_PSEL_SDA_CONNECT_Connected = 0x0

	// RXD.PTR: RXD Data pointer
	// Position of PTR field.
	TWIS_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIS_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in RXD buffer
	// Position of MAXCNT field.
	TWIS_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIS_RXD_MAXCNT_MAXCNT_Msk = 0xff

	// RXD.AMOUNT: Number of bytes transferred in the last RXD transaction
	// Position of AMOUNT field.
	TWIS_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIS_RXD_AMOUNT_AMOUNT_Msk = 0xff

	// TXD.PTR: TXD Data pointer
	// Position of PTR field.
	TWIS_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIS_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in TXD buffer
	// Position of MAXCNT field.
	TWIS_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIS_TXD_MAXCNT_MAXCNT_Msk = 0xff

	// TXD.AMOUNT: Number of bytes transferred in the last TXD transaction
	// Position of AMOUNT field.
	TWIS_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIS_TXD_AMOUNT_AMOUNT_Msk = 0xff

	// ADDRESS: Description collection[0]: TWI slave address 0
	// Position of ADDRESS field.
	TWIS_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWIS_ADDRESS_ADDRESS_Msk = 0x7f

	// CONFIG: Configuration register for the address match mechanism
	// Position of ADDRESS0 field.
	TWIS_CONFIG_ADDRESS0_Pos = 0x0
	// Bit mask of ADDRESS0 field.
	TWIS_CONFIG_ADDRESS0_Msk = 0x1
	// Bit ADDRESS0.
	TWIS_CONFIG_ADDRESS0 = 0x1
	// Disabled
	TWIS_CONFIG_ADDRESS0_Disabled = 0x0
	// Enabled
	TWIS_CONFIG_ADDRESS0_Enabled = 0x1
	// Position of ADDRESS1 field.
	TWIS_CONFIG_ADDRESS1_Pos = 0x1
	// Bit mask of ADDRESS1 field.
	TWIS_CONFIG_ADDRESS1_Msk = 0x2
	// Bit ADDRESS1.
	TWIS_CONFIG_ADDRESS1 = 0x2
	// Disabled
	TWIS_CONFIG_ADDRESS1_Disabled = 0x0
	// Enabled
	TWIS_CONFIG_ADDRESS1_Enabled = 0x1

	// ORC: Over-read character. Character sent out in case of an over-read of the transmit buffer.
	// Position of ORC field.
	TWIS_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	TWIS_ORC_ORC_Msk = 0xff
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// INTENSET: Enable interrupt
	// Position of READY field.
	SPI_INTENSET_READY_Pos = 0x2
	// Bit mask of READY field.
	SPI_INTENSET_READY_Msk = 0x4
	// Bit READY.
	SPI_INTENSET_READY = 0x4
	// Read: Disabled
	SPI_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	SPI_INTENSET_READY_Enabled = 0x1
	// Enable
	SPI_INTENSET_READY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	SPI_INTENCLR_READY_Pos = 0x2
	// Bit mask of READY field.
	SPI_INTENCLR_READY_Msk = 0x4
	// Bit READY.
	SPI_INTENCLR_READY = 0x4
	// Read: Disabled
	SPI_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	SPI_INTENCLR_READY_Enabled = 0x1
	// Disable
	SPI_INTENCLR_READY_Clear = 0x1

	// ENABLE: Enable SPI
	// Position of ENABLE field.
	SPI_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPI_ENABLE_ENABLE_Msk = 0xf
	// Disable SPI
	SPI_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPI
	SPI_ENABLE_ENABLE_Enabled = 0x1

	// PSEL.SCK: Pin select for SCK
	// Position of PSELSCK field.
	SPI_PSEL_SCK_PSELSCK_Pos = 0x0
	// Bit mask of PSELSCK field.
	SPI_PSEL_SCK_PSELSCK_Msk = 0xffffffff
	// Disconnect
	SPI_PSEL_SCK_PSELSCK_Disconnected = 0xffffffff

	// PSEL.MOSI: Pin select for MOSI
	// Position of PSELMOSI field.
	SPI_PSEL_MOSI_PSELMOSI_Pos = 0x0
	// Bit mask of PSELMOSI field.
	SPI_PSEL_MOSI_PSELMOSI_Msk = 0xffffffff
	// Disconnect
	SPI_PSEL_MOSI_PSELMOSI_Disconnected = 0xffffffff

	// PSEL.MISO: Pin select for MISO
	// Position of PSELMISO field.
	SPI_PSEL_MISO_PSELMISO_Pos = 0x0
	// Bit mask of PSELMISO field.
	SPI_PSEL_MISO_PSELMISO_Msk = 0xffffffff
	// Disconnect
	SPI_PSEL_MISO_PSELMISO_Disconnected = 0xffffffff

	// RXD: RXD register
	// Position of RXD field.
	SPI_RXD_RXD_Pos = 0x0
	// Bit mask of RXD field.
	SPI_RXD_RXD_Msk = 0xff

	// TXD: TXD register
	// Position of TXD field.
	SPI_TXD_TXD_Pos = 0x0
	// Bit mask of TXD field.
	SPI_TXD_TXD_Msk = 0xff

	// FREQUENCY: SPI frequency
	// Position of FREQUENCY field.
	SPI_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	SPI_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 125 kbps
	SPI_FREQUENCY_FREQUENCY_K125 = 0x2000000
	// 250 kbps
	SPI_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 500 kbps
	SPI_FREQUENCY_FREQUENCY_K500 = 0x8000000
	// 1 Mbps
	SPI_FREQUENCY_FREQUENCY_M1 = 0x10000000
	// 2 Mbps
	SPI_FREQUENCY_FREQUENCY_M2 = 0x20000000
	// 4 Mbps
	SPI_FREQUENCY_FREQUENCY_M4 = 0x40000000
	// 8 Mbps
	SPI_FREQUENCY_FREQUENCY_M8 = 0x80000000

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPI_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPI_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPI_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPI_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPI_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPI_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPI_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPI_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPI_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPI_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPI_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPI_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPI_CONFIG_CPOL = 0x4
	// Active high
	SPI_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPI_CONFIG_CPOL_ActiveLow = 0x1
)

// Constants for TWI0: I2C compatible Two-Wire Interface 0
const (
	// SHORTS: Shortcut register
	// Position of BB_SUSPEND field.
	TWI_SHORTS_BB_SUSPEND_Pos = 0x0
	// Bit mask of BB_SUSPEND field.
	TWI_SHORTS_BB_SUSPEND_Msk = 0x1
	// Bit BB_SUSPEND.
	TWI_SHORTS_BB_SUSPEND = 0x1
	// Disable shortcut
	TWI_SHORTS_BB_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWI_SHORTS_BB_SUSPEND_Enabled = 0x1
	// Position of BB_STOP field.
	TWI_SHORTS_BB_STOP_Pos = 0x1
	// Bit mask of BB_STOP field.
	TWI_SHORTS_BB_STOP_Msk = 0x2
	// Bit BB_STOP.
	TWI_SHORTS_BB_STOP = 0x2
	// Disable shortcut
	TWI_SHORTS_BB_STOP_Disabled = 0x0
	// Enable shortcut
	TWI_SHORTS_BB_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWI_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWI_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWI_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWI_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWI_INTENSET_STOPPED_Set = 0x1
	// Position of RXDREADY field.
	TWI_INTENSET_RXDREADY_Pos = 0x2
	// Bit mask of RXDREADY field.
	TWI_INTENSET_RXDREADY_Msk = 0x4
	// Bit RXDREADY.
	TWI_INTENSET_RXDREADY = 0x4
	// Read: Disabled
	TWI_INTENSET_RXDREADY_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_RXDREADY_Enabled = 0x1
	// Enable
	TWI_INTENSET_RXDREADY_Set = 0x1
	// Position of TXDSENT field.
	TWI_INTENSET_TXDSENT_Pos = 0x7
	// Bit mask of TXDSENT field.
	TWI_INTENSET_TXDSENT_Msk = 0x80
	// Bit TXDSENT.
	TWI_INTENSET_TXDSENT = 0x80
	// Read: Disabled
	TWI_INTENSET_TXDSENT_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_TXDSENT_Enabled = 0x1
	// Enable
	TWI_INTENSET_TXDSENT_Set = 0x1
	// Position of ERROR field.
	TWI_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWI_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWI_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWI_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWI_INTENSET_ERROR_Set = 0x1
	// Position of BB field.
	TWI_INTENSET_BB_Pos = 0xe
	// Bit mask of BB field.
	TWI_INTENSET_BB_Msk = 0x4000
	// Bit BB.
	TWI_INTENSET_BB = 0x4000
	// Read: Disabled
	TWI_INTENSET_BB_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_BB_Enabled = 0x1
	// Enable
	TWI_INTENSET_BB_Set = 0x1
	// Position of SUSPENDED field.
	TWI_INTENSET_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWI_INTENSET_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWI_INTENSET_SUSPENDED = 0x40000
	// Read: Disabled
	TWI_INTENSET_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_SUSPENDED_Enabled = 0x1
	// Enable
	TWI_INTENSET_SUSPENDED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWI_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWI_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWI_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWI_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWI_INTENCLR_STOPPED_Clear = 0x1
	// Position of RXDREADY field.
	TWI_INTENCLR_RXDREADY_Pos = 0x2
	// Bit mask of RXDREADY field.
	TWI_INTENCLR_RXDREADY_Msk = 0x4
	// Bit RXDREADY.
	TWI_INTENCLR_RXDREADY = 0x4
	// Read: Disabled
	TWI_INTENCLR_RXDREADY_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_RXDREADY_Enabled = 0x1
	// Disable
	TWI_INTENCLR_RXDREADY_Clear = 0x1
	// Position of TXDSENT field.
	TWI_INTENCLR_TXDSENT_Pos = 0x7
	// Bit mask of TXDSENT field.
	TWI_INTENCLR_TXDSENT_Msk = 0x80
	// Bit TXDSENT.
	TWI_INTENCLR_TXDSENT = 0x80
	// Read: Disabled
	TWI_INTENCLR_TXDSENT_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_TXDSENT_Enabled = 0x1
	// Disable
	TWI_INTENCLR_TXDSENT_Clear = 0x1
	// Position of ERROR field.
	TWI_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWI_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWI_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWI_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWI_INTENCLR_ERROR_Clear = 0x1
	// Position of BB field.
	TWI_INTENCLR_BB_Pos = 0xe
	// Bit mask of BB field.
	TWI_INTENCLR_BB_Msk = 0x4000
	// Bit BB.
	TWI_INTENCLR_BB = 0x4000
	// Read: Disabled
	TWI_INTENCLR_BB_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_BB_Enabled = 0x1
	// Disable
	TWI_INTENCLR_BB_Clear = 0x1
	// Position of SUSPENDED field.
	TWI_INTENCLR_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWI_INTENCLR_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWI_INTENCLR_SUSPENDED = 0x40000
	// Read: Disabled
	TWI_INTENCLR_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_SUSPENDED_Enabled = 0x1
	// Disable
	TWI_INTENCLR_SUSPENDED_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	TWI_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	TWI_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	TWI_ERRORSRC_OVERRUN = 0x1
	// Read: no overrun occured
	TWI_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: overrun occured
	TWI_ERRORSRC_OVERRUN_Present = 0x1
	// Write: clear error on writing '1'
	TWI_ERRORSRC_OVERRUN_Clear = 0x1
	// Position of ANACK field.
	TWI_ERRORSRC_ANACK_Pos = 0x1
	// Bit mask of ANACK field.
	TWI_ERRORSRC_ANACK_Msk = 0x2
	// Bit ANACK.
	TWI_ERRORSRC_ANACK = 0x2
	// Read: error not present
	TWI_ERRORSRC_ANACK_NotPresent = 0x0
	// Read: error present
	TWI_ERRORSRC_ANACK_Present = 0x1
	// Write: clear error on writing '1'
	TWI_ERRORSRC_ANACK_Clear = 0x1
	// Position of DNACK field.
	TWI_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWI_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWI_ERRORSRC_DNACK = 0x4
	// Read: error not present
	TWI_ERRORSRC_DNACK_NotPresent = 0x0
	// Read: error present
	TWI_ERRORSRC_DNACK_Present = 0x1
	// Write: clear error on writing '1'
	TWI_ERRORSRC_DNACK_Clear = 0x1

	// ENABLE: Enable TWI
	// Position of ENABLE field.
	TWI_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWI_ENABLE_ENABLE_Msk = 0xf
	// Disable TWI
	TWI_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWI
	TWI_ENABLE_ENABLE_Enabled = 0x5

	// PSELSCL: Pin select for SCL
	// Position of PSELSCL field.
	TWI_PSELSCL_PSELSCL_Pos = 0x0
	// Bit mask of PSELSCL field.
	TWI_PSELSCL_PSELSCL_Msk = 0xffffffff
	// Disconnect
	TWI_PSELSCL_PSELSCL_Disconnected = 0xffffffff

	// PSELSDA: Pin select for SDA
	// Position of PSELSDA field.
	TWI_PSELSDA_PSELSDA_Pos = 0x0
	// Bit mask of PSELSDA field.
	TWI_PSELSDA_PSELSDA_Msk = 0xffffffff
	// Disconnect
	TWI_PSELSDA_PSELSDA_Disconnected = 0xffffffff

	// RXD: RXD register
	// Position of RXD field.
	TWI_RXD_RXD_Pos = 0x0
	// Bit mask of RXD field.
	TWI_RXD_RXD_Msk = 0xff

	// TXD: TXD register
	// Position of TXD field.
	TWI_TXD_TXD_Pos = 0x0
	// Bit mask of TXD field.
	TWI_TXD_TXD_Msk = 0xff

	// FREQUENCY: TWI frequency
	// Position of FREQUENCY field.
	TWI_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	TWI_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 100 kbps
	TWI_FREQUENCY_FREQUENCY_K100 = 0x1980000
	// 250 kbps
	TWI_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 400 kbps (actual rate 410.256 kbps)
	TWI_FREQUENCY_FREQUENCY_K400 = 0x6680000

	// ADDRESS: Address used in the TWI transfer
	// Position of ADDRESS field.
	TWI_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWI_ADDRESS_ADDRESS_Msk = 0x7f
)

// Constants for NFCT: NFC-A compatible radio
const (
	// SHORTS: Shortcut register
	// Position of FIELDDETECTED_ACTIVATE field.
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos = 0x0
	// Bit mask of FIELDDETECTED_ACTIVATE field.
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk = 0x1
	// Bit FIELDDETECTED_ACTIVATE.
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE = 0x1
	// Disable shortcut
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Disabled = 0x0
	// Enable shortcut
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Enabled = 0x1
	// Position of FIELDLOST_SENSE field.
	NFCT_SHORTS_FIELDLOST_SENSE_Pos = 0x1
	// Bit mask of FIELDLOST_SENSE field.
	NFCT_SHORTS_FIELDLOST_SENSE_Msk = 0x2
	// Bit FIELDLOST_SENSE.
	NFCT_SHORTS_FIELDLOST_SENSE = 0x2
	// Disable shortcut
	NFCT_SHORTS_FIELDLOST_SENSE_Disabled = 0x0
	// Enable shortcut
	NFCT_SHORTS_FIELDLOST_SENSE_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of READY field.
	NFCT_INTEN_READY_Pos = 0x0
	// Bit mask of READY field.
	NFCT_INTEN_READY_Msk = 0x1
	// Bit READY.
	NFCT_INTEN_READY = 0x1
	// Disable
	NFCT_INTEN_READY_Disabled = 0x0
	// Enable
	NFCT_INTEN_READY_Enabled = 0x1
	// Position of FIELDDETECTED field.
	NFCT_INTEN_FIELDDETECTED_Pos = 0x1
	// Bit mask of FIELDDETECTED field.
	NFCT_INTEN_FIELDDETECTED_Msk = 0x2
	// Bit FIELDDETECTED.
	NFCT_INTEN_FIELDDETECTED = 0x2
	// Disable
	NFCT_INTEN_FIELDDETECTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_FIELDDETECTED_Enabled = 0x1
	// Position of FIELDLOST field.
	NFCT_INTEN_FIELDLOST_Pos = 0x2
	// Bit mask of FIELDLOST field.
	NFCT_INTEN_FIELDLOST_Msk = 0x4
	// Bit FIELDLOST.
	NFCT_INTEN_FIELDLOST = 0x4
	// Disable
	NFCT_INTEN_FIELDLOST_Disabled = 0x0
	// Enable
	NFCT_INTEN_FIELDLOST_Enabled = 0x1
	// Position of TXFRAMESTART field.
	NFCT_INTEN_TXFRAMESTART_Pos = 0x3
	// Bit mask of TXFRAMESTART field.
	NFCT_INTEN_TXFRAMESTART_Msk = 0x8
	// Bit TXFRAMESTART.
	NFCT_INTEN_TXFRAMESTART = 0x8
	// Disable
	NFCT_INTEN_TXFRAMESTART_Disabled = 0x0
	// Enable
	NFCT_INTEN_TXFRAMESTART_Enabled = 0x1
	// Position of TXFRAMEEND field.
	NFCT_INTEN_TXFRAMEEND_Pos = 0x4
	// Bit mask of TXFRAMEEND field.
	NFCT_INTEN_TXFRAMEEND_Msk = 0x10
	// Bit TXFRAMEEND.
	NFCT_INTEN_TXFRAMEEND = 0x10
	// Disable
	NFCT_INTEN_TXFRAMEEND_Disabled = 0x0
	// Enable
	NFCT_INTEN_TXFRAMEEND_Enabled = 0x1
	// Position of RXFRAMESTART field.
	NFCT_INTEN_RXFRAMESTART_Pos = 0x5
	// Bit mask of RXFRAMESTART field.
	NFCT_INTEN_RXFRAMESTART_Msk = 0x20
	// Bit RXFRAMESTART.
	NFCT_INTEN_RXFRAMESTART = 0x20
	// Disable
	NFCT_INTEN_RXFRAMESTART_Disabled = 0x0
	// Enable
	NFCT_INTEN_RXFRAMESTART_Enabled = 0x1
	// Position of RXFRAMEEND field.
	NFCT_INTEN_RXFRAMEEND_Pos = 0x6
	// Bit mask of RXFRAMEEND field.
	NFCT_INTEN_RXFRAMEEND_Msk = 0x40
	// Bit RXFRAMEEND.
	NFCT_INTEN_RXFRAMEEND = 0x40
	// Disable
	NFCT_INTEN_RXFRAMEEND_Disabled = 0x0
	// Enable
	NFCT_INTEN_RXFRAMEEND_Enabled = 0x1
	// Position of ERROR field.
	NFCT_INTEN_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	NFCT_INTEN_ERROR_Msk = 0x80
	// Bit ERROR.
	NFCT_INTEN_ERROR = 0x80
	// Disable
	NFCT_INTEN_ERROR_Disabled = 0x0
	// Enable
	NFCT_INTEN_ERROR_Enabled = 0x1
	// Position of RXERROR field.
	NFCT_INTEN_RXERROR_Pos = 0xa
	// Bit mask of RXERROR field.
	NFCT_INTEN_RXERROR_Msk = 0x400
	// Bit RXERROR.
	NFCT_INTEN_RXERROR = 0x400
	// Disable
	NFCT_INTEN_RXERROR_Disabled = 0x0
	// Enable
	NFCT_INTEN_RXERROR_Enabled = 0x1
	// Position of ENDRX field.
	NFCT_INTEN_ENDRX_Pos = 0xb
	// Bit mask of ENDRX field.
	NFCT_INTEN_ENDRX_Msk = 0x800
	// Bit ENDRX.
	NFCT_INTEN_ENDRX = 0x800
	// Disable
	NFCT_INTEN_ENDRX_Disabled = 0x0
	// Enable
	NFCT_INTEN_ENDRX_Enabled = 0x1
	// Position of ENDTX field.
	NFCT_INTEN_ENDTX_Pos = 0xc
	// Bit mask of ENDTX field.
	NFCT_INTEN_ENDTX_Msk = 0x1000
	// Bit ENDTX.
	NFCT_INTEN_ENDTX = 0x1000
	// Disable
	NFCT_INTEN_ENDTX_Disabled = 0x0
	// Enable
	NFCT_INTEN_ENDTX_Enabled = 0x1
	// Position of AUTOCOLRESSTARTED field.
	NFCT_INTEN_AUTOCOLRESSTARTED_Pos = 0xe
	// Bit mask of AUTOCOLRESSTARTED field.
	NFCT_INTEN_AUTOCOLRESSTARTED_Msk = 0x4000
	// Bit AUTOCOLRESSTARTED.
	NFCT_INTEN_AUTOCOLRESSTARTED = 0x4000
	// Disable
	NFCT_INTEN_AUTOCOLRESSTARTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_AUTOCOLRESSTARTED_Enabled = 0x1
	// Position of COLLISION field.
	NFCT_INTEN_COLLISION_Pos = 0x12
	// Bit mask of COLLISION field.
	NFCT_INTEN_COLLISION_Msk = 0x40000
	// Bit COLLISION.
	NFCT_INTEN_COLLISION = 0x40000
	// Disable
	NFCT_INTEN_COLLISION_Disabled = 0x0
	// Enable
	NFCT_INTEN_COLLISION_Enabled = 0x1
	// Position of SELECTED field.
	NFCT_INTEN_SELECTED_Pos = 0x13
	// Bit mask of SELECTED field.
	NFCT_INTEN_SELECTED_Msk = 0x80000
	// Bit SELECTED.
	NFCT_INTEN_SELECTED = 0x80000
	// Disable
	NFCT_INTEN_SELECTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_SELECTED_Enabled = 0x1
	// Position of STARTED field.
	NFCT_INTEN_STARTED_Pos = 0x14
	// Bit mask of STARTED field.
	NFCT_INTEN_STARTED_Msk = 0x100000
	// Bit STARTED.
	NFCT_INTEN_STARTED = 0x100000
	// Disable
	NFCT_INTEN_STARTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_STARTED_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	NFCT_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	NFCT_INTENSET_READY_Msk = 0x1
	// Bit READY.
	NFCT_INTENSET_READY = 0x1
	// Read: Disabled
	NFCT_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_READY_Enabled = 0x1
	// Enable
	NFCT_INTENSET_READY_Set = 0x1
	// Position of FIELDDETECTED field.
	NFCT_INTENSET_FIELDDETECTED_Pos = 0x1
	// Bit mask of FIELDDETECTED field.
	NFCT_INTENSET_FIELDDETECTED_Msk = 0x2
	// Bit FIELDDETECTED.
	NFCT_INTENSET_FIELDDETECTED = 0x2
	// Read: Disabled
	NFCT_INTENSET_FIELDDETECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_FIELDDETECTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_FIELDDETECTED_Set = 0x1
	// Position of FIELDLOST field.
	NFCT_INTENSET_FIELDLOST_Pos = 0x2
	// Bit mask of FIELDLOST field.
	NFCT_INTENSET_FIELDLOST_Msk = 0x4
	// Bit FIELDLOST.
	NFCT_INTENSET_FIELDLOST = 0x4
	// Read: Disabled
	NFCT_INTENSET_FIELDLOST_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_FIELDLOST_Enabled = 0x1
	// Enable
	NFCT_INTENSET_FIELDLOST_Set = 0x1
	// Position of TXFRAMESTART field.
	NFCT_INTENSET_TXFRAMESTART_Pos = 0x3
	// Bit mask of TXFRAMESTART field.
	NFCT_INTENSET_TXFRAMESTART_Msk = 0x8
	// Bit TXFRAMESTART.
	NFCT_INTENSET_TXFRAMESTART = 0x8
	// Read: Disabled
	NFCT_INTENSET_TXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_TXFRAMESTART_Enabled = 0x1
	// Enable
	NFCT_INTENSET_TXFRAMESTART_Set = 0x1
	// Position of TXFRAMEEND field.
	NFCT_INTENSET_TXFRAMEEND_Pos = 0x4
	// Bit mask of TXFRAMEEND field.
	NFCT_INTENSET_TXFRAMEEND_Msk = 0x10
	// Bit TXFRAMEEND.
	NFCT_INTENSET_TXFRAMEEND = 0x10
	// Read: Disabled
	NFCT_INTENSET_TXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_TXFRAMEEND_Enabled = 0x1
	// Enable
	NFCT_INTENSET_TXFRAMEEND_Set = 0x1
	// Position of RXFRAMESTART field.
	NFCT_INTENSET_RXFRAMESTART_Pos = 0x5
	// Bit mask of RXFRAMESTART field.
	NFCT_INTENSET_RXFRAMESTART_Msk = 0x20
	// Bit RXFRAMESTART.
	NFCT_INTENSET_RXFRAMESTART = 0x20
	// Read: Disabled
	NFCT_INTENSET_RXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_RXFRAMESTART_Enabled = 0x1
	// Enable
	NFCT_INTENSET_RXFRAMESTART_Set = 0x1
	// Position of RXFRAMEEND field.
	NFCT_INTENSET_RXFRAMEEND_Pos = 0x6
	// Bit mask of RXFRAMEEND field.
	NFCT_INTENSET_RXFRAMEEND_Msk = 0x40
	// Bit RXFRAMEEND.
	NFCT_INTENSET_RXFRAMEEND = 0x40
	// Read: Disabled
	NFCT_INTENSET_RXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_RXFRAMEEND_Enabled = 0x1
	// Enable
	NFCT_INTENSET_RXFRAMEEND_Set = 0x1
	// Position of ERROR field.
	NFCT_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	NFCT_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	NFCT_INTENSET_ERROR = 0x80
	// Read: Disabled
	NFCT_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_ERROR_Enabled = 0x1
	// Enable
	NFCT_INTENSET_ERROR_Set = 0x1
	// Position of RXERROR field.
	NFCT_INTENSET_RXERROR_Pos = 0xa
	// Bit mask of RXERROR field.
	NFCT_INTENSET_RXERROR_Msk = 0x400
	// Bit RXERROR.
	NFCT_INTENSET_RXERROR = 0x400
	// Read: Disabled
	NFCT_INTENSET_RXERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_RXERROR_Enabled = 0x1
	// Enable
	NFCT_INTENSET_RXERROR_Set = 0x1
	// Position of ENDRX field.
	NFCT_INTENSET_ENDRX_Pos = 0xb
	// Bit mask of ENDRX field.
	NFCT_INTENSET_ENDRX_Msk = 0x800
	// Bit ENDRX.
	NFCT_INTENSET_ENDRX = 0x800
	// Read: Disabled
	NFCT_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	NFCT_INTENSET_ENDRX_Set = 0x1
	// Position of ENDTX field.
	NFCT_INTENSET_ENDTX_Pos = 0xc
	// Bit mask of ENDTX field.
	NFCT_INTENSET_ENDTX_Msk = 0x1000
	// Bit ENDTX.
	NFCT_INTENSET_ENDTX = 0x1000
	// Read: Disabled
	NFCT_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	NFCT_INTENSET_ENDTX_Set = 0x1
	// Position of AUTOCOLRESSTARTED field.
	NFCT_INTENSET_AUTOCOLRESSTARTED_Pos = 0xe
	// Bit mask of AUTOCOLRESSTARTED field.
	NFCT_INTENSET_AUTOCOLRESSTARTED_Msk = 0x4000
	// Bit AUTOCOLRESSTARTED.
	NFCT_INTENSET_AUTOCOLRESSTARTED = 0x4000
	// Read: Disabled
	NFCT_INTENSET_AUTOCOLRESSTARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_AUTOCOLRESSTARTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_AUTOCOLRESSTARTED_Set = 0x1
	// Position of COLLISION field.
	NFCT_INTENSET_COLLISION_Pos = 0x12
	// Bit mask of COLLISION field.
	NFCT_INTENSET_COLLISION_Msk = 0x40000
	// Bit COLLISION.
	NFCT_INTENSET_COLLISION = 0x40000
	// Read: Disabled
	NFCT_INTENSET_COLLISION_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_COLLISION_Enabled = 0x1
	// Enable
	NFCT_INTENSET_COLLISION_Set = 0x1
	// Position of SELECTED field.
	NFCT_INTENSET_SELECTED_Pos = 0x13
	// Bit mask of SELECTED field.
	NFCT_INTENSET_SELECTED_Msk = 0x80000
	// Bit SELECTED.
	NFCT_INTENSET_SELECTED = 0x80000
	// Read: Disabled
	NFCT_INTENSET_SELECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_SELECTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_SELECTED_Set = 0x1
	// Position of STARTED field.
	NFCT_INTENSET_STARTED_Pos = 0x14
	// Bit mask of STARTED field.
	NFCT_INTENSET_STARTED_Msk = 0x100000
	// Bit STARTED.
	NFCT_INTENSET_STARTED = 0x100000
	// Read: Disabled
	NFCT_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_STARTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_STARTED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	NFCT_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	NFCT_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	NFCT_INTENCLR_READY = 0x1
	// Read: Disabled
	NFCT_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_READY_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_READY_Clear = 0x1
	// Position of FIELDDETECTED field.
	NFCT_INTENCLR_FIELDDETECTED_Pos = 0x1
	// Bit mask of FIELDDETECTED field.
	NFCT_INTENCLR_FIELDDETECTED_Msk = 0x2
	// Bit FIELDDETECTED.
	NFCT_INTENCLR_FIELDDETECTED = 0x2
	// Read: Disabled
	NFCT_INTENCLR_FIELDDETECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_FIELDDETECTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_FIELDDETECTED_Clear = 0x1
	// Position of FIELDLOST field.
	NFCT_INTENCLR_FIELDLOST_Pos = 0x2
	// Bit mask of FIELDLOST field.
	NFCT_INTENCLR_FIELDLOST_Msk = 0x4
	// Bit FIELDLOST.
	NFCT_INTENCLR_FIELDLOST = 0x4
	// Read: Disabled
	NFCT_INTENCLR_FIELDLOST_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_FIELDLOST_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_FIELDLOST_Clear = 0x1
	// Position of TXFRAMESTART field.
	NFCT_INTENCLR_TXFRAMESTART_Pos = 0x3
	// Bit mask of TXFRAMESTART field.
	NFCT_INTENCLR_TXFRAMESTART_Msk = 0x8
	// Bit TXFRAMESTART.
	NFCT_INTENCLR_TXFRAMESTART = 0x8
	// Read: Disabled
	NFCT_INTENCLR_TXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_TXFRAMESTART_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_TXFRAMESTART_Clear = 0x1
	// Position of TXFRAMEEND field.
	NFCT_INTENCLR_TXFRAMEEND_Pos = 0x4
	// Bit mask of TXFRAMEEND field.
	NFCT_INTENCLR_TXFRAMEEND_Msk = 0x10
	// Bit TXFRAMEEND.
	NFCT_INTENCLR_TXFRAMEEND = 0x10
	// Read: Disabled
	NFCT_INTENCLR_TXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_TXFRAMEEND_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_TXFRAMEEND_Clear = 0x1
	// Position of RXFRAMESTART field.
	NFCT_INTENCLR_RXFRAMESTART_Pos = 0x5
	// Bit mask of RXFRAMESTART field.
	NFCT_INTENCLR_RXFRAMESTART_Msk = 0x20
	// Bit RXFRAMESTART.
	NFCT_INTENCLR_RXFRAMESTART = 0x20
	// Read: Disabled
	NFCT_INTENCLR_RXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_RXFRAMESTART_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_RXFRAMESTART_Clear = 0x1
	// Position of RXFRAMEEND field.
	NFCT_INTENCLR_RXFRAMEEND_Pos = 0x6
	// Bit mask of RXFRAMEEND field.
	NFCT_INTENCLR_RXFRAMEEND_Msk = 0x40
	// Bit RXFRAMEEND.
	NFCT_INTENCLR_RXFRAMEEND = 0x40
	// Read: Disabled
	NFCT_INTENCLR_RXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_RXFRAMEEND_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_RXFRAMEEND_Clear = 0x1
	// Position of ERROR field.
	NFCT_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	NFCT_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	NFCT_INTENCLR_ERROR = 0x80
	// Read: Disabled
	NFCT_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_ERROR_Clear = 0x1
	// Position of RXERROR field.
	NFCT_INTENCLR_RXERROR_Pos = 0xa
	// Bit mask of RXERROR field.
	NFCT_INTENCLR_RXERROR_Msk = 0x400
	// Bit RXERROR.
	NFCT_INTENCLR_RXERROR = 0x400
	// Read: Disabled
	NFCT_INTENCLR_RXERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_RXERROR_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_RXERROR_Clear = 0x1
	// Position of ENDRX field.
	NFCT_INTENCLR_ENDRX_Pos = 0xb
	// Bit mask of ENDRX field.
	NFCT_INTENCLR_ENDRX_Msk = 0x800
	// Bit ENDRX.
	NFCT_INTENCLR_ENDRX = 0x800
	// Read: Disabled
	NFCT_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_ENDRX_Clear = 0x1
	// Position of ENDTX field.
	NFCT_INTENCLR_ENDTX_Pos = 0xc
	// Bit mask of ENDTX field.
	NFCT_INTENCLR_ENDTX_Msk = 0x1000
	// Bit ENDTX.
	NFCT_INTENCLR_ENDTX = 0x1000
	// Read: Disabled
	NFCT_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_ENDTX_Clear = 0x1
	// Position of AUTOCOLRESSTARTED field.
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos = 0xe
	// Bit mask of AUTOCOLRESSTARTED field.
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Msk = 0x4000
	// Bit AUTOCOLRESSTARTED.
	NFCT_INTENCLR_AUTOCOLRESSTARTED = 0x4000
	// Read: Disabled
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Clear = 0x1
	// Position of COLLISION field.
	NFCT_INTENCLR_COLLISION_Pos = 0x12
	// Bit mask of COLLISION field.
	NFCT_INTENCLR_COLLISION_Msk = 0x40000
	// Bit COLLISION.
	NFCT_INTENCLR_COLLISION = 0x40000
	// Read: Disabled
	NFCT_INTENCLR_COLLISION_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_COLLISION_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_COLLISION_Clear = 0x1
	// Position of SELECTED field.
	NFCT_INTENCLR_SELECTED_Pos = 0x13
	// Bit mask of SELECTED field.
	NFCT_INTENCLR_SELECTED_Msk = 0x80000
	// Bit SELECTED.
	NFCT_INTENCLR_SELECTED = 0x80000
	// Read: Disabled
	NFCT_INTENCLR_SELECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_SELECTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_SELECTED_Clear = 0x1
	// Position of STARTED field.
	NFCT_INTENCLR_STARTED_Pos = 0x14
	// Bit mask of STARTED field.
	NFCT_INTENCLR_STARTED_Msk = 0x100000
	// Bit STARTED.
	NFCT_INTENCLR_STARTED = 0x100000
	// Read: Disabled
	NFCT_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_STARTED_Clear = 0x1

	// ERRORSTATUS: NFC Error Status register
	// Position of FRAMEDELAYTIMEOUT field.
	NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos = 0x0
	// Bit mask of FRAMEDELAYTIMEOUT field.
	NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk = 0x1
	// Bit FRAMEDELAYTIMEOUT.
	NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT = 0x1
	// Position of NFCFIELDTOOSTRONG field.
	NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Pos = 0x2
	// Bit mask of NFCFIELDTOOSTRONG field.
	NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk = 0x4
	// Bit NFCFIELDTOOSTRONG.
	NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG = 0x4
	// Position of NFCFIELDTOOWEAK field.
	NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Pos = 0x3
	// Bit mask of NFCFIELDTOOWEAK field.
	NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk = 0x8
	// Bit NFCFIELDTOOWEAK.
	NFCT_ERRORSTATUS_NFCFIELDTOOWEAK = 0x8

	// FRAMESTATUS.RX: Result of last incoming frames
	// Position of CRCERROR field.
	NFCT_FRAMESTATUS_RX_CRCERROR_Pos = 0x0
	// Bit mask of CRCERROR field.
	NFCT_FRAMESTATUS_RX_CRCERROR_Msk = 0x1
	// Bit CRCERROR.
	NFCT_FRAMESTATUS_RX_CRCERROR = 0x1
	// Valid CRC detected
	NFCT_FRAMESTATUS_RX_CRCERROR_CRCCorrect = 0x0
	// CRC received does not match local check
	NFCT_FRAMESTATUS_RX_CRCERROR_CRCError = 0x1
	// Position of PARITYSTATUS field.
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos = 0x2
	// Bit mask of PARITYSTATUS field.
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk = 0x4
	// Bit PARITYSTATUS.
	NFCT_FRAMESTATUS_RX_PARITYSTATUS = 0x4
	// Frame received with parity OK
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityOK = 0x0
	// Frame received with parity error
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityError = 0x1
	// Position of OVERRUN field.
	NFCT_FRAMESTATUS_RX_OVERRUN_Pos = 0x3
	// Bit mask of OVERRUN field.
	NFCT_FRAMESTATUS_RX_OVERRUN_Msk = 0x8
	// Bit OVERRUN.
	NFCT_FRAMESTATUS_RX_OVERRUN = 0x8
	// No overrun detected
	NFCT_FRAMESTATUS_RX_OVERRUN_NoOverrun = 0x0
	// Overrun error
	NFCT_FRAMESTATUS_RX_OVERRUN_Overrun = 0x1

	// CURRENTLOADCTRL: Current value driven to the NFC Load Control
	// Position of CURRENTLOADCTRL field.
	NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Pos = 0x0
	// Bit mask of CURRENTLOADCTRL field.
	NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Msk = 0x3f

	// FIELDPRESENT: Indicates the presence or not of a valid field
	// Position of FIELDPRESENT field.
	NFCT_FIELDPRESENT_FIELDPRESENT_Pos = 0x0
	// Bit mask of FIELDPRESENT field.
	NFCT_FIELDPRESENT_FIELDPRESENT_Msk = 0x1
	// Bit FIELDPRESENT.
	NFCT_FIELDPRESENT_FIELDPRESENT = 0x1
	// No valid field detected
	NFCT_FIELDPRESENT_FIELDPRESENT_NoField = 0x0
	// Valid field detected
	NFCT_FIELDPRESENT_FIELDPRESENT_FieldPresent = 0x1
	// Position of LOCKDETECT field.
	NFCT_FIELDPRESENT_LOCKDETECT_Pos = 0x1
	// Bit mask of LOCKDETECT field.
	NFCT_FIELDPRESENT_LOCKDETECT_Msk = 0x2
	// Bit LOCKDETECT.
	NFCT_FIELDPRESENT_LOCKDETECT = 0x2
	// Not locked to field
	NFCT_FIELDPRESENT_LOCKDETECT_NotLocked = 0x0
	// Locked to field
	NFCT_FIELDPRESENT_LOCKDETECT_Locked = 0x1

	// FRAMEDELAYMIN: Minimum frame delay
	// Position of FRAMEDELAYMIN field.
	NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos = 0x0
	// Bit mask of FRAMEDELAYMIN field.
	NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk = 0xffff

	// FRAMEDELAYMAX: Maximum frame delay
	// Position of FRAMEDELAYMAX field.
	NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos = 0x0
	// Bit mask of FRAMEDELAYMAX field.
	NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk = 0xffff

	// FRAMEDELAYMODE: Configuration register for the Frame Delay Timer
	// Position of FRAMEDELAYMODE field.
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos = 0x0
	// Bit mask of FRAMEDELAYMODE field.
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk = 0x3
	// Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout.
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun = 0x0
	// Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window = 0x1
	// Frame is transmitted exactly at FRAMEDELAYMAX
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal = 0x2
	// Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid = 0x3

	// PACKETPTR: Packet pointer for TXD and RXD data storage in Data RAM
	// Position of PTR field.
	NFCT_PACKETPTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	NFCT_PACKETPTR_PTR_Msk = 0xffffffff

	// MAXLEN: Size of allocated for TXD and RXD data storage buffer in Data RAM
	// Position of MAXLEN field.
	NFCT_MAXLEN_MAXLEN_Pos = 0x0
	// Bit mask of MAXLEN field.
	NFCT_MAXLEN_MAXLEN_Msk = 0x1ff

	// TXD.FRAMECONFIG: Configuration of outgoing frames
	// Position of PARITY field.
	NFCT_TXD_FRAMECONFIG_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	NFCT_TXD_FRAMECONFIG_PARITY_Msk = 0x1
	// Bit PARITY.
	NFCT_TXD_FRAMECONFIG_PARITY = 0x1
	// Parity is not added in TX frames
	NFCT_TXD_FRAMECONFIG_PARITY_NoParity = 0x0
	// Parity is added TX frames
	NFCT_TXD_FRAMECONFIG_PARITY_Parity = 0x1
	// Position of DISCARDMODE field.
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos = 0x1
	// Bit mask of DISCARDMODE field.
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk = 0x2
	// Bit DISCARDMODE.
	NFCT_TXD_FRAMECONFIG_DISCARDMODE = 0x2
	// Unused bits is discarded at end of frame
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardEnd = 0x0
	// Unused bits is discarded at start of frame
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardStart = 0x1
	// Position of SOF field.
	NFCT_TXD_FRAMECONFIG_SOF_Pos = 0x2
	// Bit mask of SOF field.
	NFCT_TXD_FRAMECONFIG_SOF_Msk = 0x4
	// Bit SOF.
	NFCT_TXD_FRAMECONFIG_SOF = 0x4
	// Start of Frame symbol not added
	NFCT_TXD_FRAMECONFIG_SOF_NoSoF = 0x0
	// Start of Frame symbol added
	NFCT_TXD_FRAMECONFIG_SOF_SoF = 0x1
	// Position of CRCMODETX field.
	NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos = 0x4
	// Bit mask of CRCMODETX field.
	NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk = 0x10
	// Bit CRCMODETX.
	NFCT_TXD_FRAMECONFIG_CRCMODETX = 0x10
	// CRC is not added to the frame
	NFCT_TXD_FRAMECONFIG_CRCMODETX_NoCRCTX = 0x0
	// 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame
	NFCT_TXD_FRAMECONFIG_CRCMODETX_CRC16TX = 0x1

	// TXD.AMOUNT: Size of outgoing frame
	// Position of TXDATABITS field.
	NFCT_TXD_AMOUNT_TXDATABITS_Pos = 0x0
	// Bit mask of TXDATABITS field.
	NFCT_TXD_AMOUNT_TXDATABITS_Msk = 0x7
	// Position of TXDATABYTES field.
	NFCT_TXD_AMOUNT_TXDATABYTES_Pos = 0x3
	// Bit mask of TXDATABYTES field.
	NFCT_TXD_AMOUNT_TXDATABYTES_Msk = 0xff8

	// RXD.FRAMECONFIG: Configuration of incoming frames
	// Position of PARITY field.
	NFCT_RXD_FRAMECONFIG_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	NFCT_RXD_FRAMECONFIG_PARITY_Msk = 0x1
	// Bit PARITY.
	NFCT_RXD_FRAMECONFIG_PARITY = 0x1
	// Parity is not expected in RX frames
	NFCT_RXD_FRAMECONFIG_PARITY_NoParity = 0x0
	// Parity is expected in RX frames
	NFCT_RXD_FRAMECONFIG_PARITY_Parity = 0x1
	// Position of SOF field.
	NFCT_RXD_FRAMECONFIG_SOF_Pos = 0x2
	// Bit mask of SOF field.
	NFCT_RXD_FRAMECONFIG_SOF_Msk = 0x4
	// Bit SOF.
	NFCT_RXD_FRAMECONFIG_SOF = 0x4
	// Start of Frame symbol is not expected in RX frames
	NFCT_RXD_FRAMECONFIG_SOF_NoSoF = 0x0
	// Start of Frame symbol is expected in RX frames
	NFCT_RXD_FRAMECONFIG_SOF_SoF = 0x1
	// Position of CRCMODERX field.
	NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos = 0x4
	// Bit mask of CRCMODERX field.
	NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk = 0x10
	// Bit CRCMODERX.
	NFCT_RXD_FRAMECONFIG_CRCMODERX = 0x10
	// CRC is not expected in RX frames
	NFCT_RXD_FRAMECONFIG_CRCMODERX_NoCRCRX = 0x0
	// Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated
	NFCT_RXD_FRAMECONFIG_CRCMODERX_CRC16RX = 0x1

	// RXD.AMOUNT: Size of last incoming frame
	// Position of RXDATABITS field.
	NFCT_RXD_AMOUNT_RXDATABITS_Pos = 0x0
	// Bit mask of RXDATABITS field.
	NFCT_RXD_AMOUNT_RXDATABITS_Msk = 0x7
	// Position of RXDATABYTES field.
	NFCT_RXD_AMOUNT_RXDATABYTES_Pos = 0x3
	// Bit mask of RXDATABYTES field.
	NFCT_RXD_AMOUNT_RXDATABYTES_Msk = 0xff8

	// NFCID1_LAST: Last NFCID1 part (4, 7 or 10 bytes ID)
	// Position of NFCID1_Z field.
	NFCT_NFCID1_LAST_NFCID1_Z_Pos = 0x0
	// Bit mask of NFCID1_Z field.
	NFCT_NFCID1_LAST_NFCID1_Z_Msk = 0xff
	// Position of NFCID1_Y field.
	NFCT_NFCID1_LAST_NFCID1_Y_Pos = 0x8
	// Bit mask of NFCID1_Y field.
	NFCT_NFCID1_LAST_NFCID1_Y_Msk = 0xff00
	// Position of NFCID1_X field.
	NFCT_NFCID1_LAST_NFCID1_X_Pos = 0x10
	// Bit mask of NFCID1_X field.
	NFCT_NFCID1_LAST_NFCID1_X_Msk = 0xff0000
	// Position of NFCID1_W field.
	NFCT_NFCID1_LAST_NFCID1_W_Pos = 0x18
	// Bit mask of NFCID1_W field.
	NFCT_NFCID1_LAST_NFCID1_W_Msk = 0xff000000

	// NFCID1_2ND_LAST: Second last NFCID1 part (7 or 10 bytes ID)
	// Position of NFCID1_V field.
	NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos = 0x0
	// Bit mask of NFCID1_V field.
	NFCT_NFCID1_2ND_LAST_NFCID1_V_Msk = 0xff
	// Position of NFCID1_U field.
	NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos = 0x8
	// Bit mask of NFCID1_U field.
	NFCT_NFCID1_2ND_LAST_NFCID1_U_Msk = 0xff00
	// Position of NFCID1_T field.
	NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos = 0x10
	// Bit mask of NFCID1_T field.
	NFCT_NFCID1_2ND_LAST_NFCID1_T_Msk = 0xff0000

	// NFCID1_3RD_LAST: Third last NFCID1 part (10 bytes ID)
	// Position of NFCID1_S field.
	NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos = 0x0
	// Bit mask of NFCID1_S field.
	NFCT_NFCID1_3RD_LAST_NFCID1_S_Msk = 0xff
	// Position of NFCID1_R field.
	NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos = 0x8
	// Bit mask of NFCID1_R field.
	NFCT_NFCID1_3RD_LAST_NFCID1_R_Msk = 0xff00
	// Position of NFCID1_Q field.
	NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos = 0x10
	// Bit mask of NFCID1_Q field.
	NFCT_NFCID1_3RD_LAST_NFCID1_Q_Msk = 0xff0000

	// SENSRES: NFC-A SENS_RES auto-response settings
	// Position of BITFRAMESDD field.
	NFCT_SENSRES_BITFRAMESDD_Pos = 0x0
	// Bit mask of BITFRAMESDD field.
	NFCT_SENSRES_BITFRAMESDD_Msk = 0x1f
	// SDD pattern 00000
	NFCT_SENSRES_BITFRAMESDD_SDD00000 = 0x0
	// SDD pattern 00001
	NFCT_SENSRES_BITFRAMESDD_SDD00001 = 0x1
	// SDD pattern 00010
	NFCT_SENSRES_BITFRAMESDD_SDD00010 = 0x2
	// SDD pattern 00100
	NFCT_SENSRES_BITFRAMESDD_SDD00100 = 0x4
	// SDD pattern 01000
	NFCT_SENSRES_BITFRAMESDD_SDD01000 = 0x8
	// SDD pattern 10000
	NFCT_SENSRES_BITFRAMESDD_SDD10000 = 0x10
	// Position of RFU5 field.
	NFCT_SENSRES_RFU5_Pos = 0x5
	// Bit mask of RFU5 field.
	NFCT_SENSRES_RFU5_Msk = 0x20
	// Bit RFU5.
	NFCT_SENSRES_RFU5 = 0x20
	// Position of NFCIDSIZE field.
	NFCT_SENSRES_NFCIDSIZE_Pos = 0x6
	// Bit mask of NFCIDSIZE field.
	NFCT_SENSRES_NFCIDSIZE_Msk = 0xc0
	// NFCID1 size: single (4 bytes)
	NFCT_SENSRES_NFCIDSIZE_NFCID1Single = 0x0
	// NFCID1 size: double (7 bytes)
	NFCT_SENSRES_NFCIDSIZE_NFCID1Double = 0x1
	// NFCID1 size: triple (10 bytes)
	NFCT_SENSRES_NFCIDSIZE_NFCID1Triple = 0x2
	// Position of PLATFCONFIG field.
	NFCT_SENSRES_PLATFCONFIG_Pos = 0x8
	// Bit mask of PLATFCONFIG field.
	NFCT_SENSRES_PLATFCONFIG_Msk = 0xf00
	// Position of RFU74 field.
	NFCT_SENSRES_RFU74_Pos = 0xc
	// Bit mask of RFU74 field.
	NFCT_SENSRES_RFU74_Msk = 0xf000

	// SELRES: NFC-A SEL_RES auto-response settings
	// Position of RFU10 field.
	NFCT_SELRES_RFU10_Pos = 0x0
	// Bit mask of RFU10 field.
	NFCT_SELRES_RFU10_Msk = 0x3
	// Position of CASCADE field.
	NFCT_SELRES_CASCADE_Pos = 0x2
	// Bit mask of CASCADE field.
	NFCT_SELRES_CASCADE_Msk = 0x4
	// Bit CASCADE.
	NFCT_SELRES_CASCADE = 0x4
	// NFCID1 complete
	NFCT_SELRES_CASCADE_Complete = 0x0
	// NFCID1 not complete
	NFCT_SELRES_CASCADE_NotComplete = 0x1
	// Position of RFU43 field.
	NFCT_SELRES_RFU43_Pos = 0x3
	// Bit mask of RFU43 field.
	NFCT_SELRES_RFU43_Msk = 0x18
	// Position of PROTOCOL field.
	NFCT_SELRES_PROTOCOL_Pos = 0x5
	// Bit mask of PROTOCOL field.
	NFCT_SELRES_PROTOCOL_Msk = 0x60
	// Position of RFU7 field.
	NFCT_SELRES_RFU7_Pos = 0x7
	// Bit mask of RFU7 field.
	NFCT_SELRES_RFU7_Msk = 0x80
	// Bit RFU7.
	NFCT_SELRES_RFU7 = 0x80
)

// Constants for GPIOTE: GPIO Tasks and Events
const (
	// INTENSET: Enable interrupt
	// Position of IN0 field.
	GPIOTE_INTENSET_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	GPIOTE_INTENSET_IN0_Msk = 0x1
	// Bit IN0.
	GPIOTE_INTENSET_IN0 = 0x1
	// Read: Disabled
	GPIOTE_INTENSET_IN0_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN0_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN0_Set = 0x1
	// Position of IN1 field.
	GPIOTE_INTENSET_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	GPIOTE_INTENSET_IN1_Msk = 0x2
	// Bit IN1.
	GPIOTE_INTENSET_IN1 = 0x2
	// Read: Disabled
	GPIOTE_INTENSET_IN1_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN1_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN1_Set = 0x1
	// Position of IN2 field.
	GPIOTE_INTENSET_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	GPIOTE_INTENSET_IN2_Msk = 0x4
	// Bit IN2.
	GPIOTE_INTENSET_IN2 = 0x4
	// Read: Disabled
	GPIOTE_INTENSET_IN2_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN2_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN2_Set = 0x1
	// Position of IN3 field.
	GPIOTE_INTENSET_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	GPIOTE_INTENSET_IN3_Msk = 0x8
	// Bit IN3.
	GPIOTE_INTENSET_IN3 = 0x8
	// Read: Disabled
	GPIOTE_INTENSET_IN3_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN3_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN3_Set = 0x1
	// Position of IN4 field.
	GPIOTE_INTENSET_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	GPIOTE_INTENSET_IN4_Msk = 0x10
	// Bit IN4.
	GPIOTE_INTENSET_IN4 = 0x10
	// Read: Disabled
	GPIOTE_INTENSET_IN4_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN4_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN4_Set = 0x1
	// Position of IN5 field.
	GPIOTE_INTENSET_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	GPIOTE_INTENSET_IN5_Msk = 0x20
	// Bit IN5.
	GPIOTE_INTENSET_IN5 = 0x20
	// Read: Disabled
	GPIOTE_INTENSET_IN5_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN5_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN5_Set = 0x1
	// Position of IN6 field.
	GPIOTE_INTENSET_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	GPIOTE_INTENSET_IN6_Msk = 0x40
	// Bit IN6.
	GPIOTE_INTENSET_IN6 = 0x40
	// Read: Disabled
	GPIOTE_INTENSET_IN6_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN6_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN6_Set = 0x1
	// Position of IN7 field.
	GPIOTE_INTENSET_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	GPIOTE_INTENSET_IN7_Msk = 0x80
	// Bit IN7.
	GPIOTE_INTENSET_IN7 = 0x80
	// Read: Disabled
	GPIOTE_INTENSET_IN7_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN7_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN7_Set = 0x1
	// Position of PORT field.
	GPIOTE_INTENSET_PORT_Pos = 0x1f
	// Bit mask of PORT field.
	GPIOTE_INTENSET_PORT_Msk = 0x80000000
	// Bit PORT.
	GPIOTE_INTENSET_PORT = 0x80000000
	// Read: Disabled
	GPIOTE_INTENSET_PORT_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_PORT_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_PORT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of IN0 field.
	GPIOTE_INTENCLR_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	GPIOTE_INTENCLR_IN0_Msk = 0x1
	// Bit IN0.
	GPIOTE_INTENCLR_IN0 = 0x1
	// Read: Disabled
	GPIOTE_INTENCLR_IN0_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN0_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN0_Clear = 0x1
	// Position of IN1 field.
	GPIOTE_INTENCLR_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	GPIOTE_INTENCLR_IN1_Msk = 0x2
	// Bit IN1.
	GPIOTE_INTENCLR_IN1 = 0x2
	// Read: Disabled
	GPIOTE_INTENCLR_IN1_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN1_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN1_Clear = 0x1
	// Position of IN2 field.
	GPIOTE_INTENCLR_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	GPIOTE_INTENCLR_IN2_Msk = 0x4
	// Bit IN2.
	GPIOTE_INTENCLR_IN2 = 0x4
	// Read: Disabled
	GPIOTE_INTENCLR_IN2_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN2_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN2_Clear = 0x1
	// Position of IN3 field.
	GPIOTE_INTENCLR_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	GPIOTE_INTENCLR_IN3_Msk = 0x8
	// Bit IN3.
	GPIOTE_INTENCLR_IN3 = 0x8
	// Read: Disabled
	GPIOTE_INTENCLR_IN3_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN3_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN3_Clear = 0x1
	// Position of IN4 field.
	GPIOTE_INTENCLR_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	GPIOTE_INTENCLR_IN4_Msk = 0x10
	// Bit IN4.
	GPIOTE_INTENCLR_IN4 = 0x10
	// Read: Disabled
	GPIOTE_INTENCLR_IN4_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN4_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN4_Clear = 0x1
	// Position of IN5 field.
	GPIOTE_INTENCLR_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	GPIOTE_INTENCLR_IN5_Msk = 0x20
	// Bit IN5.
	GPIOTE_INTENCLR_IN5 = 0x20
	// Read: Disabled
	GPIOTE_INTENCLR_IN5_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN5_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN5_Clear = 0x1
	// Position of IN6 field.
	GPIOTE_INTENCLR_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	GPIOTE_INTENCLR_IN6_Msk = 0x40
	// Bit IN6.
	GPIOTE_INTENCLR_IN6 = 0x40
	// Read: Disabled
	GPIOTE_INTENCLR_IN6_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN6_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN6_Clear = 0x1
	// Position of IN7 field.
	GPIOTE_INTENCLR_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	GPIOTE_INTENCLR_IN7_Msk = 0x80
	// Bit IN7.
	GPIOTE_INTENCLR_IN7 = 0x80
	// Read: Disabled
	GPIOTE_INTENCLR_IN7_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN7_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN7_Clear = 0x1
	// Position of PORT field.
	GPIOTE_INTENCLR_PORT_Pos = 0x1f
	// Bit mask of PORT field.
	GPIOTE_INTENCLR_PORT_Msk = 0x80000000
	// Bit PORT.
	GPIOTE_INTENCLR_PORT = 0x80000000
	// Read: Disabled
	GPIOTE_INTENCLR_PORT_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_PORT_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_PORT_Clear = 0x1

	// CONFIG: Description collection[0]: Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event
	// Position of MODE field.
	GPIOTE_CONFIG_MODE_Pos = 0x0
	// Bit mask of MODE field.
	GPIOTE_CONFIG_MODE_Msk = 0x3
	// Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module.
	GPIOTE_CONFIG_MODE_Disabled = 0x0
	// Event mode
	GPIOTE_CONFIG_MODE_Event = 0x1
	// Task mode
	GPIOTE_CONFIG_MODE_Task = 0x3
	// Position of PSEL field.
	GPIOTE_CONFIG_PSEL_Pos = 0x8
	// Bit mask of PSEL field.
	GPIOTE_CONFIG_PSEL_Msk = 0x1f00
	// Position of POLARITY field.
	GPIOTE_CONFIG_POLARITY_Pos = 0x10
	// Bit mask of POLARITY field.
	GPIOTE_CONFIG_POLARITY_Msk = 0x30000
	// Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.
	GPIOTE_CONFIG_POLARITY_None = 0x0
	// Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.
	GPIOTE_CONFIG_POLARITY_LoToHi = 0x1
	// Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.
	GPIOTE_CONFIG_POLARITY_HiToLo = 0x2
	// Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.
	GPIOTE_CONFIG_POLARITY_Toggle = 0x3
	// Position of OUTINIT field.
	GPIOTE_CONFIG_OUTINIT_Pos = 0x14
	// Bit mask of OUTINIT field.
	GPIOTE_CONFIG_OUTINIT_Msk = 0x100000
	// Bit OUTINIT.
	GPIOTE_CONFIG_OUTINIT = 0x100000
	// Task mode: Initial value of pin before task triggering is low
	GPIOTE_CONFIG_OUTINIT_Low = 0x0
	// Task mode: Initial value of pin before task triggering is high
	GPIOTE_CONFIG_OUTINIT_High = 0x1
)

// Constants for SAADC: Analog to Digital Converter
const (
	// EVENTS_CH.LIMITH: Description cluster[0]: Last results is equal or above CH[0].LIMIT.HIGH

	// EVENTS_CH.LIMITL: Description cluster[0]: Last results is equal or below CH[0].LIMIT.LOW

	// INTEN: Enable or disable interrupt
	// Position of STARTED field.
	SAADC_INTEN_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	SAADC_INTEN_STARTED_Msk = 0x1
	// Bit STARTED.
	SAADC_INTEN_STARTED = 0x1
	// Disable
	SAADC_INTEN_STARTED_Disabled = 0x0
	// Enable
	SAADC_INTEN_STARTED_Enabled = 0x1
	// Position of END field.
	SAADC_INTEN_END_Pos = 0x1
	// Bit mask of END field.
	SAADC_INTEN_END_Msk = 0x2
	// Bit END.
	SAADC_INTEN_END = 0x2
	// Disable
	SAADC_INTEN_END_Disabled = 0x0
	// Enable
	SAADC_INTEN_END_Enabled = 0x1
	// Position of DONE field.
	SAADC_INTEN_DONE_Pos = 0x2
	// Bit mask of DONE field.
	SAADC_INTEN_DONE_Msk = 0x4
	// Bit DONE.
	SAADC_INTEN_DONE = 0x4
	// Disable
	SAADC_INTEN_DONE_Disabled = 0x0
	// Enable
	SAADC_INTEN_DONE_Enabled = 0x1
	// Position of RESULTDONE field.
	SAADC_INTEN_RESULTDONE_Pos = 0x3
	// Bit mask of RESULTDONE field.
	SAADC_INTEN_RESULTDONE_Msk = 0x8
	// Bit RESULTDONE.
	SAADC_INTEN_RESULTDONE = 0x8
	// Disable
	SAADC_INTEN_RESULTDONE_Disabled = 0x0
	// Enable
	SAADC_INTEN_RESULTDONE_Enabled = 0x1
	// Position of CALIBRATEDONE field.
	SAADC_INTEN_CALIBRATEDONE_Pos = 0x4
	// Bit mask of CALIBRATEDONE field.
	SAADC_INTEN_CALIBRATEDONE_Msk = 0x10
	// Bit CALIBRATEDONE.
	SAADC_INTEN_CALIBRATEDONE = 0x10
	// Disable
	SAADC_INTEN_CALIBRATEDONE_Disabled = 0x0
	// Enable
	SAADC_INTEN_CALIBRATEDONE_Enabled = 0x1
	// Position of STOPPED field.
	SAADC_INTEN_STOPPED_Pos = 0x5
	// Bit mask of STOPPED field.
	SAADC_INTEN_STOPPED_Msk = 0x20
	// Bit STOPPED.
	SAADC_INTEN_STOPPED = 0x20
	// Disable
	SAADC_INTEN_STOPPED_Disabled = 0x0
	// Enable
	SAADC_INTEN_STOPPED_Enabled = 0x1
	// Position of CH0LIMITH field.
	SAADC_INTEN_CH0LIMITH_Pos = 0x6
	// Bit mask of CH0LIMITH field.
	SAADC_INTEN_CH0LIMITH_Msk = 0x40
	// Bit CH0LIMITH.
	SAADC_INTEN_CH0LIMITH = 0x40
	// Disable
	SAADC_INTEN_CH0LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH0LIMITH_Enabled = 0x1
	// Position of CH0LIMITL field.
	SAADC_INTEN_CH0LIMITL_Pos = 0x7
	// Bit mask of CH0LIMITL field.
	SAADC_INTEN_CH0LIMITL_Msk = 0x80
	// Bit CH0LIMITL.
	SAADC_INTEN_CH0LIMITL = 0x80
	// Disable
	SAADC_INTEN_CH0LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH0LIMITL_Enabled = 0x1
	// Position of CH1LIMITH field.
	SAADC_INTEN_CH1LIMITH_Pos = 0x8
	// Bit mask of CH1LIMITH field.
	SAADC_INTEN_CH1LIMITH_Msk = 0x100
	// Bit CH1LIMITH.
	SAADC_INTEN_CH1LIMITH = 0x100
	// Disable
	SAADC_INTEN_CH1LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH1LIMITH_Enabled = 0x1
	// Position of CH1LIMITL field.
	SAADC_INTEN_CH1LIMITL_Pos = 0x9
	// Bit mask of CH1LIMITL field.
	SAADC_INTEN_CH1LIMITL_Msk = 0x200
	// Bit CH1LIMITL.
	SAADC_INTEN_CH1LIMITL = 0x200
	// Disable
	SAADC_INTEN_CH1LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH1LIMITL_Enabled = 0x1
	// Position of CH2LIMITH field.
	SAADC_INTEN_CH2LIMITH_Pos = 0xa
	// Bit mask of CH2LIMITH field.
	SAADC_INTEN_CH2LIMITH_Msk = 0x400
	// Bit CH2LIMITH.
	SAADC_INTEN_CH2LIMITH = 0x400
	// Disable
	SAADC_INTEN_CH2LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH2LIMITH_Enabled = 0x1
	// Position of CH2LIMITL field.
	SAADC_INTEN_CH2LIMITL_Pos = 0xb
	// Bit mask of CH2LIMITL field.
	SAADC_INTEN_CH2LIMITL_Msk = 0x800
	// Bit CH2LIMITL.
	SAADC_INTEN_CH2LIMITL = 0x800
	// Disable
	SAADC_INTEN_CH2LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH2LIMITL_Enabled = 0x1
	// Position of CH3LIMITH field.
	SAADC_INTEN_CH3LIMITH_Pos = 0xc
	// Bit mask of CH3LIMITH field.
	SAADC_INTEN_CH3LIMITH_Msk = 0x1000
	// Bit CH3LIMITH.
	SAADC_INTEN_CH3LIMITH = 0x1000
	// Disable
	SAADC_INTEN_CH3LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH3LIMITH_Enabled = 0x1
	// Position of CH3LIMITL field.
	SAADC_INTEN_CH3LIMITL_Pos = 0xd
	// Bit mask of CH3LIMITL field.
	SAADC_INTEN_CH3LIMITL_Msk = 0x2000
	// Bit CH3LIMITL.
	SAADC_INTEN_CH3LIMITL = 0x2000
	// Disable
	SAADC_INTEN_CH3LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH3LIMITL_Enabled = 0x1
	// Position of CH4LIMITH field.
	SAADC_INTEN_CH4LIMITH_Pos = 0xe
	// Bit mask of CH4LIMITH field.
	SAADC_INTEN_CH4LIMITH_Msk = 0x4000
	// Bit CH4LIMITH.
	SAADC_INTEN_CH4LIMITH = 0x4000
	// Disable
	SAADC_INTEN_CH4LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH4LIMITH_Enabled = 0x1
	// Position of CH4LIMITL field.
	SAADC_INTEN_CH4LIMITL_Pos = 0xf
	// Bit mask of CH4LIMITL field.
	SAADC_INTEN_CH4LIMITL_Msk = 0x8000
	// Bit CH4LIMITL.
	SAADC_INTEN_CH4LIMITL = 0x8000
	// Disable
	SAADC_INTEN_CH4LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH4LIMITL_Enabled = 0x1
	// Position of CH5LIMITH field.
	SAADC_INTEN_CH5LIMITH_Pos = 0x10
	// Bit mask of CH5LIMITH field.
	SAADC_INTEN_CH5LIMITH_Msk = 0x10000
	// Bit CH5LIMITH.
	SAADC_INTEN_CH5LIMITH = 0x10000
	// Disable
	SAADC_INTEN_CH5LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH5LIMITH_Enabled = 0x1
	// Position of CH5LIMITL field.
	SAADC_INTEN_CH5LIMITL_Pos = 0x11
	// Bit mask of CH5LIMITL field.
	SAADC_INTEN_CH5LIMITL_Msk = 0x20000
	// Bit CH5LIMITL.
	SAADC_INTEN_CH5LIMITL = 0x20000
	// Disable
	SAADC_INTEN_CH5LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH5LIMITL_Enabled = 0x1
	// Position of CH6LIMITH field.
	SAADC_INTEN_CH6LIMITH_Pos = 0x12
	// Bit mask of CH6LIMITH field.
	SAADC_INTEN_CH6LIMITH_Msk = 0x40000
	// Bit CH6LIMITH.
	SAADC_INTEN_CH6LIMITH = 0x40000
	// Disable
	SAADC_INTEN_CH6LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH6LIMITH_Enabled = 0x1
	// Position of CH6LIMITL field.
	SAADC_INTEN_CH6LIMITL_Pos = 0x13
	// Bit mask of CH6LIMITL field.
	SAADC_INTEN_CH6LIMITL_Msk = 0x80000
	// Bit CH6LIMITL.
	SAADC_INTEN_CH6LIMITL = 0x80000
	// Disable
	SAADC_INTEN_CH6LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH6LIMITL_Enabled = 0x1
	// Position of CH7LIMITH field.
	SAADC_INTEN_CH7LIMITH_Pos = 0x14
	// Bit mask of CH7LIMITH field.
	SAADC_INTEN_CH7LIMITH_Msk = 0x100000
	// Bit CH7LIMITH.
	SAADC_INTEN_CH7LIMITH = 0x100000
	// Disable
	SAADC_INTEN_CH7LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH7LIMITH_Enabled = 0x1
	// Position of CH7LIMITL field.
	SAADC_INTEN_CH7LIMITL_Pos = 0x15
	// Bit mask of CH7LIMITL field.
	SAADC_INTEN_CH7LIMITL_Msk = 0x200000
	// Bit CH7LIMITL.
	SAADC_INTEN_CH7LIMITL = 0x200000
	// Disable
	SAADC_INTEN_CH7LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH7LIMITL_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STARTED field.
	SAADC_INTENSET_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	SAADC_INTENSET_STARTED_Msk = 0x1
	// Bit STARTED.
	SAADC_INTENSET_STARTED = 0x1
	// Read: Disabled
	SAADC_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_STARTED_Enabled = 0x1
	// Enable
	SAADC_INTENSET_STARTED_Set = 0x1
	// Position of END field.
	SAADC_INTENSET_END_Pos = 0x1
	// Bit mask of END field.
	SAADC_INTENSET_END_Msk = 0x2
	// Bit END.
	SAADC_INTENSET_END = 0x2
	// Read: Disabled
	SAADC_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_END_Enabled = 0x1
	// Enable
	SAADC_INTENSET_END_Set = 0x1
	// Position of DONE field.
	SAADC_INTENSET_DONE_Pos = 0x2
	// Bit mask of DONE field.
	SAADC_INTENSET_DONE_Msk = 0x4
	// Bit DONE.
	SAADC_INTENSET_DONE = 0x4
	// Read: Disabled
	SAADC_INTENSET_DONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_DONE_Enabled = 0x1
	// Enable
	SAADC_INTENSET_DONE_Set = 0x1
	// Position of RESULTDONE field.
	SAADC_INTENSET_RESULTDONE_Pos = 0x3
	// Bit mask of RESULTDONE field.
	SAADC_INTENSET_RESULTDONE_Msk = 0x8
	// Bit RESULTDONE.
	SAADC_INTENSET_RESULTDONE = 0x8
	// Read: Disabled
	SAADC_INTENSET_RESULTDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_RESULTDONE_Enabled = 0x1
	// Enable
	SAADC_INTENSET_RESULTDONE_Set = 0x1
	// Position of CALIBRATEDONE field.
	SAADC_INTENSET_CALIBRATEDONE_Pos = 0x4
	// Bit mask of CALIBRATEDONE field.
	SAADC_INTENSET_CALIBRATEDONE_Msk = 0x10
	// Bit CALIBRATEDONE.
	SAADC_INTENSET_CALIBRATEDONE = 0x10
	// Read: Disabled
	SAADC_INTENSET_CALIBRATEDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CALIBRATEDONE_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CALIBRATEDONE_Set = 0x1
	// Position of STOPPED field.
	SAADC_INTENSET_STOPPED_Pos = 0x5
	// Bit mask of STOPPED field.
	SAADC_INTENSET_STOPPED_Msk = 0x20
	// Bit STOPPED.
	SAADC_INTENSET_STOPPED = 0x20
	// Read: Disabled
	SAADC_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	SAADC_INTENSET_STOPPED_Set = 0x1
	// Position of CH0LIMITH field.
	SAADC_INTENSET_CH0LIMITH_Pos = 0x6
	// Bit mask of CH0LIMITH field.
	SAADC_INTENSET_CH0LIMITH_Msk = 0x40
	// Bit CH0LIMITH.
	SAADC_INTENSET_CH0LIMITH = 0x40
	// Read: Disabled
	SAADC_INTENSET_CH0LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH0LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH0LIMITH_Set = 0x1
	// Position of CH0LIMITL field.
	SAADC_INTENSET_CH0LIMITL_Pos = 0x7
	// Bit mask of CH0LIMITL field.
	SAADC_INTENSET_CH0LIMITL_Msk = 0x80
	// Bit CH0LIMITL.
	SAADC_INTENSET_CH0LIMITL = 0x80
	// Read: Disabled
	SAADC_INTENSET_CH0LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH0LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH0LIMITL_Set = 0x1
	// Position of CH1LIMITH field.
	SAADC_INTENSET_CH1LIMITH_Pos = 0x8
	// Bit mask of CH1LIMITH field.
	SAADC_INTENSET_CH1LIMITH_Msk = 0x100
	// Bit CH1LIMITH.
	SAADC_INTENSET_CH1LIMITH = 0x100
	// Read: Disabled
	SAADC_INTENSET_CH1LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH1LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH1LIMITH_Set = 0x1
	// Position of CH1LIMITL field.
	SAADC_INTENSET_CH1LIMITL_Pos = 0x9
	// Bit mask of CH1LIMITL field.
	SAADC_INTENSET_CH1LIMITL_Msk = 0x200
	// Bit CH1LIMITL.
	SAADC_INTENSET_CH1LIMITL = 0x200
	// Read: Disabled
	SAADC_INTENSET_CH1LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH1LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH1LIMITL_Set = 0x1
	// Position of CH2LIMITH field.
	SAADC_INTENSET_CH2LIMITH_Pos = 0xa
	// Bit mask of CH2LIMITH field.
	SAADC_INTENSET_CH2LIMITH_Msk = 0x400
	// Bit CH2LIMITH.
	SAADC_INTENSET_CH2LIMITH = 0x400
	// Read: Disabled
	SAADC_INTENSET_CH2LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH2LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH2LIMITH_Set = 0x1
	// Position of CH2LIMITL field.
	SAADC_INTENSET_CH2LIMITL_Pos = 0xb
	// Bit mask of CH2LIMITL field.
	SAADC_INTENSET_CH2LIMITL_Msk = 0x800
	// Bit CH2LIMITL.
	SAADC_INTENSET_CH2LIMITL = 0x800
	// Read: Disabled
	SAADC_INTENSET_CH2LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH2LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH2LIMITL_Set = 0x1
	// Position of CH3LIMITH field.
	SAADC_INTENSET_CH3LIMITH_Pos = 0xc
	// Bit mask of CH3LIMITH field.
	SAADC_INTENSET_CH3LIMITH_Msk = 0x1000
	// Bit CH3LIMITH.
	SAADC_INTENSET_CH3LIMITH = 0x1000
	// Read: Disabled
	SAADC_INTENSET_CH3LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH3LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH3LIMITH_Set = 0x1
	// Position of CH3LIMITL field.
	SAADC_INTENSET_CH3LIMITL_Pos = 0xd
	// Bit mask of CH3LIMITL field.
	SAADC_INTENSET_CH3LIMITL_Msk = 0x2000
	// Bit CH3LIMITL.
	SAADC_INTENSET_CH3LIMITL = 0x2000
	// Read: Disabled
	SAADC_INTENSET_CH3LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH3LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH3LIMITL_Set = 0x1
	// Position of CH4LIMITH field.
	SAADC_INTENSET_CH4LIMITH_Pos = 0xe
	// Bit mask of CH4LIMITH field.
	SAADC_INTENSET_CH4LIMITH_Msk = 0x4000
	// Bit CH4LIMITH.
	SAADC_INTENSET_CH4LIMITH = 0x4000
	// Read: Disabled
	SAADC_INTENSET_CH4LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH4LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH4LIMITH_Set = 0x1
	// Position of CH4LIMITL field.
	SAADC_INTENSET_CH4LIMITL_Pos = 0xf
	// Bit mask of CH4LIMITL field.
	SAADC_INTENSET_CH4LIMITL_Msk = 0x8000
	// Bit CH4LIMITL.
	SAADC_INTENSET_CH4LIMITL = 0x8000
	// Read: Disabled
	SAADC_INTENSET_CH4LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH4LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH4LIMITL_Set = 0x1
	// Position of CH5LIMITH field.
	SAADC_INTENSET_CH5LIMITH_Pos = 0x10
	// Bit mask of CH5LIMITH field.
	SAADC_INTENSET_CH5LIMITH_Msk = 0x10000
	// Bit CH5LIMITH.
	SAADC_INTENSET_CH5LIMITH = 0x10000
	// Read: Disabled
	SAADC_INTENSET_CH5LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH5LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH5LIMITH_Set = 0x1
	// Position of CH5LIMITL field.
	SAADC_INTENSET_CH5LIMITL_Pos = 0x11
	// Bit mask of CH5LIMITL field.
	SAADC_INTENSET_CH5LIMITL_Msk = 0x20000
	// Bit CH5LIMITL.
	SAADC_INTENSET_CH5LIMITL = 0x20000
	// Read: Disabled
	SAADC_INTENSET_CH5LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH5LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH5LIMITL_Set = 0x1
	// Position of CH6LIMITH field.
	SAADC_INTENSET_CH6LIMITH_Pos = 0x12
	// Bit mask of CH6LIMITH field.
	SAADC_INTENSET_CH6LIMITH_Msk = 0x40000
	// Bit CH6LIMITH.
	SAADC_INTENSET_CH6LIMITH = 0x40000
	// Read: Disabled
	SAADC_INTENSET_CH6LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH6LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH6LIMITH_Set = 0x1
	// Position of CH6LIMITL field.
	SAADC_INTENSET_CH6LIMITL_Pos = 0x13
	// Bit mask of CH6LIMITL field.
	SAADC_INTENSET_CH6LIMITL_Msk = 0x80000
	// Bit CH6LIMITL.
	SAADC_INTENSET_CH6LIMITL = 0x80000
	// Read: Disabled
	SAADC_INTENSET_CH6LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH6LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH6LIMITL_Set = 0x1
	// Position of CH7LIMITH field.
	SAADC_INTENSET_CH7LIMITH_Pos = 0x14
	// Bit mask of CH7LIMITH field.
	SAADC_INTENSET_CH7LIMITH_Msk = 0x100000
	// Bit CH7LIMITH.
	SAADC_INTENSET_CH7LIMITH = 0x100000
	// Read: Disabled
	SAADC_INTENSET_CH7LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH7LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH7LIMITH_Set = 0x1
	// Position of CH7LIMITL field.
	SAADC_INTENSET_CH7LIMITL_Pos = 0x15
	// Bit mask of CH7LIMITL field.
	SAADC_INTENSET_CH7LIMITL_Msk = 0x200000
	// Bit CH7LIMITL.
	SAADC_INTENSET_CH7LIMITL = 0x200000
	// Read: Disabled
	SAADC_INTENSET_CH7LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH7LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH7LIMITL_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STARTED field.
	SAADC_INTENCLR_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	SAADC_INTENCLR_STARTED_Msk = 0x1
	// Bit STARTED.
	SAADC_INTENCLR_STARTED = 0x1
	// Read: Disabled
	SAADC_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_STARTED_Clear = 0x1
	// Position of END field.
	SAADC_INTENCLR_END_Pos = 0x1
	// Bit mask of END field.
	SAADC_INTENCLR_END_Msk = 0x2
	// Bit END.
	SAADC_INTENCLR_END = 0x2
	// Read: Disabled
	SAADC_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_END_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_END_Clear = 0x1
	// Position of DONE field.
	SAADC_INTENCLR_DONE_Pos = 0x2
	// Bit mask of DONE field.
	SAADC_INTENCLR_DONE_Msk = 0x4
	// Bit DONE.
	SAADC_INTENCLR_DONE = 0x4
	// Read: Disabled
	SAADC_INTENCLR_DONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_DONE_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_DONE_Clear = 0x1
	// Position of RESULTDONE field.
	SAADC_INTENCLR_RESULTDONE_Pos = 0x3
	// Bit mask of RESULTDONE field.
	SAADC_INTENCLR_RESULTDONE_Msk = 0x8
	// Bit RESULTDONE.
	SAADC_INTENCLR_RESULTDONE = 0x8
	// Read: Disabled
	SAADC_INTENCLR_RESULTDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_RESULTDONE_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_RESULTDONE_Clear = 0x1
	// Position of CALIBRATEDONE field.
	SAADC_INTENCLR_CALIBRATEDONE_Pos = 0x4
	// Bit mask of CALIBRATEDONE field.
	SAADC_INTENCLR_CALIBRATEDONE_Msk = 0x10
	// Bit CALIBRATEDONE.
	SAADC_INTENCLR_CALIBRATEDONE = 0x10
	// Read: Disabled
	SAADC_INTENCLR_CALIBRATEDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CALIBRATEDONE_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CALIBRATEDONE_Clear = 0x1
	// Position of STOPPED field.
	SAADC_INTENCLR_STOPPED_Pos = 0x5
	// Bit mask of STOPPED field.
	SAADC_INTENCLR_STOPPED_Msk = 0x20
	// Bit STOPPED.
	SAADC_INTENCLR_STOPPED = 0x20
	// Read: Disabled
	SAADC_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_STOPPED_Clear = 0x1
	// Position of CH0LIMITH field.
	SAADC_INTENCLR_CH0LIMITH_Pos = 0x6
	// Bit mask of CH0LIMITH field.
	SAADC_INTENCLR_CH0LIMITH_Msk = 0x40
	// Bit CH0LIMITH.
	SAADC_INTENCLR_CH0LIMITH = 0x40
	// Read: Disabled
	SAADC_INTENCLR_CH0LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH0LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH0LIMITH_Clear = 0x1
	// Position of CH0LIMITL field.
	SAADC_INTENCLR_CH0LIMITL_Pos = 0x7
	// Bit mask of CH0LIMITL field.
	SAADC_INTENCLR_CH0LIMITL_Msk = 0x80
	// Bit CH0LIMITL.
	SAADC_INTENCLR_CH0LIMITL = 0x80
	// Read: Disabled
	SAADC_INTENCLR_CH0LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH0LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH0LIMITL_Clear = 0x1
	// Position of CH1LIMITH field.
	SAADC_INTENCLR_CH1LIMITH_Pos = 0x8
	// Bit mask of CH1LIMITH field.
	SAADC_INTENCLR_CH1LIMITH_Msk = 0x100
	// Bit CH1LIMITH.
	SAADC_INTENCLR_CH1LIMITH = 0x100
	// Read: Disabled
	SAADC_INTENCLR_CH1LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH1LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH1LIMITH_Clear = 0x1
	// Position of CH1LIMITL field.
	SAADC_INTENCLR_CH1LIMITL_Pos = 0x9
	// Bit mask of CH1LIMITL field.
	SAADC_INTENCLR_CH1LIMITL_Msk = 0x200
	// Bit CH1LIMITL.
	SAADC_INTENCLR_CH1LIMITL = 0x200
	// Read: Disabled
	SAADC_INTENCLR_CH1LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH1LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH1LIMITL_Clear = 0x1
	// Position of CH2LIMITH field.
	SAADC_INTENCLR_CH2LIMITH_Pos = 0xa
	// Bit mask of CH2LIMITH field.
	SAADC_INTENCLR_CH2LIMITH_Msk = 0x400
	// Bit CH2LIMITH.
	SAADC_INTENCLR_CH2LIMITH = 0x400
	// Read: Disabled
	SAADC_INTENCLR_CH2LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH2LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH2LIMITH_Clear = 0x1
	// Position of CH2LIMITL field.
	SAADC_INTENCLR_CH2LIMITL_Pos = 0xb
	// Bit mask of CH2LIMITL field.
	SAADC_INTENCLR_CH2LIMITL_Msk = 0x800
	// Bit CH2LIMITL.
	SAADC_INTENCLR_CH2LIMITL = 0x800
	// Read: Disabled
	SAADC_INTENCLR_CH2LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH2LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH2LIMITL_Clear = 0x1
	// Position of CH3LIMITH field.
	SAADC_INTENCLR_CH3LIMITH_Pos = 0xc
	// Bit mask of CH3LIMITH field.
	SAADC_INTENCLR_CH3LIMITH_Msk = 0x1000
	// Bit CH3LIMITH.
	SAADC_INTENCLR_CH3LIMITH = 0x1000
	// Read: Disabled
	SAADC_INTENCLR_CH3LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH3LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH3LIMITH_Clear = 0x1
	// Position of CH3LIMITL field.
	SAADC_INTENCLR_CH3LIMITL_Pos = 0xd
	// Bit mask of CH3LIMITL field.
	SAADC_INTENCLR_CH3LIMITL_Msk = 0x2000
	// Bit CH3LIMITL.
	SAADC_INTENCLR_CH3LIMITL = 0x2000
	// Read: Disabled
	SAADC_INTENCLR_CH3LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH3LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH3LIMITL_Clear = 0x1
	// Position of CH4LIMITH field.
	SAADC_INTENCLR_CH4LIMITH_Pos = 0xe
	// Bit mask of CH4LIMITH field.
	SAADC_INTENCLR_CH4LIMITH_Msk = 0x4000
	// Bit CH4LIMITH.
	SAADC_INTENCLR_CH4LIMITH = 0x4000
	// Read: Disabled
	SAADC_INTENCLR_CH4LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH4LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH4LIMITH_Clear = 0x1
	// Position of CH4LIMITL field.
	SAADC_INTENCLR_CH4LIMITL_Pos = 0xf
	// Bit mask of CH4LIMITL field.
	SAADC_INTENCLR_CH4LIMITL_Msk = 0x8000
	// Bit CH4LIMITL.
	SAADC_INTENCLR_CH4LIMITL = 0x8000
	// Read: Disabled
	SAADC_INTENCLR_CH4LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH4LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH4LIMITL_Clear = 0x1
	// Position of CH5LIMITH field.
	SAADC_INTENCLR_CH5LIMITH_Pos = 0x10
	// Bit mask of CH5LIMITH field.
	SAADC_INTENCLR_CH5LIMITH_Msk = 0x10000
	// Bit CH5LIMITH.
	SAADC_INTENCLR_CH5LIMITH = 0x10000
	// Read: Disabled
	SAADC_INTENCLR_CH5LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH5LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH5LIMITH_Clear = 0x1
	// Position of CH5LIMITL field.
	SAADC_INTENCLR_CH5LIMITL_Pos = 0x11
	// Bit mask of CH5LIMITL field.
	SAADC_INTENCLR_CH5LIMITL_Msk = 0x20000
	// Bit CH5LIMITL.
	SAADC_INTENCLR_CH5LIMITL = 0x20000
	// Read: Disabled
	SAADC_INTENCLR_CH5LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH5LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH5LIMITL_Clear = 0x1
	// Position of CH6LIMITH field.
	SAADC_INTENCLR_CH6LIMITH_Pos = 0x12
	// Bit mask of CH6LIMITH field.
	SAADC_INTENCLR_CH6LIMITH_Msk = 0x40000
	// Bit CH6LIMITH.
	SAADC_INTENCLR_CH6LIMITH = 0x40000
	// Read: Disabled
	SAADC_INTENCLR_CH6LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH6LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH6LIMITH_Clear = 0x1
	// Position of CH6LIMITL field.
	SAADC_INTENCLR_CH6LIMITL_Pos = 0x13
	// Bit mask of CH6LIMITL field.
	SAADC_INTENCLR_CH6LIMITL_Msk = 0x80000
	// Bit CH6LIMITL.
	SAADC_INTENCLR_CH6LIMITL = 0x80000
	// Read: Disabled
	SAADC_INTENCLR_CH6LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH6LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH6LIMITL_Clear = 0x1
	// Position of CH7LIMITH field.
	SAADC_INTENCLR_CH7LIMITH_Pos = 0x14
	// Bit mask of CH7LIMITH field.
	SAADC_INTENCLR_CH7LIMITH_Msk = 0x100000
	// Bit CH7LIMITH.
	SAADC_INTENCLR_CH7LIMITH = 0x100000
	// Read: Disabled
	SAADC_INTENCLR_CH7LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH7LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH7LIMITH_Clear = 0x1
	// Position of CH7LIMITL field.
	SAADC_INTENCLR_CH7LIMITL_Pos = 0x15
	// Bit mask of CH7LIMITL field.
	SAADC_INTENCLR_CH7LIMITL_Msk = 0x200000
	// Bit CH7LIMITL.
	SAADC_INTENCLR_CH7LIMITL = 0x200000
	// Read: Disabled
	SAADC_INTENCLR_CH7LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH7LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH7LIMITL_Clear = 0x1

	// STATUS: Status
	// Position of STATUS field.
	SAADC_STATUS_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	SAADC_STATUS_STATUS_Msk = 0x1
	// Bit STATUS.
	SAADC_STATUS_STATUS = 0x1
	// ADC is ready. No on-going conversion.
	SAADC_STATUS_STATUS_Ready = 0x0
	// ADC is busy. Conversion in progress.
	SAADC_STATUS_STATUS_Busy = 0x1

	// ENABLE: Enable or disable ADC
	// Position of ENABLE field.
	SAADC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SAADC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SAADC_ENABLE_ENABLE = 0x1
	// Disable ADC
	SAADC_ENABLE_ENABLE_Disabled = 0x0
	// Enable ADC
	SAADC_ENABLE_ENABLE_Enabled = 0x1

	// CH.PSELP: Description cluster[0]: Input positive pin selection for CH[0]
	// Position of PSELP field.
	SAADC_CH_PSELP_PSELP_Pos = 0x0
	// Bit mask of PSELP field.
	SAADC_CH_PSELP_PSELP_Msk = 0x1f
	// Not connected
	SAADC_CH_PSELP_PSELP_NC = 0x0
	// AIN0
	SAADC_CH_PSELP_PSELP_AnalogInput0 = 0x1
	// AIN1
	SAADC_CH_PSELP_PSELP_AnalogInput1 = 0x2
	// AIN2
	SAADC_CH_PSELP_PSELP_AnalogInput2 = 0x3
	// AIN3
	SAADC_CH_PSELP_PSELP_AnalogInput3 = 0x4
	// AIN4
	SAADC_CH_PSELP_PSELP_AnalogInput4 = 0x5
	// AIN5
	SAADC_CH_PSELP_PSELP_AnalogInput5 = 0x6
	// AIN6
	SAADC_CH_PSELP_PSELP_AnalogInput6 = 0x7
	// AIN7
	SAADC_CH_PSELP_PSELP_AnalogInput7 = 0x8
	// VDD
	SAADC_CH_PSELP_PSELP_VDD = 0x9

	// CH.PSELN: Description cluster[0]: Input negative pin selection for CH[0]
	// Position of PSELN field.
	SAADC_CH_PSELN_PSELN_Pos = 0x0
	// Bit mask of PSELN field.
	SAADC_CH_PSELN_PSELN_Msk = 0x1f
	// Not connected
	SAADC_CH_PSELN_PSELN_NC = 0x0
	// AIN0
	SAADC_CH_PSELN_PSELN_AnalogInput0 = 0x1
	// AIN1
	SAADC_CH_PSELN_PSELN_AnalogInput1 = 0x2
	// AIN2
	SAADC_CH_PSELN_PSELN_AnalogInput2 = 0x3
	// AIN3
	SAADC_CH_PSELN_PSELN_AnalogInput3 = 0x4
	// AIN4
	SAADC_CH_PSELN_PSELN_AnalogInput4 = 0x5
	// AIN5
	SAADC_CH_PSELN_PSELN_AnalogInput5 = 0x6
	// AIN6
	SAADC_CH_PSELN_PSELN_AnalogInput6 = 0x7
	// AIN7
	SAADC_CH_PSELN_PSELN_AnalogInput7 = 0x8
	// VDD
	SAADC_CH_PSELN_PSELN_VDD = 0x9

	// CH.CONFIG: Description cluster[0]: Input configuration for CH[0]
	// Position of RESP field.
	SAADC_CH_CONFIG_RESP_Pos = 0x0
	// Bit mask of RESP field.
	SAADC_CH_CONFIG_RESP_Msk = 0x3
	// Bypass resistor ladder
	SAADC_CH_CONFIG_RESP_Bypass = 0x0
	// Pull-down to GND
	SAADC_CH_CONFIG_RESP_Pulldown = 0x1
	// Pull-up to VDD
	SAADC_CH_CONFIG_RESP_Pullup = 0x2
	// Set input at VDD/2
	SAADC_CH_CONFIG_RESP_VDD1_2 = 0x3
	// Position of RESN field.
	SAADC_CH_CONFIG_RESN_Pos = 0x4
	// Bit mask of RESN field.
	SAADC_CH_CONFIG_RESN_Msk = 0x30
	// Bypass resistor ladder
	SAADC_CH_CONFIG_RESN_Bypass = 0x0
	// Pull-down to GND
	SAADC_CH_CONFIG_RESN_Pulldown = 0x1
	// Pull-up to VDD
	SAADC_CH_CONFIG_RESN_Pullup = 0x2
	// Set input at VDD/2
	SAADC_CH_CONFIG_RESN_VDD1_2 = 0x3
	// Position of GAIN field.
	SAADC_CH_CONFIG_GAIN_Pos = 0x8
	// Bit mask of GAIN field.
	SAADC_CH_CONFIG_GAIN_Msk = 0x700
	// 1/6
	SAADC_CH_CONFIG_GAIN_Gain1_6 = 0x0
	// 1/5
	SAADC_CH_CONFIG_GAIN_Gain1_5 = 0x1
	// 1/4
	SAADC_CH_CONFIG_GAIN_Gain1_4 = 0x2
	// 1/3
	SAADC_CH_CONFIG_GAIN_Gain1_3 = 0x3
	// 1/2
	SAADC_CH_CONFIG_GAIN_Gain1_2 = 0x4
	// 1
	SAADC_CH_CONFIG_GAIN_Gain1 = 0x5
	// 2
	SAADC_CH_CONFIG_GAIN_Gain2 = 0x6
	// 4
	SAADC_CH_CONFIG_GAIN_Gain4 = 0x7
	// Position of REFSEL field.
	SAADC_CH_CONFIG_REFSEL_Pos = 0xc
	// Bit mask of REFSEL field.
	SAADC_CH_CONFIG_REFSEL_Msk = 0x1000
	// Bit REFSEL.
	SAADC_CH_CONFIG_REFSEL = 0x1000
	// Internal reference (0.6 V)
	SAADC_CH_CONFIG_REFSEL_Internal = 0x0
	// VDD/4 as reference
	SAADC_CH_CONFIG_REFSEL_VDD1_4 = 0x1
	// Position of TACQ field.
	SAADC_CH_CONFIG_TACQ_Pos = 0x10
	// Bit mask of TACQ field.
	SAADC_CH_CONFIG_TACQ_Msk = 0x70000
	// 3 us
	SAADC_CH_CONFIG_TACQ_3us = 0x0
	// 5 us
	SAADC_CH_CONFIG_TACQ_5us = 0x1
	// 10 us
	SAADC_CH_CONFIG_TACQ_10us = 0x2
	// 15 us
	SAADC_CH_CONFIG_TACQ_15us = 0x3
	// 20 us
	SAADC_CH_CONFIG_TACQ_20us = 0x4
	// 40 us
	SAADC_CH_CONFIG_TACQ_40us = 0x5
	// Position of MODE field.
	SAADC_CH_CONFIG_MODE_Pos = 0x14
	// Bit mask of MODE field.
	SAADC_CH_CONFIG_MODE_Msk = 0x100000
	// Bit MODE.
	SAADC_CH_CONFIG_MODE = 0x100000
	// Single ended, PSELN will be ignored, negative input to ADC shorted to GND
	SAADC_CH_CONFIG_MODE_SE = 0x0
	// Differential
	SAADC_CH_CONFIG_MODE_Diff = 0x1
	// Position of BURST field.
	SAADC_CH_CONFIG_BURST_Pos = 0x18
	// Bit mask of BURST field.
	SAADC_CH_CONFIG_BURST_Msk = 0x1000000
	// Bit BURST.
	SAADC_CH_CONFIG_BURST = 0x1000000
	// Burst mode is disabled (normal operation)
	SAADC_CH_CONFIG_BURST_Disabled = 0x0
	// Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM.
	SAADC_CH_CONFIG_BURST_Enabled = 0x1

	// CH.LIMIT: Description cluster[0]: High/low limits for event monitoring a channel
	// Position of LOW field.
	SAADC_CH_LIMIT_LOW_Pos = 0x0
	// Bit mask of LOW field.
	SAADC_CH_LIMIT_LOW_Msk = 0xffff
	// Position of HIGH field.
	SAADC_CH_LIMIT_HIGH_Pos = 0x10
	// Bit mask of HIGH field.
	SAADC_CH_LIMIT_HIGH_Msk = 0xffff0000

	// RESOLUTION: Resolution configuration
	// Position of VAL field.
	SAADC_RESOLUTION_VAL_Pos = 0x0
	// Bit mask of VAL field.
	SAADC_RESOLUTION_VAL_Msk = 0x7
	// 8 bit
	SAADC_RESOLUTION_VAL_8bit = 0x0
	// 10 bit
	SAADC_RESOLUTION_VAL_10bit = 0x1
	// 12 bit
	SAADC_RESOLUTION_VAL_12bit = 0x2
	// 14 bit
	SAADC_RESOLUTION_VAL_14bit = 0x3

	// OVERSAMPLE: Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
	// Position of OVERSAMPLE field.
	SAADC_OVERSAMPLE_OVERSAMPLE_Pos = 0x0
	// Bit mask of OVERSAMPLE field.
	SAADC_OVERSAMPLE_OVERSAMPLE_Msk = 0xf
	// Bypass oversampling
	SAADC_OVERSAMPLE_OVERSAMPLE_Bypass = 0x0
	// Oversample 2x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over2x = 0x1
	// Oversample 4x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over4x = 0x2
	// Oversample 8x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over8x = 0x3
	// Oversample 16x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over16x = 0x4
	// Oversample 32x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over32x = 0x5
	// Oversample 64x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over64x = 0x6
	// Oversample 128x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over128x = 0x7
	// Oversample 256x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over256x = 0x8

	// SAMPLERATE: Controls normal or continuous sample rate
	// Position of CC field.
	SAADC_SAMPLERATE_CC_Pos = 0x0
	// Bit mask of CC field.
	SAADC_SAMPLERATE_CC_Msk = 0x7ff
	// Position of MODE field.
	SAADC_SAMPLERATE_MODE_Pos = 0xc
	// Bit mask of MODE field.
	SAADC_SAMPLERATE_MODE_Msk = 0x1000
	// Bit MODE.
	SAADC_SAMPLERATE_MODE = 0x1000
	// Rate is controlled from SAMPLE task
	SAADC_SAMPLERATE_MODE_Task = 0x0
	// Rate is controlled from local timer (use CC to control the rate)
	SAADC_SAMPLERATE_MODE_Timers = 0x1

	// RESULT.PTR: Data pointer
	// Position of PTR field.
	SAADC_RESULT_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SAADC_RESULT_PTR_PTR_Msk = 0xffffffff

	// RESULT.MAXCNT: Maximum number of buffer words to transfer
	// Position of MAXCNT field.
	SAADC_RESULT_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SAADC_RESULT_MAXCNT_MAXCNT_Msk = 0x7fff

	// RESULT.AMOUNT: Number of buffer words transferred since last START
	// Position of AMOUNT field.
	SAADC_RESULT_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SAADC_RESULT_AMOUNT_AMOUNT_Msk = 0x7fff
)

// Constants for TIMER0: Timer/Counter 0
const (
	// SHORTS: Shortcut register
	// Position of COMPARE0_CLEAR field.
	TIMER_SHORTS_COMPARE0_CLEAR_Pos = 0x0
	// Bit mask of COMPARE0_CLEAR field.
	TIMER_SHORTS_COMPARE0_CLEAR_Msk = 0x1
	// Bit COMPARE0_CLEAR.
	TIMER_SHORTS_COMPARE0_CLEAR = 0x1
	// Disable shortcut
	TIMER_SHORTS_COMPARE0_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE0_CLEAR_Enabled = 0x1
	// Position of COMPARE1_CLEAR field.
	TIMER_SHORTS_COMPARE1_CLEAR_Pos = 0x1
	// Bit mask of COMPARE1_CLEAR field.
	TIMER_SHORTS_COMPARE1_CLEAR_Msk = 0x2
	// Bit COMPARE1_CLEAR.
	TIMER_SHORTS_COMPARE1_CLEAR = 0x2
	// Disable shortcut
	TIMER_SHORTS_COMPARE1_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE1_CLEAR_Enabled = 0x1
	// Position of COMPARE2_CLEAR field.
	TIMER_SHORTS_COMPARE2_CLEAR_Pos = 0x2
	// Bit mask of COMPARE2_CLEAR field.
	TIMER_SHORTS_COMPARE2_CLEAR_Msk = 0x4
	// Bit COMPARE2_CLEAR.
	TIMER_SHORTS_COMPARE2_CLEAR = 0x4
	// Disable shortcut
	TIMER_SHORTS_COMPARE2_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE2_CLEAR_Enabled = 0x1
	// Position of COMPARE3_CLEAR field.
	TIMER_SHORTS_COMPARE3_CLEAR_Pos = 0x3
	// Bit mask of COMPARE3_CLEAR field.
	TIMER_SHORTS_COMPARE3_CLEAR_Msk = 0x8
	// Bit COMPARE3_CLEAR.
	TIMER_SHORTS_COMPARE3_CLEAR = 0x8
	// Disable shortcut
	TIMER_SHORTS_COMPARE3_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE3_CLEAR_Enabled = 0x1
	// Position of COMPARE4_CLEAR field.
	TIMER_SHORTS_COMPARE4_CLEAR_Pos = 0x4
	// Bit mask of COMPARE4_CLEAR field.
	TIMER_SHORTS_COMPARE4_CLEAR_Msk = 0x10
	// Bit COMPARE4_CLEAR.
	TIMER_SHORTS_COMPARE4_CLEAR = 0x10
	// Disable shortcut
	TIMER_SHORTS_COMPARE4_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE4_CLEAR_Enabled = 0x1
	// Position of COMPARE5_CLEAR field.
	TIMER_SHORTS_COMPARE5_CLEAR_Pos = 0x5
	// Bit mask of COMPARE5_CLEAR field.
	TIMER_SHORTS_COMPARE5_CLEAR_Msk = 0x20
	// Bit COMPARE5_CLEAR.
	TIMER_SHORTS_COMPARE5_CLEAR = 0x20
	// Disable shortcut
	TIMER_SHORTS_COMPARE5_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE5_CLEAR_Enabled = 0x1
	// Position of COMPARE0_STOP field.
	TIMER_SHORTS_COMPARE0_STOP_Pos = 0x8
	// Bit mask of COMPARE0_STOP field.
	TIMER_SHORTS_COMPARE0_STOP_Msk = 0x100
	// Bit COMPARE0_STOP.
	TIMER_SHORTS_COMPARE0_STOP = 0x100
	// Disable shortcut
	TIMER_SHORTS_COMPARE0_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE0_STOP_Enabled = 0x1
	// Position of COMPARE1_STOP field.
	TIMER_SHORTS_COMPARE1_STOP_Pos = 0x9
	// Bit mask of COMPARE1_STOP field.
	TIMER_SHORTS_COMPARE1_STOP_Msk = 0x200
	// Bit COMPARE1_STOP.
	TIMER_SHORTS_COMPARE1_STOP = 0x200
	// Disable shortcut
	TIMER_SHORTS_COMPARE1_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE1_STOP_Enabled = 0x1
	// Position of COMPARE2_STOP field.
	TIMER_SHORTS_COMPARE2_STOP_Pos = 0xa
	// Bit mask of COMPARE2_STOP field.
	TIMER_SHORTS_COMPARE2_STOP_Msk = 0x400
	// Bit COMPARE2_STOP.
	TIMER_SHORTS_COMPARE2_STOP = 0x400
	// Disable shortcut
	TIMER_SHORTS_COMPARE2_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE2_STOP_Enabled = 0x1
	// Position of COMPARE3_STOP field.
	TIMER_SHORTS_COMPARE3_STOP_Pos = 0xb
	// Bit mask of COMPARE3_STOP field.
	TIMER_SHORTS_COMPARE3_STOP_Msk = 0x800
	// Bit COMPARE3_STOP.
	TIMER_SHORTS_COMPARE3_STOP = 0x800
	// Disable shortcut
	TIMER_SHORTS_COMPARE3_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE3_STOP_Enabled = 0x1
	// Position of COMPARE4_STOP field.
	TIMER_SHORTS_COMPARE4_STOP_Pos = 0xc
	// Bit mask of COMPARE4_STOP field.
	TIMER_SHORTS_COMPARE4_STOP_Msk = 0x1000
	// Bit COMPARE4_STOP.
	TIMER_SHORTS_COMPARE4_STOP = 0x1000
	// Disable shortcut
	TIMER_SHORTS_COMPARE4_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE4_STOP_Enabled = 0x1
	// Position of COMPARE5_STOP field.
	TIMER_SHORTS_COMPARE5_STOP_Pos = 0xd
	// Bit mask of COMPARE5_STOP field.
	TIMER_SHORTS_COMPARE5_STOP_Msk = 0x2000
	// Bit COMPARE5_STOP.
	TIMER_SHORTS_COMPARE5_STOP = 0x2000
	// Disable shortcut
	TIMER_SHORTS_COMPARE5_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE5_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of COMPARE0 field.
	TIMER_INTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	TIMER_INTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE0_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	TIMER_INTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	TIMER_INTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE1_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	TIMER_INTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	TIMER_INTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE2_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	TIMER_INTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	TIMER_INTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE3_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE3_Set = 0x1
	// Position of COMPARE4 field.
	TIMER_INTENSET_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTENSET_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTENSET_COMPARE4 = 0x100000
	// Read: Disabled
	TIMER_INTENSET_COMPARE4_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE4_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE4_Set = 0x1
	// Position of COMPARE5 field.
	TIMER_INTENSET_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTENSET_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTENSET_COMPARE5 = 0x200000
	// Read: Disabled
	TIMER_INTENSET_COMPARE5_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE5_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE5_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of COMPARE0 field.
	TIMER_INTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	TIMER_INTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	TIMER_INTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	TIMER_INTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE3_Clear = 0x1
	// Position of COMPARE4 field.
	TIMER_INTENCLR_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTENCLR_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTENCLR_COMPARE4 = 0x100000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE4_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE4_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE4_Clear = 0x1
	// Position of COMPARE5 field.
	TIMER_INTENCLR_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTENCLR_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTENCLR_COMPARE5 = 0x200000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE5_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE5_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE5_Clear = 0x1

	// MODE: Timer mode selection
	// Position of MODE field.
	TIMER_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	TIMER_MODE_MODE_Msk = 0x3
	// Select Timer mode
	TIMER_MODE_MODE_Timer = 0x0
	// Deprecated enumerator - Select Counter mode
	TIMER_MODE_MODE_Counter = 0x1
	// Select Low Power Counter mode
	TIMER_MODE_MODE_LowPowerCounter = 0x2

	// BITMODE: Configure the number of bits used by the TIMER
	// Position of BITMODE field.
	TIMER_BITMODE_BITMODE_Pos = 0x0
	// Bit mask of BITMODE field.
	TIMER_BITMODE_BITMODE_Msk = 0x3
	// 16 bit timer bit width
	TIMER_BITMODE_BITMODE_16Bit = 0x0
	// 8 bit timer bit width
	TIMER_BITMODE_BITMODE_08Bit = 0x1
	// 24 bit timer bit width
	TIMER_BITMODE_BITMODE_24Bit = 0x2
	// 32 bit timer bit width
	TIMER_BITMODE_BITMODE_32Bit = 0x3

	// PRESCALER: Timer prescaler register
	// Position of PRESCALER field.
	TIMER_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	TIMER_PRESCALER_PRESCALER_Msk = 0xf

	// CC: Description collection[0]: Capture/Compare register 0
	// Position of CC field.
	TIMER_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TIMER_CC_CC_Msk = 0xffffffff
)

// Constants for RTC0: Real time counter 0
const (
	// INTENSET: Enable interrupt
	// Position of TICK field.
	RTC_INTENSET_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_INTENSET_TICK_Msk = 0x1
	// Bit TICK.
	RTC_INTENSET_TICK = 0x1
	// Read: Disabled
	RTC_INTENSET_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_TICK_Enabled = 0x1
	// Enable
	RTC_INTENSET_TICK_Set = 0x1
	// Position of OVRFLW field.
	RTC_INTENSET_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_INTENSET_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_INTENSET_OVRFLW = 0x2
	// Read: Disabled
	RTC_INTENSET_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_OVRFLW_Enabled = 0x1
	// Enable
	RTC_INTENSET_OVRFLW_Set = 0x1
	// Position of COMPARE0 field.
	RTC_INTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_INTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_INTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_INTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE0_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	RTC_INTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_INTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_INTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_INTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE1_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	RTC_INTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_INTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_INTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_INTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE2_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	RTC_INTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_INTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_INTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_INTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE3_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE3_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TICK field.
	RTC_INTENCLR_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_INTENCLR_TICK_Msk = 0x1
	// Bit TICK.
	RTC_INTENCLR_TICK = 0x1
	// Read: Disabled
	RTC_INTENCLR_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_TICK_Enabled = 0x1
	// Disable
	RTC_INTENCLR_TICK_Clear = 0x1
	// Position of OVRFLW field.
	RTC_INTENCLR_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_INTENCLR_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_INTENCLR_OVRFLW = 0x2
	// Read: Disabled
	RTC_INTENCLR_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_OVRFLW_Enabled = 0x1
	// Disable
	RTC_INTENCLR_OVRFLW_Clear = 0x1
	// Position of COMPARE0 field.
	RTC_INTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_INTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_INTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_INTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	RTC_INTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_INTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_INTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_INTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	RTC_INTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_INTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_INTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_INTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	RTC_INTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_INTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_INTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_INTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE3_Clear = 0x1

	// EVTEN: Enable or disable event routing
	// Position of TICK field.
	RTC_EVTEN_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTEN_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTEN_TICK = 0x1
	// Disable
	RTC_EVTEN_TICK_Disabled = 0x0
	// Enable
	RTC_EVTEN_TICK_Enabled = 0x1
	// Position of OVRFLW field.
	RTC_EVTEN_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTEN_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTEN_OVRFLW = 0x2
	// Disable
	RTC_EVTEN_OVRFLW_Disabled = 0x0
	// Enable
	RTC_EVTEN_OVRFLW_Enabled = 0x1
	// Position of COMPARE0 field.
	RTC_EVTEN_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTEN_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTEN_COMPARE0 = 0x10000
	// Disable
	RTC_EVTEN_COMPARE0_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE0_Enabled = 0x1
	// Position of COMPARE1 field.
	RTC_EVTEN_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTEN_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTEN_COMPARE1 = 0x20000
	// Disable
	RTC_EVTEN_COMPARE1_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE1_Enabled = 0x1
	// Position of COMPARE2 field.
	RTC_EVTEN_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTEN_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTEN_COMPARE2 = 0x40000
	// Disable
	RTC_EVTEN_COMPARE2_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE2_Enabled = 0x1
	// Position of COMPARE3 field.
	RTC_EVTEN_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTEN_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTEN_COMPARE3 = 0x80000
	// Disable
	RTC_EVTEN_COMPARE3_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE3_Enabled = 0x1

	// EVTENSET: Enable event routing
	// Position of TICK field.
	RTC_EVTENSET_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTENSET_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTENSET_TICK = 0x1
	// Read: Disabled
	RTC_EVTENSET_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_TICK_Enabled = 0x1
	// Enable
	RTC_EVTENSET_TICK_Set = 0x1
	// Position of OVRFLW field.
	RTC_EVTENSET_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTENSET_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTENSET_OVRFLW = 0x2
	// Read: Disabled
	RTC_EVTENSET_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_OVRFLW_Enabled = 0x1
	// Enable
	RTC_EVTENSET_OVRFLW_Set = 0x1
	// Position of COMPARE0 field.
	RTC_EVTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_EVTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE0_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	RTC_EVTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_EVTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE1_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	RTC_EVTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_EVTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE2_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	RTC_EVTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_EVTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE3_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE3_Set = 0x1

	// EVTENCLR: Disable event routing
	// Position of TICK field.
	RTC_EVTENCLR_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTENCLR_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTENCLR_TICK = 0x1
	// Read: Disabled
	RTC_EVTENCLR_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_TICK_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_TICK_Clear = 0x1
	// Position of OVRFLW field.
	RTC_EVTENCLR_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTENCLR_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTENCLR_OVRFLW = 0x2
	// Read: Disabled
	RTC_EVTENCLR_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_OVRFLW_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_OVRFLW_Clear = 0x1
	// Position of COMPARE0 field.
	RTC_EVTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	RTC_EVTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	RTC_EVTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	RTC_EVTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE3_Clear = 0x1

	// COUNTER: Current COUNTER value
	// Position of COUNTER field.
	RTC_COUNTER_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	RTC_COUNTER_COUNTER_Msk = 0xffffff

	// PRESCALER: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
	// Position of PRESCALER field.
	RTC_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	RTC_PRESCALER_PRESCALER_Msk = 0xfff

	// CC: Description collection[0]: Compare register 0
	// Position of COMPARE field.
	RTC_CC_COMPARE_Pos = 0x0
	// Bit mask of COMPARE field.
	RTC_CC_COMPARE_Msk = 0xffffff
)

// Constants for TEMP: Temperature Sensor
const (
	// INTENSET: Enable interrupt
	// Position of DATARDY field.
	TEMP_INTENSET_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TEMP_INTENSET_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TEMP_INTENSET_DATARDY = 0x1
	// Read: Disabled
	TEMP_INTENSET_DATARDY_Disabled = 0x0
	// Read: Enabled
	TEMP_INTENSET_DATARDY_Enabled = 0x1
	// Enable
	TEMP_INTENSET_DATARDY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of DATARDY field.
	TEMP_INTENCLR_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TEMP_INTENCLR_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TEMP_INTENCLR_DATARDY = 0x1
	// Read: Disabled
	TEMP_INTENCLR_DATARDY_Disabled = 0x0
	// Read: Enabled
	TEMP_INTENCLR_DATARDY_Enabled = 0x1
	// Disable
	TEMP_INTENCLR_DATARDY_Clear = 0x1

	// TEMP: Temperature in degC (0.25deg steps)
	// Position of TEMP field.
	TEMP_TEMP_TEMP_Pos = 0x0
	// Bit mask of TEMP field.
	TEMP_TEMP_TEMP_Msk = 0xffffffff

	// A0: Slope of 1st piece wise linear function
	// Position of A0 field.
	TEMP_A0_A0_Pos = 0x0
	// Bit mask of A0 field.
	TEMP_A0_A0_Msk = 0xfff

	// A1: Slope of 2nd piece wise linear function
	// Position of A1 field.
	TEMP_A1_A1_Pos = 0x0
	// Bit mask of A1 field.
	TEMP_A1_A1_Msk = 0xfff

	// A2: Slope of 3rd piece wise linear function
	// Position of A2 field.
	TEMP_A2_A2_Pos = 0x0
	// Bit mask of A2 field.
	TEMP_A2_A2_Msk = 0xfff

	// A3: Slope of 4th piece wise linear function
	// Position of A3 field.
	TEMP_A3_A3_Pos = 0x0
	// Bit mask of A3 field.
	TEMP_A3_A3_Msk = 0xfff

	// A4: Slope of 5th piece wise linear function
	// Position of A4 field.
	TEMP_A4_A4_Pos = 0x0
	// Bit mask of A4 field.
	TEMP_A4_A4_Msk = 0xfff

	// A5: Slope of 6th piece wise linear function
	// Position of A5 field.
	TEMP_A5_A5_Pos = 0x0
	// Bit mask of A5 field.
	TEMP_A5_A5_Msk = 0xfff

	// B0: y-intercept of 1st piece wise linear function
	// Position of B0 field.
	TEMP_B0_B0_Pos = 0x0
	// Bit mask of B0 field.
	TEMP_B0_B0_Msk = 0x3fff

	// B1: y-intercept of 2nd piece wise linear function
	// Position of B1 field.
	TEMP_B1_B1_Pos = 0x0
	// Bit mask of B1 field.
	TEMP_B1_B1_Msk = 0x3fff

	// B2: y-intercept of 3rd piece wise linear function
	// Position of B2 field.
	TEMP_B2_B2_Pos = 0x0
	// Bit mask of B2 field.
	TEMP_B2_B2_Msk = 0x3fff

	// B3: y-intercept of 4th piece wise linear function
	// Position of B3 field.
	TEMP_B3_B3_Pos = 0x0
	// Bit mask of B3 field.
	TEMP_B3_B3_Msk = 0x3fff

	// B4: y-intercept of 5th piece wise linear function
	// Position of B4 field.
	TEMP_B4_B4_Pos = 0x0
	// Bit mask of B4 field.
	TEMP_B4_B4_Msk = 0x3fff

	// B5: y-intercept of 6th piece wise linear function
	// Position of B5 field.
	TEMP_B5_B5_Pos = 0x0
	// Bit mask of B5 field.
	TEMP_B5_B5_Msk = 0x3fff

	// T0: End point of 1st piece wise linear function
	// Position of T0 field.
	TEMP_T0_T0_Pos = 0x0
	// Bit mask of T0 field.
	TEMP_T0_T0_Msk = 0xff

	// T1: End point of 2nd piece wise linear function
	// Position of T1 field.
	TEMP_T1_T1_Pos = 0x0
	// Bit mask of T1 field.
	TEMP_T1_T1_Msk = 0xff

	// T2: End point of 3rd piece wise linear function
	// Position of T2 field.
	TEMP_T2_T2_Pos = 0x0
	// Bit mask of T2 field.
	TEMP_T2_T2_Msk = 0xff

	// T3: End point of 4th piece wise linear function
	// Position of T3 field.
	TEMP_T3_T3_Pos = 0x0
	// Bit mask of T3 field.
	TEMP_T3_T3_Msk = 0xff

	// T4: End point of 5th piece wise linear function
	// Position of T4 field.
	TEMP_T4_T4_Pos = 0x0
	// Bit mask of T4 field.
	TEMP_T4_T4_Msk = 0xff
)

// Constants for RNG: Random Number Generator
const (
	// SHORTS: Shortcut register
	// Position of VALRDY_STOP field.
	RNG_SHORTS_VALRDY_STOP_Pos = 0x0
	// Bit mask of VALRDY_STOP field.
	RNG_SHORTS_VALRDY_STOP_Msk = 0x1
	// Bit VALRDY_STOP.
	RNG_SHORTS_VALRDY_STOP = 0x1
	// Disable shortcut
	RNG_SHORTS_VALRDY_STOP_Disabled = 0x0
	// Enable shortcut
	RNG_SHORTS_VALRDY_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of VALRDY field.
	RNG_INTENSET_VALRDY_Pos = 0x0
	// Bit mask of VALRDY field.
	RNG_INTENSET_VALRDY_Msk = 0x1
	// Bit VALRDY.
	RNG_INTENSET_VALRDY = 0x1
	// Read: Disabled
	RNG_INTENSET_VALRDY_Disabled = 0x0
	// Read: Enabled
	RNG_INTENSET_VALRDY_Enabled = 0x1
	// Enable
	RNG_INTENSET_VALRDY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of VALRDY field.
	RNG_INTENCLR_VALRDY_Pos = 0x0
	// Bit mask of VALRDY field.
	RNG_INTENCLR_VALRDY_Msk = 0x1
	// Bit VALRDY.
	RNG_INTENCLR_VALRDY = 0x1
	// Read: Disabled
	RNG_INTENCLR_VALRDY_Disabled = 0x0
	// Read: Enabled
	RNG_INTENCLR_VALRDY_Enabled = 0x1
	// Disable
	RNG_INTENCLR_VALRDY_Clear = 0x1

	// CONFIG: Configuration register
	// Position of DERCEN field.
	RNG_CONFIG_DERCEN_Pos = 0x0
	// Bit mask of DERCEN field.
	RNG_CONFIG_DERCEN_Msk = 0x1
	// Bit DERCEN.
	RNG_CONFIG_DERCEN = 0x1
	// Disabled
	RNG_CONFIG_DERCEN_Disabled = 0x0
	// Enabled
	RNG_CONFIG_DERCEN_Enabled = 0x1

	// VALUE: Output random number
	// Position of VALUE field.
	RNG_VALUE_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	RNG_VALUE_VALUE_Msk = 0xff
)

// Constants for ECB: AES ECB Mode Encryption
const (
	// INTENSET: Enable interrupt
	// Position of ENDECB field.
	ECB_INTENSET_ENDECB_Pos = 0x0
	// Bit mask of ENDECB field.
	ECB_INTENSET_ENDECB_Msk = 0x1
	// Bit ENDECB.
	ECB_INTENSET_ENDECB = 0x1
	// Read: Disabled
	ECB_INTENSET_ENDECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENSET_ENDECB_Enabled = 0x1
	// Enable
	ECB_INTENSET_ENDECB_Set = 0x1
	// Position of ERRORECB field.
	ECB_INTENSET_ERRORECB_Pos = 0x1
	// Bit mask of ERRORECB field.
	ECB_INTENSET_ERRORECB_Msk = 0x2
	// Bit ERRORECB.
	ECB_INTENSET_ERRORECB = 0x2
	// Read: Disabled
	ECB_INTENSET_ERRORECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENSET_ERRORECB_Enabled = 0x1
	// Enable
	ECB_INTENSET_ERRORECB_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of ENDECB field.
	ECB_INTENCLR_ENDECB_Pos = 0x0
	// Bit mask of ENDECB field.
	ECB_INTENCLR_ENDECB_Msk = 0x1
	// Bit ENDECB.
	ECB_INTENCLR_ENDECB = 0x1
	// Read: Disabled
	ECB_INTENCLR_ENDECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENCLR_ENDECB_Enabled = 0x1
	// Disable
	ECB_INTENCLR_ENDECB_Clear = 0x1
	// Position of ERRORECB field.
	ECB_INTENCLR_ERRORECB_Pos = 0x1
	// Bit mask of ERRORECB field.
	ECB_INTENCLR_ERRORECB_Msk = 0x2
	// Bit ERRORECB.
	ECB_INTENCLR_ERRORECB = 0x2
	// Read: Disabled
	ECB_INTENCLR_ERRORECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENCLR_ERRORECB_Enabled = 0x1
	// Disable
	ECB_INTENCLR_ERRORECB_Clear = 0x1

	// ECBDATAPTR: ECB block encrypt memory pointers
	// Position of ECBDATAPTR field.
	ECB_ECBDATAPTR_ECBDATAPTR_Pos = 0x0
	// Bit mask of ECBDATAPTR field.
	ECB_ECBDATAPTR_ECBDATAPTR_Msk = 0xffffffff
)

// Constants for CCM: AES CCM Mode Encryption
const (
	// SHORTS: Shortcut register
	// Position of ENDKSGEN_CRYPT field.
	CCM_SHORTS_ENDKSGEN_CRYPT_Pos = 0x0
	// Bit mask of ENDKSGEN_CRYPT field.
	CCM_SHORTS_ENDKSGEN_CRYPT_Msk = 0x1
	// Bit ENDKSGEN_CRYPT.
	CCM_SHORTS_ENDKSGEN_CRYPT = 0x1
	// Disable shortcut
	CCM_SHORTS_ENDKSGEN_CRYPT_Disabled = 0x0
	// Enable shortcut
	CCM_SHORTS_ENDKSGEN_CRYPT_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of ENDKSGEN field.
	CCM_INTENSET_ENDKSGEN_Pos = 0x0
	// Bit mask of ENDKSGEN field.
	CCM_INTENSET_ENDKSGEN_Msk = 0x1
	// Bit ENDKSGEN.
	CCM_INTENSET_ENDKSGEN = 0x1
	// Read: Disabled
	CCM_INTENSET_ENDKSGEN_Disabled = 0x0
	// Read: Enabled
	CCM_INTENSET_ENDKSGEN_Enabled = 0x1
	// Enable
	CCM_INTENSET_ENDKSGEN_Set = 0x1
	// Position of ENDCRYPT field.
	CCM_INTENSET_ENDCRYPT_Pos = 0x1
	// Bit mask of ENDCRYPT field.
	CCM_INTENSET_ENDCRYPT_Msk = 0x2
	// Bit ENDCRYPT.
	CCM_INTENSET_ENDCRYPT = 0x2
	// Read: Disabled
	CCM_INTENSET_ENDCRYPT_Disabled = 0x0
	// Read: Enabled
	CCM_INTENSET_ENDCRYPT_Enabled = 0x1
	// Enable
	CCM_INTENSET_ENDCRYPT_Set = 0x1
	// Position of ERROR field.
	CCM_INTENSET_ERROR_Pos = 0x2
	// Bit mask of ERROR field.
	CCM_INTENSET_ERROR_Msk = 0x4
	// Bit ERROR.
	CCM_INTENSET_ERROR = 0x4
	// Read: Disabled
	CCM_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	CCM_INTENSET_ERROR_Enabled = 0x1
	// Enable
	CCM_INTENSET_ERROR_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of ENDKSGEN field.
	CCM_INTENCLR_ENDKSGEN_Pos = 0x0
	// Bit mask of ENDKSGEN field.
	CCM_INTENCLR_ENDKSGEN_Msk = 0x1
	// Bit ENDKSGEN.
	CCM_INTENCLR_ENDKSGEN = 0x1
	// Read: Disabled
	CCM_INTENCLR_ENDKSGEN_Disabled = 0x0
	// Read: Enabled
	CCM_INTENCLR_ENDKSGEN_Enabled = 0x1
	// Disable
	CCM_INTENCLR_ENDKSGEN_Clear = 0x1
	// Position of ENDCRYPT field.
	CCM_INTENCLR_ENDCRYPT_Pos = 0x1
	// Bit mask of ENDCRYPT field.
	CCM_INTENCLR_ENDCRYPT_Msk = 0x2
	// Bit ENDCRYPT.
	CCM_INTENCLR_ENDCRYPT = 0x2
	// Read: Disabled
	CCM_INTENCLR_ENDCRYPT_Disabled = 0x0
	// Read: Enabled
	CCM_INTENCLR_ENDCRYPT_Enabled = 0x1
	// Disable
	CCM_INTENCLR_ENDCRYPT_Clear = 0x1
	// Position of ERROR field.
	CCM_INTENCLR_ERROR_Pos = 0x2
	// Bit mask of ERROR field.
	CCM_INTENCLR_ERROR_Msk = 0x4
	// Bit ERROR.
	CCM_INTENCLR_ERROR = 0x4
	// Read: Disabled
	CCM_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	CCM_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	CCM_INTENCLR_ERROR_Clear = 0x1

	// MICSTATUS: MIC check result
	// Position of MICSTATUS field.
	CCM_MICSTATUS_MICSTATUS_Pos = 0x0
	// Bit mask of MICSTATUS field.
	CCM_MICSTATUS_MICSTATUS_Msk = 0x1
	// Bit MICSTATUS.
	CCM_MICSTATUS_MICSTATUS = 0x1
	// MIC check failed
	CCM_MICSTATUS_MICSTATUS_CheckFailed = 0x0
	// MIC check passed
	CCM_MICSTATUS_MICSTATUS_CheckPassed = 0x1

	// ENABLE: Enable
	// Position of ENABLE field.
	CCM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CCM_ENABLE_ENABLE_Msk = 0x3
	// Disable
	CCM_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	CCM_ENABLE_ENABLE_Enabled = 0x2

	// MODE: Operation mode
	// Position of MODE field.
	CCM_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	CCM_MODE_MODE_Msk = 0x1
	// Bit MODE.
	CCM_MODE_MODE = 0x1
	// AES CCM packet encryption mode
	CCM_MODE_MODE_Encryption = 0x0
	// AES CCM packet decryption mode
	CCM_MODE_MODE_Decryption = 0x1
	// Position of DATARATE field.
	CCM_MODE_DATARATE_Pos = 0x10
	// Bit mask of DATARATE field.
	CCM_MODE_DATARATE_Msk = 0x10000
	// Bit DATARATE.
	CCM_MODE_DATARATE = 0x10000
	// In synch with 1 Mbit data rate
	CCM_MODE_DATARATE_1Mbit = 0x0
	// In synch with 2 Mbit data rate
	CCM_MODE_DATARATE_2Mbit = 0x1
	// Position of LENGTH field.
	CCM_MODE_LENGTH_Pos = 0x18
	// Bit mask of LENGTH field.
	CCM_MODE_LENGTH_Msk = 0x1000000
	// Bit LENGTH.
	CCM_MODE_LENGTH = 0x1000000
	// Default length. Effective length of LENGTH field is 5-bit
	CCM_MODE_LENGTH_Default = 0x0
	// Extended length. Effective length of LENGTH field is 8-bit
	CCM_MODE_LENGTH_Extended = 0x1

	// CNFPTR: Pointer to data structure holding AES key and NONCE vector
	// Position of CNFPTR field.
	CCM_CNFPTR_CNFPTR_Pos = 0x0
	// Bit mask of CNFPTR field.
	CCM_CNFPTR_CNFPTR_Msk = 0xffffffff

	// INPTR: Input pointer
	// Position of INPTR field.
	CCM_INPTR_INPTR_Pos = 0x0
	// Bit mask of INPTR field.
	CCM_INPTR_INPTR_Msk = 0xffffffff

	// OUTPTR: Output pointer
	// Position of OUTPTR field.
	CCM_OUTPTR_OUTPTR_Pos = 0x0
	// Bit mask of OUTPTR field.
	CCM_OUTPTR_OUTPTR_Msk = 0xffffffff

	// SCRATCHPTR: Pointer to data area used for temporary storage
	// Position of SCRATCHPTR field.
	CCM_SCRATCHPTR_SCRATCHPTR_Pos = 0x0
	// Bit mask of SCRATCHPTR field.
	CCM_SCRATCHPTR_SCRATCHPTR_Msk = 0xffffffff
)

// Constants for AAR: Accelerated Address Resolver
const (
	// INTENSET: Enable interrupt
	// Position of END field.
	AAR_INTENSET_END_Pos = 0x0
	// Bit mask of END field.
	AAR_INTENSET_END_Msk = 0x1
	// Bit END.
	AAR_INTENSET_END = 0x1
	// Read: Disabled
	AAR_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	AAR_INTENSET_END_Enabled = 0x1
	// Enable
	AAR_INTENSET_END_Set = 0x1
	// Position of RESOLVED field.
	AAR_INTENSET_RESOLVED_Pos = 0x1
	// Bit mask of RESOLVED field.
	AAR_INTENSET_RESOLVED_Msk = 0x2
	// Bit RESOLVED.
	AAR_INTENSET_RESOLVED = 0x2
	// Read: Disabled
	AAR_INTENSET_RESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENSET_RESOLVED_Enabled = 0x1
	// Enable
	AAR_INTENSET_RESOLVED_Set = 0x1
	// Position of NOTRESOLVED field.
	AAR_INTENSET_NOTRESOLVED_Pos = 0x2
	// Bit mask of NOTRESOLVED field.
	AAR_INTENSET_NOTRESOLVED_Msk = 0x4
	// Bit NOTRESOLVED.
	AAR_INTENSET_NOTRESOLVED = 0x4
	// Read: Disabled
	AAR_INTENSET_NOTRESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENSET_NOTRESOLVED_Enabled = 0x1
	// Enable
	AAR_INTENSET_NOTRESOLVED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of END field.
	AAR_INTENCLR_END_Pos = 0x0
	// Bit mask of END field.
	AAR_INTENCLR_END_Msk = 0x1
	// Bit END.
	AAR_INTENCLR_END = 0x1
	// Read: Disabled
	AAR_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	AAR_INTENCLR_END_Enabled = 0x1
	// Disable
	AAR_INTENCLR_END_Clear = 0x1
	// Position of RESOLVED field.
	AAR_INTENCLR_RESOLVED_Pos = 0x1
	// Bit mask of RESOLVED field.
	AAR_INTENCLR_RESOLVED_Msk = 0x2
	// Bit RESOLVED.
	AAR_INTENCLR_RESOLVED = 0x2
	// Read: Disabled
	AAR_INTENCLR_RESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENCLR_RESOLVED_Enabled = 0x1
	// Disable
	AAR_INTENCLR_RESOLVED_Clear = 0x1
	// Position of NOTRESOLVED field.
	AAR_INTENCLR_NOTRESOLVED_Pos = 0x2
	// Bit mask of NOTRESOLVED field.
	AAR_INTENCLR_NOTRESOLVED_Msk = 0x4
	// Bit NOTRESOLVED.
	AAR_INTENCLR_NOTRESOLVED = 0x4
	// Read: Disabled
	AAR_INTENCLR_NOTRESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENCLR_NOTRESOLVED_Enabled = 0x1
	// Disable
	AAR_INTENCLR_NOTRESOLVED_Clear = 0x1

	// STATUS: Resolution status
	// Position of STATUS field.
	AAR_STATUS_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	AAR_STATUS_STATUS_Msk = 0xf

	// ENABLE: Enable AAR
	// Position of ENABLE field.
	AAR_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	AAR_ENABLE_ENABLE_Msk = 0x3
	// Disable
	AAR_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	AAR_ENABLE_ENABLE_Enabled = 0x3

	// NIRK: Number of IRKs
	// Position of NIRK field.
	AAR_NIRK_NIRK_Pos = 0x0
	// Bit mask of NIRK field.
	AAR_NIRK_NIRK_Msk = 0x1f

	// IRKPTR: Pointer to IRK data structure
	// Position of IRKPTR field.
	AAR_IRKPTR_IRKPTR_Pos = 0x0
	// Bit mask of IRKPTR field.
	AAR_IRKPTR_IRKPTR_Msk = 0xffffffff

	// ADDRPTR: Pointer to the resolvable address
	// Position of ADDRPTR field.
	AAR_ADDRPTR_ADDRPTR_Pos = 0x0
	// Bit mask of ADDRPTR field.
	AAR_ADDRPTR_ADDRPTR_Msk = 0xffffffff

	// SCRATCHPTR: Pointer to data area used for temporary storage
	// Position of SCRATCHPTR field.
	AAR_SCRATCHPTR_SCRATCHPTR_Pos = 0x0
	// Bit mask of SCRATCHPTR field.
	AAR_SCRATCHPTR_SCRATCHPTR_Msk = 0xffffffff
)

// Constants for WDT: Watchdog Timer
const (
	// INTENSET: Enable interrupt
	// Position of TIMEOUT field.
	WDT_INTENSET_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_INTENSET_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_INTENSET_TIMEOUT = 0x1
	// Read: Disabled
	WDT_INTENSET_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_INTENSET_TIMEOUT_Enabled = 0x1
	// Enable
	WDT_INTENSET_TIMEOUT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TIMEOUT field.
	WDT_INTENCLR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_INTENCLR_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_INTENCLR_TIMEOUT = 0x1
	// Read: Disabled
	WDT_INTENCLR_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_INTENCLR_TIMEOUT_Enabled = 0x1
	// Disable
	WDT_INTENCLR_TIMEOUT_Clear = 0x1

	// RUNSTATUS: Run status
	// Position of RUNSTATUS field.
	WDT_RUNSTATUS_RUNSTATUS_Pos = 0x0
	// Bit mask of RUNSTATUS field.
	WDT_RUNSTATUS_RUNSTATUS_Msk = 0x1
	// Bit RUNSTATUS.
	WDT_RUNSTATUS_RUNSTATUS = 0x1
	// Watchdog not running
	WDT_RUNSTATUS_RUNSTATUS_NotRunning = 0x0
	// Watchdog is running
	WDT_RUNSTATUS_RUNSTATUS_Running = 0x1

	// REQSTATUS: Request status
	// Position of RR0 field.
	WDT_REQSTATUS_RR0_Pos = 0x0
	// Bit mask of RR0 field.
	WDT_REQSTATUS_RR0_Msk = 0x1
	// Bit RR0.
	WDT_REQSTATUS_RR0 = 0x1
	// RR[0] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR0_DisabledOrRequested = 0x0
	// RR[0] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR0_EnabledAndUnrequested = 0x1
	// Position of RR1 field.
	WDT_REQSTATUS_RR1_Pos = 0x1
	// Bit mask of RR1 field.
	WDT_REQSTATUS_RR1_Msk = 0x2
	// Bit RR1.
	WDT_REQSTATUS_RR1 = 0x2
	// RR[1] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR1_DisabledOrRequested = 0x0
	// RR[1] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR1_EnabledAndUnrequested = 0x1
	// Position of RR2 field.
	WDT_REQSTATUS_RR2_Pos = 0x2
	// Bit mask of RR2 field.
	WDT_REQSTATUS_RR2_Msk = 0x4
	// Bit RR2.
	WDT_REQSTATUS_RR2 = 0x4
	// RR[2] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR2_DisabledOrRequested = 0x0
	// RR[2] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR2_EnabledAndUnrequested = 0x1
	// Position of RR3 field.
	WDT_REQSTATUS_RR3_Pos = 0x3
	// Bit mask of RR3 field.
	WDT_REQSTATUS_RR3_Msk = 0x8
	// Bit RR3.
	WDT_REQSTATUS_RR3 = 0x8
	// RR[3] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR3_DisabledOrRequested = 0x0
	// RR[3] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR3_EnabledAndUnrequested = 0x1
	// Position of RR4 field.
	WDT_REQSTATUS_RR4_Pos = 0x4
	// Bit mask of RR4 field.
	WDT_REQSTATUS_RR4_Msk = 0x10
	// Bit RR4.
	WDT_REQSTATUS_RR4 = 0x10
	// RR[4] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR4_DisabledOrRequested = 0x0
	// RR[4] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR4_EnabledAndUnrequested = 0x1
	// Position of RR5 field.
	WDT_REQSTATUS_RR5_Pos = 0x5
	// Bit mask of RR5 field.
	WDT_REQSTATUS_RR5_Msk = 0x20
	// Bit RR5.
	WDT_REQSTATUS_RR5 = 0x20
	// RR[5] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR5_DisabledOrRequested = 0x0
	// RR[5] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR5_EnabledAndUnrequested = 0x1
	// Position of RR6 field.
	WDT_REQSTATUS_RR6_Pos = 0x6
	// Bit mask of RR6 field.
	WDT_REQSTATUS_RR6_Msk = 0x40
	// Bit RR6.
	WDT_REQSTATUS_RR6 = 0x40
	// RR[6] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR6_DisabledOrRequested = 0x0
	// RR[6] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR6_EnabledAndUnrequested = 0x1
	// Position of RR7 field.
	WDT_REQSTATUS_RR7_Pos = 0x7
	// Bit mask of RR7 field.
	WDT_REQSTATUS_RR7_Msk = 0x80
	// Bit RR7.
	WDT_REQSTATUS_RR7 = 0x80
	// RR[7] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR7_DisabledOrRequested = 0x0
	// RR[7] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR7_EnabledAndUnrequested = 0x1

	// CRV: Counter reload value
	// Position of CRV field.
	WDT_CRV_CRV_Pos = 0x0
	// Bit mask of CRV field.
	WDT_CRV_CRV_Msk = 0xffffffff

	// RREN: Enable register for reload request registers
	// Position of RR0 field.
	WDT_RREN_RR0_Pos = 0x0
	// Bit mask of RR0 field.
	WDT_RREN_RR0_Msk = 0x1
	// Bit RR0.
	WDT_RREN_RR0 = 0x1
	// Disable RR[0] register
	WDT_RREN_RR0_Disabled = 0x0
	// Enable RR[0] register
	WDT_RREN_RR0_Enabled = 0x1
	// Position of RR1 field.
	WDT_RREN_RR1_Pos = 0x1
	// Bit mask of RR1 field.
	WDT_RREN_RR1_Msk = 0x2
	// Bit RR1.
	WDT_RREN_RR1 = 0x2
	// Disable RR[1] register
	WDT_RREN_RR1_Disabled = 0x0
	// Enable RR[1] register
	WDT_RREN_RR1_Enabled = 0x1
	// Position of RR2 field.
	WDT_RREN_RR2_Pos = 0x2
	// Bit mask of RR2 field.
	WDT_RREN_RR2_Msk = 0x4
	// Bit RR2.
	WDT_RREN_RR2 = 0x4
	// Disable RR[2] register
	WDT_RREN_RR2_Disabled = 0x0
	// Enable RR[2] register
	WDT_RREN_RR2_Enabled = 0x1
	// Position of RR3 field.
	WDT_RREN_RR3_Pos = 0x3
	// Bit mask of RR3 field.
	WDT_RREN_RR3_Msk = 0x8
	// Bit RR3.
	WDT_RREN_RR3 = 0x8
	// Disable RR[3] register
	WDT_RREN_RR3_Disabled = 0x0
	// Enable RR[3] register
	WDT_RREN_RR3_Enabled = 0x1
	// Position of RR4 field.
	WDT_RREN_RR4_Pos = 0x4
	// Bit mask of RR4 field.
	WDT_RREN_RR4_Msk = 0x10
	// Bit RR4.
	WDT_RREN_RR4 = 0x10
	// Disable RR[4] register
	WDT_RREN_RR4_Disabled = 0x0
	// Enable RR[4] register
	WDT_RREN_RR4_Enabled = 0x1
	// Position of RR5 field.
	WDT_RREN_RR5_Pos = 0x5
	// Bit mask of RR5 field.
	WDT_RREN_RR5_Msk = 0x20
	// Bit RR5.
	WDT_RREN_RR5 = 0x20
	// Disable RR[5] register
	WDT_RREN_RR5_Disabled = 0x0
	// Enable RR[5] register
	WDT_RREN_RR5_Enabled = 0x1
	// Position of RR6 field.
	WDT_RREN_RR6_Pos = 0x6
	// Bit mask of RR6 field.
	WDT_RREN_RR6_Msk = 0x40
	// Bit RR6.
	WDT_RREN_RR6 = 0x40
	// Disable RR[6] register
	WDT_RREN_RR6_Disabled = 0x0
	// Enable RR[6] register
	WDT_RREN_RR6_Enabled = 0x1
	// Position of RR7 field.
	WDT_RREN_RR7_Pos = 0x7
	// Bit mask of RR7 field.
	WDT_RREN_RR7_Msk = 0x80
	// Bit RR7.
	WDT_RREN_RR7 = 0x80
	// Disable RR[7] register
	WDT_RREN_RR7_Disabled = 0x0
	// Enable RR[7] register
	WDT_RREN_RR7_Enabled = 0x1

	// CONFIG: Configuration register
	// Position of SLEEP field.
	WDT_CONFIG_SLEEP_Pos = 0x0
	// Bit mask of SLEEP field.
	WDT_CONFIG_SLEEP_Msk = 0x1
	// Bit SLEEP.
	WDT_CONFIG_SLEEP = 0x1
	// Pause watchdog while the CPU is sleeping
	WDT_CONFIG_SLEEP_Pause = 0x0
	// Keep the watchdog running while the CPU is sleeping
	WDT_CONFIG_SLEEP_Run = 0x1
	// Position of HALT field.
	WDT_CONFIG_HALT_Pos = 0x3
	// Bit mask of HALT field.
	WDT_CONFIG_HALT_Msk = 0x8
	// Bit HALT.
	WDT_CONFIG_HALT = 0x8
	// Pause watchdog while the CPU is halted by the debugger
	WDT_CONFIG_HALT_Pause = 0x0
	// Keep the watchdog running while the CPU is halted by the debugger
	WDT_CONFIG_HALT_Run = 0x1

	// RR: Description collection[0]: Reload request 0
	// Position of RR field.
	WDT_RR_RR_Pos = 0x0
	// Bit mask of RR field.
	WDT_RR_RR_Msk = 0xffffffff
	// Value to request a reload of the watchdog timer
	WDT_RR_RR_Reload = 0x6e524635
)

// Constants for QDEC: Quadrature Decoder
const (
	// SHORTS: Shortcut register
	// Position of REPORTRDY_READCLRACC field.
	QDEC_SHORTS_REPORTRDY_READCLRACC_Pos = 0x0
	// Bit mask of REPORTRDY_READCLRACC field.
	QDEC_SHORTS_REPORTRDY_READCLRACC_Msk = 0x1
	// Bit REPORTRDY_READCLRACC.
	QDEC_SHORTS_REPORTRDY_READCLRACC = 0x1
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled = 0x1
	// Position of SAMPLERDY_STOP field.
	QDEC_SHORTS_SAMPLERDY_STOP_Pos = 0x1
	// Bit mask of SAMPLERDY_STOP field.
	QDEC_SHORTS_SAMPLERDY_STOP_Msk = 0x2
	// Bit SAMPLERDY_STOP.
	QDEC_SHORTS_SAMPLERDY_STOP = 0x2
	// Disable shortcut
	QDEC_SHORTS_SAMPLERDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_SAMPLERDY_STOP_Enabled = 0x1
	// Position of REPORTRDY_RDCLRACC field.
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos = 0x2
	// Bit mask of REPORTRDY_RDCLRACC field.
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Msk = 0x4
	// Bit REPORTRDY_RDCLRACC.
	QDEC_SHORTS_REPORTRDY_RDCLRACC = 0x4
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Enabled = 0x1
	// Position of REPORTRDY_STOP field.
	QDEC_SHORTS_REPORTRDY_STOP_Pos = 0x3
	// Bit mask of REPORTRDY_STOP field.
	QDEC_SHORTS_REPORTRDY_STOP_Msk = 0x8
	// Bit REPORTRDY_STOP.
	QDEC_SHORTS_REPORTRDY_STOP = 0x8
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_STOP_Enabled = 0x1
	// Position of DBLRDY_RDCLRDBL field.
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos = 0x4
	// Bit mask of DBLRDY_RDCLRDBL field.
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Msk = 0x10
	// Bit DBLRDY_RDCLRDBL.
	QDEC_SHORTS_DBLRDY_RDCLRDBL = 0x10
	// Disable shortcut
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Enabled = 0x1
	// Position of DBLRDY_STOP field.
	QDEC_SHORTS_DBLRDY_STOP_Pos = 0x5
	// Bit mask of DBLRDY_STOP field.
	QDEC_SHORTS_DBLRDY_STOP_Msk = 0x20
	// Bit DBLRDY_STOP.
	QDEC_SHORTS_DBLRDY_STOP = 0x20
	// Disable shortcut
	QDEC_SHORTS_DBLRDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_DBLRDY_STOP_Enabled = 0x1
	// Position of SAMPLERDY_READCLRACC field.
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos = 0x6
	// Bit mask of SAMPLERDY_READCLRACC field.
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Msk = 0x40
	// Bit SAMPLERDY_READCLRACC.
	QDEC_SHORTS_SAMPLERDY_READCLRACC = 0x40
	// Disable shortcut
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of SAMPLERDY field.
	QDEC_INTENSET_SAMPLERDY_Pos = 0x0
	// Bit mask of SAMPLERDY field.
	QDEC_INTENSET_SAMPLERDY_Msk = 0x1
	// Bit SAMPLERDY.
	QDEC_INTENSET_SAMPLERDY = 0x1
	// Read: Disabled
	QDEC_INTENSET_SAMPLERDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_SAMPLERDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_SAMPLERDY_Set = 0x1
	// Position of REPORTRDY field.
	QDEC_INTENSET_REPORTRDY_Pos = 0x1
	// Bit mask of REPORTRDY field.
	QDEC_INTENSET_REPORTRDY_Msk = 0x2
	// Bit REPORTRDY.
	QDEC_INTENSET_REPORTRDY = 0x2
	// Read: Disabled
	QDEC_INTENSET_REPORTRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_REPORTRDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_REPORTRDY_Set = 0x1
	// Position of ACCOF field.
	QDEC_INTENSET_ACCOF_Pos = 0x2
	// Bit mask of ACCOF field.
	QDEC_INTENSET_ACCOF_Msk = 0x4
	// Bit ACCOF.
	QDEC_INTENSET_ACCOF = 0x4
	// Read: Disabled
	QDEC_INTENSET_ACCOF_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_ACCOF_Enabled = 0x1
	// Enable
	QDEC_INTENSET_ACCOF_Set = 0x1
	// Position of DBLRDY field.
	QDEC_INTENSET_DBLRDY_Pos = 0x3
	// Bit mask of DBLRDY field.
	QDEC_INTENSET_DBLRDY_Msk = 0x8
	// Bit DBLRDY.
	QDEC_INTENSET_DBLRDY = 0x8
	// Read: Disabled
	QDEC_INTENSET_DBLRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_DBLRDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_DBLRDY_Set = 0x1
	// Position of STOPPED field.
	QDEC_INTENSET_STOPPED_Pos = 0x4
	// Bit mask of STOPPED field.
	QDEC_INTENSET_STOPPED_Msk = 0x10
	// Bit STOPPED.
	QDEC_INTENSET_STOPPED = 0x10
	// Read: Disabled
	QDEC_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	QDEC_INTENSET_STOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of SAMPLERDY field.
	QDEC_INTENCLR_SAMPLERDY_Pos = 0x0
	// Bit mask of SAMPLERDY field.
	QDEC_INTENCLR_SAMPLERDY_Msk = 0x1
	// Bit SAMPLERDY.
	QDEC_INTENCLR_SAMPLERDY = 0x1
	// Read: Disabled
	QDEC_INTENCLR_SAMPLERDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_SAMPLERDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_SAMPLERDY_Clear = 0x1
	// Position of REPORTRDY field.
	QDEC_INTENCLR_REPORTRDY_Pos = 0x1
	// Bit mask of REPORTRDY field.
	QDEC_INTENCLR_REPORTRDY_Msk = 0x2
	// Bit REPORTRDY.
	QDEC_INTENCLR_REPORTRDY = 0x2
	// Read: Disabled
	QDEC_INTENCLR_REPORTRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_REPORTRDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_REPORTRDY_Clear = 0x1
	// Position of ACCOF field.
	QDEC_INTENCLR_ACCOF_Pos = 0x2
	// Bit mask of ACCOF field.
	QDEC_INTENCLR_ACCOF_Msk = 0x4
	// Bit ACCOF.
	QDEC_INTENCLR_ACCOF = 0x4
	// Read: Disabled
	QDEC_INTENCLR_ACCOF_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_ACCOF_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_ACCOF_Clear = 0x1
	// Position of DBLRDY field.
	QDEC_INTENCLR_DBLRDY_Pos = 0x3
	// Bit mask of DBLRDY field.
	QDEC_INTENCLR_DBLRDY_Msk = 0x8
	// Bit DBLRDY.
	QDEC_INTENCLR_DBLRDY = 0x8
	// Read: Disabled
	QDEC_INTENCLR_DBLRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_DBLRDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_DBLRDY_Clear = 0x1
	// Position of STOPPED field.
	QDEC_INTENCLR_STOPPED_Pos = 0x4
	// Bit mask of STOPPED field.
	QDEC_INTENCLR_STOPPED_Msk = 0x10
	// Bit STOPPED.
	QDEC_INTENCLR_STOPPED = 0x10
	// Read: Disabled
	QDEC_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_STOPPED_Clear = 0x1

	// ENABLE: Enable the quadrature decoder
	// Position of ENABLE field.
	QDEC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QDEC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QDEC_ENABLE_ENABLE = 0x1
	// Disable
	QDEC_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	QDEC_ENABLE_ENABLE_Enabled = 0x1

	// LEDPOL: LED output pin polarity
	// Position of LEDPOL field.
	QDEC_LEDPOL_LEDPOL_Pos = 0x0
	// Bit mask of LEDPOL field.
	QDEC_LEDPOL_LEDPOL_Msk = 0x1
	// Bit LEDPOL.
	QDEC_LEDPOL_LEDPOL = 0x1
	// Led active on output pin low
	QDEC_LEDPOL_LEDPOL_ActiveLow = 0x0
	// Led active on output pin high
	QDEC_LEDPOL_LEDPOL_ActiveHigh = 0x1

	// SAMPLEPER: Sample period
	// Position of SAMPLEPER field.
	QDEC_SAMPLEPER_SAMPLEPER_Pos = 0x0
	// Bit mask of SAMPLEPER field.
	QDEC_SAMPLEPER_SAMPLEPER_Msk = 0xf
	// 128 us
	QDEC_SAMPLEPER_SAMPLEPER_128us = 0x0
	// 256 us
	QDEC_SAMPLEPER_SAMPLEPER_256us = 0x1
	// 512 us
	QDEC_SAMPLEPER_SAMPLEPER_512us = 0x2
	// 1024 us
	QDEC_SAMPLEPER_SAMPLEPER_1024us = 0x3
	// 2048 us
	QDEC_SAMPLEPER_SAMPLEPER_2048us = 0x4
	// 4096 us
	QDEC_SAMPLEPER_SAMPLEPER_4096us = 0x5
	// 8192 us
	QDEC_SAMPLEPER_SAMPLEPER_8192us = 0x6
	// 16384 us
	QDEC_SAMPLEPER_SAMPLEPER_16384us = 0x7
	// 32768 us
	QDEC_SAMPLEPER_SAMPLEPER_32ms = 0x8
	// 65536 us
	QDEC_SAMPLEPER_SAMPLEPER_65ms = 0x9
	// 131072 us
	QDEC_SAMPLEPER_SAMPLEPER_131ms = 0xa

	// SAMPLE: Motion sample value
	// Position of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Pos = 0x0
	// Bit mask of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Msk = 0xffffffff

	// REPORTPER: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
	// Position of REPORTPER field.
	QDEC_REPORTPER_REPORTPER_Pos = 0x0
	// Bit mask of REPORTPER field.
	QDEC_REPORTPER_REPORTPER_Msk = 0xf
	// 10 samples / report
	QDEC_REPORTPER_REPORTPER_10Smpl = 0x0
	// 40 samples / report
	QDEC_REPORTPER_REPORTPER_40Smpl = 0x1
	// 80 samples / report
	QDEC_REPORTPER_REPORTPER_80Smpl = 0x2
	// 120 samples / report
	QDEC_REPORTPER_REPORTPER_120Smpl = 0x3
	// 160 samples / report
	QDEC_REPORTPER_REPORTPER_160Smpl = 0x4
	// 200 samples / report
	QDEC_REPORTPER_REPORTPER_200Smpl = 0x5
	// 240 samples / report
	QDEC_REPORTPER_REPORTPER_240Smpl = 0x6
	// 280 samples / report
	QDEC_REPORTPER_REPORTPER_280Smpl = 0x7
	// 1 sample / report
	QDEC_REPORTPER_REPORTPER_1Smpl = 0x8

	// ACC: Register accumulating the valid transitions
	// Position of ACC field.
	QDEC_ACC_ACC_Pos = 0x0
	// Bit mask of ACC field.
	QDEC_ACC_ACC_Msk = 0xffffffff

	// ACCREAD: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
	// Position of ACCREAD field.
	QDEC_ACCREAD_ACCREAD_Pos = 0x0
	// Bit mask of ACCREAD field.
	QDEC_ACCREAD_ACCREAD_Msk = 0xffffffff

	// PSEL.LED: Pin select for LED signal
	// Position of PIN field.
	QDEC_PSEL_LED_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_LED_PIN_Msk = 0x1f
	// Position of CONNECT field.
	QDEC_PSEL_LED_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_LED_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_LED_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_LED_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_LED_CONNECT_Connected = 0x0

	// PSEL.A: Pin select for A signal
	// Position of PIN field.
	QDEC_PSEL_A_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_A_PIN_Msk = 0x1f
	// Position of CONNECT field.
	QDEC_PSEL_A_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_A_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_A_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_A_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_A_CONNECT_Connected = 0x0

	// PSEL.B: Pin select for B signal
	// Position of PIN field.
	QDEC_PSEL_B_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_B_PIN_Msk = 0x1f
	// Position of CONNECT field.
	QDEC_PSEL_B_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_B_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_B_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_B_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_B_CONNECT_Connected = 0x0

	// DBFEN: Enable input debounce filters
	// Position of DBFEN field.
	QDEC_DBFEN_DBFEN_Pos = 0x0
	// Bit mask of DBFEN field.
	QDEC_DBFEN_DBFEN_Msk = 0x1
	// Bit DBFEN.
	QDEC_DBFEN_DBFEN = 0x1
	// Debounce input filters disabled
	QDEC_DBFEN_DBFEN_Disabled = 0x0
	// Debounce input filters enabled
	QDEC_DBFEN_DBFEN_Enabled = 0x1

	// LEDPRE: Time period the LED is switched ON prior to sampling
	// Position of LEDPRE field.
	QDEC_LEDPRE_LEDPRE_Pos = 0x0
	// Bit mask of LEDPRE field.
	QDEC_LEDPRE_LEDPRE_Msk = 0x1ff

	// ACCDBL: Register accumulating the number of detected double transitions
	// Position of ACCDBL field.
	QDEC_ACCDBL_ACCDBL_Pos = 0x0
	// Bit mask of ACCDBL field.
	QDEC_ACCDBL_ACCDBL_Msk = 0xf

	// ACCDBLREAD: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
	// Position of ACCDBLREAD field.
	QDEC_ACCDBLREAD_ACCDBLREAD_Pos = 0x0
	// Bit mask of ACCDBLREAD field.
	QDEC_ACCDBLREAD_ACCDBLREAD_Msk = 0xf
)

// Constants for COMP: Comparator
const (
	// SHORTS: Shortcut register
	// Position of READY_SAMPLE field.
	COMP_SHORTS_READY_SAMPLE_Pos = 0x0
	// Bit mask of READY_SAMPLE field.
	COMP_SHORTS_READY_SAMPLE_Msk = 0x1
	// Bit READY_SAMPLE.
	COMP_SHORTS_READY_SAMPLE = 0x1
	// Disable shortcut
	COMP_SHORTS_READY_SAMPLE_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_READY_SAMPLE_Enabled = 0x1
	// Position of READY_STOP field.
	COMP_SHORTS_READY_STOP_Pos = 0x1
	// Bit mask of READY_STOP field.
	COMP_SHORTS_READY_STOP_Msk = 0x2
	// Bit READY_STOP.
	COMP_SHORTS_READY_STOP = 0x2
	// Disable shortcut
	COMP_SHORTS_READY_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_READY_STOP_Enabled = 0x1
	// Position of DOWN_STOP field.
	COMP_SHORTS_DOWN_STOP_Pos = 0x2
	// Bit mask of DOWN_STOP field.
	COMP_SHORTS_DOWN_STOP_Msk = 0x4
	// Bit DOWN_STOP.
	COMP_SHORTS_DOWN_STOP = 0x4
	// Disable shortcut
	COMP_SHORTS_DOWN_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_DOWN_STOP_Enabled = 0x1
	// Position of UP_STOP field.
	COMP_SHORTS_UP_STOP_Pos = 0x3
	// Bit mask of UP_STOP field.
	COMP_SHORTS_UP_STOP_Msk = 0x8
	// Bit UP_STOP.
	COMP_SHORTS_UP_STOP = 0x8
	// Disable shortcut
	COMP_SHORTS_UP_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_UP_STOP_Enabled = 0x1
	// Position of CROSS_STOP field.
	COMP_SHORTS_CROSS_STOP_Pos = 0x4
	// Bit mask of CROSS_STOP field.
	COMP_SHORTS_CROSS_STOP_Msk = 0x10
	// Bit CROSS_STOP.
	COMP_SHORTS_CROSS_STOP = 0x10
	// Disable shortcut
	COMP_SHORTS_CROSS_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_CROSS_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of READY field.
	COMP_INTEN_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTEN_READY_Msk = 0x1
	// Bit READY.
	COMP_INTEN_READY = 0x1
	// Disable
	COMP_INTEN_READY_Disabled = 0x0
	// Enable
	COMP_INTEN_READY_Enabled = 0x1
	// Position of DOWN field.
	COMP_INTEN_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTEN_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTEN_DOWN = 0x2
	// Disable
	COMP_INTEN_DOWN_Disabled = 0x0
	// Enable
	COMP_INTEN_DOWN_Enabled = 0x1
	// Position of UP field.
	COMP_INTEN_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTEN_UP_Msk = 0x4
	// Bit UP.
	COMP_INTEN_UP = 0x4
	// Disable
	COMP_INTEN_UP_Disabled = 0x0
	// Enable
	COMP_INTEN_UP_Enabled = 0x1
	// Position of CROSS field.
	COMP_INTEN_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTEN_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTEN_CROSS = 0x8
	// Disable
	COMP_INTEN_CROSS_Disabled = 0x0
	// Enable
	COMP_INTEN_CROSS_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	COMP_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTENSET_READY_Msk = 0x1
	// Bit READY.
	COMP_INTENSET_READY = 0x1
	// Read: Disabled
	COMP_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_READY_Enabled = 0x1
	// Enable
	COMP_INTENSET_READY_Set = 0x1
	// Position of DOWN field.
	COMP_INTENSET_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTENSET_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTENSET_DOWN = 0x2
	// Read: Disabled
	COMP_INTENSET_DOWN_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_DOWN_Enabled = 0x1
	// Enable
	COMP_INTENSET_DOWN_Set = 0x1
	// Position of UP field.
	COMP_INTENSET_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTENSET_UP_Msk = 0x4
	// Bit UP.
	COMP_INTENSET_UP = 0x4
	// Read: Disabled
	COMP_INTENSET_UP_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_UP_Enabled = 0x1
	// Enable
	COMP_INTENSET_UP_Set = 0x1
	// Position of CROSS field.
	COMP_INTENSET_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTENSET_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTENSET_CROSS = 0x8
	// Read: Disabled
	COMP_INTENSET_CROSS_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_CROSS_Enabled = 0x1
	// Enable
	COMP_INTENSET_CROSS_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	COMP_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	COMP_INTENCLR_READY = 0x1
	// Read: Disabled
	COMP_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_READY_Enabled = 0x1
	// Disable
	COMP_INTENCLR_READY_Clear = 0x1
	// Position of DOWN field.
	COMP_INTENCLR_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTENCLR_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTENCLR_DOWN = 0x2
	// Read: Disabled
	COMP_INTENCLR_DOWN_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_DOWN_Enabled = 0x1
	// Disable
	COMP_INTENCLR_DOWN_Clear = 0x1
	// Position of UP field.
	COMP_INTENCLR_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTENCLR_UP_Msk = 0x4
	// Bit UP.
	COMP_INTENCLR_UP = 0x4
	// Read: Disabled
	COMP_INTENCLR_UP_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_UP_Enabled = 0x1
	// Disable
	COMP_INTENCLR_UP_Clear = 0x1
	// Position of CROSS field.
	COMP_INTENCLR_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTENCLR_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTENCLR_CROSS = 0x8
	// Read: Disabled
	COMP_INTENCLR_CROSS_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_CROSS_Enabled = 0x1
	// Disable
	COMP_INTENCLR_CROSS_Clear = 0x1

	// RESULT: Compare result
	// Position of RESULT field.
	COMP_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	COMP_RESULT_RESULT_Msk = 0x1
	// Bit RESULT.
	COMP_RESULT_RESULT = 0x1
	// Input voltage is below the threshold (VIN+ &lt; VIN-)
	COMP_RESULT_RESULT_Below = 0x0
	// Input voltage is above the threshold (VIN+ &gt; VIN-)
	COMP_RESULT_RESULT_Above = 0x1

	// ENABLE: COMP enable
	// Position of ENABLE field.
	COMP_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	COMP_ENABLE_ENABLE_Msk = 0x3
	// Disable
	COMP_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	COMP_ENABLE_ENABLE_Enabled = 0x2

	// PSEL: Pin select
	// Position of PSEL field.
	COMP_PSEL_PSEL_Pos = 0x0
	// Bit mask of PSEL field.
	COMP_PSEL_PSEL_Msk = 0x7
	// AIN0 selected as analog input
	COMP_PSEL_PSEL_AnalogInput0 = 0x0
	// AIN1 selected as analog input
	COMP_PSEL_PSEL_AnalogInput1 = 0x1
	// AIN2 selected as analog input
	COMP_PSEL_PSEL_AnalogInput2 = 0x2
	// AIN3 selected as analog input
	COMP_PSEL_PSEL_AnalogInput3 = 0x3
	// AIN4 selected as analog input
	COMP_PSEL_PSEL_AnalogInput4 = 0x4
	// AIN5 selected as analog input
	COMP_PSEL_PSEL_AnalogInput5 = 0x5
	// AIN6 selected as analog input
	COMP_PSEL_PSEL_AnalogInput6 = 0x6
	// AIN7 selected as analog input
	COMP_PSEL_PSEL_AnalogInput7 = 0x7

	// REFSEL: Reference source select for single-ended mode
	// Position of REFSEL field.
	COMP_REFSEL_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	COMP_REFSEL_REFSEL_Msk = 0x7
	// VREF = internal 1.2 V reference (VDD &gt;= 1.7 V)
	COMP_REFSEL_REFSEL_Int1V2 = 0x0
	// VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V)
	COMP_REFSEL_REFSEL_Int1V8 = 0x1
	// VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V)
	COMP_REFSEL_REFSEL_Int2V4 = 0x2
	// VREF = VDD
	COMP_REFSEL_REFSEL_VDD = 0x4
	// VREF = AREF (VDD &gt;= VREF &gt;= AREFMIN)
	COMP_REFSEL_REFSEL_ARef = 0x7

	// EXTREFSEL: External reference select
	// Position of EXTREFSEL field.
	COMP_EXTREFSEL_EXTREFSEL_Pos = 0x0
	// Bit mask of EXTREFSEL field.
	COMP_EXTREFSEL_EXTREFSEL_Msk = 0x7
	// Use AIN0 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 = 0x0
	// Use AIN1 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 = 0x1
	// Use AIN2 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference2 = 0x2
	// Use AIN3 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference3 = 0x3
	// Use AIN4 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference4 = 0x4
	// Use AIN5 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference5 = 0x5
	// Use AIN6 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference6 = 0x6
	// Use AIN7 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference7 = 0x7

	// TH: Threshold configuration for hysteresis unit
	// Position of THDOWN field.
	COMP_TH_THDOWN_Pos = 0x0
	// Bit mask of THDOWN field.
	COMP_TH_THDOWN_Msk = 0x3f
	// Position of THUP field.
	COMP_TH_THUP_Pos = 0x8
	// Bit mask of THUP field.
	COMP_TH_THUP_Msk = 0x3f00

	// MODE: Mode configuration
	// Position of SP field.
	COMP_MODE_SP_Pos = 0x0
	// Bit mask of SP field.
	COMP_MODE_SP_Msk = 0x3
	// Low-power mode
	COMP_MODE_SP_Low = 0x0
	// Normal mode
	COMP_MODE_SP_Normal = 0x1
	// High-speed mode
	COMP_MODE_SP_High = 0x2
	// Position of MAIN field.
	COMP_MODE_MAIN_Pos = 0x8
	// Bit mask of MAIN field.
	COMP_MODE_MAIN_Msk = 0x100
	// Bit MAIN.
	COMP_MODE_MAIN = 0x100
	// Single-ended mode
	COMP_MODE_MAIN_SE = 0x0
	// Differential mode
	COMP_MODE_MAIN_Diff = 0x1

	// HYST: Comparator hysteresis enable
	// Position of HYST field.
	COMP_HYST_HYST_Pos = 0x0
	// Bit mask of HYST field.
	COMP_HYST_HYST_Msk = 0x1
	// Bit HYST.
	COMP_HYST_HYST = 0x1
	// Comparator hysteresis disabled
	COMP_HYST_HYST_NoHyst = 0x0
	// Comparator hysteresis enabled
	COMP_HYST_HYST_Hyst50mV = 0x1

	// ISOURCE: Current source select on analog input
	// Position of ISOURCE field.
	COMP_ISOURCE_ISOURCE_Pos = 0x0
	// Bit mask of ISOURCE field.
	COMP_ISOURCE_ISOURCE_Msk = 0x3
	// Current source disabled
	COMP_ISOURCE_ISOURCE_Off = 0x0
	// Current source enabled (+/- 2.5 uA)
	COMP_ISOURCE_ISOURCE_Ien2mA5 = 0x1
	// Current source enabled (+/- 5 uA)
	COMP_ISOURCE_ISOURCE_Ien5mA = 0x2
	// Current source enabled (+/- 10 uA)
	COMP_ISOURCE_ISOURCE_Ien10mA = 0x3
)

// Constants for LPCOMP: Low Power Comparator
const (
	// SHORTS: Shortcut register
	// Position of READY_SAMPLE field.
	LPCOMP_SHORTS_READY_SAMPLE_Pos = 0x0
	// Bit mask of READY_SAMPLE field.
	LPCOMP_SHORTS_READY_SAMPLE_Msk = 0x1
	// Bit READY_SAMPLE.
	LPCOMP_SHORTS_READY_SAMPLE = 0x1
	// Disable shortcut
	LPCOMP_SHORTS_READY_SAMPLE_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_READY_SAMPLE_Enabled = 0x1
	// Position of READY_STOP field.
	LPCOMP_SHORTS_READY_STOP_Pos = 0x1
	// Bit mask of READY_STOP field.
	LPCOMP_SHORTS_READY_STOP_Msk = 0x2
	// Bit READY_STOP.
	LPCOMP_SHORTS_READY_STOP = 0x2
	// Disable shortcut
	LPCOMP_SHORTS_READY_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_READY_STOP_Enabled = 0x1
	// Position of DOWN_STOP field.
	LPCOMP_SHORTS_DOWN_STOP_Pos = 0x2
	// Bit mask of DOWN_STOP field.
	LPCOMP_SHORTS_DOWN_STOP_Msk = 0x4
	// Bit DOWN_STOP.
	LPCOMP_SHORTS_DOWN_STOP = 0x4
	// Disable shortcut
	LPCOMP_SHORTS_DOWN_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_DOWN_STOP_Enabled = 0x1
	// Position of UP_STOP field.
	LPCOMP_SHORTS_UP_STOP_Pos = 0x3
	// Bit mask of UP_STOP field.
	LPCOMP_SHORTS_UP_STOP_Msk = 0x8
	// Bit UP_STOP.
	LPCOMP_SHORTS_UP_STOP = 0x8
	// Disable shortcut
	LPCOMP_SHORTS_UP_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_UP_STOP_Enabled = 0x1
	// Position of CROSS_STOP field.
	LPCOMP_SHORTS_CROSS_STOP_Pos = 0x4
	// Bit mask of CROSS_STOP field.
	LPCOMP_SHORTS_CROSS_STOP_Msk = 0x10
	// Bit CROSS_STOP.
	LPCOMP_SHORTS_CROSS_STOP = 0x10
	// Disable shortcut
	LPCOMP_SHORTS_CROSS_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_CROSS_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	LPCOMP_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	LPCOMP_INTENSET_READY_Msk = 0x1
	// Bit READY.
	LPCOMP_INTENSET_READY = 0x1
	// Read: Disabled
	LPCOMP_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_READY_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_READY_Set = 0x1
	// Position of DOWN field.
	LPCOMP_INTENSET_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	LPCOMP_INTENSET_DOWN_Msk = 0x2
	// Bit DOWN.
	LPCOMP_INTENSET_DOWN = 0x2
	// Read: Disabled
	LPCOMP_INTENSET_DOWN_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_DOWN_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_DOWN_Set = 0x1
	// Position of UP field.
	LPCOMP_INTENSET_UP_Pos = 0x2
	// Bit mask of UP field.
	LPCOMP_INTENSET_UP_Msk = 0x4
	// Bit UP.
	LPCOMP_INTENSET_UP = 0x4
	// Read: Disabled
	LPCOMP_INTENSET_UP_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_UP_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_UP_Set = 0x1
	// Position of CROSS field.
	LPCOMP_INTENSET_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	LPCOMP_INTENSET_CROSS_Msk = 0x8
	// Bit CROSS.
	LPCOMP_INTENSET_CROSS = 0x8
	// Read: Disabled
	LPCOMP_INTENSET_CROSS_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_CROSS_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_CROSS_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	LPCOMP_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	LPCOMP_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	LPCOMP_INTENCLR_READY = 0x1
	// Read: Disabled
	LPCOMP_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_READY_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_READY_Clear = 0x1
	// Position of DOWN field.
	LPCOMP_INTENCLR_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	LPCOMP_INTENCLR_DOWN_Msk = 0x2
	// Bit DOWN.
	LPCOMP_INTENCLR_DOWN = 0x2
	// Read: Disabled
	LPCOMP_INTENCLR_DOWN_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_DOWN_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_DOWN_Clear = 0x1
	// Position of UP field.
	LPCOMP_INTENCLR_UP_Pos = 0x2
	// Bit mask of UP field.
	LPCOMP_INTENCLR_UP_Msk = 0x4
	// Bit UP.
	LPCOMP_INTENCLR_UP = 0x4
	// Read: Disabled
	LPCOMP_INTENCLR_UP_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_UP_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_UP_Clear = 0x1
	// Position of CROSS field.
	LPCOMP_INTENCLR_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	LPCOMP_INTENCLR_CROSS_Msk = 0x8
	// Bit CROSS.
	LPCOMP_INTENCLR_CROSS = 0x8
	// Read: Disabled
	LPCOMP_INTENCLR_CROSS_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_CROSS_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_CROSS_Clear = 0x1

	// RESULT: Compare result
	// Position of RESULT field.
	LPCOMP_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	LPCOMP_RESULT_RESULT_Msk = 0x1
	// Bit RESULT.
	LPCOMP_RESULT_RESULT = 0x1
	// Input voltage is below the reference threshold (VIN+ &lt; VIN-).
	LPCOMP_RESULT_RESULT_Below = 0x0
	// Input voltage is above the reference threshold (VIN+ &gt; VIN-).
	LPCOMP_RESULT_RESULT_Above = 0x1

	// ENABLE: Enable LPCOMP
	// Position of ENABLE field.
	LPCOMP_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPCOMP_ENABLE_ENABLE_Msk = 0x3
	// Disable
	LPCOMP_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	LPCOMP_ENABLE_ENABLE_Enabled = 0x1

	// PSEL: Input pin select
	// Position of PSEL field.
	LPCOMP_PSEL_PSEL_Pos = 0x0
	// Bit mask of PSEL field.
	LPCOMP_PSEL_PSEL_Msk = 0x7
	// AIN0 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput0 = 0x0
	// AIN1 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput1 = 0x1
	// AIN2 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput2 = 0x2
	// AIN3 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput3 = 0x3
	// AIN4 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput4 = 0x4
	// AIN5 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput5 = 0x5
	// AIN6 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput6 = 0x6
	// AIN7 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput7 = 0x7

	// REFSEL: Reference select
	// Position of REFSEL field.
	LPCOMP_REFSEL_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	LPCOMP_REFSEL_REFSEL_Msk = 0xf
	// VDD * 1/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref1_8Vdd = 0x0
	// VDD * 2/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref2_8Vdd = 0x1
	// VDD * 3/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref3_8Vdd = 0x2
	// VDD * 4/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref4_8Vdd = 0x3
	// VDD * 5/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref5_8Vdd = 0x4
	// VDD * 6/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref6_8Vdd = 0x5
	// VDD * 7/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref7_8Vdd = 0x6
	// External analog reference selected
	LPCOMP_REFSEL_REFSEL_ARef = 0x7
	// VDD * 1/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref1_16Vdd = 0x8
	// VDD * 3/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref3_16Vdd = 0x9
	// VDD * 5/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref5_16Vdd = 0xa
	// VDD * 7/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref7_16Vdd = 0xb
	// VDD * 9/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref9_16Vdd = 0xc
	// VDD * 11/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref11_16Vdd = 0xd
	// VDD * 13/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref13_16Vdd = 0xe
	// VDD * 15/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref15_16Vdd = 0xf

	// EXTREFSEL: External reference select
	// Position of EXTREFSEL field.
	LPCOMP_EXTREFSEL_EXTREFSEL_Pos = 0x0
	// Bit mask of EXTREFSEL field.
	LPCOMP_EXTREFSEL_EXTREFSEL_Msk = 0x1
	// Bit EXTREFSEL.
	LPCOMP_EXTREFSEL_EXTREFSEL = 0x1
	// Use AIN0 as external analog reference
	LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 = 0x0
	// Use AIN1 as external analog reference
	LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 = 0x1

	// ANADETECT: Analog detect configuration
	// Position of ANADETECT field.
	LPCOMP_ANADETECT_ANADETECT_Pos = 0x0
	// Bit mask of ANADETECT field.
	LPCOMP_ANADETECT_ANADETECT_Msk = 0x3
	// Generate ANADETECT on crossing, both upward crossing and downward crossing
	LPCOMP_ANADETECT_ANADETECT_Cross = 0x0
	// Generate ANADETECT on upward crossing only
	LPCOMP_ANADETECT_ANADETECT_Up = 0x1
	// Generate ANADETECT on downward crossing only
	LPCOMP_ANADETECT_ANADETECT_Down = 0x2

	// HYST: Comparator hysteresis enable
	// Position of HYST field.
	LPCOMP_HYST_HYST_Pos = 0x0
	// Bit mask of HYST field.
	LPCOMP_HYST_HYST_Msk = 0x1
	// Bit HYST.
	LPCOMP_HYST_HYST = 0x1
	// Comparator hysteresis disabled
	LPCOMP_HYST_HYST_NoHyst = 0x0
	// Comparator hysteresis disabled (typ. 50 mV)
	LPCOMP_HYST_HYST_Hyst50mV = 0x1
)

// Constants for SWI0: Software interrupt 0
const ()

// Constants for EGU0: Event Generator Unit 0
const (
	// INTEN: Enable or disable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTEN_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTEN_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTEN_TRIGGERED0 = 0x1
	// Disable
	EGU_INTEN_TRIGGERED0_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED0_Enabled = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTEN_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTEN_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTEN_TRIGGERED1 = 0x2
	// Disable
	EGU_INTEN_TRIGGERED1_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED1_Enabled = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTEN_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTEN_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTEN_TRIGGERED2 = 0x4
	// Disable
	EGU_INTEN_TRIGGERED2_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED2_Enabled = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTEN_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTEN_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTEN_TRIGGERED3 = 0x8
	// Disable
	EGU_INTEN_TRIGGERED3_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED3_Enabled = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTEN_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTEN_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTEN_TRIGGERED4 = 0x10
	// Disable
	EGU_INTEN_TRIGGERED4_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED4_Enabled = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTEN_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTEN_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTEN_TRIGGERED5 = 0x20
	// Disable
	EGU_INTEN_TRIGGERED5_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED5_Enabled = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTEN_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTEN_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTEN_TRIGGERED6 = 0x40
	// Disable
	EGU_INTEN_TRIGGERED6_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED6_Enabled = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTEN_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTEN_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTEN_TRIGGERED7 = 0x80
	// Disable
	EGU_INTEN_TRIGGERED7_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED7_Enabled = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTEN_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTEN_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTEN_TRIGGERED8 = 0x100
	// Disable
	EGU_INTEN_TRIGGERED8_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED8_Enabled = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTEN_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTEN_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTEN_TRIGGERED9 = 0x200
	// Disable
	EGU_INTEN_TRIGGERED9_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED9_Enabled = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTEN_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTEN_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTEN_TRIGGERED10 = 0x400
	// Disable
	EGU_INTEN_TRIGGERED10_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED10_Enabled = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTEN_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTEN_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTEN_TRIGGERED11 = 0x800
	// Disable
	EGU_INTEN_TRIGGERED11_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED11_Enabled = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTEN_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTEN_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTEN_TRIGGERED12 = 0x1000
	// Disable
	EGU_INTEN_TRIGGERED12_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED12_Enabled = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTEN_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTEN_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTEN_TRIGGERED13 = 0x2000
	// Disable
	EGU_INTEN_TRIGGERED13_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED13_Enabled = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTEN_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTEN_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTEN_TRIGGERED14 = 0x4000
	// Disable
	EGU_INTEN_TRIGGERED14_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED14_Enabled = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTEN_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTEN_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTEN_TRIGGERED15 = 0x8000
	// Disable
	EGU_INTEN_TRIGGERED15_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED15_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTENSET_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTENSET_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTENSET_TRIGGERED0 = 0x1
	// Read: Disabled
	EGU_INTENSET_TRIGGERED0_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED0_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED0_Set = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTENSET_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTENSET_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTENSET_TRIGGERED1 = 0x2
	// Read: Disabled
	EGU_INTENSET_TRIGGERED1_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED1_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED1_Set = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTENSET_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTENSET_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTENSET_TRIGGERED2 = 0x4
	// Read: Disabled
	EGU_INTENSET_TRIGGERED2_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED2_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED2_Set = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTENSET_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTENSET_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTENSET_TRIGGERED3 = 0x8
	// Read: Disabled
	EGU_INTENSET_TRIGGERED3_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED3_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED3_Set = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTENSET_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTENSET_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTENSET_TRIGGERED4 = 0x10
	// Read: Disabled
	EGU_INTENSET_TRIGGERED4_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED4_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED4_Set = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTENSET_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTENSET_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTENSET_TRIGGERED5 = 0x20
	// Read: Disabled
	EGU_INTENSET_TRIGGERED5_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED5_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED5_Set = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTENSET_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTENSET_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTENSET_TRIGGERED6 = 0x40
	// Read: Disabled
	EGU_INTENSET_TRIGGERED6_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED6_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED6_Set = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTENSET_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTENSET_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTENSET_TRIGGERED7 = 0x80
	// Read: Disabled
	EGU_INTENSET_TRIGGERED7_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED7_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED7_Set = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTENSET_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTENSET_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTENSET_TRIGGERED8 = 0x100
	// Read: Disabled
	EGU_INTENSET_TRIGGERED8_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED8_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED8_Set = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTENSET_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTENSET_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTENSET_TRIGGERED9 = 0x200
	// Read: Disabled
	EGU_INTENSET_TRIGGERED9_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED9_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED9_Set = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTENSET_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTENSET_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTENSET_TRIGGERED10 = 0x400
	// Read: Disabled
	EGU_INTENSET_TRIGGERED10_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED10_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED10_Set = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTENSET_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTENSET_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTENSET_TRIGGERED11 = 0x800
	// Read: Disabled
	EGU_INTENSET_TRIGGERED11_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED11_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED11_Set = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTENSET_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTENSET_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTENSET_TRIGGERED12 = 0x1000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED12_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED12_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED12_Set = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTENSET_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTENSET_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTENSET_TRIGGERED13 = 0x2000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED13_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED13_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED13_Set = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTENSET_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTENSET_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTENSET_TRIGGERED14 = 0x4000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED14_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED14_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED14_Set = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTENSET_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTENSET_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTENSET_TRIGGERED15 = 0x8000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED15_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED15_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED15_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTENCLR_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTENCLR_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTENCLR_TRIGGERED0 = 0x1
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED0_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED0_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED0_Clear = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTENCLR_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTENCLR_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTENCLR_TRIGGERED1 = 0x2
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED1_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED1_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED1_Clear = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTENCLR_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTENCLR_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTENCLR_TRIGGERED2 = 0x4
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED2_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED2_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED2_Clear = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTENCLR_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTENCLR_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTENCLR_TRIGGERED3 = 0x8
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED3_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED3_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED3_Clear = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTENCLR_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTENCLR_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTENCLR_TRIGGERED4 = 0x10
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED4_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED4_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED4_Clear = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTENCLR_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTENCLR_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTENCLR_TRIGGERED5 = 0x20
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED5_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED5_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED5_Clear = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTENCLR_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTENCLR_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTENCLR_TRIGGERED6 = 0x40
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED6_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED6_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED6_Clear = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTENCLR_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTENCLR_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTENCLR_TRIGGERED7 = 0x80
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED7_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED7_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED7_Clear = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTENCLR_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTENCLR_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTENCLR_TRIGGERED8 = 0x100
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED8_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED8_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED8_Clear = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTENCLR_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTENCLR_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTENCLR_TRIGGERED9 = 0x200
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED9_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED9_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED9_Clear = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTENCLR_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTENCLR_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTENCLR_TRIGGERED10 = 0x400
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED10_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED10_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED10_Clear = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTENCLR_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTENCLR_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTENCLR_TRIGGERED11 = 0x800
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED11_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED11_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED11_Clear = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTENCLR_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTENCLR_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTENCLR_TRIGGERED12 = 0x1000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED12_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED12_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED12_Clear = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTENCLR_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTENCLR_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTENCLR_TRIGGERED13 = 0x2000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED13_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED13_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED13_Clear = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTENCLR_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTENCLR_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTENCLR_TRIGGERED14 = 0x4000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED14_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED14_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED14_Clear = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTENCLR_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTENCLR_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTENCLR_TRIGGERED15 = 0x8000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED15_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED15_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED15_Clear = 0x1
)

// Constants for PWM0: Pulse Width Modulation Unit 0
const (
	// SHORTS: Shortcut register
	// Position of SEQEND0_STOP field.
	PWM_SHORTS_SEQEND0_STOP_Pos = 0x0
	// Bit mask of SEQEND0_STOP field.
	PWM_SHORTS_SEQEND0_STOP_Msk = 0x1
	// Bit SEQEND0_STOP.
	PWM_SHORTS_SEQEND0_STOP = 0x1
	// Disable shortcut
	PWM_SHORTS_SEQEND0_STOP_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_SEQEND0_STOP_Enabled = 0x1
	// Position of SEQEND1_STOP field.
	PWM_SHORTS_SEQEND1_STOP_Pos = 0x1
	// Bit mask of SEQEND1_STOP field.
	PWM_SHORTS_SEQEND1_STOP_Msk = 0x2
	// Bit SEQEND1_STOP.
	PWM_SHORTS_SEQEND1_STOP = 0x2
	// Disable shortcut
	PWM_SHORTS_SEQEND1_STOP_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_SEQEND1_STOP_Enabled = 0x1
	// Position of LOOPSDONE_SEQSTART0 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos = 0x2
	// Bit mask of LOOPSDONE_SEQSTART0 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Msk = 0x4
	// Bit LOOPSDONE_SEQSTART0.
	PWM_SHORTS_LOOPSDONE_SEQSTART0 = 0x4
	// Disable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Enabled = 0x1
	// Position of LOOPSDONE_SEQSTART1 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos = 0x3
	// Bit mask of LOOPSDONE_SEQSTART1 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Msk = 0x8
	// Bit LOOPSDONE_SEQSTART1.
	PWM_SHORTS_LOOPSDONE_SEQSTART1 = 0x8
	// Disable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Enabled = 0x1
	// Position of LOOPSDONE_STOP field.
	PWM_SHORTS_LOOPSDONE_STOP_Pos = 0x4
	// Bit mask of LOOPSDONE_STOP field.
	PWM_SHORTS_LOOPSDONE_STOP_Msk = 0x10
	// Bit LOOPSDONE_STOP.
	PWM_SHORTS_LOOPSDONE_STOP = 0x10
	// Disable shortcut
	PWM_SHORTS_LOOPSDONE_STOP_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_LOOPSDONE_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	PWM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PWM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PWM_INTEN_STOPPED = 0x2
	// Disable
	PWM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	PWM_INTEN_STOPPED_Enabled = 0x1
	// Position of SEQSTARTED0 field.
	PWM_INTEN_SEQSTARTED0_Pos = 0x2
	// Bit mask of SEQSTARTED0 field.
	PWM_INTEN_SEQSTARTED0_Msk = 0x4
	// Bit SEQSTARTED0.
	PWM_INTEN_SEQSTARTED0 = 0x4
	// Disable
	PWM_INTEN_SEQSTARTED0_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQSTARTED0_Enabled = 0x1
	// Position of SEQSTARTED1 field.
	PWM_INTEN_SEQSTARTED1_Pos = 0x3
	// Bit mask of SEQSTARTED1 field.
	PWM_INTEN_SEQSTARTED1_Msk = 0x8
	// Bit SEQSTARTED1.
	PWM_INTEN_SEQSTARTED1 = 0x8
	// Disable
	PWM_INTEN_SEQSTARTED1_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQSTARTED1_Enabled = 0x1
	// Position of SEQEND0 field.
	PWM_INTEN_SEQEND0_Pos = 0x4
	// Bit mask of SEQEND0 field.
	PWM_INTEN_SEQEND0_Msk = 0x10
	// Bit SEQEND0.
	PWM_INTEN_SEQEND0 = 0x10
	// Disable
	PWM_INTEN_SEQEND0_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQEND0_Enabled = 0x1
	// Position of SEQEND1 field.
	PWM_INTEN_SEQEND1_Pos = 0x5
	// Bit mask of SEQEND1 field.
	PWM_INTEN_SEQEND1_Msk = 0x20
	// Bit SEQEND1.
	PWM_INTEN_SEQEND1 = 0x20
	// Disable
	PWM_INTEN_SEQEND1_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQEND1_Enabled = 0x1
	// Position of PWMPERIODEND field.
	PWM_INTEN_PWMPERIODEND_Pos = 0x6
	// Bit mask of PWMPERIODEND field.
	PWM_INTEN_PWMPERIODEND_Msk = 0x40
	// Bit PWMPERIODEND.
	PWM_INTEN_PWMPERIODEND = 0x40
	// Disable
	PWM_INTEN_PWMPERIODEND_Disabled = 0x0
	// Enable
	PWM_INTEN_PWMPERIODEND_Enabled = 0x1
	// Position of LOOPSDONE field.
	PWM_INTEN_LOOPSDONE_Pos = 0x7
	// Bit mask of LOOPSDONE field.
	PWM_INTEN_LOOPSDONE_Msk = 0x80
	// Bit LOOPSDONE.
	PWM_INTEN_LOOPSDONE = 0x80
	// Disable
	PWM_INTEN_LOOPSDONE_Disabled = 0x0
	// Enable
	PWM_INTEN_LOOPSDONE_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	PWM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PWM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PWM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	PWM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	PWM_INTENSET_STOPPED_Set = 0x1
	// Position of SEQSTARTED0 field.
	PWM_INTENSET_SEQSTARTED0_Pos = 0x2
	// Bit mask of SEQSTARTED0 field.
	PWM_INTENSET_SEQSTARTED0_Msk = 0x4
	// Bit SEQSTARTED0.
	PWM_INTENSET_SEQSTARTED0 = 0x4
	// Read: Disabled
	PWM_INTENSET_SEQSTARTED0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQSTARTED0_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQSTARTED0_Set = 0x1
	// Position of SEQSTARTED1 field.
	PWM_INTENSET_SEQSTARTED1_Pos = 0x3
	// Bit mask of SEQSTARTED1 field.
	PWM_INTENSET_SEQSTARTED1_Msk = 0x8
	// Bit SEQSTARTED1.
	PWM_INTENSET_SEQSTARTED1 = 0x8
	// Read: Disabled
	PWM_INTENSET_SEQSTARTED1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQSTARTED1_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQSTARTED1_Set = 0x1
	// Position of SEQEND0 field.
	PWM_INTENSET_SEQEND0_Pos = 0x4
	// Bit mask of SEQEND0 field.
	PWM_INTENSET_SEQEND0_Msk = 0x10
	// Bit SEQEND0.
	PWM_INTENSET_SEQEND0 = 0x10
	// Read: Disabled
	PWM_INTENSET_SEQEND0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQEND0_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQEND0_Set = 0x1
	// Position of SEQEND1 field.
	PWM_INTENSET_SEQEND1_Pos = 0x5
	// Bit mask of SEQEND1 field.
	PWM_INTENSET_SEQEND1_Msk = 0x20
	// Bit SEQEND1.
	PWM_INTENSET_SEQEND1 = 0x20
	// Read: Disabled
	PWM_INTENSET_SEQEND1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQEND1_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQEND1_Set = 0x1
	// Position of PWMPERIODEND field.
	PWM_INTENSET_PWMPERIODEND_Pos = 0x6
	// Bit mask of PWMPERIODEND field.
	PWM_INTENSET_PWMPERIODEND_Msk = 0x40
	// Bit PWMPERIODEND.
	PWM_INTENSET_PWMPERIODEND = 0x40
	// Read: Disabled
	PWM_INTENSET_PWMPERIODEND_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_PWMPERIODEND_Enabled = 0x1
	// Enable
	PWM_INTENSET_PWMPERIODEND_Set = 0x1
	// Position of LOOPSDONE field.
	PWM_INTENSET_LOOPSDONE_Pos = 0x7
	// Bit mask of LOOPSDONE field.
	PWM_INTENSET_LOOPSDONE_Msk = 0x80
	// Bit LOOPSDONE.
	PWM_INTENSET_LOOPSDONE = 0x80
	// Read: Disabled
	PWM_INTENSET_LOOPSDONE_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_LOOPSDONE_Enabled = 0x1
	// Enable
	PWM_INTENSET_LOOPSDONE_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	PWM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PWM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PWM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	PWM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	PWM_INTENCLR_STOPPED_Clear = 0x1
	// Position of SEQSTARTED0 field.
	PWM_INTENCLR_SEQSTARTED0_Pos = 0x2
	// Bit mask of SEQSTARTED0 field.
	PWM_INTENCLR_SEQSTARTED0_Msk = 0x4
	// Bit SEQSTARTED0.
	PWM_INTENCLR_SEQSTARTED0 = 0x4
	// Read: Disabled
	PWM_INTENCLR_SEQSTARTED0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQSTARTED0_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQSTARTED0_Clear = 0x1
	// Position of SEQSTARTED1 field.
	PWM_INTENCLR_SEQSTARTED1_Pos = 0x3
	// Bit mask of SEQSTARTED1 field.
	PWM_INTENCLR_SEQSTARTED1_Msk = 0x8
	// Bit SEQSTARTED1.
	PWM_INTENCLR_SEQSTARTED1 = 0x8
	// Read: Disabled
	PWM_INTENCLR_SEQSTARTED1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQSTARTED1_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQSTARTED1_Clear = 0x1
	// Position of SEQEND0 field.
	PWM_INTENCLR_SEQEND0_Pos = 0x4
	// Bit mask of SEQEND0 field.
	PWM_INTENCLR_SEQEND0_Msk = 0x10
	// Bit SEQEND0.
	PWM_INTENCLR_SEQEND0 = 0x10
	// Read: Disabled
	PWM_INTENCLR_SEQEND0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQEND0_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQEND0_Clear = 0x1
	// Position of SEQEND1 field.
	PWM_INTENCLR_SEQEND1_Pos = 0x5
	// Bit mask of SEQEND1 field.
	PWM_INTENCLR_SEQEND1_Msk = 0x20
	// Bit SEQEND1.
	PWM_INTENCLR_SEQEND1 = 0x20
	// Read: Disabled
	PWM_INTENCLR_SEQEND1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQEND1_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQEND1_Clear = 0x1
	// Position of PWMPERIODEND field.
	PWM_INTENCLR_PWMPERIODEND_Pos = 0x6
	// Bit mask of PWMPERIODEND field.
	PWM_INTENCLR_PWMPERIODEND_Msk = 0x40
	// Bit PWMPERIODEND.
	PWM_INTENCLR_PWMPERIODEND = 0x40
	// Read: Disabled
	PWM_INTENCLR_PWMPERIODEND_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_PWMPERIODEND_Enabled = 0x1
	// Disable
	PWM_INTENCLR_PWMPERIODEND_Clear = 0x1
	// Position of LOOPSDONE field.
	PWM_INTENCLR_LOOPSDONE_Pos = 0x7
	// Bit mask of LOOPSDONE field.
	PWM_INTENCLR_LOOPSDONE_Msk = 0x80
	// Bit LOOPSDONE.
	PWM_INTENCLR_LOOPSDONE = 0x80
	// Read: Disabled
	PWM_INTENCLR_LOOPSDONE_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_LOOPSDONE_Enabled = 0x1
	// Disable
	PWM_INTENCLR_LOOPSDONE_Clear = 0x1

	// ENABLE: PWM module enable register
	// Position of ENABLE field.
	PWM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PWM_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PWM_ENABLE_ENABLE = 0x1
	// Disabled
	PWM_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	PWM_ENABLE_ENABLE_Enabled = 0x1

	// MODE: Selects operating mode of the wave counter
	// Position of UPDOWN field.
	PWM_MODE_UPDOWN_Pos = 0x0
	// Bit mask of UPDOWN field.
	PWM_MODE_UPDOWN_Msk = 0x1
	// Bit UPDOWN.
	PWM_MODE_UPDOWN = 0x1
	// Up counter - edge aligned PWM duty-cycle
	PWM_MODE_UPDOWN_Up = 0x0
	// Up and down counter - center aligned PWM duty cycle
	PWM_MODE_UPDOWN_UpAndDown = 0x1

	// COUNTERTOP: Value up to which the pulse generator counter counts
	// Position of COUNTERTOP field.
	PWM_COUNTERTOP_COUNTERTOP_Pos = 0x0
	// Bit mask of COUNTERTOP field.
	PWM_COUNTERTOP_COUNTERTOP_Msk = 0x7fff

	// PRESCALER: Configuration for PWM_CLK
	// Position of PRESCALER field.
	PWM_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	PWM_PRESCALER_PRESCALER_Msk = 0x7
	// Divide by 1 (16MHz)
	PWM_PRESCALER_PRESCALER_DIV_1 = 0x0
	// Divide by 2 ( 8MHz)
	PWM_PRESCALER_PRESCALER_DIV_2 = 0x1
	// Divide by 4 ( 4MHz)
	PWM_PRESCALER_PRESCALER_DIV_4 = 0x2
	// Divide by 8 ( 2MHz)
	PWM_PRESCALER_PRESCALER_DIV_8 = 0x3
	// Divide by 16 ( 1MHz)
	PWM_PRESCALER_PRESCALER_DIV_16 = 0x4
	// Divide by 32 ( 500kHz)
	PWM_PRESCALER_PRESCALER_DIV_32 = 0x5
	// Divide by 64 ( 250kHz)
	PWM_PRESCALER_PRESCALER_DIV_64 = 0x6
	// Divide by 128 ( 125kHz)
	PWM_PRESCALER_PRESCALER_DIV_128 = 0x7

	// DECODER: Configuration of the decoder
	// Position of LOAD field.
	PWM_DECODER_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	PWM_DECODER_LOAD_Msk = 0x3
	// 1st half word (16-bit) used in all PWM channels 0..3
	PWM_DECODER_LOAD_Common = 0x0
	// 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
	PWM_DECODER_LOAD_Grouped = 0x1
	// 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
	PWM_DECODER_LOAD_Individual = 0x2
	// 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
	PWM_DECODER_LOAD_WaveForm = 0x3
	// Position of MODE field.
	PWM_DECODER_MODE_Pos = 0x8
	// Bit mask of MODE field.
	PWM_DECODER_MODE_Msk = 0x100
	// Bit MODE.
	PWM_DECODER_MODE = 0x100
	// SEQ[n].REFRESH is used to determine loading internal compare registers
	PWM_DECODER_MODE_RefreshCount = 0x0
	// NEXTSTEP task causes a new value to be loaded to internal compare registers
	PWM_DECODER_MODE_NextStep = 0x1

	// LOOP: Amount of playback of a loop
	// Position of CNT field.
	PWM_LOOP_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_LOOP_CNT_Msk = 0xffff
	// Looping disabled (stop at the end of the sequence)
	PWM_LOOP_CNT_Disabled = 0x0

	// SEQ.PTR: Description cluster[0]: Beginning address in Data RAM of this sequence
	// Position of PTR field.
	PWM_SEQ_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	PWM_SEQ_PTR_PTR_Msk = 0xffffffff

	// SEQ.CNT: Description cluster[0]: Amount of values (duty cycles) in this sequence
	// Position of CNT field.
	PWM_SEQ_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SEQ_CNT_CNT_Msk = 0x7fff
	// Sequence is disabled, and shall not be started as it is empty
	PWM_SEQ_CNT_CNT_Disabled = 0x0

	// SEQ.REFRESH: Description cluster[0]: Amount of additional PWM periods between samples loaded into compare register
	// Position of CNT field.
	PWM_SEQ_REFRESH_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SEQ_REFRESH_CNT_Msk = 0xffffff
	// Update every PWM period
	PWM_SEQ_REFRESH_CNT_Continuous = 0x0

	// SEQ.ENDDELAY: Description cluster[0]: Time added after the sequence
	// Position of CNT field.
	PWM_SEQ_ENDDELAY_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SEQ_ENDDELAY_CNT_Msk = 0xffffff

	// PSEL.OUT: Description collection[0]: Output pin select for PWM channel 0
	// Position of PIN field.
	PWM_PSEL_OUT_PIN_Pos = 0x0
	// Bit mask of PIN field.
	PWM_PSEL_OUT_PIN_Msk = 0x1f
	// Position of CONNECT field.
	PWM_PSEL_OUT_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	PWM_PSEL_OUT_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	PWM_PSEL_OUT_CONNECT = 0x80000000
	// Disconnect
	PWM_PSEL_OUT_CONNECT_Disconnected = 0x1
	// Connect
	PWM_PSEL_OUT_CONNECT_Connected = 0x0
)

// Constants for PDM: Pulse Density Modulation (Digital Microphone) Interface
const (
	// INTEN: Enable or disable interrupt
	// Position of STARTED field.
	PDM_INTEN_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	PDM_INTEN_STARTED_Msk = 0x1
	// Bit STARTED.
	PDM_INTEN_STARTED = 0x1
	// Disable
	PDM_INTEN_STARTED_Disabled = 0x0
	// Enable
	PDM_INTEN_STARTED_Enabled = 0x1
	// Position of STOPPED field.
	PDM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PDM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PDM_INTEN_STOPPED = 0x2
	// Disable
	PDM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	PDM_INTEN_STOPPED_Enabled = 0x1
	// Position of END field.
	PDM_INTEN_END_Pos = 0x2
	// Bit mask of END field.
	PDM_INTEN_END_Msk = 0x4
	// Bit END.
	PDM_INTEN_END = 0x4
	// Disable
	PDM_INTEN_END_Disabled = 0x0
	// Enable
	PDM_INTEN_END_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STARTED field.
	PDM_INTENSET_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	PDM_INTENSET_STARTED_Msk = 0x1
	// Bit STARTED.
	PDM_INTENSET_STARTED = 0x1
	// Read: Disabled
	PDM_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENSET_STARTED_Enabled = 0x1
	// Enable
	PDM_INTENSET_STARTED_Set = 0x1
	// Position of STOPPED field.
	PDM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PDM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PDM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	PDM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	PDM_INTENSET_STOPPED_Set = 0x1
	// Position of END field.
	PDM_INTENSET_END_Pos = 0x2
	// Bit mask of END field.
	PDM_INTENSET_END_Msk = 0x4
	// Bit END.
	PDM_INTENSET_END = 0x4
	// Read: Disabled
	PDM_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	PDM_INTENSET_END_Enabled = 0x1
	// Enable
	PDM_INTENSET_END_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STARTED field.
	PDM_INTENCLR_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	PDM_INTENCLR_STARTED_Msk = 0x1
	// Bit STARTED.
	PDM_INTENCLR_STARTED = 0x1
	// Read: Disabled
	PDM_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	PDM_INTENCLR_STARTED_Clear = 0x1
	// Position of STOPPED field.
	PDM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PDM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PDM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	PDM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	PDM_INTENCLR_STOPPED_Clear = 0x1
	// Position of END field.
	PDM_INTENCLR_END_Pos = 0x2
	// Bit mask of END field.
	PDM_INTENCLR_END_Msk = 0x4
	// Bit END.
	PDM_INTENCLR_END = 0x4
	// Read: Disabled
	PDM_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	PDM_INTENCLR_END_Enabled = 0x1
	// Disable
	PDM_INTENCLR_END_Clear = 0x1

	// ENABLE: PDM module enable register
	// Position of ENABLE field.
	PDM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PDM_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PDM_ENABLE_ENABLE = 0x1
	// Disable
	PDM_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	PDM_ENABLE_ENABLE_Enabled = 0x1

	// PDMCLKCTRL: PDM clock generator control
	// Position of FREQ field.
	PDM_PDMCLKCTRL_FREQ_Pos = 0x0
	// Bit mask of FREQ field.
	PDM_PDMCLKCTRL_FREQ_Msk = 0xffffffff
	// PDM_CLK = 32 MHz / 32 = 1.000 MHz
	PDM_PDMCLKCTRL_FREQ_1000K = 0x8000000
	// PDM_CLK = 32 MHz / 31 = 1.032 MHz
	PDM_PDMCLKCTRL_FREQ_Default = 0x8400000
	// PDM_CLK = 32 MHz / 30 = 1.067 MHz
	PDM_PDMCLKCTRL_FREQ_1067K = 0x8800000

	// MODE: Defines the routing of the connected PDM microphones' signals
	// Position of OPERATION field.
	PDM_MODE_OPERATION_Pos = 0x0
	// Bit mask of OPERATION field.
	PDM_MODE_OPERATION_Msk = 0x1
	// Bit OPERATION.
	PDM_MODE_OPERATION = 0x1
	// Sample and store one pair (Left + Right) of 16bit samples per RAM word R=[31:16]; L=[15:0]
	PDM_MODE_OPERATION_Stereo = 0x0
	// Sample and store two successive Left samples (16 bit each) per RAM word L1=[31:16]; L0=[15:0]
	PDM_MODE_OPERATION_Mono = 0x1
	// Position of EDGE field.
	PDM_MODE_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	PDM_MODE_EDGE_Msk = 0x2
	// Bit EDGE.
	PDM_MODE_EDGE = 0x2
	// Left (or mono) is sampled on falling edge of PDM_CLK
	PDM_MODE_EDGE_LeftFalling = 0x0
	// Left (or mono) is sampled on rising edge of PDM_CLK
	PDM_MODE_EDGE_LeftRising = 0x1

	// GAINL: Left output gain adjustment
	// Position of GAINL field.
	PDM_GAINL_GAINL_Pos = 0x0
	// Bit mask of GAINL field.
	PDM_GAINL_GAINL_Msk = 0x7f
	// -20dB gain adjustment (minimum)
	PDM_GAINL_GAINL_MinGain = 0x0
	// 0dB gain adjustment ('2500 RMS' requirement)
	PDM_GAINL_GAINL_DefaultGain = 0x28
	// +20dB gain adjustment (maximum)
	PDM_GAINL_GAINL_MaxGain = 0x50

	// GAINR: Right output gain adjustment
	// Position of GAINR field.
	PDM_GAINR_GAINR_Pos = 0x0
	// Bit mask of GAINR field.
	PDM_GAINR_GAINR_Msk = 0xff
	// -20dB gain adjustment (minimum)
	PDM_GAINR_GAINR_MinGain = 0x0
	// 0dB gain adjustment ('2500 RMS' requirement)
	PDM_GAINR_GAINR_DefaultGain = 0x28
	// +20dB gain adjustment (maximum)
	PDM_GAINR_GAINR_MaxGain = 0x50

	// PSEL.CLK: Pin number configuration for PDM CLK signal
	// Position of PIN field.
	PDM_PSEL_CLK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	PDM_PSEL_CLK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	PDM_PSEL_CLK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	PDM_PSEL_CLK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	PDM_PSEL_CLK_CONNECT = 0x80000000
	// Disconnect
	PDM_PSEL_CLK_CONNECT_Disconnected = 0x1
	// Connect
	PDM_PSEL_CLK_CONNECT_Connected = 0x0

	// PSEL.DIN: Pin number configuration for PDM DIN signal
	// Position of PIN field.
	PDM_PSEL_DIN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	PDM_PSEL_DIN_PIN_Msk = 0x1f
	// Position of CONNECT field.
	PDM_PSEL_DIN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	PDM_PSEL_DIN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	PDM_PSEL_DIN_CONNECT = 0x80000000
	// Disconnect
	PDM_PSEL_DIN_CONNECT_Disconnected = 0x1
	// Connect
	PDM_PSEL_DIN_CONNECT_Connected = 0x0

	// SAMPLE.PTR: RAM address pointer to write samples to with EasyDMA
	// Position of SAMPLEPTR field.
	PDM_SAMPLE_PTR_SAMPLEPTR_Pos = 0x0
	// Bit mask of SAMPLEPTR field.
	PDM_SAMPLE_PTR_SAMPLEPTR_Msk = 0xffffffff

	// SAMPLE.MAXCNT: Number of samples to allocate memory for in EasyDMA mode
	// Position of BUFFSIZE field.
	PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos = 0x0
	// Bit mask of BUFFSIZE field.
	PDM_SAMPLE_MAXCNT_BUFFSIZE_Msk = 0x7fff
)

// Constants for NVMC: Non Volatile Memory Controller
const (
	// READY: Ready flag
	// Position of READY field.
	NVMC_READY_READY_Pos = 0x0
	// Bit mask of READY field.
	NVMC_READY_READY_Msk = 0x1
	// Bit READY.
	NVMC_READY_READY = 0x1
	// NVMC is busy (on-going write or erase operation)
	NVMC_READY_READY_Busy = 0x0
	// NVMC is ready
	NVMC_READY_READY_Ready = 0x1

	// CONFIG: Configuration register
	// Position of WEN field.
	NVMC_CONFIG_WEN_Pos = 0x0
	// Bit mask of WEN field.
	NVMC_CONFIG_WEN_Msk = 0x3
	// Read only access
	NVMC_CONFIG_WEN_Ren = 0x0
	// Write Enabled
	NVMC_CONFIG_WEN_Wen = 0x1
	// Erase enabled
	NVMC_CONFIG_WEN_Een = 0x2

	// ERASEPAGE: Register for erasing a page in Code area
	// Position of ERASEPAGE field.
	NVMC_ERASEPAGE_ERASEPAGE_Pos = 0x0
	// Bit mask of ERASEPAGE field.
	NVMC_ERASEPAGE_ERASEPAGE_Msk = 0xffffffff

	// ERASEPCR1: Deprecated register - Register for erasing a page in Code area. Equivalent to ERASEPAGE.
	// Position of ERASEPCR1 field.
	NVMC_ERASEPCR1_ERASEPCR1_Pos = 0x0
	// Bit mask of ERASEPCR1 field.
	NVMC_ERASEPCR1_ERASEPCR1_Msk = 0xffffffff

	// ERASEALL: Register for erasing all non-volatile user memory
	// Position of ERASEALL field.
	NVMC_ERASEALL_ERASEALL_Pos = 0x0
	// Bit mask of ERASEALL field.
	NVMC_ERASEALL_ERASEALL_Msk = 0x1
	// Bit ERASEALL.
	NVMC_ERASEALL_ERASEALL = 0x1
	// No operation
	NVMC_ERASEALL_ERASEALL_NoOperation = 0x0
	// Start chip erase
	NVMC_ERASEALL_ERASEALL_Erase = 0x1

	// ERASEPCR0: Deprecated register - Register for erasing a page in Code area. Equivalent to ERASEPAGE.
	// Position of ERASEPCR0 field.
	NVMC_ERASEPCR0_ERASEPCR0_Pos = 0x0
	// Bit mask of ERASEPCR0 field.
	NVMC_ERASEPCR0_ERASEPCR0_Msk = 0xffffffff

	// ERASEUICR: Register for erasing User Information Configuration Registers
	// Position of ERASEUICR field.
	NVMC_ERASEUICR_ERASEUICR_Pos = 0x0
	// Bit mask of ERASEUICR field.
	NVMC_ERASEUICR_ERASEUICR_Msk = 0x1
	// Bit ERASEUICR.
	NVMC_ERASEUICR_ERASEUICR = 0x1
	// No operation
	NVMC_ERASEUICR_ERASEUICR_NoOperation = 0x0
	// Start erase of UICR
	NVMC_ERASEUICR_ERASEUICR_Erase = 0x1

	// ICACHECNF: I-Code cache configuration register.
	// Position of CACHEEN field.
	NVMC_ICACHECNF_CACHEEN_Pos = 0x0
	// Bit mask of CACHEEN field.
	NVMC_ICACHECNF_CACHEEN_Msk = 0x1
	// Bit CACHEEN.
	NVMC_ICACHECNF_CACHEEN = 0x1
	// Disable cache. Invalidates all cache entries.
	NVMC_ICACHECNF_CACHEEN_Disabled = 0x0
	// Enable cache
	NVMC_ICACHECNF_CACHEEN_Enabled = 0x1
	// Position of CACHEPROFEN field.
	NVMC_ICACHECNF_CACHEPROFEN_Pos = 0x8
	// Bit mask of CACHEPROFEN field.
	NVMC_ICACHECNF_CACHEPROFEN_Msk = 0x100
	// Bit CACHEPROFEN.
	NVMC_ICACHECNF_CACHEPROFEN = 0x100
	// Disable cache profiling
	NVMC_ICACHECNF_CACHEPROFEN_Disabled = 0x0
	// Enable cache profiling
	NVMC_ICACHECNF_CACHEPROFEN_Enabled = 0x1

	// IHIT: I-Code cache hit counter.
	// Position of HITS field.
	NVMC_IHIT_HITS_Pos = 0x0
	// Bit mask of HITS field.
	NVMC_IHIT_HITS_Msk = 0xffffffff

	// IMISS: I-Code cache miss counter.
	// Position of MISSES field.
	NVMC_IMISS_MISSES_Pos = 0x0
	// Bit mask of MISSES field.
	NVMC_IMISS_MISSES_Msk = 0xffffffff
)

// Constants for PPI: Programmable Peripheral Interconnect
const (
	// TASKS_CHG.EN: Description cluster[0]: Enable channel group 0

	// TASKS_CHG.DIS: Description cluster[0]: Disable channel group 0

	// CHEN: Channel enable register
	// Position of CH0 field.
	PPI_CHEN_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHEN_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHEN_CH0 = 0x1
	// Disable channel
	PPI_CHEN_CH0_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH0_Enabled = 0x1
	// Position of CH1 field.
	PPI_CHEN_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHEN_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHEN_CH1 = 0x2
	// Disable channel
	PPI_CHEN_CH1_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH1_Enabled = 0x1
	// Position of CH2 field.
	PPI_CHEN_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHEN_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHEN_CH2 = 0x4
	// Disable channel
	PPI_CHEN_CH2_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH2_Enabled = 0x1
	// Position of CH3 field.
	PPI_CHEN_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHEN_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHEN_CH3 = 0x8
	// Disable channel
	PPI_CHEN_CH3_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH3_Enabled = 0x1
	// Position of CH4 field.
	PPI_CHEN_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHEN_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHEN_CH4 = 0x10
	// Disable channel
	PPI_CHEN_CH4_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH4_Enabled = 0x1
	// Position of CH5 field.
	PPI_CHEN_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHEN_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHEN_CH5 = 0x20
	// Disable channel
	PPI_CHEN_CH5_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH5_Enabled = 0x1
	// Position of CH6 field.
	PPI_CHEN_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHEN_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHEN_CH6 = 0x40
	// Disable channel
	PPI_CHEN_CH6_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH6_Enabled = 0x1
	// Position of CH7 field.
	PPI_CHEN_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHEN_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHEN_CH7 = 0x80
	// Disable channel
	PPI_CHEN_CH7_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH7_Enabled = 0x1
	// Position of CH8 field.
	PPI_CHEN_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHEN_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHEN_CH8 = 0x100
	// Disable channel
	PPI_CHEN_CH8_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH8_Enabled = 0x1
	// Position of CH9 field.
	PPI_CHEN_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHEN_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHEN_CH9 = 0x200
	// Disable channel
	PPI_CHEN_CH9_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH9_Enabled = 0x1
	// Position of CH10 field.
	PPI_CHEN_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHEN_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHEN_CH10 = 0x400
	// Disable channel
	PPI_CHEN_CH10_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH10_Enabled = 0x1
	// Position of CH11 field.
	PPI_CHEN_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHEN_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHEN_CH11 = 0x800
	// Disable channel
	PPI_CHEN_CH11_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH11_Enabled = 0x1
	// Position of CH12 field.
	PPI_CHEN_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHEN_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHEN_CH12 = 0x1000
	// Disable channel
	PPI_CHEN_CH12_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH12_Enabled = 0x1
	// Position of CH13 field.
	PPI_CHEN_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHEN_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHEN_CH13 = 0x2000
	// Disable channel
	PPI_CHEN_CH13_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH13_Enabled = 0x1
	// Position of CH14 field.
	PPI_CHEN_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHEN_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHEN_CH14 = 0x4000
	// Disable channel
	PPI_CHEN_CH14_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH14_Enabled = 0x1
	// Position of CH15 field.
	PPI_CHEN_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHEN_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHEN_CH15 = 0x8000
	// Disable channel
	PPI_CHEN_CH15_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH15_Enabled = 0x1
	// Position of CH16 field.
	PPI_CHEN_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHEN_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHEN_CH16 = 0x10000
	// Disable channel
	PPI_CHEN_CH16_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH16_Enabled = 0x1
	// Position of CH17 field.
	PPI_CHEN_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHEN_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHEN_CH17 = 0x20000
	// Disable channel
	PPI_CHEN_CH17_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH17_Enabled = 0x1
	// Position of CH18 field.
	PPI_CHEN_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHEN_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHEN_CH18 = 0x40000
	// Disable channel
	PPI_CHEN_CH18_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH18_Enabled = 0x1
	// Position of CH19 field.
	PPI_CHEN_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHEN_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHEN_CH19 = 0x80000
	// Disable channel
	PPI_CHEN_CH19_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH19_Enabled = 0x1
	// Position of CH20 field.
	PPI_CHEN_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHEN_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHEN_CH20 = 0x100000
	// Disable channel
	PPI_CHEN_CH20_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH20_Enabled = 0x1
	// Position of CH21 field.
	PPI_CHEN_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHEN_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHEN_CH21 = 0x200000
	// Disable channel
	PPI_CHEN_CH21_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH21_Enabled = 0x1
	// Position of CH22 field.
	PPI_CHEN_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHEN_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHEN_CH22 = 0x400000
	// Disable channel
	PPI_CHEN_CH22_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH22_Enabled = 0x1
	// Position of CH23 field.
	PPI_CHEN_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHEN_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHEN_CH23 = 0x800000
	// Disable channel
	PPI_CHEN_CH23_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH23_Enabled = 0x1
	// Position of CH24 field.
	PPI_CHEN_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHEN_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHEN_CH24 = 0x1000000
	// Disable channel
	PPI_CHEN_CH24_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH24_Enabled = 0x1
	// Position of CH25 field.
	PPI_CHEN_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHEN_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHEN_CH25 = 0x2000000
	// Disable channel
	PPI_CHEN_CH25_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH25_Enabled = 0x1
	// Position of CH26 field.
	PPI_CHEN_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHEN_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHEN_CH26 = 0x4000000
	// Disable channel
	PPI_CHEN_CH26_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH26_Enabled = 0x1
	// Position of CH27 field.
	PPI_CHEN_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHEN_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHEN_CH27 = 0x8000000
	// Disable channel
	PPI_CHEN_CH27_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH27_Enabled = 0x1
	// Position of CH28 field.
	PPI_CHEN_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHEN_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHEN_CH28 = 0x10000000
	// Disable channel
	PPI_CHEN_CH28_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH28_Enabled = 0x1
	// Position of CH29 field.
	PPI_CHEN_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHEN_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHEN_CH29 = 0x20000000
	// Disable channel
	PPI_CHEN_CH29_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH29_Enabled = 0x1
	// Position of CH30 field.
	PPI_CHEN_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHEN_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHEN_CH30 = 0x40000000
	// Disable channel
	PPI_CHEN_CH30_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH30_Enabled = 0x1
	// Position of CH31 field.
	PPI_CHEN_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHEN_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHEN_CH31 = 0x80000000
	// Disable channel
	PPI_CHEN_CH31_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH31_Enabled = 0x1

	// CHENSET: Channel enable set register
	// Position of CH0 field.
	PPI_CHENSET_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHENSET_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHENSET_CH0 = 0x1
	// Read: channel disabled
	PPI_CHENSET_CH0_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH0_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH0_Set = 0x1
	// Position of CH1 field.
	PPI_CHENSET_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHENSET_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHENSET_CH1 = 0x2
	// Read: channel disabled
	PPI_CHENSET_CH1_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH1_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH1_Set = 0x1
	// Position of CH2 field.
	PPI_CHENSET_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHENSET_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHENSET_CH2 = 0x4
	// Read: channel disabled
	PPI_CHENSET_CH2_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH2_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH2_Set = 0x1
	// Position of CH3 field.
	PPI_CHENSET_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHENSET_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHENSET_CH3 = 0x8
	// Read: channel disabled
	PPI_CHENSET_CH3_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH3_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH3_Set = 0x1
	// Position of CH4 field.
	PPI_CHENSET_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHENSET_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHENSET_CH4 = 0x10
	// Read: channel disabled
	PPI_CHENSET_CH4_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH4_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH4_Set = 0x1
	// Position of CH5 field.
	PPI_CHENSET_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHENSET_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHENSET_CH5 = 0x20
	// Read: channel disabled
	PPI_CHENSET_CH5_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH5_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH5_Set = 0x1
	// Position of CH6 field.
	PPI_CHENSET_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHENSET_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHENSET_CH6 = 0x40
	// Read: channel disabled
	PPI_CHENSET_CH6_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH6_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH6_Set = 0x1
	// Position of CH7 field.
	PPI_CHENSET_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHENSET_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHENSET_CH7 = 0x80
	// Read: channel disabled
	PPI_CHENSET_CH7_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH7_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH7_Set = 0x1
	// Position of CH8 field.
	PPI_CHENSET_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHENSET_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHENSET_CH8 = 0x100
	// Read: channel disabled
	PPI_CHENSET_CH8_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH8_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH8_Set = 0x1
	// Position of CH9 field.
	PPI_CHENSET_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHENSET_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHENSET_CH9 = 0x200
	// Read: channel disabled
	PPI_CHENSET_CH9_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH9_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH9_Set = 0x1
	// Position of CH10 field.
	PPI_CHENSET_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHENSET_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHENSET_CH10 = 0x400
	// Read: channel disabled
	PPI_CHENSET_CH10_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH10_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH10_Set = 0x1
	// Position of CH11 field.
	PPI_CHENSET_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHENSET_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHENSET_CH11 = 0x800
	// Read: channel disabled
	PPI_CHENSET_CH11_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH11_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH11_Set = 0x1
	// Position of CH12 field.
	PPI_CHENSET_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHENSET_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHENSET_CH12 = 0x1000
	// Read: channel disabled
	PPI_CHENSET_CH12_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH12_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH12_Set = 0x1
	// Position of CH13 field.
	PPI_CHENSET_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHENSET_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHENSET_CH13 = 0x2000
	// Read: channel disabled
	PPI_CHENSET_CH13_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH13_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH13_Set = 0x1
	// Position of CH14 field.
	PPI_CHENSET_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHENSET_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHENSET_CH14 = 0x4000
	// Read: channel disabled
	PPI_CHENSET_CH14_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH14_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH14_Set = 0x1
	// Position of CH15 field.
	PPI_CHENSET_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHENSET_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHENSET_CH15 = 0x8000
	// Read: channel disabled
	PPI_CHENSET_CH15_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH15_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH15_Set = 0x1
	// Position of CH16 field.
	PPI_CHENSET_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHENSET_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHENSET_CH16 = 0x10000
	// Read: channel disabled
	PPI_CHENSET_CH16_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH16_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH16_Set = 0x1
	// Position of CH17 field.
	PPI_CHENSET_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHENSET_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHENSET_CH17 = 0x20000
	// Read: channel disabled
	PPI_CHENSET_CH17_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH17_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH17_Set = 0x1
	// Position of CH18 field.
	PPI_CHENSET_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHENSET_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHENSET_CH18 = 0x40000
	// Read: channel disabled
	PPI_CHENSET_CH18_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH18_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH18_Set = 0x1
	// Position of CH19 field.
	PPI_CHENSET_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHENSET_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHENSET_CH19 = 0x80000
	// Read: channel disabled
	PPI_CHENSET_CH19_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH19_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH19_Set = 0x1
	// Position of CH20 field.
	PPI_CHENSET_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHENSET_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHENSET_CH20 = 0x100000
	// Read: channel disabled
	PPI_CHENSET_CH20_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH20_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH20_Set = 0x1
	// Position of CH21 field.
	PPI_CHENSET_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHENSET_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHENSET_CH21 = 0x200000
	// Read: channel disabled
	PPI_CHENSET_CH21_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH21_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH21_Set = 0x1
	// Position of CH22 field.
	PPI_CHENSET_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHENSET_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHENSET_CH22 = 0x400000
	// Read: channel disabled
	PPI_CHENSET_CH22_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH22_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH22_Set = 0x1
	// Position of CH23 field.
	PPI_CHENSET_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHENSET_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHENSET_CH23 = 0x800000
	// Read: channel disabled
	PPI_CHENSET_CH23_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH23_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH23_Set = 0x1
	// Position of CH24 field.
	PPI_CHENSET_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHENSET_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHENSET_CH24 = 0x1000000
	// Read: channel disabled
	PPI_CHENSET_CH24_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH24_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH24_Set = 0x1
	// Position of CH25 field.
	PPI_CHENSET_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHENSET_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHENSET_CH25 = 0x2000000
	// Read: channel disabled
	PPI_CHENSET_CH25_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH25_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH25_Set = 0x1
	// Position of CH26 field.
	PPI_CHENSET_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHENSET_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHENSET_CH26 = 0x4000000
	// Read: channel disabled
	PPI_CHENSET_CH26_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH26_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH26_Set = 0x1
	// Position of CH27 field.
	PPI_CHENSET_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHENSET_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHENSET_CH27 = 0x8000000
	// Read: channel disabled
	PPI_CHENSET_CH27_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH27_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH27_Set = 0x1
	// Position of CH28 field.
	PPI_CHENSET_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHENSET_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHENSET_CH28 = 0x10000000
	// Read: channel disabled
	PPI_CHENSET_CH28_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH28_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH28_Set = 0x1
	// Position of CH29 field.
	PPI_CHENSET_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHENSET_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHENSET_CH29 = 0x20000000
	// Read: channel disabled
	PPI_CHENSET_CH29_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH29_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH29_Set = 0x1
	// Position of CH30 field.
	PPI_CHENSET_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHENSET_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHENSET_CH30 = 0x40000000
	// Read: channel disabled
	PPI_CHENSET_CH30_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH30_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH30_Set = 0x1
	// Position of CH31 field.
	PPI_CHENSET_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHENSET_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHENSET_CH31 = 0x80000000
	// Read: channel disabled
	PPI_CHENSET_CH31_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH31_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH31_Set = 0x1

	// CHENCLR: Channel enable clear register
	// Position of CH0 field.
	PPI_CHENCLR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHENCLR_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHENCLR_CH0 = 0x1
	// Read: channel disabled
	PPI_CHENCLR_CH0_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH0_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH0_Clear = 0x1
	// Position of CH1 field.
	PPI_CHENCLR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHENCLR_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHENCLR_CH1 = 0x2
	// Read: channel disabled
	PPI_CHENCLR_CH1_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH1_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH1_Clear = 0x1
	// Position of CH2 field.
	PPI_CHENCLR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHENCLR_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHENCLR_CH2 = 0x4
	// Read: channel disabled
	PPI_CHENCLR_CH2_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH2_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH2_Clear = 0x1
	// Position of CH3 field.
	PPI_CHENCLR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHENCLR_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHENCLR_CH3 = 0x8
	// Read: channel disabled
	PPI_CHENCLR_CH3_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH3_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH3_Clear = 0x1
	// Position of CH4 field.
	PPI_CHENCLR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHENCLR_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHENCLR_CH4 = 0x10
	// Read: channel disabled
	PPI_CHENCLR_CH4_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH4_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH4_Clear = 0x1
	// Position of CH5 field.
	PPI_CHENCLR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHENCLR_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHENCLR_CH5 = 0x20
	// Read: channel disabled
	PPI_CHENCLR_CH5_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH5_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH5_Clear = 0x1
	// Position of CH6 field.
	PPI_CHENCLR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHENCLR_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHENCLR_CH6 = 0x40
	// Read: channel disabled
	PPI_CHENCLR_CH6_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH6_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH6_Clear = 0x1
	// Position of CH7 field.
	PPI_CHENCLR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHENCLR_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHENCLR_CH7 = 0x80
	// Read: channel disabled
	PPI_CHENCLR_CH7_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH7_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH7_Clear = 0x1
	// Position of CH8 field.
	PPI_CHENCLR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHENCLR_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHENCLR_CH8 = 0x100
	// Read: channel disabled
	PPI_CHENCLR_CH8_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH8_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH8_Clear = 0x1
	// Position of CH9 field.
	PPI_CHENCLR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHENCLR_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHENCLR_CH9 = 0x200
	// Read: channel disabled
	PPI_CHENCLR_CH9_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH9_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH9_Clear = 0x1
	// Position of CH10 field.
	PPI_CHENCLR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHENCLR_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHENCLR_CH10 = 0x400
	// Read: channel disabled
	PPI_CHENCLR_CH10_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH10_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH10_Clear = 0x1
	// Position of CH11 field.
	PPI_CHENCLR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHENCLR_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHENCLR_CH11 = 0x800
	// Read: channel disabled
	PPI_CHENCLR_CH11_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH11_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH11_Clear = 0x1
	// Position of CH12 field.
	PPI_CHENCLR_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHENCLR_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHENCLR_CH12 = 0x1000
	// Read: channel disabled
	PPI_CHENCLR_CH12_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH12_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH12_Clear = 0x1
	// Position of CH13 field.
	PPI_CHENCLR_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHENCLR_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHENCLR_CH13 = 0x2000
	// Read: channel disabled
	PPI_CHENCLR_CH13_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH13_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH13_Clear = 0x1
	// Position of CH14 field.
	PPI_CHENCLR_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHENCLR_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHENCLR_CH14 = 0x4000
	// Read: channel disabled
	PPI_CHENCLR_CH14_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH14_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH14_Clear = 0x1
	// Position of CH15 field.
	PPI_CHENCLR_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHENCLR_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHENCLR_CH15 = 0x8000
	// Read: channel disabled
	PPI_CHENCLR_CH15_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH15_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH15_Clear = 0x1
	// Position of CH16 field.
	PPI_CHENCLR_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHENCLR_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHENCLR_CH16 = 0x10000
	// Read: channel disabled
	PPI_CHENCLR_CH16_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH16_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH16_Clear = 0x1
	// Position of CH17 field.
	PPI_CHENCLR_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHENCLR_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHENCLR_CH17 = 0x20000
	// Read: channel disabled
	PPI_CHENCLR_CH17_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH17_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH17_Clear = 0x1
	// Position of CH18 field.
	PPI_CHENCLR_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHENCLR_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHENCLR_CH18 = 0x40000
	// Read: channel disabled
	PPI_CHENCLR_CH18_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH18_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH18_Clear = 0x1
	// Position of CH19 field.
	PPI_CHENCLR_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHENCLR_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHENCLR_CH19 = 0x80000
	// Read: channel disabled
	PPI_CHENCLR_CH19_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH19_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH19_Clear = 0x1
	// Position of CH20 field.
	PPI_CHENCLR_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHENCLR_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHENCLR_CH20 = 0x100000
	// Read: channel disabled
	PPI_CHENCLR_CH20_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH20_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH20_Clear = 0x1
	// Position of CH21 field.
	PPI_CHENCLR_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHENCLR_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHENCLR_CH21 = 0x200000
	// Read: channel disabled
	PPI_CHENCLR_CH21_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH21_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH21_Clear = 0x1
	// Position of CH22 field.
	PPI_CHENCLR_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHENCLR_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHENCLR_CH22 = 0x400000
	// Read: channel disabled
	PPI_CHENCLR_CH22_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH22_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH22_Clear = 0x1
	// Position of CH23 field.
	PPI_CHENCLR_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHENCLR_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHENCLR_CH23 = 0x800000
	// Read: channel disabled
	PPI_CHENCLR_CH23_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH23_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH23_Clear = 0x1
	// Position of CH24 field.
	PPI_CHENCLR_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHENCLR_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHENCLR_CH24 = 0x1000000
	// Read: channel disabled
	PPI_CHENCLR_CH24_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH24_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH24_Clear = 0x1
	// Position of CH25 field.
	PPI_CHENCLR_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHENCLR_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHENCLR_CH25 = 0x2000000
	// Read: channel disabled
	PPI_CHENCLR_CH25_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH25_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH25_Clear = 0x1
	// Position of CH26 field.
	PPI_CHENCLR_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHENCLR_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHENCLR_CH26 = 0x4000000
	// Read: channel disabled
	PPI_CHENCLR_CH26_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH26_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH26_Clear = 0x1
	// Position of CH27 field.
	PPI_CHENCLR_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHENCLR_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHENCLR_CH27 = 0x8000000
	// Read: channel disabled
	PPI_CHENCLR_CH27_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH27_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH27_Clear = 0x1
	// Position of CH28 field.
	PPI_CHENCLR_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHENCLR_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHENCLR_CH28 = 0x10000000
	// Read: channel disabled
	PPI_CHENCLR_CH28_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH28_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH28_Clear = 0x1
	// Position of CH29 field.
	PPI_CHENCLR_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHENCLR_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHENCLR_CH29 = 0x20000000
	// Read: channel disabled
	PPI_CHENCLR_CH29_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH29_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH29_Clear = 0x1
	// Position of CH30 field.
	PPI_CHENCLR_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHENCLR_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHENCLR_CH30 = 0x40000000
	// Read: channel disabled
	PPI_CHENCLR_CH30_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH30_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH30_Clear = 0x1
	// Position of CH31 field.
	PPI_CHENCLR_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHENCLR_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHENCLR_CH31 = 0x80000000
	// Read: channel disabled
	PPI_CHENCLR_CH31_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH31_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH31_Clear = 0x1

	// CH.EEP: Description cluster[0]: Channel 0 event end-point
	// Position of EEP field.
	PPI_CH_EEP_EEP_Pos = 0x0
	// Bit mask of EEP field.
	PPI_CH_EEP_EEP_Msk = 0xffffffff

	// CH.TEP: Description cluster[0]: Channel 0 task end-point
	// Position of TEP field.
	PPI_CH_TEP_TEP_Pos = 0x0
	// Bit mask of TEP field.
	PPI_CH_TEP_TEP_Msk = 0xffffffff

	// CHG: Description collection[0]: Channel group 0
	// Position of CH0 field.
	PPI_CHG_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHG_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHG_CH0 = 0x1
	// Exclude
	PPI_CHG_CH0_Excluded = 0x0
	// Include
	PPI_CHG_CH0_Included = 0x1
	// Position of CH1 field.
	PPI_CHG_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHG_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHG_CH1 = 0x2
	// Exclude
	PPI_CHG_CH1_Excluded = 0x0
	// Include
	PPI_CHG_CH1_Included = 0x1
	// Position of CH2 field.
	PPI_CHG_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHG_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHG_CH2 = 0x4
	// Exclude
	PPI_CHG_CH2_Excluded = 0x0
	// Include
	PPI_CHG_CH2_Included = 0x1
	// Position of CH3 field.
	PPI_CHG_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHG_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHG_CH3 = 0x8
	// Exclude
	PPI_CHG_CH3_Excluded = 0x0
	// Include
	PPI_CHG_CH3_Included = 0x1
	// Position of CH4 field.
	PPI_CHG_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHG_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHG_CH4 = 0x10
	// Exclude
	PPI_CHG_CH4_Excluded = 0x0
	// Include
	PPI_CHG_CH4_Included = 0x1
	// Position of CH5 field.
	PPI_CHG_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHG_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHG_CH5 = 0x20
	// Exclude
	PPI_CHG_CH5_Excluded = 0x0
	// Include
	PPI_CHG_CH5_Included = 0x1
	// Position of CH6 field.
	PPI_CHG_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHG_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHG_CH6 = 0x40
	// Exclude
	PPI_CHG_CH6_Excluded = 0x0
	// Include
	PPI_CHG_CH6_Included = 0x1
	// Position of CH7 field.
	PPI_CHG_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHG_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHG_CH7 = 0x80
	// Exclude
	PPI_CHG_CH7_Excluded = 0x0
	// Include
	PPI_CHG_CH7_Included = 0x1
	// Position of CH8 field.
	PPI_CHG_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHG_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHG_CH8 = 0x100
	// Exclude
	PPI_CHG_CH8_Excluded = 0x0
	// Include
	PPI_CHG_CH8_Included = 0x1
	// Position of CH9 field.
	PPI_CHG_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHG_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHG_CH9 = 0x200
	// Exclude
	PPI_CHG_CH9_Excluded = 0x0
	// Include
	PPI_CHG_CH9_Included = 0x1
	// Position of CH10 field.
	PPI_CHG_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHG_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHG_CH10 = 0x400
	// Exclude
	PPI_CHG_CH10_Excluded = 0x0
	// Include
	PPI_CHG_CH10_Included = 0x1
	// Position of CH11 field.
	PPI_CHG_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHG_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHG_CH11 = 0x800
	// Exclude
	PPI_CHG_CH11_Excluded = 0x0
	// Include
	PPI_CHG_CH11_Included = 0x1
	// Position of CH12 field.
	PPI_CHG_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHG_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHG_CH12 = 0x1000
	// Exclude
	PPI_CHG_CH12_Excluded = 0x0
	// Include
	PPI_CHG_CH12_Included = 0x1
	// Position of CH13 field.
	PPI_CHG_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHG_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHG_CH13 = 0x2000
	// Exclude
	PPI_CHG_CH13_Excluded = 0x0
	// Include
	PPI_CHG_CH13_Included = 0x1
	// Position of CH14 field.
	PPI_CHG_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHG_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHG_CH14 = 0x4000
	// Exclude
	PPI_CHG_CH14_Excluded = 0x0
	// Include
	PPI_CHG_CH14_Included = 0x1
	// Position of CH15 field.
	PPI_CHG_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHG_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHG_CH15 = 0x8000
	// Exclude
	PPI_CHG_CH15_Excluded = 0x0
	// Include
	PPI_CHG_CH15_Included = 0x1
	// Position of CH16 field.
	PPI_CHG_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHG_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHG_CH16 = 0x10000
	// Exclude
	PPI_CHG_CH16_Excluded = 0x0
	// Include
	PPI_CHG_CH16_Included = 0x1
	// Position of CH17 field.
	PPI_CHG_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHG_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHG_CH17 = 0x20000
	// Exclude
	PPI_CHG_CH17_Excluded = 0x0
	// Include
	PPI_CHG_CH17_Included = 0x1
	// Position of CH18 field.
	PPI_CHG_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHG_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHG_CH18 = 0x40000
	// Exclude
	PPI_CHG_CH18_Excluded = 0x0
	// Include
	PPI_CHG_CH18_Included = 0x1
	// Position of CH19 field.
	PPI_CHG_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHG_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHG_CH19 = 0x80000
	// Exclude
	PPI_CHG_CH19_Excluded = 0x0
	// Include
	PPI_CHG_CH19_Included = 0x1
	// Position of CH20 field.
	PPI_CHG_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHG_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHG_CH20 = 0x100000
	// Exclude
	PPI_CHG_CH20_Excluded = 0x0
	// Include
	PPI_CHG_CH20_Included = 0x1
	// Position of CH21 field.
	PPI_CHG_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHG_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHG_CH21 = 0x200000
	// Exclude
	PPI_CHG_CH21_Excluded = 0x0
	// Include
	PPI_CHG_CH21_Included = 0x1
	// Position of CH22 field.
	PPI_CHG_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHG_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHG_CH22 = 0x400000
	// Exclude
	PPI_CHG_CH22_Excluded = 0x0
	// Include
	PPI_CHG_CH22_Included = 0x1
	// Position of CH23 field.
	PPI_CHG_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHG_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHG_CH23 = 0x800000
	// Exclude
	PPI_CHG_CH23_Excluded = 0x0
	// Include
	PPI_CHG_CH23_Included = 0x1
	// Position of CH24 field.
	PPI_CHG_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHG_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHG_CH24 = 0x1000000
	// Exclude
	PPI_CHG_CH24_Excluded = 0x0
	// Include
	PPI_CHG_CH24_Included = 0x1
	// Position of CH25 field.
	PPI_CHG_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHG_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHG_CH25 = 0x2000000
	// Exclude
	PPI_CHG_CH25_Excluded = 0x0
	// Include
	PPI_CHG_CH25_Included = 0x1
	// Position of CH26 field.
	PPI_CHG_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHG_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHG_CH26 = 0x4000000
	// Exclude
	PPI_CHG_CH26_Excluded = 0x0
	// Include
	PPI_CHG_CH26_Included = 0x1
	// Position of CH27 field.
	PPI_CHG_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHG_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHG_CH27 = 0x8000000
	// Exclude
	PPI_CHG_CH27_Excluded = 0x0
	// Include
	PPI_CHG_CH27_Included = 0x1
	// Position of CH28 field.
	PPI_CHG_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHG_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHG_CH28 = 0x10000000
	// Exclude
	PPI_CHG_CH28_Excluded = 0x0
	// Include
	PPI_CHG_CH28_Included = 0x1
	// Position of CH29 field.
	PPI_CHG_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHG_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHG_CH29 = 0x20000000
	// Exclude
	PPI_CHG_CH29_Excluded = 0x0
	// Include
	PPI_CHG_CH29_Included = 0x1
	// Position of CH30 field.
	PPI_CHG_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHG_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHG_CH30 = 0x40000000
	// Exclude
	PPI_CHG_CH30_Excluded = 0x0
	// Include
	PPI_CHG_CH30_Included = 0x1
	// Position of CH31 field.
	PPI_CHG_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHG_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHG_CH31 = 0x80000000
	// Exclude
	PPI_CHG_CH31_Excluded = 0x0
	// Include
	PPI_CHG_CH31_Included = 0x1

	// FORK.TEP: Description cluster[0]: Channel 0 task end-point
	// Position of TEP field.
	PPI_FORK_TEP_TEP_Pos = 0x0
	// Bit mask of TEP field.
	PPI_FORK_TEP_TEP_Msk = 0xffffffff
)

// Constants for MWU: Memory Watch Unit
const (
	// EVENTS_REGION.WA: Description cluster[0]: Write access to region 0 detected

	// EVENTS_REGION.RA: Description cluster[0]: Read access to region 0 detected

	// EVENTS_PREGION.WA: Description cluster[0]: Write access to peripheral region 0 detected

	// EVENTS_PREGION.RA: Description cluster[0]: Read access to peripheral region 0 detected

	// INTEN: Enable or disable interrupt
	// Position of REGION0WA field.
	MWU_INTEN_REGION0WA_Pos = 0x0
	// Bit mask of REGION0WA field.
	MWU_INTEN_REGION0WA_Msk = 0x1
	// Bit REGION0WA.
	MWU_INTEN_REGION0WA = 0x1
	// Disable
	MWU_INTEN_REGION0WA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION0WA_Enabled = 0x1
	// Position of REGION0RA field.
	MWU_INTEN_REGION0RA_Pos = 0x1
	// Bit mask of REGION0RA field.
	MWU_INTEN_REGION0RA_Msk = 0x2
	// Bit REGION0RA.
	MWU_INTEN_REGION0RA = 0x2
	// Disable
	MWU_INTEN_REGION0RA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION0RA_Enabled = 0x1
	// Position of REGION1WA field.
	MWU_INTEN_REGION1WA_Pos = 0x2
	// Bit mask of REGION1WA field.
	MWU_INTEN_REGION1WA_Msk = 0x4
	// Bit REGION1WA.
	MWU_INTEN_REGION1WA = 0x4
	// Disable
	MWU_INTEN_REGION1WA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION1WA_Enabled = 0x1
	// Position of REGION1RA field.
	MWU_INTEN_REGION1RA_Pos = 0x3
	// Bit mask of REGION1RA field.
	MWU_INTEN_REGION1RA_Msk = 0x8
	// Bit REGION1RA.
	MWU_INTEN_REGION1RA = 0x8
	// Disable
	MWU_INTEN_REGION1RA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION1RA_Enabled = 0x1
	// Position of REGION2WA field.
	MWU_INTEN_REGION2WA_Pos = 0x4
	// Bit mask of REGION2WA field.
	MWU_INTEN_REGION2WA_Msk = 0x10
	// Bit REGION2WA.
	MWU_INTEN_REGION2WA = 0x10
	// Disable
	MWU_INTEN_REGION2WA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION2WA_Enabled = 0x1
	// Position of REGION2RA field.
	MWU_INTEN_REGION2RA_Pos = 0x5
	// Bit mask of REGION2RA field.
	MWU_INTEN_REGION2RA_Msk = 0x20
	// Bit REGION2RA.
	MWU_INTEN_REGION2RA = 0x20
	// Disable
	MWU_INTEN_REGION2RA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION2RA_Enabled = 0x1
	// Position of REGION3WA field.
	MWU_INTEN_REGION3WA_Pos = 0x6
	// Bit mask of REGION3WA field.
	MWU_INTEN_REGION3WA_Msk = 0x40
	// Bit REGION3WA.
	MWU_INTEN_REGION3WA = 0x40
	// Disable
	MWU_INTEN_REGION3WA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION3WA_Enabled = 0x1
	// Position of REGION3RA field.
	MWU_INTEN_REGION3RA_Pos = 0x7
	// Bit mask of REGION3RA field.
	MWU_INTEN_REGION3RA_Msk = 0x80
	// Bit REGION3RA.
	MWU_INTEN_REGION3RA = 0x80
	// Disable
	MWU_INTEN_REGION3RA_Disabled = 0x0
	// Enable
	MWU_INTEN_REGION3RA_Enabled = 0x1
	// Position of PREGION0WA field.
	MWU_INTEN_PREGION0WA_Pos = 0x18
	// Bit mask of PREGION0WA field.
	MWU_INTEN_PREGION0WA_Msk = 0x1000000
	// Bit PREGION0WA.
	MWU_INTEN_PREGION0WA = 0x1000000
	// Disable
	MWU_INTEN_PREGION0WA_Disabled = 0x0
	// Enable
	MWU_INTEN_PREGION0WA_Enabled = 0x1
	// Position of PREGION0RA field.
	MWU_INTEN_PREGION0RA_Pos = 0x19
	// Bit mask of PREGION0RA field.
	MWU_INTEN_PREGION0RA_Msk = 0x2000000
	// Bit PREGION0RA.
	MWU_INTEN_PREGION0RA = 0x2000000
	// Disable
	MWU_INTEN_PREGION0RA_Disabled = 0x0
	// Enable
	MWU_INTEN_PREGION0RA_Enabled = 0x1
	// Position of PREGION1WA field.
	MWU_INTEN_PREGION1WA_Pos = 0x1a
	// Bit mask of PREGION1WA field.
	MWU_INTEN_PREGION1WA_Msk = 0x4000000
	// Bit PREGION1WA.
	MWU_INTEN_PREGION1WA = 0x4000000
	// Disable
	MWU_INTEN_PREGION1WA_Disabled = 0x0
	// Enable
	MWU_INTEN_PREGION1WA_Enabled = 0x1
	// Position of PREGION1RA field.
	MWU_INTEN_PREGION1RA_Pos = 0x1b
	// Bit mask of PREGION1RA field.
	MWU_INTEN_PREGION1RA_Msk = 0x8000000
	// Bit PREGION1RA.
	MWU_INTEN_PREGION1RA = 0x8000000
	// Disable
	MWU_INTEN_PREGION1RA_Disabled = 0x0
	// Enable
	MWU_INTEN_PREGION1RA_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of REGION0WA field.
	MWU_INTENSET_REGION0WA_Pos = 0x0
	// Bit mask of REGION0WA field.
	MWU_INTENSET_REGION0WA_Msk = 0x1
	// Bit REGION0WA.
	MWU_INTENSET_REGION0WA = 0x1
	// Read: Disabled
	MWU_INTENSET_REGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION0WA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION0WA_Set = 0x1
	// Position of REGION0RA field.
	MWU_INTENSET_REGION0RA_Pos = 0x1
	// Bit mask of REGION0RA field.
	MWU_INTENSET_REGION0RA_Msk = 0x2
	// Bit REGION0RA.
	MWU_INTENSET_REGION0RA = 0x2
	// Read: Disabled
	MWU_INTENSET_REGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION0RA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION0RA_Set = 0x1
	// Position of REGION1WA field.
	MWU_INTENSET_REGION1WA_Pos = 0x2
	// Bit mask of REGION1WA field.
	MWU_INTENSET_REGION1WA_Msk = 0x4
	// Bit REGION1WA.
	MWU_INTENSET_REGION1WA = 0x4
	// Read: Disabled
	MWU_INTENSET_REGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION1WA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION1WA_Set = 0x1
	// Position of REGION1RA field.
	MWU_INTENSET_REGION1RA_Pos = 0x3
	// Bit mask of REGION1RA field.
	MWU_INTENSET_REGION1RA_Msk = 0x8
	// Bit REGION1RA.
	MWU_INTENSET_REGION1RA = 0x8
	// Read: Disabled
	MWU_INTENSET_REGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION1RA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION1RA_Set = 0x1
	// Position of REGION2WA field.
	MWU_INTENSET_REGION2WA_Pos = 0x4
	// Bit mask of REGION2WA field.
	MWU_INTENSET_REGION2WA_Msk = 0x10
	// Bit REGION2WA.
	MWU_INTENSET_REGION2WA = 0x10
	// Read: Disabled
	MWU_INTENSET_REGION2WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION2WA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION2WA_Set = 0x1
	// Position of REGION2RA field.
	MWU_INTENSET_REGION2RA_Pos = 0x5
	// Bit mask of REGION2RA field.
	MWU_INTENSET_REGION2RA_Msk = 0x20
	// Bit REGION2RA.
	MWU_INTENSET_REGION2RA = 0x20
	// Read: Disabled
	MWU_INTENSET_REGION2RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION2RA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION2RA_Set = 0x1
	// Position of REGION3WA field.
	MWU_INTENSET_REGION3WA_Pos = 0x6
	// Bit mask of REGION3WA field.
	MWU_INTENSET_REGION3WA_Msk = 0x40
	// Bit REGION3WA.
	MWU_INTENSET_REGION3WA = 0x40
	// Read: Disabled
	MWU_INTENSET_REGION3WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION3WA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION3WA_Set = 0x1
	// Position of REGION3RA field.
	MWU_INTENSET_REGION3RA_Pos = 0x7
	// Bit mask of REGION3RA field.
	MWU_INTENSET_REGION3RA_Msk = 0x80
	// Bit REGION3RA.
	MWU_INTENSET_REGION3RA = 0x80
	// Read: Disabled
	MWU_INTENSET_REGION3RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_REGION3RA_Enabled = 0x1
	// Enable
	MWU_INTENSET_REGION3RA_Set = 0x1
	// Position of PREGION0WA field.
	MWU_INTENSET_PREGION0WA_Pos = 0x18
	// Bit mask of PREGION0WA field.
	MWU_INTENSET_PREGION0WA_Msk = 0x1000000
	// Bit PREGION0WA.
	MWU_INTENSET_PREGION0WA = 0x1000000
	// Read: Disabled
	MWU_INTENSET_PREGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_PREGION0WA_Enabled = 0x1
	// Enable
	MWU_INTENSET_PREGION0WA_Set = 0x1
	// Position of PREGION0RA field.
	MWU_INTENSET_PREGION0RA_Pos = 0x19
	// Bit mask of PREGION0RA field.
	MWU_INTENSET_PREGION0RA_Msk = 0x2000000
	// Bit PREGION0RA.
	MWU_INTENSET_PREGION0RA = 0x2000000
	// Read: Disabled
	MWU_INTENSET_PREGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_PREGION0RA_Enabled = 0x1
	// Enable
	MWU_INTENSET_PREGION0RA_Set = 0x1
	// Position of PREGION1WA field.
	MWU_INTENSET_PREGION1WA_Pos = 0x1a
	// Bit mask of PREGION1WA field.
	MWU_INTENSET_PREGION1WA_Msk = 0x4000000
	// Bit PREGION1WA.
	MWU_INTENSET_PREGION1WA = 0x4000000
	// Read: Disabled
	MWU_INTENSET_PREGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_PREGION1WA_Enabled = 0x1
	// Enable
	MWU_INTENSET_PREGION1WA_Set = 0x1
	// Position of PREGION1RA field.
	MWU_INTENSET_PREGION1RA_Pos = 0x1b
	// Bit mask of PREGION1RA field.
	MWU_INTENSET_PREGION1RA_Msk = 0x8000000
	// Bit PREGION1RA.
	MWU_INTENSET_PREGION1RA = 0x8000000
	// Read: Disabled
	MWU_INTENSET_PREGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENSET_PREGION1RA_Enabled = 0x1
	// Enable
	MWU_INTENSET_PREGION1RA_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of REGION0WA field.
	MWU_INTENCLR_REGION0WA_Pos = 0x0
	// Bit mask of REGION0WA field.
	MWU_INTENCLR_REGION0WA_Msk = 0x1
	// Bit REGION0WA.
	MWU_INTENCLR_REGION0WA = 0x1
	// Read: Disabled
	MWU_INTENCLR_REGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION0WA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION0WA_Clear = 0x1
	// Position of REGION0RA field.
	MWU_INTENCLR_REGION0RA_Pos = 0x1
	// Bit mask of REGION0RA field.
	MWU_INTENCLR_REGION0RA_Msk = 0x2
	// Bit REGION0RA.
	MWU_INTENCLR_REGION0RA = 0x2
	// Read: Disabled
	MWU_INTENCLR_REGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION0RA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION0RA_Clear = 0x1
	// Position of REGION1WA field.
	MWU_INTENCLR_REGION1WA_Pos = 0x2
	// Bit mask of REGION1WA field.
	MWU_INTENCLR_REGION1WA_Msk = 0x4
	// Bit REGION1WA.
	MWU_INTENCLR_REGION1WA = 0x4
	// Read: Disabled
	MWU_INTENCLR_REGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION1WA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION1WA_Clear = 0x1
	// Position of REGION1RA field.
	MWU_INTENCLR_REGION1RA_Pos = 0x3
	// Bit mask of REGION1RA field.
	MWU_INTENCLR_REGION1RA_Msk = 0x8
	// Bit REGION1RA.
	MWU_INTENCLR_REGION1RA = 0x8
	// Read: Disabled
	MWU_INTENCLR_REGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION1RA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION1RA_Clear = 0x1
	// Position of REGION2WA field.
	MWU_INTENCLR_REGION2WA_Pos = 0x4
	// Bit mask of REGION2WA field.
	MWU_INTENCLR_REGION2WA_Msk = 0x10
	// Bit REGION2WA.
	MWU_INTENCLR_REGION2WA = 0x10
	// Read: Disabled
	MWU_INTENCLR_REGION2WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION2WA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION2WA_Clear = 0x1
	// Position of REGION2RA field.
	MWU_INTENCLR_REGION2RA_Pos = 0x5
	// Bit mask of REGION2RA field.
	MWU_INTENCLR_REGION2RA_Msk = 0x20
	// Bit REGION2RA.
	MWU_INTENCLR_REGION2RA = 0x20
	// Read: Disabled
	MWU_INTENCLR_REGION2RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION2RA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION2RA_Clear = 0x1
	// Position of REGION3WA field.
	MWU_INTENCLR_REGION3WA_Pos = 0x6
	// Bit mask of REGION3WA field.
	MWU_INTENCLR_REGION3WA_Msk = 0x40
	// Bit REGION3WA.
	MWU_INTENCLR_REGION3WA = 0x40
	// Read: Disabled
	MWU_INTENCLR_REGION3WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION3WA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION3WA_Clear = 0x1
	// Position of REGION3RA field.
	MWU_INTENCLR_REGION3RA_Pos = 0x7
	// Bit mask of REGION3RA field.
	MWU_INTENCLR_REGION3RA_Msk = 0x80
	// Bit REGION3RA.
	MWU_INTENCLR_REGION3RA = 0x80
	// Read: Disabled
	MWU_INTENCLR_REGION3RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_REGION3RA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_REGION3RA_Clear = 0x1
	// Position of PREGION0WA field.
	MWU_INTENCLR_PREGION0WA_Pos = 0x18
	// Bit mask of PREGION0WA field.
	MWU_INTENCLR_PREGION0WA_Msk = 0x1000000
	// Bit PREGION0WA.
	MWU_INTENCLR_PREGION0WA = 0x1000000
	// Read: Disabled
	MWU_INTENCLR_PREGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_PREGION0WA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_PREGION0WA_Clear = 0x1
	// Position of PREGION0RA field.
	MWU_INTENCLR_PREGION0RA_Pos = 0x19
	// Bit mask of PREGION0RA field.
	MWU_INTENCLR_PREGION0RA_Msk = 0x2000000
	// Bit PREGION0RA.
	MWU_INTENCLR_PREGION0RA = 0x2000000
	// Read: Disabled
	MWU_INTENCLR_PREGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_PREGION0RA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_PREGION0RA_Clear = 0x1
	// Position of PREGION1WA field.
	MWU_INTENCLR_PREGION1WA_Pos = 0x1a
	// Bit mask of PREGION1WA field.
	MWU_INTENCLR_PREGION1WA_Msk = 0x4000000
	// Bit PREGION1WA.
	MWU_INTENCLR_PREGION1WA = 0x4000000
	// Read: Disabled
	MWU_INTENCLR_PREGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_PREGION1WA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_PREGION1WA_Clear = 0x1
	// Position of PREGION1RA field.
	MWU_INTENCLR_PREGION1RA_Pos = 0x1b
	// Bit mask of PREGION1RA field.
	MWU_INTENCLR_PREGION1RA_Msk = 0x8000000
	// Bit PREGION1RA.
	MWU_INTENCLR_PREGION1RA = 0x8000000
	// Read: Disabled
	MWU_INTENCLR_PREGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_INTENCLR_PREGION1RA_Enabled = 0x1
	// Disable
	MWU_INTENCLR_PREGION1RA_Clear = 0x1

	// NMIEN: Enable or disable non-maskable interrupt
	// Position of REGION0WA field.
	MWU_NMIEN_REGION0WA_Pos = 0x0
	// Bit mask of REGION0WA field.
	MWU_NMIEN_REGION0WA_Msk = 0x1
	// Bit REGION0WA.
	MWU_NMIEN_REGION0WA = 0x1
	// Disable
	MWU_NMIEN_REGION0WA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION0WA_Enabled = 0x1
	// Position of REGION0RA field.
	MWU_NMIEN_REGION0RA_Pos = 0x1
	// Bit mask of REGION0RA field.
	MWU_NMIEN_REGION0RA_Msk = 0x2
	// Bit REGION0RA.
	MWU_NMIEN_REGION0RA = 0x2
	// Disable
	MWU_NMIEN_REGION0RA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION0RA_Enabled = 0x1
	// Position of REGION1WA field.
	MWU_NMIEN_REGION1WA_Pos = 0x2
	// Bit mask of REGION1WA field.
	MWU_NMIEN_REGION1WA_Msk = 0x4
	// Bit REGION1WA.
	MWU_NMIEN_REGION1WA = 0x4
	// Disable
	MWU_NMIEN_REGION1WA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION1WA_Enabled = 0x1
	// Position of REGION1RA field.
	MWU_NMIEN_REGION1RA_Pos = 0x3
	// Bit mask of REGION1RA field.
	MWU_NMIEN_REGION1RA_Msk = 0x8
	// Bit REGION1RA.
	MWU_NMIEN_REGION1RA = 0x8
	// Disable
	MWU_NMIEN_REGION1RA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION1RA_Enabled = 0x1
	// Position of REGION2WA field.
	MWU_NMIEN_REGION2WA_Pos = 0x4
	// Bit mask of REGION2WA field.
	MWU_NMIEN_REGION2WA_Msk = 0x10
	// Bit REGION2WA.
	MWU_NMIEN_REGION2WA = 0x10
	// Disable
	MWU_NMIEN_REGION2WA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION2WA_Enabled = 0x1
	// Position of REGION2RA field.
	MWU_NMIEN_REGION2RA_Pos = 0x5
	// Bit mask of REGION2RA field.
	MWU_NMIEN_REGION2RA_Msk = 0x20
	// Bit REGION2RA.
	MWU_NMIEN_REGION2RA = 0x20
	// Disable
	MWU_NMIEN_REGION2RA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION2RA_Enabled = 0x1
	// Position of REGION3WA field.
	MWU_NMIEN_REGION3WA_Pos = 0x6
	// Bit mask of REGION3WA field.
	MWU_NMIEN_REGION3WA_Msk = 0x40
	// Bit REGION3WA.
	MWU_NMIEN_REGION3WA = 0x40
	// Disable
	MWU_NMIEN_REGION3WA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION3WA_Enabled = 0x1
	// Position of REGION3RA field.
	MWU_NMIEN_REGION3RA_Pos = 0x7
	// Bit mask of REGION3RA field.
	MWU_NMIEN_REGION3RA_Msk = 0x80
	// Bit REGION3RA.
	MWU_NMIEN_REGION3RA = 0x80
	// Disable
	MWU_NMIEN_REGION3RA_Disabled = 0x0
	// Enable
	MWU_NMIEN_REGION3RA_Enabled = 0x1
	// Position of PREGION0WA field.
	MWU_NMIEN_PREGION0WA_Pos = 0x18
	// Bit mask of PREGION0WA field.
	MWU_NMIEN_PREGION0WA_Msk = 0x1000000
	// Bit PREGION0WA.
	MWU_NMIEN_PREGION0WA = 0x1000000
	// Disable
	MWU_NMIEN_PREGION0WA_Disabled = 0x0
	// Enable
	MWU_NMIEN_PREGION0WA_Enabled = 0x1
	// Position of PREGION0RA field.
	MWU_NMIEN_PREGION0RA_Pos = 0x19
	// Bit mask of PREGION0RA field.
	MWU_NMIEN_PREGION0RA_Msk = 0x2000000
	// Bit PREGION0RA.
	MWU_NMIEN_PREGION0RA = 0x2000000
	// Disable
	MWU_NMIEN_PREGION0RA_Disabled = 0x0
	// Enable
	MWU_NMIEN_PREGION0RA_Enabled = 0x1
	// Position of PREGION1WA field.
	MWU_NMIEN_PREGION1WA_Pos = 0x1a
	// Bit mask of PREGION1WA field.
	MWU_NMIEN_PREGION1WA_Msk = 0x4000000
	// Bit PREGION1WA.
	MWU_NMIEN_PREGION1WA = 0x4000000
	// Disable
	MWU_NMIEN_PREGION1WA_Disabled = 0x0
	// Enable
	MWU_NMIEN_PREGION1WA_Enabled = 0x1
	// Position of PREGION1RA field.
	MWU_NMIEN_PREGION1RA_Pos = 0x1b
	// Bit mask of PREGION1RA field.
	MWU_NMIEN_PREGION1RA_Msk = 0x8000000
	// Bit PREGION1RA.
	MWU_NMIEN_PREGION1RA = 0x8000000
	// Disable
	MWU_NMIEN_PREGION1RA_Disabled = 0x0
	// Enable
	MWU_NMIEN_PREGION1RA_Enabled = 0x1

	// NMIENSET: Enable non-maskable interrupt
	// Position of REGION0WA field.
	MWU_NMIENSET_REGION0WA_Pos = 0x0
	// Bit mask of REGION0WA field.
	MWU_NMIENSET_REGION0WA_Msk = 0x1
	// Bit REGION0WA.
	MWU_NMIENSET_REGION0WA = 0x1
	// Read: Disabled
	MWU_NMIENSET_REGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION0WA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION0WA_Set = 0x1
	// Position of REGION0RA field.
	MWU_NMIENSET_REGION0RA_Pos = 0x1
	// Bit mask of REGION0RA field.
	MWU_NMIENSET_REGION0RA_Msk = 0x2
	// Bit REGION0RA.
	MWU_NMIENSET_REGION0RA = 0x2
	// Read: Disabled
	MWU_NMIENSET_REGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION0RA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION0RA_Set = 0x1
	// Position of REGION1WA field.
	MWU_NMIENSET_REGION1WA_Pos = 0x2
	// Bit mask of REGION1WA field.
	MWU_NMIENSET_REGION1WA_Msk = 0x4
	// Bit REGION1WA.
	MWU_NMIENSET_REGION1WA = 0x4
	// Read: Disabled
	MWU_NMIENSET_REGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION1WA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION1WA_Set = 0x1
	// Position of REGION1RA field.
	MWU_NMIENSET_REGION1RA_Pos = 0x3
	// Bit mask of REGION1RA field.
	MWU_NMIENSET_REGION1RA_Msk = 0x8
	// Bit REGION1RA.
	MWU_NMIENSET_REGION1RA = 0x8
	// Read: Disabled
	MWU_NMIENSET_REGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION1RA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION1RA_Set = 0x1
	// Position of REGION2WA field.
	MWU_NMIENSET_REGION2WA_Pos = 0x4
	// Bit mask of REGION2WA field.
	MWU_NMIENSET_REGION2WA_Msk = 0x10
	// Bit REGION2WA.
	MWU_NMIENSET_REGION2WA = 0x10
	// Read: Disabled
	MWU_NMIENSET_REGION2WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION2WA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION2WA_Set = 0x1
	// Position of REGION2RA field.
	MWU_NMIENSET_REGION2RA_Pos = 0x5
	// Bit mask of REGION2RA field.
	MWU_NMIENSET_REGION2RA_Msk = 0x20
	// Bit REGION2RA.
	MWU_NMIENSET_REGION2RA = 0x20
	// Read: Disabled
	MWU_NMIENSET_REGION2RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION2RA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION2RA_Set = 0x1
	// Position of REGION3WA field.
	MWU_NMIENSET_REGION3WA_Pos = 0x6
	// Bit mask of REGION3WA field.
	MWU_NMIENSET_REGION3WA_Msk = 0x40
	// Bit REGION3WA.
	MWU_NMIENSET_REGION3WA = 0x40
	// Read: Disabled
	MWU_NMIENSET_REGION3WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION3WA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION3WA_Set = 0x1
	// Position of REGION3RA field.
	MWU_NMIENSET_REGION3RA_Pos = 0x7
	// Bit mask of REGION3RA field.
	MWU_NMIENSET_REGION3RA_Msk = 0x80
	// Bit REGION3RA.
	MWU_NMIENSET_REGION3RA = 0x80
	// Read: Disabled
	MWU_NMIENSET_REGION3RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_REGION3RA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_REGION3RA_Set = 0x1
	// Position of PREGION0WA field.
	MWU_NMIENSET_PREGION0WA_Pos = 0x18
	// Bit mask of PREGION0WA field.
	MWU_NMIENSET_PREGION0WA_Msk = 0x1000000
	// Bit PREGION0WA.
	MWU_NMIENSET_PREGION0WA = 0x1000000
	// Read: Disabled
	MWU_NMIENSET_PREGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_PREGION0WA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_PREGION0WA_Set = 0x1
	// Position of PREGION0RA field.
	MWU_NMIENSET_PREGION0RA_Pos = 0x19
	// Bit mask of PREGION0RA field.
	MWU_NMIENSET_PREGION0RA_Msk = 0x2000000
	// Bit PREGION0RA.
	MWU_NMIENSET_PREGION0RA = 0x2000000
	// Read: Disabled
	MWU_NMIENSET_PREGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_PREGION0RA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_PREGION0RA_Set = 0x1
	// Position of PREGION1WA field.
	MWU_NMIENSET_PREGION1WA_Pos = 0x1a
	// Bit mask of PREGION1WA field.
	MWU_NMIENSET_PREGION1WA_Msk = 0x4000000
	// Bit PREGION1WA.
	MWU_NMIENSET_PREGION1WA = 0x4000000
	// Read: Disabled
	MWU_NMIENSET_PREGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_PREGION1WA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_PREGION1WA_Set = 0x1
	// Position of PREGION1RA field.
	MWU_NMIENSET_PREGION1RA_Pos = 0x1b
	// Bit mask of PREGION1RA field.
	MWU_NMIENSET_PREGION1RA_Msk = 0x8000000
	// Bit PREGION1RA.
	MWU_NMIENSET_PREGION1RA = 0x8000000
	// Read: Disabled
	MWU_NMIENSET_PREGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENSET_PREGION1RA_Enabled = 0x1
	// Enable
	MWU_NMIENSET_PREGION1RA_Set = 0x1

	// NMIENCLR: Disable non-maskable interrupt
	// Position of REGION0WA field.
	MWU_NMIENCLR_REGION0WA_Pos = 0x0
	// Bit mask of REGION0WA field.
	MWU_NMIENCLR_REGION0WA_Msk = 0x1
	// Bit REGION0WA.
	MWU_NMIENCLR_REGION0WA = 0x1
	// Read: Disabled
	MWU_NMIENCLR_REGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION0WA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION0WA_Clear = 0x1
	// Position of REGION0RA field.
	MWU_NMIENCLR_REGION0RA_Pos = 0x1
	// Bit mask of REGION0RA field.
	MWU_NMIENCLR_REGION0RA_Msk = 0x2
	// Bit REGION0RA.
	MWU_NMIENCLR_REGION0RA = 0x2
	// Read: Disabled
	MWU_NMIENCLR_REGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION0RA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION0RA_Clear = 0x1
	// Position of REGION1WA field.
	MWU_NMIENCLR_REGION1WA_Pos = 0x2
	// Bit mask of REGION1WA field.
	MWU_NMIENCLR_REGION1WA_Msk = 0x4
	// Bit REGION1WA.
	MWU_NMIENCLR_REGION1WA = 0x4
	// Read: Disabled
	MWU_NMIENCLR_REGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION1WA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION1WA_Clear = 0x1
	// Position of REGION1RA field.
	MWU_NMIENCLR_REGION1RA_Pos = 0x3
	// Bit mask of REGION1RA field.
	MWU_NMIENCLR_REGION1RA_Msk = 0x8
	// Bit REGION1RA.
	MWU_NMIENCLR_REGION1RA = 0x8
	// Read: Disabled
	MWU_NMIENCLR_REGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION1RA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION1RA_Clear = 0x1
	// Position of REGION2WA field.
	MWU_NMIENCLR_REGION2WA_Pos = 0x4
	// Bit mask of REGION2WA field.
	MWU_NMIENCLR_REGION2WA_Msk = 0x10
	// Bit REGION2WA.
	MWU_NMIENCLR_REGION2WA = 0x10
	// Read: Disabled
	MWU_NMIENCLR_REGION2WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION2WA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION2WA_Clear = 0x1
	// Position of REGION2RA field.
	MWU_NMIENCLR_REGION2RA_Pos = 0x5
	// Bit mask of REGION2RA field.
	MWU_NMIENCLR_REGION2RA_Msk = 0x20
	// Bit REGION2RA.
	MWU_NMIENCLR_REGION2RA = 0x20
	// Read: Disabled
	MWU_NMIENCLR_REGION2RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION2RA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION2RA_Clear = 0x1
	// Position of REGION3WA field.
	MWU_NMIENCLR_REGION3WA_Pos = 0x6
	// Bit mask of REGION3WA field.
	MWU_NMIENCLR_REGION3WA_Msk = 0x40
	// Bit REGION3WA.
	MWU_NMIENCLR_REGION3WA = 0x40
	// Read: Disabled
	MWU_NMIENCLR_REGION3WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION3WA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION3WA_Clear = 0x1
	// Position of REGION3RA field.
	MWU_NMIENCLR_REGION3RA_Pos = 0x7
	// Bit mask of REGION3RA field.
	MWU_NMIENCLR_REGION3RA_Msk = 0x80
	// Bit REGION3RA.
	MWU_NMIENCLR_REGION3RA = 0x80
	// Read: Disabled
	MWU_NMIENCLR_REGION3RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_REGION3RA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_REGION3RA_Clear = 0x1
	// Position of PREGION0WA field.
	MWU_NMIENCLR_PREGION0WA_Pos = 0x18
	// Bit mask of PREGION0WA field.
	MWU_NMIENCLR_PREGION0WA_Msk = 0x1000000
	// Bit PREGION0WA.
	MWU_NMIENCLR_PREGION0WA = 0x1000000
	// Read: Disabled
	MWU_NMIENCLR_PREGION0WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_PREGION0WA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_PREGION0WA_Clear = 0x1
	// Position of PREGION0RA field.
	MWU_NMIENCLR_PREGION0RA_Pos = 0x19
	// Bit mask of PREGION0RA field.
	MWU_NMIENCLR_PREGION0RA_Msk = 0x2000000
	// Bit PREGION0RA.
	MWU_NMIENCLR_PREGION0RA = 0x2000000
	// Read: Disabled
	MWU_NMIENCLR_PREGION0RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_PREGION0RA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_PREGION0RA_Clear = 0x1
	// Position of PREGION1WA field.
	MWU_NMIENCLR_PREGION1WA_Pos = 0x1a
	// Bit mask of PREGION1WA field.
	MWU_NMIENCLR_PREGION1WA_Msk = 0x4000000
	// Bit PREGION1WA.
	MWU_NMIENCLR_PREGION1WA = 0x4000000
	// Read: Disabled
	MWU_NMIENCLR_PREGION1WA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_PREGION1WA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_PREGION1WA_Clear = 0x1
	// Position of PREGION1RA field.
	MWU_NMIENCLR_PREGION1RA_Pos = 0x1b
	// Bit mask of PREGION1RA field.
	MWU_NMIENCLR_PREGION1RA_Msk = 0x8000000
	// Bit PREGION1RA.
	MWU_NMIENCLR_PREGION1RA = 0x8000000
	// Read: Disabled
	MWU_NMIENCLR_PREGION1RA_Disabled = 0x0
	// Read: Enabled
	MWU_NMIENCLR_PREGION1RA_Enabled = 0x1
	// Disable
	MWU_NMIENCLR_PREGION1RA_Clear = 0x1

	// PERREGION.SUBSTATWA: Description cluster[0]: Source of event/interrupt in region 0, write access detected while corresponding subregion was enabled for watching
	// Position of SR0 field.
	MWU_PERREGION_SUBSTATWA_SR0_Pos = 0x0
	// Bit mask of SR0 field.
	MWU_PERREGION_SUBSTATWA_SR0_Msk = 0x1
	// Bit SR0.
	MWU_PERREGION_SUBSTATWA_SR0 = 0x1
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR0_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR0_Access = 0x1
	// Position of SR1 field.
	MWU_PERREGION_SUBSTATWA_SR1_Pos = 0x1
	// Bit mask of SR1 field.
	MWU_PERREGION_SUBSTATWA_SR1_Msk = 0x2
	// Bit SR1.
	MWU_PERREGION_SUBSTATWA_SR1 = 0x2
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR1_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR1_Access = 0x1
	// Position of SR2 field.
	MWU_PERREGION_SUBSTATWA_SR2_Pos = 0x2
	// Bit mask of SR2 field.
	MWU_PERREGION_SUBSTATWA_SR2_Msk = 0x4
	// Bit SR2.
	MWU_PERREGION_SUBSTATWA_SR2 = 0x4
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR2_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR2_Access = 0x1
	// Position of SR3 field.
	MWU_PERREGION_SUBSTATWA_SR3_Pos = 0x3
	// Bit mask of SR3 field.
	MWU_PERREGION_SUBSTATWA_SR3_Msk = 0x8
	// Bit SR3.
	MWU_PERREGION_SUBSTATWA_SR3 = 0x8
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR3_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR3_Access = 0x1
	// Position of SR4 field.
	MWU_PERREGION_SUBSTATWA_SR4_Pos = 0x4
	// Bit mask of SR4 field.
	MWU_PERREGION_SUBSTATWA_SR4_Msk = 0x10
	// Bit SR4.
	MWU_PERREGION_SUBSTATWA_SR4 = 0x10
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR4_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR4_Access = 0x1
	// Position of SR5 field.
	MWU_PERREGION_SUBSTATWA_SR5_Pos = 0x5
	// Bit mask of SR5 field.
	MWU_PERREGION_SUBSTATWA_SR5_Msk = 0x20
	// Bit SR5.
	MWU_PERREGION_SUBSTATWA_SR5 = 0x20
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR5_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR5_Access = 0x1
	// Position of SR6 field.
	MWU_PERREGION_SUBSTATWA_SR6_Pos = 0x6
	// Bit mask of SR6 field.
	MWU_PERREGION_SUBSTATWA_SR6_Msk = 0x40
	// Bit SR6.
	MWU_PERREGION_SUBSTATWA_SR6 = 0x40
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR6_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR6_Access = 0x1
	// Position of SR7 field.
	MWU_PERREGION_SUBSTATWA_SR7_Pos = 0x7
	// Bit mask of SR7 field.
	MWU_PERREGION_SUBSTATWA_SR7_Msk = 0x80
	// Bit SR7.
	MWU_PERREGION_SUBSTATWA_SR7 = 0x80
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR7_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR7_Access = 0x1
	// Position of SR8 field.
	MWU_PERREGION_SUBSTATWA_SR8_Pos = 0x8
	// Bit mask of SR8 field.
	MWU_PERREGION_SUBSTATWA_SR8_Msk = 0x100
	// Bit SR8.
	MWU_PERREGION_SUBSTATWA_SR8 = 0x100
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR8_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR8_Access = 0x1
	// Position of SR9 field.
	MWU_PERREGION_SUBSTATWA_SR9_Pos = 0x9
	// Bit mask of SR9 field.
	MWU_PERREGION_SUBSTATWA_SR9_Msk = 0x200
	// Bit SR9.
	MWU_PERREGION_SUBSTATWA_SR9 = 0x200
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR9_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR9_Access = 0x1
	// Position of SR10 field.
	MWU_PERREGION_SUBSTATWA_SR10_Pos = 0xa
	// Bit mask of SR10 field.
	MWU_PERREGION_SUBSTATWA_SR10_Msk = 0x400
	// Bit SR10.
	MWU_PERREGION_SUBSTATWA_SR10 = 0x400
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR10_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR10_Access = 0x1
	// Position of SR11 field.
	MWU_PERREGION_SUBSTATWA_SR11_Pos = 0xb
	// Bit mask of SR11 field.
	MWU_PERREGION_SUBSTATWA_SR11_Msk = 0x800
	// Bit SR11.
	MWU_PERREGION_SUBSTATWA_SR11 = 0x800
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR11_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR11_Access = 0x1
	// Position of SR12 field.
	MWU_PERREGION_SUBSTATWA_SR12_Pos = 0xc
	// Bit mask of SR12 field.
	MWU_PERREGION_SUBSTATWA_SR12_Msk = 0x1000
	// Bit SR12.
	MWU_PERREGION_SUBSTATWA_SR12 = 0x1000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR12_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR12_Access = 0x1
	// Position of SR13 field.
	MWU_PERREGION_SUBSTATWA_SR13_Pos = 0xd
	// Bit mask of SR13 field.
	MWU_PERREGION_SUBSTATWA_SR13_Msk = 0x2000
	// Bit SR13.
	MWU_PERREGION_SUBSTATWA_SR13 = 0x2000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR13_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR13_Access = 0x1
	// Position of SR14 field.
	MWU_PERREGION_SUBSTATWA_SR14_Pos = 0xe
	// Bit mask of SR14 field.
	MWU_PERREGION_SUBSTATWA_SR14_Msk = 0x4000
	// Bit SR14.
	MWU_PERREGION_SUBSTATWA_SR14 = 0x4000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR14_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR14_Access = 0x1
	// Position of SR15 field.
	MWU_PERREGION_SUBSTATWA_SR15_Pos = 0xf
	// Bit mask of SR15 field.
	MWU_PERREGION_SUBSTATWA_SR15_Msk = 0x8000
	// Bit SR15.
	MWU_PERREGION_SUBSTATWA_SR15 = 0x8000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR15_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR15_Access = 0x1
	// Position of SR16 field.
	MWU_PERREGION_SUBSTATWA_SR16_Pos = 0x10
	// Bit mask of SR16 field.
	MWU_PERREGION_SUBSTATWA_SR16_Msk = 0x10000
	// Bit SR16.
	MWU_PERREGION_SUBSTATWA_SR16 = 0x10000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR16_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR16_Access = 0x1
	// Position of SR17 field.
	MWU_PERREGION_SUBSTATWA_SR17_Pos = 0x11
	// Bit mask of SR17 field.
	MWU_PERREGION_SUBSTATWA_SR17_Msk = 0x20000
	// Bit SR17.
	MWU_PERREGION_SUBSTATWA_SR17 = 0x20000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR17_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR17_Access = 0x1
	// Position of SR18 field.
	MWU_PERREGION_SUBSTATWA_SR18_Pos = 0x12
	// Bit mask of SR18 field.
	MWU_PERREGION_SUBSTATWA_SR18_Msk = 0x40000
	// Bit SR18.
	MWU_PERREGION_SUBSTATWA_SR18 = 0x40000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR18_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR18_Access = 0x1
	// Position of SR19 field.
	MWU_PERREGION_SUBSTATWA_SR19_Pos = 0x13
	// Bit mask of SR19 field.
	MWU_PERREGION_SUBSTATWA_SR19_Msk = 0x80000
	// Bit SR19.
	MWU_PERREGION_SUBSTATWA_SR19 = 0x80000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR19_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR19_Access = 0x1
	// Position of SR20 field.
	MWU_PERREGION_SUBSTATWA_SR20_Pos = 0x14
	// Bit mask of SR20 field.
	MWU_PERREGION_SUBSTATWA_SR20_Msk = 0x100000
	// Bit SR20.
	MWU_PERREGION_SUBSTATWA_SR20 = 0x100000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR20_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR20_Access = 0x1
	// Position of SR21 field.
	MWU_PERREGION_SUBSTATWA_SR21_Pos = 0x15
	// Bit mask of SR21 field.
	MWU_PERREGION_SUBSTATWA_SR21_Msk = 0x200000
	// Bit SR21.
	MWU_PERREGION_SUBSTATWA_SR21 = 0x200000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR21_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR21_Access = 0x1
	// Position of SR22 field.
	MWU_PERREGION_SUBSTATWA_SR22_Pos = 0x16
	// Bit mask of SR22 field.
	MWU_PERREGION_SUBSTATWA_SR22_Msk = 0x400000
	// Bit SR22.
	MWU_PERREGION_SUBSTATWA_SR22 = 0x400000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR22_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR22_Access = 0x1
	// Position of SR23 field.
	MWU_PERREGION_SUBSTATWA_SR23_Pos = 0x17
	// Bit mask of SR23 field.
	MWU_PERREGION_SUBSTATWA_SR23_Msk = 0x800000
	// Bit SR23.
	MWU_PERREGION_SUBSTATWA_SR23 = 0x800000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR23_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR23_Access = 0x1
	// Position of SR24 field.
	MWU_PERREGION_SUBSTATWA_SR24_Pos = 0x18
	// Bit mask of SR24 field.
	MWU_PERREGION_SUBSTATWA_SR24_Msk = 0x1000000
	// Bit SR24.
	MWU_PERREGION_SUBSTATWA_SR24 = 0x1000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR24_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR24_Access = 0x1
	// Position of SR25 field.
	MWU_PERREGION_SUBSTATWA_SR25_Pos = 0x19
	// Bit mask of SR25 field.
	MWU_PERREGION_SUBSTATWA_SR25_Msk = 0x2000000
	// Bit SR25.
	MWU_PERREGION_SUBSTATWA_SR25 = 0x2000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR25_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR25_Access = 0x1
	// Position of SR26 field.
	MWU_PERREGION_SUBSTATWA_SR26_Pos = 0x1a
	// Bit mask of SR26 field.
	MWU_PERREGION_SUBSTATWA_SR26_Msk = 0x4000000
	// Bit SR26.
	MWU_PERREGION_SUBSTATWA_SR26 = 0x4000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR26_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR26_Access = 0x1
	// Position of SR27 field.
	MWU_PERREGION_SUBSTATWA_SR27_Pos = 0x1b
	// Bit mask of SR27 field.
	MWU_PERREGION_SUBSTATWA_SR27_Msk = 0x8000000
	// Bit SR27.
	MWU_PERREGION_SUBSTATWA_SR27 = 0x8000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR27_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR27_Access = 0x1
	// Position of SR28 field.
	MWU_PERREGION_SUBSTATWA_SR28_Pos = 0x1c
	// Bit mask of SR28 field.
	MWU_PERREGION_SUBSTATWA_SR28_Msk = 0x10000000
	// Bit SR28.
	MWU_PERREGION_SUBSTATWA_SR28 = 0x10000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR28_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR28_Access = 0x1
	// Position of SR29 field.
	MWU_PERREGION_SUBSTATWA_SR29_Pos = 0x1d
	// Bit mask of SR29 field.
	MWU_PERREGION_SUBSTATWA_SR29_Msk = 0x20000000
	// Bit SR29.
	MWU_PERREGION_SUBSTATWA_SR29 = 0x20000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR29_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR29_Access = 0x1
	// Position of SR30 field.
	MWU_PERREGION_SUBSTATWA_SR30_Pos = 0x1e
	// Bit mask of SR30 field.
	MWU_PERREGION_SUBSTATWA_SR30_Msk = 0x40000000
	// Bit SR30.
	MWU_PERREGION_SUBSTATWA_SR30 = 0x40000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR30_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR30_Access = 0x1
	// Position of SR31 field.
	MWU_PERREGION_SUBSTATWA_SR31_Pos = 0x1f
	// Bit mask of SR31 field.
	MWU_PERREGION_SUBSTATWA_SR31_Msk = 0x80000000
	// Bit SR31.
	MWU_PERREGION_SUBSTATWA_SR31 = 0x80000000
	// No write access occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR31_NoAccess = 0x0
	// Write access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATWA_SR31_Access = 0x1

	// PERREGION.SUBSTATRA: Description cluster[0]: Source of event/interrupt in region 0, read access detected while corresponding subregion was enabled for watching
	// Position of SR0 field.
	MWU_PERREGION_SUBSTATRA_SR0_Pos = 0x0
	// Bit mask of SR0 field.
	MWU_PERREGION_SUBSTATRA_SR0_Msk = 0x1
	// Bit SR0.
	MWU_PERREGION_SUBSTATRA_SR0 = 0x1
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR0_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR0_Access = 0x1
	// Position of SR1 field.
	MWU_PERREGION_SUBSTATRA_SR1_Pos = 0x1
	// Bit mask of SR1 field.
	MWU_PERREGION_SUBSTATRA_SR1_Msk = 0x2
	// Bit SR1.
	MWU_PERREGION_SUBSTATRA_SR1 = 0x2
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR1_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR1_Access = 0x1
	// Position of SR2 field.
	MWU_PERREGION_SUBSTATRA_SR2_Pos = 0x2
	// Bit mask of SR2 field.
	MWU_PERREGION_SUBSTATRA_SR2_Msk = 0x4
	// Bit SR2.
	MWU_PERREGION_SUBSTATRA_SR2 = 0x4
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR2_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR2_Access = 0x1
	// Position of SR3 field.
	MWU_PERREGION_SUBSTATRA_SR3_Pos = 0x3
	// Bit mask of SR3 field.
	MWU_PERREGION_SUBSTATRA_SR3_Msk = 0x8
	// Bit SR3.
	MWU_PERREGION_SUBSTATRA_SR3 = 0x8
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR3_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR3_Access = 0x1
	// Position of SR4 field.
	MWU_PERREGION_SUBSTATRA_SR4_Pos = 0x4
	// Bit mask of SR4 field.
	MWU_PERREGION_SUBSTATRA_SR4_Msk = 0x10
	// Bit SR4.
	MWU_PERREGION_SUBSTATRA_SR4 = 0x10
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR4_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR4_Access = 0x1
	// Position of SR5 field.
	MWU_PERREGION_SUBSTATRA_SR5_Pos = 0x5
	// Bit mask of SR5 field.
	MWU_PERREGION_SUBSTATRA_SR5_Msk = 0x20
	// Bit SR5.
	MWU_PERREGION_SUBSTATRA_SR5 = 0x20
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR5_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR5_Access = 0x1
	// Position of SR6 field.
	MWU_PERREGION_SUBSTATRA_SR6_Pos = 0x6
	// Bit mask of SR6 field.
	MWU_PERREGION_SUBSTATRA_SR6_Msk = 0x40
	// Bit SR6.
	MWU_PERREGION_SUBSTATRA_SR6 = 0x40
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR6_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR6_Access = 0x1
	// Position of SR7 field.
	MWU_PERREGION_SUBSTATRA_SR7_Pos = 0x7
	// Bit mask of SR7 field.
	MWU_PERREGION_SUBSTATRA_SR7_Msk = 0x80
	// Bit SR7.
	MWU_PERREGION_SUBSTATRA_SR7 = 0x80
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR7_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR7_Access = 0x1
	// Position of SR8 field.
	MWU_PERREGION_SUBSTATRA_SR8_Pos = 0x8
	// Bit mask of SR8 field.
	MWU_PERREGION_SUBSTATRA_SR8_Msk = 0x100
	// Bit SR8.
	MWU_PERREGION_SUBSTATRA_SR8 = 0x100
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR8_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR8_Access = 0x1
	// Position of SR9 field.
	MWU_PERREGION_SUBSTATRA_SR9_Pos = 0x9
	// Bit mask of SR9 field.
	MWU_PERREGION_SUBSTATRA_SR9_Msk = 0x200
	// Bit SR9.
	MWU_PERREGION_SUBSTATRA_SR9 = 0x200
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR9_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR9_Access = 0x1
	// Position of SR10 field.
	MWU_PERREGION_SUBSTATRA_SR10_Pos = 0xa
	// Bit mask of SR10 field.
	MWU_PERREGION_SUBSTATRA_SR10_Msk = 0x400
	// Bit SR10.
	MWU_PERREGION_SUBSTATRA_SR10 = 0x400
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR10_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR10_Access = 0x1
	// Position of SR11 field.
	MWU_PERREGION_SUBSTATRA_SR11_Pos = 0xb
	// Bit mask of SR11 field.
	MWU_PERREGION_SUBSTATRA_SR11_Msk = 0x800
	// Bit SR11.
	MWU_PERREGION_SUBSTATRA_SR11 = 0x800
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR11_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR11_Access = 0x1
	// Position of SR12 field.
	MWU_PERREGION_SUBSTATRA_SR12_Pos = 0xc
	// Bit mask of SR12 field.
	MWU_PERREGION_SUBSTATRA_SR12_Msk = 0x1000
	// Bit SR12.
	MWU_PERREGION_SUBSTATRA_SR12 = 0x1000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR12_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR12_Access = 0x1
	// Position of SR13 field.
	MWU_PERREGION_SUBSTATRA_SR13_Pos = 0xd
	// Bit mask of SR13 field.
	MWU_PERREGION_SUBSTATRA_SR13_Msk = 0x2000
	// Bit SR13.
	MWU_PERREGION_SUBSTATRA_SR13 = 0x2000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR13_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR13_Access = 0x1
	// Position of SR14 field.
	MWU_PERREGION_SUBSTATRA_SR14_Pos = 0xe
	// Bit mask of SR14 field.
	MWU_PERREGION_SUBSTATRA_SR14_Msk = 0x4000
	// Bit SR14.
	MWU_PERREGION_SUBSTATRA_SR14 = 0x4000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR14_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR14_Access = 0x1
	// Position of SR15 field.
	MWU_PERREGION_SUBSTATRA_SR15_Pos = 0xf
	// Bit mask of SR15 field.
	MWU_PERREGION_SUBSTATRA_SR15_Msk = 0x8000
	// Bit SR15.
	MWU_PERREGION_SUBSTATRA_SR15 = 0x8000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR15_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR15_Access = 0x1
	// Position of SR16 field.
	MWU_PERREGION_SUBSTATRA_SR16_Pos = 0x10
	// Bit mask of SR16 field.
	MWU_PERREGION_SUBSTATRA_SR16_Msk = 0x10000
	// Bit SR16.
	MWU_PERREGION_SUBSTATRA_SR16 = 0x10000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR16_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR16_Access = 0x1
	// Position of SR17 field.
	MWU_PERREGION_SUBSTATRA_SR17_Pos = 0x11
	// Bit mask of SR17 field.
	MWU_PERREGION_SUBSTATRA_SR17_Msk = 0x20000
	// Bit SR17.
	MWU_PERREGION_SUBSTATRA_SR17 = 0x20000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR17_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR17_Access = 0x1
	// Position of SR18 field.
	MWU_PERREGION_SUBSTATRA_SR18_Pos = 0x12
	// Bit mask of SR18 field.
	MWU_PERREGION_SUBSTATRA_SR18_Msk = 0x40000
	// Bit SR18.
	MWU_PERREGION_SUBSTATRA_SR18 = 0x40000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR18_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR18_Access = 0x1
	// Position of SR19 field.
	MWU_PERREGION_SUBSTATRA_SR19_Pos = 0x13
	// Bit mask of SR19 field.
	MWU_PERREGION_SUBSTATRA_SR19_Msk = 0x80000
	// Bit SR19.
	MWU_PERREGION_SUBSTATRA_SR19 = 0x80000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR19_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR19_Access = 0x1
	// Position of SR20 field.
	MWU_PERREGION_SUBSTATRA_SR20_Pos = 0x14
	// Bit mask of SR20 field.
	MWU_PERREGION_SUBSTATRA_SR20_Msk = 0x100000
	// Bit SR20.
	MWU_PERREGION_SUBSTATRA_SR20 = 0x100000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR20_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR20_Access = 0x1
	// Position of SR21 field.
	MWU_PERREGION_SUBSTATRA_SR21_Pos = 0x15
	// Bit mask of SR21 field.
	MWU_PERREGION_SUBSTATRA_SR21_Msk = 0x200000
	// Bit SR21.
	MWU_PERREGION_SUBSTATRA_SR21 = 0x200000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR21_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR21_Access = 0x1
	// Position of SR22 field.
	MWU_PERREGION_SUBSTATRA_SR22_Pos = 0x16
	// Bit mask of SR22 field.
	MWU_PERREGION_SUBSTATRA_SR22_Msk = 0x400000
	// Bit SR22.
	MWU_PERREGION_SUBSTATRA_SR22 = 0x400000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR22_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR22_Access = 0x1
	// Position of SR23 field.
	MWU_PERREGION_SUBSTATRA_SR23_Pos = 0x17
	// Bit mask of SR23 field.
	MWU_PERREGION_SUBSTATRA_SR23_Msk = 0x800000
	// Bit SR23.
	MWU_PERREGION_SUBSTATRA_SR23 = 0x800000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR23_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR23_Access = 0x1
	// Position of SR24 field.
	MWU_PERREGION_SUBSTATRA_SR24_Pos = 0x18
	// Bit mask of SR24 field.
	MWU_PERREGION_SUBSTATRA_SR24_Msk = 0x1000000
	// Bit SR24.
	MWU_PERREGION_SUBSTATRA_SR24 = 0x1000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR24_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR24_Access = 0x1
	// Position of SR25 field.
	MWU_PERREGION_SUBSTATRA_SR25_Pos = 0x19
	// Bit mask of SR25 field.
	MWU_PERREGION_SUBSTATRA_SR25_Msk = 0x2000000
	// Bit SR25.
	MWU_PERREGION_SUBSTATRA_SR25 = 0x2000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR25_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR25_Access = 0x1
	// Position of SR26 field.
	MWU_PERREGION_SUBSTATRA_SR26_Pos = 0x1a
	// Bit mask of SR26 field.
	MWU_PERREGION_SUBSTATRA_SR26_Msk = 0x4000000
	// Bit SR26.
	MWU_PERREGION_SUBSTATRA_SR26 = 0x4000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR26_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR26_Access = 0x1
	// Position of SR27 field.
	MWU_PERREGION_SUBSTATRA_SR27_Pos = 0x1b
	// Bit mask of SR27 field.
	MWU_PERREGION_SUBSTATRA_SR27_Msk = 0x8000000
	// Bit SR27.
	MWU_PERREGION_SUBSTATRA_SR27 = 0x8000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR27_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR27_Access = 0x1
	// Position of SR28 field.
	MWU_PERREGION_SUBSTATRA_SR28_Pos = 0x1c
	// Bit mask of SR28 field.
	MWU_PERREGION_SUBSTATRA_SR28_Msk = 0x10000000
	// Bit SR28.
	MWU_PERREGION_SUBSTATRA_SR28 = 0x10000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR28_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR28_Access = 0x1
	// Position of SR29 field.
	MWU_PERREGION_SUBSTATRA_SR29_Pos = 0x1d
	// Bit mask of SR29 field.
	MWU_PERREGION_SUBSTATRA_SR29_Msk = 0x20000000
	// Bit SR29.
	MWU_PERREGION_SUBSTATRA_SR29 = 0x20000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR29_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR29_Access = 0x1
	// Position of SR30 field.
	MWU_PERREGION_SUBSTATRA_SR30_Pos = 0x1e
	// Bit mask of SR30 field.
	MWU_PERREGION_SUBSTATRA_SR30_Msk = 0x40000000
	// Bit SR30.
	MWU_PERREGION_SUBSTATRA_SR30 = 0x40000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR30_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR30_Access = 0x1
	// Position of SR31 field.
	MWU_PERREGION_SUBSTATRA_SR31_Pos = 0x1f
	// Bit mask of SR31 field.
	MWU_PERREGION_SUBSTATRA_SR31_Msk = 0x80000000
	// Bit SR31.
	MWU_PERREGION_SUBSTATRA_SR31 = 0x80000000
	// No read access occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR31_NoAccess = 0x0
	// Read access(es) occurred in this subregion
	MWU_PERREGION_SUBSTATRA_SR31_Access = 0x1

	// REGIONEN: Enable/disable regions watch
	// Position of RGN0WA field.
	MWU_REGIONEN_RGN0WA_Pos = 0x0
	// Bit mask of RGN0WA field.
	MWU_REGIONEN_RGN0WA_Msk = 0x1
	// Bit RGN0WA.
	MWU_REGIONEN_RGN0WA = 0x1
	// Disable write access watch in this region
	MWU_REGIONEN_RGN0WA_Disable = 0x0
	// Enable write access watch in this region
	MWU_REGIONEN_RGN0WA_Enable = 0x1
	// Position of RGN0RA field.
	MWU_REGIONEN_RGN0RA_Pos = 0x1
	// Bit mask of RGN0RA field.
	MWU_REGIONEN_RGN0RA_Msk = 0x2
	// Bit RGN0RA.
	MWU_REGIONEN_RGN0RA = 0x2
	// Disable read access watch in this region
	MWU_REGIONEN_RGN0RA_Disable = 0x0
	// Enable read access watch in this region
	MWU_REGIONEN_RGN0RA_Enable = 0x1
	// Position of RGN1WA field.
	MWU_REGIONEN_RGN1WA_Pos = 0x2
	// Bit mask of RGN1WA field.
	MWU_REGIONEN_RGN1WA_Msk = 0x4
	// Bit RGN1WA.
	MWU_REGIONEN_RGN1WA = 0x4
	// Disable write access watch in this region
	MWU_REGIONEN_RGN1WA_Disable = 0x0
	// Enable write access watch in this region
	MWU_REGIONEN_RGN1WA_Enable = 0x1
	// Position of RGN1RA field.
	MWU_REGIONEN_RGN1RA_Pos = 0x3
	// Bit mask of RGN1RA field.
	MWU_REGIONEN_RGN1RA_Msk = 0x8
	// Bit RGN1RA.
	MWU_REGIONEN_RGN1RA = 0x8
	// Disable read access watch in this region
	MWU_REGIONEN_RGN1RA_Disable = 0x0
	// Enable read access watch in this region
	MWU_REGIONEN_RGN1RA_Enable = 0x1
	// Position of RGN2WA field.
	MWU_REGIONEN_RGN2WA_Pos = 0x4
	// Bit mask of RGN2WA field.
	MWU_REGIONEN_RGN2WA_Msk = 0x10
	// Bit RGN2WA.
	MWU_REGIONEN_RGN2WA = 0x10
	// Disable write access watch in this region
	MWU_REGIONEN_RGN2WA_Disable = 0x0
	// Enable write access watch in this region
	MWU_REGIONEN_RGN2WA_Enable = 0x1
	// Position of RGN2RA field.
	MWU_REGIONEN_RGN2RA_Pos = 0x5
	// Bit mask of RGN2RA field.
	MWU_REGIONEN_RGN2RA_Msk = 0x20
	// Bit RGN2RA.
	MWU_REGIONEN_RGN2RA = 0x20
	// Disable read access watch in this region
	MWU_REGIONEN_RGN2RA_Disable = 0x0
	// Enable read access watch in this region
	MWU_REGIONEN_RGN2RA_Enable = 0x1
	// Position of RGN3WA field.
	MWU_REGIONEN_RGN3WA_Pos = 0x6
	// Bit mask of RGN3WA field.
	MWU_REGIONEN_RGN3WA_Msk = 0x40
	// Bit RGN3WA.
	MWU_REGIONEN_RGN3WA = 0x40
	// Disable write access watch in this region
	MWU_REGIONEN_RGN3WA_Disable = 0x0
	// Enable write access watch in this region
	MWU_REGIONEN_RGN3WA_Enable = 0x1
	// Position of RGN3RA field.
	MWU_REGIONEN_RGN3RA_Pos = 0x7
	// Bit mask of RGN3RA field.
	MWU_REGIONEN_RGN3RA_Msk = 0x80
	// Bit RGN3RA.
	MWU_REGIONEN_RGN3RA = 0x80
	// Disable read access watch in this region
	MWU_REGIONEN_RGN3RA_Disable = 0x0
	// Enable read access watch in this region
	MWU_REGIONEN_RGN3RA_Enable = 0x1
	// Position of PRGN0WA field.
	MWU_REGIONEN_PRGN0WA_Pos = 0x18
	// Bit mask of PRGN0WA field.
	MWU_REGIONEN_PRGN0WA_Msk = 0x1000000
	// Bit PRGN0WA.
	MWU_REGIONEN_PRGN0WA = 0x1000000
	// Disable write access watch in this PREGION
	MWU_REGIONEN_PRGN0WA_Disable = 0x0
	// Enable write access watch in this PREGION
	MWU_REGIONEN_PRGN0WA_Enable = 0x1
	// Position of PRGN0RA field.
	MWU_REGIONEN_PRGN0RA_Pos = 0x19
	// Bit mask of PRGN0RA field.
	MWU_REGIONEN_PRGN0RA_Msk = 0x2000000
	// Bit PRGN0RA.
	MWU_REGIONEN_PRGN0RA = 0x2000000
	// Disable read access watch in this PREGION
	MWU_REGIONEN_PRGN0RA_Disable = 0x0
	// Enable read access watch in this PREGION
	MWU_REGIONEN_PRGN0RA_Enable = 0x1
	// Position of PRGN1WA field.
	MWU_REGIONEN_PRGN1WA_Pos = 0x1a
	// Bit mask of PRGN1WA field.
	MWU_REGIONEN_PRGN1WA_Msk = 0x4000000
	// Bit PRGN1WA.
	MWU_REGIONEN_PRGN1WA = 0x4000000
	// Disable write access watch in this PREGION
	MWU_REGIONEN_PRGN1WA_Disable = 0x0
	// Enable write access watch in this PREGION
	MWU_REGIONEN_PRGN1WA_Enable = 0x1
	// Position of PRGN1RA field.
	MWU_REGIONEN_PRGN1RA_Pos = 0x1b
	// Bit mask of PRGN1RA field.
	MWU_REGIONEN_PRGN1RA_Msk = 0x8000000
	// Bit PRGN1RA.
	MWU_REGIONEN_PRGN1RA = 0x8000000
	// Disable read access watch in this PREGION
	MWU_REGIONEN_PRGN1RA_Disable = 0x0
	// Enable read access watch in this PREGION
	MWU_REGIONEN_PRGN1RA_Enable = 0x1

	// REGIONENSET: Enable regions watch
	// Position of RGN0WA field.
	MWU_REGIONENSET_RGN0WA_Pos = 0x0
	// Bit mask of RGN0WA field.
	MWU_REGIONENSET_RGN0WA_Msk = 0x1
	// Bit RGN0WA.
	MWU_REGIONENSET_RGN0WA = 0x1
	// Write access watch in this region is disabled
	MWU_REGIONENSET_RGN0WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENSET_RGN0WA_Enabled = 0x1
	// Enable write access watch in this region
	MWU_REGIONENSET_RGN0WA_Set = 0x1
	// Position of RGN0RA field.
	MWU_REGIONENSET_RGN0RA_Pos = 0x1
	// Bit mask of RGN0RA field.
	MWU_REGIONENSET_RGN0RA_Msk = 0x2
	// Bit RGN0RA.
	MWU_REGIONENSET_RGN0RA = 0x2
	// Read access watch in this region is disabled
	MWU_REGIONENSET_RGN0RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENSET_RGN0RA_Enabled = 0x1
	// Enable read access watch in this region
	MWU_REGIONENSET_RGN0RA_Set = 0x1
	// Position of RGN1WA field.
	MWU_REGIONENSET_RGN1WA_Pos = 0x2
	// Bit mask of RGN1WA field.
	MWU_REGIONENSET_RGN1WA_Msk = 0x4
	// Bit RGN1WA.
	MWU_REGIONENSET_RGN1WA = 0x4
	// Write access watch in this region is disabled
	MWU_REGIONENSET_RGN1WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENSET_RGN1WA_Enabled = 0x1
	// Enable write access watch in this region
	MWU_REGIONENSET_RGN1WA_Set = 0x1
	// Position of RGN1RA field.
	MWU_REGIONENSET_RGN1RA_Pos = 0x3
	// Bit mask of RGN1RA field.
	MWU_REGIONENSET_RGN1RA_Msk = 0x8
	// Bit RGN1RA.
	MWU_REGIONENSET_RGN1RA = 0x8
	// Read access watch in this region is disabled
	MWU_REGIONENSET_RGN1RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENSET_RGN1RA_Enabled = 0x1
	// Enable read access watch in this region
	MWU_REGIONENSET_RGN1RA_Set = 0x1
	// Position of RGN2WA field.
	MWU_REGIONENSET_RGN2WA_Pos = 0x4
	// Bit mask of RGN2WA field.
	MWU_REGIONENSET_RGN2WA_Msk = 0x10
	// Bit RGN2WA.
	MWU_REGIONENSET_RGN2WA = 0x10
	// Write access watch in this region is disabled
	MWU_REGIONENSET_RGN2WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENSET_RGN2WA_Enabled = 0x1
	// Enable write access watch in this region
	MWU_REGIONENSET_RGN2WA_Set = 0x1
	// Position of RGN2RA field.
	MWU_REGIONENSET_RGN2RA_Pos = 0x5
	// Bit mask of RGN2RA field.
	MWU_REGIONENSET_RGN2RA_Msk = 0x20
	// Bit RGN2RA.
	MWU_REGIONENSET_RGN2RA = 0x20
	// Read access watch in this region is disabled
	MWU_REGIONENSET_RGN2RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENSET_RGN2RA_Enabled = 0x1
	// Enable read access watch in this region
	MWU_REGIONENSET_RGN2RA_Set = 0x1
	// Position of RGN3WA field.
	MWU_REGIONENSET_RGN3WA_Pos = 0x6
	// Bit mask of RGN3WA field.
	MWU_REGIONENSET_RGN3WA_Msk = 0x40
	// Bit RGN3WA.
	MWU_REGIONENSET_RGN3WA = 0x40
	// Write access watch in this region is disabled
	MWU_REGIONENSET_RGN3WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENSET_RGN3WA_Enabled = 0x1
	// Enable write access watch in this region
	MWU_REGIONENSET_RGN3WA_Set = 0x1
	// Position of RGN3RA field.
	MWU_REGIONENSET_RGN3RA_Pos = 0x7
	// Bit mask of RGN3RA field.
	MWU_REGIONENSET_RGN3RA_Msk = 0x80
	// Bit RGN3RA.
	MWU_REGIONENSET_RGN3RA = 0x80
	// Read access watch in this region is disabled
	MWU_REGIONENSET_RGN3RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENSET_RGN3RA_Enabled = 0x1
	// Enable read access watch in this region
	MWU_REGIONENSET_RGN3RA_Set = 0x1
	// Position of PRGN0WA field.
	MWU_REGIONENSET_PRGN0WA_Pos = 0x18
	// Bit mask of PRGN0WA field.
	MWU_REGIONENSET_PRGN0WA_Msk = 0x1000000
	// Bit PRGN0WA.
	MWU_REGIONENSET_PRGN0WA = 0x1000000
	// Write access watch in this PREGION is disabled
	MWU_REGIONENSET_PRGN0WA_Disabled = 0x0
	// Write access watch in this PREGION is enabled
	MWU_REGIONENSET_PRGN0WA_Enabled = 0x1
	// Enable write access watch in this PREGION
	MWU_REGIONENSET_PRGN0WA_Set = 0x1
	// Position of PRGN0RA field.
	MWU_REGIONENSET_PRGN0RA_Pos = 0x19
	// Bit mask of PRGN0RA field.
	MWU_REGIONENSET_PRGN0RA_Msk = 0x2000000
	// Bit PRGN0RA.
	MWU_REGIONENSET_PRGN0RA = 0x2000000
	// Read access watch in this PREGION is disabled
	MWU_REGIONENSET_PRGN0RA_Disabled = 0x0
	// Read access watch in this PREGION is enabled
	MWU_REGIONENSET_PRGN0RA_Enabled = 0x1
	// Enable read access watch in this PREGION
	MWU_REGIONENSET_PRGN0RA_Set = 0x1
	// Position of PRGN1WA field.
	MWU_REGIONENSET_PRGN1WA_Pos = 0x1a
	// Bit mask of PRGN1WA field.
	MWU_REGIONENSET_PRGN1WA_Msk = 0x4000000
	// Bit PRGN1WA.
	MWU_REGIONENSET_PRGN1WA = 0x4000000
	// Write access watch in this PREGION is disabled
	MWU_REGIONENSET_PRGN1WA_Disabled = 0x0
	// Write access watch in this PREGION is enabled
	MWU_REGIONENSET_PRGN1WA_Enabled = 0x1
	// Enable write access watch in this PREGION
	MWU_REGIONENSET_PRGN1WA_Set = 0x1
	// Position of PRGN1RA field.
	MWU_REGIONENSET_PRGN1RA_Pos = 0x1b
	// Bit mask of PRGN1RA field.
	MWU_REGIONENSET_PRGN1RA_Msk = 0x8000000
	// Bit PRGN1RA.
	MWU_REGIONENSET_PRGN1RA = 0x8000000
	// Read access watch in this PREGION is disabled
	MWU_REGIONENSET_PRGN1RA_Disabled = 0x0
	// Read access watch in this PREGION is enabled
	MWU_REGIONENSET_PRGN1RA_Enabled = 0x1
	// Enable read access watch in this PREGION
	MWU_REGIONENSET_PRGN1RA_Set = 0x1

	// REGIONENCLR: Disable regions watch
	// Position of RGN0WA field.
	MWU_REGIONENCLR_RGN0WA_Pos = 0x0
	// Bit mask of RGN0WA field.
	MWU_REGIONENCLR_RGN0WA_Msk = 0x1
	// Bit RGN0WA.
	MWU_REGIONENCLR_RGN0WA = 0x1
	// Write access watch in this region is disabled
	MWU_REGIONENCLR_RGN0WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENCLR_RGN0WA_Enabled = 0x1
	// Disable write access watch in this region
	MWU_REGIONENCLR_RGN0WA_Clear = 0x1
	// Position of RGN0RA field.
	MWU_REGIONENCLR_RGN0RA_Pos = 0x1
	// Bit mask of RGN0RA field.
	MWU_REGIONENCLR_RGN0RA_Msk = 0x2
	// Bit RGN0RA.
	MWU_REGIONENCLR_RGN0RA = 0x2
	// Read access watch in this region is disabled
	MWU_REGIONENCLR_RGN0RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENCLR_RGN0RA_Enabled = 0x1
	// Disable read access watch in this region
	MWU_REGIONENCLR_RGN0RA_Clear = 0x1
	// Position of RGN1WA field.
	MWU_REGIONENCLR_RGN1WA_Pos = 0x2
	// Bit mask of RGN1WA field.
	MWU_REGIONENCLR_RGN1WA_Msk = 0x4
	// Bit RGN1WA.
	MWU_REGIONENCLR_RGN1WA = 0x4
	// Write access watch in this region is disabled
	MWU_REGIONENCLR_RGN1WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENCLR_RGN1WA_Enabled = 0x1
	// Disable write access watch in this region
	MWU_REGIONENCLR_RGN1WA_Clear = 0x1
	// Position of RGN1RA field.
	MWU_REGIONENCLR_RGN1RA_Pos = 0x3
	// Bit mask of RGN1RA field.
	MWU_REGIONENCLR_RGN1RA_Msk = 0x8
	// Bit RGN1RA.
	MWU_REGIONENCLR_RGN1RA = 0x8
	// Read access watch in this region is disabled
	MWU_REGIONENCLR_RGN1RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENCLR_RGN1RA_Enabled = 0x1
	// Disable read access watch in this region
	MWU_REGIONENCLR_RGN1RA_Clear = 0x1
	// Position of RGN2WA field.
	MWU_REGIONENCLR_RGN2WA_Pos = 0x4
	// Bit mask of RGN2WA field.
	MWU_REGIONENCLR_RGN2WA_Msk = 0x10
	// Bit RGN2WA.
	MWU_REGIONENCLR_RGN2WA = 0x10
	// Write access watch in this region is disabled
	MWU_REGIONENCLR_RGN2WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENCLR_RGN2WA_Enabled = 0x1
	// Disable write access watch in this region
	MWU_REGIONENCLR_RGN2WA_Clear = 0x1
	// Position of RGN2RA field.
	MWU_REGIONENCLR_RGN2RA_Pos = 0x5
	// Bit mask of RGN2RA field.
	MWU_REGIONENCLR_RGN2RA_Msk = 0x20
	// Bit RGN2RA.
	MWU_REGIONENCLR_RGN2RA = 0x20
	// Read access watch in this region is disabled
	MWU_REGIONENCLR_RGN2RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENCLR_RGN2RA_Enabled = 0x1
	// Disable read access watch in this region
	MWU_REGIONENCLR_RGN2RA_Clear = 0x1
	// Position of RGN3WA field.
	MWU_REGIONENCLR_RGN3WA_Pos = 0x6
	// Bit mask of RGN3WA field.
	MWU_REGIONENCLR_RGN3WA_Msk = 0x40
	// Bit RGN3WA.
	MWU_REGIONENCLR_RGN3WA = 0x40
	// Write access watch in this region is disabled
	MWU_REGIONENCLR_RGN3WA_Disabled = 0x0
	// Write access watch in this region is enabled
	MWU_REGIONENCLR_RGN3WA_Enabled = 0x1
	// Disable write access watch in this region
	MWU_REGIONENCLR_RGN3WA_Clear = 0x1
	// Position of RGN3RA field.
	MWU_REGIONENCLR_RGN3RA_Pos = 0x7
	// Bit mask of RGN3RA field.
	MWU_REGIONENCLR_RGN3RA_Msk = 0x80
	// Bit RGN3RA.
	MWU_REGIONENCLR_RGN3RA = 0x80
	// Read access watch in this region is disabled
	MWU_REGIONENCLR_RGN3RA_Disabled = 0x0
	// Read access watch in this region is enabled
	MWU_REGIONENCLR_RGN3RA_Enabled = 0x1
	// Disable read access watch in this region
	MWU_REGIONENCLR_RGN3RA_Clear = 0x1
	// Position of PRGN0WA field.
	MWU_REGIONENCLR_PRGN0WA_Pos = 0x18
	// Bit mask of PRGN0WA field.
	MWU_REGIONENCLR_PRGN0WA_Msk = 0x1000000
	// Bit PRGN0WA.
	MWU_REGIONENCLR_PRGN0WA = 0x1000000
	// Write access watch in this PREGION is disabled
	MWU_REGIONENCLR_PRGN0WA_Disabled = 0x0
	// Write access watch in this PREGION is enabled
	MWU_REGIONENCLR_PRGN0WA_Enabled = 0x1
	// Disable write access watch in this PREGION
	MWU_REGIONENCLR_PRGN0WA_Clear = 0x1
	// Position of PRGN0RA field.
	MWU_REGIONENCLR_PRGN0RA_Pos = 0x19
	// Bit mask of PRGN0RA field.
	MWU_REGIONENCLR_PRGN0RA_Msk = 0x2000000
	// Bit PRGN0RA.
	MWU_REGIONENCLR_PRGN0RA = 0x2000000
	// Read access watch in this PREGION is disabled
	MWU_REGIONENCLR_PRGN0RA_Disabled = 0x0
	// Read access watch in this PREGION is enabled
	MWU_REGIONENCLR_PRGN0RA_Enabled = 0x1
	// Disable read access watch in this PREGION
	MWU_REGIONENCLR_PRGN0RA_Clear = 0x1
	// Position of PRGN1WA field.
	MWU_REGIONENCLR_PRGN1WA_Pos = 0x1a
	// Bit mask of PRGN1WA field.
	MWU_REGIONENCLR_PRGN1WA_Msk = 0x4000000
	// Bit PRGN1WA.
	MWU_REGIONENCLR_PRGN1WA = 0x4000000
	// Write access watch in this PREGION is disabled
	MWU_REGIONENCLR_PRGN1WA_Disabled = 0x0
	// Write access watch in this PREGION is enabled
	MWU_REGIONENCLR_PRGN1WA_Enabled = 0x1
	// Disable write access watch in this PREGION
	MWU_REGIONENCLR_PRGN1WA_Clear = 0x1
	// Position of PRGN1RA field.
	MWU_REGIONENCLR_PRGN1RA_Pos = 0x1b
	// Bit mask of PRGN1RA field.
	MWU_REGIONENCLR_PRGN1RA_Msk = 0x8000000
	// Bit PRGN1RA.
	MWU_REGIONENCLR_PRGN1RA = 0x8000000
	// Read access watch in this PREGION is disabled
	MWU_REGIONENCLR_PRGN1RA_Disabled = 0x0
	// Read access watch in this PREGION is enabled
	MWU_REGIONENCLR_PRGN1RA_Enabled = 0x1
	// Disable read access watch in this PREGION
	MWU_REGIONENCLR_PRGN1RA_Clear = 0x1

	// REGION.START: Description cluster[0]: Start address for region 0
	// Position of START field.
	MWU_REGION_START_START_Pos = 0x0
	// Bit mask of START field.
	MWU_REGION_START_START_Msk = 0xffffffff

	// REGION.END: Description cluster[0]: End address of region 0
	// Position of END field.
	MWU_REGION_END_END_Pos = 0x0
	// Bit mask of END field.
	MWU_REGION_END_END_Msk = 0xffffffff

	// PREGION.START: Description cluster[0]: Reserved for future use
	// Position of START field.
	MWU_PREGION_START_START_Pos = 0x0
	// Bit mask of START field.
	MWU_PREGION_START_START_Msk = 0xffffffff

	// PREGION.END: Description cluster[0]: Reserved for future use
	// Position of END field.
	MWU_PREGION_END_END_Pos = 0x0
	// Bit mask of END field.
	MWU_PREGION_END_END_Msk = 0xffffffff

	// PREGION.SUBS: Description cluster[0]: Subregions of region 0
	// Position of SR0 field.
	MWU_PREGION_SUBS_SR0_Pos = 0x0
	// Bit mask of SR0 field.
	MWU_PREGION_SUBS_SR0_Msk = 0x1
	// Bit SR0.
	MWU_PREGION_SUBS_SR0 = 0x1
	// Exclude
	MWU_PREGION_SUBS_SR0_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR0_Include = 0x1
	// Position of SR1 field.
	MWU_PREGION_SUBS_SR1_Pos = 0x1
	// Bit mask of SR1 field.
	MWU_PREGION_SUBS_SR1_Msk = 0x2
	// Bit SR1.
	MWU_PREGION_SUBS_SR1 = 0x2
	// Exclude
	MWU_PREGION_SUBS_SR1_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR1_Include = 0x1
	// Position of SR2 field.
	MWU_PREGION_SUBS_SR2_Pos = 0x2
	// Bit mask of SR2 field.
	MWU_PREGION_SUBS_SR2_Msk = 0x4
	// Bit SR2.
	MWU_PREGION_SUBS_SR2 = 0x4
	// Exclude
	MWU_PREGION_SUBS_SR2_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR2_Include = 0x1
	// Position of SR3 field.
	MWU_PREGION_SUBS_SR3_Pos = 0x3
	// Bit mask of SR3 field.
	MWU_PREGION_SUBS_SR3_Msk = 0x8
	// Bit SR3.
	MWU_PREGION_SUBS_SR3 = 0x8
	// Exclude
	MWU_PREGION_SUBS_SR3_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR3_Include = 0x1
	// Position of SR4 field.
	MWU_PREGION_SUBS_SR4_Pos = 0x4
	// Bit mask of SR4 field.
	MWU_PREGION_SUBS_SR4_Msk = 0x10
	// Bit SR4.
	MWU_PREGION_SUBS_SR4 = 0x10
	// Exclude
	MWU_PREGION_SUBS_SR4_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR4_Include = 0x1
	// Position of SR5 field.
	MWU_PREGION_SUBS_SR5_Pos = 0x5
	// Bit mask of SR5 field.
	MWU_PREGION_SUBS_SR5_Msk = 0x20
	// Bit SR5.
	MWU_PREGION_SUBS_SR5 = 0x20
	// Exclude
	MWU_PREGION_SUBS_SR5_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR5_Include = 0x1
	// Position of SR6 field.
	MWU_PREGION_SUBS_SR6_Pos = 0x6
	// Bit mask of SR6 field.
	MWU_PREGION_SUBS_SR6_Msk = 0x40
	// Bit SR6.
	MWU_PREGION_SUBS_SR6 = 0x40
	// Exclude
	MWU_PREGION_SUBS_SR6_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR6_Include = 0x1
	// Position of SR7 field.
	MWU_PREGION_SUBS_SR7_Pos = 0x7
	// Bit mask of SR7 field.
	MWU_PREGION_SUBS_SR7_Msk = 0x80
	// Bit SR7.
	MWU_PREGION_SUBS_SR7 = 0x80
	// Exclude
	MWU_PREGION_SUBS_SR7_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR7_Include = 0x1
	// Position of SR8 field.
	MWU_PREGION_SUBS_SR8_Pos = 0x8
	// Bit mask of SR8 field.
	MWU_PREGION_SUBS_SR8_Msk = 0x100
	// Bit SR8.
	MWU_PREGION_SUBS_SR8 = 0x100
	// Exclude
	MWU_PREGION_SUBS_SR8_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR8_Include = 0x1
	// Position of SR9 field.
	MWU_PREGION_SUBS_SR9_Pos = 0x9
	// Bit mask of SR9 field.
	MWU_PREGION_SUBS_SR9_Msk = 0x200
	// Bit SR9.
	MWU_PREGION_SUBS_SR9 = 0x200
	// Exclude
	MWU_PREGION_SUBS_SR9_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR9_Include = 0x1
	// Position of SR10 field.
	MWU_PREGION_SUBS_SR10_Pos = 0xa
	// Bit mask of SR10 field.
	MWU_PREGION_SUBS_SR10_Msk = 0x400
	// Bit SR10.
	MWU_PREGION_SUBS_SR10 = 0x400
	// Exclude
	MWU_PREGION_SUBS_SR10_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR10_Include = 0x1
	// Position of SR11 field.
	MWU_PREGION_SUBS_SR11_Pos = 0xb
	// Bit mask of SR11 field.
	MWU_PREGION_SUBS_SR11_Msk = 0x800
	// Bit SR11.
	MWU_PREGION_SUBS_SR11 = 0x800
	// Exclude
	MWU_PREGION_SUBS_SR11_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR11_Include = 0x1
	// Position of SR12 field.
	MWU_PREGION_SUBS_SR12_Pos = 0xc
	// Bit mask of SR12 field.
	MWU_PREGION_SUBS_SR12_Msk = 0x1000
	// Bit SR12.
	MWU_PREGION_SUBS_SR12 = 0x1000
	// Exclude
	MWU_PREGION_SUBS_SR12_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR12_Include = 0x1
	// Position of SR13 field.
	MWU_PREGION_SUBS_SR13_Pos = 0xd
	// Bit mask of SR13 field.
	MWU_PREGION_SUBS_SR13_Msk = 0x2000
	// Bit SR13.
	MWU_PREGION_SUBS_SR13 = 0x2000
	// Exclude
	MWU_PREGION_SUBS_SR13_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR13_Include = 0x1
	// Position of SR14 field.
	MWU_PREGION_SUBS_SR14_Pos = 0xe
	// Bit mask of SR14 field.
	MWU_PREGION_SUBS_SR14_Msk = 0x4000
	// Bit SR14.
	MWU_PREGION_SUBS_SR14 = 0x4000
	// Exclude
	MWU_PREGION_SUBS_SR14_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR14_Include = 0x1
	// Position of SR15 field.
	MWU_PREGION_SUBS_SR15_Pos = 0xf
	// Bit mask of SR15 field.
	MWU_PREGION_SUBS_SR15_Msk = 0x8000
	// Bit SR15.
	MWU_PREGION_SUBS_SR15 = 0x8000
	// Exclude
	MWU_PREGION_SUBS_SR15_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR15_Include = 0x1
	// Position of SR16 field.
	MWU_PREGION_SUBS_SR16_Pos = 0x10
	// Bit mask of SR16 field.
	MWU_PREGION_SUBS_SR16_Msk = 0x10000
	// Bit SR16.
	MWU_PREGION_SUBS_SR16 = 0x10000
	// Exclude
	MWU_PREGION_SUBS_SR16_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR16_Include = 0x1
	// Position of SR17 field.
	MWU_PREGION_SUBS_SR17_Pos = 0x11
	// Bit mask of SR17 field.
	MWU_PREGION_SUBS_SR17_Msk = 0x20000
	// Bit SR17.
	MWU_PREGION_SUBS_SR17 = 0x20000
	// Exclude
	MWU_PREGION_SUBS_SR17_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR17_Include = 0x1
	// Position of SR18 field.
	MWU_PREGION_SUBS_SR18_Pos = 0x12
	// Bit mask of SR18 field.
	MWU_PREGION_SUBS_SR18_Msk = 0x40000
	// Bit SR18.
	MWU_PREGION_SUBS_SR18 = 0x40000
	// Exclude
	MWU_PREGION_SUBS_SR18_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR18_Include = 0x1
	// Position of SR19 field.
	MWU_PREGION_SUBS_SR19_Pos = 0x13
	// Bit mask of SR19 field.
	MWU_PREGION_SUBS_SR19_Msk = 0x80000
	// Bit SR19.
	MWU_PREGION_SUBS_SR19 = 0x80000
	// Exclude
	MWU_PREGION_SUBS_SR19_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR19_Include = 0x1
	// Position of SR20 field.
	MWU_PREGION_SUBS_SR20_Pos = 0x14
	// Bit mask of SR20 field.
	MWU_PREGION_SUBS_SR20_Msk = 0x100000
	// Bit SR20.
	MWU_PREGION_SUBS_SR20 = 0x100000
	// Exclude
	MWU_PREGION_SUBS_SR20_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR20_Include = 0x1
	// Position of SR21 field.
	MWU_PREGION_SUBS_SR21_Pos = 0x15
	// Bit mask of SR21 field.
	MWU_PREGION_SUBS_SR21_Msk = 0x200000
	// Bit SR21.
	MWU_PREGION_SUBS_SR21 = 0x200000
	// Exclude
	MWU_PREGION_SUBS_SR21_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR21_Include = 0x1
	// Position of SR22 field.
	MWU_PREGION_SUBS_SR22_Pos = 0x16
	// Bit mask of SR22 field.
	MWU_PREGION_SUBS_SR22_Msk = 0x400000
	// Bit SR22.
	MWU_PREGION_SUBS_SR22 = 0x400000
	// Exclude
	MWU_PREGION_SUBS_SR22_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR22_Include = 0x1
	// Position of SR23 field.
	MWU_PREGION_SUBS_SR23_Pos = 0x17
	// Bit mask of SR23 field.
	MWU_PREGION_SUBS_SR23_Msk = 0x800000
	// Bit SR23.
	MWU_PREGION_SUBS_SR23 = 0x800000
	// Exclude
	MWU_PREGION_SUBS_SR23_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR23_Include = 0x1
	// Position of SR24 field.
	MWU_PREGION_SUBS_SR24_Pos = 0x18
	// Bit mask of SR24 field.
	MWU_PREGION_SUBS_SR24_Msk = 0x1000000
	// Bit SR24.
	MWU_PREGION_SUBS_SR24 = 0x1000000
	// Exclude
	MWU_PREGION_SUBS_SR24_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR24_Include = 0x1
	// Position of SR25 field.
	MWU_PREGION_SUBS_SR25_Pos = 0x19
	// Bit mask of SR25 field.
	MWU_PREGION_SUBS_SR25_Msk = 0x2000000
	// Bit SR25.
	MWU_PREGION_SUBS_SR25 = 0x2000000
	// Exclude
	MWU_PREGION_SUBS_SR25_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR25_Include = 0x1
	// Position of SR26 field.
	MWU_PREGION_SUBS_SR26_Pos = 0x1a
	// Bit mask of SR26 field.
	MWU_PREGION_SUBS_SR26_Msk = 0x4000000
	// Bit SR26.
	MWU_PREGION_SUBS_SR26 = 0x4000000
	// Exclude
	MWU_PREGION_SUBS_SR26_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR26_Include = 0x1
	// Position of SR27 field.
	MWU_PREGION_SUBS_SR27_Pos = 0x1b
	// Bit mask of SR27 field.
	MWU_PREGION_SUBS_SR27_Msk = 0x8000000
	// Bit SR27.
	MWU_PREGION_SUBS_SR27 = 0x8000000
	// Exclude
	MWU_PREGION_SUBS_SR27_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR27_Include = 0x1
	// Position of SR28 field.
	MWU_PREGION_SUBS_SR28_Pos = 0x1c
	// Bit mask of SR28 field.
	MWU_PREGION_SUBS_SR28_Msk = 0x10000000
	// Bit SR28.
	MWU_PREGION_SUBS_SR28 = 0x10000000
	// Exclude
	MWU_PREGION_SUBS_SR28_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR28_Include = 0x1
	// Position of SR29 field.
	MWU_PREGION_SUBS_SR29_Pos = 0x1d
	// Bit mask of SR29 field.
	MWU_PREGION_SUBS_SR29_Msk = 0x20000000
	// Bit SR29.
	MWU_PREGION_SUBS_SR29 = 0x20000000
	// Exclude
	MWU_PREGION_SUBS_SR29_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR29_Include = 0x1
	// Position of SR30 field.
	MWU_PREGION_SUBS_SR30_Pos = 0x1e
	// Bit mask of SR30 field.
	MWU_PREGION_SUBS_SR30_Msk = 0x40000000
	// Bit SR30.
	MWU_PREGION_SUBS_SR30 = 0x40000000
	// Exclude
	MWU_PREGION_SUBS_SR30_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR30_Include = 0x1
	// Position of SR31 field.
	MWU_PREGION_SUBS_SR31_Pos = 0x1f
	// Bit mask of SR31 field.
	MWU_PREGION_SUBS_SR31_Msk = 0x80000000
	// Bit SR31.
	MWU_PREGION_SUBS_SR31 = 0x80000000
	// Exclude
	MWU_PREGION_SUBS_SR31_Exclude = 0x0
	// Include
	MWU_PREGION_SUBS_SR31_Include = 0x1
)

// Constants for I2S: Inter-IC Sound
const (
	// INTEN: Enable or disable interrupt
	// Position of RXPTRUPD field.
	I2S_INTEN_RXPTRUPD_Pos = 0x1
	// Bit mask of RXPTRUPD field.
	I2S_INTEN_RXPTRUPD_Msk = 0x2
	// Bit RXPTRUPD.
	I2S_INTEN_RXPTRUPD = 0x2
	// Disable
	I2S_INTEN_RXPTRUPD_Disabled = 0x0
	// Enable
	I2S_INTEN_RXPTRUPD_Enabled = 0x1
	// Position of STOPPED field.
	I2S_INTEN_STOPPED_Pos = 0x2
	// Bit mask of STOPPED field.
	I2S_INTEN_STOPPED_Msk = 0x4
	// Bit STOPPED.
	I2S_INTEN_STOPPED = 0x4
	// Disable
	I2S_INTEN_STOPPED_Disabled = 0x0
	// Enable
	I2S_INTEN_STOPPED_Enabled = 0x1
	// Position of TXPTRUPD field.
	I2S_INTEN_TXPTRUPD_Pos = 0x5
	// Bit mask of TXPTRUPD field.
	I2S_INTEN_TXPTRUPD_Msk = 0x20
	// Bit TXPTRUPD.
	I2S_INTEN_TXPTRUPD = 0x20
	// Disable
	I2S_INTEN_TXPTRUPD_Disabled = 0x0
	// Enable
	I2S_INTEN_TXPTRUPD_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of RXPTRUPD field.
	I2S_INTENSET_RXPTRUPD_Pos = 0x1
	// Bit mask of RXPTRUPD field.
	I2S_INTENSET_RXPTRUPD_Msk = 0x2
	// Bit RXPTRUPD.
	I2S_INTENSET_RXPTRUPD = 0x2
	// Read: Disabled
	I2S_INTENSET_RXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_RXPTRUPD_Enabled = 0x1
	// Enable
	I2S_INTENSET_RXPTRUPD_Set = 0x1
	// Position of STOPPED field.
	I2S_INTENSET_STOPPED_Pos = 0x2
	// Bit mask of STOPPED field.
	I2S_INTENSET_STOPPED_Msk = 0x4
	// Bit STOPPED.
	I2S_INTENSET_STOPPED = 0x4
	// Read: Disabled
	I2S_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	I2S_INTENSET_STOPPED_Set = 0x1
	// Position of TXPTRUPD field.
	I2S_INTENSET_TXPTRUPD_Pos = 0x5
	// Bit mask of TXPTRUPD field.
	I2S_INTENSET_TXPTRUPD_Msk = 0x20
	// Bit TXPTRUPD.
	I2S_INTENSET_TXPTRUPD = 0x20
	// Read: Disabled
	I2S_INTENSET_TXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_TXPTRUPD_Enabled = 0x1
	// Enable
	I2S_INTENSET_TXPTRUPD_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of RXPTRUPD field.
	I2S_INTENCLR_RXPTRUPD_Pos = 0x1
	// Bit mask of RXPTRUPD field.
	I2S_INTENCLR_RXPTRUPD_Msk = 0x2
	// Bit RXPTRUPD.
	I2S_INTENCLR_RXPTRUPD = 0x2
	// Read: Disabled
	I2S_INTENCLR_RXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_RXPTRUPD_Enabled = 0x1
	// Disable
	I2S_INTENCLR_RXPTRUPD_Clear = 0x1
	// Position of STOPPED field.
	I2S_INTENCLR_STOPPED_Pos = 0x2
	// Bit mask of STOPPED field.
	I2S_INTENCLR_STOPPED_Msk = 0x4
	// Bit STOPPED.
	I2S_INTENCLR_STOPPED = 0x4
	// Read: Disabled
	I2S_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	I2S_INTENCLR_STOPPED_Clear = 0x1
	// Position of TXPTRUPD field.
	I2S_INTENCLR_TXPTRUPD_Pos = 0x5
	// Bit mask of TXPTRUPD field.
	I2S_INTENCLR_TXPTRUPD_Msk = 0x20
	// Bit TXPTRUPD.
	I2S_INTENCLR_TXPTRUPD = 0x20
	// Read: Disabled
	I2S_INTENCLR_TXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_TXPTRUPD_Enabled = 0x1
	// Disable
	I2S_INTENCLR_TXPTRUPD_Clear = 0x1

	// ENABLE: Enable I2S module.
	// Position of ENABLE field.
	I2S_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	I2S_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	I2S_ENABLE_ENABLE = 0x1
	// Disable
	I2S_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	I2S_ENABLE_ENABLE_Enabled = 0x1

	// CONFIG.MODE: I2S mode.
	// Position of MODE field.
	I2S_CONFIG_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	I2S_CONFIG_MODE_MODE_Msk = 0x1
	// Bit MODE.
	I2S_CONFIG_MODE_MODE = 0x1
	// Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx.
	I2S_CONFIG_MODE_MODE_Master = 0x0
	// Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx
	I2S_CONFIG_MODE_MODE_Slave = 0x1

	// CONFIG.RXEN: Reception (RX) enable.
	// Position of RXEN field.
	I2S_CONFIG_RXEN_RXEN_Pos = 0x0
	// Bit mask of RXEN field.
	I2S_CONFIG_RXEN_RXEN_Msk = 0x1
	// Bit RXEN.
	I2S_CONFIG_RXEN_RXEN = 0x1
	// Reception disabled and now data will be written to the RXD.PTR address.
	I2S_CONFIG_RXEN_RXEN_Disabled = 0x0
	// Reception enabled.
	I2S_CONFIG_RXEN_RXEN_Enabled = 0x1

	// CONFIG.TXEN: Transmission (TX) enable.
	// Position of TXEN field.
	I2S_CONFIG_TXEN_TXEN_Pos = 0x0
	// Bit mask of TXEN field.
	I2S_CONFIG_TXEN_TXEN_Msk = 0x1
	// Bit TXEN.
	I2S_CONFIG_TXEN_TXEN = 0x1
	// Transmission disabled and now data will be read from the RXD.TXD address.
	I2S_CONFIG_TXEN_TXEN_Disabled = 0x0
	// Transmission enabled.
	I2S_CONFIG_TXEN_TXEN_Enabled = 0x1

	// CONFIG.MCKEN: Master clock generator enable.
	// Position of MCKEN field.
	I2S_CONFIG_MCKEN_MCKEN_Pos = 0x0
	// Bit mask of MCKEN field.
	I2S_CONFIG_MCKEN_MCKEN_Msk = 0x1
	// Bit MCKEN.
	I2S_CONFIG_MCKEN_MCKEN = 0x1
	// Master clock generator disabled and PSEL.MCK not connected(available as GPIO).
	I2S_CONFIG_MCKEN_MCKEN_Disabled = 0x0
	// Master clock generator running and MCK output on PSEL.MCK.
	I2S_CONFIG_MCKEN_MCKEN_Enabled = 0x1

	// CONFIG.MCKFREQ: Master clock generator frequency.
	// Position of MCKFREQ field.
	I2S_CONFIG_MCKFREQ_MCKFREQ_Pos = 0x0
	// Bit mask of MCKFREQ field.
	I2S_CONFIG_MCKFREQ_MCKFREQ_Msk = 0xffffffff
	// 32 MHz / 2 = 16.0 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2 = 0x80000000
	// 32 MHz / 3 = 10.6666667 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3 = 0x50000000
	// 32 MHz / 4 = 8.0 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4 = 0x40000000
	// 32 MHz / 5 = 6.4 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5 = 0x30000000
	// 32 MHz / 6 = 5.3333333 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6 = 0x28000000
	// 32 MHz / 8 = 4.0 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8 = 0x20000000
	// 32 MHz / 10 = 3.2 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10 = 0x18000000
	// 32 MHz / 11 = 2.9090909 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11 = 0x16000000
	// 32 MHz / 15 = 2.1333333 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15 = 0x11000000
	// 32 MHz / 16 = 2.0 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16 = 0x10000000
	// 32 MHz / 21 = 1.5238095
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21 = 0xc000000
	// 32 MHz / 23 = 1.3913043 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23 = 0xb000000
	// 32 MHz / 30 = 1.0666667 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30 = 0x8800000
	// 32 MHz / 31 = 1.0322581 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31 = 0x8400000
	// 32 MHz / 32 = 1.0 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32 = 0x8000000
	// 32 MHz / 42 = 0.7619048 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42 = 0x6000000
	// 32 MHz / 63 = 0.5079365 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63 = 0x4100000
	// 32 MHz / 125 = 0.256 MHz
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125 = 0x20c0000

	// CONFIG.RATIO: MCK / LRCK ratio.
	// Position of RATIO field.
	I2S_CONFIG_RATIO_RATIO_Pos = 0x0
	// Bit mask of RATIO field.
	I2S_CONFIG_RATIO_RATIO_Msk = 0xf
	// LRCK = MCK / 32
	I2S_CONFIG_RATIO_RATIO_32X = 0x0
	// LRCK = MCK / 48
	I2S_CONFIG_RATIO_RATIO_48X = 0x1
	// LRCK = MCK / 64
	I2S_CONFIG_RATIO_RATIO_64X = 0x2
	// LRCK = MCK / 96
	I2S_CONFIG_RATIO_RATIO_96X = 0x3
	// LRCK = MCK / 128
	I2S_CONFIG_RATIO_RATIO_128X = 0x4
	// LRCK = MCK / 192
	I2S_CONFIG_RATIO_RATIO_192X = 0x5
	// LRCK = MCK / 256
	I2S_CONFIG_RATIO_RATIO_256X = 0x6
	// LRCK = MCK / 384
	I2S_CONFIG_RATIO_RATIO_384X = 0x7
	// LRCK = MCK / 512
	I2S_CONFIG_RATIO_RATIO_512X = 0x8

	// CONFIG.SWIDTH: Sample width.
	// Position of SWIDTH field.
	I2S_CONFIG_SWIDTH_SWIDTH_Pos = 0x0
	// Bit mask of SWIDTH field.
	I2S_CONFIG_SWIDTH_SWIDTH_Msk = 0x3
	// 8 bit.
	I2S_CONFIG_SWIDTH_SWIDTH_8Bit = 0x0
	// 16 bit.
	I2S_CONFIG_SWIDTH_SWIDTH_16Bit = 0x1
	// 24 bit.
	I2S_CONFIG_SWIDTH_SWIDTH_24Bit = 0x2

	// CONFIG.ALIGN: Alignment of sample within a frame.
	// Position of ALIGN field.
	I2S_CONFIG_ALIGN_ALIGN_Pos = 0x0
	// Bit mask of ALIGN field.
	I2S_CONFIG_ALIGN_ALIGN_Msk = 0x1
	// Bit ALIGN.
	I2S_CONFIG_ALIGN_ALIGN = 0x1
	// Left-aligned.
	I2S_CONFIG_ALIGN_ALIGN_Left = 0x0
	// Right-aligned.
	I2S_CONFIG_ALIGN_ALIGN_Right = 0x1

	// CONFIG.FORMAT: Frame format.
	// Position of FORMAT field.
	I2S_CONFIG_FORMAT_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	I2S_CONFIG_FORMAT_FORMAT_Msk = 0x1
	// Bit FORMAT.
	I2S_CONFIG_FORMAT_FORMAT = 0x1
	// Original I2S format.
	I2S_CONFIG_FORMAT_FORMAT_I2S = 0x0
	// Alternate (left- or right-aligned) format.
	I2S_CONFIG_FORMAT_FORMAT_Aligned = 0x1

	// CONFIG.CHANNELS: Enable channels.
	// Position of CHANNELS field.
	I2S_CONFIG_CHANNELS_CHANNELS_Pos = 0x0
	// Bit mask of CHANNELS field.
	I2S_CONFIG_CHANNELS_CHANNELS_Msk = 0x3
	// Stereo.
	I2S_CONFIG_CHANNELS_CHANNELS_Stereo = 0x0
	// Left only.
	I2S_CONFIG_CHANNELS_CHANNELS_Left = 0x1
	// Right only.
	I2S_CONFIG_CHANNELS_CHANNELS_Right = 0x2

	// RXD.PTR: Receive buffer RAM start address.
	// Position of PTR field.
	I2S_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	I2S_RXD_PTR_PTR_Msk = 0xffffffff

	// TXD.PTR: Transmit buffer RAM start address.
	// Position of PTR field.
	I2S_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	I2S_TXD_PTR_PTR_Msk = 0xffffffff

	// RXTXD.MAXCNT: Size of RXD and TXD buffers.
	// Position of MAXCNT field.
	I2S_RXTXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	I2S_RXTXD_MAXCNT_MAXCNT_Msk = 0x3fff

	// PSEL.MCK: Pin select for MCK signal.
	// Position of PIN field.
	I2S_PSEL_MCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_MCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	I2S_PSEL_MCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_MCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_MCK_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_MCK_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_MCK_CONNECT_Connected = 0x0

	// PSEL.SCK: Pin select for SCK signal.
	// Position of PIN field.
	I2S_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_SCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	I2S_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.LRCK: Pin select for LRCK signal.
	// Position of PIN field.
	I2S_PSEL_LRCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_LRCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	I2S_PSEL_LRCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_LRCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_LRCK_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_LRCK_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_LRCK_CONNECT_Connected = 0x0

	// PSEL.SDIN: Pin select for SDIN signal.
	// Position of PIN field.
	I2S_PSEL_SDIN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_SDIN_PIN_Msk = 0x1f
	// Position of CONNECT field.
	I2S_PSEL_SDIN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_SDIN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_SDIN_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_SDIN_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_SDIN_CONNECT_Connected = 0x0

	// PSEL.SDOUT: Pin select for SDOUT signal.
	// Position of PIN field.
	I2S_PSEL_SDOUT_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_SDOUT_PIN_Msk = 0x1f
	// Position of CONNECT field.
	I2S_PSEL_SDOUT_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_SDOUT_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_SDOUT_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_SDOUT_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_SDOUT_CONNECT_Connected = 0x0
)

// Constants for FPU: FPU
const ()

// Constants for P0: GPIO Port 1
const (
	// OUT: Write GPIO port
	// Position of PIN0 field.
	GPIO_OUT_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUT_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUT_PIN0 = 0x1
	// Pin driver is low
	GPIO_OUT_PIN0_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN0_High = 0x1
	// Position of PIN1 field.
	GPIO_OUT_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUT_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUT_PIN1 = 0x2
	// Pin driver is low
	GPIO_OUT_PIN1_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN1_High = 0x1
	// Position of PIN2 field.
	GPIO_OUT_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUT_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUT_PIN2 = 0x4
	// Pin driver is low
	GPIO_OUT_PIN2_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN2_High = 0x1
	// Position of PIN3 field.
	GPIO_OUT_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUT_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUT_PIN3 = 0x8
	// Pin driver is low
	GPIO_OUT_PIN3_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN3_High = 0x1
	// Position of PIN4 field.
	GPIO_OUT_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUT_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUT_PIN4 = 0x10
	// Pin driver is low
	GPIO_OUT_PIN4_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN4_High = 0x1
	// Position of PIN5 field.
	GPIO_OUT_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUT_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUT_PIN5 = 0x20
	// Pin driver is low
	GPIO_OUT_PIN5_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN5_High = 0x1
	// Position of PIN6 field.
	GPIO_OUT_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUT_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUT_PIN6 = 0x40
	// Pin driver is low
	GPIO_OUT_PIN6_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN6_High = 0x1
	// Position of PIN7 field.
	GPIO_OUT_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUT_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUT_PIN7 = 0x80
	// Pin driver is low
	GPIO_OUT_PIN7_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN7_High = 0x1
	// Position of PIN8 field.
	GPIO_OUT_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUT_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUT_PIN8 = 0x100
	// Pin driver is low
	GPIO_OUT_PIN8_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN8_High = 0x1
	// Position of PIN9 field.
	GPIO_OUT_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUT_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUT_PIN9 = 0x200
	// Pin driver is low
	GPIO_OUT_PIN9_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN9_High = 0x1
	// Position of PIN10 field.
	GPIO_OUT_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUT_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUT_PIN10 = 0x400
	// Pin driver is low
	GPIO_OUT_PIN10_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN10_High = 0x1
	// Position of PIN11 field.
	GPIO_OUT_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUT_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUT_PIN11 = 0x800
	// Pin driver is low
	GPIO_OUT_PIN11_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN11_High = 0x1
	// Position of PIN12 field.
	GPIO_OUT_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUT_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUT_PIN12 = 0x1000
	// Pin driver is low
	GPIO_OUT_PIN12_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN12_High = 0x1
	// Position of PIN13 field.
	GPIO_OUT_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUT_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUT_PIN13 = 0x2000
	// Pin driver is low
	GPIO_OUT_PIN13_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN13_High = 0x1
	// Position of PIN14 field.
	GPIO_OUT_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUT_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUT_PIN14 = 0x4000
	// Pin driver is low
	GPIO_OUT_PIN14_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN14_High = 0x1
	// Position of PIN15 field.
	GPIO_OUT_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUT_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUT_PIN15 = 0x8000
	// Pin driver is low
	GPIO_OUT_PIN15_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN15_High = 0x1
	// Position of PIN16 field.
	GPIO_OUT_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUT_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUT_PIN16 = 0x10000
	// Pin driver is low
	GPIO_OUT_PIN16_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN16_High = 0x1
	// Position of PIN17 field.
	GPIO_OUT_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUT_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUT_PIN17 = 0x20000
	// Pin driver is low
	GPIO_OUT_PIN17_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN17_High = 0x1
	// Position of PIN18 field.
	GPIO_OUT_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUT_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUT_PIN18 = 0x40000
	// Pin driver is low
	GPIO_OUT_PIN18_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN18_High = 0x1
	// Position of PIN19 field.
	GPIO_OUT_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUT_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUT_PIN19 = 0x80000
	// Pin driver is low
	GPIO_OUT_PIN19_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN19_High = 0x1
	// Position of PIN20 field.
	GPIO_OUT_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUT_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUT_PIN20 = 0x100000
	// Pin driver is low
	GPIO_OUT_PIN20_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN20_High = 0x1
	// Position of PIN21 field.
	GPIO_OUT_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUT_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUT_PIN21 = 0x200000
	// Pin driver is low
	GPIO_OUT_PIN21_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN21_High = 0x1
	// Position of PIN22 field.
	GPIO_OUT_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUT_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUT_PIN22 = 0x400000
	// Pin driver is low
	GPIO_OUT_PIN22_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN22_High = 0x1
	// Position of PIN23 field.
	GPIO_OUT_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUT_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUT_PIN23 = 0x800000
	// Pin driver is low
	GPIO_OUT_PIN23_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN23_High = 0x1
	// Position of PIN24 field.
	GPIO_OUT_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUT_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUT_PIN24 = 0x1000000
	// Pin driver is low
	GPIO_OUT_PIN24_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN24_High = 0x1
	// Position of PIN25 field.
	GPIO_OUT_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUT_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUT_PIN25 = 0x2000000
	// Pin driver is low
	GPIO_OUT_PIN25_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN25_High = 0x1
	// Position of PIN26 field.
	GPIO_OUT_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUT_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUT_PIN26 = 0x4000000
	// Pin driver is low
	GPIO_OUT_PIN26_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN26_High = 0x1
	// Position of PIN27 field.
	GPIO_OUT_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUT_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUT_PIN27 = 0x8000000
	// Pin driver is low
	GPIO_OUT_PIN27_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN27_High = 0x1
	// Position of PIN28 field.
	GPIO_OUT_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUT_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUT_PIN28 = 0x10000000
	// Pin driver is low
	GPIO_OUT_PIN28_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN28_High = 0x1
	// Position of PIN29 field.
	GPIO_OUT_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUT_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUT_PIN29 = 0x20000000
	// Pin driver is low
	GPIO_OUT_PIN29_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN29_High = 0x1
	// Position of PIN30 field.
	GPIO_OUT_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUT_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUT_PIN30 = 0x40000000
	// Pin driver is low
	GPIO_OUT_PIN30_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN30_High = 0x1
	// Position of PIN31 field.
	GPIO_OUT_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUT_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUT_PIN31 = 0x80000000
	// Pin driver is low
	GPIO_OUT_PIN31_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN31_High = 0x1

	// OUTSET: Set individual bits in GPIO port
	// Position of PIN0 field.
	GPIO_OUTSET_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUTSET_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUTSET_PIN0 = 0x1
	// Read: pin driver is low
	GPIO_OUTSET_PIN0_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN0_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN0_Set = 0x1
	// Position of PIN1 field.
	GPIO_OUTSET_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUTSET_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUTSET_PIN1 = 0x2
	// Read: pin driver is low
	GPIO_OUTSET_PIN1_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN1_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN1_Set = 0x1
	// Position of PIN2 field.
	GPIO_OUTSET_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUTSET_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUTSET_PIN2 = 0x4
	// Read: pin driver is low
	GPIO_OUTSET_PIN2_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN2_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN2_Set = 0x1
	// Position of PIN3 field.
	GPIO_OUTSET_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUTSET_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUTSET_PIN3 = 0x8
	// Read: pin driver is low
	GPIO_OUTSET_PIN3_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN3_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN3_Set = 0x1
	// Position of PIN4 field.
	GPIO_OUTSET_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUTSET_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUTSET_PIN4 = 0x10
	// Read: pin driver is low
	GPIO_OUTSET_PIN4_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN4_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN4_Set = 0x1
	// Position of PIN5 field.
	GPIO_OUTSET_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUTSET_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUTSET_PIN5 = 0x20
	// Read: pin driver is low
	GPIO_OUTSET_PIN5_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN5_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN5_Set = 0x1
	// Position of PIN6 field.
	GPIO_OUTSET_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUTSET_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUTSET_PIN6 = 0x40
	// Read: pin driver is low
	GPIO_OUTSET_PIN6_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN6_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN6_Set = 0x1
	// Position of PIN7 field.
	GPIO_OUTSET_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUTSET_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUTSET_PIN7 = 0x80
	// Read: pin driver is low
	GPIO_OUTSET_PIN7_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN7_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN7_Set = 0x1
	// Position of PIN8 field.
	GPIO_OUTSET_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUTSET_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUTSET_PIN8 = 0x100
	// Read: pin driver is low
	GPIO_OUTSET_PIN8_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN8_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN8_Set = 0x1
	// Position of PIN9 field.
	GPIO_OUTSET_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUTSET_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUTSET_PIN9 = 0x200
	// Read: pin driver is low
	GPIO_OUTSET_PIN9_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN9_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN9_Set = 0x1
	// Position of PIN10 field.
	GPIO_OUTSET_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUTSET_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUTSET_PIN10 = 0x400
	// Read: pin driver is low
	GPIO_OUTSET_PIN10_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN10_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN10_Set = 0x1
	// Position of PIN11 field.
	GPIO_OUTSET_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUTSET_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUTSET_PIN11 = 0x800
	// Read: pin driver is low
	GPIO_OUTSET_PIN11_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN11_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN11_Set = 0x1
	// Position of PIN12 field.
	GPIO_OUTSET_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUTSET_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUTSET_PIN12 = 0x1000
	// Read: pin driver is low
	GPIO_OUTSET_PIN12_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN12_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN12_Set = 0x1
	// Position of PIN13 field.
	GPIO_OUTSET_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUTSET_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUTSET_PIN13 = 0x2000
	// Read: pin driver is low
	GPIO_OUTSET_PIN13_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN13_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN13_Set = 0x1
	// Position of PIN14 field.
	GPIO_OUTSET_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUTSET_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUTSET_PIN14 = 0x4000
	// Read: pin driver is low
	GPIO_OUTSET_PIN14_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN14_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN14_Set = 0x1
	// Position of PIN15 field.
	GPIO_OUTSET_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUTSET_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUTSET_PIN15 = 0x8000
	// Read: pin driver is low
	GPIO_OUTSET_PIN15_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN15_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN15_Set = 0x1
	// Position of PIN16 field.
	GPIO_OUTSET_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUTSET_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUTSET_PIN16 = 0x10000
	// Read: pin driver is low
	GPIO_OUTSET_PIN16_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN16_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN16_Set = 0x1
	// Position of PIN17 field.
	GPIO_OUTSET_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUTSET_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUTSET_PIN17 = 0x20000
	// Read: pin driver is low
	GPIO_OUTSET_PIN17_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN17_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN17_Set = 0x1
	// Position of PIN18 field.
	GPIO_OUTSET_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUTSET_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUTSET_PIN18 = 0x40000
	// Read: pin driver is low
	GPIO_OUTSET_PIN18_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN18_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN18_Set = 0x1
	// Position of PIN19 field.
	GPIO_OUTSET_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUTSET_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUTSET_PIN19 = 0x80000
	// Read: pin driver is low
	GPIO_OUTSET_PIN19_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN19_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN19_Set = 0x1
	// Position of PIN20 field.
	GPIO_OUTSET_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUTSET_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUTSET_PIN20 = 0x100000
	// Read: pin driver is low
	GPIO_OUTSET_PIN20_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN20_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN20_Set = 0x1
	// Position of PIN21 field.
	GPIO_OUTSET_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUTSET_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUTSET_PIN21 = 0x200000
	// Read: pin driver is low
	GPIO_OUTSET_PIN21_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN21_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN21_Set = 0x1
	// Position of PIN22 field.
	GPIO_OUTSET_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUTSET_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUTSET_PIN22 = 0x400000
	// Read: pin driver is low
	GPIO_OUTSET_PIN22_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN22_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN22_Set = 0x1
	// Position of PIN23 field.
	GPIO_OUTSET_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUTSET_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUTSET_PIN23 = 0x800000
	// Read: pin driver is low
	GPIO_OUTSET_PIN23_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN23_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN23_Set = 0x1
	// Position of PIN24 field.
	GPIO_OUTSET_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUTSET_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUTSET_PIN24 = 0x1000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN24_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN24_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN24_Set = 0x1
	// Position of PIN25 field.
	GPIO_OUTSET_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUTSET_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUTSET_PIN25 = 0x2000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN25_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN25_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN25_Set = 0x1
	// Position of PIN26 field.
	GPIO_OUTSET_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUTSET_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUTSET_PIN26 = 0x4000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN26_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN26_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN26_Set = 0x1
	// Position of PIN27 field.
	GPIO_OUTSET_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUTSET_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUTSET_PIN27 = 0x8000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN27_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN27_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN27_Set = 0x1
	// Position of PIN28 field.
	GPIO_OUTSET_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUTSET_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUTSET_PIN28 = 0x10000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN28_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN28_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN28_Set = 0x1
	// Position of PIN29 field.
	GPIO_OUTSET_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUTSET_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUTSET_PIN29 = 0x20000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN29_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN29_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN29_Set = 0x1
	// Position of PIN30 field.
	GPIO_OUTSET_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUTSET_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUTSET_PIN30 = 0x40000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN30_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN30_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN30_Set = 0x1
	// Position of PIN31 field.
	GPIO_OUTSET_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUTSET_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUTSET_PIN31 = 0x80000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN31_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN31_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN31_Set = 0x1

	// OUTCLR: Clear individual bits in GPIO port
	// Position of PIN0 field.
	GPIO_OUTCLR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUTCLR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUTCLR_PIN0 = 0x1
	// Read: pin driver is low
	GPIO_OUTCLR_PIN0_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN0_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN0_Clear = 0x1
	// Position of PIN1 field.
	GPIO_OUTCLR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUTCLR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUTCLR_PIN1 = 0x2
	// Read: pin driver is low
	GPIO_OUTCLR_PIN1_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN1_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN1_Clear = 0x1
	// Position of PIN2 field.
	GPIO_OUTCLR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUTCLR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUTCLR_PIN2 = 0x4
	// Read: pin driver is low
	GPIO_OUTCLR_PIN2_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN2_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN2_Clear = 0x1
	// Position of PIN3 field.
	GPIO_OUTCLR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUTCLR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUTCLR_PIN3 = 0x8
	// Read: pin driver is low
	GPIO_OUTCLR_PIN3_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN3_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN3_Clear = 0x1
	// Position of PIN4 field.
	GPIO_OUTCLR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUTCLR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUTCLR_PIN4 = 0x10
	// Read: pin driver is low
	GPIO_OUTCLR_PIN4_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN4_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN4_Clear = 0x1
	// Position of PIN5 field.
	GPIO_OUTCLR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUTCLR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUTCLR_PIN5 = 0x20
	// Read: pin driver is low
	GPIO_OUTCLR_PIN5_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN5_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN5_Clear = 0x1
	// Position of PIN6 field.
	GPIO_OUTCLR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUTCLR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUTCLR_PIN6 = 0x40
	// Read: pin driver is low
	GPIO_OUTCLR_PIN6_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN6_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN6_Clear = 0x1
	// Position of PIN7 field.
	GPIO_OUTCLR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUTCLR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUTCLR_PIN7 = 0x80
	// Read: pin driver is low
	GPIO_OUTCLR_PIN7_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN7_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN7_Clear = 0x1
	// Position of PIN8 field.
	GPIO_OUTCLR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUTCLR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUTCLR_PIN8 = 0x100
	// Read: pin driver is low
	GPIO_OUTCLR_PIN8_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN8_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN8_Clear = 0x1
	// Position of PIN9 field.
	GPIO_OUTCLR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUTCLR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUTCLR_PIN9 = 0x200
	// Read: pin driver is low
	GPIO_OUTCLR_PIN9_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN9_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN9_Clear = 0x1
	// Position of PIN10 field.
	GPIO_OUTCLR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUTCLR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUTCLR_PIN10 = 0x400
	// Read: pin driver is low
	GPIO_OUTCLR_PIN10_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN10_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN10_Clear = 0x1
	// Position of PIN11 field.
	GPIO_OUTCLR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUTCLR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUTCLR_PIN11 = 0x800
	// Read: pin driver is low
	GPIO_OUTCLR_PIN11_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN11_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN11_Clear = 0x1
	// Position of PIN12 field.
	GPIO_OUTCLR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUTCLR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUTCLR_PIN12 = 0x1000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN12_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN12_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN12_Clear = 0x1
	// Position of PIN13 field.
	GPIO_OUTCLR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUTCLR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUTCLR_PIN13 = 0x2000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN13_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN13_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN13_Clear = 0x1
	// Position of PIN14 field.
	GPIO_OUTCLR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUTCLR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUTCLR_PIN14 = 0x4000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN14_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN14_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN14_Clear = 0x1
	// Position of PIN15 field.
	GPIO_OUTCLR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUTCLR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUTCLR_PIN15 = 0x8000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN15_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN15_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN15_Clear = 0x1
	// Position of PIN16 field.
	GPIO_OUTCLR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUTCLR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUTCLR_PIN16 = 0x10000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN16_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN16_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN16_Clear = 0x1
	// Position of PIN17 field.
	GPIO_OUTCLR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUTCLR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUTCLR_PIN17 = 0x20000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN17_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN17_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN17_Clear = 0x1
	// Position of PIN18 field.
	GPIO_OUTCLR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUTCLR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUTCLR_PIN18 = 0x40000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN18_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN18_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN18_Clear = 0x1
	// Position of PIN19 field.
	GPIO_OUTCLR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUTCLR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUTCLR_PIN19 = 0x80000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN19_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN19_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN19_Clear = 0x1
	// Position of PIN20 field.
	GPIO_OUTCLR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUTCLR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUTCLR_PIN20 = 0x100000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN20_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN20_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN20_Clear = 0x1
	// Position of PIN21 field.
	GPIO_OUTCLR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUTCLR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUTCLR_PIN21 = 0x200000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN21_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN21_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN21_Clear = 0x1
	// Position of PIN22 field.
	GPIO_OUTCLR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUTCLR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUTCLR_PIN22 = 0x400000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN22_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN22_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN22_Clear = 0x1
	// Position of PIN23 field.
	GPIO_OUTCLR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUTCLR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUTCLR_PIN23 = 0x800000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN23_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN23_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN23_Clear = 0x1
	// Position of PIN24 field.
	GPIO_OUTCLR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUTCLR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUTCLR_PIN24 = 0x1000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN24_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN24_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN24_Clear = 0x1
	// Position of PIN25 field.
	GPIO_OUTCLR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUTCLR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUTCLR_PIN25 = 0x2000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN25_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN25_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN25_Clear = 0x1
	// Position of PIN26 field.
	GPIO_OUTCLR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUTCLR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUTCLR_PIN26 = 0x4000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN26_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN26_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN26_Clear = 0x1
	// Position of PIN27 field.
	GPIO_OUTCLR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUTCLR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUTCLR_PIN27 = 0x8000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN27_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN27_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN27_Clear = 0x1
	// Position of PIN28 field.
	GPIO_OUTCLR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUTCLR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUTCLR_PIN28 = 0x10000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN28_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN28_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN28_Clear = 0x1
	// Position of PIN29 field.
	GPIO_OUTCLR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUTCLR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUTCLR_PIN29 = 0x20000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN29_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN29_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN29_Clear = 0x1
	// Position of PIN30 field.
	GPIO_OUTCLR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUTCLR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUTCLR_PIN30 = 0x40000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN30_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN30_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN30_Clear = 0x1
	// Position of PIN31 field.
	GPIO_OUTCLR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUTCLR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUTCLR_PIN31 = 0x80000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN31_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN31_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN31_Clear = 0x1

	// IN: Read GPIO port
	// Position of PIN0 field.
	GPIO_IN_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_IN_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_IN_PIN0 = 0x1
	// Pin input is low
	GPIO_IN_PIN0_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN0_High = 0x1
	// Position of PIN1 field.
	GPIO_IN_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_IN_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_IN_PIN1 = 0x2
	// Pin input is low
	GPIO_IN_PIN1_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN1_High = 0x1
	// Position of PIN2 field.
	GPIO_IN_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_IN_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_IN_PIN2 = 0x4
	// Pin input is low
	GPIO_IN_PIN2_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN2_High = 0x1
	// Position of PIN3 field.
	GPIO_IN_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_IN_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_IN_PIN3 = 0x8
	// Pin input is low
	GPIO_IN_PIN3_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN3_High = 0x1
	// Position of PIN4 field.
	GPIO_IN_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_IN_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_IN_PIN4 = 0x10
	// Pin input is low
	GPIO_IN_PIN4_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN4_High = 0x1
	// Position of PIN5 field.
	GPIO_IN_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_IN_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_IN_PIN5 = 0x20
	// Pin input is low
	GPIO_IN_PIN5_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN5_High = 0x1
	// Position of PIN6 field.
	GPIO_IN_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_IN_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_IN_PIN6 = 0x40
	// Pin input is low
	GPIO_IN_PIN6_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN6_High = 0x1
	// Position of PIN7 field.
	GPIO_IN_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_IN_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_IN_PIN7 = 0x80
	// Pin input is low
	GPIO_IN_PIN7_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN7_High = 0x1
	// Position of PIN8 field.
	GPIO_IN_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_IN_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_IN_PIN8 = 0x100
	// Pin input is low
	GPIO_IN_PIN8_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN8_High = 0x1
	// Position of PIN9 field.
	GPIO_IN_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_IN_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_IN_PIN9 = 0x200
	// Pin input is low
	GPIO_IN_PIN9_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN9_High = 0x1
	// Position of PIN10 field.
	GPIO_IN_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_IN_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_IN_PIN10 = 0x400
	// Pin input is low
	GPIO_IN_PIN10_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN10_High = 0x1
	// Position of PIN11 field.
	GPIO_IN_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_IN_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_IN_PIN11 = 0x800
	// Pin input is low
	GPIO_IN_PIN11_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN11_High = 0x1
	// Position of PIN12 field.
	GPIO_IN_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_IN_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_IN_PIN12 = 0x1000
	// Pin input is low
	GPIO_IN_PIN12_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN12_High = 0x1
	// Position of PIN13 field.
	GPIO_IN_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_IN_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_IN_PIN13 = 0x2000
	// Pin input is low
	GPIO_IN_PIN13_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN13_High = 0x1
	// Position of PIN14 field.
	GPIO_IN_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_IN_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_IN_PIN14 = 0x4000
	// Pin input is low
	GPIO_IN_PIN14_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN14_High = 0x1
	// Position of PIN15 field.
	GPIO_IN_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_IN_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_IN_PIN15 = 0x8000
	// Pin input is low
	GPIO_IN_PIN15_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN15_High = 0x1
	// Position of PIN16 field.
	GPIO_IN_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_IN_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_IN_PIN16 = 0x10000
	// Pin input is low
	GPIO_IN_PIN16_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN16_High = 0x1
	// Position of PIN17 field.
	GPIO_IN_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_IN_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_IN_PIN17 = 0x20000
	// Pin input is low
	GPIO_IN_PIN17_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN17_High = 0x1
	// Position of PIN18 field.
	GPIO_IN_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_IN_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_IN_PIN18 = 0x40000
	// Pin input is low
	GPIO_IN_PIN18_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN18_High = 0x1
	// Position of PIN19 field.
	GPIO_IN_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_IN_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_IN_PIN19 = 0x80000
	// Pin input is low
	GPIO_IN_PIN19_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN19_High = 0x1
	// Position of PIN20 field.
	GPIO_IN_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_IN_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_IN_PIN20 = 0x100000
	// Pin input is low
	GPIO_IN_PIN20_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN20_High = 0x1
	// Position of PIN21 field.
	GPIO_IN_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_IN_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_IN_PIN21 = 0x200000
	// Pin input is low
	GPIO_IN_PIN21_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN21_High = 0x1
	// Position of PIN22 field.
	GPIO_IN_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_IN_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_IN_PIN22 = 0x400000
	// Pin input is low
	GPIO_IN_PIN22_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN22_High = 0x1
	// Position of PIN23 field.
	GPIO_IN_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_IN_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_IN_PIN23 = 0x800000
	// Pin input is low
	GPIO_IN_PIN23_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN23_High = 0x1
	// Position of PIN24 field.
	GPIO_IN_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_IN_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_IN_PIN24 = 0x1000000
	// Pin input is low
	GPIO_IN_PIN24_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN24_High = 0x1
	// Position of PIN25 field.
	GPIO_IN_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_IN_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_IN_PIN25 = 0x2000000
	// Pin input is low
	GPIO_IN_PIN25_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN25_High = 0x1
	// Position of PIN26 field.
	GPIO_IN_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_IN_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_IN_PIN26 = 0x4000000
	// Pin input is low
	GPIO_IN_PIN26_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN26_High = 0x1
	// Position of PIN27 field.
	GPIO_IN_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_IN_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_IN_PIN27 = 0x8000000
	// Pin input is low
	GPIO_IN_PIN27_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN27_High = 0x1
	// Position of PIN28 field.
	GPIO_IN_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_IN_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_IN_PIN28 = 0x10000000
	// Pin input is low
	GPIO_IN_PIN28_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN28_High = 0x1
	// Position of PIN29 field.
	GPIO_IN_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_IN_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_IN_PIN29 = 0x20000000
	// Pin input is low
	GPIO_IN_PIN29_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN29_High = 0x1
	// Position of PIN30 field.
	GPIO_IN_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_IN_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_IN_PIN30 = 0x40000000
	// Pin input is low
	GPIO_IN_PIN30_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN30_High = 0x1
	// Position of PIN31 field.
	GPIO_IN_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_IN_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_IN_PIN31 = 0x80000000
	// Pin input is low
	GPIO_IN_PIN31_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN31_High = 0x1

	// DIR: Direction of GPIO pins
	// Position of PIN0 field.
	GPIO_DIR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIR_PIN0 = 0x1
	// Pin set as input
	GPIO_DIR_PIN0_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN0_Output = 0x1
	// Position of PIN1 field.
	GPIO_DIR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIR_PIN1 = 0x2
	// Pin set as input
	GPIO_DIR_PIN1_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN1_Output = 0x1
	// Position of PIN2 field.
	GPIO_DIR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIR_PIN2 = 0x4
	// Pin set as input
	GPIO_DIR_PIN2_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN2_Output = 0x1
	// Position of PIN3 field.
	GPIO_DIR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIR_PIN3 = 0x8
	// Pin set as input
	GPIO_DIR_PIN3_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN3_Output = 0x1
	// Position of PIN4 field.
	GPIO_DIR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIR_PIN4 = 0x10
	// Pin set as input
	GPIO_DIR_PIN4_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN4_Output = 0x1
	// Position of PIN5 field.
	GPIO_DIR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIR_PIN5 = 0x20
	// Pin set as input
	GPIO_DIR_PIN5_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN5_Output = 0x1
	// Position of PIN6 field.
	GPIO_DIR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIR_PIN6 = 0x40
	// Pin set as input
	GPIO_DIR_PIN6_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN6_Output = 0x1
	// Position of PIN7 field.
	GPIO_DIR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIR_PIN7 = 0x80
	// Pin set as input
	GPIO_DIR_PIN7_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN7_Output = 0x1
	// Position of PIN8 field.
	GPIO_DIR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIR_PIN8 = 0x100
	// Pin set as input
	GPIO_DIR_PIN8_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN8_Output = 0x1
	// Position of PIN9 field.
	GPIO_DIR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIR_PIN9 = 0x200
	// Pin set as input
	GPIO_DIR_PIN9_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN9_Output = 0x1
	// Position of PIN10 field.
	GPIO_DIR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIR_PIN10 = 0x400
	// Pin set as input
	GPIO_DIR_PIN10_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN10_Output = 0x1
	// Position of PIN11 field.
	GPIO_DIR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIR_PIN11 = 0x800
	// Pin set as input
	GPIO_DIR_PIN11_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN11_Output = 0x1
	// Position of PIN12 field.
	GPIO_DIR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIR_PIN12 = 0x1000
	// Pin set as input
	GPIO_DIR_PIN12_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN12_Output = 0x1
	// Position of PIN13 field.
	GPIO_DIR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIR_PIN13 = 0x2000
	// Pin set as input
	GPIO_DIR_PIN13_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN13_Output = 0x1
	// Position of PIN14 field.
	GPIO_DIR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIR_PIN14 = 0x4000
	// Pin set as input
	GPIO_DIR_PIN14_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN14_Output = 0x1
	// Position of PIN15 field.
	GPIO_DIR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIR_PIN15 = 0x8000
	// Pin set as input
	GPIO_DIR_PIN15_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN15_Output = 0x1
	// Position of PIN16 field.
	GPIO_DIR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIR_PIN16 = 0x10000
	// Pin set as input
	GPIO_DIR_PIN16_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN16_Output = 0x1
	// Position of PIN17 field.
	GPIO_DIR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIR_PIN17 = 0x20000
	// Pin set as input
	GPIO_DIR_PIN17_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN17_Output = 0x1
	// Position of PIN18 field.
	GPIO_DIR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIR_PIN18 = 0x40000
	// Pin set as input
	GPIO_DIR_PIN18_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN18_Output = 0x1
	// Position of PIN19 field.
	GPIO_DIR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIR_PIN19 = 0x80000
	// Pin set as input
	GPIO_DIR_PIN19_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN19_Output = 0x1
	// Position of PIN20 field.
	GPIO_DIR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIR_PIN20 = 0x100000
	// Pin set as input
	GPIO_DIR_PIN20_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN20_Output = 0x1
	// Position of PIN21 field.
	GPIO_DIR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIR_PIN21 = 0x200000
	// Pin set as input
	GPIO_DIR_PIN21_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN21_Output = 0x1
	// Position of PIN22 field.
	GPIO_DIR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIR_PIN22 = 0x400000
	// Pin set as input
	GPIO_DIR_PIN22_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN22_Output = 0x1
	// Position of PIN23 field.
	GPIO_DIR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIR_PIN23 = 0x800000
	// Pin set as input
	GPIO_DIR_PIN23_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN23_Output = 0x1
	// Position of PIN24 field.
	GPIO_DIR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIR_PIN24 = 0x1000000
	// Pin set as input
	GPIO_DIR_PIN24_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN24_Output = 0x1
	// Position of PIN25 field.
	GPIO_DIR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIR_PIN25 = 0x2000000
	// Pin set as input
	GPIO_DIR_PIN25_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN25_Output = 0x1
	// Position of PIN26 field.
	GPIO_DIR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIR_PIN26 = 0x4000000
	// Pin set as input
	GPIO_DIR_PIN26_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN26_Output = 0x1
	// Position of PIN27 field.
	GPIO_DIR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIR_PIN27 = 0x8000000
	// Pin set as input
	GPIO_DIR_PIN27_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN27_Output = 0x1
	// Position of PIN28 field.
	GPIO_DIR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIR_PIN28 = 0x10000000
	// Pin set as input
	GPIO_DIR_PIN28_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN28_Output = 0x1
	// Position of PIN29 field.
	GPIO_DIR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIR_PIN29 = 0x20000000
	// Pin set as input
	GPIO_DIR_PIN29_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN29_Output = 0x1
	// Position of PIN30 field.
	GPIO_DIR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIR_PIN30 = 0x40000000
	// Pin set as input
	GPIO_DIR_PIN30_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN30_Output = 0x1
	// Position of PIN31 field.
	GPIO_DIR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIR_PIN31 = 0x80000000
	// Pin set as input
	GPIO_DIR_PIN31_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN31_Output = 0x1

	// DIRSET: DIR set register
	// Position of PIN0 field.
	GPIO_DIRSET_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIRSET_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIRSET_PIN0 = 0x1
	// Read: pin set as input
	GPIO_DIRSET_PIN0_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN0_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN0_Set = 0x1
	// Position of PIN1 field.
	GPIO_DIRSET_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIRSET_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIRSET_PIN1 = 0x2
	// Read: pin set as input
	GPIO_DIRSET_PIN1_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN1_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN1_Set = 0x1
	// Position of PIN2 field.
	GPIO_DIRSET_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIRSET_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIRSET_PIN2 = 0x4
	// Read: pin set as input
	GPIO_DIRSET_PIN2_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN2_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN2_Set = 0x1
	// Position of PIN3 field.
	GPIO_DIRSET_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIRSET_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIRSET_PIN3 = 0x8
	// Read: pin set as input
	GPIO_DIRSET_PIN3_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN3_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN3_Set = 0x1
	// Position of PIN4 field.
	GPIO_DIRSET_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIRSET_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIRSET_PIN4 = 0x10
	// Read: pin set as input
	GPIO_DIRSET_PIN4_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN4_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN4_Set = 0x1
	// Position of PIN5 field.
	GPIO_DIRSET_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIRSET_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIRSET_PIN5 = 0x20
	// Read: pin set as input
	GPIO_DIRSET_PIN5_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN5_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN5_Set = 0x1
	// Position of PIN6 field.
	GPIO_DIRSET_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIRSET_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIRSET_PIN6 = 0x40
	// Read: pin set as input
	GPIO_DIRSET_PIN6_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN6_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN6_Set = 0x1
	// Position of PIN7 field.
	GPIO_DIRSET_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIRSET_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIRSET_PIN7 = 0x80
	// Read: pin set as input
	GPIO_DIRSET_PIN7_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN7_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN7_Set = 0x1
	// Position of PIN8 field.
	GPIO_DIRSET_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIRSET_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIRSET_PIN8 = 0x100
	// Read: pin set as input
	GPIO_DIRSET_PIN8_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN8_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN8_Set = 0x1
	// Position of PIN9 field.
	GPIO_DIRSET_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIRSET_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIRSET_PIN9 = 0x200
	// Read: pin set as input
	GPIO_DIRSET_PIN9_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN9_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN9_Set = 0x1
	// Position of PIN10 field.
	GPIO_DIRSET_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIRSET_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIRSET_PIN10 = 0x400
	// Read: pin set as input
	GPIO_DIRSET_PIN10_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN10_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN10_Set = 0x1
	// Position of PIN11 field.
	GPIO_DIRSET_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIRSET_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIRSET_PIN11 = 0x800
	// Read: pin set as input
	GPIO_DIRSET_PIN11_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN11_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN11_Set = 0x1
	// Position of PIN12 field.
	GPIO_DIRSET_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIRSET_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIRSET_PIN12 = 0x1000
	// Read: pin set as input
	GPIO_DIRSET_PIN12_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN12_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN12_Set = 0x1
	// Position of PIN13 field.
	GPIO_DIRSET_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIRSET_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIRSET_PIN13 = 0x2000
	// Read: pin set as input
	GPIO_DIRSET_PIN13_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN13_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN13_Set = 0x1
	// Position of PIN14 field.
	GPIO_DIRSET_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIRSET_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIRSET_PIN14 = 0x4000
	// Read: pin set as input
	GPIO_DIRSET_PIN14_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN14_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN14_Set = 0x1
	// Position of PIN15 field.
	GPIO_DIRSET_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIRSET_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIRSET_PIN15 = 0x8000
	// Read: pin set as input
	GPIO_DIRSET_PIN15_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN15_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN15_Set = 0x1
	// Position of PIN16 field.
	GPIO_DIRSET_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIRSET_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIRSET_PIN16 = 0x10000
	// Read: pin set as input
	GPIO_DIRSET_PIN16_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN16_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN16_Set = 0x1
	// Position of PIN17 field.
	GPIO_DIRSET_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIRSET_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIRSET_PIN17 = 0x20000
	// Read: pin set as input
	GPIO_DIRSET_PIN17_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN17_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN17_Set = 0x1
	// Position of PIN18 field.
	GPIO_DIRSET_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIRSET_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIRSET_PIN18 = 0x40000
	// Read: pin set as input
	GPIO_DIRSET_PIN18_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN18_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN18_Set = 0x1
	// Position of PIN19 field.
	GPIO_DIRSET_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIRSET_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIRSET_PIN19 = 0x80000
	// Read: pin set as input
	GPIO_DIRSET_PIN19_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN19_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN19_Set = 0x1
	// Position of PIN20 field.
	GPIO_DIRSET_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIRSET_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIRSET_PIN20 = 0x100000
	// Read: pin set as input
	GPIO_DIRSET_PIN20_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN20_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN20_Set = 0x1
	// Position of PIN21 field.
	GPIO_DIRSET_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIRSET_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIRSET_PIN21 = 0x200000
	// Read: pin set as input
	GPIO_DIRSET_PIN21_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN21_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN21_Set = 0x1
	// Position of PIN22 field.
	GPIO_DIRSET_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIRSET_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIRSET_PIN22 = 0x400000
	// Read: pin set as input
	GPIO_DIRSET_PIN22_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN22_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN22_Set = 0x1
	// Position of PIN23 field.
	GPIO_DIRSET_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIRSET_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIRSET_PIN23 = 0x800000
	// Read: pin set as input
	GPIO_DIRSET_PIN23_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN23_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN23_Set = 0x1
	// Position of PIN24 field.
	GPIO_DIRSET_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIRSET_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIRSET_PIN24 = 0x1000000
	// Read: pin set as input
	GPIO_DIRSET_PIN24_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN24_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN24_Set = 0x1
	// Position of PIN25 field.
	GPIO_DIRSET_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIRSET_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIRSET_PIN25 = 0x2000000
	// Read: pin set as input
	GPIO_DIRSET_PIN25_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN25_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN25_Set = 0x1
	// Position of PIN26 field.
	GPIO_DIRSET_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIRSET_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIRSET_PIN26 = 0x4000000
	// Read: pin set as input
	GPIO_DIRSET_PIN26_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN26_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN26_Set = 0x1
	// Position of PIN27 field.
	GPIO_DIRSET_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIRSET_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIRSET_PIN27 = 0x8000000
	// Read: pin set as input
	GPIO_DIRSET_PIN27_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN27_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN27_Set = 0x1
	// Position of PIN28 field.
	GPIO_DIRSET_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIRSET_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIRSET_PIN28 = 0x10000000
	// Read: pin set as input
	GPIO_DIRSET_PIN28_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN28_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN28_Set = 0x1
	// Position of PIN29 field.
	GPIO_DIRSET_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIRSET_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIRSET_PIN29 = 0x20000000
	// Read: pin set as input
	GPIO_DIRSET_PIN29_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN29_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN29_Set = 0x1
	// Position of PIN30 field.
	GPIO_DIRSET_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIRSET_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIRSET_PIN30 = 0x40000000
	// Read: pin set as input
	GPIO_DIRSET_PIN30_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN30_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN30_Set = 0x1
	// Position of PIN31 field.
	GPIO_DIRSET_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIRSET_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIRSET_PIN31 = 0x80000000
	// Read: pin set as input
	GPIO_DIRSET_PIN31_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN31_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN31_Set = 0x1

	// DIRCLR: DIR clear register
	// Position of PIN0 field.
	GPIO_DIRCLR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIRCLR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIRCLR_PIN0 = 0x1
	// Read: pin set as input
	GPIO_DIRCLR_PIN0_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN0_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN0_Clear = 0x1
	// Position of PIN1 field.
	GPIO_DIRCLR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIRCLR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIRCLR_PIN1 = 0x2
	// Read: pin set as input
	GPIO_DIRCLR_PIN1_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN1_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN1_Clear = 0x1
	// Position of PIN2 field.
	GPIO_DIRCLR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIRCLR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIRCLR_PIN2 = 0x4
	// Read: pin set as input
	GPIO_DIRCLR_PIN2_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN2_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN2_Clear = 0x1
	// Position of PIN3 field.
	GPIO_DIRCLR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIRCLR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIRCLR_PIN3 = 0x8
	// Read: pin set as input
	GPIO_DIRCLR_PIN3_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN3_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN3_Clear = 0x1
	// Position of PIN4 field.
	GPIO_DIRCLR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIRCLR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIRCLR_PIN4 = 0x10
	// Read: pin set as input
	GPIO_DIRCLR_PIN4_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN4_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN4_Clear = 0x1
	// Position of PIN5 field.
	GPIO_DIRCLR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIRCLR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIRCLR_PIN5 = 0x20
	// Read: pin set as input
	GPIO_DIRCLR_PIN5_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN5_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN5_Clear = 0x1
	// Position of PIN6 field.
	GPIO_DIRCLR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIRCLR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIRCLR_PIN6 = 0x40
	// Read: pin set as input
	GPIO_DIRCLR_PIN6_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN6_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN6_Clear = 0x1
	// Position of PIN7 field.
	GPIO_DIRCLR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIRCLR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIRCLR_PIN7 = 0x80
	// Read: pin set as input
	GPIO_DIRCLR_PIN7_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN7_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN7_Clear = 0x1
	// Position of PIN8 field.
	GPIO_DIRCLR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIRCLR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIRCLR_PIN8 = 0x100
	// Read: pin set as input
	GPIO_DIRCLR_PIN8_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN8_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN8_Clear = 0x1
	// Position of PIN9 field.
	GPIO_DIRCLR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIRCLR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIRCLR_PIN9 = 0x200
	// Read: pin set as input
	GPIO_DIRCLR_PIN9_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN9_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN9_Clear = 0x1
	// Position of PIN10 field.
	GPIO_DIRCLR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIRCLR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIRCLR_PIN10 = 0x400
	// Read: pin set as input
	GPIO_DIRCLR_PIN10_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN10_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN10_Clear = 0x1
	// Position of PIN11 field.
	GPIO_DIRCLR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIRCLR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIRCLR_PIN11 = 0x800
	// Read: pin set as input
	GPIO_DIRCLR_PIN11_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN11_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN11_Clear = 0x1
	// Position of PIN12 field.
	GPIO_DIRCLR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIRCLR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIRCLR_PIN12 = 0x1000
	// Read: pin set as input
	GPIO_DIRCLR_PIN12_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN12_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN12_Clear = 0x1
	// Position of PIN13 field.
	GPIO_DIRCLR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIRCLR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIRCLR_PIN13 = 0x2000
	// Read: pin set as input
	GPIO_DIRCLR_PIN13_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN13_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN13_Clear = 0x1
	// Position of PIN14 field.
	GPIO_DIRCLR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIRCLR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIRCLR_PIN14 = 0x4000
	// Read: pin set as input
	GPIO_DIRCLR_PIN14_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN14_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN14_Clear = 0x1
	// Position of PIN15 field.
	GPIO_DIRCLR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIRCLR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIRCLR_PIN15 = 0x8000
	// Read: pin set as input
	GPIO_DIRCLR_PIN15_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN15_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN15_Clear = 0x1
	// Position of PIN16 field.
	GPIO_DIRCLR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIRCLR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIRCLR_PIN16 = 0x10000
	// Read: pin set as input
	GPIO_DIRCLR_PIN16_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN16_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN16_Clear = 0x1
	// Position of PIN17 field.
	GPIO_DIRCLR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIRCLR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIRCLR_PIN17 = 0x20000
	// Read: pin set as input
	GPIO_DIRCLR_PIN17_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN17_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN17_Clear = 0x1
	// Position of PIN18 field.
	GPIO_DIRCLR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIRCLR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIRCLR_PIN18 = 0x40000
	// Read: pin set as input
	GPIO_DIRCLR_PIN18_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN18_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN18_Clear = 0x1
	// Position of PIN19 field.
	GPIO_DIRCLR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIRCLR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIRCLR_PIN19 = 0x80000
	// Read: pin set as input
	GPIO_DIRCLR_PIN19_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN19_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN19_Clear = 0x1
	// Position of PIN20 field.
	GPIO_DIRCLR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIRCLR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIRCLR_PIN20 = 0x100000
	// Read: pin set as input
	GPIO_DIRCLR_PIN20_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN20_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN20_Clear = 0x1
	// Position of PIN21 field.
	GPIO_DIRCLR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIRCLR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIRCLR_PIN21 = 0x200000
	// Read: pin set as input
	GPIO_DIRCLR_PIN21_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN21_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN21_Clear = 0x1
	// Position of PIN22 field.
	GPIO_DIRCLR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIRCLR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIRCLR_PIN22 = 0x400000
	// Read: pin set as input
	GPIO_DIRCLR_PIN22_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN22_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN22_Clear = 0x1
	// Position of PIN23 field.
	GPIO_DIRCLR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIRCLR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIRCLR_PIN23 = 0x800000
	// Read: pin set as input
	GPIO_DIRCLR_PIN23_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN23_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN23_Clear = 0x1
	// Position of PIN24 field.
	GPIO_DIRCLR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIRCLR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIRCLR_PIN24 = 0x1000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN24_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN24_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN24_Clear = 0x1
	// Position of PIN25 field.
	GPIO_DIRCLR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIRCLR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIRCLR_PIN25 = 0x2000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN25_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN25_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN25_Clear = 0x1
	// Position of PIN26 field.
	GPIO_DIRCLR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIRCLR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIRCLR_PIN26 = 0x4000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN26_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN26_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN26_Clear = 0x1
	// Position of PIN27 field.
	GPIO_DIRCLR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIRCLR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIRCLR_PIN27 = 0x8000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN27_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN27_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN27_Clear = 0x1
	// Position of PIN28 field.
	GPIO_DIRCLR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIRCLR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIRCLR_PIN28 = 0x10000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN28_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN28_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN28_Clear = 0x1
	// Position of PIN29 field.
	GPIO_DIRCLR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIRCLR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIRCLR_PIN29 = 0x20000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN29_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN29_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN29_Clear = 0x1
	// Position of PIN30 field.
	GPIO_DIRCLR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIRCLR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIRCLR_PIN30 = 0x40000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN30_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN30_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN30_Clear = 0x1
	// Position of PIN31 field.
	GPIO_DIRCLR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIRCLR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIRCLR_PIN31 = 0x80000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN31_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN31_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN31_Clear = 0x1

	// LATCH: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
	// Position of PIN0 field.
	GPIO_LATCH_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_LATCH_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_LATCH_PIN0 = 0x1
	// Criteria has not been met
	GPIO_LATCH_PIN0_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN0_Latched = 0x1
	// Position of PIN1 field.
	GPIO_LATCH_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_LATCH_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_LATCH_PIN1 = 0x2
	// Criteria has not been met
	GPIO_LATCH_PIN1_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN1_Latched = 0x1
	// Position of PIN2 field.
	GPIO_LATCH_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_LATCH_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_LATCH_PIN2 = 0x4
	// Criteria has not been met
	GPIO_LATCH_PIN2_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN2_Latched = 0x1
	// Position of PIN3 field.
	GPIO_LATCH_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_LATCH_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_LATCH_PIN3 = 0x8
	// Criteria has not been met
	GPIO_LATCH_PIN3_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN3_Latched = 0x1
	// Position of PIN4 field.
	GPIO_LATCH_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_LATCH_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_LATCH_PIN4 = 0x10
	// Criteria has not been met
	GPIO_LATCH_PIN4_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN4_Latched = 0x1
	// Position of PIN5 field.
	GPIO_LATCH_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_LATCH_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_LATCH_PIN5 = 0x20
	// Criteria has not been met
	GPIO_LATCH_PIN5_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN5_Latched = 0x1
	// Position of PIN6 field.
	GPIO_LATCH_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_LATCH_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_LATCH_PIN6 = 0x40
	// Criteria has not been met
	GPIO_LATCH_PIN6_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN6_Latched = 0x1
	// Position of PIN7 field.
	GPIO_LATCH_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_LATCH_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_LATCH_PIN7 = 0x80
	// Criteria has not been met
	GPIO_LATCH_PIN7_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN7_Latched = 0x1
	// Position of PIN8 field.
	GPIO_LATCH_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_LATCH_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_LATCH_PIN8 = 0x100
	// Criteria has not been met
	GPIO_LATCH_PIN8_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN8_Latched = 0x1
	// Position of PIN9 field.
	GPIO_LATCH_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_LATCH_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_LATCH_PIN9 = 0x200
	// Criteria has not been met
	GPIO_LATCH_PIN9_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN9_Latched = 0x1
	// Position of PIN10 field.
	GPIO_LATCH_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_LATCH_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_LATCH_PIN10 = 0x400
	// Criteria has not been met
	GPIO_LATCH_PIN10_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN10_Latched = 0x1
	// Position of PIN11 field.
	GPIO_LATCH_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_LATCH_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_LATCH_PIN11 = 0x800
	// Criteria has not been met
	GPIO_LATCH_PIN11_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN11_Latched = 0x1
	// Position of PIN12 field.
	GPIO_LATCH_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_LATCH_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_LATCH_PIN12 = 0x1000
	// Criteria has not been met
	GPIO_LATCH_PIN12_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN12_Latched = 0x1
	// Position of PIN13 field.
	GPIO_LATCH_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_LATCH_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_LATCH_PIN13 = 0x2000
	// Criteria has not been met
	GPIO_LATCH_PIN13_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN13_Latched = 0x1
	// Position of PIN14 field.
	GPIO_LATCH_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_LATCH_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_LATCH_PIN14 = 0x4000
	// Criteria has not been met
	GPIO_LATCH_PIN14_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN14_Latched = 0x1
	// Position of PIN15 field.
	GPIO_LATCH_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_LATCH_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_LATCH_PIN15 = 0x8000
	// Criteria has not been met
	GPIO_LATCH_PIN15_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN15_Latched = 0x1
	// Position of PIN16 field.
	GPIO_LATCH_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_LATCH_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_LATCH_PIN16 = 0x10000
	// Criteria has not been met
	GPIO_LATCH_PIN16_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN16_Latched = 0x1
	// Position of PIN17 field.
	GPIO_LATCH_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_LATCH_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_LATCH_PIN17 = 0x20000
	// Criteria has not been met
	GPIO_LATCH_PIN17_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN17_Latched = 0x1
	// Position of PIN18 field.
	GPIO_LATCH_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_LATCH_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_LATCH_PIN18 = 0x40000
	// Criteria has not been met
	GPIO_LATCH_PIN18_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN18_Latched = 0x1
	// Position of PIN19 field.
	GPIO_LATCH_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_LATCH_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_LATCH_PIN19 = 0x80000
	// Criteria has not been met
	GPIO_LATCH_PIN19_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN19_Latched = 0x1
	// Position of PIN20 field.
	GPIO_LATCH_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_LATCH_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_LATCH_PIN20 = 0x100000
	// Criteria has not been met
	GPIO_LATCH_PIN20_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN20_Latched = 0x1
	// Position of PIN21 field.
	GPIO_LATCH_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_LATCH_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_LATCH_PIN21 = 0x200000
	// Criteria has not been met
	GPIO_LATCH_PIN21_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN21_Latched = 0x1
	// Position of PIN22 field.
	GPIO_LATCH_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_LATCH_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_LATCH_PIN22 = 0x400000
	// Criteria has not been met
	GPIO_LATCH_PIN22_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN22_Latched = 0x1
	// Position of PIN23 field.
	GPIO_LATCH_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_LATCH_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_LATCH_PIN23 = 0x800000
	// Criteria has not been met
	GPIO_LATCH_PIN23_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN23_Latched = 0x1
	// Position of PIN24 field.
	GPIO_LATCH_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_LATCH_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_LATCH_PIN24 = 0x1000000
	// Criteria has not been met
	GPIO_LATCH_PIN24_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN24_Latched = 0x1
	// Position of PIN25 field.
	GPIO_LATCH_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_LATCH_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_LATCH_PIN25 = 0x2000000
	// Criteria has not been met
	GPIO_LATCH_PIN25_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN25_Latched = 0x1
	// Position of PIN26 field.
	GPIO_LATCH_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_LATCH_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_LATCH_PIN26 = 0x4000000
	// Criteria has not been met
	GPIO_LATCH_PIN26_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN26_Latched = 0x1
	// Position of PIN27 field.
	GPIO_LATCH_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_LATCH_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_LATCH_PIN27 = 0x8000000
	// Criteria has not been met
	GPIO_LATCH_PIN27_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN27_Latched = 0x1
	// Position of PIN28 field.
	GPIO_LATCH_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_LATCH_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_LATCH_PIN28 = 0x10000000
	// Criteria has not been met
	GPIO_LATCH_PIN28_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN28_Latched = 0x1
	// Position of PIN29 field.
	GPIO_LATCH_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_LATCH_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_LATCH_PIN29 = 0x20000000
	// Criteria has not been met
	GPIO_LATCH_PIN29_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN29_Latched = 0x1
	// Position of PIN30 field.
	GPIO_LATCH_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_LATCH_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_LATCH_PIN30 = 0x40000000
	// Criteria has not been met
	GPIO_LATCH_PIN30_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN30_Latched = 0x1
	// Position of PIN31 field.
	GPIO_LATCH_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_LATCH_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_LATCH_PIN31 = 0x80000000
	// Criteria has not been met
	GPIO_LATCH_PIN31_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN31_Latched = 0x1

	// DETECTMODE: Select between default DETECT signal behaviour and LDETECT mode
	// Position of DETECTMODE field.
	GPIO_DETECTMODE_DETECTMODE_Pos = 0x0
	// Bit mask of DETECTMODE field.
	GPIO_DETECTMODE_DETECTMODE_Msk = 0x1
	// Bit DETECTMODE.
	GPIO_DETECTMODE_DETECTMODE = 0x1
	// DETECT directly connected to PIN DETECT signals
	GPIO_DETECTMODE_DETECTMODE_Default = 0x0
	// Use the latched LDETECT behaviour
	GPIO_DETECTMODE_DETECTMODE_LDETECT = 0x1

	// PIN_CNF: Description collection[0]: Configuration of GPIO pins
	// Position of DIR field.
	GPIO_PIN_CNF_DIR_Pos = 0x0
	// Bit mask of DIR field.
	GPIO_PIN_CNF_DIR_Msk = 0x1
	// Bit DIR.
	GPIO_PIN_CNF_DIR = 0x1
	// Configure pin as an input pin
	GPIO_PIN_CNF_DIR_Input = 0x0
	// Configure pin as an output pin
	GPIO_PIN_CNF_DIR_Output = 0x1
	// Position of INPUT field.
	GPIO_PIN_CNF_INPUT_Pos = 0x1
	// Bit mask of INPUT field.
	GPIO_PIN_CNF_INPUT_Msk = 0x2
	// Bit INPUT.
	GPIO_PIN_CNF_INPUT = 0x2
	// Connect input buffer
	GPIO_PIN_CNF_INPUT_Connect = 0x0
	// Disconnect input buffer
	GPIO_PIN_CNF_INPUT_Disconnect = 0x1
	// Position of PULL field.
	GPIO_PIN_CNF_PULL_Pos = 0x2
	// Bit mask of PULL field.
	GPIO_PIN_CNF_PULL_Msk = 0xc
	// No pull
	GPIO_PIN_CNF_PULL_Disabled = 0x0
	// Pull down on pin
	GPIO_PIN_CNF_PULL_Pulldown = 0x1
	// Pull up on pin
	GPIO_PIN_CNF_PULL_Pullup = 0x3
	// Position of DRIVE field.
	GPIO_PIN_CNF_DRIVE_Pos = 0x8
	// Bit mask of DRIVE field.
	GPIO_PIN_CNF_DRIVE_Msk = 0x700
	// Standard '0', standard '1'
	GPIO_PIN_CNF_DRIVE_S0S1 = 0x0
	// High drive '0', standard '1'
	GPIO_PIN_CNF_DRIVE_H0S1 = 0x1
	// Standard '0', high drive '1'
	GPIO_PIN_CNF_DRIVE_S0H1 = 0x2
	// High drive '0', high 'drive '1''
	GPIO_PIN_CNF_DRIVE_H0H1 = 0x3
	// Disconnect '0' standard '1' (normally used for wired-or connections)
	GPIO_PIN_CNF_DRIVE_D0S1 = 0x4
	// Disconnect '0', high drive '1' (normally used for wired-or connections)
	GPIO_PIN_CNF_DRIVE_D0H1 = 0x5
	// Standard '0'. disconnect '1' (normally used for wired-and connections)
	GPIO_PIN_CNF_DRIVE_S0D1 = 0x6
	// High drive '0', disconnect '1' (normally used for wired-and connections)
	GPIO_PIN_CNF_DRIVE_H0D1 = 0x7
	// Position of SENSE field.
	GPIO_PIN_CNF_SENSE_Pos = 0x10
	// Bit mask of SENSE field.
	GPIO_PIN_CNF_SENSE_Msk = 0x30000
	// Disabled
	GPIO_PIN_CNF_SENSE_Disabled = 0x0
	// Sense for high level
	GPIO_PIN_CNF_SENSE_High = 0x2
	// Sense for low level
	GPIO_PIN_CNF_SENSE_Low = 0x3
)
