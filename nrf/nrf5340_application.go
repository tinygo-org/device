// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from nrf5340_application.svd, see https://github.com/NordicSemiconductor/nrfx/tree/master/mdk

//go:build nrf && nrf5340_application
// +build nrf,nrf5340_application

// nRF53 reference description for system-on-chip with dual ARM 32-bit Cortex-M33 microcontrollers
//
//     Copyright (c) 2010 - 2020, Nordic Semiconductor ASA All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. Neither the name of Nordic Semiconductor ASA nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
package nrf

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "nrf5340_application"
	CPU          = "CM33"
	FPUPresent   = true
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// FPU control peripheral 0 // FPU control peripheral 1
	IRQ_FPU = 0

	// FPU control peripheral 0
	IRQ_FPU_NS = 0

	// FPU control peripheral 1
	IRQ_FPU_S = 0

	// Cache
	IRQ_CACHE = 1

	// Cache
	IRQ_CACHE_S = 1

	// System protection unit
	IRQ_SPU = 3

	// System protection unit
	IRQ_SPU_S = 3

	// Clock management 0 // Power control 0 // Clock management 1 // Power control 1
	IRQ_CLOCK_POWER = 5

	// Clock management 0
	IRQ_CLOCK_NS = 5

	// Power control 0
	IRQ_POWER_NS = 5

	// Clock management 1
	IRQ_CLOCK_S = 5

	// Power control 1
	IRQ_POWER_S = 5

	// Serial Peripheral Interface Master with EasyDMA 0 // SPI Slave 0 // I2C compatible Two-Wire Master Interface with EasyDMA 0 // I2C compatible Two-Wire Slave Interface with EasyDMA 0 // UART with EasyDMA 0 // Serial Peripheral Interface Master with EasyDMA 1 // SPI Slave 1 // I2C compatible Two-Wire Master Interface with EasyDMA 1 // I2C compatible Two-Wire Slave Interface with EasyDMA 1 // UART with EasyDMA 1
	IRQ_SPIM0_SPIS0_TWIM0_TWIS0_UARTE0 = 8

	// Serial Peripheral Interface Master with EasyDMA 0
	IRQ_SPIM0_NS = 8

	// SPI Slave 0
	IRQ_SPIS0_NS = 8

	// I2C compatible Two-Wire Master Interface with EasyDMA 0
	IRQ_TWIM0_NS = 8

	// I2C compatible Two-Wire Slave Interface with EasyDMA 0
	IRQ_TWIS0_NS = 8

	// UART with EasyDMA 0
	IRQ_UARTE0_NS = 8

	// Serial Peripheral Interface Master with EasyDMA 1
	IRQ_SPIM0_S = 8

	// SPI Slave 1
	IRQ_SPIS0_S = 8

	// I2C compatible Two-Wire Master Interface with EasyDMA 1
	IRQ_TWIM0_S = 8

	// I2C compatible Two-Wire Slave Interface with EasyDMA 1
	IRQ_TWIS0_S = 8

	// UART with EasyDMA 1
	IRQ_UARTE0_S = 8

	// Serial Peripheral Interface Master with EasyDMA 2 // SPI Slave 2 // I2C compatible Two-Wire Master Interface with EasyDMA 2 // I2C compatible Two-Wire Slave Interface with EasyDMA 2 // UART with EasyDMA 2 // Serial Peripheral Interface Master with EasyDMA 3 // SPI Slave 3 // I2C compatible Two-Wire Master Interface with EasyDMA 3 // I2C compatible Two-Wire Slave Interface with EasyDMA 3 // UART with EasyDMA 3
	IRQ_SPIM1_SPIS1_TWIM1_TWIS1_UARTE1 = 9

	// Serial Peripheral Interface Master with EasyDMA 2
	IRQ_SPIM1_NS = 9

	// SPI Slave 2
	IRQ_SPIS1_NS = 9

	// I2C compatible Two-Wire Master Interface with EasyDMA 2
	IRQ_TWIM1_NS = 9

	// I2C compatible Two-Wire Slave Interface with EasyDMA 2
	IRQ_TWIS1_NS = 9

	// UART with EasyDMA 2
	IRQ_UARTE1_NS = 9

	// Serial Peripheral Interface Master with EasyDMA 3
	IRQ_SPIM1_S = 9

	// SPI Slave 3
	IRQ_SPIS1_S = 9

	// I2C compatible Two-Wire Master Interface with EasyDMA 3
	IRQ_TWIM1_S = 9

	// I2C compatible Two-Wire Slave Interface with EasyDMA 3
	IRQ_TWIS1_S = 9

	// UART with EasyDMA 3
	IRQ_UARTE1_S = 9

	// Serial Peripheral Interface Master with EasyDMA 4 // Serial Peripheral Interface Master with EasyDMA 5
	IRQ_SPIM4 = 10

	// Serial Peripheral Interface Master with EasyDMA 4
	IRQ_SPIM4_NS = 10

	// Serial Peripheral Interface Master with EasyDMA 5
	IRQ_SPIM4_S = 10

	// Serial Peripheral Interface Master with EasyDMA 6 // SPI Slave 4 // I2C compatible Two-Wire Master Interface with EasyDMA 4 // I2C compatible Two-Wire Slave Interface with EasyDMA 4 // UART with EasyDMA 4 // Serial Peripheral Interface Master with EasyDMA 7 // SPI Slave 5 // I2C compatible Two-Wire Master Interface with EasyDMA 5 // I2C compatible Two-Wire Slave Interface with EasyDMA 5 // UART with EasyDMA 5
	IRQ_SPIM2_SPIS2_TWIM2_TWIS2_UARTE2 = 11

	// Serial Peripheral Interface Master with EasyDMA 6
	IRQ_SPIM2_NS = 11

	// SPI Slave 4
	IRQ_SPIS2_NS = 11

	// I2C compatible Two-Wire Master Interface with EasyDMA 4
	IRQ_TWIM2_NS = 11

	// I2C compatible Two-Wire Slave Interface with EasyDMA 4
	IRQ_TWIS2_NS = 11

	// UART with EasyDMA 4
	IRQ_UARTE2_NS = 11

	// Serial Peripheral Interface Master with EasyDMA 7
	IRQ_SPIM2_S = 11

	// SPI Slave 5
	IRQ_SPIS2_S = 11

	// I2C compatible Two-Wire Master Interface with EasyDMA 5
	IRQ_TWIM2_S = 11

	// I2C compatible Two-Wire Slave Interface with EasyDMA 5
	IRQ_TWIS2_S = 11

	// UART with EasyDMA 5
	IRQ_UARTE2_S = 11

	// Serial Peripheral Interface Master with EasyDMA 8 // SPI Slave 6 // I2C compatible Two-Wire Master Interface with EasyDMA 6 // I2C compatible Two-Wire Slave Interface with EasyDMA 6 // UART with EasyDMA 6 // Serial Peripheral Interface Master with EasyDMA 9 // SPI Slave 7 // I2C compatible Two-Wire Master Interface with EasyDMA 7 // I2C compatible Two-Wire Slave Interface with EasyDMA 7 // UART with EasyDMA 7
	IRQ_SPIM3_SPIS3_TWIM3_TWIS3_UARTE3 = 12

	// Serial Peripheral Interface Master with EasyDMA 8
	IRQ_SPIM3_NS = 12

	// SPI Slave 6
	IRQ_SPIS3_NS = 12

	// I2C compatible Two-Wire Master Interface with EasyDMA 6
	IRQ_TWIM3_NS = 12

	// I2C compatible Two-Wire Slave Interface with EasyDMA 6
	IRQ_TWIS3_NS = 12

	// UART with EasyDMA 6
	IRQ_UARTE3_NS = 12

	// Serial Peripheral Interface Master with EasyDMA 9
	IRQ_SPIM3_S = 12

	// SPI Slave 7
	IRQ_SPIS3_S = 12

	// I2C compatible Two-Wire Master Interface with EasyDMA 7
	IRQ_TWIM3_S = 12

	// I2C compatible Two-Wire Slave Interface with EasyDMA 7
	IRQ_TWIS3_S = 12

	// UART with EasyDMA 7
	IRQ_UARTE3_S = 12

	// GPIO Tasks and Events 0
	IRQ_GPIOTE0 = 13

	// GPIO Tasks and Events 0
	IRQ_GPIOTE0_S = 13

	// Analog to Digital Converter 0 // Analog to Digital Converter 1
	IRQ_SAADC = 14

	// Analog to Digital Converter 0
	IRQ_SAADC_NS = 14

	// Analog to Digital Converter 1
	IRQ_SAADC_S = 14

	// Timer/Counter 0 // Timer/Counter 1
	IRQ_TIMER0 = 15

	// Timer/Counter 0
	IRQ_TIMER0_NS = 15

	// Timer/Counter 1
	IRQ_TIMER0_S = 15

	// Timer/Counter 2 // Timer/Counter 3
	IRQ_TIMER1 = 16

	// Timer/Counter 2
	IRQ_TIMER1_NS = 16

	// Timer/Counter 3
	IRQ_TIMER1_S = 16

	// Timer/Counter 4 // Timer/Counter 5
	IRQ_TIMER2 = 17

	// Timer/Counter 4
	IRQ_TIMER2_NS = 17

	// Timer/Counter 5
	IRQ_TIMER2_S = 17

	// Real-time counter 0 // Real-time counter 1
	IRQ_RTC0 = 20

	// Real-time counter 0
	IRQ_RTC0_NS = 20

	// Real-time counter 1
	IRQ_RTC0_S = 20

	// Real-time counter 2 // Real-time counter 3
	IRQ_RTC1 = 21

	// Real-time counter 2
	IRQ_RTC1_NS = 21

	// Real-time counter 3
	IRQ_RTC1_S = 21

	// Watchdog Timer 0 // Watchdog Timer 1
	IRQ_WDT0 = 24

	// Watchdog Timer 0
	IRQ_WDT0_NS = 24

	// Watchdog Timer 1
	IRQ_WDT0_S = 24

	// Watchdog Timer 2 // Watchdog Timer 3
	IRQ_WDT1 = 25

	// Watchdog Timer 2
	IRQ_WDT1_NS = 25

	// Watchdog Timer 3
	IRQ_WDT1_S = 25

	// Comparator 0 // Low-power comparator 0 // Comparator 1 // Low-power comparator 1
	IRQ_COMP_LPCOMP = 26

	// Comparator 0
	IRQ_COMP_NS = 26

	// Low-power comparator 0
	IRQ_LPCOMP_NS = 26

	// Comparator 1
	IRQ_COMP_S = 26

	// Low-power comparator 1
	IRQ_LPCOMP_S = 26

	// Event generator unit 0 // Event generator unit 1
	IRQ_EGU0 = 27

	// Event generator unit 0
	IRQ_EGU0_NS = 27

	// Event generator unit 1
	IRQ_EGU0_S = 27

	// Event generator unit 2 // Event generator unit 3
	IRQ_EGU1 = 28

	// Event generator unit 2
	IRQ_EGU1_NS = 28

	// Event generator unit 3
	IRQ_EGU1_S = 28

	// Event generator unit 4 // Event generator unit 5
	IRQ_EGU2 = 29

	// Event generator unit 4
	IRQ_EGU2_NS = 29

	// Event generator unit 5
	IRQ_EGU2_S = 29

	// Event generator unit 6 // Event generator unit 7
	IRQ_EGU3 = 30

	// Event generator unit 6
	IRQ_EGU3_NS = 30

	// Event generator unit 7
	IRQ_EGU3_S = 30

	// Event generator unit 8 // Event generator unit 9
	IRQ_EGU4 = 31

	// Event generator unit 8
	IRQ_EGU4_NS = 31

	// Event generator unit 9
	IRQ_EGU4_S = 31

	// Event generator unit 10 // Event generator unit 11
	IRQ_EGU5 = 32

	// Event generator unit 10
	IRQ_EGU5_NS = 32

	// Event generator unit 11
	IRQ_EGU5_S = 32

	// Pulse width modulation unit 0 // Pulse width modulation unit 1
	IRQ_PWM0 = 33

	// Pulse width modulation unit 0
	IRQ_PWM0_NS = 33

	// Pulse width modulation unit 1
	IRQ_PWM0_S = 33

	// Pulse width modulation unit 2 // Pulse width modulation unit 3
	IRQ_PWM1 = 34

	// Pulse width modulation unit 2
	IRQ_PWM1_NS = 34

	// Pulse width modulation unit 3
	IRQ_PWM1_S = 34

	// Pulse width modulation unit 4 // Pulse width modulation unit 5
	IRQ_PWM2 = 35

	// Pulse width modulation unit 4
	IRQ_PWM2_NS = 35

	// Pulse width modulation unit 5
	IRQ_PWM2_S = 35

	// Pulse width modulation unit 6 // Pulse width modulation unit 7
	IRQ_PWM3 = 36

	// Pulse width modulation unit 6
	IRQ_PWM3_NS = 36

	// Pulse width modulation unit 7
	IRQ_PWM3_S = 36

	// Pulse Density Modulation (Digital Microphone) Interface 0 // Pulse Density Modulation (Digital Microphone) Interface 1
	IRQ_PDM0 = 38

	// Pulse Density Modulation (Digital Microphone) Interface 0
	IRQ_PDM0_NS = 38

	// Pulse Density Modulation (Digital Microphone) Interface 1
	IRQ_PDM0_S = 38

	// Inter-IC Sound 0 // Inter-IC Sound 1
	IRQ_I2S0 = 40

	// Inter-IC Sound 0
	IRQ_I2S0_NS = 40

	// Inter-IC Sound 1
	IRQ_I2S0_S = 40

	// Interprocessor communication 0 // Interprocessor communication 1
	IRQ_IPC = 42

	// Interprocessor communication 0
	IRQ_IPC_NS = 42

	// Interprocessor communication 1
	IRQ_IPC_S = 42

	// External flash interface 0 // External flash interface 1
	IRQ_QSPI = 43

	// External flash interface 0
	IRQ_QSPI_NS = 43

	// External flash interface 1
	IRQ_QSPI_S = 43

	// NFC-A compatible radio 0 // NFC-A compatible radio 1
	IRQ_NFCT = 45

	// NFC-A compatible radio 0
	IRQ_NFCT_NS = 45

	// NFC-A compatible radio 1
	IRQ_NFCT_S = 45

	// GPIO Tasks and Events 1
	IRQ_GPIOTE1 = 47

	// GPIO Tasks and Events 1
	IRQ_GPIOTE1_NS = 47

	// Quadrature Decoder 0 // Quadrature Decoder 1
	IRQ_QDEC0 = 51

	// Quadrature Decoder 0
	IRQ_QDEC0_NS = 51

	// Quadrature Decoder 1
	IRQ_QDEC0_S = 51

	// Quadrature Decoder 2 // Quadrature Decoder 3
	IRQ_QDEC1 = 52

	// Quadrature Decoder 2
	IRQ_QDEC1_NS = 52

	// Quadrature Decoder 3
	IRQ_QDEC1_S = 52

	// Universal serial bus device 0 // Universal serial bus device 1
	IRQ_USBD = 54

	// Universal serial bus device 0
	IRQ_USBD_NS = 54

	// Universal serial bus device 1
	IRQ_USBD_S = 54

	// USB Regulator 0 // USB Regulator 1
	IRQ_USBREGULATOR = 55

	// USB Regulator 0
	IRQ_USBREGULATOR_NS = 55

	// USB Regulator 1
	IRQ_USBREGULATOR_S = 55

	// Key management unit 0 // Key management unit 1
	IRQ_KMU = 57

	// Key management unit 0
	IRQ_KMU_NS = 57

	// Key management unit 1
	IRQ_KMU_S = 57

	// ARM TrustZone CryptoCell register interface
	IRQ_CRYPTOCELL = 68

	// ARM TrustZone CryptoCell register interface
	IRQ_CRYPTOCELL_S = 68

	// Highest interrupt number on this device.
	IRQ_max = 68
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export FPU_IRQHandler
func interruptFPU() {
	callHandlers(IRQ_FPU)
}

//export CACHE_IRQHandler
func interruptCACHE() {
	callHandlers(IRQ_CACHE)
}

//export SPU_IRQHandler
func interruptSPU() {
	callHandlers(IRQ_SPU)
}

//export CLOCK_POWER_IRQHandler
func interruptCLOCK_POWER() {
	callHandlers(IRQ_CLOCK_POWER)
}

//export SPIM0_SPIS0_TWIM0_TWIS0_UARTE0_IRQHandler
func interruptSPIM0_SPIS0_TWIM0_TWIS0_UARTE0() {
	callHandlers(IRQ_SPIM0_SPIS0_TWIM0_TWIS0_UARTE0)
}

//export SPIM1_SPIS1_TWIM1_TWIS1_UARTE1_IRQHandler
func interruptSPIM1_SPIS1_TWIM1_TWIS1_UARTE1() {
	callHandlers(IRQ_SPIM1_SPIS1_TWIM1_TWIS1_UARTE1)
}

//export SPIM4_IRQHandler
func interruptSPIM4() {
	callHandlers(IRQ_SPIM4)
}

//export SPIM2_SPIS2_TWIM2_TWIS2_UARTE2_IRQHandler
func interruptSPIM2_SPIS2_TWIM2_TWIS2_UARTE2() {
	callHandlers(IRQ_SPIM2_SPIS2_TWIM2_TWIS2_UARTE2)
}

//export SPIM3_SPIS3_TWIM3_TWIS3_UARTE3_IRQHandler
func interruptSPIM3_SPIS3_TWIM3_TWIS3_UARTE3() {
	callHandlers(IRQ_SPIM3_SPIS3_TWIM3_TWIS3_UARTE3)
}

//export GPIOTE0_IRQHandler
func interruptGPIOTE0() {
	callHandlers(IRQ_GPIOTE0)
}

//export SAADC_IRQHandler
func interruptSAADC() {
	callHandlers(IRQ_SAADC)
}

//export TIMER0_IRQHandler
func interruptTIMER0() {
	callHandlers(IRQ_TIMER0)
}

//export TIMER1_IRQHandler
func interruptTIMER1() {
	callHandlers(IRQ_TIMER1)
}

//export TIMER2_IRQHandler
func interruptTIMER2() {
	callHandlers(IRQ_TIMER2)
}

//export RTC0_IRQHandler
func interruptRTC0() {
	callHandlers(IRQ_RTC0)
}

//export RTC1_IRQHandler
func interruptRTC1() {
	callHandlers(IRQ_RTC1)
}

//export WDT0_IRQHandler
func interruptWDT0() {
	callHandlers(IRQ_WDT0)
}

//export WDT1_IRQHandler
func interruptWDT1() {
	callHandlers(IRQ_WDT1)
}

//export COMP_LPCOMP_IRQHandler
func interruptCOMP_LPCOMP() {
	callHandlers(IRQ_COMP_LPCOMP)
}

//export EGU0_IRQHandler
func interruptEGU0() {
	callHandlers(IRQ_EGU0)
}

//export EGU1_IRQHandler
func interruptEGU1() {
	callHandlers(IRQ_EGU1)
}

//export EGU2_IRQHandler
func interruptEGU2() {
	callHandlers(IRQ_EGU2)
}

//export EGU3_IRQHandler
func interruptEGU3() {
	callHandlers(IRQ_EGU3)
}

//export EGU4_IRQHandler
func interruptEGU4() {
	callHandlers(IRQ_EGU4)
}

//export EGU5_IRQHandler
func interruptEGU5() {
	callHandlers(IRQ_EGU5)
}

//export PWM0_IRQHandler
func interruptPWM0() {
	callHandlers(IRQ_PWM0)
}

//export PWM1_IRQHandler
func interruptPWM1() {
	callHandlers(IRQ_PWM1)
}

//export PWM2_IRQHandler
func interruptPWM2() {
	callHandlers(IRQ_PWM2)
}

//export PWM3_IRQHandler
func interruptPWM3() {
	callHandlers(IRQ_PWM3)
}

//export PDM0_IRQHandler
func interruptPDM0() {
	callHandlers(IRQ_PDM0)
}

//export I2S0_IRQHandler
func interruptI2S0() {
	callHandlers(IRQ_I2S0)
}

//export IPC_IRQHandler
func interruptIPC() {
	callHandlers(IRQ_IPC)
}

//export QSPI_IRQHandler
func interruptQSPI() {
	callHandlers(IRQ_QSPI)
}

//export NFCT_IRQHandler
func interruptNFCT() {
	callHandlers(IRQ_NFCT)
}

//export GPIOTE1_IRQHandler
func interruptGPIOTE1() {
	callHandlers(IRQ_GPIOTE1)
}

//export QDEC0_IRQHandler
func interruptQDEC0() {
	callHandlers(IRQ_QDEC0)
}

//export QDEC1_IRQHandler
func interruptQDEC1() {
	callHandlers(IRQ_QDEC1)
}

//export USBD_IRQHandler
func interruptUSBD() {
	callHandlers(IRQ_USBD)
}

//export USBREGULATOR_IRQHandler
func interruptUSBREGULATOR() {
	callHandlers(IRQ_USBREGULATOR)
}

//export KMU_IRQHandler
func interruptKMU() {
	callHandlers(IRQ_KMU)
}

//export CRYPTOCELL_IRQHandler
func interruptCRYPTOCELL() {
	callHandlers(IRQ_CRYPTOCELL)
}

// Peripherals.
var (
	// CACHEDATA
	CACHEDATA_S = (*CACHEDATA_Type)(unsafe.Pointer(uintptr(0xf00000)))

	// CACHEINFO
	CACHEINFO_S = (*CACHEINFO_Type)(unsafe.Pointer(uintptr(0xf08000)))

	// Factory Information Configuration Registers
	FICR_S = (*FICR_Type)(unsafe.Pointer(uintptr(0xff0000)))

	// User Information Configuration Registers User information configuration registers
	UICR_S = (*UICR_Type)(unsafe.Pointer(uintptr(0xff8000)))

	// Cross-Trigger Interface control. NOTE: this is not a separate peripheral, but describes CM33 functionality.
	CTI_S = (*CTI_Type)(unsafe.Pointer(uintptr(0xe0042000)))

	// Trace and debug control
	TAD_S = (*TAD_Type)(unsafe.Pointer(uintptr(0xe0080000)))

	// Domain configuration management 0
	DCNF_NS = (*DCNF_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// FPU control peripheral 0
	FPU_NS = (*FPU_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Cache
	CACHE_S = (*CACHE_Type)(unsafe.Pointer(uintptr(0x50001000)))

	// System protection unit
	SPU_S = (*SPU_Type)(unsafe.Pointer(uintptr(0x50003000)))

	// Oscillator control 0
	OSCILLATORS_NS = (*OSCILLATORS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Voltage regulators 0
	REGULATORS_NS = (*REGULATORS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Clock management 0
	CLOCK_NS = (*CLOCK_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Power control 0
	POWER_NS = (*POWER_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Reset control 0
	RESET_NS = (*RESET_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Control access port 0
	CTRLAP_NS = (*CTRLAPPERI_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Serial Peripheral Interface Master with EasyDMA 0
	SPIM0_NS = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// SPI Slave 0
	SPIS0_NS = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 0
	TWIM0_NS = (*TWIM_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 0
	TWIS0_NS = (*TWIS_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// UART with EasyDMA 0
	UARTE0_NS = (*UARTE_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// GPIO Tasks and Events 0
	GPIOTE0_S = (*GPIOTE_Type)(unsafe.Pointer(uintptr(0x5000d000)))

	// Analog to Digital Converter 0
	SAADC_NS = (*SAADC_Type)(unsafe.Pointer(uintptr(0x4000e000)))

	// Timer/Counter 0
	TIMER0_NS = (*TIMER_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// Real-time counter 0
	RTC0_NS = (*RTC_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Distributed programmable peripheral interconnect controller 0
	DPPIC_NS = (*DPPIC_Type)(unsafe.Pointer(uintptr(0x40017000)))

	// Watchdog Timer 0
	WDT0_NS = (*WDT_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// Comparator 0
	COMP_NS = (*COMP_Type)(unsafe.Pointer(uintptr(0x4001a000)))

	// Low-power comparator 0
	LPCOMP_NS = (*LPCOMP_Type)(unsafe.Pointer(uintptr(0x4001a000)))

	// Event generator unit 0
	EGU0_NS = (*EGU_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// Pulse width modulation unit 0
	PWM0_NS = (*PWM_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Pulse Density Modulation (Digital Microphone) Interface 0
	PDM0_NS = (*PDM_Type)(unsafe.Pointer(uintptr(0x40026000)))

	// Inter-IC Sound 0
	I2S0_NS = (*I2S_Type)(unsafe.Pointer(uintptr(0x40028000)))

	// Interprocessor communication 0
	IPC_NS = (*IPC_Type)(unsafe.Pointer(uintptr(0x4002a000)))

	// External flash interface 0
	QSPI_NS = (*QSPI_Type)(unsafe.Pointer(uintptr(0x4002b000)))

	// NFC-A compatible radio 0
	NFCT_NS = (*NFCT_Type)(unsafe.Pointer(uintptr(0x4002d000)))

	// MUTEX 0
	MUTEX_NS = (*MUTEX_Type)(unsafe.Pointer(uintptr(0x40030000)))

	// Quadrature Decoder 0
	QDEC0_NS = (*QDEC_Type)(unsafe.Pointer(uintptr(0x40033000)))

	// Universal serial bus device 0
	USBD_NS = (*USBD_Type)(unsafe.Pointer(uintptr(0x40036000)))

	// USB Regulator 0
	USBREGULATOR_NS = (*USBREG_Type)(unsafe.Pointer(uintptr(0x40037000)))

	// Key management unit 0
	KMU_NS = (*KMU_Type)(unsafe.Pointer(uintptr(0x40039000)))

	// Non-volatile memory controller 0
	NVMC_NS = (*NVMC_Type)(unsafe.Pointer(uintptr(0x40039000)))

	// GPIO Port 0
	P0_NS = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40842500)))

	// ARM TrustZone CryptoCell register interface
	CRYPTOCELL_S = (*CRYPTOCELL_Type)(unsafe.Pointer(uintptr(0x50844000)))

	// Volatile Memory controller 0
	VMC_NS = (*VMC_Type)(unsafe.Pointer(uintptr(0x40081000)))

	// Domain configuration management 1
	DCNF_S = (*DCNF_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// FPU control peripheral 1
	FPU_S = (*FPU_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// Oscillator control 1
	OSCILLATORS_S = (*OSCILLATORS_Type)(unsafe.Pointer(uintptr(0x50004000)))

	// Voltage regulators 1
	REGULATORS_S = (*REGULATORS_Type)(unsafe.Pointer(uintptr(0x50004000)))

	// Clock management 1
	CLOCK_S = (*CLOCK_Type)(unsafe.Pointer(uintptr(0x50005000)))

	// Power control 1
	POWER_S = (*POWER_Type)(unsafe.Pointer(uintptr(0x50005000)))

	// Reset control 1
	RESET_S = (*RESET_Type)(unsafe.Pointer(uintptr(0x50005000)))

	// Control access port 1
	CTRLAP_S = (*CTRLAPPERI_Type)(unsafe.Pointer(uintptr(0x50006000)))

	// Serial Peripheral Interface Master with EasyDMA 1
	SPIM0_S = (*SPIM_Type)(unsafe.Pointer(uintptr(0x50008000)))

	// SPI Slave 1
	SPIS0_S = (*SPIS_Type)(unsafe.Pointer(uintptr(0x50008000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 1
	TWIM0_S = (*TWIM_Type)(unsafe.Pointer(uintptr(0x50008000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 1
	TWIS0_S = (*TWIS_Type)(unsafe.Pointer(uintptr(0x50008000)))

	// UART with EasyDMA 1
	UARTE0_S = (*UARTE_Type)(unsafe.Pointer(uintptr(0x50008000)))

	// Serial Peripheral Interface Master with EasyDMA 2
	SPIM1_NS = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// SPI Slave 2
	SPIS1_NS = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 2
	TWIM1_NS = (*TWIM_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 2
	TWIS1_NS = (*TWIS_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// UART with EasyDMA 2
	UARTE1_NS = (*UARTE_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// Serial Peripheral Interface Master with EasyDMA 3
	SPIM1_S = (*SPIM_Type)(unsafe.Pointer(uintptr(0x50009000)))

	// SPI Slave 3
	SPIS1_S = (*SPIS_Type)(unsafe.Pointer(uintptr(0x50009000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 3
	TWIM1_S = (*TWIM_Type)(unsafe.Pointer(uintptr(0x50009000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 3
	TWIS1_S = (*TWIS_Type)(unsafe.Pointer(uintptr(0x50009000)))

	// UART with EasyDMA 3
	UARTE1_S = (*UARTE_Type)(unsafe.Pointer(uintptr(0x50009000)))

	// Serial Peripheral Interface Master with EasyDMA 4
	SPIM4_NS = (*SPIM_Type)(unsafe.Pointer(uintptr(0x4000a000)))

	// Serial Peripheral Interface Master with EasyDMA 5
	SPIM4_S = (*SPIM_Type)(unsafe.Pointer(uintptr(0x5000a000)))

	// Serial Peripheral Interface Master with EasyDMA 6
	SPIM2_NS = (*SPIM_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// SPI Slave 4
	SPIS2_NS = (*SPIS_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 4
	TWIM2_NS = (*TWIM_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 4
	TWIS2_NS = (*TWIS_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// UART with EasyDMA 4
	UARTE2_NS = (*UARTE_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// Serial Peripheral Interface Master with EasyDMA 7
	SPIM2_S = (*SPIM_Type)(unsafe.Pointer(uintptr(0x5000b000)))

	// SPI Slave 5
	SPIS2_S = (*SPIS_Type)(unsafe.Pointer(uintptr(0x5000b000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 5
	TWIM2_S = (*TWIM_Type)(unsafe.Pointer(uintptr(0x5000b000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 5
	TWIS2_S = (*TWIS_Type)(unsafe.Pointer(uintptr(0x5000b000)))

	// UART with EasyDMA 5
	UARTE2_S = (*UARTE_Type)(unsafe.Pointer(uintptr(0x5000b000)))

	// Serial Peripheral Interface Master with EasyDMA 8
	SPIM3_NS = (*SPIM_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// SPI Slave 6
	SPIS3_NS = (*SPIS_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 6
	TWIM3_NS = (*TWIM_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 6
	TWIS3_NS = (*TWIS_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// UART with EasyDMA 6
	UARTE3_NS = (*UARTE_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// Serial Peripheral Interface Master with EasyDMA 9
	SPIM3_S = (*SPIM_Type)(unsafe.Pointer(uintptr(0x5000c000)))

	// SPI Slave 7
	SPIS3_S = (*SPIS_Type)(unsafe.Pointer(uintptr(0x5000c000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 7
	TWIM3_S = (*TWIM_Type)(unsafe.Pointer(uintptr(0x5000c000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 7
	TWIS3_S = (*TWIS_Type)(unsafe.Pointer(uintptr(0x5000c000)))

	// UART with EasyDMA 7
	UARTE3_S = (*UARTE_Type)(unsafe.Pointer(uintptr(0x5000c000)))

	// Analog to Digital Converter 1
	SAADC_S = (*SAADC_Type)(unsafe.Pointer(uintptr(0x5000e000)))

	// Timer/Counter 1
	TIMER0_S = (*TIMER_Type)(unsafe.Pointer(uintptr(0x5000f000)))

	// Timer/Counter 2
	TIMER1_NS = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Timer/Counter 3
	TIMER1_S = (*TIMER_Type)(unsafe.Pointer(uintptr(0x50010000)))

	// Timer/Counter 4
	TIMER2_NS = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40011000)))

	// Timer/Counter 5
	TIMER2_S = (*TIMER_Type)(unsafe.Pointer(uintptr(0x50011000)))

	// Real-time counter 1
	RTC0_S = (*RTC_Type)(unsafe.Pointer(uintptr(0x50014000)))

	// Real-time counter 2
	RTC1_NS = (*RTC_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Real-time counter 3
	RTC1_S = (*RTC_Type)(unsafe.Pointer(uintptr(0x50015000)))

	// Distributed programmable peripheral interconnect controller 1
	DPPIC_S = (*DPPIC_Type)(unsafe.Pointer(uintptr(0x50017000)))

	// Watchdog Timer 1
	WDT0_S = (*WDT_Type)(unsafe.Pointer(uintptr(0x50018000)))

	// Watchdog Timer 2
	WDT1_NS = (*WDT_Type)(unsafe.Pointer(uintptr(0x40019000)))

	// Watchdog Timer 3
	WDT1_S = (*WDT_Type)(unsafe.Pointer(uintptr(0x50019000)))

	// Comparator 1
	COMP_S = (*COMP_Type)(unsafe.Pointer(uintptr(0x5001a000)))

	// Low-power comparator 1
	LPCOMP_S = (*LPCOMP_Type)(unsafe.Pointer(uintptr(0x5001a000)))

	// Event generator unit 1
	EGU0_S = (*EGU_Type)(unsafe.Pointer(uintptr(0x5001b000)))

	// Event generator unit 2
	EGU1_NS = (*EGU_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// Event generator unit 3
	EGU1_S = (*EGU_Type)(unsafe.Pointer(uintptr(0x5001c000)))

	// Event generator unit 4
	EGU2_NS = (*EGU_Type)(unsafe.Pointer(uintptr(0x4001d000)))

	// Event generator unit 5
	EGU2_S = (*EGU_Type)(unsafe.Pointer(uintptr(0x5001d000)))

	// Event generator unit 6
	EGU3_NS = (*EGU_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Event generator unit 7
	EGU3_S = (*EGU_Type)(unsafe.Pointer(uintptr(0x5001e000)))

	// Event generator unit 8
	EGU4_NS = (*EGU_Type)(unsafe.Pointer(uintptr(0x4001f000)))

	// Event generator unit 9
	EGU4_S = (*EGU_Type)(unsafe.Pointer(uintptr(0x5001f000)))

	// Event generator unit 10
	EGU5_NS = (*EGU_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// Event generator unit 11
	EGU5_S = (*EGU_Type)(unsafe.Pointer(uintptr(0x50020000)))

	// Pulse width modulation unit 1
	PWM0_S = (*PWM_Type)(unsafe.Pointer(uintptr(0x50021000)))

	// Pulse width modulation unit 2
	PWM1_NS = (*PWM_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// Pulse width modulation unit 3
	PWM1_S = (*PWM_Type)(unsafe.Pointer(uintptr(0x50022000)))

	// Pulse width modulation unit 4
	PWM2_NS = (*PWM_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// Pulse width modulation unit 5
	PWM2_S = (*PWM_Type)(unsafe.Pointer(uintptr(0x50023000)))

	// Pulse width modulation unit 6
	PWM3_NS = (*PWM_Type)(unsafe.Pointer(uintptr(0x40024000)))

	// Pulse width modulation unit 7
	PWM3_S = (*PWM_Type)(unsafe.Pointer(uintptr(0x50024000)))

	// Pulse Density Modulation (Digital Microphone) Interface 1
	PDM0_S = (*PDM_Type)(unsafe.Pointer(uintptr(0x50026000)))

	// Inter-IC Sound 1
	I2S0_S = (*I2S_Type)(unsafe.Pointer(uintptr(0x50028000)))

	// Interprocessor communication 1
	IPC_S = (*IPC_Type)(unsafe.Pointer(uintptr(0x5002a000)))

	// External flash interface 1
	QSPI_S = (*QSPI_Type)(unsafe.Pointer(uintptr(0x5002b000)))

	// NFC-A compatible radio 1
	NFCT_S = (*NFCT_Type)(unsafe.Pointer(uintptr(0x5002d000)))

	// GPIO Tasks and Events 1
	GPIOTE1_NS = (*GPIOTE_Type)(unsafe.Pointer(uintptr(0x4002f000)))

	// MUTEX 1
	MUTEX_S = (*MUTEX_Type)(unsafe.Pointer(uintptr(0x50030000)))

	// Quadrature Decoder 1
	QDEC0_S = (*QDEC_Type)(unsafe.Pointer(uintptr(0x50033000)))

	// Quadrature Decoder 2
	QDEC1_NS = (*QDEC_Type)(unsafe.Pointer(uintptr(0x40034000)))

	// Quadrature Decoder 3
	QDEC1_S = (*QDEC_Type)(unsafe.Pointer(uintptr(0x50034000)))

	// Universal serial bus device 1
	USBD_S = (*USBD_Type)(unsafe.Pointer(uintptr(0x50036000)))

	// USB Regulator 1
	USBREGULATOR_S = (*USBREG_Type)(unsafe.Pointer(uintptr(0x50037000)))

	// Key management unit 1
	KMU_S = (*KMU_Type)(unsafe.Pointer(uintptr(0x50039000)))

	// Non-volatile memory controller 1
	NVMC_S = (*NVMC_Type)(unsafe.Pointer(uintptr(0x50039000)))

	// GPIO Port 1
	P1_NS = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40842800)))

	// GPIO Port 2
	P0_S = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50842500)))

	// GPIO Port 3
	P1_S = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50842800)))

	// Volatile Memory controller 1
	VMC_S = (*VMC_Type)(unsafe.Pointer(uintptr(0x50081000)))
)

// CACHEDATA
type CACHEDATA_Type struct {
	SET [256]CACHEDATA_SET_Type // 0x0
}

// CACHEINFO
type CACHEINFO_Type struct {
	SET [256]CACHEINFO_SET_Type // 0x0
}

type CACHEINFO_SET_Type struct {
	WAY [2]volatile.Register32 // 0x0
}

// Factory Information Configuration Registers
type FICR_Type struct {
	_           [512]byte
	INFO        FICR_INFO_Type // 0x200
	_           [212]byte
	TRIMCNF     [32]FICR_TRIMCNF_Type // 0x300
	_           [80]byte
	NFC         FICR_NFC_Type // 0x450
	_           [1952]byte
	TRNG90B     FICR_TRNG90B_Type   // 0xC00
	XOSC32MTRIM volatile.Register32 // 0xC20
}

// FICR.XOSC32MTRIM: XOSC32M capacitor selection trim values
func (o *FICR_Type) SetXOSC32MTRIM_SLOPE(value uint32) {
	volatile.StoreUint32(&o.XOSC32MTRIM.Reg, volatile.LoadUint32(&o.XOSC32MTRIM.Reg)&^(0x1f)|value)
}
func (o *FICR_Type) GetXOSC32MTRIM_SLOPE() uint32 {
	return volatile.LoadUint32(&o.XOSC32MTRIM.Reg) & 0x1f
}
func (o *FICR_Type) SetXOSC32MTRIM_OFFSET(value uint32) {
	volatile.StoreUint32(&o.XOSC32MTRIM.Reg, volatile.LoadUint32(&o.XOSC32MTRIM.Reg)&^(0x3e0)|value<<5)
}
func (o *FICR_Type) GetXOSC32MTRIM_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.XOSC32MTRIM.Reg) & 0x3e0) >> 5
}

type FICR_INFO_Type struct {
	CONFIGID     volatile.Register32    // 0x200
	DEVICEID     [2]volatile.Register32 // 0x204
	PART         volatile.Register32    // 0x20C
	VARIANT      volatile.Register32    // 0x210
	PACKAGE      volatile.Register32    // 0x214
	RAM          volatile.Register32    // 0x218
	FLASH        volatile.Register32    // 0x21C
	CODEPAGESIZE volatile.Register32    // 0x220
	CODESIZE     volatile.Register32    // 0x224
	DEVICETYPE   volatile.Register32    // 0x228
}

// FICR_INFO.CONFIGID: Configuration identifier
func (o *FICR_INFO_Type) SetCONFIGID_HWID(value uint32) {
	volatile.StoreUint32(&o.CONFIGID.Reg, volatile.LoadUint32(&o.CONFIGID.Reg)&^(0xffff)|value)
}
func (o *FICR_INFO_Type) GetCONFIGID_HWID() uint32 {
	return volatile.LoadUint32(&o.CONFIGID.Reg) & 0xffff
}

// FICR_INFO.PART: Part code
func (o *FICR_INFO_Type) SetPART(value uint32) {
	volatile.StoreUint32(&o.PART.Reg, value)
}
func (o *FICR_INFO_Type) GetPART() uint32 {
	return volatile.LoadUint32(&o.PART.Reg)
}

// FICR_INFO.VARIANT: Part Variant, Hardware version and Production configuration
func (o *FICR_INFO_Type) SetVARIANT(value uint32) {
	volatile.StoreUint32(&o.VARIANT.Reg, value)
}
func (o *FICR_INFO_Type) GetVARIANT() uint32 {
	return volatile.LoadUint32(&o.VARIANT.Reg)
}

// FICR_INFO.PACKAGE: Package option
func (o *FICR_INFO_Type) SetPACKAGE(value uint32) {
	volatile.StoreUint32(&o.PACKAGE.Reg, value)
}
func (o *FICR_INFO_Type) GetPACKAGE() uint32 {
	return volatile.LoadUint32(&o.PACKAGE.Reg)
}

// FICR_INFO.RAM: RAM variant
func (o *FICR_INFO_Type) SetRAM(value uint32) {
	volatile.StoreUint32(&o.RAM.Reg, value)
}
func (o *FICR_INFO_Type) GetRAM() uint32 {
	return volatile.LoadUint32(&o.RAM.Reg)
}

// FICR_INFO.FLASH: Flash variant
func (o *FICR_INFO_Type) SetFLASH(value uint32) {
	volatile.StoreUint32(&o.FLASH.Reg, value)
}
func (o *FICR_INFO_Type) GetFLASH() uint32 {
	return volatile.LoadUint32(&o.FLASH.Reg)
}

// FICR_INFO.CODEPAGESIZE: Code memory page size in bytes
func (o *FICR_INFO_Type) SetCODEPAGESIZE(value uint32) {
	volatile.StoreUint32(&o.CODEPAGESIZE.Reg, value)
}
func (o *FICR_INFO_Type) GetCODEPAGESIZE() uint32 {
	return volatile.LoadUint32(&o.CODEPAGESIZE.Reg)
}

// FICR_INFO.CODESIZE: Code memory size
func (o *FICR_INFO_Type) SetCODESIZE(value uint32) {
	volatile.StoreUint32(&o.CODESIZE.Reg, value)
}
func (o *FICR_INFO_Type) GetCODESIZE() uint32 {
	return volatile.LoadUint32(&o.CODESIZE.Reg)
}

// FICR_INFO.DEVICETYPE: Device type
func (o *FICR_INFO_Type) SetDEVICETYPE(value uint32) {
	volatile.StoreUint32(&o.DEVICETYPE.Reg, value)
}
func (o *FICR_INFO_Type) GetDEVICETYPE() uint32 {
	return volatile.LoadUint32(&o.DEVICETYPE.Reg)
}

type FICR_TRIMCNF_Type struct {
	ADDR volatile.Register32 // 0x300
	DATA volatile.Register32 // 0x304
}

// FICR_TRIMCNF.ADDR: Description cluster: Address of the PAR register which will be written
func (o *FICR_TRIMCNF_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *FICR_TRIMCNF_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// FICR_TRIMCNF.DATA: Description cluster: Data
func (o *FICR_TRIMCNF_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *FICR_TRIMCNF_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

type FICR_NFC_Type struct {
	TAGHEADER0 volatile.Register32 // 0x450
	TAGHEADER1 volatile.Register32 // 0x454
	TAGHEADER2 volatile.Register32 // 0x458
	TAGHEADER3 volatile.Register32 // 0x45C
}

// FICR_NFC.TAGHEADER0: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER0_MFGID(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_MFGID() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER0_UD1(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_UD1() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER0_UD2(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_UD2() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER0_UD3(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER0.Reg, volatile.LoadUint32(&o.TAGHEADER0.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER0_UD3() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER0.Reg) & 0xff000000) >> 24
}

// FICR_NFC.TAGHEADER1: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER1_UD4(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD4() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER1_UD5(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD5() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER1_UD6(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD6() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER1_UD7(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER1.Reg, volatile.LoadUint32(&o.TAGHEADER1.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER1_UD7() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER1.Reg) & 0xff000000) >> 24
}

// FICR_NFC.TAGHEADER2: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER2_UD8(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD8() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER2_UD9(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD9() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER2_UD10(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD10() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER2_UD11(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER2.Reg, volatile.LoadUint32(&o.TAGHEADER2.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER2_UD11() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER2.Reg) & 0xff000000) >> 24
}

// FICR_NFC.TAGHEADER3: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
func (o *FICR_NFC_Type) SetTAGHEADER3_UD12(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff)|value)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD12() uint32 {
	return volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff
}
func (o *FICR_NFC_Type) SetTAGHEADER3_UD13(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff00)|value<<8)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD13() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff00) >> 8
}
func (o *FICR_NFC_Type) SetTAGHEADER3_UD14(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff0000)|value<<16)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD14() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff0000) >> 16
}
func (o *FICR_NFC_Type) SetTAGHEADER3_UD15(value uint32) {
	volatile.StoreUint32(&o.TAGHEADER3.Reg, volatile.LoadUint32(&o.TAGHEADER3.Reg)&^(0xff000000)|value<<24)
}
func (o *FICR_NFC_Type) GetTAGHEADER3_UD15() uint32 {
	return (volatile.LoadUint32(&o.TAGHEADER3.Reg) & 0xff000000) >> 24
}

type FICR_TRNG90B_Type struct {
	BYTES    volatile.Register32 // 0xC00
	RCCUTOFF volatile.Register32 // 0xC04
	APCUTOFF volatile.Register32 // 0xC08
	STARTUP  volatile.Register32 // 0xC0C
	ROSC1    volatile.Register32 // 0xC10
	ROSC2    volatile.Register32 // 0xC14
	ROSC3    volatile.Register32 // 0xC18
	ROSC4    volatile.Register32 // 0xC1C
}

// FICR_TRNG90B.BYTES: Amount of bytes for the required entropy bits
func (o *FICR_TRNG90B_Type) SetBYTES(value uint32) {
	volatile.StoreUint32(&o.BYTES.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetBYTES() uint32 {
	return volatile.LoadUint32(&o.BYTES.Reg)
}

// FICR_TRNG90B.RCCUTOFF: Repetition counter cutoff
func (o *FICR_TRNG90B_Type) SetRCCUTOFF(value uint32) {
	volatile.StoreUint32(&o.RCCUTOFF.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetRCCUTOFF() uint32 {
	return volatile.LoadUint32(&o.RCCUTOFF.Reg)
}

// FICR_TRNG90B.APCUTOFF: Adaptive proportion cutoff
func (o *FICR_TRNG90B_Type) SetAPCUTOFF(value uint32) {
	volatile.StoreUint32(&o.APCUTOFF.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetAPCUTOFF() uint32 {
	return volatile.LoadUint32(&o.APCUTOFF.Reg)
}

// FICR_TRNG90B.STARTUP: Amount of bytes for the startup tests
func (o *FICR_TRNG90B_Type) SetSTARTUP(value uint32) {
	volatile.StoreUint32(&o.STARTUP.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetSTARTUP() uint32 {
	return volatile.LoadUint32(&o.STARTUP.Reg)
}

// FICR_TRNG90B.ROSC1: Sample count for ring oscillator 1
func (o *FICR_TRNG90B_Type) SetROSC1(value uint32) {
	volatile.StoreUint32(&o.ROSC1.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetROSC1() uint32 {
	return volatile.LoadUint32(&o.ROSC1.Reg)
}

// FICR_TRNG90B.ROSC2: Sample count for ring oscillator 2
func (o *FICR_TRNG90B_Type) SetROSC2(value uint32) {
	volatile.StoreUint32(&o.ROSC2.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetROSC2() uint32 {
	return volatile.LoadUint32(&o.ROSC2.Reg)
}

// FICR_TRNG90B.ROSC3: Sample count for ring oscillator 3
func (o *FICR_TRNG90B_Type) SetROSC3(value uint32) {
	volatile.StoreUint32(&o.ROSC3.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetROSC3() uint32 {
	return volatile.LoadUint32(&o.ROSC3.Reg)
}

// FICR_TRNG90B.ROSC4: Sample count for ring oscillator 4
func (o *FICR_TRNG90B_Type) SetROSC4(value uint32) {
	volatile.StoreUint32(&o.ROSC4.Reg, value)
}
func (o *FICR_TRNG90B_Type) GetROSC4() uint32 {
	return volatile.LoadUint32(&o.ROSC4.Reg)
}

// User Information Configuration Registers User information configuration registers
type UICR_Type struct {
	APPROTECT       volatile.Register32 // 0x0
	_               [8]byte
	EXTSUPPLY       volatile.Register32 // 0xC
	VREGHVOUT       volatile.Register32 // 0x10
	HFXOCNT         volatile.Register32 // 0x14
	_               [4]byte
	SECUREAPPROTECT volatile.Register32 // 0x1C
	ERASEPROTECT    volatile.Register32 // 0x20
	TINSTANCE       volatile.Register32 // 0x24
	NFCPINS         volatile.Register32 // 0x28
	_               [212]byte
	OTP             [192]volatile.Register32 // 0x100
	KEYSLOT         UICR_KEYSLOT_Type        // 0x400
}

// UICR.APPROTECT: Access port protection
func (o *UICR_Type) SetAPPROTECT(value uint32) {
	volatile.StoreUint32(&o.APPROTECT.Reg, value)
}
func (o *UICR_Type) GetAPPROTECT() uint32 {
	return volatile.LoadUint32(&o.APPROTECT.Reg)
}

// UICR.EXTSUPPLY: Enable external circuitry to be supplied from VDD pin. Applicable in 'High voltage mode' only.
func (o *UICR_Type) SetEXTSUPPLY(value uint32) {
	volatile.StoreUint32(&o.EXTSUPPLY.Reg, volatile.LoadUint32(&o.EXTSUPPLY.Reg)&^(0x1)|value)
}
func (o *UICR_Type) GetEXTSUPPLY() uint32 {
	return volatile.LoadUint32(&o.EXTSUPPLY.Reg) & 0x1
}

// UICR.VREGHVOUT: GPIO reference voltage / external output supply voltage in 'High voltage mode'.
func (o *UICR_Type) SetVREGHVOUT(value uint32) {
	volatile.StoreUint32(&o.VREGHVOUT.Reg, volatile.LoadUint32(&o.VREGHVOUT.Reg)&^(0x7)|value)
}
func (o *UICR_Type) GetVREGHVOUT() uint32 {
	return volatile.LoadUint32(&o.VREGHVOUT.Reg) & 0x7
}

// UICR.HFXOCNT: HFXO startup counter
func (o *UICR_Type) SetHFXOCNT(value uint32) {
	volatile.StoreUint32(&o.HFXOCNT.Reg, volatile.LoadUint32(&o.HFXOCNT.Reg)&^(0xff)|value)
}
func (o *UICR_Type) GetHFXOCNT() uint32 {
	return volatile.LoadUint32(&o.HFXOCNT.Reg) & 0xff
}

// UICR.SECUREAPPROTECT: Secure access port protection
func (o *UICR_Type) SetSECUREAPPROTECT(value uint32) {
	volatile.StoreUint32(&o.SECUREAPPROTECT.Reg, value)
}
func (o *UICR_Type) GetSECUREAPPROTECT() uint32 {
	return volatile.LoadUint32(&o.SECUREAPPROTECT.Reg)
}

// UICR.ERASEPROTECT: Erase protection
func (o *UICR_Type) SetERASEPROTECT(value uint32) {
	volatile.StoreUint32(&o.ERASEPROTECT.Reg, value)
}
func (o *UICR_Type) GetERASEPROTECT() uint32 {
	return volatile.LoadUint32(&o.ERASEPROTECT.Reg)
}

// UICR.TINSTANCE: SW-DP Target instance
func (o *UICR_Type) SetTINSTANCE(value uint32) {
	volatile.StoreUint32(&o.TINSTANCE.Reg, volatile.LoadUint32(&o.TINSTANCE.Reg)&^(0xf0000000)|value<<28)
}
func (o *UICR_Type) GetTINSTANCE() uint32 {
	return (volatile.LoadUint32(&o.TINSTANCE.Reg) & 0xf0000000) >> 28
}

// UICR.NFCPINS: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
func (o *UICR_Type) SetNFCPINS_PROTECT(value uint32) {
	volatile.StoreUint32(&o.NFCPINS.Reg, volatile.LoadUint32(&o.NFCPINS.Reg)&^(0x1)|value)
}
func (o *UICR_Type) GetNFCPINS_PROTECT() uint32 {
	return volatile.LoadUint32(&o.NFCPINS.Reg) & 0x1
}

// UICR.OTP: Description collection: One time programmable memory
func (o *UICR_Type) SetOTP_LOWER(idx int, value uint32) {
	volatile.StoreUint32(&o.OTP[idx].Reg, volatile.LoadUint32(&o.OTP[idx].Reg)&^(0xffff)|value)
}
func (o *UICR_Type) GetOTP_LOWER(idx int) uint32 {
	return volatile.LoadUint32(&o.OTP[idx].Reg) & 0xffff
}
func (o *UICR_Type) SetOTP_UPPER(idx int, value uint32) {
	volatile.StoreUint32(&o.OTP[idx].Reg, volatile.LoadUint32(&o.OTP[idx].Reg)&^(0xffff0000)|value<<16)
}
func (o *UICR_Type) GetOTP_UPPER(idx int) uint32 {
	return (volatile.LoadUint32(&o.OTP[idx].Reg) & 0xffff0000) >> 16
}

// Cross-Trigger Interface control. NOTE: this is not a separate peripheral, but describes CM33 functionality.
type CTI_Type struct {
	CTICONTROL       volatile.Register32 // 0x0
	_                [12]byte
	CTIINTACK        volatile.Register32    // 0x10
	CTIAPPSET        volatile.Register32    // 0x14
	CTIAPPCLEAR      volatile.Register32    // 0x18
	CTIAPPPULSE      volatile.Register32    // 0x1C
	CTIINEN          [8]volatile.Register32 // 0x20
	_                [96]byte
	CTIOUTEN         [8]volatile.Register32 // 0xA0
	_                [112]byte
	CTITRIGINSTATUS  volatile.Register32 // 0x130
	CTITRIGOUTSTATUS volatile.Register32 // 0x134
	CTICHINSTATUS    volatile.Register32 // 0x138
	_                [4]byte
	CTIGATE          volatile.Register32 // 0x140
	_                [3704]byte
	DEVARCH          volatile.Register32 // 0xFBC
	_                [8]byte
	DEVID            volatile.Register32 // 0xFC8
	DEVTYPE          volatile.Register32 // 0xFCC
	PIDR4            volatile.Register32 // 0xFD0
	PIDR5            volatile.Register32 // 0xFD4
	PIDR6            volatile.Register32 // 0xFD8
	PIDR7            volatile.Register32 // 0xFDC
	PIDR0            volatile.Register32 // 0xFE0
	PIDR1            volatile.Register32 // 0xFE4
	PIDR2            volatile.Register32 // 0xFE8
	PIDR3            volatile.Register32 // 0xFEC
	CIDR0            volatile.Register32 // 0xFF0
	CIDR1            volatile.Register32 // 0xFF4
	CIDR2            volatile.Register32 // 0xFF8
	CIDR3            volatile.Register32 // 0xFFC
}

// CTI.CTICONTROL: CTI Control register
func (o *CTI_Type) SetCTICONTROL_GLBEN(value uint32) {
	volatile.StoreUint32(&o.CTICONTROL.Reg, volatile.LoadUint32(&o.CTICONTROL.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTICONTROL_GLBEN() uint32 {
	return volatile.LoadUint32(&o.CTICONTROL.Reg) & 0x1
}

// CTI.CTIINTACK: CTI Interrupt Acknowledge register
func (o *CTI_Type) SetCTIINTACK_DEBUGREQ(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIINTACK_DEBUGREQ() uint32 {
	return volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x1
}
func (o *CTI_Type) SetCTIINTACK_CPURESTART(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIINTACK_CPURESTART() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIINTACK_UNUSED0(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIINTACK_UNUSED0() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIINTACK_UNUSED1(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIINTACK_UNUSED1() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x8) >> 3
}
func (o *CTI_Type) SetCTIINTACK_ETMEVTIN0(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x10)|value<<4)
}
func (o *CTI_Type) GetCTIINTACK_ETMEVTIN0() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x10) >> 4
}
func (o *CTI_Type) SetCTIINTACK_ETMEVTIN1(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x20)|value<<5)
}
func (o *CTI_Type) GetCTIINTACK_ETMEVTIN1() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x20) >> 5
}
func (o *CTI_Type) SetCTIINTACK_ETMEVTIN2(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x40)|value<<6)
}
func (o *CTI_Type) GetCTIINTACK_ETMEVTIN2() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x40) >> 6
}
func (o *CTI_Type) SetCTIINTACK_ETMEVTIN3(value uint32) {
	volatile.StoreUint32(&o.CTIINTACK.Reg, volatile.LoadUint32(&o.CTIINTACK.Reg)&^(0x80)|value<<7)
}
func (o *CTI_Type) GetCTIINTACK_ETMEVTIN3() uint32 {
	return (volatile.LoadUint32(&o.CTIINTACK.Reg) & 0x80) >> 7
}

// CTI.CTIAPPSET: CTI Application Trigger Set register
func (o *CTI_Type) SetCTIAPPSET_APPSET_0(value uint32) {
	volatile.StoreUint32(&o.CTIAPPSET.Reg, volatile.LoadUint32(&o.CTIAPPSET.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIAPPSET_APPSET_0() uint32 {
	return volatile.LoadUint32(&o.CTIAPPSET.Reg) & 0x1
}
func (o *CTI_Type) SetCTIAPPSET_APPSET_1(value uint32) {
	volatile.StoreUint32(&o.CTIAPPSET.Reg, volatile.LoadUint32(&o.CTIAPPSET.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIAPPSET_APPSET_1() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPSET.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIAPPSET_APPSET_2(value uint32) {
	volatile.StoreUint32(&o.CTIAPPSET.Reg, volatile.LoadUint32(&o.CTIAPPSET.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIAPPSET_APPSET_2() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPSET.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIAPPSET_APPSET_3(value uint32) {
	volatile.StoreUint32(&o.CTIAPPSET.Reg, volatile.LoadUint32(&o.CTIAPPSET.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIAPPSET_APPSET_3() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPSET.Reg) & 0x8) >> 3
}

// CTI.CTIAPPCLEAR: CTI Application Trigger Clear register
func (o *CTI_Type) SetCTIAPPCLEAR_APPCLEAR_0(value uint32) {
	volatile.StoreUint32(&o.CTIAPPCLEAR.Reg, volatile.LoadUint32(&o.CTIAPPCLEAR.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIAPPCLEAR_APPCLEAR_0() uint32 {
	return volatile.LoadUint32(&o.CTIAPPCLEAR.Reg) & 0x1
}
func (o *CTI_Type) SetCTIAPPCLEAR_APPCLEAR_1(value uint32) {
	volatile.StoreUint32(&o.CTIAPPCLEAR.Reg, volatile.LoadUint32(&o.CTIAPPCLEAR.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIAPPCLEAR_APPCLEAR_1() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPCLEAR.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIAPPCLEAR_APPCLEAR_2(value uint32) {
	volatile.StoreUint32(&o.CTIAPPCLEAR.Reg, volatile.LoadUint32(&o.CTIAPPCLEAR.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIAPPCLEAR_APPCLEAR_2() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPCLEAR.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIAPPCLEAR_APPCLEAR_3(value uint32) {
	volatile.StoreUint32(&o.CTIAPPCLEAR.Reg, volatile.LoadUint32(&o.CTIAPPCLEAR.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIAPPCLEAR_APPCLEAR_3() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPCLEAR.Reg) & 0x8) >> 3
}

// CTI.CTIAPPPULSE: CTI Application Pulse register
func (o *CTI_Type) SetCTIAPPPULSE_APPULSE_0(value uint32) {
	volatile.StoreUint32(&o.CTIAPPPULSE.Reg, volatile.LoadUint32(&o.CTIAPPPULSE.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIAPPPULSE_APPULSE_0() uint32 {
	return volatile.LoadUint32(&o.CTIAPPPULSE.Reg) & 0x1
}
func (o *CTI_Type) SetCTIAPPPULSE_APPULSE_1(value uint32) {
	volatile.StoreUint32(&o.CTIAPPPULSE.Reg, volatile.LoadUint32(&o.CTIAPPPULSE.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIAPPPULSE_APPULSE_1() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPPULSE.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIAPPPULSE_APPULSE_2(value uint32) {
	volatile.StoreUint32(&o.CTIAPPPULSE.Reg, volatile.LoadUint32(&o.CTIAPPPULSE.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIAPPPULSE_APPULSE_2() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPPULSE.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIAPPPULSE_APPULSE_3(value uint32) {
	volatile.StoreUint32(&o.CTIAPPPULSE.Reg, volatile.LoadUint32(&o.CTIAPPPULSE.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIAPPPULSE_APPULSE_3() uint32 {
	return (volatile.LoadUint32(&o.CTIAPPPULSE.Reg) & 0x8) >> 3
}

// CTI.CTIINEN: Description collection: CTI Trigger input
func (o *CTI_Type) SetCTIINEN_TRIGINEN_0(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIINEN[idx].Reg, volatile.LoadUint32(&o.CTIINEN[idx].Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIINEN_TRIGINEN_0(idx int) uint32 {
	return volatile.LoadUint32(&o.CTIINEN[idx].Reg) & 0x1
}
func (o *CTI_Type) SetCTIINEN_TRIGINEN_1(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIINEN[idx].Reg, volatile.LoadUint32(&o.CTIINEN[idx].Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIINEN_TRIGINEN_1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CTIINEN[idx].Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIINEN_TRIGINEN_2(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIINEN[idx].Reg, volatile.LoadUint32(&o.CTIINEN[idx].Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIINEN_TRIGINEN_2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CTIINEN[idx].Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIINEN_TRIGINEN_3(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIINEN[idx].Reg, volatile.LoadUint32(&o.CTIINEN[idx].Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIINEN_TRIGINEN_3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CTIINEN[idx].Reg) & 0x8) >> 3
}

// CTI.CTIOUTEN: Description collection: CTI Trigger output
func (o *CTI_Type) SetCTIOUTEN_TRIGOUTEN_0(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIOUTEN[idx].Reg, volatile.LoadUint32(&o.CTIOUTEN[idx].Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIOUTEN_TRIGOUTEN_0(idx int) uint32 {
	return volatile.LoadUint32(&o.CTIOUTEN[idx].Reg) & 0x1
}
func (o *CTI_Type) SetCTIOUTEN_TRIGOUTEN_1(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIOUTEN[idx].Reg, volatile.LoadUint32(&o.CTIOUTEN[idx].Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIOUTEN_TRIGOUTEN_1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CTIOUTEN[idx].Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIOUTEN_TRIGOUTEN_2(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIOUTEN[idx].Reg, volatile.LoadUint32(&o.CTIOUTEN[idx].Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIOUTEN_TRIGOUTEN_2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CTIOUTEN[idx].Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIOUTEN_TRIGOUTEN_3(idx int, value uint32) {
	volatile.StoreUint32(&o.CTIOUTEN[idx].Reg, volatile.LoadUint32(&o.CTIOUTEN[idx].Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIOUTEN_TRIGOUTEN_3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CTIOUTEN[idx].Reg) & 0x8) >> 3
}

// CTI.CTITRIGINSTATUS: CTI Trigger In Status register
func (o *CTI_Type) SetCTITRIGINSTATUS_CPUHALTED(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_CPUHALTED() uint32 {
	return volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x1
}
func (o *CTI_Type) SetCTITRIGINSTATUS_DWTCOMPOUT0(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_DWTCOMPOUT0() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTITRIGINSTATUS_DWTCOMPOUT1(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_DWTCOMPOUT1() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTITRIGINSTATUS_DWTCOMPOUT2(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_DWTCOMPOUT2() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x8) >> 3
}
func (o *CTI_Type) SetCTITRIGINSTATUS_ETMEVTOUT0(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_ETMEVTOUT0() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x10) >> 4
}
func (o *CTI_Type) SetCTITRIGINSTATUS_ETMEVTOUT1(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_ETMEVTOUT1() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x20) >> 5
}
func (o *CTI_Type) SetCTITRIGINSTATUS_UNUSED0(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_UNUSED0() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x40) >> 6
}
func (o *CTI_Type) SetCTITRIGINSTATUS_UNUSED1(value uint32) {
	volatile.StoreUint32(&o.CTITRIGINSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *CTI_Type) GetCTITRIGINSTATUS_UNUSED1() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGINSTATUS.Reg) & 0x80) >> 7
}

// CTI.CTITRIGOUTSTATUS: CTI Trigger Out Status register
func (o *CTI_Type) SetCTITRIGOUTSTATUS_DEBUGREQ(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_DEBUGREQ() uint32 {
	return volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x1
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_CPURESTART(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_CPURESTART() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_UNUSED0(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_UNUSED0() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_UNUSED1(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_UNUSED1() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x8) >> 3
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_ETMEVTIN0(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_ETMEVTIN0() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x10) >> 4
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_ETMEVTIN1(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_ETMEVTIN1() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x20) >> 5
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_ETMEVTIN2(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_ETMEVTIN2() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x40) >> 6
}
func (o *CTI_Type) SetCTITRIGOUTSTATUS_ETMEVTIN3(value uint32) {
	volatile.StoreUint32(&o.CTITRIGOUTSTATUS.Reg, volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *CTI_Type) GetCTITRIGOUTSTATUS_ETMEVTIN3() uint32 {
	return (volatile.LoadUint32(&o.CTITRIGOUTSTATUS.Reg) & 0x80) >> 7
}

// CTI.CTICHINSTATUS: CTI Channel In Status register
func (o *CTI_Type) SetCTICHINSTATUS_CTICHINSTATUS_0(value uint32) {
	volatile.StoreUint32(&o.CTICHINSTATUS.Reg, volatile.LoadUint32(&o.CTICHINSTATUS.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTICHINSTATUS_CTICHINSTATUS_0() uint32 {
	return volatile.LoadUint32(&o.CTICHINSTATUS.Reg) & 0x1
}
func (o *CTI_Type) SetCTICHINSTATUS_CTICHINSTATUS_1(value uint32) {
	volatile.StoreUint32(&o.CTICHINSTATUS.Reg, volatile.LoadUint32(&o.CTICHINSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTICHINSTATUS_CTICHINSTATUS_1() uint32 {
	return (volatile.LoadUint32(&o.CTICHINSTATUS.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTICHINSTATUS_CTICHINSTATUS_2(value uint32) {
	volatile.StoreUint32(&o.CTICHINSTATUS.Reg, volatile.LoadUint32(&o.CTICHINSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTICHINSTATUS_CTICHINSTATUS_2() uint32 {
	return (volatile.LoadUint32(&o.CTICHINSTATUS.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTICHINSTATUS_CTICHINSTATUS_3(value uint32) {
	volatile.StoreUint32(&o.CTICHINSTATUS.Reg, volatile.LoadUint32(&o.CTICHINSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTICHINSTATUS_CTICHINSTATUS_3() uint32 {
	return (volatile.LoadUint32(&o.CTICHINSTATUS.Reg) & 0x8) >> 3
}

// CTI.CTIGATE: Enable CTI Channel Gate register
func (o *CTI_Type) SetCTIGATE_CTIGATEEN_0(value uint32) {
	volatile.StoreUint32(&o.CTIGATE.Reg, volatile.LoadUint32(&o.CTIGATE.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetCTIGATE_CTIGATEEN_0() uint32 {
	return volatile.LoadUint32(&o.CTIGATE.Reg) & 0x1
}
func (o *CTI_Type) SetCTIGATE_CTIGATEEN_1(value uint32) {
	volatile.StoreUint32(&o.CTIGATE.Reg, volatile.LoadUint32(&o.CTIGATE.Reg)&^(0x2)|value<<1)
}
func (o *CTI_Type) GetCTIGATE_CTIGATEEN_1() uint32 {
	return (volatile.LoadUint32(&o.CTIGATE.Reg) & 0x2) >> 1
}
func (o *CTI_Type) SetCTIGATE_CTIGATEEN_2(value uint32) {
	volatile.StoreUint32(&o.CTIGATE.Reg, volatile.LoadUint32(&o.CTIGATE.Reg)&^(0x4)|value<<2)
}
func (o *CTI_Type) GetCTIGATE_CTIGATEEN_2() uint32 {
	return (volatile.LoadUint32(&o.CTIGATE.Reg) & 0x4) >> 2
}
func (o *CTI_Type) SetCTIGATE_CTIGATEEN_3(value uint32) {
	volatile.StoreUint32(&o.CTIGATE.Reg, volatile.LoadUint32(&o.CTIGATE.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetCTIGATE_CTIGATEEN_3() uint32 {
	return (volatile.LoadUint32(&o.CTIGATE.Reg) & 0x8) >> 3
}

// CTI.DEVARCH: Device Architecture register
func (o *CTI_Type) SetDEVARCH_Architecture(value uint32) {
	volatile.StoreUint32(&o.DEVARCH.Reg, volatile.LoadUint32(&o.DEVARCH.Reg)&^(0x1)|value)
}
func (o *CTI_Type) GetDEVARCH_Architecture() uint32 {
	return volatile.LoadUint32(&o.DEVARCH.Reg) & 0x1
}

// CTI.DEVID: Device Configuration register
func (o *CTI_Type) SetDEVID_EXTMUXNUM(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x1f)|value)
}
func (o *CTI_Type) GetDEVID_EXTMUXNUM() uint32 {
	return volatile.LoadUint32(&o.DEVID.Reg) & 0x1f
}
func (o *CTI_Type) SetDEVID_NUMTRIG(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0xff00)|value<<8)
}
func (o *CTI_Type) GetDEVID_NUMTRIG() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0xff00) >> 8
}
func (o *CTI_Type) SetDEVID_NUMCH(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0xf0000)|value<<16)
}
func (o *CTI_Type) GetDEVID_NUMCH() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0xf0000) >> 16
}

// CTI.DEVTYPE: Device Type Identifier register
func (o *CTI_Type) SetDEVTYPE_MAJOR(value uint32) {
	volatile.StoreUint32(&o.DEVTYPE.Reg, volatile.LoadUint32(&o.DEVTYPE.Reg)&^(0xf)|value)
}
func (o *CTI_Type) GetDEVTYPE_MAJOR() uint32 {
	return volatile.LoadUint32(&o.DEVTYPE.Reg) & 0xf
}
func (o *CTI_Type) SetDEVTYPE_SUB(value uint32) {
	volatile.StoreUint32(&o.DEVTYPE.Reg, volatile.LoadUint32(&o.DEVTYPE.Reg)&^(0xf0)|value<<4)
}
func (o *CTI_Type) GetDEVTYPE_SUB() uint32 {
	return (volatile.LoadUint32(&o.DEVTYPE.Reg) & 0xf0) >> 4
}

// CTI.PIDR4: Peripheral ID4 Register
func (o *CTI_Type) SetPIDR4_DES_2(value uint32) {
	volatile.StoreUint32(&o.PIDR4.Reg, volatile.LoadUint32(&o.PIDR4.Reg)&^(0xf)|value)
}
func (o *CTI_Type) GetPIDR4_DES_2() uint32 {
	return volatile.LoadUint32(&o.PIDR4.Reg) & 0xf
}
func (o *CTI_Type) SetPIDR4_SIZE(value uint32) {
	volatile.StoreUint32(&o.PIDR4.Reg, volatile.LoadUint32(&o.PIDR4.Reg)&^(0xf0)|value<<4)
}
func (o *CTI_Type) GetPIDR4_SIZE() uint32 {
	return (volatile.LoadUint32(&o.PIDR4.Reg) & 0xf0) >> 4
}

// CTI.PIDR0: Peripheral ID0 Register
func (o *CTI_Type) SetPIDR0_PART_0(value uint32) {
	volatile.StoreUint32(&o.PIDR0.Reg, volatile.LoadUint32(&o.PIDR0.Reg)&^(0xff)|value)
}
func (o *CTI_Type) GetPIDR0_PART_0() uint32 {
	return volatile.LoadUint32(&o.PIDR0.Reg) & 0xff
}

// CTI.PIDR1: Peripheral ID1 Register
func (o *CTI_Type) SetPIDR1_PART_1(value uint32) {
	volatile.StoreUint32(&o.PIDR1.Reg, volatile.LoadUint32(&o.PIDR1.Reg)&^(0xf)|value)
}
func (o *CTI_Type) GetPIDR1_PART_1() uint32 {
	return volatile.LoadUint32(&o.PIDR1.Reg) & 0xf
}
func (o *CTI_Type) SetPIDR1_DES_0(value uint32) {
	volatile.StoreUint32(&o.PIDR1.Reg, volatile.LoadUint32(&o.PIDR1.Reg)&^(0xf0)|value<<4)
}
func (o *CTI_Type) GetPIDR1_DES_0() uint32 {
	return (volatile.LoadUint32(&o.PIDR1.Reg) & 0xf0) >> 4
}

// CTI.PIDR2: Peripheral ID2 Register
func (o *CTI_Type) SetPIDR2_DES_1(value uint32) {
	volatile.StoreUint32(&o.PIDR2.Reg, volatile.LoadUint32(&o.PIDR2.Reg)&^(0x7)|value)
}
func (o *CTI_Type) GetPIDR2_DES_1() uint32 {
	return volatile.LoadUint32(&o.PIDR2.Reg) & 0x7
}
func (o *CTI_Type) SetPIDR2_JEDEC(value uint32) {
	volatile.StoreUint32(&o.PIDR2.Reg, volatile.LoadUint32(&o.PIDR2.Reg)&^(0x8)|value<<3)
}
func (o *CTI_Type) GetPIDR2_JEDEC() uint32 {
	return (volatile.LoadUint32(&o.PIDR2.Reg) & 0x8) >> 3
}
func (o *CTI_Type) SetPIDR2_REVISION(value uint32) {
	volatile.StoreUint32(&o.PIDR2.Reg, volatile.LoadUint32(&o.PIDR2.Reg)&^(0xf0)|value<<4)
}
func (o *CTI_Type) GetPIDR2_REVISION() uint32 {
	return (volatile.LoadUint32(&o.PIDR2.Reg) & 0xf0) >> 4
}

// CTI.PIDR3: Peripheral ID3 Register
func (o *CTI_Type) SetPIDR3_CMOD(value uint32) {
	volatile.StoreUint32(&o.PIDR3.Reg, volatile.LoadUint32(&o.PIDR3.Reg)&^(0xf)|value)
}
func (o *CTI_Type) GetPIDR3_CMOD() uint32 {
	return volatile.LoadUint32(&o.PIDR3.Reg) & 0xf
}
func (o *CTI_Type) SetPIDR3_REVAND(value uint32) {
	volatile.StoreUint32(&o.PIDR3.Reg, volatile.LoadUint32(&o.PIDR3.Reg)&^(0xf0)|value<<4)
}
func (o *CTI_Type) GetPIDR3_REVAND() uint32 {
	return (volatile.LoadUint32(&o.PIDR3.Reg) & 0xf0) >> 4
}

// CTI.CIDR0: Component ID0 Register
func (o *CTI_Type) SetCIDR0_PRMBL_0(value uint32) {
	volatile.StoreUint32(&o.CIDR0.Reg, volatile.LoadUint32(&o.CIDR0.Reg)&^(0xff)|value)
}
func (o *CTI_Type) GetCIDR0_PRMBL_0() uint32 {
	return volatile.LoadUint32(&o.CIDR0.Reg) & 0xff
}

// CTI.CIDR1: Component ID1 Register
func (o *CTI_Type) SetCIDR1_PRMBL_1(value uint32) {
	volatile.StoreUint32(&o.CIDR1.Reg, volatile.LoadUint32(&o.CIDR1.Reg)&^(0xf)|value)
}
func (o *CTI_Type) GetCIDR1_PRMBL_1() uint32 {
	return volatile.LoadUint32(&o.CIDR1.Reg) & 0xf
}
func (o *CTI_Type) SetCIDR1_CLASS(value uint32) {
	volatile.StoreUint32(&o.CIDR1.Reg, volatile.LoadUint32(&o.CIDR1.Reg)&^(0xf0)|value<<4)
}
func (o *CTI_Type) GetCIDR1_CLASS() uint32 {
	return (volatile.LoadUint32(&o.CIDR1.Reg) & 0xf0) >> 4
}

// CTI.CIDR2: Component ID2 Register
func (o *CTI_Type) SetCIDR2_PRMBL_2(value uint32) {
	volatile.StoreUint32(&o.CIDR2.Reg, volatile.LoadUint32(&o.CIDR2.Reg)&^(0xff)|value)
}
func (o *CTI_Type) GetCIDR2_PRMBL_2() uint32 {
	return volatile.LoadUint32(&o.CIDR2.Reg) & 0xff
}

// CTI.CIDR3: Component ID3 Register
func (o *CTI_Type) SetCIDR3_PRMBL_3(value uint32) {
	volatile.StoreUint32(&o.CIDR3.Reg, volatile.LoadUint32(&o.CIDR3.Reg)&^(0xff)|value)
}
func (o *CTI_Type) GetCIDR3_PRMBL_3() uint32 {
	return volatile.LoadUint32(&o.CIDR3.Reg) & 0xff
}

// Trace and debug control
type TAD_Type struct {
	_              [4]byte
	CLOCKSTART     volatile.Register32 // 0x4
	CLOCKSTOP      volatile.Register32 // 0x8
	_              [1268]byte
	ENABLE         volatile.Register32 // 0x500
	PSEL           TAD_PSEL_Type       // 0x504
	TRACEPORTSPEED volatile.Register32 // 0x518
}

// TAD.CLOCKSTART: Start all trace and debug clocks.
func (o *TAD_Type) SetCLOCKSTART_START(value uint32) {
	volatile.StoreUint32(&o.CLOCKSTART.Reg, volatile.LoadUint32(&o.CLOCKSTART.Reg)&^(0x1)|value)
}
func (o *TAD_Type) GetCLOCKSTART_START() uint32 {
	return volatile.LoadUint32(&o.CLOCKSTART.Reg) & 0x1
}

// TAD.CLOCKSTOP: Stop all trace and debug clocks.
func (o *TAD_Type) SetCLOCKSTOP_STOP(value uint32) {
	volatile.StoreUint32(&o.CLOCKSTOP.Reg, volatile.LoadUint32(&o.CLOCKSTOP.Reg)&^(0x1)|value)
}
func (o *TAD_Type) GetCLOCKSTOP_STOP() uint32 {
	return volatile.LoadUint32(&o.CLOCKSTOP.Reg) & 0x1
}

// TAD.ENABLE: Enable debug domain and aquire selected GPIOs
func (o *TAD_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *TAD_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// TAD.TRACEPORTSPEED: Clocking options for the Trace Port debug interface.
func (o *TAD_Type) SetTRACEPORTSPEED(value uint32) {
	volatile.StoreUint32(&o.TRACEPORTSPEED.Reg, volatile.LoadUint32(&o.TRACEPORTSPEED.Reg)&^(0x3)|value)
}
func (o *TAD_Type) GetTRACEPORTSPEED() uint32 {
	return volatile.LoadUint32(&o.TRACEPORTSPEED.Reg) & 0x3
}

type TAD_PSEL_Type struct {
	TRACECLK   volatile.Register32 // 0x504
	TRACEDATA0 volatile.Register32 // 0x508
	TRACEDATA1 volatile.Register32 // 0x50C
	TRACEDATA2 volatile.Register32 // 0x510
	TRACEDATA3 volatile.Register32 // 0x514
}

// TAD_PSEL.TRACECLK: Pin configuration for TRACECLK
func (o *TAD_PSEL_Type) SetTRACECLK_PIN(value uint32) {
	volatile.StoreUint32(&o.TRACECLK.Reg, volatile.LoadUint32(&o.TRACECLK.Reg)&^(0x1f)|value)
}
func (o *TAD_PSEL_Type) GetTRACECLK_PIN() uint32 {
	return volatile.LoadUint32(&o.TRACECLK.Reg) & 0x1f
}
func (o *TAD_PSEL_Type) SetTRACECLK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TRACECLK.Reg, volatile.LoadUint32(&o.TRACECLK.Reg)&^(0x80000000)|value<<31)
}
func (o *TAD_PSEL_Type) GetTRACECLK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TRACECLK.Reg) & 0x80000000) >> 31
}

// TAD_PSEL.TRACEDATA0: Pin configuration for TRACEDATA[0] and SWO
func (o *TAD_PSEL_Type) SetTRACEDATA0_PIN(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA0.Reg, volatile.LoadUint32(&o.TRACEDATA0.Reg)&^(0x1f)|value)
}
func (o *TAD_PSEL_Type) GetTRACEDATA0_PIN() uint32 {
	return volatile.LoadUint32(&o.TRACEDATA0.Reg) & 0x1f
}
func (o *TAD_PSEL_Type) SetTRACEDATA0_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA0.Reg, volatile.LoadUint32(&o.TRACEDATA0.Reg)&^(0x80000000)|value<<31)
}
func (o *TAD_PSEL_Type) GetTRACEDATA0_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TRACEDATA0.Reg) & 0x80000000) >> 31
}

// TAD_PSEL.TRACEDATA1: Pin configuration for TRACEDATA[1]
func (o *TAD_PSEL_Type) SetTRACEDATA1_PIN(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA1.Reg, volatile.LoadUint32(&o.TRACEDATA1.Reg)&^(0x1f)|value)
}
func (o *TAD_PSEL_Type) GetTRACEDATA1_PIN() uint32 {
	return volatile.LoadUint32(&o.TRACEDATA1.Reg) & 0x1f
}
func (o *TAD_PSEL_Type) SetTRACEDATA1_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA1.Reg, volatile.LoadUint32(&o.TRACEDATA1.Reg)&^(0x80000000)|value<<31)
}
func (o *TAD_PSEL_Type) GetTRACEDATA1_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TRACEDATA1.Reg) & 0x80000000) >> 31
}

// TAD_PSEL.TRACEDATA2: Pin configuration for TRACEDATA[2]
func (o *TAD_PSEL_Type) SetTRACEDATA2_PIN(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA2.Reg, volatile.LoadUint32(&o.TRACEDATA2.Reg)&^(0x1f)|value)
}
func (o *TAD_PSEL_Type) GetTRACEDATA2_PIN() uint32 {
	return volatile.LoadUint32(&o.TRACEDATA2.Reg) & 0x1f
}
func (o *TAD_PSEL_Type) SetTRACEDATA2_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA2.Reg, volatile.LoadUint32(&o.TRACEDATA2.Reg)&^(0x80000000)|value<<31)
}
func (o *TAD_PSEL_Type) GetTRACEDATA2_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TRACEDATA2.Reg) & 0x80000000) >> 31
}

// TAD_PSEL.TRACEDATA3: Pin configuration for TRACEDATA[3]
func (o *TAD_PSEL_Type) SetTRACEDATA3_PIN(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA3.Reg, volatile.LoadUint32(&o.TRACEDATA3.Reg)&^(0x1f)|value)
}
func (o *TAD_PSEL_Type) GetTRACEDATA3_PIN() uint32 {
	return volatile.LoadUint32(&o.TRACEDATA3.Reg) & 0x1f
}
func (o *TAD_PSEL_Type) SetTRACEDATA3_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TRACEDATA3.Reg, volatile.LoadUint32(&o.TRACEDATA3.Reg)&^(0x80000000)|value<<31)
}
func (o *TAD_PSEL_Type) GetTRACEDATA3_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TRACEDATA3.Reg) & 0x80000000) >> 31
}

// Domain configuration management 0
type DCNF_Type struct {
	_       [1056]byte
	CPUID   volatile.Register32 // 0x420
	_       [28]byte
	EXTPERI [1]DCNF_EXTPERI_Type // 0x440
	_       [32]byte
	EXTRAM  [1]DCNF_EXTRAM_Type // 0x460
	_       [32]byte
	EXTCODE [1]DCNF_EXTCODE_Type // 0x480
}

// DCNF.CPUID: CPU ID of this subsystem
func (o *DCNF_Type) SetCPUID(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff)|value)
}
func (o *DCNF_Type) GetCPUID() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xff
}

type DCNF_EXTPERI_Type struct {
	PROTECT volatile.Register32 // 0x440
}

// DCNF_EXTPERI.PROTECT: Description cluster: Control access for master connected to AMLI master port EXTPERI[n]
func (o *DCNF_EXTPERI_Type) SetPROTECT_SLAVE0(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x1)|value)
}
func (o *DCNF_EXTPERI_Type) GetPROTECT_SLAVE0() uint32 {
	return volatile.LoadUint32(&o.PROTECT.Reg) & 0x1
}

type DCNF_EXTRAM_Type struct {
	PROTECT volatile.Register32 // 0x460
}

// DCNF_EXTRAM.PROTECT: Description cluster: Control access from master connected to AMLI master port EXTRAM[n]
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE0(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x1)|value)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE0() uint32 {
	return volatile.LoadUint32(&o.PROTECT.Reg) & 0x1
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE1(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x2)|value<<1)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE1() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x2) >> 1
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE2(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x4)|value<<2)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE2() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x4) >> 2
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE3(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x8)|value<<3)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE3() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x8) >> 3
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE4(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x10)|value<<4)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE4() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x10) >> 4
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE5(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x20)|value<<5)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE5() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x20) >> 5
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE6(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x40)|value<<6)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE6() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x40) >> 6
}
func (o *DCNF_EXTRAM_Type) SetPROTECT_SLAVE7(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x80)|value<<7)
}
func (o *DCNF_EXTRAM_Type) GetPROTECT_SLAVE7() uint32 {
	return (volatile.LoadUint32(&o.PROTECT.Reg) & 0x80) >> 7
}

type DCNF_EXTCODE_Type struct {
	PROTECT volatile.Register32 // 0x480
}

// DCNF_EXTCODE.PROTECT: Description cluster: Control access from master connected to AMLI master port EXTCODE[n]
func (o *DCNF_EXTCODE_Type) SetPROTECT_SLAVE0(value uint32) {
	volatile.StoreUint32(&o.PROTECT.Reg, volatile.LoadUint32(&o.PROTECT.Reg)&^(0x1)|value)
}
func (o *DCNF_EXTCODE_Type) GetPROTECT_SLAVE0() uint32 {
	return volatile.LoadUint32(&o.PROTECT.Reg) & 0x1
}

// FPU control peripheral 0
type FPU_Type struct {
	_                       [256]byte
	EVENTS_INVALIDOPERATION volatile.Register32 // 0x100
	EVENTS_DIVIDEBYZERO     volatile.Register32 // 0x104
	EVENTS_OVERFLOW         volatile.Register32 // 0x108
	EVENTS_UNDERFLOW        volatile.Register32 // 0x10C
	EVENTS_INEXACT          volatile.Register32 // 0x110
	EVENTS_DENORMALINPUT    volatile.Register32 // 0x114
	_                       [488]byte
	INTEN                   volatile.Register32 // 0x300
	INTENSET                volatile.Register32 // 0x304
	INTENCLR                volatile.Register32 // 0x308
}

// FPU.EVENTS_INVALIDOPERATION: An FPUIOC exception triggered by an invalid operation has occurred in the FPU
func (o *FPU_Type) SetEVENTS_INVALIDOPERATION(value uint32) {
	volatile.StoreUint32(&o.EVENTS_INVALIDOPERATION.Reg, volatile.LoadUint32(&o.EVENTS_INVALIDOPERATION.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetEVENTS_INVALIDOPERATION() uint32 {
	return volatile.LoadUint32(&o.EVENTS_INVALIDOPERATION.Reg) & 0x1
}

// FPU.EVENTS_DIVIDEBYZERO: An FPUDZC exception triggered by a floating-point divide-by-zero operation has occurred in the FPU
func (o *FPU_Type) SetEVENTS_DIVIDEBYZERO(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DIVIDEBYZERO.Reg, volatile.LoadUint32(&o.EVENTS_DIVIDEBYZERO.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetEVENTS_DIVIDEBYZERO() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DIVIDEBYZERO.Reg) & 0x1
}

// FPU.EVENTS_OVERFLOW: An FPUOFC exception triggered by a floating-point overflow has occurred in the FPU
func (o *FPU_Type) SetEVENTS_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.EVENTS_OVERFLOW.Reg, volatile.LoadUint32(&o.EVENTS_OVERFLOW.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetEVENTS_OVERFLOW() uint32 {
	return volatile.LoadUint32(&o.EVENTS_OVERFLOW.Reg) & 0x1
}

// FPU.EVENTS_UNDERFLOW: An FPUUFC exception triggered by a floating-point underflow has occurred in the FPU
func (o *FPU_Type) SetEVENTS_UNDERFLOW(value uint32) {
	volatile.StoreUint32(&o.EVENTS_UNDERFLOW.Reg, volatile.LoadUint32(&o.EVENTS_UNDERFLOW.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetEVENTS_UNDERFLOW() uint32 {
	return volatile.LoadUint32(&o.EVENTS_UNDERFLOW.Reg) & 0x1
}

// FPU.EVENTS_INEXACT: An FPUIXC exception triggered by an inexact floating-point operation has occurred in the FPU
func (o *FPU_Type) SetEVENTS_INEXACT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_INEXACT.Reg, volatile.LoadUint32(&o.EVENTS_INEXACT.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetEVENTS_INEXACT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_INEXACT.Reg) & 0x1
}

// FPU.EVENTS_DENORMALINPUT: An FPUIDC exception triggered by a denormal floating-point input has occurred in the FPU
func (o *FPU_Type) SetEVENTS_DENORMALINPUT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DENORMALINPUT.Reg, volatile.LoadUint32(&o.EVENTS_DENORMALINPUT.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetEVENTS_DENORMALINPUT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DENORMALINPUT.Reg) & 0x1
}

// FPU.INTEN: Enable or disable interrupt
func (o *FPU_Type) SetINTEN_INVALIDOPERATION(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetINTEN_INVALIDOPERATION() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *FPU_Type) SetINTEN_DIVIDEBYZERO(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetINTEN_DIVIDEBYZERO() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetINTEN_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *FPU_Type) GetINTEN_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *FPU_Type) SetINTEN_UNDERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetINTEN_UNDERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetINTEN_INEXACT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetINTEN_INEXACT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetINTEN_DENORMALINPUT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetINTEN_DENORMALINPUT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}

// FPU.INTENSET: Enable interrupt
func (o *FPU_Type) SetINTENSET_INVALIDOPERATION(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetINTENSET_INVALIDOPERATION() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *FPU_Type) SetINTENSET_DIVIDEBYZERO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetINTENSET_DIVIDEBYZERO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetINTENSET_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *FPU_Type) GetINTENSET_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *FPU_Type) SetINTENSET_UNDERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetINTENSET_UNDERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetINTENSET_INEXACT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetINTENSET_INEXACT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetINTENSET_DENORMALINPUT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetINTENSET_DENORMALINPUT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}

// FPU.INTENCLR: Disable interrupt
func (o *FPU_Type) SetINTENCLR_INVALIDOPERATION(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetINTENCLR_INVALIDOPERATION() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *FPU_Type) SetINTENCLR_DIVIDEBYZERO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetINTENCLR_DIVIDEBYZERO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetINTENCLR_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *FPU_Type) GetINTENCLR_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *FPU_Type) SetINTENCLR_UNDERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetINTENCLR_UNDERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetINTENCLR_INEXACT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetINTENCLR_INEXACT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetINTENCLR_DENORMALINPUT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetINTENCLR_DENORMALINPUT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}

// Cache
type CACHE_Type struct {
	_               [1024]byte
	PROFILING       [2]CACHE_PROFILING_Type // 0x400
	_               [192]byte
	ENABLE          volatile.Register32 // 0x500
	INVALIDATE      volatile.Register32 // 0x504
	ERASE           volatile.Register32 // 0x508
	PROFILINGENABLE volatile.Register32 // 0x50C
	PROFILINGCLEAR  volatile.Register32 // 0x510
	MODE            volatile.Register32 // 0x514
	DEBUGLOCK       volatile.Register32 // 0x518
	ERASESTATUS     volatile.Register32 // 0x51C
	WRITELOCK       volatile.Register32 // 0x520
}

// CACHE.ENABLE: Enable cache
func (o *CACHE_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// CACHE.INVALIDATE: Invalidate the cache
func (o *CACHE_Type) SetINVALIDATE(value uint32) {
	volatile.StoreUint32(&o.INVALIDATE.Reg, volatile.LoadUint32(&o.INVALIDATE.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetINVALIDATE() uint32 {
	return volatile.LoadUint32(&o.INVALIDATE.Reg) & 0x1
}

// CACHE.ERASE: Erase the cache
func (o *CACHE_Type) SetERASE(value uint32) {
	volatile.StoreUint32(&o.ERASE.Reg, volatile.LoadUint32(&o.ERASE.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetERASE() uint32 {
	return volatile.LoadUint32(&o.ERASE.Reg) & 0x1
}

// CACHE.PROFILINGENABLE: Enable the profiling counters
func (o *CACHE_Type) SetPROFILINGENABLE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PROFILINGENABLE.Reg, volatile.LoadUint32(&o.PROFILINGENABLE.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetPROFILINGENABLE_ENABLE() uint32 {
	return volatile.LoadUint32(&o.PROFILINGENABLE.Reg) & 0x1
}

// CACHE.PROFILINGCLEAR: Clear the profiling counters
func (o *CACHE_Type) SetPROFILINGCLEAR_CLEAR(value uint32) {
	volatile.StoreUint32(&o.PROFILINGCLEAR.Reg, volatile.LoadUint32(&o.PROFILINGCLEAR.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetPROFILINGCLEAR_CLEAR() uint32 {
	return volatile.LoadUint32(&o.PROFILINGCLEAR.Reg) & 0x1
}

// CACHE.MODE: Cache mode. Switching from Cache to RAM mode causes the RAM to be cleared. Switching from RAM to Cache mode causes the cache to be invalidated.
func (o *CACHE_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}

// CACHE.DEBUGLOCK: Lock debug mode Ignored in RAM mode.
func (o *CACHE_Type) SetDEBUGLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUGLOCK.Reg, volatile.LoadUint32(&o.DEBUGLOCK.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetDEBUGLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUGLOCK.Reg) & 0x1
}

// CACHE.ERASESTATUS: Cache erase status
func (o *CACHE_Type) SetERASESTATUS(value uint32) {
	volatile.StoreUint32(&o.ERASESTATUS.Reg, volatile.LoadUint32(&o.ERASESTATUS.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetERASESTATUS() uint32 {
	return volatile.LoadUint32(&o.ERASESTATUS.Reg) & 0x1
}

// CACHE.WRITELOCK: Lock cache updates. Prevents updating of cache content on cache misses, but will continue to lookup instruction/data fetches in content already present in the cache. Ignored in RAM mode.
func (o *CACHE_Type) SetWRITELOCK(value uint32) {
	volatile.StoreUint32(&o.WRITELOCK.Reg, volatile.LoadUint32(&o.WRITELOCK.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetWRITELOCK() uint32 {
	return volatile.LoadUint32(&o.WRITELOCK.Reg) & 0x1
}

type CACHE_PROFILING_Type struct {
	IHIT  volatile.Register32 // 0x400
	IMISS volatile.Register32 // 0x404
	DHIT  volatile.Register32 // 0x408
	DMISS volatile.Register32 // 0x40C
	_     [16]byte
}

// CACHE_PROFILING.IHIT: Description cluster: Instruction fetch cache hit counter for cache region n, where n=0 means Flash and n=1 means XIP.
func (o *CACHE_PROFILING_Type) SetIHIT(value uint32) {
	volatile.StoreUint32(&o.IHIT.Reg, value)
}
func (o *CACHE_PROFILING_Type) GetIHIT() uint32 {
	return volatile.LoadUint32(&o.IHIT.Reg)
}

// CACHE_PROFILING.IMISS: Description cluster: Instruction fetch cache miss counter for cache region n, where n=0 means Flash and n=1 means XIP.
func (o *CACHE_PROFILING_Type) SetIMISS(value uint32) {
	volatile.StoreUint32(&o.IMISS.Reg, value)
}
func (o *CACHE_PROFILING_Type) GetIMISS() uint32 {
	return volatile.LoadUint32(&o.IMISS.Reg)
}

// CACHE_PROFILING.DHIT: Description cluster: Data fetch cache hit counter for cache region n, where n=0 means Flash and n=1 means XIP.
func (o *CACHE_PROFILING_Type) SetDHIT(value uint32) {
	volatile.StoreUint32(&o.DHIT.Reg, value)
}
func (o *CACHE_PROFILING_Type) GetDHIT() uint32 {
	return volatile.LoadUint32(&o.DHIT.Reg)
}

// CACHE_PROFILING.DMISS: Description cluster: Data fetch cache miss counter for cache region n, where n=0 means Flash and n=1 means XIP.
func (o *CACHE_PROFILING_Type) SetDMISS(value uint32) {
	volatile.StoreUint32(&o.DMISS.Reg, value)
}
func (o *CACHE_PROFILING_Type) GetDMISS() uint32 {
	return volatile.LoadUint32(&o.DMISS.Reg)
}

// System protection unit
type SPU_Type struct {
	_                    [256]byte
	EVENTS_RAMACCERR     volatile.Register32 // 0x100
	EVENTS_FLASHACCERR   volatile.Register32 // 0x104
	EVENTS_PERIPHACCERR  volatile.Register32 // 0x108
	_                    [116]byte
	PUBLISH_RAMACCERR    volatile.Register32 // 0x180
	PUBLISH_FLASHACCERR  volatile.Register32 // 0x184
	PUBLISH_PERIPHACCERR volatile.Register32 // 0x188
	_                    [372]byte
	INTEN                volatile.Register32 // 0x300
	INTENSET             volatile.Register32 // 0x304
	INTENCLR             volatile.Register32 // 0x308
	_                    [244]byte
	CAP                  volatile.Register32 // 0x400
	CPULOCK              volatile.Register32 // 0x404
	_                    [56]byte
	EXTDOMAIN            [1]SPU_EXTDOMAIN_Type // 0x440
	_                    [64]byte
	DPPI                 [1]SPU_DPPI_Type // 0x480
	_                    [60]byte
	GPIOPORT             [2]SPU_GPIOPORT_Type // 0x4C0
	_                    [48]byte
	FLASHNSC             [2]SPU_FLASHNSC_Type // 0x500
	_                    [48]byte
	RAMNSC               [2]SPU_RAMNSC_Type // 0x540
	_                    [176]byte
	FLASHREGION          [64]SPU_FLASHREGION_Type // 0x600
	RAMREGION            [64]SPU_RAMREGION_Type   // 0x700
	PERIPHID             [256]SPU_PERIPHID_Type   // 0x800
}

// SPU.EVENTS_RAMACCERR: A security violation has been detected for the RAM memory space
func (o *SPU_Type) SetEVENTS_RAMACCERR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RAMACCERR.Reg, volatile.LoadUint32(&o.EVENTS_RAMACCERR.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetEVENTS_RAMACCERR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RAMACCERR.Reg) & 0x1
}

// SPU.EVENTS_FLASHACCERR: A security violation has been detected for the flash memory space
func (o *SPU_Type) SetEVENTS_FLASHACCERR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_FLASHACCERR.Reg, volatile.LoadUint32(&o.EVENTS_FLASHACCERR.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetEVENTS_FLASHACCERR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_FLASHACCERR.Reg) & 0x1
}

// SPU.EVENTS_PERIPHACCERR: A security violation has been detected on one or several peripherals
func (o *SPU_Type) SetEVENTS_PERIPHACCERR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_PERIPHACCERR.Reg, volatile.LoadUint32(&o.EVENTS_PERIPHACCERR.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetEVENTS_PERIPHACCERR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_PERIPHACCERR.Reg) & 0x1
}

// SPU.PUBLISH_RAMACCERR: Publish configuration for event RAMACCERR
func (o *SPU_Type) SetPUBLISH_RAMACCERR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RAMACCERR.Reg, volatile.LoadUint32(&o.PUBLISH_RAMACCERR.Reg)&^(0xff)|value)
}
func (o *SPU_Type) GetPUBLISH_RAMACCERR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RAMACCERR.Reg) & 0xff
}
func (o *SPU_Type) SetPUBLISH_RAMACCERR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RAMACCERR.Reg, volatile.LoadUint32(&o.PUBLISH_RAMACCERR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPU_Type) GetPUBLISH_RAMACCERR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RAMACCERR.Reg) & 0x80000000) >> 31
}

// SPU.PUBLISH_FLASHACCERR: Publish configuration for event FLASHACCERR
func (o *SPU_Type) SetPUBLISH_FLASHACCERR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FLASHACCERR.Reg, volatile.LoadUint32(&o.PUBLISH_FLASHACCERR.Reg)&^(0xff)|value)
}
func (o *SPU_Type) GetPUBLISH_FLASHACCERR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_FLASHACCERR.Reg) & 0xff
}
func (o *SPU_Type) SetPUBLISH_FLASHACCERR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FLASHACCERR.Reg, volatile.LoadUint32(&o.PUBLISH_FLASHACCERR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPU_Type) GetPUBLISH_FLASHACCERR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_FLASHACCERR.Reg) & 0x80000000) >> 31
}

// SPU.PUBLISH_PERIPHACCERR: Publish configuration for event PERIPHACCERR
func (o *SPU_Type) SetPUBLISH_PERIPHACCERR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_PERIPHACCERR.Reg, volatile.LoadUint32(&o.PUBLISH_PERIPHACCERR.Reg)&^(0xff)|value)
}
func (o *SPU_Type) GetPUBLISH_PERIPHACCERR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_PERIPHACCERR.Reg) & 0xff
}
func (o *SPU_Type) SetPUBLISH_PERIPHACCERR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_PERIPHACCERR.Reg, volatile.LoadUint32(&o.PUBLISH_PERIPHACCERR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPU_Type) GetPUBLISH_PERIPHACCERR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_PERIPHACCERR.Reg) & 0x80000000) >> 31
}

// SPU.INTEN: Enable or disable interrupt
func (o *SPU_Type) SetINTEN_RAMACCERR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetINTEN_RAMACCERR() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *SPU_Type) SetINTEN_FLASHACCERR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *SPU_Type) GetINTEN_FLASHACCERR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *SPU_Type) SetINTEN_PERIPHACCERR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *SPU_Type) GetINTEN_PERIPHACCERR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}

// SPU.INTENSET: Enable interrupt
func (o *SPU_Type) SetINTENSET_RAMACCERR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetINTENSET_RAMACCERR() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *SPU_Type) SetINTENSET_FLASHACCERR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPU_Type) GetINTENSET_FLASHACCERR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPU_Type) SetINTENSET_PERIPHACCERR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SPU_Type) GetINTENSET_PERIPHACCERR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// SPU.INTENCLR: Disable interrupt
func (o *SPU_Type) SetINTENCLR_RAMACCERR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetINTENCLR_RAMACCERR() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *SPU_Type) SetINTENCLR_FLASHACCERR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPU_Type) GetINTENCLR_FLASHACCERR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPU_Type) SetINTENCLR_PERIPHACCERR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SPU_Type) GetINTENCLR_PERIPHACCERR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// SPU.CAP: Show implemented features for the current device
func (o *SPU_Type) SetCAP_TZM(value uint32) {
	volatile.StoreUint32(&o.CAP.Reg, volatile.LoadUint32(&o.CAP.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetCAP_TZM() uint32 {
	return volatile.LoadUint32(&o.CAP.Reg) & 0x1
}

// SPU.CPULOCK: Configure bits to lock down CPU features at runtime
func (o *SPU_Type) SetCPULOCK_LOCKSVTAIRCR(value uint32) {
	volatile.StoreUint32(&o.CPULOCK.Reg, volatile.LoadUint32(&o.CPULOCK.Reg)&^(0x1)|value)
}
func (o *SPU_Type) GetCPULOCK_LOCKSVTAIRCR() uint32 {
	return volatile.LoadUint32(&o.CPULOCK.Reg) & 0x1
}
func (o *SPU_Type) SetCPULOCK_LOCKNSVTOR(value uint32) {
	volatile.StoreUint32(&o.CPULOCK.Reg, volatile.LoadUint32(&o.CPULOCK.Reg)&^(0x2)|value<<1)
}
func (o *SPU_Type) GetCPULOCK_LOCKNSVTOR() uint32 {
	return (volatile.LoadUint32(&o.CPULOCK.Reg) & 0x2) >> 1
}
func (o *SPU_Type) SetCPULOCK_LOCKSMPU(value uint32) {
	volatile.StoreUint32(&o.CPULOCK.Reg, volatile.LoadUint32(&o.CPULOCK.Reg)&^(0x4)|value<<2)
}
func (o *SPU_Type) GetCPULOCK_LOCKSMPU() uint32 {
	return (volatile.LoadUint32(&o.CPULOCK.Reg) & 0x4) >> 2
}
func (o *SPU_Type) SetCPULOCK_LOCKNSMPU(value uint32) {
	volatile.StoreUint32(&o.CPULOCK.Reg, volatile.LoadUint32(&o.CPULOCK.Reg)&^(0x8)|value<<3)
}
func (o *SPU_Type) GetCPULOCK_LOCKNSMPU() uint32 {
	return (volatile.LoadUint32(&o.CPULOCK.Reg) & 0x8) >> 3
}
func (o *SPU_Type) SetCPULOCK_LOCKSAU(value uint32) {
	volatile.StoreUint32(&o.CPULOCK.Reg, volatile.LoadUint32(&o.CPULOCK.Reg)&^(0x10)|value<<4)
}
func (o *SPU_Type) GetCPULOCK_LOCKSAU() uint32 {
	return (volatile.LoadUint32(&o.CPULOCK.Reg) & 0x10) >> 4
}

type SPU_EXTDOMAIN_Type struct {
	PERM volatile.Register32 // 0x440
}

// SPU_EXTDOMAIN.PERM: Description cluster: Access for bus access generated from the external domain n List capabilities of the external domain n
func (o *SPU_EXTDOMAIN_Type) SetPERM_SECUREMAPPING(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x3)|value)
}
func (o *SPU_EXTDOMAIN_Type) GetPERM_SECUREMAPPING() uint32 {
	return volatile.LoadUint32(&o.PERM.Reg) & 0x3
}
func (o *SPU_EXTDOMAIN_Type) SetPERM_SECATTR(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10)|value<<4)
}
func (o *SPU_EXTDOMAIN_Type) GetPERM_SECATTR() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10) >> 4
}
func (o *SPU_EXTDOMAIN_Type) SetPERM_LOCK(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100)|value<<8)
}
func (o *SPU_EXTDOMAIN_Type) GetPERM_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100) >> 8
}

type SPU_DPPI_Type struct {
	PERM volatile.Register32 // 0x480
	LOCK volatile.Register32 // 0x484
}

// SPU_DPPI.PERM: Description cluster: Select between secure and non-secure attribute for the DPPI channels.
func (o *SPU_DPPI_Type) SetPERM_CHANNEL0(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1)|value)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL0() uint32 {
	return volatile.LoadUint32(&o.PERM.Reg) & 0x1
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL1(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2)|value<<1)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL1() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2) >> 1
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL2(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4)|value<<2)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL2() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4) >> 2
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL3(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x8)|value<<3)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL3() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x8) >> 3
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL4(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10)|value<<4)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL4() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10) >> 4
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL5(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20)|value<<5)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL5() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20) >> 5
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL6(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x40)|value<<6)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL6() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x40) >> 6
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL7(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80)|value<<7)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL7() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80) >> 7
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL8(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100)|value<<8)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL8() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100) >> 8
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL9(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x200)|value<<9)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL9() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x200) >> 9
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL10(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x400)|value<<10)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL10() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x400) >> 10
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL11(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x800)|value<<11)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL11() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x800) >> 11
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL12(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1000)|value<<12)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL12() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x1000) >> 12
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL13(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2000)|value<<13)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL13() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2000) >> 13
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL14(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4000)|value<<14)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL14() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4000) >> 14
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL15(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x8000)|value<<15)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL15() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x8000) >> 15
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL16(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10000)|value<<16)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL16() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10000) >> 16
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL17(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20000)|value<<17)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL17() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20000) >> 17
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL18(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x40000)|value<<18)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL18() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x40000) >> 18
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL19(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80000)|value<<19)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL19() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80000) >> 19
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL20(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100000)|value<<20)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL20() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100000) >> 20
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL21(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x200000)|value<<21)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL21() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x200000) >> 21
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL22(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x400000)|value<<22)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL22() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x400000) >> 22
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL23(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x800000)|value<<23)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL23() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x800000) >> 23
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL24(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1000000)|value<<24)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL24() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x1000000) >> 24
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL25(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2000000)|value<<25)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL25() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2000000) >> 25
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL26(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4000000)|value<<26)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL26() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4000000) >> 26
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL27(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x8000000)|value<<27)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL27() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x8000000) >> 27
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL28(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10000000)|value<<28)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL28() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10000000) >> 28
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL29(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20000000)|value<<29)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL29() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20000000) >> 29
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL30(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x40000000)|value<<30)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL30() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x40000000) >> 30
}
func (o *SPU_DPPI_Type) SetPERM_CHANNEL31(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80000000)|value<<31)
}
func (o *SPU_DPPI_Type) GetPERM_CHANNEL31() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80000000) >> 31
}

// SPU_DPPI.LOCK: Description cluster: Prevent further modification of the corresponding PERM register
func (o *SPU_DPPI_Type) SetLOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK.Reg, volatile.LoadUint32(&o.LOCK.Reg)&^(0x1)|value)
}
func (o *SPU_DPPI_Type) GetLOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK.Reg) & 0x1
}

type SPU_GPIOPORT_Type struct {
	PERM volatile.Register32 // 0x4C0
	LOCK volatile.Register32 // 0x4C4
}

// SPU_GPIOPORT.PERM: Description cluster: Select between secure and non-secure attribute for pins 0 to 31 of port n.
func (o *SPU_GPIOPORT_Type) SetPERM_PIN0(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1)|value)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN0() uint32 {
	return volatile.LoadUint32(&o.PERM.Reg) & 0x1
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN1(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2)|value<<1)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN1() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2) >> 1
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN2(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4)|value<<2)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN2() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4) >> 2
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN3(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x8)|value<<3)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN3() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x8) >> 3
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN4(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10)|value<<4)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN4() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10) >> 4
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN5(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20)|value<<5)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN5() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20) >> 5
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN6(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x40)|value<<6)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN6() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x40) >> 6
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN7(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80)|value<<7)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN7() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80) >> 7
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN8(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100)|value<<8)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN8() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100) >> 8
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN9(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x200)|value<<9)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN9() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x200) >> 9
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN10(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x400)|value<<10)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN10() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x400) >> 10
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN11(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x800)|value<<11)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN11() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x800) >> 11
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN12(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1000)|value<<12)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN12() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x1000) >> 12
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN13(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2000)|value<<13)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN13() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2000) >> 13
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN14(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4000)|value<<14)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN14() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4000) >> 14
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN15(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x8000)|value<<15)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN15() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x8000) >> 15
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN16(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10000)|value<<16)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN16() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10000) >> 16
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN17(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20000)|value<<17)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN17() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20000) >> 17
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN18(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x40000)|value<<18)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN18() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x40000) >> 18
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN19(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80000)|value<<19)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN19() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80000) >> 19
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN20(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100000)|value<<20)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN20() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100000) >> 20
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN21(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x200000)|value<<21)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN21() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x200000) >> 21
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN22(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x400000)|value<<22)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN22() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x400000) >> 22
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN23(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x800000)|value<<23)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN23() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x800000) >> 23
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN24(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1000000)|value<<24)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN24() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x1000000) >> 24
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN25(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2000000)|value<<25)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN25() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2000000) >> 25
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN26(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4000000)|value<<26)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN26() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4000000) >> 26
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN27(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x8000000)|value<<27)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN27() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x8000000) >> 27
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN28(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10000000)|value<<28)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN28() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10000000) >> 28
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN29(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20000000)|value<<29)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN29() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20000000) >> 29
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN30(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x40000000)|value<<30)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN30() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x40000000) >> 30
}
func (o *SPU_GPIOPORT_Type) SetPERM_PIN31(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80000000)|value<<31)
}
func (o *SPU_GPIOPORT_Type) GetPERM_PIN31() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80000000) >> 31
}

// SPU_GPIOPORT.LOCK: Description cluster: Prevent further modification of the corresponding PERM register
func (o *SPU_GPIOPORT_Type) SetLOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK.Reg, volatile.LoadUint32(&o.LOCK.Reg)&^(0x1)|value)
}
func (o *SPU_GPIOPORT_Type) GetLOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK.Reg) & 0x1
}

type SPU_FLASHNSC_Type struct {
	REGION volatile.Register32 // 0x500
	SIZE   volatile.Register32 // 0x504
}

// SPU_FLASHNSC.REGION: Description cluster: Define which flash region can contain the non-secure callable (NSC) region n
func (o *SPU_FLASHNSC_Type) SetREGION(value uint32) {
	volatile.StoreUint32(&o.REGION.Reg, volatile.LoadUint32(&o.REGION.Reg)&^(0x3f)|value)
}
func (o *SPU_FLASHNSC_Type) GetREGION() uint32 {
	return volatile.LoadUint32(&o.REGION.Reg) & 0x3f
}
func (o *SPU_FLASHNSC_Type) SetREGION_LOCK(value uint32) {
	volatile.StoreUint32(&o.REGION.Reg, volatile.LoadUint32(&o.REGION.Reg)&^(0x100)|value<<8)
}
func (o *SPU_FLASHNSC_Type) GetREGION_LOCK() uint32 {
	return (volatile.LoadUint32(&o.REGION.Reg) & 0x100) >> 8
}

// SPU_FLASHNSC.SIZE: Description cluster: Define the size of the non-secure callable (NSC) region n
func (o *SPU_FLASHNSC_Type) SetSIZE(value uint32) {
	volatile.StoreUint32(&o.SIZE.Reg, volatile.LoadUint32(&o.SIZE.Reg)&^(0xf)|value)
}
func (o *SPU_FLASHNSC_Type) GetSIZE() uint32 {
	return volatile.LoadUint32(&o.SIZE.Reg) & 0xf
}
func (o *SPU_FLASHNSC_Type) SetSIZE_LOCK(value uint32) {
	volatile.StoreUint32(&o.SIZE.Reg, volatile.LoadUint32(&o.SIZE.Reg)&^(0x100)|value<<8)
}
func (o *SPU_FLASHNSC_Type) GetSIZE_LOCK() uint32 {
	return (volatile.LoadUint32(&o.SIZE.Reg) & 0x100) >> 8
}

type SPU_RAMNSC_Type struct {
	REGION volatile.Register32 // 0x540
	SIZE   volatile.Register32 // 0x544
}

// SPU_RAMNSC.REGION: Description cluster: Define which RAM region can contain the non-secure callable (NSC) region n
func (o *SPU_RAMNSC_Type) SetREGION(value uint32) {
	volatile.StoreUint32(&o.REGION.Reg, volatile.LoadUint32(&o.REGION.Reg)&^(0x3f)|value)
}
func (o *SPU_RAMNSC_Type) GetREGION() uint32 {
	return volatile.LoadUint32(&o.REGION.Reg) & 0x3f
}
func (o *SPU_RAMNSC_Type) SetREGION_LOCK(value uint32) {
	volatile.StoreUint32(&o.REGION.Reg, volatile.LoadUint32(&o.REGION.Reg)&^(0x100)|value<<8)
}
func (o *SPU_RAMNSC_Type) GetREGION_LOCK() uint32 {
	return (volatile.LoadUint32(&o.REGION.Reg) & 0x100) >> 8
}

// SPU_RAMNSC.SIZE: Description cluster: Define the size of the non-secure callable (NSC) region n
func (o *SPU_RAMNSC_Type) SetSIZE(value uint32) {
	volatile.StoreUint32(&o.SIZE.Reg, volatile.LoadUint32(&o.SIZE.Reg)&^(0xf)|value)
}
func (o *SPU_RAMNSC_Type) GetSIZE() uint32 {
	return volatile.LoadUint32(&o.SIZE.Reg) & 0xf
}
func (o *SPU_RAMNSC_Type) SetSIZE_LOCK(value uint32) {
	volatile.StoreUint32(&o.SIZE.Reg, volatile.LoadUint32(&o.SIZE.Reg)&^(0x100)|value<<8)
}
func (o *SPU_RAMNSC_Type) GetSIZE_LOCK() uint32 {
	return (volatile.LoadUint32(&o.SIZE.Reg) & 0x100) >> 8
}

type SPU_FLASHREGION_Type struct {
	PERM volatile.Register32 // 0x600
}

// SPU_FLASHREGION.PERM: Description cluster: Access permissions for flash region n
func (o *SPU_FLASHREGION_Type) SetPERM_EXECUTE(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1)|value)
}
func (o *SPU_FLASHREGION_Type) GetPERM_EXECUTE() uint32 {
	return volatile.LoadUint32(&o.PERM.Reg) & 0x1
}
func (o *SPU_FLASHREGION_Type) SetPERM_WRITE(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2)|value<<1)
}
func (o *SPU_FLASHREGION_Type) GetPERM_WRITE() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2) >> 1
}
func (o *SPU_FLASHREGION_Type) SetPERM_READ(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4)|value<<2)
}
func (o *SPU_FLASHREGION_Type) GetPERM_READ() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4) >> 2
}
func (o *SPU_FLASHREGION_Type) SetPERM_SECATTR(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10)|value<<4)
}
func (o *SPU_FLASHREGION_Type) GetPERM_SECATTR() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10) >> 4
}
func (o *SPU_FLASHREGION_Type) SetPERM_LOCK(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100)|value<<8)
}
func (o *SPU_FLASHREGION_Type) GetPERM_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100) >> 8
}

type SPU_RAMREGION_Type struct {
	PERM volatile.Register32 // 0x700
}

// SPU_RAMREGION.PERM: Description cluster: Access permissions for RAM region n
func (o *SPU_RAMREGION_Type) SetPERM_EXECUTE(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x1)|value)
}
func (o *SPU_RAMREGION_Type) GetPERM_EXECUTE() uint32 {
	return volatile.LoadUint32(&o.PERM.Reg) & 0x1
}
func (o *SPU_RAMREGION_Type) SetPERM_WRITE(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2)|value<<1)
}
func (o *SPU_RAMREGION_Type) GetPERM_WRITE() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2) >> 1
}
func (o *SPU_RAMREGION_Type) SetPERM_READ(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4)|value<<2)
}
func (o *SPU_RAMREGION_Type) GetPERM_READ() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4) >> 2
}
func (o *SPU_RAMREGION_Type) SetPERM_SECATTR(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10)|value<<4)
}
func (o *SPU_RAMREGION_Type) GetPERM_SECATTR() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10) >> 4
}
func (o *SPU_RAMREGION_Type) SetPERM_LOCK(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100)|value<<8)
}
func (o *SPU_RAMREGION_Type) GetPERM_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100) >> 8
}

type SPU_PERIPHID_Type struct {
	PERM volatile.Register32 // 0x800
}

// SPU_PERIPHID.PERM: Description cluster: List capabilities and access permissions for the peripheral with ID n
func (o *SPU_PERIPHID_Type) SetPERM_SECUREMAPPING(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x3)|value)
}
func (o *SPU_PERIPHID_Type) GetPERM_SECUREMAPPING() uint32 {
	return volatile.LoadUint32(&o.PERM.Reg) & 0x3
}
func (o *SPU_PERIPHID_Type) SetPERM_DMA(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0xc)|value<<2)
}
func (o *SPU_PERIPHID_Type) GetPERM_DMA() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0xc) >> 2
}
func (o *SPU_PERIPHID_Type) SetPERM_SECATTR(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x10)|value<<4)
}
func (o *SPU_PERIPHID_Type) GetPERM_SECATTR() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x10) >> 4
}
func (o *SPU_PERIPHID_Type) SetPERM_DMASEC(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x20)|value<<5)
}
func (o *SPU_PERIPHID_Type) GetPERM_DMASEC() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x20) >> 5
}
func (o *SPU_PERIPHID_Type) SetPERM_LOCK(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x100)|value<<8)
}
func (o *SPU_PERIPHID_Type) GetPERM_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x100) >> 8
}
func (o *SPU_PERIPHID_Type) SetPERM_PRESENT(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x80000000)|value<<31)
}
func (o *SPU_PERIPHID_Type) GetPERM_PRESENT() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x80000000) >> 31
}

// Oscillator control 0
type OSCILLATORS_Type struct {
	_           [1476]byte
	XOSC32MCAPS volatile.Register32 // 0x5C4
	_           [248]byte
	XOSC32KI    OSCILLATORS_XOSC32KI_Type // 0x6C0
}

// OSCILLATORS.XOSC32MCAPS: Programmable capacitance of XC1 and XC2
func (o *OSCILLATORS_Type) SetXOSC32MCAPS_CAPVALUE(value uint32) {
	volatile.StoreUint32(&o.XOSC32MCAPS.Reg, volatile.LoadUint32(&o.XOSC32MCAPS.Reg)&^(0x1f)|value)
}
func (o *OSCILLATORS_Type) GetXOSC32MCAPS_CAPVALUE() uint32 {
	return volatile.LoadUint32(&o.XOSC32MCAPS.Reg) & 0x1f
}
func (o *OSCILLATORS_Type) SetXOSC32MCAPS_ENABLE(value uint32) {
	volatile.StoreUint32(&o.XOSC32MCAPS.Reg, volatile.LoadUint32(&o.XOSC32MCAPS.Reg)&^(0x100)|value<<8)
}
func (o *OSCILLATORS_Type) GetXOSC32MCAPS_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.XOSC32MCAPS.Reg) & 0x100) >> 8
}

type OSCILLATORS_XOSC32KI_Type struct {
	BYPASS volatile.Register32 // 0x6C0
	_      [12]byte
	INTCAP volatile.Register32 // 0x6D0
}

// OSCILLATORS_XOSC32KI.BYPASS: Enable or disable bypass of LFCLK crystal oscillator with external clock source
func (o *OSCILLATORS_XOSC32KI_Type) SetBYPASS(value uint32) {
	volatile.StoreUint32(&o.BYPASS.Reg, volatile.LoadUint32(&o.BYPASS.Reg)&^(0x1)|value)
}
func (o *OSCILLATORS_XOSC32KI_Type) GetBYPASS() uint32 {
	return volatile.LoadUint32(&o.BYPASS.Reg) & 0x1
}

// OSCILLATORS_XOSC32KI.INTCAP: Control usage of internal load capacitors
func (o *OSCILLATORS_XOSC32KI_Type) SetINTCAP(value uint32) {
	volatile.StoreUint32(&o.INTCAP.Reg, volatile.LoadUint32(&o.INTCAP.Reg)&^(0x3)|value)
}
func (o *OSCILLATORS_XOSC32KI_Type) GetINTCAP() uint32 {
	return volatile.LoadUint32(&o.INTCAP.Reg) & 0x3
}

// Voltage regulators 0
type REGULATORS_Type struct {
	_             [1064]byte
	MAINREGSTATUS volatile.Register32 // 0x428
	_             [212]byte
	SYSTEMOFF     volatile.Register32 // 0x500
	_             [12]byte
	POFCON        volatile.Register32 // 0x510
	_             [496]byte
	VREGMAIN      REGULATORS_VREGMAIN_Type // 0x704
	_             [504]byte
	VREGRADIO     REGULATORS_VREGRADIO_Type // 0x900
	_             [504]byte
	VREGH         REGULATORS_VREGH_Type // 0xB00
}

// REGULATORS.MAINREGSTATUS: Main supply status
func (o *REGULATORS_Type) SetMAINREGSTATUS_VREGH(value uint32) {
	volatile.StoreUint32(&o.MAINREGSTATUS.Reg, volatile.LoadUint32(&o.MAINREGSTATUS.Reg)&^(0x1)|value)
}
func (o *REGULATORS_Type) GetMAINREGSTATUS_VREGH() uint32 {
	return volatile.LoadUint32(&o.MAINREGSTATUS.Reg) & 0x1
}

// REGULATORS.SYSTEMOFF: System OFF register
func (o *REGULATORS_Type) SetSYSTEMOFF(value uint32) {
	volatile.StoreUint32(&o.SYSTEMOFF.Reg, volatile.LoadUint32(&o.SYSTEMOFF.Reg)&^(0x1)|value)
}
func (o *REGULATORS_Type) GetSYSTEMOFF() uint32 {
	return volatile.LoadUint32(&o.SYSTEMOFF.Reg) & 0x1
}

// REGULATORS.POFCON: Power-fail comparator configuration
func (o *REGULATORS_Type) SetPOFCON_POF(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0x1)|value)
}
func (o *REGULATORS_Type) GetPOFCON_POF() uint32 {
	return volatile.LoadUint32(&o.POFCON.Reg) & 0x1
}
func (o *REGULATORS_Type) SetPOFCON_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0x1e)|value<<1)
}
func (o *REGULATORS_Type) GetPOFCON_THRESHOLD() uint32 {
	return (volatile.LoadUint32(&o.POFCON.Reg) & 0x1e) >> 1
}
func (o *REGULATORS_Type) SetPOFCON_THRESHOLDVDDH(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0xf00)|value<<8)
}
func (o *REGULATORS_Type) GetPOFCON_THRESHOLDVDDH() uint32 {
	return (volatile.LoadUint32(&o.POFCON.Reg) & 0xf00) >> 8
}

type REGULATORS_VREGMAIN_Type struct {
	DCDCEN volatile.Register32 // 0x704
}

// REGULATORS_VREGMAIN.DCDCEN: DC/DC enable register for VREGMAIN
func (o *REGULATORS_VREGMAIN_Type) SetDCDCEN(value uint32) {
	volatile.StoreUint32(&o.DCDCEN.Reg, volatile.LoadUint32(&o.DCDCEN.Reg)&^(0x1)|value)
}
func (o *REGULATORS_VREGMAIN_Type) GetDCDCEN() uint32 {
	return volatile.LoadUint32(&o.DCDCEN.Reg) & 0x1
}

type REGULATORS_VREGRADIO_Type struct {
	_      [4]byte
	DCDCEN volatile.Register32 // 0x904
}

// REGULATORS_VREGRADIO.DCDCEN: DC/DC enable register for VREGRADIO
func (o *REGULATORS_VREGRADIO_Type) SetDCDCEN(value uint32) {
	volatile.StoreUint32(&o.DCDCEN.Reg, volatile.LoadUint32(&o.DCDCEN.Reg)&^(0x1)|value)
}
func (o *REGULATORS_VREGRADIO_Type) GetDCDCEN() uint32 {
	return volatile.LoadUint32(&o.DCDCEN.Reg) & 0x1
}

type REGULATORS_VREGH_Type struct {
	DCDCEN volatile.Register32 // 0xB00
}

// REGULATORS_VREGH.DCDCEN: DC/DC enable register for VREGH
func (o *REGULATORS_VREGH_Type) SetDCDCEN(value uint32) {
	volatile.StoreUint32(&o.DCDCEN.Reg, volatile.LoadUint32(&o.DCDCEN.Reg)&^(0x1)|value)
}
func (o *REGULATORS_VREGH_Type) GetDCDCEN() uint32 {
	return volatile.LoadUint32(&o.DCDCEN.Reg) & 0x1
}

// Clock management 0
type CLOCK_Type struct {
	TASKS_HFCLKSTART          volatile.Register32 // 0x0
	TASKS_HFCLKSTOP           volatile.Register32 // 0x4
	TASKS_LFCLKSTART          volatile.Register32 // 0x8
	TASKS_LFCLKSTOP           volatile.Register32 // 0xC
	TASKS_CAL                 volatile.Register32 // 0x10
	_                         [4]byte
	TASKS_HFCLKAUDIOSTART     volatile.Register32 // 0x18
	TASKS_HFCLKAUDIOSTOP      volatile.Register32 // 0x1C
	TASKS_HFCLK192MSTART      volatile.Register32 // 0x20
	TASKS_HFCLK192MSTOP       volatile.Register32 // 0x24
	_                         [88]byte
	SUBSCRIBE_HFCLKSTART      volatile.Register32 // 0x80
	SUBSCRIBE_HFCLKSTOP       volatile.Register32 // 0x84
	SUBSCRIBE_LFCLKSTART      volatile.Register32 // 0x88
	SUBSCRIBE_LFCLKSTOP       volatile.Register32 // 0x8C
	SUBSCRIBE_CAL             volatile.Register32 // 0x90
	_                         [4]byte
	SUBSCRIBE_HFCLKAUDIOSTART volatile.Register32 // 0x98
	SUBSCRIBE_HFCLKAUDIOSTOP  volatile.Register32 // 0x9C
	SUBSCRIBE_HFCLK192MSTART  volatile.Register32 // 0xA0
	SUBSCRIBE_HFCLK192MSTOP   volatile.Register32 // 0xA4
	_                         [88]byte
	EVENTS_HFCLKSTARTED       volatile.Register32 // 0x100
	EVENTS_LFCLKSTARTED       volatile.Register32 // 0x104
	_                         [20]byte
	EVENTS_DONE               volatile.Register32 // 0x11C
	EVENTS_HFCLKAUDIOSTARTED  volatile.Register32 // 0x120
	EVENTS_HFCLK192MSTARTED   volatile.Register32 // 0x124
	_                         [88]byte
	PUBLISH_HFCLKSTARTED      volatile.Register32 // 0x180
	PUBLISH_LFCLKSTARTED      volatile.Register32 // 0x184
	_                         [20]byte
	PUBLISH_DONE              volatile.Register32 // 0x19C
	PUBLISH_HFCLKAUDIOSTARTED volatile.Register32 // 0x1A0
	PUBLISH_HFCLK192MSTARTED  volatile.Register32 // 0x1A4
	_                         [344]byte
	INTEN                     volatile.Register32 // 0x300
	INTENSET                  volatile.Register32 // 0x304
	INTENCLR                  volatile.Register32 // 0x308
	INTPEND                   volatile.Register32 // 0x30C
	_                         [248]byte
	HFCLKRUN                  volatile.Register32 // 0x408
	HFCLKSTAT                 volatile.Register32 // 0x40C
	_                         [4]byte
	LFCLKRUN                  volatile.Register32 // 0x414
	LFCLKSTAT                 volatile.Register32 // 0x418
	LFCLKSRCCOPY              volatile.Register32 // 0x41C
	_                         [48]byte
	HFCLKAUDIORUN             volatile.Register32 // 0x450
	HFCLKAUDIOSTAT            volatile.Register32 // 0x454
	HFCLK192MRUN              volatile.Register32 // 0x458
	HFCLK192MSTAT             volatile.Register32 // 0x45C
	_                         [180]byte
	HFCLKSRC                  volatile.Register32 // 0x514
	LFCLKSRC                  volatile.Register32 // 0x518
	_                         [60]byte
	HFCLKCTRL                 volatile.Register32   // 0x558
	HFCLKAUDIO                CLOCK_HFCLKAUDIO_Type // 0x55C
	_                         [16]byte
	HFCLKALWAYSRUN            volatile.Register32 // 0x570
	LFCLKALWAYSRUN            volatile.Register32 // 0x574
	_                         [4]byte
	HFCLKAUDIOALWAYSRUN       volatile.Register32 // 0x57C
	HFCLK192MSRC              volatile.Register32 // 0x580
	HFCLK192MALWAYSRUN        volatile.Register32 // 0x584
	_                         [48]byte
	HFCLK192MCTRL             volatile.Register32 // 0x5B8
}

// CLOCK.TASKS_HFCLKSTART: Start HFCLK128M/HFCLK64M source as selected in HFCLKSRC
func (o *CLOCK_Type) SetTASKS_HFCLKSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLKSTART.Reg, volatile.LoadUint32(&o.TASKS_HFCLKSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLKSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLKSTART.Reg) & 0x1
}

// CLOCK.TASKS_HFCLKSTOP: Stop HFCLK128M/HFCLK64M source
func (o *CLOCK_Type) SetTASKS_HFCLKSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLKSTOP.Reg, volatile.LoadUint32(&o.TASKS_HFCLKSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLKSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLKSTOP.Reg) & 0x1
}

// CLOCK.TASKS_LFCLKSTART: Start LFCLK source as selected in LFCLKSRC
func (o *CLOCK_Type) SetTASKS_LFCLKSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_LFCLKSTART.Reg, volatile.LoadUint32(&o.TASKS_LFCLKSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_LFCLKSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_LFCLKSTART.Reg) & 0x1
}

// CLOCK.TASKS_LFCLKSTOP: Stop LFCLK source
func (o *CLOCK_Type) SetTASKS_LFCLKSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_LFCLKSTOP.Reg, volatile.LoadUint32(&o.TASKS_LFCLKSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_LFCLKSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_LFCLKSTOP.Reg) & 0x1
}

// CLOCK.TASKS_CAL: Start calibration of LFRC oscillator
func (o *CLOCK_Type) SetTASKS_CAL(value uint32) {
	volatile.StoreUint32(&o.TASKS_CAL.Reg, volatile.LoadUint32(&o.TASKS_CAL.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_CAL() uint32 {
	return volatile.LoadUint32(&o.TASKS_CAL.Reg) & 0x1
}

// CLOCK.TASKS_HFCLKAUDIOSTART: Start HFCLKAUDIO source
func (o *CLOCK_Type) SetTASKS_HFCLKAUDIOSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLKAUDIOSTART.Reg, volatile.LoadUint32(&o.TASKS_HFCLKAUDIOSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLKAUDIOSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLKAUDIOSTART.Reg) & 0x1
}

// CLOCK.TASKS_HFCLKAUDIOSTOP: Stop HFCLKAUDIO source
func (o *CLOCK_Type) SetTASKS_HFCLKAUDIOSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLKAUDIOSTOP.Reg, volatile.LoadUint32(&o.TASKS_HFCLKAUDIOSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLKAUDIOSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLKAUDIOSTOP.Reg) & 0x1
}

// CLOCK.TASKS_HFCLK192MSTART: Start HFCLK192M source as selected in HFCLK192MSRC
func (o *CLOCK_Type) SetTASKS_HFCLK192MSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLK192MSTART.Reg, volatile.LoadUint32(&o.TASKS_HFCLK192MSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLK192MSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLK192MSTART.Reg) & 0x1
}

// CLOCK.TASKS_HFCLK192MSTOP: Stop HFCLK192M source
func (o *CLOCK_Type) SetTASKS_HFCLK192MSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLK192MSTOP.Reg, volatile.LoadUint32(&o.TASKS_HFCLK192MSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLK192MSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLK192MSTOP.Reg) & 0x1
}

// CLOCK.SUBSCRIBE_HFCLKSTART: Subscribe configuration for task HFCLKSTART
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKSTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTART.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKSTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTART.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKSTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTART.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKSTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTART.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_HFCLKSTOP: Subscribe configuration for task HFCLKSTOP
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKSTOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTOP.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKSTOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTOP.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKSTOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTOP.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKSTOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_HFCLKSTOP.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_LFCLKSTART: Subscribe configuration for task LFCLKSTART
func (o *CLOCK_Type) SetSUBSCRIBE_LFCLKSTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_LFCLKSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTART.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_LFCLKSTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTART.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_LFCLKSTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_LFCLKSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTART.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_LFCLKSTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTART.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_LFCLKSTOP: Subscribe configuration for task LFCLKSTOP
func (o *CLOCK_Type) SetSUBSCRIBE_LFCLKSTOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_LFCLKSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTOP.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_LFCLKSTOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTOP.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_LFCLKSTOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_LFCLKSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTOP.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_LFCLKSTOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_LFCLKSTOP.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_CAL: Subscribe configuration for task CAL
func (o *CLOCK_Type) SetSUBSCRIBE_CAL_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CAL.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CAL.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_CAL_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CAL.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CAL.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CAL.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CAL.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_HFCLKAUDIOSTART: Subscribe configuration for task HFCLKAUDIOSTART
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKAUDIOSTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKAUDIOSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTART.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKAUDIOSTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTART.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKAUDIOSTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKAUDIOSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTART.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKAUDIOSTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTART.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_HFCLKAUDIOSTOP: Subscribe configuration for task HFCLKAUDIOSTOP
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKAUDIOSTOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKAUDIOSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTOP.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKAUDIOSTOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTOP.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLKAUDIOSTOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLKAUDIOSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTOP.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLKAUDIOSTOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_HFCLKAUDIOSTOP.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_HFCLK192MSTART: Subscribe configuration for task HFCLK192MSTART
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLK192MSTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLK192MSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTART.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLK192MSTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTART.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLK192MSTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLK192MSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTART.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLK192MSTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTART.Reg) & 0x80000000) >> 31
}

// CLOCK.SUBSCRIBE_HFCLK192MSTOP: Subscribe configuration for task HFCLK192MSTOP
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLK192MSTOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLK192MSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTOP.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLK192MSTOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTOP.Reg) & 0xff
}
func (o *CLOCK_Type) SetSUBSCRIBE_HFCLK192MSTOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_HFCLK192MSTOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTOP.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetSUBSCRIBE_HFCLK192MSTOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_HFCLK192MSTOP.Reg) & 0x80000000) >> 31
}

// CLOCK.EVENTS_HFCLKSTARTED: HFCLK128M/HFCLK64M source started
func (o *CLOCK_Type) SetEVENTS_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_HFCLKSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_HFCLKSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_HFCLKSTARTED.Reg) & 0x1
}

// CLOCK.EVENTS_LFCLKSTARTED: LFCLK source started
func (o *CLOCK_Type) SetEVENTS_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LFCLKSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_LFCLKSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_LFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LFCLKSTARTED.Reg) & 0x1
}

// CLOCK.EVENTS_DONE: Calibration of LFRC oscillator complete event
func (o *CLOCK_Type) SetEVENTS_DONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DONE.Reg, volatile.LoadUint32(&o.EVENTS_DONE.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_DONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DONE.Reg) & 0x1
}

// CLOCK.EVENTS_HFCLKAUDIOSTARTED: HFCLKAUDIO source started
func (o *CLOCK_Type) SetEVENTS_HFCLKAUDIOSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_HFCLKAUDIOSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_HFCLKAUDIOSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_HFCLKAUDIOSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_HFCLKAUDIOSTARTED.Reg) & 0x1
}

// CLOCK.EVENTS_HFCLK192MSTARTED: HFCLK192M source started
func (o *CLOCK_Type) SetEVENTS_HFCLK192MSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_HFCLK192MSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_HFCLK192MSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_HFCLK192MSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_HFCLK192MSTARTED.Reg) & 0x1
}

// CLOCK.PUBLISH_HFCLKSTARTED: Publish configuration for event HFCLKSTARTED
func (o *CLOCK_Type) SetPUBLISH_HFCLKSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_HFCLKSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_HFCLKSTARTED.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetPUBLISH_HFCLKSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_HFCLKSTARTED.Reg) & 0xff
}
func (o *CLOCK_Type) SetPUBLISH_HFCLKSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_HFCLKSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_HFCLKSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetPUBLISH_HFCLKSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_HFCLKSTARTED.Reg) & 0x80000000) >> 31
}

// CLOCK.PUBLISH_LFCLKSTARTED: Publish configuration for event LFCLKSTARTED
func (o *CLOCK_Type) SetPUBLISH_LFCLKSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LFCLKSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_LFCLKSTARTED.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetPUBLISH_LFCLKSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_LFCLKSTARTED.Reg) & 0xff
}
func (o *CLOCK_Type) SetPUBLISH_LFCLKSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LFCLKSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_LFCLKSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetPUBLISH_LFCLKSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_LFCLKSTARTED.Reg) & 0x80000000) >> 31
}

// CLOCK.PUBLISH_DONE: Publish configuration for event DONE
func (o *CLOCK_Type) SetPUBLISH_DONE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DONE.Reg, volatile.LoadUint32(&o.PUBLISH_DONE.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetPUBLISH_DONE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_DONE.Reg) & 0xff
}
func (o *CLOCK_Type) SetPUBLISH_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DONE.Reg, volatile.LoadUint32(&o.PUBLISH_DONE.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetPUBLISH_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_DONE.Reg) & 0x80000000) >> 31
}

// CLOCK.PUBLISH_HFCLKAUDIOSTARTED: Publish configuration for event HFCLKAUDIOSTARTED
func (o *CLOCK_Type) SetPUBLISH_HFCLKAUDIOSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_HFCLKAUDIOSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_HFCLKAUDIOSTARTED.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetPUBLISH_HFCLKAUDIOSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_HFCLKAUDIOSTARTED.Reg) & 0xff
}
func (o *CLOCK_Type) SetPUBLISH_HFCLKAUDIOSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_HFCLKAUDIOSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_HFCLKAUDIOSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetPUBLISH_HFCLKAUDIOSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_HFCLKAUDIOSTARTED.Reg) & 0x80000000) >> 31
}

// CLOCK.PUBLISH_HFCLK192MSTARTED: Publish configuration for event HFCLK192MSTARTED
func (o *CLOCK_Type) SetPUBLISH_HFCLK192MSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_HFCLK192MSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_HFCLK192MSTARTED.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetPUBLISH_HFCLK192MSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_HFCLK192MSTARTED.Reg) & 0xff
}
func (o *CLOCK_Type) SetPUBLISH_HFCLK192MSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_HFCLK192MSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_HFCLK192MSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCK_Type) GetPUBLISH_HFCLK192MSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_HFCLK192MSTARTED.Reg) & 0x80000000) >> 31
}

// CLOCK.INTEN: Enable or disable interrupt
func (o *CLOCK_Type) SetINTEN_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTEN_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTEN_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTEN_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTEN_DONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *CLOCK_Type) GetINTEN_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *CLOCK_Type) SetINTEN_HFCLKAUDIOSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *CLOCK_Type) GetINTEN_HFCLKAUDIOSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *CLOCK_Type) SetINTEN_HFCLK192MSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *CLOCK_Type) GetINTEN_HFCLK192MSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}

// CLOCK.INTENSET: Enable interrupt
func (o *CLOCK_Type) SetINTENSET_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTENSET_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTENSET_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTENSET_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTENSET_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *CLOCK_Type) GetINTENSET_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *CLOCK_Type) SetINTENSET_HFCLKAUDIOSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *CLOCK_Type) GetINTENSET_HFCLKAUDIOSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *CLOCK_Type) SetINTENSET_HFCLK192MSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *CLOCK_Type) GetINTENSET_HFCLK192MSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}

// CLOCK.INTENCLR: Disable interrupt
func (o *CLOCK_Type) SetINTENCLR_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTENCLR_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTENCLR_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTENCLR_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTENCLR_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *CLOCK_Type) GetINTENCLR_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *CLOCK_Type) SetINTENCLR_HFCLKAUDIOSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *CLOCK_Type) GetINTENCLR_HFCLKAUDIOSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *CLOCK_Type) SetINTENCLR_HFCLK192MSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *CLOCK_Type) GetINTENCLR_HFCLK192MSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}

// CLOCK.INTPEND: Pending interrupts
func (o *CLOCK_Type) SetINTPEND_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTPEND_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTPEND.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTPEND_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTPEND_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTPEND_DONE(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x80)|value<<7)
}
func (o *CLOCK_Type) GetINTPEND_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x80) >> 7
}
func (o *CLOCK_Type) SetINTPEND_HFCLKAUDIOSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x100)|value<<8)
}
func (o *CLOCK_Type) GetINTPEND_HFCLKAUDIOSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x100) >> 8
}
func (o *CLOCK_Type) SetINTPEND_HFCLK192MSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x200)|value<<9)
}
func (o *CLOCK_Type) GetINTPEND_HFCLK192MSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x200) >> 9
}

// CLOCK.HFCLKRUN: Status indicating that HFCLKSTART task has been triggered
func (o *CLOCK_Type) SetHFCLKRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.HFCLKRUN.Reg, volatile.LoadUint32(&o.HFCLKRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.HFCLKRUN.Reg) & 0x1
}

// CLOCK.HFCLKSTAT: Status indicating which HFCLK128M/HFCLK64M source is running This register value in any CLOCK instance reflects status only due to configurations/actions in that CLOCK instance.
func (o *CLOCK_Type) SetHFCLKSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x1
}
func (o *CLOCK_Type) SetHFCLKSTAT_ALWAYSRUNNING(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetHFCLKSTAT_ALWAYSRUNNING() uint32 {
	return (volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x10) >> 4
}
func (o *CLOCK_Type) SetHFCLKSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetHFCLKSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.LFCLKRUN: Status indicating that LFCLKSTART task has been triggered
func (o *CLOCK_Type) SetLFCLKRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.LFCLKRUN.Reg, volatile.LoadUint32(&o.LFCLKRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetLFCLKRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.LFCLKRUN.Reg) & 0x1
}

// CLOCK.LFCLKSTAT: Status indicating which LFCLK source is running This register value in any CLOCK instance reflects status only due to configurations/actions in that CLOCK instance.
func (o *CLOCK_Type) SetLFCLKSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x3
}
func (o *CLOCK_Type) SetLFCLKSTAT_ALWAYSRUNNING(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetLFCLKSTAT_ALWAYSRUNNING() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x10) >> 4
}
func (o *CLOCK_Type) SetLFCLKSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetLFCLKSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.LFCLKSRCCOPY: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
func (o *CLOCK_Type) SetLFCLKSRCCOPY_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRCCOPY.Reg, volatile.LoadUint32(&o.LFCLKSRCCOPY.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSRCCOPY_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSRCCOPY.Reg) & 0x3
}

// CLOCK.HFCLKAUDIORUN: Status indicating that HFCLKAUDIOSTART task has been triggered
func (o *CLOCK_Type) SetHFCLKAUDIORUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.HFCLKAUDIORUN.Reg, volatile.LoadUint32(&o.HFCLKAUDIORUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKAUDIORUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.HFCLKAUDIORUN.Reg) & 0x1
}

// CLOCK.HFCLKAUDIOSTAT: Status indicating which HFCLKAUDIO source is running
func (o *CLOCK_Type) SetHFCLKAUDIOSTAT_ALWAYSRUNNING(value uint32) {
	volatile.StoreUint32(&o.HFCLKAUDIOSTAT.Reg, volatile.LoadUint32(&o.HFCLKAUDIOSTAT.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetHFCLKAUDIOSTAT_ALWAYSRUNNING() uint32 {
	return (volatile.LoadUint32(&o.HFCLKAUDIOSTAT.Reg) & 0x10) >> 4
}
func (o *CLOCK_Type) SetHFCLKAUDIOSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.HFCLKAUDIOSTAT.Reg, volatile.LoadUint32(&o.HFCLKAUDIOSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetHFCLKAUDIOSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.HFCLKAUDIOSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.HFCLK192MRUN: Status indicating that HFCLK192MSTART task has been triggered
func (o *CLOCK_Type) SetHFCLK192MRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MRUN.Reg, volatile.LoadUint32(&o.HFCLK192MRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLK192MRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.HFCLK192MRUN.Reg) & 0x1
}

// CLOCK.HFCLK192MSTAT: Status indicating which HFCLK192M source is running
func (o *CLOCK_Type) SetHFCLK192MSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MSTAT.Reg, volatile.LoadUint32(&o.HFCLK192MSTAT.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLK192MSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.HFCLK192MSTAT.Reg) & 0x1
}
func (o *CLOCK_Type) SetHFCLK192MSTAT_ALWAYSRUNNING(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MSTAT.Reg, volatile.LoadUint32(&o.HFCLK192MSTAT.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetHFCLK192MSTAT_ALWAYSRUNNING() uint32 {
	return (volatile.LoadUint32(&o.HFCLK192MSTAT.Reg) & 0x10) >> 4
}
func (o *CLOCK_Type) SetHFCLK192MSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MSTAT.Reg, volatile.LoadUint32(&o.HFCLK192MSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetHFCLK192MSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.HFCLK192MSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.HFCLKSRC: Clock source for HFCLK128M/HFCLK64M
func (o *CLOCK_Type) SetHFCLKSRC_SRC(value uint32) {
	volatile.StoreUint32(&o.HFCLKSRC.Reg, volatile.LoadUint32(&o.HFCLKSRC.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKSRC_SRC() uint32 {
	return volatile.LoadUint32(&o.HFCLKSRC.Reg) & 0x1
}

// CLOCK.LFCLKSRC: Clock source for LFCLK
func (o *CLOCK_Type) SetLFCLKSRC_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSRC_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x3
}

// CLOCK.HFCLKCTRL: HFCLK128M frequency configuration
func (o *CLOCK_Type) SetHFCLKCTRL_HCLK(value uint32) {
	volatile.StoreUint32(&o.HFCLKCTRL.Reg, volatile.LoadUint32(&o.HFCLKCTRL.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetHFCLKCTRL_HCLK() uint32 {
	return volatile.LoadUint32(&o.HFCLKCTRL.Reg) & 0x3
}

// CLOCK.HFCLKALWAYSRUN: Automatic or manual control of HFCLK128M/HFCLK64M
func (o *CLOCK_Type) SetHFCLKALWAYSRUN_ALWAYSRUN(value uint32) {
	volatile.StoreUint32(&o.HFCLKALWAYSRUN.Reg, volatile.LoadUint32(&o.HFCLKALWAYSRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKALWAYSRUN_ALWAYSRUN() uint32 {
	return volatile.LoadUint32(&o.HFCLKALWAYSRUN.Reg) & 0x1
}

// CLOCK.LFCLKALWAYSRUN: Automatic or manual control of LFCLK
func (o *CLOCK_Type) SetLFCLKALWAYSRUN_ALWAYSRUN(value uint32) {
	volatile.StoreUint32(&o.LFCLKALWAYSRUN.Reg, volatile.LoadUint32(&o.LFCLKALWAYSRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetLFCLKALWAYSRUN_ALWAYSRUN() uint32 {
	return volatile.LoadUint32(&o.LFCLKALWAYSRUN.Reg) & 0x1
}

// CLOCK.HFCLKAUDIOALWAYSRUN: Automatic or manual control of HFCLKAUDIO
func (o *CLOCK_Type) SetHFCLKAUDIOALWAYSRUN_ALWAYSRUN(value uint32) {
	volatile.StoreUint32(&o.HFCLKAUDIOALWAYSRUN.Reg, volatile.LoadUint32(&o.HFCLKAUDIOALWAYSRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKAUDIOALWAYSRUN_ALWAYSRUN() uint32 {
	return volatile.LoadUint32(&o.HFCLKAUDIOALWAYSRUN.Reg) & 0x1
}

// CLOCK.HFCLK192MSRC: Clock source for HFCLK192M
func (o *CLOCK_Type) SetHFCLK192MSRC_SRC(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MSRC.Reg, volatile.LoadUint32(&o.HFCLK192MSRC.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLK192MSRC_SRC() uint32 {
	return volatile.LoadUint32(&o.HFCLK192MSRC.Reg) & 0x1
}

// CLOCK.HFCLK192MALWAYSRUN: Automatic or manual control of HFCLK192M
func (o *CLOCK_Type) SetHFCLK192MALWAYSRUN_ALWAYSRUN(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MALWAYSRUN.Reg, volatile.LoadUint32(&o.HFCLK192MALWAYSRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLK192MALWAYSRUN_ALWAYSRUN() uint32 {
	return volatile.LoadUint32(&o.HFCLK192MALWAYSRUN.Reg) & 0x1
}

// CLOCK.HFCLK192MCTRL: HFCLK192M frequency configuration
func (o *CLOCK_Type) SetHFCLK192MCTRL_HCLK192M(value uint32) {
	volatile.StoreUint32(&o.HFCLK192MCTRL.Reg, volatile.LoadUint32(&o.HFCLK192MCTRL.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetHFCLK192MCTRL_HCLK192M() uint32 {
	return volatile.LoadUint32(&o.HFCLK192MCTRL.Reg) & 0x3
}

type CLOCK_HFCLKAUDIO_Type struct {
	FREQUENCY volatile.Register32 // 0x55C
}

// CLOCK_HFCLKAUDIO.FREQUENCY: Audio PLL frequency in 11.176 MHz - 11.402 MHz or 12.165 MHz - 12.411 MHz frequency bands
func (o *CLOCK_HFCLKAUDIO_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, volatile.LoadUint32(&o.FREQUENCY.Reg)&^(0xffff)|value)
}
func (o *CLOCK_HFCLKAUDIO_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg) & 0xffff
}

// Power control 0
type POWER_Type struct {
	_                  [120]byte
	TASKS_CONSTLAT     volatile.Register32 // 0x78
	TASKS_LOWPWR       volatile.Register32 // 0x7C
	_                  [120]byte
	SUBSCRIBE_CONSTLAT volatile.Register32 // 0xF8
	SUBSCRIBE_LOWPWR   volatile.Register32 // 0xFC
	_                  [8]byte
	EVENTS_POFWARN     volatile.Register32 // 0x108
	_                  [8]byte
	EVENTS_SLEEPENTER  volatile.Register32 // 0x114
	EVENTS_SLEEPEXIT   volatile.Register32 // 0x118
	_                  [108]byte
	PUBLISH_POFWARN    volatile.Register32 // 0x188
	_                  [8]byte
	PUBLISH_SLEEPENTER volatile.Register32 // 0x194
	PUBLISH_SLEEPEXIT  volatile.Register32 // 0x198
	_                  [356]byte
	INTEN              volatile.Register32 // 0x300
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [528]byte
	GPREGRET           [2]volatile.Register32 // 0x51C
}

// POWER.TASKS_CONSTLAT: Enable Constant Latency mode
func (o *POWER_Type) SetTASKS_CONSTLAT(value uint32) {
	volatile.StoreUint32(&o.TASKS_CONSTLAT.Reg, volatile.LoadUint32(&o.TASKS_CONSTLAT.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetTASKS_CONSTLAT() uint32 {
	return volatile.LoadUint32(&o.TASKS_CONSTLAT.Reg) & 0x1
}

// POWER.TASKS_LOWPWR: Enable Low-Power mode (variable latency)
func (o *POWER_Type) SetTASKS_LOWPWR(value uint32) {
	volatile.StoreUint32(&o.TASKS_LOWPWR.Reg, volatile.LoadUint32(&o.TASKS_LOWPWR.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetTASKS_LOWPWR() uint32 {
	return volatile.LoadUint32(&o.TASKS_LOWPWR.Reg) & 0x1
}

// POWER.SUBSCRIBE_CONSTLAT: Subscribe configuration for task CONSTLAT
func (o *POWER_Type) SetSUBSCRIBE_CONSTLAT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CONSTLAT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CONSTLAT.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetSUBSCRIBE_CONSTLAT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CONSTLAT.Reg) & 0xff
}
func (o *POWER_Type) SetSUBSCRIBE_CONSTLAT_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CONSTLAT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CONSTLAT.Reg)&^(0x80000000)|value<<31)
}
func (o *POWER_Type) GetSUBSCRIBE_CONSTLAT_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CONSTLAT.Reg) & 0x80000000) >> 31
}

// POWER.SUBSCRIBE_LOWPWR: Subscribe configuration for task LOWPWR
func (o *POWER_Type) SetSUBSCRIBE_LOWPWR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_LOWPWR.Reg, volatile.LoadUint32(&o.SUBSCRIBE_LOWPWR.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetSUBSCRIBE_LOWPWR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_LOWPWR.Reg) & 0xff
}
func (o *POWER_Type) SetSUBSCRIBE_LOWPWR_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_LOWPWR.Reg, volatile.LoadUint32(&o.SUBSCRIBE_LOWPWR.Reg)&^(0x80000000)|value<<31)
}
func (o *POWER_Type) GetSUBSCRIBE_LOWPWR_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_LOWPWR.Reg) & 0x80000000) >> 31
}

// POWER.EVENTS_POFWARN: Power failure warning
func (o *POWER_Type) SetEVENTS_POFWARN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_POFWARN.Reg, volatile.LoadUint32(&o.EVENTS_POFWARN.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_POFWARN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_POFWARN.Reg) & 0x1
}

// POWER.EVENTS_SLEEPENTER: CPU entered WFI/WFE sleep
func (o *POWER_Type) SetEVENTS_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SLEEPENTER.Reg, volatile.LoadUint32(&o.EVENTS_SLEEPENTER.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_SLEEPENTER() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SLEEPENTER.Reg) & 0x1
}

// POWER.EVENTS_SLEEPEXIT: CPU exited WFI/WFE sleep
func (o *POWER_Type) SetEVENTS_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SLEEPEXIT.Reg, volatile.LoadUint32(&o.EVENTS_SLEEPEXIT.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_SLEEPEXIT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SLEEPEXIT.Reg) & 0x1
}

// POWER.PUBLISH_POFWARN: Publish configuration for event POFWARN
func (o *POWER_Type) SetPUBLISH_POFWARN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_POFWARN.Reg, volatile.LoadUint32(&o.PUBLISH_POFWARN.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetPUBLISH_POFWARN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_POFWARN.Reg) & 0xff
}
func (o *POWER_Type) SetPUBLISH_POFWARN_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_POFWARN.Reg, volatile.LoadUint32(&o.PUBLISH_POFWARN.Reg)&^(0x80000000)|value<<31)
}
func (o *POWER_Type) GetPUBLISH_POFWARN_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_POFWARN.Reg) & 0x80000000) >> 31
}

// POWER.PUBLISH_SLEEPENTER: Publish configuration for event SLEEPENTER
func (o *POWER_Type) SetPUBLISH_SLEEPENTER_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SLEEPENTER.Reg, volatile.LoadUint32(&o.PUBLISH_SLEEPENTER.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetPUBLISH_SLEEPENTER_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SLEEPENTER.Reg) & 0xff
}
func (o *POWER_Type) SetPUBLISH_SLEEPENTER_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SLEEPENTER.Reg, volatile.LoadUint32(&o.PUBLISH_SLEEPENTER.Reg)&^(0x80000000)|value<<31)
}
func (o *POWER_Type) GetPUBLISH_SLEEPENTER_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SLEEPENTER.Reg) & 0x80000000) >> 31
}

// POWER.PUBLISH_SLEEPEXIT: Publish configuration for event SLEEPEXIT
func (o *POWER_Type) SetPUBLISH_SLEEPEXIT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SLEEPEXIT.Reg, volatile.LoadUint32(&o.PUBLISH_SLEEPEXIT.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetPUBLISH_SLEEPEXIT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SLEEPEXIT.Reg) & 0xff
}
func (o *POWER_Type) SetPUBLISH_SLEEPEXIT_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SLEEPEXIT.Reg, volatile.LoadUint32(&o.PUBLISH_SLEEPEXIT.Reg)&^(0x80000000)|value<<31)
}
func (o *POWER_Type) GetPUBLISH_SLEEPEXIT_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SLEEPEXIT.Reg) & 0x80000000) >> 31
}

// POWER.INTEN: Enable or disable interrupt
func (o *POWER_Type) SetINTEN_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTEN_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTEN_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTEN_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTEN_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTEN_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}

// POWER.INTENSET: Enable interrupt
func (o *POWER_Type) SetINTENSET_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTENSET_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTENSET_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTENSET_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTENSET_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTENSET_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}

// POWER.INTENCLR: Disable interrupt
func (o *POWER_Type) SetINTENCLR_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTENCLR_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTENCLR_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTENCLR_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTENCLR_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTENCLR_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}

// POWER.GPREGRET: Description collection: General purpose retention register
func (o *POWER_Type) SetGPREGRET(idx int, value uint32) {
	volatile.StoreUint32(&o.GPREGRET[idx].Reg, volatile.LoadUint32(&o.GPREGRET[idx].Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetGPREGRET(idx int) uint32 {
	return volatile.LoadUint32(&o.GPREGRET[idx].Reg) & 0xff
}

// Reset control 0
type RESET_Type struct {
	_         [1024]byte
	RESETREAS volatile.Register32 // 0x400
	_         [524]byte
	NETWORK   RESET_NETWORK_Type // 0x610
}

// RESET.RESETREAS: Reset reason
func (o *RESET_Type) SetRESETREAS_RESETPIN(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x1)|value)
}
func (o *RESET_Type) GetRESETREAS_RESETPIN() uint32 {
	return volatile.LoadUint32(&o.RESETREAS.Reg) & 0x1
}
func (o *RESET_Type) SetRESETREAS_DOG0(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x2)|value<<1)
}
func (o *RESET_Type) GetRESETREAS_DOG0() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x2) >> 1
}
func (o *RESET_Type) SetRESETREAS_CTRLAP(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x4)|value<<2)
}
func (o *RESET_Type) GetRESETREAS_CTRLAP() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x4) >> 2
}
func (o *RESET_Type) SetRESETREAS_SREQ(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x8)|value<<3)
}
func (o *RESET_Type) GetRESETREAS_SREQ() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x8) >> 3
}
func (o *RESET_Type) SetRESETREAS_LOCKUP(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x10)|value<<4)
}
func (o *RESET_Type) GetRESETREAS_LOCKUP() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x10) >> 4
}
func (o *RESET_Type) SetRESETREAS_OFF(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x20)|value<<5)
}
func (o *RESET_Type) GetRESETREAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x20) >> 5
}
func (o *RESET_Type) SetRESETREAS_LPCOMP(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x40)|value<<6)
}
func (o *RESET_Type) GetRESETREAS_LPCOMP() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x40) >> 6
}
func (o *RESET_Type) SetRESETREAS_DIF(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x80)|value<<7)
}
func (o *RESET_Type) GetRESETREAS_DIF() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x80) >> 7
}
func (o *RESET_Type) SetRESETREAS_NFC(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x1000000)|value<<24)
}
func (o *RESET_Type) GetRESETREAS_NFC() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x1000000) >> 24
}
func (o *RESET_Type) SetRESETREAS_DOG1(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x2000000)|value<<25)
}
func (o *RESET_Type) GetRESETREAS_DOG1() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x2000000) >> 25
}
func (o *RESET_Type) SetRESETREAS_VBUS(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x4000000)|value<<26)
}
func (o *RESET_Type) GetRESETREAS_VBUS() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x4000000) >> 26
}

type RESET_NETWORK_Type struct {
	_        [4]byte
	FORCEOFF volatile.Register32 // 0x614
}

// RESET_NETWORK.FORCEOFF: Force network core off
func (o *RESET_NETWORK_Type) SetFORCEOFF(value uint32) {
	volatile.StoreUint32(&o.FORCEOFF.Reg, volatile.LoadUint32(&o.FORCEOFF.Reg)&^(0x1)|value)
}
func (o *RESET_NETWORK_Type) GetFORCEOFF() uint32 {
	return volatile.LoadUint32(&o.FORCEOFF.Reg) & 0x1
}

// Control access port 0
type CTRLAPPERI_Type struct {
	_               [1024]byte
	MAILBOX         CTRLAPPERI_MAILBOX_Type // 0x400
	_               [120]byte
	ERASEPROTECT    CTRLAPPERI_ERASEPROTECT_Type // 0x500
	_               [56]byte
	APPROTECT       CTRLAPPERI_APPROTECT_Type       // 0x540
	SECUREAPPROTECT CTRLAPPERI_SECUREAPPROTECT_Type // 0x548
	_               [176]byte
	STATUS          volatile.Register32 // 0x600
}

// CTRLAPPERI.STATUS: Status bits for CTRL-AP peripheral
func (o *CTRLAPPERI_Type) SetSTATUS_APPROTECT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *CTRLAPPERI_Type) GetSTATUS_APPROTECT() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *CTRLAPPERI_Type) SetSTATUS_SECUREAPPROTECT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *CTRLAPPERI_Type) GetSTATUS_SECUREAPPROTECT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *CTRLAPPERI_Type) SetSTATUS_DBGIFACEMODE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *CTRLAPPERI_Type) GetSTATUS_DBGIFACEMODE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}

type CTRLAPPERI_MAILBOX_Type struct {
	RXDATA   volatile.Register32 // 0x400
	RXSTATUS volatile.Register32 // 0x404
	_        [120]byte
	TXDATA   volatile.Register32 // 0x480
	TXSTATUS volatile.Register32 // 0x484
}

// CTRLAPPERI_MAILBOX.RXDATA: Data sent from the debugger to the CPU.
func (o *CTRLAPPERI_MAILBOX_Type) SetRXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDATA.Reg, value)
}
func (o *CTRLAPPERI_MAILBOX_Type) GetRXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDATA.Reg)
}

// CTRLAPPERI_MAILBOX.RXSTATUS: This register shows a status that indicates if data sent from the debugger to the CPU has been read.
func (o *CTRLAPPERI_MAILBOX_Type) SetRXSTATUS(value uint32) {
	volatile.StoreUint32(&o.RXSTATUS.Reg, volatile.LoadUint32(&o.RXSTATUS.Reg)&^(0x1)|value)
}
func (o *CTRLAPPERI_MAILBOX_Type) GetRXSTATUS() uint32 {
	return volatile.LoadUint32(&o.RXSTATUS.Reg) & 0x1
}

// CTRLAPPERI_MAILBOX.TXDATA: Data sent from the CPU to the debugger.
func (o *CTRLAPPERI_MAILBOX_Type) SetTXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDATA.Reg, value)
}
func (o *CTRLAPPERI_MAILBOX_Type) GetTXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDATA.Reg)
}

// CTRLAPPERI_MAILBOX.TXSTATUS: This register shows a status that indicates if the data sent from the CPU to the debugger has been read.
func (o *CTRLAPPERI_MAILBOX_Type) SetTXSTATUS(value uint32) {
	volatile.StoreUint32(&o.TXSTATUS.Reg, volatile.LoadUint32(&o.TXSTATUS.Reg)&^(0x1)|value)
}
func (o *CTRLAPPERI_MAILBOX_Type) GetTXSTATUS() uint32 {
	return volatile.LoadUint32(&o.TXSTATUS.Reg) & 0x1
}

type CTRLAPPERI_ERASEPROTECT_Type struct {
	LOCK    volatile.Register32 // 0x500
	DISABLE volatile.Register32 // 0x504
}

// CTRLAPPERI_ERASEPROTECT.LOCK: This register locks the ERASEPROTECT.DISABLE register from being written until next reset.
func (o *CTRLAPPERI_ERASEPROTECT_Type) SetLOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK.Reg, volatile.LoadUint32(&o.LOCK.Reg)&^(0x1)|value)
}
func (o *CTRLAPPERI_ERASEPROTECT_Type) GetLOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK.Reg) & 0x1
}

// CTRLAPPERI_ERASEPROTECT.DISABLE: This register disables the ERASEPROTECT register and performs an ERASEALL operation.
func (o *CTRLAPPERI_ERASEPROTECT_Type) SetDISABLE(value uint32) {
	volatile.StoreUint32(&o.DISABLE.Reg, value)
}
func (o *CTRLAPPERI_ERASEPROTECT_Type) GetDISABLE() uint32 {
	return volatile.LoadUint32(&o.DISABLE.Reg)
}

type CTRLAPPERI_APPROTECT_Type struct {
	LOCK    volatile.Register32 // 0x540
	DISABLE volatile.Register32 // 0x544
}

// CTRLAPPERI_APPROTECT.LOCK: This register locks the APPROTECT.DISABLE register from being written to until next reset.
func (o *CTRLAPPERI_APPROTECT_Type) SetLOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK.Reg, volatile.LoadUint32(&o.LOCK.Reg)&^(0x1)|value)
}
func (o *CTRLAPPERI_APPROTECT_Type) GetLOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK.Reg) & 0x1
}

// CTRLAPPERI_APPROTECT.DISABLE: This register disables the APPROTECT register and enables debug access to non-secure mode.
func (o *CTRLAPPERI_APPROTECT_Type) SetDISABLE(value uint32) {
	volatile.StoreUint32(&o.DISABLE.Reg, value)
}
func (o *CTRLAPPERI_APPROTECT_Type) GetDISABLE() uint32 {
	return volatile.LoadUint32(&o.DISABLE.Reg)
}

type CTRLAPPERI_SECUREAPPROTECT_Type struct {
	LOCK    volatile.Register32 // 0x548
	DISABLE volatile.Register32 // 0x54C
}

// CTRLAPPERI_SECUREAPPROTECT.LOCK: This register locks the SECUREAPPROTECT.DISABLE register from being written until next reset.
func (o *CTRLAPPERI_SECUREAPPROTECT_Type) SetLOCK(value uint32) {
	volatile.StoreUint32(&o.LOCK.Reg, volatile.LoadUint32(&o.LOCK.Reg)&^(0x1)|value)
}
func (o *CTRLAPPERI_SECUREAPPROTECT_Type) GetLOCK() uint32 {
	return volatile.LoadUint32(&o.LOCK.Reg) & 0x1
}

// CTRLAPPERI_SECUREAPPROTECT.DISABLE: This register disables the SECUREAPPROTECT register and enables debug access to secure mode.
func (o *CTRLAPPERI_SECUREAPPROTECT_Type) SetDISABLE(value uint32) {
	volatile.StoreUint32(&o.DISABLE.Reg, value)
}
func (o *CTRLAPPERI_SECUREAPPROTECT_Type) GetDISABLE() uint32 {
	return volatile.LoadUint32(&o.DISABLE.Reg)
}

// Serial Peripheral Interface Master with EasyDMA 0
type SPIM_Type struct {
	_                 [16]byte
	TASKS_START       volatile.Register32 // 0x10
	TASKS_STOP        volatile.Register32 // 0x14
	_                 [4]byte
	TASKS_SUSPEND     volatile.Register32 // 0x1C
	TASKS_RESUME      volatile.Register32 // 0x20
	_                 [108]byte
	SUBSCRIBE_START   volatile.Register32 // 0x90
	SUBSCRIBE_STOP    volatile.Register32 // 0x94
	_                 [4]byte
	SUBSCRIBE_SUSPEND volatile.Register32 // 0x9C
	SUBSCRIBE_RESUME  volatile.Register32 // 0xA0
	_                 [96]byte
	EVENTS_STOPPED    volatile.Register32 // 0x104
	_                 [8]byte
	EVENTS_ENDRX      volatile.Register32 // 0x110
	_                 [4]byte
	EVENTS_END        volatile.Register32 // 0x118
	_                 [4]byte
	EVENTS_ENDTX      volatile.Register32 // 0x120
	_                 [40]byte
	EVENTS_STARTED    volatile.Register32 // 0x14C
	_                 [52]byte
	PUBLISH_STOPPED   volatile.Register32 // 0x184
	_                 [8]byte
	PUBLISH_ENDRX     volatile.Register32 // 0x190
	_                 [4]byte
	PUBLISH_END       volatile.Register32 // 0x198
	_                 [4]byte
	PUBLISH_ENDTX     volatile.Register32 // 0x1A0
	_                 [40]byte
	PUBLISH_STARTED   volatile.Register32 // 0x1CC
	_                 [48]byte
	SHORTS            volatile.Register32 // 0x200
	_                 [256]byte
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
	_                 [244]byte
	STALLSTAT         volatile.Register32 // 0x400
	_                 [252]byte
	ENABLE            volatile.Register32 // 0x500
	_                 [4]byte
	PSEL              SPIM_PSEL_Type // 0x508
	_                 [12]byte
	FREQUENCY         volatile.Register32 // 0x524
	_                 [12]byte
	RXD               SPIM_RXD_Type       // 0x534
	TXD               SPIM_TXD_Type       // 0x544
	CONFIG            volatile.Register32 // 0x554
	_                 [8]byte
	IFTIMING          SPIM_IFTIMING_Type  // 0x560
	CSNPOL            volatile.Register32 // 0x568
	PSELDCX           volatile.Register32 // 0x56C
	DCXCNT            volatile.Register32 // 0x570
	_                 [76]byte
	ORC               volatile.Register32 // 0x5C0
}

// SPIM.TASKS_START: Start SPI transaction
func (o *SPIM_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// SPIM.TASKS_STOP: Stop SPI transaction
func (o *SPIM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// SPIM.TASKS_SUSPEND: Suspend SPI transaction
func (o *SPIM_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// SPIM.TASKS_RESUME: Resume SPI transaction
func (o *SPIM_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// SPIM.SUBSCRIBE_START: Subscribe configuration for task START
func (o *SPIM_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *SPIM_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// SPIM.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *SPIM_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *SPIM_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// SPIM.SUBSCRIBE_SUSPEND: Subscribe configuration for task SUSPEND
func (o *SPIM_Type) SetSUBSCRIBE_SUSPEND_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SUSPEND.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetSUBSCRIBE_SUSPEND_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg) & 0xff
}
func (o *SPIM_Type) SetSUBSCRIBE_SUSPEND_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SUSPEND.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetSUBSCRIBE_SUSPEND_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg) & 0x80000000) >> 31
}

// SPIM.SUBSCRIBE_RESUME: Subscribe configuration for task RESUME
func (o *SPIM_Type) SetSUBSCRIBE_RESUME_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RESUME.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetSUBSCRIBE_RESUME_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg) & 0xff
}
func (o *SPIM_Type) SetSUBSCRIBE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RESUME.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetSUBSCRIBE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg) & 0x80000000) >> 31
}

// SPIM.EVENTS_STOPPED: SPI transaction has stopped
func (o *SPIM_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// SPIM.EVENTS_ENDRX: End of RXD buffer reached
func (o *SPIM_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// SPIM.EVENTS_END: End of RXD buffer and TXD buffer reached
func (o *SPIM_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// SPIM.EVENTS_ENDTX: End of TXD buffer reached
func (o *SPIM_Type) SetEVENTS_ENDTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDTX.Reg, volatile.LoadUint32(&o.EVENTS_ENDTX.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_ENDTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDTX.Reg) & 0x1
}

// SPIM.EVENTS_STARTED: Transaction started
func (o *SPIM_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// SPIM.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *SPIM_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *SPIM_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// SPIM.PUBLISH_ENDRX: Publish configuration for event ENDRX
func (o *SPIM_Type) SetPUBLISH_ENDRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetPUBLISH_ENDRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0xff
}
func (o *SPIM_Type) SetPUBLISH_ENDRX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetPUBLISH_ENDRX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0x80000000) >> 31
}

// SPIM.PUBLISH_END: Publish configuration for event END
func (o *SPIM_Type) SetPUBLISH_END_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetPUBLISH_END_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0xff
}
func (o *SPIM_Type) SetPUBLISH_END_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetPUBLISH_END_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0x80000000) >> 31
}

// SPIM.PUBLISH_ENDTX: Publish configuration for event ENDTX
func (o *SPIM_Type) SetPUBLISH_ENDTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDTX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetPUBLISH_ENDTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg) & 0xff
}
func (o *SPIM_Type) SetPUBLISH_ENDTX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDTX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetPUBLISH_ENDTX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg) & 0x80000000) >> 31
}

// SPIM.PUBLISH_STARTED: Publish configuration for event STARTED
func (o *SPIM_Type) SetPUBLISH_STARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetPUBLISH_STARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0xff
}
func (o *SPIM_Type) SetPUBLISH_STARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetPUBLISH_STARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0x80000000) >> 31
}

// SPIM.SHORTS: Shortcuts between local events and tasks
func (o *SPIM_Type) SetSHORTS_END_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20000)|value<<17)
}
func (o *SPIM_Type) GetSHORTS_END_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20000) >> 17
}

// SPIM.INTENSET: Enable interrupt
func (o *SPIM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPIM_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPIM_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *SPIM_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *SPIM_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SPIM_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *SPIM_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *SPIM_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}

// SPIM.INTENCLR: Disable interrupt
func (o *SPIM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPIM_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPIM_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *SPIM_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *SPIM_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SPIM_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *SPIM_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *SPIM_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}

// SPIM.STALLSTAT: Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU.
func (o *SPIM_Type) SetSTALLSTAT_TX(value uint32) {
	volatile.StoreUint32(&o.STALLSTAT.Reg, volatile.LoadUint32(&o.STALLSTAT.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetSTALLSTAT_TX() uint32 {
	return volatile.LoadUint32(&o.STALLSTAT.Reg) & 0x1
}
func (o *SPIM_Type) SetSTALLSTAT_RX(value uint32) {
	volatile.StoreUint32(&o.STALLSTAT.Reg, volatile.LoadUint32(&o.STALLSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetSTALLSTAT_RX() uint32 {
	return (volatile.LoadUint32(&o.STALLSTAT.Reg) & 0x2) >> 1
}

// SPIM.ENABLE: Enable SPIM
func (o *SPIM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPIM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPIM.FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
func (o *SPIM_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *SPIM_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// SPIM.CONFIG: Configuration register
func (o *SPIM_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPIM_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPIM_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// SPIM.CSNPOL: Polarity of CSN output
func (o *SPIM_Type) SetCSNPOL(value uint32) {
	volatile.StoreUint32(&o.CSNPOL.Reg, volatile.LoadUint32(&o.CSNPOL.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetCSNPOL() uint32 {
	return volatile.LoadUint32(&o.CSNPOL.Reg) & 0x1
}

// SPIM.PSELDCX: Pin select for DCX signal
func (o *SPIM_Type) SetPSELDCX_PIN(value uint32) {
	volatile.StoreUint32(&o.PSELDCX.Reg, volatile.LoadUint32(&o.PSELDCX.Reg)&^(0x1f)|value)
}
func (o *SPIM_Type) GetPSELDCX_PIN() uint32 {
	return volatile.LoadUint32(&o.PSELDCX.Reg) & 0x1f
}
func (o *SPIM_Type) SetPSELDCX_PORT(value uint32) {
	volatile.StoreUint32(&o.PSELDCX.Reg, volatile.LoadUint32(&o.PSELDCX.Reg)&^(0x20)|value<<5)
}
func (o *SPIM_Type) GetPSELDCX_PORT() uint32 {
	return (volatile.LoadUint32(&o.PSELDCX.Reg) & 0x20) >> 5
}
func (o *SPIM_Type) SetPSELDCX_CONNECT(value uint32) {
	volatile.StoreUint32(&o.PSELDCX.Reg, volatile.LoadUint32(&o.PSELDCX.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_Type) GetPSELDCX_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.PSELDCX.Reg) & 0x80000000) >> 31
}

// SPIM.DCXCNT: DCX configuration
func (o *SPIM_Type) SetDCXCNT(value uint32) {
	volatile.StoreUint32(&o.DCXCNT.Reg, volatile.LoadUint32(&o.DCXCNT.Reg)&^(0xf)|value)
}
func (o *SPIM_Type) GetDCXCNT() uint32 {
	return volatile.LoadUint32(&o.DCXCNT.Reg) & 0xf
}

// SPIM.ORC: Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
func (o *SPIM_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

type SPIM_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MOSI volatile.Register32 // 0x50C
	MISO volatile.Register32 // 0x510
	CSN  volatile.Register32 // 0x514
}

// SPIM_PSEL.SCK: Pin select for SCK
func (o *SPIM_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetSCK_PORT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x20)|value<<5)
}
func (o *SPIM_PSEL_Type) GetSCK_PORT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x20) >> 5
}
func (o *SPIM_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.MOSI: Pin select for MOSI signal
func (o *SPIM_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetMOSI_PORT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x20)|value<<5)
}
func (o *SPIM_PSEL_Type) GetMOSI_PORT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x20) >> 5
}
func (o *SPIM_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.MISO: Pin select for MISO signal
func (o *SPIM_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetMISO_PORT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x20)|value<<5)
}
func (o *SPIM_PSEL_Type) GetMISO_PORT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x20) >> 5
}
func (o *SPIM_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.CSN: Pin select for CSN
func (o *SPIM_PSEL_Type) SetCSN_PIN(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetCSN_PIN() uint32 {
	return volatile.LoadUint32(&o.CSN.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetCSN_PORT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x20)|value<<5)
}
func (o *SPIM_PSEL_Type) GetCSN_PORT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x20) >> 5
}
func (o *SPIM_PSEL_Type) SetCSN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetCSN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x80000000) >> 31
}

type SPIM_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// SPIM_RXD.PTR: Data pointer
func (o *SPIM_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIM_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIM_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *SPIM_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *SPIM_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// SPIM_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *SPIM_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *SPIM_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// SPIM_RXD.LIST: EasyDMA list type
func (o *SPIM_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIM_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

type SPIM_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// SPIM_TXD.PTR: Data pointer
func (o *SPIM_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIM_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIM_TXD.MAXCNT: Number of bytes in transmit buffer
func (o *SPIM_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *SPIM_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// SPIM_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *SPIM_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *SPIM_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// SPIM_TXD.LIST: EasyDMA list type
func (o *SPIM_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIM_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

type SPIM_IFTIMING_Type struct {
	RXDELAY volatile.Register32 // 0x560
	CSNDUR  volatile.Register32 // 0x564
}

// SPIM_IFTIMING.RXDELAY: Sample delay for input serial data on MISO
func (o *SPIM_IFTIMING_Type) SetRXDELAY(value uint32) {
	volatile.StoreUint32(&o.RXDELAY.Reg, volatile.LoadUint32(&o.RXDELAY.Reg)&^(0x7)|value)
}
func (o *SPIM_IFTIMING_Type) GetRXDELAY() uint32 {
	return volatile.LoadUint32(&o.RXDELAY.Reg) & 0x7
}

// SPIM_IFTIMING.CSNDUR: Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions
func (o *SPIM_IFTIMING_Type) SetCSNDUR(value uint32) {
	volatile.StoreUint32(&o.CSNDUR.Reg, volatile.LoadUint32(&o.CSNDUR.Reg)&^(0xff)|value)
}
func (o *SPIM_IFTIMING_Type) GetCSNDUR() uint32 {
	return volatile.LoadUint32(&o.CSNDUR.Reg) & 0xff
}

// SPI Slave 0
type SPIS_Type struct {
	_                 [36]byte
	TASKS_ACQUIRE     volatile.Register32 // 0x24
	TASKS_RELEASE     volatile.Register32 // 0x28
	_                 [120]byte
	SUBSCRIBE_ACQUIRE volatile.Register32 // 0xA4
	SUBSCRIBE_RELEASE volatile.Register32 // 0xA8
	_                 [88]byte
	EVENTS_END        volatile.Register32 // 0x104
	_                 [8]byte
	EVENTS_ENDRX      volatile.Register32 // 0x110
	_                 [20]byte
	EVENTS_ACQUIRED   volatile.Register32 // 0x128
	_                 [88]byte
	PUBLISH_END       volatile.Register32 // 0x184
	_                 [8]byte
	PUBLISH_ENDRX     volatile.Register32 // 0x190
	_                 [20]byte
	PUBLISH_ACQUIRED  volatile.Register32 // 0x1A8
	_                 [84]byte
	SHORTS            volatile.Register32 // 0x200
	_                 [256]byte
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
	_                 [244]byte
	SEMSTAT           volatile.Register32 // 0x400
	_                 [60]byte
	STATUS            volatile.Register32 // 0x440
	_                 [188]byte
	ENABLE            volatile.Register32 // 0x500
	_                 [4]byte
	PSEL              SPIS_PSEL_Type // 0x508
	_                 [28]byte
	RXD               SPIS_RXD_Type       // 0x534
	TXD               SPIS_TXD_Type       // 0x544
	CONFIG            volatile.Register32 // 0x554
	_                 [4]byte
	DEF               volatile.Register32 // 0x55C
	_                 [96]byte
	ORC               volatile.Register32 // 0x5C0
}

// SPIS.TASKS_ACQUIRE: Acquire SPI semaphore
func (o *SPIS_Type) SetTASKS_ACQUIRE(value uint32) {
	volatile.StoreUint32(&o.TASKS_ACQUIRE.Reg, volatile.LoadUint32(&o.TASKS_ACQUIRE.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetTASKS_ACQUIRE() uint32 {
	return volatile.LoadUint32(&o.TASKS_ACQUIRE.Reg) & 0x1
}

// SPIS.TASKS_RELEASE: Release SPI semaphore, enabling the SPI slave to acquire it
func (o *SPIS_Type) SetTASKS_RELEASE(value uint32) {
	volatile.StoreUint32(&o.TASKS_RELEASE.Reg, volatile.LoadUint32(&o.TASKS_RELEASE.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetTASKS_RELEASE() uint32 {
	return volatile.LoadUint32(&o.TASKS_RELEASE.Reg) & 0x1
}

// SPIS.SUBSCRIBE_ACQUIRE: Subscribe configuration for task ACQUIRE
func (o *SPIS_Type) SetSUBSCRIBE_ACQUIRE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ACQUIRE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ACQUIRE.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetSUBSCRIBE_ACQUIRE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_ACQUIRE.Reg) & 0xff
}
func (o *SPIS_Type) SetSUBSCRIBE_ACQUIRE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ACQUIRE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ACQUIRE.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_Type) GetSUBSCRIBE_ACQUIRE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_ACQUIRE.Reg) & 0x80000000) >> 31
}

// SPIS.SUBSCRIBE_RELEASE: Subscribe configuration for task RELEASE
func (o *SPIS_Type) SetSUBSCRIBE_RELEASE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RELEASE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RELEASE.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetSUBSCRIBE_RELEASE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_RELEASE.Reg) & 0xff
}
func (o *SPIS_Type) SetSUBSCRIBE_RELEASE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RELEASE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RELEASE.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_Type) GetSUBSCRIBE_RELEASE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_RELEASE.Reg) & 0x80000000) >> 31
}

// SPIS.EVENTS_END: Granted transaction completed
func (o *SPIS_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// SPIS.EVENTS_ENDRX: End of RXD buffer reached
func (o *SPIS_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// SPIS.EVENTS_ACQUIRED: Semaphore acquired
func (o *SPIS_Type) SetEVENTS_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ACQUIRED.Reg, volatile.LoadUint32(&o.EVENTS_ACQUIRED.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetEVENTS_ACQUIRED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ACQUIRED.Reg) & 0x1
}

// SPIS.PUBLISH_END: Publish configuration for event END
func (o *SPIS_Type) SetPUBLISH_END_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetPUBLISH_END_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0xff
}
func (o *SPIS_Type) SetPUBLISH_END_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_Type) GetPUBLISH_END_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0x80000000) >> 31
}

// SPIS.PUBLISH_ENDRX: Publish configuration for event ENDRX
func (o *SPIS_Type) SetPUBLISH_ENDRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetPUBLISH_ENDRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0xff
}
func (o *SPIS_Type) SetPUBLISH_ENDRX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_Type) GetPUBLISH_ENDRX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0x80000000) >> 31
}

// SPIS.PUBLISH_ACQUIRED: Publish configuration for event ACQUIRED
func (o *SPIS_Type) SetPUBLISH_ACQUIRED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ACQUIRED.Reg, volatile.LoadUint32(&o.PUBLISH_ACQUIRED.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetPUBLISH_ACQUIRED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ACQUIRED.Reg) & 0xff
}
func (o *SPIS_Type) SetPUBLISH_ACQUIRED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ACQUIRED.Reg, volatile.LoadUint32(&o.PUBLISH_ACQUIRED.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_Type) GetPUBLISH_ACQUIRED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ACQUIRED.Reg) & 0x80000000) >> 31
}

// SPIS.SHORTS: Shortcuts between local events and tasks
func (o *SPIS_Type) SetSHORTS_END_ACQUIRE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *SPIS_Type) GetSHORTS_END_ACQUIRE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}

// SPIS.INTENSET: Enable interrupt
func (o *SPIS_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPIS_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPIS_Type) SetINTENSET_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *SPIS_Type) GetINTENSET_ACQUIRED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}

// SPIS.INTENCLR: Disable interrupt
func (o *SPIS_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPIS_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPIS_Type) SetINTENCLR_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *SPIS_Type) GetINTENCLR_ACQUIRED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}

// SPIS.SEMSTAT: Semaphore status register
func (o *SPIS_Type) SetSEMSTAT(value uint32) {
	volatile.StoreUint32(&o.SEMSTAT.Reg, volatile.LoadUint32(&o.SEMSTAT.Reg)&^(0x3)|value)
}
func (o *SPIS_Type) GetSEMSTAT() uint32 {
	return volatile.LoadUint32(&o.SEMSTAT.Reg) & 0x3
}

// SPIS.STATUS: Status from last transaction
func (o *SPIS_Type) SetSTATUS_OVERREAD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetSTATUS_OVERREAD() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *SPIS_Type) SetSTATUS_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetSTATUS_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}

// SPIS.ENABLE: Enable SPI slave
func (o *SPIS_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPIS_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPIS.CONFIG: Configuration register
func (o *SPIS_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPIS_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPIS_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// SPIS.DEF: Default character. Character clocked out in case of an ignored transaction.
func (o *SPIS_Type) SetDEF(value uint32) {
	volatile.StoreUint32(&o.DEF.Reg, volatile.LoadUint32(&o.DEF.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetDEF() uint32 {
	return volatile.LoadUint32(&o.DEF.Reg) & 0xff
}

// SPIS.ORC: Over-read character
func (o *SPIS_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

type SPIS_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MISO volatile.Register32 // 0x50C
	MOSI volatile.Register32 // 0x510
	CSN  volatile.Register32 // 0x514
}

// SPIS_PSEL.SCK: Pin select for SCK
func (o *SPIS_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetSCK_PORT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x20)|value<<5)
}
func (o *SPIS_PSEL_Type) GetSCK_PORT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x20) >> 5
}
func (o *SPIS_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.MISO: Pin select for MISO signal
func (o *SPIS_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetMISO_PORT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x20)|value<<5)
}
func (o *SPIS_PSEL_Type) GetMISO_PORT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x20) >> 5
}
func (o *SPIS_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.MOSI: Pin select for MOSI signal
func (o *SPIS_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetMOSI_PORT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x20)|value<<5)
}
func (o *SPIS_PSEL_Type) GetMOSI_PORT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x20) >> 5
}
func (o *SPIS_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.CSN: Pin select for CSN signal
func (o *SPIS_PSEL_Type) SetCSN_PIN(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetCSN_PIN() uint32 {
	return volatile.LoadUint32(&o.CSN.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetCSN_PORT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x20)|value<<5)
}
func (o *SPIS_PSEL_Type) GetCSN_PORT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x20) >> 5
}
func (o *SPIS_PSEL_Type) SetCSN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetCSN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x80000000) >> 31
}

type SPIS_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// SPIS_RXD.PTR: RXD data pointer
func (o *SPIS_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIS_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIS_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *SPIS_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *SPIS_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// SPIS_RXD.AMOUNT: Number of bytes received in last granted transaction
func (o *SPIS_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *SPIS_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// SPIS_RXD.LIST: EasyDMA list type
func (o *SPIS_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIS_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

type SPIS_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// SPIS_TXD.PTR: TXD data pointer
func (o *SPIS_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIS_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIS_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *SPIS_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *SPIS_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// SPIS_TXD.AMOUNT: Number of bytes transmitted in last granted transaction
func (o *SPIS_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *SPIS_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// SPIS_TXD.LIST: EasyDMA list type
func (o *SPIS_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIS_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// I2C compatible Two-Wire Master Interface with EasyDMA 0
type TWIM_Type struct {
	TASKS_STARTRX     volatile.Register32 // 0x0
	_                 [4]byte
	TASKS_STARTTX     volatile.Register32 // 0x8
	_                 [8]byte
	TASKS_STOP        volatile.Register32 // 0x14
	_                 [4]byte
	TASKS_SUSPEND     volatile.Register32 // 0x1C
	TASKS_RESUME      volatile.Register32 // 0x20
	_                 [92]byte
	SUBSCRIBE_STARTRX volatile.Register32 // 0x80
	_                 [4]byte
	SUBSCRIBE_STARTTX volatile.Register32 // 0x88
	_                 [8]byte
	SUBSCRIBE_STOP    volatile.Register32 // 0x94
	_                 [4]byte
	SUBSCRIBE_SUSPEND volatile.Register32 // 0x9C
	SUBSCRIBE_RESUME  volatile.Register32 // 0xA0
	_                 [96]byte
	EVENTS_STOPPED    volatile.Register32 // 0x104
	_                 [28]byte
	EVENTS_ERROR      volatile.Register32 // 0x124
	_                 [32]byte
	EVENTS_SUSPENDED  volatile.Register32 // 0x148
	EVENTS_RXSTARTED  volatile.Register32 // 0x14C
	EVENTS_TXSTARTED  volatile.Register32 // 0x150
	_                 [8]byte
	EVENTS_LASTRX     volatile.Register32 // 0x15C
	EVENTS_LASTTX     volatile.Register32 // 0x160
	_                 [32]byte
	PUBLISH_STOPPED   volatile.Register32 // 0x184
	_                 [28]byte
	PUBLISH_ERROR     volatile.Register32 // 0x1A4
	_                 [32]byte
	PUBLISH_SUSPENDED volatile.Register32 // 0x1C8
	PUBLISH_RXSTARTED volatile.Register32 // 0x1CC
	PUBLISH_TXSTARTED volatile.Register32 // 0x1D0
	_                 [8]byte
	PUBLISH_LASTRX    volatile.Register32 // 0x1DC
	PUBLISH_LASTTX    volatile.Register32 // 0x1E0
	_                 [28]byte
	SHORTS            volatile.Register32 // 0x200
	_                 [252]byte
	INTEN             volatile.Register32 // 0x300
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
	_                 [440]byte
	ERRORSRC          volatile.Register32 // 0x4C4
	_                 [56]byte
	ENABLE            volatile.Register32 // 0x500
	_                 [4]byte
	PSEL              TWIM_PSEL_Type // 0x508
	_                 [20]byte
	FREQUENCY         volatile.Register32 // 0x524
	_                 [12]byte
	RXD               TWIM_RXD_Type // 0x534
	TXD               TWIM_TXD_Type // 0x544
	_                 [52]byte
	ADDRESS           volatile.Register32 // 0x588
}

// TWIM.TASKS_STARTRX: Start TWI receive sequence
func (o *TWIM_Type) SetTASKS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTRX.Reg, volatile.LoadUint32(&o.TASKS_STARTRX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_STARTRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTRX.Reg) & 0x1
}

// TWIM.TASKS_STARTTX: Start TWI transmit sequence
func (o *TWIM_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// TWIM.TASKS_STOP: Stop TWI transaction. Must be issued while the TWI master is not suspended.
func (o *TWIM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TWIM.TASKS_SUSPEND: Suspend TWI transaction
func (o *TWIM_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// TWIM.TASKS_RESUME: Resume TWI transaction
func (o *TWIM_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// TWIM.SUBSCRIBE_STARTRX: Subscribe configuration for task STARTRX
func (o *TWIM_Type) SetSUBSCRIBE_STARTRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetSUBSCRIBE_STARTRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg) & 0xff
}
func (o *TWIM_Type) SetSUBSCRIBE_STARTRX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetSUBSCRIBE_STARTRX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg) & 0x80000000) >> 31
}

// TWIM.SUBSCRIBE_STARTTX: Subscribe configuration for task STARTTX
func (o *TWIM_Type) SetSUBSCRIBE_STARTTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetSUBSCRIBE_STARTTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg) & 0xff
}
func (o *TWIM_Type) SetSUBSCRIBE_STARTTX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetSUBSCRIBE_STARTTX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg) & 0x80000000) >> 31
}

// TWIM.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *TWIM_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *TWIM_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// TWIM.SUBSCRIBE_SUSPEND: Subscribe configuration for task SUSPEND
func (o *TWIM_Type) SetSUBSCRIBE_SUSPEND_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SUSPEND.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetSUBSCRIBE_SUSPEND_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg) & 0xff
}
func (o *TWIM_Type) SetSUBSCRIBE_SUSPEND_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SUSPEND.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetSUBSCRIBE_SUSPEND_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg) & 0x80000000) >> 31
}

// TWIM.SUBSCRIBE_RESUME: Subscribe configuration for task RESUME
func (o *TWIM_Type) SetSUBSCRIBE_RESUME_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RESUME.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetSUBSCRIBE_RESUME_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg) & 0xff
}
func (o *TWIM_Type) SetSUBSCRIBE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RESUME.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetSUBSCRIBE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg) & 0x80000000) >> 31
}

// TWIM.EVENTS_STOPPED: TWI stopped
func (o *TWIM_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// TWIM.EVENTS_ERROR: TWI error
func (o *TWIM_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// TWIM.EVENTS_SUSPENDED: SUSPEND task has been issued, TWI traffic is now suspended.
func (o *TWIM_Type) SetEVENTS_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SUSPENDED.Reg, volatile.LoadUint32(&o.EVENTS_SUSPENDED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_SUSPENDED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SUSPENDED.Reg) & 0x1
}

// TWIM.EVENTS_RXSTARTED: Receive sequence started
func (o *TWIM_Type) SetEVENTS_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_RXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg) & 0x1
}

// TWIM.EVENTS_TXSTARTED: Transmit sequence started
func (o *TWIM_Type) SetEVENTS_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_TXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg) & 0x1
}

// TWIM.EVENTS_LASTRX: Byte boundary, starting to receive the last byte
func (o *TWIM_Type) SetEVENTS_LASTRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LASTRX.Reg, volatile.LoadUint32(&o.EVENTS_LASTRX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_LASTRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LASTRX.Reg) & 0x1
}

// TWIM.EVENTS_LASTTX: Byte boundary, starting to transmit the last byte
func (o *TWIM_Type) SetEVENTS_LASTTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LASTTX.Reg, volatile.LoadUint32(&o.EVENTS_LASTTX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_LASTTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LASTTX.Reg) & 0x1
}

// TWIM.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *TWIM_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// TWIM.PUBLISH_ERROR: Publish configuration for event ERROR
func (o *TWIM_Type) SetPUBLISH_ERROR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_ERROR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0x80000000) >> 31
}

// TWIM.PUBLISH_SUSPENDED: Publish configuration for event SUSPENDED
func (o *TWIM_Type) SetPUBLISH_SUSPENDED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SUSPENDED.Reg, volatile.LoadUint32(&o.PUBLISH_SUSPENDED.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_SUSPENDED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SUSPENDED.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_SUSPENDED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SUSPENDED.Reg, volatile.LoadUint32(&o.PUBLISH_SUSPENDED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_SUSPENDED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SUSPENDED.Reg) & 0x80000000) >> 31
}

// TWIM.PUBLISH_RXSTARTED: Publish configuration for event RXSTARTED
func (o *TWIM_Type) SetPUBLISH_RXSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_RXSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_RXSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_RXSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg) & 0x80000000) >> 31
}

// TWIM.PUBLISH_TXSTARTED: Publish configuration for event TXSTARTED
func (o *TWIM_Type) SetPUBLISH_TXSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_TXSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_TXSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_TXSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg) & 0x80000000) >> 31
}

// TWIM.PUBLISH_LASTRX: Publish configuration for event LASTRX
func (o *TWIM_Type) SetPUBLISH_LASTRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LASTRX.Reg, volatile.LoadUint32(&o.PUBLISH_LASTRX.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_LASTRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_LASTRX.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_LASTRX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LASTRX.Reg, volatile.LoadUint32(&o.PUBLISH_LASTRX.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_LASTRX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_LASTRX.Reg) & 0x80000000) >> 31
}

// TWIM.PUBLISH_LASTTX: Publish configuration for event LASTTX
func (o *TWIM_Type) SetPUBLISH_LASTTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LASTTX.Reg, volatile.LoadUint32(&o.PUBLISH_LASTTX.Reg)&^(0xff)|value)
}
func (o *TWIM_Type) GetPUBLISH_LASTTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_LASTTX.Reg) & 0xff
}
func (o *TWIM_Type) SetPUBLISH_LASTTX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LASTTX.Reg, volatile.LoadUint32(&o.PUBLISH_LASTTX.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_Type) GetPUBLISH_LASTTX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_LASTTX.Reg) & 0x80000000) >> 31
}

// TWIM.SHORTS: Shortcuts between local events and tasks
func (o *TWIM_Type) SetSHORTS_LASTTX_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x80)|value<<7)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x80) >> 7
}
func (o *TWIM_Type) SetSHORTS_LASTTX_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}
func (o *TWIM_Type) SetSHORTS_LASTTX_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetSHORTS_LASTRX_STARTTX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x400)|value<<10)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_STARTTX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x400) >> 10
}
func (o *TWIM_Type) SetSHORTS_LASTRX_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x800)|value<<11)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x800) >> 11
}
func (o *TWIM_Type) SetSHORTS_LASTRX_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1000)|value<<12)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x1000) >> 12
}

// TWIM.INTEN: Enable or disable interrupt
func (o *TWIM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTEN_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTEN_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTEN_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTEN_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTEN_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTEN_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}

// TWIM.INTENSET: Enable interrupt
func (o *TWIM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTENSET_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTENSET_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTENSET_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTENSET_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTENSET_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTENSET_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}

// TWIM.INTENCLR: Disable interrupt
func (o *TWIM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTENCLR_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTENCLR_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTENCLR_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTENCLR_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTENCLR_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTENCLR_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}

// TWIM.ERRORSRC: Error source
func (o *TWIM_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWIM_Type) SetERRORSRC_ANACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetERRORSRC_ANACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWIM_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}

// TWIM.ENABLE: Enable TWIM
func (o *TWIM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWIM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWIM.FREQUENCY: TWI frequency. Accuracy depends on the HFCLK source selected.
func (o *TWIM_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *TWIM_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// TWIM.ADDRESS: Address used in the TWI transfer
func (o *TWIM_Type) SetADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDRESS.Reg, volatile.LoadUint32(&o.ADDRESS.Reg)&^(0x7f)|value)
}
func (o *TWIM_Type) GetADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDRESS.Reg) & 0x7f
}

type TWIM_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWIM_PSEL.SCL: Pin select for SCL signal
func (o *TWIM_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWIM_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWIM_PSEL_Type) SetSCL_PORT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x20)|value<<5)
}
func (o *TWIM_PSEL_Type) GetSCL_PORT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x20) >> 5
}
func (o *TWIM_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWIM_PSEL.SDA: Pin select for SDA signal
func (o *TWIM_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWIM_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWIM_PSEL_Type) SetSDA_PORT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x20)|value<<5)
}
func (o *TWIM_PSEL_Type) GetSDA_PORT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x20) >> 5
}
func (o *TWIM_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

type TWIM_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// TWIM_RXD.PTR: Data pointer
func (o *TWIM_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIM_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIM_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *TWIM_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *TWIM_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// TWIM_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *TWIM_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *TWIM_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// TWIM_RXD.LIST: EasyDMA list type
func (o *TWIM_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *TWIM_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

type TWIM_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// TWIM_TXD.PTR: Data pointer
func (o *TWIM_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIM_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIM_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *TWIM_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *TWIM_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// TWIM_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *TWIM_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *TWIM_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// TWIM_TXD.LIST: EasyDMA list type
func (o *TWIM_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *TWIM_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

// I2C compatible Two-Wire Slave Interface with EasyDMA 0
type TWIS_Type struct {
	_                   [20]byte
	TASKS_STOP          volatile.Register32 // 0x14
	_                   [4]byte
	TASKS_SUSPEND       volatile.Register32 // 0x1C
	TASKS_RESUME        volatile.Register32 // 0x20
	_                   [12]byte
	TASKS_PREPARERX     volatile.Register32 // 0x30
	TASKS_PREPARETX     volatile.Register32 // 0x34
	_                   [92]byte
	SUBSCRIBE_STOP      volatile.Register32 // 0x94
	_                   [4]byte
	SUBSCRIBE_SUSPEND   volatile.Register32 // 0x9C
	SUBSCRIBE_RESUME    volatile.Register32 // 0xA0
	_                   [12]byte
	SUBSCRIBE_PREPARERX volatile.Register32 // 0xB0
	SUBSCRIBE_PREPARETX volatile.Register32 // 0xB4
	_                   [76]byte
	EVENTS_STOPPED      volatile.Register32 // 0x104
	_                   [28]byte
	EVENTS_ERROR        volatile.Register32 // 0x124
	_                   [36]byte
	EVENTS_RXSTARTED    volatile.Register32 // 0x14C
	EVENTS_TXSTARTED    volatile.Register32 // 0x150
	_                   [16]byte
	EVENTS_WRITE        volatile.Register32 // 0x164
	EVENTS_READ         volatile.Register32 // 0x168
	_                   [24]byte
	PUBLISH_STOPPED     volatile.Register32 // 0x184
	_                   [28]byte
	PUBLISH_ERROR       volatile.Register32 // 0x1A4
	_                   [36]byte
	PUBLISH_RXSTARTED   volatile.Register32 // 0x1CC
	PUBLISH_TXSTARTED   volatile.Register32 // 0x1D0
	_                   [16]byte
	PUBLISH_WRITE       volatile.Register32 // 0x1E4
	PUBLISH_READ        volatile.Register32 // 0x1E8
	_                   [20]byte
	SHORTS              volatile.Register32 // 0x200
	_                   [252]byte
	INTEN               volatile.Register32 // 0x300
	INTENSET            volatile.Register32 // 0x304
	INTENCLR            volatile.Register32 // 0x308
	_                   [452]byte
	ERRORSRC            volatile.Register32 // 0x4D0
	MATCH               volatile.Register32 // 0x4D4
	_                   [40]byte
	ENABLE              volatile.Register32 // 0x500
	_                   [4]byte
	PSEL                TWIS_PSEL_Type // 0x508
	_                   [36]byte
	RXD                 TWIS_RXD_Type // 0x534
	TXD                 TWIS_TXD_Type // 0x544
	_                   [52]byte
	ADDRESS             [2]volatile.Register32 // 0x588
	_                   [4]byte
	CONFIG              volatile.Register32 // 0x594
	_                   [40]byte
	ORC                 volatile.Register32 // 0x5C0
}

// TWIS.TASKS_STOP: Stop TWI transaction
func (o *TWIS_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TWIS.TASKS_SUSPEND: Suspend TWI transaction
func (o *TWIS_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// TWIS.TASKS_RESUME: Resume TWI transaction
func (o *TWIS_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// TWIS.TASKS_PREPARERX: Prepare the TWI slave to respond to a write command
func (o *TWIS_Type) SetTASKS_PREPARERX(value uint32) {
	volatile.StoreUint32(&o.TASKS_PREPARERX.Reg, volatile.LoadUint32(&o.TASKS_PREPARERX.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_PREPARERX() uint32 {
	return volatile.LoadUint32(&o.TASKS_PREPARERX.Reg) & 0x1
}

// TWIS.TASKS_PREPARETX: Prepare the TWI slave to respond to a read command
func (o *TWIS_Type) SetTASKS_PREPARETX(value uint32) {
	volatile.StoreUint32(&o.TASKS_PREPARETX.Reg, volatile.LoadUint32(&o.TASKS_PREPARETX.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_PREPARETX() uint32 {
	return volatile.LoadUint32(&o.TASKS_PREPARETX.Reg) & 0x1
}

// TWIS.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *TWIS_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *TWIS_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// TWIS.SUBSCRIBE_SUSPEND: Subscribe configuration for task SUSPEND
func (o *TWIS_Type) SetSUBSCRIBE_SUSPEND_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SUSPEND.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetSUBSCRIBE_SUSPEND_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg) & 0xff
}
func (o *TWIS_Type) SetSUBSCRIBE_SUSPEND_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SUSPEND.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetSUBSCRIBE_SUSPEND_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SUSPEND.Reg) & 0x80000000) >> 31
}

// TWIS.SUBSCRIBE_RESUME: Subscribe configuration for task RESUME
func (o *TWIS_Type) SetSUBSCRIBE_RESUME_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RESUME.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetSUBSCRIBE_RESUME_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg) & 0xff
}
func (o *TWIS_Type) SetSUBSCRIBE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RESUME.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetSUBSCRIBE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_RESUME.Reg) & 0x80000000) >> 31
}

// TWIS.SUBSCRIBE_PREPARERX: Subscribe configuration for task PREPARERX
func (o *TWIS_Type) SetSUBSCRIBE_PREPARERX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_PREPARERX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_PREPARERX.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetSUBSCRIBE_PREPARERX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_PREPARERX.Reg) & 0xff
}
func (o *TWIS_Type) SetSUBSCRIBE_PREPARERX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_PREPARERX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_PREPARERX.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetSUBSCRIBE_PREPARERX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_PREPARERX.Reg) & 0x80000000) >> 31
}

// TWIS.SUBSCRIBE_PREPARETX: Subscribe configuration for task PREPARETX
func (o *TWIS_Type) SetSUBSCRIBE_PREPARETX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_PREPARETX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_PREPARETX.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetSUBSCRIBE_PREPARETX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_PREPARETX.Reg) & 0xff
}
func (o *TWIS_Type) SetSUBSCRIBE_PREPARETX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_PREPARETX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_PREPARETX.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetSUBSCRIBE_PREPARETX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_PREPARETX.Reg) & 0x80000000) >> 31
}

// TWIS.EVENTS_STOPPED: TWI stopped
func (o *TWIS_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// TWIS.EVENTS_ERROR: TWI error
func (o *TWIS_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// TWIS.EVENTS_RXSTARTED: Receive sequence started
func (o *TWIS_Type) SetEVENTS_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_RXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg) & 0x1
}

// TWIS.EVENTS_TXSTARTED: Transmit sequence started
func (o *TWIS_Type) SetEVENTS_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_TXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg) & 0x1
}

// TWIS.EVENTS_WRITE: Write command received
func (o *TWIS_Type) SetEVENTS_WRITE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_WRITE.Reg, volatile.LoadUint32(&o.EVENTS_WRITE.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_WRITE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_WRITE.Reg) & 0x1
}

// TWIS.EVENTS_READ: Read command received
func (o *TWIS_Type) SetEVENTS_READ(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READ.Reg, volatile.LoadUint32(&o.EVENTS_READ.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_READ() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READ.Reg) & 0x1
}

// TWIS.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *TWIS_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *TWIS_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// TWIS.PUBLISH_ERROR: Publish configuration for event ERROR
func (o *TWIS_Type) SetPUBLISH_ERROR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetPUBLISH_ERROR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0xff
}
func (o *TWIS_Type) SetPUBLISH_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetPUBLISH_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0x80000000) >> 31
}

// TWIS.PUBLISH_RXSTARTED: Publish configuration for event RXSTARTED
func (o *TWIS_Type) SetPUBLISH_RXSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetPUBLISH_RXSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg) & 0xff
}
func (o *TWIS_Type) SetPUBLISH_RXSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetPUBLISH_RXSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg) & 0x80000000) >> 31
}

// TWIS.PUBLISH_TXSTARTED: Publish configuration for event TXSTARTED
func (o *TWIS_Type) SetPUBLISH_TXSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetPUBLISH_TXSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg) & 0xff
}
func (o *TWIS_Type) SetPUBLISH_TXSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetPUBLISH_TXSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg) & 0x80000000) >> 31
}

// TWIS.PUBLISH_WRITE: Publish configuration for event WRITE
func (o *TWIS_Type) SetPUBLISH_WRITE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_WRITE.Reg, volatile.LoadUint32(&o.PUBLISH_WRITE.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetPUBLISH_WRITE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_WRITE.Reg) & 0xff
}
func (o *TWIS_Type) SetPUBLISH_WRITE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_WRITE.Reg, volatile.LoadUint32(&o.PUBLISH_WRITE.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetPUBLISH_WRITE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_WRITE.Reg) & 0x80000000) >> 31
}

// TWIS.PUBLISH_READ: Publish configuration for event READ
func (o *TWIS_Type) SetPUBLISH_READ_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READ.Reg, volatile.LoadUint32(&o.PUBLISH_READ.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetPUBLISH_READ_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_READ.Reg) & 0xff
}
func (o *TWIS_Type) SetPUBLISH_READ_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READ.Reg, volatile.LoadUint32(&o.PUBLISH_READ.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_Type) GetPUBLISH_READ_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_READ.Reg) & 0x80000000) >> 31
}

// TWIS.SHORTS: Shortcuts between local events and tasks
func (o *TWIS_Type) SetSHORTS_WRITE_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2000)|value<<13)
}
func (o *TWIS_Type) GetSHORTS_WRITE_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2000) >> 13
}
func (o *TWIS_Type) SetSHORTS_READ_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4000)|value<<14)
}
func (o *TWIS_Type) GetSHORTS_READ_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4000) >> 14
}

// TWIS.INTEN: Enable or disable interrupt
func (o *TWIS_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTEN_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTEN_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTEN_READ(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTEN_READ() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000000) >> 26
}

// TWIS.INTENSET: Enable interrupt
func (o *TWIS_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTENSET_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTENSET_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTENSET_READ(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTENSET_READ() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000000) >> 26
}

// TWIS.INTENCLR: Disable interrupt
func (o *TWIS_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTENCLR_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTENCLR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTENCLR_READ(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTENCLR_READ() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000000) >> 26
}

// TWIS.ERRORSRC: Error source
func (o *TWIS_Type) SetERRORSRC_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetERRORSRC_OVERFLOW() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWIS_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWIS_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *TWIS_Type) SetERRORSRC_OVERREAD(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *TWIS_Type) GetERRORSRC_OVERREAD() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// TWIS.MATCH: Status register indicating which address had a match
func (o *TWIS_Type) SetMATCH(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetMATCH() uint32 {
	return volatile.LoadUint32(&o.MATCH.Reg) & 0x1
}

// TWIS.ENABLE: Enable TWIS
func (o *TWIS_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWIS_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWIS.ADDRESS: Description collection: TWI slave address n
func (o *TWIS_Type) SetADDRESS(idx int, value uint32) {
	volatile.StoreUint32(&o.ADDRESS[idx].Reg, volatile.LoadUint32(&o.ADDRESS[idx].Reg)&^(0x7f)|value)
}
func (o *TWIS_Type) GetADDRESS(idx int) uint32 {
	return volatile.LoadUint32(&o.ADDRESS[idx].Reg) & 0x7f
}

// TWIS.CONFIG: Configuration register for the address match mechanism
func (o *TWIS_Type) SetCONFIG_ADDRESS0(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetCONFIG_ADDRESS0() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *TWIS_Type) SetCONFIG_ADDRESS1(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetCONFIG_ADDRESS1() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}

// TWIS.ORC: Over-read character. Character sent out in case of an over-read of the transmit buffer.
func (o *TWIS_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

type TWIS_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWIS_PSEL.SCL: Pin select for SCL signal
func (o *TWIS_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWIS_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWIS_PSEL_Type) SetSCL_PORT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x20)|value<<5)
}
func (o *TWIS_PSEL_Type) GetSCL_PORT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x20) >> 5
}
func (o *TWIS_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWIS_PSEL.SDA: Pin select for SDA signal
func (o *TWIS_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWIS_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWIS_PSEL_Type) SetSDA_PORT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x20)|value<<5)
}
func (o *TWIS_PSEL_Type) GetSDA_PORT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x20) >> 5
}
func (o *TWIS_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

type TWIS_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// TWIS_RXD.PTR: RXD Data pointer
func (o *TWIS_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIS_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIS_RXD.MAXCNT: Maximum number of bytes in RXD buffer
func (o *TWIS_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *TWIS_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// TWIS_RXD.AMOUNT: Number of bytes transferred in the last RXD transaction
func (o *TWIS_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *TWIS_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// TWIS_RXD.LIST: EasyDMA list type
func (o *TWIS_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *TWIS_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

type TWIS_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// TWIS_TXD.PTR: TXD Data pointer
func (o *TWIS_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIS_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIS_TXD.MAXCNT: Maximum number of bytes in TXD buffer
func (o *TWIS_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *TWIS_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// TWIS_TXD.AMOUNT: Number of bytes transferred in the last TXD transaction
func (o *TWIS_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *TWIS_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// TWIS_TXD.LIST: EasyDMA list type
func (o *TWIS_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *TWIS_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// UART with EasyDMA 0
type UARTE_Type struct {
	TASKS_STARTRX     volatile.Register32 // 0x0
	TASKS_STOPRX      volatile.Register32 // 0x4
	TASKS_STARTTX     volatile.Register32 // 0x8
	TASKS_STOPTX      volatile.Register32 // 0xC
	_                 [28]byte
	TASKS_FLUSHRX     volatile.Register32 // 0x2C
	_                 [80]byte
	SUBSCRIBE_STARTRX volatile.Register32 // 0x80
	SUBSCRIBE_STOPRX  volatile.Register32 // 0x84
	SUBSCRIBE_STARTTX volatile.Register32 // 0x88
	SUBSCRIBE_STOPTX  volatile.Register32 // 0x8C
	_                 [28]byte
	SUBSCRIBE_FLUSHRX volatile.Register32 // 0xAC
	_                 [80]byte
	EVENTS_CTS        volatile.Register32 // 0x100
	EVENTS_NCTS       volatile.Register32 // 0x104
	EVENTS_RXDRDY     volatile.Register32 // 0x108
	_                 [4]byte
	EVENTS_ENDRX      volatile.Register32 // 0x110
	_                 [8]byte
	EVENTS_TXDRDY     volatile.Register32 // 0x11C
	EVENTS_ENDTX      volatile.Register32 // 0x120
	EVENTS_ERROR      volatile.Register32 // 0x124
	_                 [28]byte
	EVENTS_RXTO       volatile.Register32 // 0x144
	_                 [4]byte
	EVENTS_RXSTARTED  volatile.Register32 // 0x14C
	EVENTS_TXSTARTED  volatile.Register32 // 0x150
	_                 [4]byte
	EVENTS_TXSTOPPED  volatile.Register32 // 0x158
	_                 [36]byte
	PUBLISH_CTS       volatile.Register32 // 0x180
	PUBLISH_NCTS      volatile.Register32 // 0x184
	PUBLISH_RXDRDY    volatile.Register32 // 0x188
	_                 [4]byte
	PUBLISH_ENDRX     volatile.Register32 // 0x190
	_                 [8]byte
	PUBLISH_TXDRDY    volatile.Register32 // 0x19C
	PUBLISH_ENDTX     volatile.Register32 // 0x1A0
	PUBLISH_ERROR     volatile.Register32 // 0x1A4
	_                 [28]byte
	PUBLISH_RXTO      volatile.Register32 // 0x1C4
	_                 [4]byte
	PUBLISH_RXSTARTED volatile.Register32 // 0x1CC
	PUBLISH_TXSTARTED volatile.Register32 // 0x1D0
	_                 [4]byte
	PUBLISH_TXSTOPPED volatile.Register32 // 0x1D8
	_                 [36]byte
	SHORTS            volatile.Register32 // 0x200
	_                 [252]byte
	INTEN             volatile.Register32 // 0x300
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
	_                 [372]byte
	ERRORSRC          volatile.Register32 // 0x480
	_                 [124]byte
	ENABLE            volatile.Register32 // 0x500
	_                 [4]byte
	PSEL              UARTE_PSEL_Type // 0x508
	_                 [12]byte
	BAUDRATE          volatile.Register32 // 0x524
	_                 [12]byte
	RXD               UARTE_RXD_Type // 0x534
	_                 [4]byte
	TXD               UARTE_TXD_Type // 0x544
	_                 [28]byte
	CONFIG            volatile.Register32 // 0x56C
}

// UARTE.TASKS_STARTRX: Start UART receiver
func (o *UARTE_Type) SetTASKS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTRX.Reg, volatile.LoadUint32(&o.TASKS_STARTRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STARTRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTRX.Reg) & 0x1
}

// UARTE.TASKS_STOPRX: Stop UART receiver
func (o *UARTE_Type) SetTASKS_STOPRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPRX.Reg, volatile.LoadUint32(&o.TASKS_STOPRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STOPRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPRX.Reg) & 0x1
}

// UARTE.TASKS_STARTTX: Start UART transmitter
func (o *UARTE_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// UARTE.TASKS_STOPTX: Stop UART transmitter
func (o *UARTE_Type) SetTASKS_STOPTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPTX.Reg, volatile.LoadUint32(&o.TASKS_STOPTX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STOPTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPTX.Reg) & 0x1
}

// UARTE.TASKS_FLUSHRX: Flush RX FIFO into RX buffer
func (o *UARTE_Type) SetTASKS_FLUSHRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_FLUSHRX.Reg, volatile.LoadUint32(&o.TASKS_FLUSHRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_FLUSHRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_FLUSHRX.Reg) & 0x1
}

// UARTE.SUBSCRIBE_STARTRX: Subscribe configuration for task STARTRX
func (o *UARTE_Type) SetSUBSCRIBE_STARTRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetSUBSCRIBE_STARTRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg) & 0xff
}
func (o *UARTE_Type) SetSUBSCRIBE_STARTRX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetSUBSCRIBE_STARTRX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTRX.Reg) & 0x80000000) >> 31
}

// UARTE.SUBSCRIBE_STOPRX: Subscribe configuration for task STOPRX
func (o *UARTE_Type) SetSUBSCRIBE_STOPRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOPRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOPRX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetSUBSCRIBE_STOPRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOPRX.Reg) & 0xff
}
func (o *UARTE_Type) SetSUBSCRIBE_STOPRX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOPRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOPRX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetSUBSCRIBE_STOPRX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOPRX.Reg) & 0x80000000) >> 31
}

// UARTE.SUBSCRIBE_STARTTX: Subscribe configuration for task STARTTX
func (o *UARTE_Type) SetSUBSCRIBE_STARTTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetSUBSCRIBE_STARTTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg) & 0xff
}
func (o *UARTE_Type) SetSUBSCRIBE_STARTTX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetSUBSCRIBE_STARTTX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg) & 0x80000000) >> 31
}

// UARTE.SUBSCRIBE_STOPTX: Subscribe configuration for task STOPTX
func (o *UARTE_Type) SetSUBSCRIBE_STOPTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOPTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOPTX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetSUBSCRIBE_STOPTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOPTX.Reg) & 0xff
}
func (o *UARTE_Type) SetSUBSCRIBE_STOPTX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOPTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOPTX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetSUBSCRIBE_STOPTX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOPTX.Reg) & 0x80000000) >> 31
}

// UARTE.SUBSCRIBE_FLUSHRX: Subscribe configuration for task FLUSHRX
func (o *UARTE_Type) SetSUBSCRIBE_FLUSHRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_FLUSHRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_FLUSHRX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetSUBSCRIBE_FLUSHRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_FLUSHRX.Reg) & 0xff
}
func (o *UARTE_Type) SetSUBSCRIBE_FLUSHRX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_FLUSHRX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_FLUSHRX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetSUBSCRIBE_FLUSHRX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_FLUSHRX.Reg) & 0x80000000) >> 31
}

// UARTE.EVENTS_CTS: CTS is activated (set low). Clear To Send.
func (o *UARTE_Type) SetEVENTS_CTS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTS.Reg, volatile.LoadUint32(&o.EVENTS_CTS.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_CTS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTS.Reg) & 0x1
}

// UARTE.EVENTS_NCTS: CTS is deactivated (set high). Not Clear To Send.
func (o *UARTE_Type) SetEVENTS_NCTS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_NCTS.Reg, volatile.LoadUint32(&o.EVENTS_NCTS.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_NCTS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_NCTS.Reg) & 0x1
}

// UARTE.EVENTS_RXDRDY: Data received in RXD (but potentially not yet transferred to Data RAM)
func (o *UARTE_Type) SetEVENTS_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXDRDY.Reg, volatile.LoadUint32(&o.EVENTS_RXDRDY.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_RXDRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXDRDY.Reg) & 0x1
}

// UARTE.EVENTS_ENDRX: Receive buffer is filled up
func (o *UARTE_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// UARTE.EVENTS_TXDRDY: Data sent from TXD
func (o *UARTE_Type) SetEVENTS_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXDRDY.Reg, volatile.LoadUint32(&o.EVENTS_TXDRDY.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_TXDRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXDRDY.Reg) & 0x1
}

// UARTE.EVENTS_ENDTX: Last TX byte transmitted
func (o *UARTE_Type) SetEVENTS_ENDTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDTX.Reg, volatile.LoadUint32(&o.EVENTS_ENDTX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_ENDTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDTX.Reg) & 0x1
}

// UARTE.EVENTS_ERROR: Error detected
func (o *UARTE_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// UARTE.EVENTS_RXTO: Receiver timeout
func (o *UARTE_Type) SetEVENTS_RXTO(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXTO.Reg, volatile.LoadUint32(&o.EVENTS_RXTO.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_RXTO() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXTO.Reg) & 0x1
}

// UARTE.EVENTS_RXSTARTED: UART receiver has started
func (o *UARTE_Type) SetEVENTS_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_RXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg) & 0x1
}

// UARTE.EVENTS_TXSTARTED: UART transmitter has started
func (o *UARTE_Type) SetEVENTS_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_TXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg) & 0x1
}

// UARTE.EVENTS_TXSTOPPED: Transmitter stopped
func (o *UARTE_Type) SetEVENTS_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTOPPED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTOPPED.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_TXSTOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTOPPED.Reg) & 0x1
}

// UARTE.PUBLISH_CTS: Publish configuration for event CTS
func (o *UARTE_Type) SetPUBLISH_CTS_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CTS.Reg, volatile.LoadUint32(&o.PUBLISH_CTS.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_CTS_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_CTS.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_CTS_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CTS.Reg, volatile.LoadUint32(&o.PUBLISH_CTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_CTS_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_CTS.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_NCTS: Publish configuration for event NCTS
func (o *UARTE_Type) SetPUBLISH_NCTS_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_NCTS.Reg, volatile.LoadUint32(&o.PUBLISH_NCTS.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_NCTS_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_NCTS.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_NCTS_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_NCTS.Reg, volatile.LoadUint32(&o.PUBLISH_NCTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_NCTS_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_NCTS.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_RXDRDY: Publish configuration for event RXDRDY
func (o *UARTE_Type) SetPUBLISH_RXDRDY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXDRDY.Reg, volatile.LoadUint32(&o.PUBLISH_RXDRDY.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_RXDRDY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXDRDY.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_RXDRDY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXDRDY.Reg, volatile.LoadUint32(&o.PUBLISH_RXDRDY.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_RXDRDY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXDRDY.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_ENDRX: Publish configuration for event ENDRX
func (o *UARTE_Type) SetPUBLISH_ENDRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_ENDRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_ENDRX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_ENDRX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_TXDRDY: Publish configuration for event TXDRDY
func (o *UARTE_Type) SetPUBLISH_TXDRDY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXDRDY.Reg, volatile.LoadUint32(&o.PUBLISH_TXDRDY.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_TXDRDY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXDRDY.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_TXDRDY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXDRDY.Reg, volatile.LoadUint32(&o.PUBLISH_TXDRDY.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_TXDRDY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXDRDY.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_ENDTX: Publish configuration for event ENDTX
func (o *UARTE_Type) SetPUBLISH_ENDTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDTX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_ENDTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_ENDTX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDTX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_ENDTX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_ERROR: Publish configuration for event ERROR
func (o *UARTE_Type) SetPUBLISH_ERROR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_ERROR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_RXTO: Publish configuration for event RXTO
func (o *UARTE_Type) SetPUBLISH_RXTO_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXTO.Reg, volatile.LoadUint32(&o.PUBLISH_RXTO.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_RXTO_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXTO.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_RXTO_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXTO.Reg, volatile.LoadUint32(&o.PUBLISH_RXTO.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_RXTO_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXTO.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_RXSTARTED: Publish configuration for event RXSTARTED
func (o *UARTE_Type) SetPUBLISH_RXSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_RXSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_RXSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_RXSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXSTARTED.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_TXSTARTED: Publish configuration for event TXSTARTED
func (o *UARTE_Type) SetPUBLISH_TXSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_TXSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_TXSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_TXSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXSTARTED.Reg) & 0x80000000) >> 31
}

// UARTE.PUBLISH_TXSTOPPED: Publish configuration for event TXSTOPPED
func (o *UARTE_Type) SetPUBLISH_TXSTOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTOPPED.Reg)&^(0xff)|value)
}
func (o *UARTE_Type) GetPUBLISH_TXSTOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXSTOPPED.Reg) & 0xff
}
func (o *UARTE_Type) SetPUBLISH_TXSTOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXSTOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_TXSTOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_Type) GetPUBLISH_TXSTOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXSTOPPED.Reg) & 0x80000000) >> 31
}

// UARTE.SHORTS: Shortcuts between local events and tasks
func (o *UARTE_Type) SetSHORTS_ENDRX_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_Type) GetSHORTS_ENDRX_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *UARTE_Type) SetSHORTS_ENDRX_STOPRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *UARTE_Type) GetSHORTS_ENDRX_STOPRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}

// UARTE.INTEN: Enable or disable interrupt
func (o *UARTE_Type) SetINTEN_CTS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTEN_CTS() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *UARTE_Type) SetINTEN_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTEN_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTEN_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTEN_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTEN_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTEN_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTEN_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTEN_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTEN_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTEN_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTEN_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTEN_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTEN_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTEN_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400000) >> 22
}

// UARTE.INTENSET: Enable interrupt
func (o *UARTE_Type) SetINTENSET_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTENSET_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *UARTE_Type) SetINTENSET_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTENSET_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTENSET_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTENSET_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTENSET_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTENSET_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTENSET_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTENSET_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTENSET_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTENSET_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400000) >> 22
}

// UARTE.INTENCLR: Disable interrupt
func (o *UARTE_Type) SetINTENCLR_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTENCLR_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *UARTE_Type) SetINTENCLR_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTENCLR_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTENCLR_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTENCLR_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTENCLR_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTENCLR_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTENCLR_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTENCLR_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTENCLR_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTENCLR_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400000) >> 22
}

// UARTE.ERRORSRC: Error source Note : this register is read / write one to clear.
func (o *UARTE_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *UARTE_Type) SetERRORSRC_PARITY(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetERRORSRC_PARITY() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetERRORSRC_FRAMING(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetERRORSRC_FRAMING() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetERRORSRC_BREAK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *UARTE_Type) GetERRORSRC_BREAK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// UARTE.ENABLE: Enable UART
func (o *UARTE_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *UARTE_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// UARTE.BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
func (o *UARTE_Type) SetBAUDRATE(value uint32) {
	volatile.StoreUint32(&o.BAUDRATE.Reg, value)
}
func (o *UARTE_Type) GetBAUDRATE() uint32 {
	return volatile.LoadUint32(&o.BAUDRATE.Reg)
}

// UARTE.CONFIG: Configuration of parity and hardware flow control
func (o *UARTE_Type) SetCONFIG_HWFC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetCONFIG_HWFC() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *UARTE_Type) SetCONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xe)|value<<1)
}
func (o *UARTE_Type) GetCONFIG_PARITY() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xe) >> 1
}
func (o *UARTE_Type) SetCONFIG_STOP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetCONFIG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetCONFIG_PARITYTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetCONFIG_PARITYTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}

type UARTE_PSEL_Type struct {
	RTS volatile.Register32 // 0x508
	TXD volatile.Register32 // 0x50C
	CTS volatile.Register32 // 0x510
	RXD volatile.Register32 // 0x514
}

// UARTE_PSEL.RTS: Pin select for RTS signal
func (o *UARTE_PSEL_Type) SetRTS_PIN(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetRTS_PIN() uint32 {
	return volatile.LoadUint32(&o.RTS.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetRTS_PORT(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_PSEL_Type) GetRTS_PORT() uint32 {
	return (volatile.LoadUint32(&o.RTS.Reg) & 0x20) >> 5
}
func (o *UARTE_PSEL_Type) SetRTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetRTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RTS.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.TXD: Pin select for TXD signal
func (o *UARTE_PSEL_Type) SetTXD_PIN(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetTXD_PIN() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetTXD_PORT(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_PSEL_Type) GetTXD_PORT() uint32 {
	return (volatile.LoadUint32(&o.TXD.Reg) & 0x20) >> 5
}
func (o *UARTE_PSEL_Type) SetTXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetTXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TXD.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.CTS: Pin select for CTS signal
func (o *UARTE_PSEL_Type) SetCTS_PIN(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetCTS_PIN() uint32 {
	return volatile.LoadUint32(&o.CTS.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetCTS_PORT(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_PSEL_Type) GetCTS_PORT() uint32 {
	return (volatile.LoadUint32(&o.CTS.Reg) & 0x20) >> 5
}
func (o *UARTE_PSEL_Type) SetCTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetCTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CTS.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.RXD: Pin select for RXD signal
func (o *UARTE_PSEL_Type) SetRXD_PIN(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetRXD_PIN() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetRXD_PORT(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_PSEL_Type) GetRXD_PORT() uint32 {
	return (volatile.LoadUint32(&o.RXD.Reg) & 0x20) >> 5
}
func (o *UARTE_PSEL_Type) SetRXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetRXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RXD.Reg) & 0x80000000) >> 31
}

type UARTE_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
}

// UARTE_RXD.PTR: Data pointer
func (o *UARTE_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *UARTE_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// UARTE_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *UARTE_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *UARTE_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// UARTE_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *UARTE_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *UARTE_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

type UARTE_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
}

// UARTE_TXD.PTR: Data pointer
func (o *UARTE_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *UARTE_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// UARTE_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *UARTE_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0xffff)|value)
}
func (o *UARTE_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0xffff
}

// UARTE_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *UARTE_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *UARTE_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// GPIO Tasks and Events 0
type GPIOTE_Type struct {
	TASKS_OUT     [8]volatile.Register32 // 0x0
	_             [16]byte
	TASKS_SET     [8]volatile.Register32 // 0x30
	_             [16]byte
	TASKS_CLR     [8]volatile.Register32 // 0x60
	SUBSCRIBE_OUT [8]volatile.Register32 // 0x80
	_             [16]byte
	SUBSCRIBE_SET [8]volatile.Register32 // 0xB0
	_             [16]byte
	SUBSCRIBE_CLR [8]volatile.Register32 // 0xE0
	EVENTS_IN     [8]volatile.Register32 // 0x100
	_             [92]byte
	EVENTS_PORT   volatile.Register32    // 0x17C
	PUBLISH_IN    [8]volatile.Register32 // 0x180
	_             [92]byte
	PUBLISH_PORT  volatile.Register32 // 0x1FC
	_             [260]byte
	INTENSET      volatile.Register32 // 0x304
	INTENCLR      volatile.Register32 // 0x308
	_             [504]byte
	LATENCY       volatile.Register32 // 0x504
	_             [8]byte
	CONFIG        [8]volatile.Register32 // 0x510
}

// GPIOTE.TASKS_OUT: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
func (o *GPIOTE_Type) SetTASKS_OUT(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_OUT[idx].Reg, volatile.LoadUint32(&o.TASKS_OUT[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetTASKS_OUT(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_OUT[idx].Reg) & 0x1
}

// GPIOTE.TASKS_SET: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
func (o *GPIOTE_Type) SetTASKS_SET(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_SET[idx].Reg, volatile.LoadUint32(&o.TASKS_SET[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetTASKS_SET(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_SET[idx].Reg) & 0x1
}

// GPIOTE.TASKS_CLR: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
func (o *GPIOTE_Type) SetTASKS_CLR(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_CLR[idx].Reg, volatile.LoadUint32(&o.TASKS_CLR[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetTASKS_CLR(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_CLR[idx].Reg) & 0x1
}

// GPIOTE.SUBSCRIBE_OUT: Description collection: Subscribe configuration for task OUT[n]
func (o *GPIOTE_Type) SetSUBSCRIBE_OUT_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_OUT[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_OUT[idx].Reg)&^(0xff)|value)
}
func (o *GPIOTE_Type) GetSUBSCRIBE_OUT_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_OUT[idx].Reg) & 0xff
}
func (o *GPIOTE_Type) SetSUBSCRIBE_OUT_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_OUT[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_OUT[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetSUBSCRIBE_OUT_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_OUT[idx].Reg) & 0x80000000) >> 31
}

// GPIOTE.SUBSCRIBE_SET: Description collection: Subscribe configuration for task SET[n]
func (o *GPIOTE_Type) SetSUBSCRIBE_SET_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SET[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_SET[idx].Reg)&^(0xff)|value)
}
func (o *GPIOTE_Type) GetSUBSCRIBE_SET_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SET[idx].Reg) & 0xff
}
func (o *GPIOTE_Type) SetSUBSCRIBE_SET_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SET[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_SET[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetSUBSCRIBE_SET_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SET[idx].Reg) & 0x80000000) >> 31
}

// GPIOTE.SUBSCRIBE_CLR: Description collection: Subscribe configuration for task CLR[n]
func (o *GPIOTE_Type) SetSUBSCRIBE_CLR_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CLR[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_CLR[idx].Reg)&^(0xff)|value)
}
func (o *GPIOTE_Type) GetSUBSCRIBE_CLR_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CLR[idx].Reg) & 0xff
}
func (o *GPIOTE_Type) SetSUBSCRIBE_CLR_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CLR[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_CLR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetSUBSCRIBE_CLR_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CLR[idx].Reg) & 0x80000000) >> 31
}

// GPIOTE.EVENTS_IN: Description collection: Event generated from pin specified in CONFIG[n].PSEL
func (o *GPIOTE_Type) SetEVENTS_IN(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_IN[idx].Reg, volatile.LoadUint32(&o.EVENTS_IN[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetEVENTS_IN(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_IN[idx].Reg) & 0x1
}

// GPIOTE.EVENTS_PORT: Event generated from multiple input GPIO pins with SENSE mechanism enabled
func (o *GPIOTE_Type) SetEVENTS_PORT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_PORT.Reg, volatile.LoadUint32(&o.EVENTS_PORT.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetEVENTS_PORT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_PORT.Reg) & 0x1
}

// GPIOTE.PUBLISH_IN: Description collection: Publish configuration for event IN[n]
func (o *GPIOTE_Type) SetPUBLISH_IN_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_IN[idx].Reg, volatile.LoadUint32(&o.PUBLISH_IN[idx].Reg)&^(0xff)|value)
}
func (o *GPIOTE_Type) GetPUBLISH_IN_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_IN[idx].Reg) & 0xff
}
func (o *GPIOTE_Type) SetPUBLISH_IN_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_IN[idx].Reg, volatile.LoadUint32(&o.PUBLISH_IN[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetPUBLISH_IN_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_IN[idx].Reg) & 0x80000000) >> 31
}

// GPIOTE.PUBLISH_PORT: Publish configuration for event PORT
func (o *GPIOTE_Type) SetPUBLISH_PORT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_PORT.Reg, volatile.LoadUint32(&o.PUBLISH_PORT.Reg)&^(0xff)|value)
}
func (o *GPIOTE_Type) GetPUBLISH_PORT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_PORT.Reg) & 0xff
}
func (o *GPIOTE_Type) SetPUBLISH_PORT_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_PORT.Reg, volatile.LoadUint32(&o.PUBLISH_PORT.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetPUBLISH_PORT_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_PORT.Reg) & 0x80000000) >> 31
}

// GPIOTE.INTENSET: Enable interrupt
func (o *GPIOTE_Type) SetINTENSET_IN0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetINTENSET_IN0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *GPIOTE_Type) SetINTENSET_IN1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIOTE_Type) GetINTENSET_IN1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *GPIOTE_Type) SetINTENSET_IN2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIOTE_Type) GetINTENSET_IN2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *GPIOTE_Type) SetINTENSET_IN3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIOTE_Type) GetINTENSET_IN3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *GPIOTE_Type) SetINTENSET_IN4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIOTE_Type) GetINTENSET_IN4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *GPIOTE_Type) SetINTENSET_IN5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIOTE_Type) GetINTENSET_IN5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *GPIOTE_Type) SetINTENSET_IN6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIOTE_Type) GetINTENSET_IN6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *GPIOTE_Type) SetINTENSET_IN7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIOTE_Type) GetINTENSET_IN7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *GPIOTE_Type) SetINTENSET_PORT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetINTENSET_PORT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000000) >> 31
}

// GPIOTE.INTENCLR: Disable interrupt
func (o *GPIOTE_Type) SetINTENCLR_IN0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetINTENCLR_IN0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *GPIOTE_Type) SetINTENCLR_IN1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIOTE_Type) GetINTENCLR_IN1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *GPIOTE_Type) SetINTENCLR_IN2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIOTE_Type) GetINTENCLR_IN2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *GPIOTE_Type) SetINTENCLR_IN3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIOTE_Type) GetINTENCLR_IN3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *GPIOTE_Type) SetINTENCLR_IN4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIOTE_Type) GetINTENCLR_IN4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *GPIOTE_Type) SetINTENCLR_IN5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIOTE_Type) GetINTENCLR_IN5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *GPIOTE_Type) SetINTENCLR_IN6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIOTE_Type) GetINTENCLR_IN6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *GPIOTE_Type) SetINTENCLR_IN7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIOTE_Type) GetINTENCLR_IN7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *GPIOTE_Type) SetINTENCLR_PORT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetINTENCLR_PORT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000000) >> 31
}

// GPIOTE.LATENCY: Latency selection for Event mode (MODE=Event) with rising or falling edge detection on the pin.
func (o *GPIOTE_Type) SetLATENCY(value uint32) {
	volatile.StoreUint32(&o.LATENCY.Reg, volatile.LoadUint32(&o.LATENCY.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetLATENCY() uint32 {
	return volatile.LoadUint32(&o.LATENCY.Reg) & 0x1
}

// GPIOTE.CONFIG: Description collection: Configuration for OUT[n], SET[n], and CLR[n] tasks and IN[n] event
func (o *GPIOTE_Type) SetCONFIG_MODE(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x3)|value)
}
func (o *GPIOTE_Type) GetCONFIG_MODE(idx int) uint32 {
	return volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x3
}
func (o *GPIOTE_Type) SetCONFIG_PSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x1f00)|value<<8)
}
func (o *GPIOTE_Type) GetCONFIG_PSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x1f00) >> 8
}
func (o *GPIOTE_Type) SetCONFIG_PORT(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x2000)|value<<13)
}
func (o *GPIOTE_Type) GetCONFIG_PORT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x2000) >> 13
}
func (o *GPIOTE_Type) SetCONFIG_POLARITY(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *GPIOTE_Type) GetCONFIG_POLARITY(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x30000) >> 16
}
func (o *GPIOTE_Type) SetCONFIG_OUTINIT(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x100000)|value<<20)
}
func (o *GPIOTE_Type) GetCONFIG_OUTINIT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x100000) >> 20
}

// Analog to Digital Converter 0
type SAADC_Type struct {
	TASKS_START               volatile.Register32 // 0x0
	TASKS_SAMPLE              volatile.Register32 // 0x4
	TASKS_STOP                volatile.Register32 // 0x8
	TASKS_CALIBRATEOFFSET     volatile.Register32 // 0xC
	_                         [112]byte
	SUBSCRIBE_START           volatile.Register32 // 0x80
	SUBSCRIBE_SAMPLE          volatile.Register32 // 0x84
	SUBSCRIBE_STOP            volatile.Register32 // 0x88
	SUBSCRIBE_CALIBRATEOFFSET volatile.Register32 // 0x8C
	_                         [112]byte
	EVENTS_STARTED            volatile.Register32     // 0x100
	EVENTS_END                volatile.Register32     // 0x104
	EVENTS_DONE               volatile.Register32     // 0x108
	EVENTS_RESULTDONE         volatile.Register32     // 0x10C
	EVENTS_CALIBRATEDONE      volatile.Register32     // 0x110
	EVENTS_STOPPED            volatile.Register32     // 0x114
	EVENTS_CH                 [8]SAADC_EVENTS_CH_Type // 0x118
	_                         [40]byte
	PUBLISH_STARTED           volatile.Register32      // 0x180
	PUBLISH_END               volatile.Register32      // 0x184
	PUBLISH_DONE              volatile.Register32      // 0x188
	PUBLISH_RESULTDONE        volatile.Register32      // 0x18C
	PUBLISH_CALIBRATEDONE     volatile.Register32      // 0x190
	PUBLISH_STOPPED           volatile.Register32      // 0x194
	PUBLISH_CH                [8]SAADC_PUBLISH_CH_Type // 0x198
	_                         [296]byte
	INTEN                     volatile.Register32 // 0x300
	INTENSET                  volatile.Register32 // 0x304
	INTENCLR                  volatile.Register32 // 0x308
	_                         [244]byte
	STATUS                    volatile.Register32 // 0x400
	_                         [252]byte
	ENABLE                    volatile.Register32 // 0x500
	_                         [12]byte
	CH                        [8]SAADC_CH_Type // 0x510
	_                         [96]byte
	RESOLUTION                volatile.Register32 // 0x5F0
	OVERSAMPLE                volatile.Register32 // 0x5F4
	SAMPLERATE                volatile.Register32 // 0x5F8
	_                         [48]byte
	RESULT                    SAADC_RESULT_Type // 0x62C
}

// SAADC.TASKS_START: Start the ADC and prepare the result buffer in RAM
func (o *SAADC_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// SAADC.TASKS_SAMPLE: Take one ADC sample, if scan is enabled all channels are sampled
func (o *SAADC_Type) SetTASKS_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_SAMPLE.Reg, volatile.LoadUint32(&o.TASKS_SAMPLE.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetTASKS_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_SAMPLE.Reg) & 0x1
}

// SAADC.TASKS_STOP: Stop the ADC and terminate any on-going conversion
func (o *SAADC_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// SAADC.TASKS_CALIBRATEOFFSET: Starts offset auto-calibration
func (o *SAADC_Type) SetTASKS_CALIBRATEOFFSET(value uint32) {
	volatile.StoreUint32(&o.TASKS_CALIBRATEOFFSET.Reg, volatile.LoadUint32(&o.TASKS_CALIBRATEOFFSET.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetTASKS_CALIBRATEOFFSET() uint32 {
	return volatile.LoadUint32(&o.TASKS_CALIBRATEOFFSET.Reg) & 0x1
}

// SAADC.SUBSCRIBE_START: Subscribe configuration for task START
func (o *SAADC_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *SAADC_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// SAADC.SUBSCRIBE_SAMPLE: Subscribe configuration for task SAMPLE
func (o *SAADC_Type) SetSUBSCRIBE_SAMPLE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SAMPLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetSUBSCRIBE_SAMPLE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg) & 0xff
}
func (o *SAADC_Type) SetSUBSCRIBE_SAMPLE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SAMPLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetSUBSCRIBE_SAMPLE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg) & 0x80000000) >> 31
}

// SAADC.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *SAADC_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *SAADC_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// SAADC.SUBSCRIBE_CALIBRATEOFFSET: Subscribe configuration for task CALIBRATEOFFSET
func (o *SAADC_Type) SetSUBSCRIBE_CALIBRATEOFFSET_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CALIBRATEOFFSET.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CALIBRATEOFFSET.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetSUBSCRIBE_CALIBRATEOFFSET_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CALIBRATEOFFSET.Reg) & 0xff
}
func (o *SAADC_Type) SetSUBSCRIBE_CALIBRATEOFFSET_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CALIBRATEOFFSET.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CALIBRATEOFFSET.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetSUBSCRIBE_CALIBRATEOFFSET_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CALIBRATEOFFSET.Reg) & 0x80000000) >> 31
}

// SAADC.EVENTS_STARTED: The ADC has started
func (o *SAADC_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// SAADC.EVENTS_END: The ADC has filled up the Result buffer
func (o *SAADC_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// SAADC.EVENTS_DONE: A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM.
func (o *SAADC_Type) SetEVENTS_DONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DONE.Reg, volatile.LoadUint32(&o.EVENTS_DONE.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetEVENTS_DONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DONE.Reg) & 0x1
}

// SAADC.EVENTS_RESULTDONE: A result is ready to get transferred to RAM.
func (o *SAADC_Type) SetEVENTS_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RESULTDONE.Reg, volatile.LoadUint32(&o.EVENTS_RESULTDONE.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetEVENTS_RESULTDONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RESULTDONE.Reg) & 0x1
}

// SAADC.EVENTS_CALIBRATEDONE: Calibration is complete
func (o *SAADC_Type) SetEVENTS_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CALIBRATEDONE.Reg, volatile.LoadUint32(&o.EVENTS_CALIBRATEDONE.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetEVENTS_CALIBRATEDONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CALIBRATEDONE.Reg) & 0x1
}

// SAADC.EVENTS_STOPPED: The ADC has stopped
func (o *SAADC_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// SAADC.PUBLISH_STARTED: Publish configuration for event STARTED
func (o *SAADC_Type) SetPUBLISH_STARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetPUBLISH_STARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0xff
}
func (o *SAADC_Type) SetPUBLISH_STARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetPUBLISH_STARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0x80000000) >> 31
}

// SAADC.PUBLISH_END: Publish configuration for event END
func (o *SAADC_Type) SetPUBLISH_END_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetPUBLISH_END_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0xff
}
func (o *SAADC_Type) SetPUBLISH_END_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetPUBLISH_END_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0x80000000) >> 31
}

// SAADC.PUBLISH_DONE: Publish configuration for event DONE
func (o *SAADC_Type) SetPUBLISH_DONE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DONE.Reg, volatile.LoadUint32(&o.PUBLISH_DONE.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetPUBLISH_DONE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_DONE.Reg) & 0xff
}
func (o *SAADC_Type) SetPUBLISH_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DONE.Reg, volatile.LoadUint32(&o.PUBLISH_DONE.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetPUBLISH_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_DONE.Reg) & 0x80000000) >> 31
}

// SAADC.PUBLISH_RESULTDONE: Publish configuration for event RESULTDONE
func (o *SAADC_Type) SetPUBLISH_RESULTDONE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RESULTDONE.Reg, volatile.LoadUint32(&o.PUBLISH_RESULTDONE.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetPUBLISH_RESULTDONE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RESULTDONE.Reg) & 0xff
}
func (o *SAADC_Type) SetPUBLISH_RESULTDONE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RESULTDONE.Reg, volatile.LoadUint32(&o.PUBLISH_RESULTDONE.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetPUBLISH_RESULTDONE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RESULTDONE.Reg) & 0x80000000) >> 31
}

// SAADC.PUBLISH_CALIBRATEDONE: Publish configuration for event CALIBRATEDONE
func (o *SAADC_Type) SetPUBLISH_CALIBRATEDONE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CALIBRATEDONE.Reg, volatile.LoadUint32(&o.PUBLISH_CALIBRATEDONE.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetPUBLISH_CALIBRATEDONE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_CALIBRATEDONE.Reg) & 0xff
}
func (o *SAADC_Type) SetPUBLISH_CALIBRATEDONE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CALIBRATEDONE.Reg, volatile.LoadUint32(&o.PUBLISH_CALIBRATEDONE.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetPUBLISH_CALIBRATEDONE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_CALIBRATEDONE.Reg) & 0x80000000) >> 31
}

// SAADC.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *SAADC_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *SAADC_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *SAADC_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// SAADC.INTEN: Enable or disable interrupt
func (o *SAADC_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetINTEN_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *SAADC_Type) SetINTEN_END(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *SAADC_Type) GetINTEN_END() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *SAADC_Type) SetINTEN_DONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *SAADC_Type) GetINTEN_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *SAADC_Type) SetINTEN_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *SAADC_Type) GetINTEN_RESULTDONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *SAADC_Type) SetINTEN_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *SAADC_Type) GetINTEN_CALIBRATEDONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *SAADC_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *SAADC_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *SAADC_Type) SetINTEN_CH0LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *SAADC_Type) GetINTEN_CH0LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *SAADC_Type) SetINTEN_CH0LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *SAADC_Type) GetINTEN_CH0LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *SAADC_Type) SetINTEN_CH1LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *SAADC_Type) GetINTEN_CH1LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *SAADC_Type) SetINTEN_CH1LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *SAADC_Type) GetINTEN_CH1LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *SAADC_Type) SetINTEN_CH2LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *SAADC_Type) GetINTEN_CH2LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *SAADC_Type) SetINTEN_CH2LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *SAADC_Type) GetINTEN_CH2LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *SAADC_Type) SetINTEN_CH3LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetINTEN_CH3LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *SAADC_Type) SetINTEN_CH3LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *SAADC_Type) GetINTEN_CH3LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *SAADC_Type) SetINTEN_CH4LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *SAADC_Type) GetINTEN_CH4LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *SAADC_Type) SetINTEN_CH4LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *SAADC_Type) GetINTEN_CH4LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}
func (o *SAADC_Type) SetINTEN_CH5LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000)|value<<16)
}
func (o *SAADC_Type) GetINTEN_CH5LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000) >> 16
}
func (o *SAADC_Type) SetINTEN_CH5LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *SAADC_Type) GetINTEN_CH5LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *SAADC_Type) SetINTEN_CH6LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *SAADC_Type) GetINTEN_CH6LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *SAADC_Type) SetINTEN_CH6LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *SAADC_Type) GetINTEN_CH6LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *SAADC_Type) SetINTEN_CH7LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_Type) GetINTEN_CH7LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *SAADC_Type) SetINTEN_CH7LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200000)|value<<21)
}
func (o *SAADC_Type) GetINTEN_CH7LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200000) >> 21
}

// SAADC.INTENSET: Enable interrupt
func (o *SAADC_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetINTENSET_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *SAADC_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SAADC_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SAADC_Type) SetINTENSET_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SAADC_Type) GetINTENSET_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SAADC_Type) SetINTENSET_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SAADC_Type) GetINTENSET_RESULTDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *SAADC_Type) SetINTENSET_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SAADC_Type) GetINTENSET_CALIBRATEDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SAADC_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *SAADC_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *SAADC_Type) SetINTENSET_CH0LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *SAADC_Type) GetINTENSET_CH0LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *SAADC_Type) SetINTENSET_CH0LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SAADC_Type) GetINTENSET_CH0LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *SAADC_Type) SetINTENSET_CH1LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SAADC_Type) GetINTENSET_CH1LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *SAADC_Type) SetINTENSET_CH1LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *SAADC_Type) GetINTENSET_CH1LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *SAADC_Type) SetINTENSET_CH2LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *SAADC_Type) GetINTENSET_CH2LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *SAADC_Type) SetINTENSET_CH2LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *SAADC_Type) GetINTENSET_CH2LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *SAADC_Type) SetINTENSET_CH3LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetINTENSET_CH3LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *SAADC_Type) SetINTENSET_CH3LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *SAADC_Type) GetINTENSET_CH3LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *SAADC_Type) SetINTENSET_CH4LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *SAADC_Type) GetINTENSET_CH4LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *SAADC_Type) SetINTENSET_CH4LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *SAADC_Type) GetINTENSET_CH4LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *SAADC_Type) SetINTENSET_CH5LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *SAADC_Type) GetINTENSET_CH5LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *SAADC_Type) SetINTENSET_CH5LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *SAADC_Type) GetINTENSET_CH5LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *SAADC_Type) SetINTENSET_CH6LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *SAADC_Type) GetINTENSET_CH6LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *SAADC_Type) SetINTENSET_CH6LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *SAADC_Type) GetINTENSET_CH6LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *SAADC_Type) SetINTENSET_CH7LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_Type) GetINTENSET_CH7LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *SAADC_Type) SetINTENSET_CH7LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *SAADC_Type) GetINTENSET_CH7LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}

// SAADC.INTENCLR: Disable interrupt
func (o *SAADC_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetINTENCLR_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *SAADC_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SAADC_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SAADC_Type) SetINTENCLR_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SAADC_Type) GetINTENCLR_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SAADC_Type) SetINTENCLR_RESULTDONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SAADC_Type) GetINTENCLR_RESULTDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *SAADC_Type) SetINTENCLR_CALIBRATEDONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SAADC_Type) GetINTENCLR_CALIBRATEDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SAADC_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *SAADC_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *SAADC_Type) SetINTENCLR_CH0LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *SAADC_Type) GetINTENCLR_CH0LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *SAADC_Type) SetINTENCLR_CH0LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SAADC_Type) GetINTENCLR_CH0LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *SAADC_Type) SetINTENCLR_CH1LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SAADC_Type) GetINTENCLR_CH1LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *SAADC_Type) SetINTENCLR_CH1LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *SAADC_Type) GetINTENCLR_CH1LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *SAADC_Type) SetINTENCLR_CH2LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *SAADC_Type) GetINTENCLR_CH2LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *SAADC_Type) SetINTENCLR_CH2LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *SAADC_Type) GetINTENCLR_CH2LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *SAADC_Type) SetINTENCLR_CH3LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetINTENCLR_CH3LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *SAADC_Type) SetINTENCLR_CH3LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *SAADC_Type) GetINTENCLR_CH3LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *SAADC_Type) SetINTENCLR_CH4LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *SAADC_Type) GetINTENCLR_CH4LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *SAADC_Type) SetINTENCLR_CH4LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *SAADC_Type) GetINTENCLR_CH4LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *SAADC_Type) SetINTENCLR_CH5LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *SAADC_Type) GetINTENCLR_CH5LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *SAADC_Type) SetINTENCLR_CH5LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *SAADC_Type) GetINTENCLR_CH5LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *SAADC_Type) SetINTENCLR_CH6LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *SAADC_Type) GetINTENCLR_CH6LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *SAADC_Type) SetINTENCLR_CH6LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *SAADC_Type) GetINTENCLR_CH6LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *SAADC_Type) SetINTENCLR_CH7LIMITH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_Type) GetINTENCLR_CH7LIMITH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *SAADC_Type) SetINTENCLR_CH7LIMITL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *SAADC_Type) GetINTENCLR_CH7LIMITL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}

// SAADC.STATUS: Status
func (o *SAADC_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}

// SAADC.ENABLE: Enable or disable ADC
func (o *SAADC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *SAADC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// SAADC.RESOLUTION: Resolution configuration
func (o *SAADC_Type) SetRESOLUTION_VAL(value uint32) {
	volatile.StoreUint32(&o.RESOLUTION.Reg, volatile.LoadUint32(&o.RESOLUTION.Reg)&^(0x7)|value)
}
func (o *SAADC_Type) GetRESOLUTION_VAL() uint32 {
	return volatile.LoadUint32(&o.RESOLUTION.Reg) & 0x7
}

// SAADC.OVERSAMPLE: Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
func (o *SAADC_Type) SetOVERSAMPLE(value uint32) {
	volatile.StoreUint32(&o.OVERSAMPLE.Reg, volatile.LoadUint32(&o.OVERSAMPLE.Reg)&^(0xf)|value)
}
func (o *SAADC_Type) GetOVERSAMPLE() uint32 {
	return volatile.LoadUint32(&o.OVERSAMPLE.Reg) & 0xf
}

// SAADC.SAMPLERATE: Controls normal or continuous sample rate
func (o *SAADC_Type) SetSAMPLERATE_CC(value uint32) {
	volatile.StoreUint32(&o.SAMPLERATE.Reg, volatile.LoadUint32(&o.SAMPLERATE.Reg)&^(0x7ff)|value)
}
func (o *SAADC_Type) GetSAMPLERATE_CC() uint32 {
	return volatile.LoadUint32(&o.SAMPLERATE.Reg) & 0x7ff
}
func (o *SAADC_Type) SetSAMPLERATE_MODE(value uint32) {
	volatile.StoreUint32(&o.SAMPLERATE.Reg, volatile.LoadUint32(&o.SAMPLERATE.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_Type) GetSAMPLERATE_MODE() uint32 {
	return (volatile.LoadUint32(&o.SAMPLERATE.Reg) & 0x1000) >> 12
}

type SAADC_EVENTS_CH_Type struct {
	LIMITH volatile.Register32 // 0x118
	LIMITL volatile.Register32 // 0x11C
}

// SAADC_EVENTS_CH.LIMITH: Description cluster: Last results is equal or above CH[n].LIMIT.HIGH
func (o *SAADC_EVENTS_CH_Type) SetLIMITH(value uint32) {
	volatile.StoreUint32(&o.LIMITH.Reg, volatile.LoadUint32(&o.LIMITH.Reg)&^(0x1)|value)
}
func (o *SAADC_EVENTS_CH_Type) GetLIMITH() uint32 {
	return volatile.LoadUint32(&o.LIMITH.Reg) & 0x1
}

// SAADC_EVENTS_CH.LIMITL: Description cluster: Last results is equal or below CH[n].LIMIT.LOW
func (o *SAADC_EVENTS_CH_Type) SetLIMITL(value uint32) {
	volatile.StoreUint32(&o.LIMITL.Reg, volatile.LoadUint32(&o.LIMITL.Reg)&^(0x1)|value)
}
func (o *SAADC_EVENTS_CH_Type) GetLIMITL() uint32 {
	return volatile.LoadUint32(&o.LIMITL.Reg) & 0x1
}

type SAADC_PUBLISH_CH_Type struct {
	LIMITH volatile.Register32 // 0x198
	LIMITL volatile.Register32 // 0x19C
}

// SAADC_PUBLISH_CH.LIMITH: Description cluster: Publish configuration for event CH[n].LIMITH
func (o *SAADC_PUBLISH_CH_Type) SetLIMITH_CHIDX(value uint32) {
	volatile.StoreUint32(&o.LIMITH.Reg, volatile.LoadUint32(&o.LIMITH.Reg)&^(0xff)|value)
}
func (o *SAADC_PUBLISH_CH_Type) GetLIMITH_CHIDX() uint32 {
	return volatile.LoadUint32(&o.LIMITH.Reg) & 0xff
}
func (o *SAADC_PUBLISH_CH_Type) SetLIMITH_EN(value uint32) {
	volatile.StoreUint32(&o.LIMITH.Reg, volatile.LoadUint32(&o.LIMITH.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_PUBLISH_CH_Type) GetLIMITH_EN() uint32 {
	return (volatile.LoadUint32(&o.LIMITH.Reg) & 0x80000000) >> 31
}

// SAADC_PUBLISH_CH.LIMITL: Description cluster: Publish configuration for event CH[n].LIMITL
func (o *SAADC_PUBLISH_CH_Type) SetLIMITL_CHIDX(value uint32) {
	volatile.StoreUint32(&o.LIMITL.Reg, volatile.LoadUint32(&o.LIMITL.Reg)&^(0xff)|value)
}
func (o *SAADC_PUBLISH_CH_Type) GetLIMITL_CHIDX() uint32 {
	return volatile.LoadUint32(&o.LIMITL.Reg) & 0xff
}
func (o *SAADC_PUBLISH_CH_Type) SetLIMITL_EN(value uint32) {
	volatile.StoreUint32(&o.LIMITL.Reg, volatile.LoadUint32(&o.LIMITL.Reg)&^(0x80000000)|value<<31)
}
func (o *SAADC_PUBLISH_CH_Type) GetLIMITL_EN() uint32 {
	return (volatile.LoadUint32(&o.LIMITL.Reg) & 0x80000000) >> 31
}

type SAADC_CH_Type struct {
	PSELP  volatile.Register32 // 0x510
	PSELN  volatile.Register32 // 0x514
	CONFIG volatile.Register32 // 0x518
	LIMIT  volatile.Register32 // 0x51C
}

// SAADC_CH.PSELP: Description cluster: Input positive pin selection for CH[n]
func (o *SAADC_CH_Type) SetPSELP(value uint32) {
	volatile.StoreUint32(&o.PSELP.Reg, volatile.LoadUint32(&o.PSELP.Reg)&^(0x1f)|value)
}
func (o *SAADC_CH_Type) GetPSELP() uint32 {
	return volatile.LoadUint32(&o.PSELP.Reg) & 0x1f
}

// SAADC_CH.PSELN: Description cluster: Input negative pin selection for CH[n]
func (o *SAADC_CH_Type) SetPSELN(value uint32) {
	volatile.StoreUint32(&o.PSELN.Reg, volatile.LoadUint32(&o.PSELN.Reg)&^(0x1f)|value)
}
func (o *SAADC_CH_Type) GetPSELN() uint32 {
	return volatile.LoadUint32(&o.PSELN.Reg) & 0x1f
}

// SAADC_CH.CONFIG: Description cluster: Input configuration for CH[n]
func (o *SAADC_CH_Type) SetCONFIG_RESP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x3)|value)
}
func (o *SAADC_CH_Type) GetCONFIG_RESP() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x3
}
func (o *SAADC_CH_Type) SetCONFIG_RESN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x30)|value<<4)
}
func (o *SAADC_CH_Type) GetCONFIG_RESN() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x30) >> 4
}
func (o *SAADC_CH_Type) SetCONFIG_GAIN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x700)|value<<8)
}
func (o *SAADC_CH_Type) GetCONFIG_GAIN() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x700) >> 8
}
func (o *SAADC_CH_Type) SetCONFIG_REFSEL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *SAADC_CH_Type) GetCONFIG_REFSEL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x1000) >> 12
}
func (o *SAADC_CH_Type) SetCONFIG_TACQ(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x70000)|value<<16)
}
func (o *SAADC_CH_Type) GetCONFIG_TACQ() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x70000) >> 16
}
func (o *SAADC_CH_Type) SetCONFIG_MODE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100000)|value<<20)
}
func (o *SAADC_CH_Type) GetCONFIG_MODE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100000) >> 20
}
func (o *SAADC_CH_Type) SetCONFIG_BURST(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1000000)|value<<24)
}
func (o *SAADC_CH_Type) GetCONFIG_BURST() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x1000000) >> 24
}

// SAADC_CH.LIMIT: Description cluster: High/low limits for event monitoring a channel
func (o *SAADC_CH_Type) SetLIMIT_LOW(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff)|value)
}
func (o *SAADC_CH_Type) GetLIMIT_LOW() uint32 {
	return volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff
}
func (o *SAADC_CH_Type) SetLIMIT_HIGH(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SAADC_CH_Type) GetLIMIT_HIGH() uint32 {
	return (volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff0000) >> 16
}

type SAADC_RESULT_Type struct {
	PTR    volatile.Register32 // 0x62C
	MAXCNT volatile.Register32 // 0x630
	AMOUNT volatile.Register32 // 0x634
}

// SAADC_RESULT.PTR: Data pointer
func (o *SAADC_RESULT_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SAADC_RESULT_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SAADC_RESULT.MAXCNT: Maximum number of buffer words to transfer
func (o *SAADC_RESULT_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *SAADC_RESULT_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// SAADC_RESULT.AMOUNT: Number of buffer words transferred since last START
func (o *SAADC_RESULT_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *SAADC_RESULT_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// Timer/Counter 0
type TIMER_Type struct {
	TASKS_START        volatile.Register32 // 0x0
	TASKS_STOP         volatile.Register32 // 0x4
	TASKS_COUNT        volatile.Register32 // 0x8
	TASKS_CLEAR        volatile.Register32 // 0xC
	TASKS_SHUTDOWN     volatile.Register32 // 0x10
	_                  [44]byte
	TASKS_CAPTURE      [6]volatile.Register32 // 0x40
	_                  [40]byte
	SUBSCRIBE_START    volatile.Register32 // 0x80
	SUBSCRIBE_STOP     volatile.Register32 // 0x84
	SUBSCRIBE_COUNT    volatile.Register32 // 0x88
	SUBSCRIBE_CLEAR    volatile.Register32 // 0x8C
	SUBSCRIBE_SHUTDOWN volatile.Register32 // 0x90
	_                  [44]byte
	SUBSCRIBE_CAPTURE  [6]volatile.Register32 // 0xC0
	_                  [104]byte
	EVENTS_COMPARE     [6]volatile.Register32 // 0x140
	_                  [104]byte
	PUBLISH_COMPARE    [6]volatile.Register32 // 0x1C0
	_                  [40]byte
	SHORTS             volatile.Register32 // 0x200
	_                  [252]byte
	INTEN              volatile.Register32 // 0x300
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [504]byte
	MODE               volatile.Register32 // 0x504
	BITMODE            volatile.Register32 // 0x508
	_                  [4]byte
	PRESCALER          volatile.Register32 // 0x510
	_                  [44]byte
	CC                 [6]volatile.Register32 // 0x540
	_                  [40]byte
	ONESHOTEN          [6]volatile.Register32 // 0x580
}

// TIMER.TASKS_START: Start Timer
func (o *TIMER_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// TIMER.TASKS_STOP: Stop Timer
func (o *TIMER_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TIMER.TASKS_COUNT: Increment Timer (Counter mode only)
func (o *TIMER_Type) SetTASKS_COUNT(value uint32) {
	volatile.StoreUint32(&o.TASKS_COUNT.Reg, volatile.LoadUint32(&o.TASKS_COUNT.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_COUNT() uint32 {
	return volatile.LoadUint32(&o.TASKS_COUNT.Reg) & 0x1
}

// TIMER.TASKS_CLEAR: Clear time
func (o *TIMER_Type) SetTASKS_CLEAR(value uint32) {
	volatile.StoreUint32(&o.TASKS_CLEAR.Reg, volatile.LoadUint32(&o.TASKS_CLEAR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_CLEAR() uint32 {
	return volatile.LoadUint32(&o.TASKS_CLEAR.Reg) & 0x1
}

// TIMER.TASKS_SHUTDOWN: Deprecated register - Shut down timer
func (o *TIMER_Type) SetTASKS_SHUTDOWN(value uint32) {
	volatile.StoreUint32(&o.TASKS_SHUTDOWN.Reg, volatile.LoadUint32(&o.TASKS_SHUTDOWN.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_SHUTDOWN() uint32 {
	return volatile.LoadUint32(&o.TASKS_SHUTDOWN.Reg) & 0x1
}

// TIMER.TASKS_CAPTURE: Description collection: Capture Timer value to CC[n] register
func (o *TIMER_Type) SetTASKS_CAPTURE(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_CAPTURE[idx].Reg, volatile.LoadUint32(&o.TASKS_CAPTURE[idx].Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_CAPTURE(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_CAPTURE[idx].Reg) & 0x1
}

// TIMER.SUBSCRIBE_START: Subscribe configuration for task START
func (o *TIMER_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *TIMER_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// TIMER.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *TIMER_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *TIMER_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// TIMER.SUBSCRIBE_COUNT: Subscribe configuration for task COUNT
func (o *TIMER_Type) SetSUBSCRIBE_COUNT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_COUNT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_COUNT.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetSUBSCRIBE_COUNT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_COUNT.Reg) & 0xff
}
func (o *TIMER_Type) SetSUBSCRIBE_COUNT_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_COUNT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_COUNT.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetSUBSCRIBE_COUNT_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_COUNT.Reg) & 0x80000000) >> 31
}

// TIMER.SUBSCRIBE_CLEAR: Subscribe configuration for task CLEAR
func (o *TIMER_Type) SetSUBSCRIBE_CLEAR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CLEAR.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetSUBSCRIBE_CLEAR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg) & 0xff
}
func (o *TIMER_Type) SetSUBSCRIBE_CLEAR_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CLEAR.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetSUBSCRIBE_CLEAR_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg) & 0x80000000) >> 31
}

// TIMER.SUBSCRIBE_SHUTDOWN: Deprecated register - Subscribe configuration for task SHUTDOWN
func (o *TIMER_Type) SetSUBSCRIBE_SHUTDOWN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SHUTDOWN.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SHUTDOWN.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetSUBSCRIBE_SHUTDOWN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SHUTDOWN.Reg) & 0xff
}
func (o *TIMER_Type) SetSUBSCRIBE_SHUTDOWN_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SHUTDOWN.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SHUTDOWN.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetSUBSCRIBE_SHUTDOWN_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SHUTDOWN.Reg) & 0x80000000) >> 31
}

// TIMER.SUBSCRIBE_CAPTURE: Description collection: Subscribe configuration for task CAPTURE[n]
func (o *TIMER_Type) SetSUBSCRIBE_CAPTURE_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetSUBSCRIBE_CAPTURE_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg) & 0xff
}
func (o *TIMER_Type) SetSUBSCRIBE_CAPTURE_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetSUBSCRIBE_CAPTURE_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg) & 0x80000000) >> 31
}

// TIMER.EVENTS_COMPARE: Description collection: Compare event on CC[n] match
func (o *TIMER_Type) SetEVENTS_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_COMPARE[idx].Reg, volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetEVENTS_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg) & 0x1
}

// TIMER.PUBLISH_COMPARE: Description collection: Publish configuration for event COMPARE[n]
func (o *TIMER_Type) SetPUBLISH_COMPARE_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_COMPARE[idx].Reg, volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetPUBLISH_COMPARE_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg) & 0xff
}
func (o *TIMER_Type) SetPUBLISH_COMPARE_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_COMPARE[idx].Reg, volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *TIMER_Type) GetPUBLISH_COMPARE_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg) & 0x80000000) >> 31
}

// TIMER.SHORTS: Shortcuts between local events and tasks
func (o *TIMER_Type) SetSHORTS_COMPARE0_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetSHORTS_COMPARE0_CLEAR() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *TIMER_Type) SetSHORTS_COMPARE1_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetSHORTS_COMPARE1_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetSHORTS_COMPARE2_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetSHORTS_COMPARE2_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetSHORTS_COMPARE3_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetSHORTS_COMPARE3_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetSHORTS_COMPARE4_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *TIMER_Type) GetSHORTS_COMPARE4_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *TIMER_Type) SetSHORTS_COMPARE5_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *TIMER_Type) GetSHORTS_COMPARE5_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *TIMER_Type) SetSHORTS_COMPARE0_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetSHORTS_COMPARE0_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetSHORTS_COMPARE1_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetSHORTS_COMPARE1_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetSHORTS_COMPARE2_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetSHORTS_COMPARE2_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetSHORTS_COMPARE3_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetSHORTS_COMPARE3_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetSHORTS_COMPARE4_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetSHORTS_COMPARE4_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetSHORTS_COMPARE5_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetSHORTS_COMPARE5_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200000) >> 21
}

// TIMER.INTEN: Enable or disable interrupt
func (o *TIMER_Type) SetINTEN_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTEN_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTEN_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTEN_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTEN_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTEN_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTEN_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTEN_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTEN_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTEN_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTEN_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTEN_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200000) >> 21
}

// TIMER.INTENSET: Enable interrupt
func (o *TIMER_Type) SetINTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTENSET_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTENSET_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTENSET_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTENSET_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}

// TIMER.INTENCLR: Disable interrupt
func (o *TIMER_Type) SetINTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTENCLR_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTENCLR_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}

// TIMER.MODE: Timer mode selection
func (o *TIMER_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}

// TIMER.BITMODE: Configure the number of bits used by the TIMER
func (o *TIMER_Type) SetBITMODE(value uint32) {
	volatile.StoreUint32(&o.BITMODE.Reg, volatile.LoadUint32(&o.BITMODE.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetBITMODE() uint32 {
	return volatile.LoadUint32(&o.BITMODE.Reg) & 0x3
}

// TIMER.PRESCALER: Timer prescaler register
func (o *TIMER_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0xf)|value)
}
func (o *TIMER_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0xf
}

// TIMER.CC: Description collection: Capture/Compare register n
func (o *TIMER_Type) SetCC(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, value)
}
func (o *TIMER_Type) GetCC(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg)
}

// TIMER.ONESHOTEN: Description collection: Enable one-shot operation for Capture/Compare channel n
func (o *TIMER_Type) SetONESHOTEN(idx int, value uint32) {
	volatile.StoreUint32(&o.ONESHOTEN[idx].Reg, volatile.LoadUint32(&o.ONESHOTEN[idx].Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetONESHOTEN(idx int) uint32 {
	return volatile.LoadUint32(&o.ONESHOTEN[idx].Reg) & 0x1
}

// Real-time counter 0
type RTC_Type struct {
	TASKS_START          volatile.Register32 // 0x0
	TASKS_STOP           volatile.Register32 // 0x4
	TASKS_CLEAR          volatile.Register32 // 0x8
	TASKS_TRIGOVRFLW     volatile.Register32 // 0xC
	_                    [48]byte
	TASKS_CAPTURE        [4]volatile.Register32 // 0x40
	_                    [48]byte
	SUBSCRIBE_START      volatile.Register32 // 0x80
	SUBSCRIBE_STOP       volatile.Register32 // 0x84
	SUBSCRIBE_CLEAR      volatile.Register32 // 0x88
	SUBSCRIBE_TRIGOVRFLW volatile.Register32 // 0x8C
	_                    [48]byte
	SUBSCRIBE_CAPTURE    [4]volatile.Register32 // 0xC0
	_                    [48]byte
	EVENTS_TICK          volatile.Register32 // 0x100
	EVENTS_OVRFLW        volatile.Register32 // 0x104
	_                    [56]byte
	EVENTS_COMPARE       [4]volatile.Register32 // 0x140
	_                    [48]byte
	PUBLISH_TICK         volatile.Register32 // 0x180
	PUBLISH_OVRFLW       volatile.Register32 // 0x184
	_                    [56]byte
	PUBLISH_COMPARE      [4]volatile.Register32 // 0x1C0
	_                    [48]byte
	SHORTS               volatile.Register32 // 0x200
	_                    [256]byte
	INTENSET             volatile.Register32 // 0x304
	INTENCLR             volatile.Register32 // 0x308
	_                    [52]byte
	EVTEN                volatile.Register32 // 0x340
	EVTENSET             volatile.Register32 // 0x344
	EVTENCLR             volatile.Register32 // 0x348
	_                    [440]byte
	COUNTER              volatile.Register32 // 0x504
	PRESCALER            volatile.Register32 // 0x508
	_                    [52]byte
	CC                   [4]volatile.Register32 // 0x540
}

// RTC.TASKS_START: Start RTC counter
func (o *RTC_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// RTC.TASKS_STOP: Stop RTC counter
func (o *RTC_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// RTC.TASKS_CLEAR: Clear RTC counter
func (o *RTC_Type) SetTASKS_CLEAR(value uint32) {
	volatile.StoreUint32(&o.TASKS_CLEAR.Reg, volatile.LoadUint32(&o.TASKS_CLEAR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_CLEAR() uint32 {
	return volatile.LoadUint32(&o.TASKS_CLEAR.Reg) & 0x1
}

// RTC.TASKS_TRIGOVRFLW: Set counter to 0xFFFFF0
func (o *RTC_Type) SetTASKS_TRIGOVRFLW(value uint32) {
	volatile.StoreUint32(&o.TASKS_TRIGOVRFLW.Reg, volatile.LoadUint32(&o.TASKS_TRIGOVRFLW.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_TRIGOVRFLW() uint32 {
	return volatile.LoadUint32(&o.TASKS_TRIGOVRFLW.Reg) & 0x1
}

// RTC.TASKS_CAPTURE: Description collection: Capture RTC counter to CC[n] register
func (o *RTC_Type) SetTASKS_CAPTURE(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_CAPTURE[idx].Reg, volatile.LoadUint32(&o.TASKS_CAPTURE[idx].Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_CAPTURE(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_CAPTURE[idx].Reg) & 0x1
}

// RTC.SUBSCRIBE_START: Subscribe configuration for task START
func (o *RTC_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *RTC_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// RTC.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *RTC_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *RTC_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// RTC.SUBSCRIBE_CLEAR: Subscribe configuration for task CLEAR
func (o *RTC_Type) SetSUBSCRIBE_CLEAR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CLEAR.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetSUBSCRIBE_CLEAR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg) & 0xff
}
func (o *RTC_Type) SetSUBSCRIBE_CLEAR_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CLEAR.Reg, volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSUBSCRIBE_CLEAR_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CLEAR.Reg) & 0x80000000) >> 31
}

// RTC.SUBSCRIBE_TRIGOVRFLW: Subscribe configuration for task TRIGOVRFLW
func (o *RTC_Type) SetSUBSCRIBE_TRIGOVRFLW_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_TRIGOVRFLW.Reg, volatile.LoadUint32(&o.SUBSCRIBE_TRIGOVRFLW.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetSUBSCRIBE_TRIGOVRFLW_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_TRIGOVRFLW.Reg) & 0xff
}
func (o *RTC_Type) SetSUBSCRIBE_TRIGOVRFLW_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_TRIGOVRFLW.Reg, volatile.LoadUint32(&o.SUBSCRIBE_TRIGOVRFLW.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSUBSCRIBE_TRIGOVRFLW_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_TRIGOVRFLW.Reg) & 0x80000000) >> 31
}

// RTC.SUBSCRIBE_CAPTURE: Description collection: Subscribe configuration for task CAPTURE[n]
func (o *RTC_Type) SetSUBSCRIBE_CAPTURE_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetSUBSCRIBE_CAPTURE_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg) & 0xff
}
func (o *RTC_Type) SetSUBSCRIBE_CAPTURE_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSUBSCRIBE_CAPTURE_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_CAPTURE[idx].Reg) & 0x80000000) >> 31
}

// RTC.EVENTS_TICK: Event on counter increment
func (o *RTC_Type) SetEVENTS_TICK(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TICK.Reg, volatile.LoadUint32(&o.EVENTS_TICK.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVENTS_TICK() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TICK.Reg) & 0x1
}

// RTC.EVENTS_OVRFLW: Event on counter overflow
func (o *RTC_Type) SetEVENTS_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVENTS_OVRFLW.Reg, volatile.LoadUint32(&o.EVENTS_OVRFLW.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVENTS_OVRFLW() uint32 {
	return volatile.LoadUint32(&o.EVENTS_OVRFLW.Reg) & 0x1
}

// RTC.EVENTS_COMPARE: Description collection: Compare event on CC[n] match
func (o *RTC_Type) SetEVENTS_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_COMPARE[idx].Reg, volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVENTS_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg) & 0x1
}

// RTC.PUBLISH_TICK: Publish configuration for event TICK
func (o *RTC_Type) SetPUBLISH_TICK_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TICK.Reg, volatile.LoadUint32(&o.PUBLISH_TICK.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetPUBLISH_TICK_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TICK.Reg) & 0xff
}
func (o *RTC_Type) SetPUBLISH_TICK_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TICK.Reg, volatile.LoadUint32(&o.PUBLISH_TICK.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetPUBLISH_TICK_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TICK.Reg) & 0x80000000) >> 31
}

// RTC.PUBLISH_OVRFLW: Publish configuration for event OVRFLW
func (o *RTC_Type) SetPUBLISH_OVRFLW_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_OVRFLW.Reg, volatile.LoadUint32(&o.PUBLISH_OVRFLW.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetPUBLISH_OVRFLW_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_OVRFLW.Reg) & 0xff
}
func (o *RTC_Type) SetPUBLISH_OVRFLW_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_OVRFLW.Reg, volatile.LoadUint32(&o.PUBLISH_OVRFLW.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetPUBLISH_OVRFLW_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_OVRFLW.Reg) & 0x80000000) >> 31
}

// RTC.PUBLISH_COMPARE: Description collection: Publish configuration for event COMPARE[n]
func (o *RTC_Type) SetPUBLISH_COMPARE_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_COMPARE[idx].Reg, volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetPUBLISH_COMPARE_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg) & 0xff
}
func (o *RTC_Type) SetPUBLISH_COMPARE_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_COMPARE[idx].Reg, volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetPUBLISH_COMPARE_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_COMPARE[idx].Reg) & 0x80000000) >> 31
}

// RTC.SHORTS: Shortcuts between local events and tasks
func (o *RTC_Type) SetSHORTS_COMPARE0_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSHORTS_COMPARE0_CLEAR() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *RTC_Type) SetSHORTS_COMPARE1_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSHORTS_COMPARE1_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSHORTS_COMPARE2_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSHORTS_COMPARE2_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSHORTS_COMPARE3_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSHORTS_COMPARE3_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}

// RTC.INTENSET: Enable interrupt
func (o *RTC_Type) SetINTENSET_TICK(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTENSET_TICK() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *RTC_Type) SetINTENSET_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetINTENSET_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetINTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetINTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetINTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetINTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetINTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetINTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetINTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetINTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}

// RTC.INTENCLR: Disable interrupt
func (o *RTC_Type) SetINTENCLR_TICK(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTENCLR_TICK() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *RTC_Type) SetINTENCLR_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetINTENCLR_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetINTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetINTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetINTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetINTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetINTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetINTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetINTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetINTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}

// RTC.EVTEN: Enable or disable event routing
func (o *RTC_Type) SetEVTEN_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTEN_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTEN.Reg) & 0x1
}
func (o *RTC_Type) SetEVTEN_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTEN_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTEN_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTEN_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTEN_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTEN_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTEN_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTEN_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTEN_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTEN_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x80000) >> 19
}

// RTC.EVTENSET: Enable event routing
func (o *RTC_Type) SetEVTENSET_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTENSET_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTENSET.Reg) & 0x1
}
func (o *RTC_Type) SetEVTENSET_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTENSET_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x80000) >> 19
}

// RTC.EVTENCLR: Disable event routing
func (o *RTC_Type) SetEVTENCLR_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTENCLR_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x1
}
func (o *RTC_Type) SetEVTENCLR_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTENCLR_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x80000) >> 19
}

// RTC.COUNTER: Current counter value
func (o *RTC_Type) SetCOUNTER(value uint32) {
	volatile.StoreUint32(&o.COUNTER.Reg, volatile.LoadUint32(&o.COUNTER.Reg)&^(0xffffff)|value)
}
func (o *RTC_Type) GetCOUNTER() uint32 {
	return volatile.LoadUint32(&o.COUNTER.Reg) & 0xffffff
}

// RTC.PRESCALER: 12-bit prescaler for counter frequency (32768/(PRESCALER+1)). Must be written when RTC is stopped.
func (o *RTC_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0xfff
}

// RTC.CC: Description collection: Compare register n
func (o *RTC_Type) SetCC_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, volatile.LoadUint32(&o.CC[idx].Reg)&^(0xffffff)|value)
}
func (o *RTC_Type) GetCC_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg) & 0xffffff
}

// Distributed programmable peripheral interconnect controller 0
type DPPIC_Type struct {
	TASKS_CHG     [6]DPPIC_TASKS_CHG_Type // 0x0
	_             [80]byte
	SUBSCRIBE_CHG [6]DPPIC_SUBSCRIBE_CHG_Type // 0x80
	_             [1104]byte
	CHEN          volatile.Register32 // 0x500
	CHENSET       volatile.Register32 // 0x504
	CHENCLR       volatile.Register32 // 0x508
	_             [756]byte
	CHG           [6]volatile.Register32 // 0x800
}

// DPPIC.CHEN: Channel enable register
func (o *DPPIC_Type) SetCHEN_CH0(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1)|value)
}
func (o *DPPIC_Type) GetCHEN_CH0() uint32 {
	return volatile.LoadUint32(&o.CHEN.Reg) & 0x1
}
func (o *DPPIC_Type) SetCHEN_CH1(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2)|value<<1)
}
func (o *DPPIC_Type) GetCHEN_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2) >> 1
}
func (o *DPPIC_Type) SetCHEN_CH2(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4)|value<<2)
}
func (o *DPPIC_Type) GetCHEN_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4) >> 2
}
func (o *DPPIC_Type) SetCHEN_CH3(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8)|value<<3)
}
func (o *DPPIC_Type) GetCHEN_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8) >> 3
}
func (o *DPPIC_Type) SetCHEN_CH4(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10)|value<<4)
}
func (o *DPPIC_Type) GetCHEN_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10) >> 4
}
func (o *DPPIC_Type) SetCHEN_CH5(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20)|value<<5)
}
func (o *DPPIC_Type) GetCHEN_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20) >> 5
}
func (o *DPPIC_Type) SetCHEN_CH6(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40)|value<<6)
}
func (o *DPPIC_Type) GetCHEN_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40) >> 6
}
func (o *DPPIC_Type) SetCHEN_CH7(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80)|value<<7)
}
func (o *DPPIC_Type) GetCHEN_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80) >> 7
}
func (o *DPPIC_Type) SetCHEN_CH8(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x100)|value<<8)
}
func (o *DPPIC_Type) GetCHEN_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x100) >> 8
}
func (o *DPPIC_Type) SetCHEN_CH9(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x200)|value<<9)
}
func (o *DPPIC_Type) GetCHEN_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x200) >> 9
}
func (o *DPPIC_Type) SetCHEN_CH10(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x400)|value<<10)
}
func (o *DPPIC_Type) GetCHEN_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x400) >> 10
}
func (o *DPPIC_Type) SetCHEN_CH11(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x800)|value<<11)
}
func (o *DPPIC_Type) GetCHEN_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x800) >> 11
}
func (o *DPPIC_Type) SetCHEN_CH12(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1000)|value<<12)
}
func (o *DPPIC_Type) GetCHEN_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x1000) >> 12
}
func (o *DPPIC_Type) SetCHEN_CH13(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2000)|value<<13)
}
func (o *DPPIC_Type) GetCHEN_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2000) >> 13
}
func (o *DPPIC_Type) SetCHEN_CH14(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4000)|value<<14)
}
func (o *DPPIC_Type) GetCHEN_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4000) >> 14
}
func (o *DPPIC_Type) SetCHEN_CH15(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8000)|value<<15)
}
func (o *DPPIC_Type) GetCHEN_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8000) >> 15
}
func (o *DPPIC_Type) SetCHEN_CH16(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10000)|value<<16)
}
func (o *DPPIC_Type) GetCHEN_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10000) >> 16
}
func (o *DPPIC_Type) SetCHEN_CH17(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20000)|value<<17)
}
func (o *DPPIC_Type) GetCHEN_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20000) >> 17
}
func (o *DPPIC_Type) SetCHEN_CH18(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40000)|value<<18)
}
func (o *DPPIC_Type) GetCHEN_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40000) >> 18
}
func (o *DPPIC_Type) SetCHEN_CH19(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80000)|value<<19)
}
func (o *DPPIC_Type) GetCHEN_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80000) >> 19
}
func (o *DPPIC_Type) SetCHEN_CH20(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x100000)|value<<20)
}
func (o *DPPIC_Type) GetCHEN_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x100000) >> 20
}
func (o *DPPIC_Type) SetCHEN_CH21(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x200000)|value<<21)
}
func (o *DPPIC_Type) GetCHEN_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x200000) >> 21
}
func (o *DPPIC_Type) SetCHEN_CH22(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x400000)|value<<22)
}
func (o *DPPIC_Type) GetCHEN_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x400000) >> 22
}
func (o *DPPIC_Type) SetCHEN_CH23(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x800000)|value<<23)
}
func (o *DPPIC_Type) GetCHEN_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x800000) >> 23
}
func (o *DPPIC_Type) SetCHEN_CH24(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1000000)|value<<24)
}
func (o *DPPIC_Type) GetCHEN_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x1000000) >> 24
}
func (o *DPPIC_Type) SetCHEN_CH25(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2000000)|value<<25)
}
func (o *DPPIC_Type) GetCHEN_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2000000) >> 25
}
func (o *DPPIC_Type) SetCHEN_CH26(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4000000)|value<<26)
}
func (o *DPPIC_Type) GetCHEN_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4000000) >> 26
}
func (o *DPPIC_Type) SetCHEN_CH27(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8000000)|value<<27)
}
func (o *DPPIC_Type) GetCHEN_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8000000) >> 27
}
func (o *DPPIC_Type) SetCHEN_CH28(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10000000)|value<<28)
}
func (o *DPPIC_Type) GetCHEN_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10000000) >> 28
}
func (o *DPPIC_Type) SetCHEN_CH29(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20000000)|value<<29)
}
func (o *DPPIC_Type) GetCHEN_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20000000) >> 29
}
func (o *DPPIC_Type) SetCHEN_CH30(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40000000)|value<<30)
}
func (o *DPPIC_Type) GetCHEN_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40000000) >> 30
}
func (o *DPPIC_Type) SetCHEN_CH31(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80000000)|value<<31)
}
func (o *DPPIC_Type) GetCHEN_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80000000) >> 31
}

// DPPIC.CHENSET: Channel enable set register
func (o *DPPIC_Type) SetCHENSET_CH0(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1)|value)
}
func (o *DPPIC_Type) GetCHENSET_CH0() uint32 {
	return volatile.LoadUint32(&o.CHENSET.Reg) & 0x1
}
func (o *DPPIC_Type) SetCHENSET_CH1(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2)|value<<1)
}
func (o *DPPIC_Type) GetCHENSET_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2) >> 1
}
func (o *DPPIC_Type) SetCHENSET_CH2(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4)|value<<2)
}
func (o *DPPIC_Type) GetCHENSET_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4) >> 2
}
func (o *DPPIC_Type) SetCHENSET_CH3(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8)|value<<3)
}
func (o *DPPIC_Type) GetCHENSET_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8) >> 3
}
func (o *DPPIC_Type) SetCHENSET_CH4(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10)|value<<4)
}
func (o *DPPIC_Type) GetCHENSET_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10) >> 4
}
func (o *DPPIC_Type) SetCHENSET_CH5(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20)|value<<5)
}
func (o *DPPIC_Type) GetCHENSET_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20) >> 5
}
func (o *DPPIC_Type) SetCHENSET_CH6(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40)|value<<6)
}
func (o *DPPIC_Type) GetCHENSET_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40) >> 6
}
func (o *DPPIC_Type) SetCHENSET_CH7(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80)|value<<7)
}
func (o *DPPIC_Type) GetCHENSET_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80) >> 7
}
func (o *DPPIC_Type) SetCHENSET_CH8(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x100)|value<<8)
}
func (o *DPPIC_Type) GetCHENSET_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x100) >> 8
}
func (o *DPPIC_Type) SetCHENSET_CH9(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x200)|value<<9)
}
func (o *DPPIC_Type) GetCHENSET_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x200) >> 9
}
func (o *DPPIC_Type) SetCHENSET_CH10(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x400)|value<<10)
}
func (o *DPPIC_Type) GetCHENSET_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x400) >> 10
}
func (o *DPPIC_Type) SetCHENSET_CH11(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x800)|value<<11)
}
func (o *DPPIC_Type) GetCHENSET_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x800) >> 11
}
func (o *DPPIC_Type) SetCHENSET_CH12(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1000)|value<<12)
}
func (o *DPPIC_Type) GetCHENSET_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x1000) >> 12
}
func (o *DPPIC_Type) SetCHENSET_CH13(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2000)|value<<13)
}
func (o *DPPIC_Type) GetCHENSET_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2000) >> 13
}
func (o *DPPIC_Type) SetCHENSET_CH14(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4000)|value<<14)
}
func (o *DPPIC_Type) GetCHENSET_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4000) >> 14
}
func (o *DPPIC_Type) SetCHENSET_CH15(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8000)|value<<15)
}
func (o *DPPIC_Type) GetCHENSET_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8000) >> 15
}
func (o *DPPIC_Type) SetCHENSET_CH16(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10000)|value<<16)
}
func (o *DPPIC_Type) GetCHENSET_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10000) >> 16
}
func (o *DPPIC_Type) SetCHENSET_CH17(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20000)|value<<17)
}
func (o *DPPIC_Type) GetCHENSET_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20000) >> 17
}
func (o *DPPIC_Type) SetCHENSET_CH18(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40000)|value<<18)
}
func (o *DPPIC_Type) GetCHENSET_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40000) >> 18
}
func (o *DPPIC_Type) SetCHENSET_CH19(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80000)|value<<19)
}
func (o *DPPIC_Type) GetCHENSET_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80000) >> 19
}
func (o *DPPIC_Type) SetCHENSET_CH20(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x100000)|value<<20)
}
func (o *DPPIC_Type) GetCHENSET_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x100000) >> 20
}
func (o *DPPIC_Type) SetCHENSET_CH21(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x200000)|value<<21)
}
func (o *DPPIC_Type) GetCHENSET_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x200000) >> 21
}
func (o *DPPIC_Type) SetCHENSET_CH22(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x400000)|value<<22)
}
func (o *DPPIC_Type) GetCHENSET_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x400000) >> 22
}
func (o *DPPIC_Type) SetCHENSET_CH23(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x800000)|value<<23)
}
func (o *DPPIC_Type) GetCHENSET_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x800000) >> 23
}
func (o *DPPIC_Type) SetCHENSET_CH24(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *DPPIC_Type) GetCHENSET_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x1000000) >> 24
}
func (o *DPPIC_Type) SetCHENSET_CH25(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *DPPIC_Type) GetCHENSET_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2000000) >> 25
}
func (o *DPPIC_Type) SetCHENSET_CH26(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *DPPIC_Type) GetCHENSET_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4000000) >> 26
}
func (o *DPPIC_Type) SetCHENSET_CH27(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *DPPIC_Type) GetCHENSET_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8000000) >> 27
}
func (o *DPPIC_Type) SetCHENSET_CH28(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10000000)|value<<28)
}
func (o *DPPIC_Type) GetCHENSET_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10000000) >> 28
}
func (o *DPPIC_Type) SetCHENSET_CH29(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20000000)|value<<29)
}
func (o *DPPIC_Type) GetCHENSET_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20000000) >> 29
}
func (o *DPPIC_Type) SetCHENSET_CH30(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40000000)|value<<30)
}
func (o *DPPIC_Type) GetCHENSET_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40000000) >> 30
}
func (o *DPPIC_Type) SetCHENSET_CH31(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80000000)|value<<31)
}
func (o *DPPIC_Type) GetCHENSET_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80000000) >> 31
}

// DPPIC.CHENCLR: Channel enable clear register
func (o *DPPIC_Type) SetCHENCLR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1)|value)
}
func (o *DPPIC_Type) GetCHENCLR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1
}
func (o *DPPIC_Type) SetCHENCLR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2)|value<<1)
}
func (o *DPPIC_Type) GetCHENCLR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2) >> 1
}
func (o *DPPIC_Type) SetCHENCLR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4)|value<<2)
}
func (o *DPPIC_Type) GetCHENCLR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4) >> 2
}
func (o *DPPIC_Type) SetCHENCLR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8)|value<<3)
}
func (o *DPPIC_Type) GetCHENCLR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8) >> 3
}
func (o *DPPIC_Type) SetCHENCLR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10)|value<<4)
}
func (o *DPPIC_Type) GetCHENCLR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10) >> 4
}
func (o *DPPIC_Type) SetCHENCLR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20)|value<<5)
}
func (o *DPPIC_Type) GetCHENCLR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20) >> 5
}
func (o *DPPIC_Type) SetCHENCLR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40)|value<<6)
}
func (o *DPPIC_Type) GetCHENCLR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40) >> 6
}
func (o *DPPIC_Type) SetCHENCLR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80)|value<<7)
}
func (o *DPPIC_Type) GetCHENCLR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80) >> 7
}
func (o *DPPIC_Type) SetCHENCLR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x100)|value<<8)
}
func (o *DPPIC_Type) GetCHENCLR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x100) >> 8
}
func (o *DPPIC_Type) SetCHENCLR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x200)|value<<9)
}
func (o *DPPIC_Type) GetCHENCLR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x200) >> 9
}
func (o *DPPIC_Type) SetCHENCLR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x400)|value<<10)
}
func (o *DPPIC_Type) GetCHENCLR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x400) >> 10
}
func (o *DPPIC_Type) SetCHENCLR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x800)|value<<11)
}
func (o *DPPIC_Type) GetCHENCLR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x800) >> 11
}
func (o *DPPIC_Type) SetCHENCLR_CH12(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *DPPIC_Type) GetCHENCLR_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1000) >> 12
}
func (o *DPPIC_Type) SetCHENCLR_CH13(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *DPPIC_Type) GetCHENCLR_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2000) >> 13
}
func (o *DPPIC_Type) SetCHENCLR_CH14(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *DPPIC_Type) GetCHENCLR_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4000) >> 14
}
func (o *DPPIC_Type) SetCHENCLR_CH15(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *DPPIC_Type) GetCHENCLR_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8000) >> 15
}
func (o *DPPIC_Type) SetCHENCLR_CH16(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *DPPIC_Type) GetCHENCLR_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10000) >> 16
}
func (o *DPPIC_Type) SetCHENCLR_CH17(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *DPPIC_Type) GetCHENCLR_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20000) >> 17
}
func (o *DPPIC_Type) SetCHENCLR_CH18(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *DPPIC_Type) GetCHENCLR_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40000) >> 18
}
func (o *DPPIC_Type) SetCHENCLR_CH19(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *DPPIC_Type) GetCHENCLR_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80000) >> 19
}
func (o *DPPIC_Type) SetCHENCLR_CH20(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *DPPIC_Type) GetCHENCLR_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x100000) >> 20
}
func (o *DPPIC_Type) SetCHENCLR_CH21(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *DPPIC_Type) GetCHENCLR_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x200000) >> 21
}
func (o *DPPIC_Type) SetCHENCLR_CH22(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *DPPIC_Type) GetCHENCLR_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x400000) >> 22
}
func (o *DPPIC_Type) SetCHENCLR_CH23(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *DPPIC_Type) GetCHENCLR_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x800000) >> 23
}
func (o *DPPIC_Type) SetCHENCLR_CH24(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *DPPIC_Type) GetCHENCLR_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1000000) >> 24
}
func (o *DPPIC_Type) SetCHENCLR_CH25(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *DPPIC_Type) GetCHENCLR_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2000000) >> 25
}
func (o *DPPIC_Type) SetCHENCLR_CH26(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *DPPIC_Type) GetCHENCLR_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4000000) >> 26
}
func (o *DPPIC_Type) SetCHENCLR_CH27(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *DPPIC_Type) GetCHENCLR_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8000000) >> 27
}
func (o *DPPIC_Type) SetCHENCLR_CH28(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *DPPIC_Type) GetCHENCLR_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10000000) >> 28
}
func (o *DPPIC_Type) SetCHENCLR_CH29(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *DPPIC_Type) GetCHENCLR_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20000000) >> 29
}
func (o *DPPIC_Type) SetCHENCLR_CH30(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *DPPIC_Type) GetCHENCLR_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40000000) >> 30
}
func (o *DPPIC_Type) SetCHENCLR_CH31(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *DPPIC_Type) GetCHENCLR_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80000000) >> 31
}

// DPPIC.CHG: Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG[n].EN or SUBSCRIBE_CHG[n].DIS is enabled
func (o *DPPIC_Type) SetCHG_CH0(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1)|value)
}
func (o *DPPIC_Type) GetCHG_CH0(idx int) uint32 {
	return volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1
}
func (o *DPPIC_Type) SetCHG_CH1(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2)|value<<1)
}
func (o *DPPIC_Type) GetCHG_CH1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2) >> 1
}
func (o *DPPIC_Type) SetCHG_CH2(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4)|value<<2)
}
func (o *DPPIC_Type) GetCHG_CH2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4) >> 2
}
func (o *DPPIC_Type) SetCHG_CH3(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8)|value<<3)
}
func (o *DPPIC_Type) GetCHG_CH3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8) >> 3
}
func (o *DPPIC_Type) SetCHG_CH4(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10)|value<<4)
}
func (o *DPPIC_Type) GetCHG_CH4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10) >> 4
}
func (o *DPPIC_Type) SetCHG_CH5(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20)|value<<5)
}
func (o *DPPIC_Type) GetCHG_CH5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20) >> 5
}
func (o *DPPIC_Type) SetCHG_CH6(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40)|value<<6)
}
func (o *DPPIC_Type) GetCHG_CH6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40) >> 6
}
func (o *DPPIC_Type) SetCHG_CH7(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80)|value<<7)
}
func (o *DPPIC_Type) GetCHG_CH7(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80) >> 7
}
func (o *DPPIC_Type) SetCHG_CH8(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x100)|value<<8)
}
func (o *DPPIC_Type) GetCHG_CH8(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x100) >> 8
}
func (o *DPPIC_Type) SetCHG_CH9(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x200)|value<<9)
}
func (o *DPPIC_Type) GetCHG_CH9(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x200) >> 9
}
func (o *DPPIC_Type) SetCHG_CH10(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x400)|value<<10)
}
func (o *DPPIC_Type) GetCHG_CH10(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x400) >> 10
}
func (o *DPPIC_Type) SetCHG_CH11(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x800)|value<<11)
}
func (o *DPPIC_Type) GetCHG_CH11(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x800) >> 11
}
func (o *DPPIC_Type) SetCHG_CH12(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1000)|value<<12)
}
func (o *DPPIC_Type) GetCHG_CH12(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1000) >> 12
}
func (o *DPPIC_Type) SetCHG_CH13(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2000)|value<<13)
}
func (o *DPPIC_Type) GetCHG_CH13(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2000) >> 13
}
func (o *DPPIC_Type) SetCHG_CH14(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4000)|value<<14)
}
func (o *DPPIC_Type) GetCHG_CH14(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4000) >> 14
}
func (o *DPPIC_Type) SetCHG_CH15(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8000)|value<<15)
}
func (o *DPPIC_Type) GetCHG_CH15(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8000) >> 15
}
func (o *DPPIC_Type) SetCHG_CH16(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10000)|value<<16)
}
func (o *DPPIC_Type) GetCHG_CH16(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10000) >> 16
}
func (o *DPPIC_Type) SetCHG_CH17(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20000)|value<<17)
}
func (o *DPPIC_Type) GetCHG_CH17(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20000) >> 17
}
func (o *DPPIC_Type) SetCHG_CH18(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40000)|value<<18)
}
func (o *DPPIC_Type) GetCHG_CH18(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40000) >> 18
}
func (o *DPPIC_Type) SetCHG_CH19(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80000)|value<<19)
}
func (o *DPPIC_Type) GetCHG_CH19(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80000) >> 19
}
func (o *DPPIC_Type) SetCHG_CH20(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x100000)|value<<20)
}
func (o *DPPIC_Type) GetCHG_CH20(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x100000) >> 20
}
func (o *DPPIC_Type) SetCHG_CH21(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x200000)|value<<21)
}
func (o *DPPIC_Type) GetCHG_CH21(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x200000) >> 21
}
func (o *DPPIC_Type) SetCHG_CH22(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x400000)|value<<22)
}
func (o *DPPIC_Type) GetCHG_CH22(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x400000) >> 22
}
func (o *DPPIC_Type) SetCHG_CH23(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x800000)|value<<23)
}
func (o *DPPIC_Type) GetCHG_CH23(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x800000) >> 23
}
func (o *DPPIC_Type) SetCHG_CH24(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *DPPIC_Type) GetCHG_CH24(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1000000) >> 24
}
func (o *DPPIC_Type) SetCHG_CH25(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2000000)|value<<25)
}
func (o *DPPIC_Type) GetCHG_CH25(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2000000) >> 25
}
func (o *DPPIC_Type) SetCHG_CH26(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4000000)|value<<26)
}
func (o *DPPIC_Type) GetCHG_CH26(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4000000) >> 26
}
func (o *DPPIC_Type) SetCHG_CH27(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *DPPIC_Type) GetCHG_CH27(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8000000) >> 27
}
func (o *DPPIC_Type) SetCHG_CH28(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *DPPIC_Type) GetCHG_CH28(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10000000) >> 28
}
func (o *DPPIC_Type) SetCHG_CH29(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *DPPIC_Type) GetCHG_CH29(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20000000) >> 29
}
func (o *DPPIC_Type) SetCHG_CH30(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *DPPIC_Type) GetCHG_CH30(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40000000) >> 30
}
func (o *DPPIC_Type) SetCHG_CH31(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *DPPIC_Type) GetCHG_CH31(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80000000) >> 31
}

type DPPIC_TASKS_CHG_Type struct {
	EN  volatile.Register32 // 0x0
	DIS volatile.Register32 // 0x4
}

// DPPIC_TASKS_CHG.EN: Description cluster: Enable channel group n
func (o *DPPIC_TASKS_CHG_Type) SetEN(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x1)|value)
}
func (o *DPPIC_TASKS_CHG_Type) GetEN() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0x1
}

// DPPIC_TASKS_CHG.DIS: Description cluster: Disable channel group n
func (o *DPPIC_TASKS_CHG_Type) SetDIS(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x1)|value)
}
func (o *DPPIC_TASKS_CHG_Type) GetDIS() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0x1
}

type DPPIC_SUBSCRIBE_CHG_Type struct {
	EN  volatile.Register32 // 0x80
	DIS volatile.Register32 // 0x84
}

// DPPIC_SUBSCRIBE_CHG.EN: Description cluster: Subscribe configuration for task CHG[n].EN
func (o *DPPIC_SUBSCRIBE_CHG_Type) SetEN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0xff)|value)
}
func (o *DPPIC_SUBSCRIBE_CHG_Type) GetEN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0xff
}
func (o *DPPIC_SUBSCRIBE_CHG_Type) SetEN(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x80000000)|value<<31)
}
func (o *DPPIC_SUBSCRIBE_CHG_Type) GetEN() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x80000000) >> 31
}

// DPPIC_SUBSCRIBE_CHG.DIS: Description cluster: Subscribe configuration for task CHG[n].DIS
func (o *DPPIC_SUBSCRIBE_CHG_Type) SetDIS_CHIDX(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0xff)|value)
}
func (o *DPPIC_SUBSCRIBE_CHG_Type) GetDIS_CHIDX() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0xff
}
func (o *DPPIC_SUBSCRIBE_CHG_Type) SetDIS_EN(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x80000000)|value<<31)
}
func (o *DPPIC_SUBSCRIBE_CHG_Type) GetDIS_EN() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x80000000) >> 31
}

// Watchdog Timer 0
type WDT_Type struct {
	TASKS_START     volatile.Register32 // 0x0
	TASKS_STOP      volatile.Register32 // 0x4
	_               [120]byte
	SUBSCRIBE_START volatile.Register32 // 0x80
	SUBSCRIBE_STOP  volatile.Register32 // 0x84
	_               [120]byte
	EVENTS_TIMEOUT  volatile.Register32 // 0x100
	EVENTS_STOPPED  volatile.Register32 // 0x104
	_               [120]byte
	PUBLISH_TIMEOUT volatile.Register32 // 0x180
	PUBLISH_STOPPED volatile.Register32 // 0x184
	_               [380]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [24]byte
	NMIENSET        volatile.Register32 // 0x324
	NMIENCLR        volatile.Register32 // 0x328
	_               [212]byte
	RUNSTATUS       volatile.Register32 // 0x400
	REQSTATUS       volatile.Register32 // 0x404
	_               [252]byte
	CRV             volatile.Register32 // 0x504
	RREN            volatile.Register32 // 0x508
	CONFIG          volatile.Register32 // 0x50C
	_               [16]byte
	TSEN            volatile.Register32 // 0x520
	_               [220]byte
	RR              [8]volatile.Register32 // 0x600
}

// WDT.TASKS_START: Start the watchdog
func (o *WDT_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// WDT.TASKS_STOP: Stop the watchdog timer.
func (o *WDT_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// WDT.SUBSCRIBE_START: Subscribe configuration for task START
func (o *WDT_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *WDT_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *WDT_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *WDT_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// WDT.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *WDT_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *WDT_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *WDT_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *WDT_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// WDT.EVENTS_TIMEOUT: Watchdog timeout
func (o *WDT_Type) SetEVENTS_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TIMEOUT.Reg, volatile.LoadUint32(&o.EVENTS_TIMEOUT.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetEVENTS_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TIMEOUT.Reg) & 0x1
}

// WDT.EVENTS_STOPPED: Watchdog stopped
func (o *WDT_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// WDT.PUBLISH_TIMEOUT: Publish configuration for event TIMEOUT
func (o *WDT_Type) SetPUBLISH_TIMEOUT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TIMEOUT.Reg, volatile.LoadUint32(&o.PUBLISH_TIMEOUT.Reg)&^(0xff)|value)
}
func (o *WDT_Type) GetPUBLISH_TIMEOUT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TIMEOUT.Reg) & 0xff
}
func (o *WDT_Type) SetPUBLISH_TIMEOUT_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TIMEOUT.Reg, volatile.LoadUint32(&o.PUBLISH_TIMEOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *WDT_Type) GetPUBLISH_TIMEOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TIMEOUT.Reg) & 0x80000000) >> 31
}

// WDT.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *WDT_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *WDT_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *WDT_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *WDT_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// WDT.INTENSET: Enable interrupt
func (o *WDT_Type) SetINTENSET_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENSET_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *WDT_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}

// WDT.INTENCLR: Disable interrupt
func (o *WDT_Type) SetINTENCLR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENCLR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *WDT_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}

// WDT.NMIENSET: Enable interrupt
func (o *WDT_Type) SetNMIENSET_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetNMIENSET_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.NMIENSET.Reg) & 0x1
}
func (o *WDT_Type) SetNMIENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.NMIENSET.Reg, volatile.LoadUint32(&o.NMIENSET.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetNMIENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.NMIENSET.Reg) & 0x2) >> 1
}

// WDT.NMIENCLR: Disable interrupt
func (o *WDT_Type) SetNMIENCLR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetNMIENCLR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x1
}
func (o *WDT_Type) SetNMIENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.NMIENCLR.Reg, volatile.LoadUint32(&o.NMIENCLR.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetNMIENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.NMIENCLR.Reg) & 0x2) >> 1
}

// WDT.RUNSTATUS: Run status
func (o *WDT_Type) SetRUNSTATUS_RUNSTATUSWDT(value uint32) {
	volatile.StoreUint32(&o.RUNSTATUS.Reg, volatile.LoadUint32(&o.RUNSTATUS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetRUNSTATUS_RUNSTATUSWDT() uint32 {
	return volatile.LoadUint32(&o.RUNSTATUS.Reg) & 0x1
}

// WDT.REQSTATUS: Request status
func (o *WDT_Type) SetREQSTATUS_RR0(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetREQSTATUS_RR0() uint32 {
	return volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x1
}
func (o *WDT_Type) SetREQSTATUS_RR1(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetREQSTATUS_RR1() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetREQSTATUS_RR2(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetREQSTATUS_RR2() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetREQSTATUS_RR3(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetREQSTATUS_RR3() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetREQSTATUS_RR4(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetREQSTATUS_RR4() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x10) >> 4
}
func (o *WDT_Type) SetREQSTATUS_RR5(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *WDT_Type) GetREQSTATUS_RR5() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x20) >> 5
}
func (o *WDT_Type) SetREQSTATUS_RR6(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetREQSTATUS_RR6() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x40) >> 6
}
func (o *WDT_Type) SetREQSTATUS_RR7(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetREQSTATUS_RR7() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x80) >> 7
}

// WDT.CRV: Counter reload value
func (o *WDT_Type) SetCRV(value uint32) {
	volatile.StoreUint32(&o.CRV.Reg, value)
}
func (o *WDT_Type) GetCRV() uint32 {
	return volatile.LoadUint32(&o.CRV.Reg)
}

// WDT.RREN: Enable register for reload request registers
func (o *WDT_Type) SetRREN_RR0(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetRREN_RR0() uint32 {
	return volatile.LoadUint32(&o.RREN.Reg) & 0x1
}
func (o *WDT_Type) SetRREN_RR1(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetRREN_RR1() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetRREN_RR2(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetRREN_RR2() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetRREN_RR3(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetRREN_RR3() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetRREN_RR4(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetRREN_RR4() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x10) >> 4
}
func (o *WDT_Type) SetRREN_RR5(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x20)|value<<5)
}
func (o *WDT_Type) GetRREN_RR5() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x20) >> 5
}
func (o *WDT_Type) SetRREN_RR6(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetRREN_RR6() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x40) >> 6
}
func (o *WDT_Type) SetRREN_RR7(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetRREN_RR7() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x80) >> 7
}

// WDT.CONFIG: Configuration register
func (o *WDT_Type) SetCONFIG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetCONFIG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *WDT_Type) SetCONFIG_HALT(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetCONFIG_HALT() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetCONFIG_STOPEN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetCONFIG_STOPEN() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x40) >> 6
}

// WDT.TSEN: Task Stop Enable
func (o *WDT_Type) SetTSEN(value uint32) {
	volatile.StoreUint32(&o.TSEN.Reg, value)
}
func (o *WDT_Type) GetTSEN() uint32 {
	return volatile.LoadUint32(&o.TSEN.Reg)
}

// WDT.RR: Description collection: Reload request n
func (o *WDT_Type) SetRR(idx int, value uint32) {
	volatile.StoreUint32(&o.RR[idx].Reg, value)
}
func (o *WDT_Type) GetRR(idx int) uint32 {
	return volatile.LoadUint32(&o.RR[idx].Reg)
}

// Comparator 0
type COMP_Type struct {
	TASKS_START      volatile.Register32 // 0x0
	TASKS_STOP       volatile.Register32 // 0x4
	TASKS_SAMPLE     volatile.Register32 // 0x8
	_                [116]byte
	SUBSCRIBE_START  volatile.Register32 // 0x80
	SUBSCRIBE_STOP   volatile.Register32 // 0x84
	SUBSCRIBE_SAMPLE volatile.Register32 // 0x88
	_                [116]byte
	EVENTS_READY     volatile.Register32 // 0x100
	EVENTS_DOWN      volatile.Register32 // 0x104
	EVENTS_UP        volatile.Register32 // 0x108
	EVENTS_CROSS     volatile.Register32 // 0x10C
	_                [112]byte
	PUBLISH_READY    volatile.Register32 // 0x180
	PUBLISH_DOWN     volatile.Register32 // 0x184
	PUBLISH_UP       volatile.Register32 // 0x188
	PUBLISH_CROSS    volatile.Register32 // 0x18C
	_                [112]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [244]byte
	RESULT           volatile.Register32 // 0x400
	_                [252]byte
	ENABLE           volatile.Register32 // 0x500
	PSEL             volatile.Register32 // 0x504
	REFSEL           volatile.Register32 // 0x508
	EXTREFSEL        volatile.Register32 // 0x50C
	_                [32]byte
	TH               volatile.Register32 // 0x530
	MODE             volatile.Register32 // 0x534
	HYST             volatile.Register32 // 0x538
	ISOURCE          volatile.Register32 // 0x53C
}

// COMP.TASKS_START: Start comparator
func (o *COMP_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// COMP.TASKS_STOP: Stop comparator
func (o *COMP_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// COMP.TASKS_SAMPLE: Sample comparator value
func (o *COMP_Type) SetTASKS_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_SAMPLE.Reg, volatile.LoadUint32(&o.TASKS_SAMPLE.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetTASKS_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_SAMPLE.Reg) & 0x1
}

// COMP.SUBSCRIBE_START: Subscribe configuration for task START
func (o *COMP_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *COMP_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// COMP.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *COMP_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *COMP_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// COMP.SUBSCRIBE_SAMPLE: Subscribe configuration for task SAMPLE
func (o *COMP_Type) SetSUBSCRIBE_SAMPLE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SAMPLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetSUBSCRIBE_SAMPLE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg) & 0xff
}
func (o *COMP_Type) SetSUBSCRIBE_SAMPLE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SAMPLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetSUBSCRIBE_SAMPLE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg) & 0x80000000) >> 31
}

// COMP.EVENTS_READY: COMP is ready and output is valid
func (o *COMP_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// COMP.EVENTS_DOWN: Downward crossing
func (o *COMP_Type) SetEVENTS_DOWN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DOWN.Reg, volatile.LoadUint32(&o.EVENTS_DOWN.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_DOWN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DOWN.Reg) & 0x1
}

// COMP.EVENTS_UP: Upward crossing
func (o *COMP_Type) SetEVENTS_UP(value uint32) {
	volatile.StoreUint32(&o.EVENTS_UP.Reg, volatile.LoadUint32(&o.EVENTS_UP.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_UP() uint32 {
	return volatile.LoadUint32(&o.EVENTS_UP.Reg) & 0x1
}

// COMP.EVENTS_CROSS: Downward or upward crossing
func (o *COMP_Type) SetEVENTS_CROSS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CROSS.Reg, volatile.LoadUint32(&o.EVENTS_CROSS.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_CROSS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CROSS.Reg) & 0x1
}

// COMP.PUBLISH_READY: Publish configuration for event READY
func (o *COMP_Type) SetPUBLISH_READY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetPUBLISH_READY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0xff
}
func (o *COMP_Type) SetPUBLISH_READY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetPUBLISH_READY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0x80000000) >> 31
}

// COMP.PUBLISH_DOWN: Publish configuration for event DOWN
func (o *COMP_Type) SetPUBLISH_DOWN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DOWN.Reg, volatile.LoadUint32(&o.PUBLISH_DOWN.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetPUBLISH_DOWN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_DOWN.Reg) & 0xff
}
func (o *COMP_Type) SetPUBLISH_DOWN_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DOWN.Reg, volatile.LoadUint32(&o.PUBLISH_DOWN.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetPUBLISH_DOWN_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_DOWN.Reg) & 0x80000000) >> 31
}

// COMP.PUBLISH_UP: Publish configuration for event UP
func (o *COMP_Type) SetPUBLISH_UP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_UP.Reg, volatile.LoadUint32(&o.PUBLISH_UP.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetPUBLISH_UP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_UP.Reg) & 0xff
}
func (o *COMP_Type) SetPUBLISH_UP_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_UP.Reg, volatile.LoadUint32(&o.PUBLISH_UP.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetPUBLISH_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_UP.Reg) & 0x80000000) >> 31
}

// COMP.PUBLISH_CROSS: Publish configuration for event CROSS
func (o *COMP_Type) SetPUBLISH_CROSS_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CROSS.Reg, volatile.LoadUint32(&o.PUBLISH_CROSS.Reg)&^(0xff)|value)
}
func (o *COMP_Type) GetPUBLISH_CROSS_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_CROSS.Reg) & 0xff
}
func (o *COMP_Type) SetPUBLISH_CROSS_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CROSS.Reg, volatile.LoadUint32(&o.PUBLISH_CROSS.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetPUBLISH_CROSS_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_CROSS.Reg) & 0x80000000) >> 31
}

// COMP.SHORTS: Shortcuts between local events and tasks
func (o *COMP_Type) SetSHORTS_READY_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetSHORTS_READY_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *COMP_Type) SetSHORTS_READY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetSHORTS_READY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetSHORTS_DOWN_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetSHORTS_DOWN_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetSHORTS_UP_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetSHORTS_UP_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *COMP_Type) SetSHORTS_CROSS_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *COMP_Type) GetSHORTS_CROSS_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// COMP.INTEN: Enable or disable interrupt
func (o *COMP_Type) SetINTEN_READY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTEN_READY() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *COMP_Type) SetINTEN_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTEN_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTEN_UP(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTEN_UP() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTEN_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTEN_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}

// COMP.INTENSET: Enable interrupt
func (o *COMP_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *COMP_Type) SetINTENSET_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTENSET_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTENSET_UP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTENSET_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTENSET_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTENSET_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}

// COMP.INTENCLR: Disable interrupt
func (o *COMP_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *COMP_Type) SetINTENCLR_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTENCLR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTENCLR_UP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTENCLR_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTENCLR_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTENCLR_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}

// COMP.RESULT: Compare result
func (o *COMP_Type) SetRESULT(value uint32) {
	volatile.StoreUint32(&o.RESULT.Reg, volatile.LoadUint32(&o.RESULT.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetRESULT() uint32 {
	return volatile.LoadUint32(&o.RESULT.Reg) & 0x1
}

// COMP.ENABLE: COMP enable
func (o *COMP_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// COMP.PSEL: Pin select
func (o *COMP_Type) SetPSEL(value uint32) {
	volatile.StoreUint32(&o.PSEL.Reg, volatile.LoadUint32(&o.PSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetPSEL() uint32 {
	return volatile.LoadUint32(&o.PSEL.Reg) & 0x7
}

// COMP.REFSEL: Reference source select for single-ended mode
func (o *COMP_Type) SetREFSEL(value uint32) {
	volatile.StoreUint32(&o.REFSEL.Reg, volatile.LoadUint32(&o.REFSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetREFSEL() uint32 {
	return volatile.LoadUint32(&o.REFSEL.Reg) & 0x7
}

// COMP.EXTREFSEL: External reference select
func (o *COMP_Type) SetEXTREFSEL(value uint32) {
	volatile.StoreUint32(&o.EXTREFSEL.Reg, volatile.LoadUint32(&o.EXTREFSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetEXTREFSEL() uint32 {
	return volatile.LoadUint32(&o.EXTREFSEL.Reg) & 0x7
}

// COMP.TH: Threshold configuration for hysteresis unit
func (o *COMP_Type) SetTH_THDOWN(value uint32) {
	volatile.StoreUint32(&o.TH.Reg, volatile.LoadUint32(&o.TH.Reg)&^(0x3f)|value)
}
func (o *COMP_Type) GetTH_THDOWN() uint32 {
	return volatile.LoadUint32(&o.TH.Reg) & 0x3f
}
func (o *COMP_Type) SetTH_THUP(value uint32) {
	volatile.StoreUint32(&o.TH.Reg, volatile.LoadUint32(&o.TH.Reg)&^(0x3f00)|value<<8)
}
func (o *COMP_Type) GetTH_THUP() uint32 {
	return (volatile.LoadUint32(&o.TH.Reg) & 0x3f00) >> 8
}

// COMP.MODE: Mode configuration
func (o *COMP_Type) SetMODE_SP(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetMODE_SP() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}
func (o *COMP_Type) SetMODE_MAIN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x100)|value<<8)
}
func (o *COMP_Type) GetMODE_MAIN() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x100) >> 8
}

// COMP.HYST: Comparator hysteresis enable
func (o *COMP_Type) SetHYST(value uint32) {
	volatile.StoreUint32(&o.HYST.Reg, volatile.LoadUint32(&o.HYST.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetHYST() uint32 {
	return volatile.LoadUint32(&o.HYST.Reg) & 0x1
}

// COMP.ISOURCE: Current source select on analog input
func (o *COMP_Type) SetISOURCE(value uint32) {
	volatile.StoreUint32(&o.ISOURCE.Reg, volatile.LoadUint32(&o.ISOURCE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetISOURCE() uint32 {
	return volatile.LoadUint32(&o.ISOURCE.Reg) & 0x3
}

// Low-power comparator 0
type LPCOMP_Type struct {
	TASKS_START      volatile.Register32 // 0x0
	TASKS_STOP       volatile.Register32 // 0x4
	TASKS_SAMPLE     volatile.Register32 // 0x8
	_                [116]byte
	SUBSCRIBE_START  volatile.Register32 // 0x80
	SUBSCRIBE_STOP   volatile.Register32 // 0x84
	SUBSCRIBE_SAMPLE volatile.Register32 // 0x88
	_                [116]byte
	EVENTS_READY     volatile.Register32 // 0x100
	EVENTS_DOWN      volatile.Register32 // 0x104
	EVENTS_UP        volatile.Register32 // 0x108
	EVENTS_CROSS     volatile.Register32 // 0x10C
	_                [112]byte
	PUBLISH_READY    volatile.Register32 // 0x180
	PUBLISH_DOWN     volatile.Register32 // 0x184
	PUBLISH_UP       volatile.Register32 // 0x188
	PUBLISH_CROSS    volatile.Register32 // 0x18C
	_                [112]byte
	SHORTS           volatile.Register32 // 0x200
	_                [256]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [244]byte
	RESULT           volatile.Register32 // 0x400
	_                [252]byte
	ENABLE           volatile.Register32 // 0x500
	PSEL             volatile.Register32 // 0x504
	REFSEL           volatile.Register32 // 0x508
	EXTREFSEL        volatile.Register32 // 0x50C
	_                [16]byte
	ANADETECT        volatile.Register32 // 0x520
	_                [20]byte
	HYST             volatile.Register32 // 0x538
}

// LPCOMP.TASKS_START: Start comparator
func (o *LPCOMP_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// LPCOMP.TASKS_STOP: Stop comparator
func (o *LPCOMP_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// LPCOMP.TASKS_SAMPLE: Sample comparator value
func (o *LPCOMP_Type) SetTASKS_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_SAMPLE.Reg, volatile.LoadUint32(&o.TASKS_SAMPLE.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetTASKS_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_SAMPLE.Reg) & 0x1
}

// LPCOMP.SUBSCRIBE_START: Subscribe configuration for task START
func (o *LPCOMP_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *LPCOMP_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// LPCOMP.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *LPCOMP_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *LPCOMP_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// LPCOMP.SUBSCRIBE_SAMPLE: Subscribe configuration for task SAMPLE
func (o *LPCOMP_Type) SetSUBSCRIBE_SAMPLE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SAMPLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetSUBSCRIBE_SAMPLE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg) & 0xff
}
func (o *LPCOMP_Type) SetSUBSCRIBE_SAMPLE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SAMPLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetSUBSCRIBE_SAMPLE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SAMPLE.Reg) & 0x80000000) >> 31
}

// LPCOMP.EVENTS_READY: LPCOMP is ready and output is valid
func (o *LPCOMP_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// LPCOMP.EVENTS_DOWN: Downward crossing
func (o *LPCOMP_Type) SetEVENTS_DOWN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DOWN.Reg, volatile.LoadUint32(&o.EVENTS_DOWN.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetEVENTS_DOWN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DOWN.Reg) & 0x1
}

// LPCOMP.EVENTS_UP: Upward crossing
func (o *LPCOMP_Type) SetEVENTS_UP(value uint32) {
	volatile.StoreUint32(&o.EVENTS_UP.Reg, volatile.LoadUint32(&o.EVENTS_UP.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetEVENTS_UP() uint32 {
	return volatile.LoadUint32(&o.EVENTS_UP.Reg) & 0x1
}

// LPCOMP.EVENTS_CROSS: Downward or upward crossing
func (o *LPCOMP_Type) SetEVENTS_CROSS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CROSS.Reg, volatile.LoadUint32(&o.EVENTS_CROSS.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetEVENTS_CROSS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CROSS.Reg) & 0x1
}

// LPCOMP.PUBLISH_READY: Publish configuration for event READY
func (o *LPCOMP_Type) SetPUBLISH_READY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetPUBLISH_READY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0xff
}
func (o *LPCOMP_Type) SetPUBLISH_READY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetPUBLISH_READY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0x80000000) >> 31
}

// LPCOMP.PUBLISH_DOWN: Publish configuration for event DOWN
func (o *LPCOMP_Type) SetPUBLISH_DOWN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DOWN.Reg, volatile.LoadUint32(&o.PUBLISH_DOWN.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetPUBLISH_DOWN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_DOWN.Reg) & 0xff
}
func (o *LPCOMP_Type) SetPUBLISH_DOWN_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DOWN.Reg, volatile.LoadUint32(&o.PUBLISH_DOWN.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetPUBLISH_DOWN_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_DOWN.Reg) & 0x80000000) >> 31
}

// LPCOMP.PUBLISH_UP: Publish configuration for event UP
func (o *LPCOMP_Type) SetPUBLISH_UP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_UP.Reg, volatile.LoadUint32(&o.PUBLISH_UP.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetPUBLISH_UP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_UP.Reg) & 0xff
}
func (o *LPCOMP_Type) SetPUBLISH_UP_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_UP.Reg, volatile.LoadUint32(&o.PUBLISH_UP.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetPUBLISH_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_UP.Reg) & 0x80000000) >> 31
}

// LPCOMP.PUBLISH_CROSS: Publish configuration for event CROSS
func (o *LPCOMP_Type) SetPUBLISH_CROSS_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CROSS.Reg, volatile.LoadUint32(&o.PUBLISH_CROSS.Reg)&^(0xff)|value)
}
func (o *LPCOMP_Type) GetPUBLISH_CROSS_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_CROSS.Reg) & 0xff
}
func (o *LPCOMP_Type) SetPUBLISH_CROSS_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_CROSS.Reg, volatile.LoadUint32(&o.PUBLISH_CROSS.Reg)&^(0x80000000)|value<<31)
}
func (o *LPCOMP_Type) GetPUBLISH_CROSS_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_CROSS.Reg) & 0x80000000) >> 31
}

// LPCOMP.SHORTS: Shortcuts between local events and tasks
func (o *LPCOMP_Type) SetSHORTS_READY_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetSHORTS_READY_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *LPCOMP_Type) SetSHORTS_READY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *LPCOMP_Type) GetSHORTS_READY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *LPCOMP_Type) SetSHORTS_DOWN_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *LPCOMP_Type) GetSHORTS_DOWN_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *LPCOMP_Type) SetSHORTS_UP_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *LPCOMP_Type) GetSHORTS_UP_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *LPCOMP_Type) SetSHORTS_CROSS_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *LPCOMP_Type) GetSHORTS_CROSS_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// LPCOMP.INTENSET: Enable interrupt
func (o *LPCOMP_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *LPCOMP_Type) SetINTENSET_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *LPCOMP_Type) GetINTENSET_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *LPCOMP_Type) SetINTENSET_UP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *LPCOMP_Type) GetINTENSET_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *LPCOMP_Type) SetINTENSET_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *LPCOMP_Type) GetINTENSET_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}

// LPCOMP.INTENCLR: Disable interrupt
func (o *LPCOMP_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *LPCOMP_Type) SetINTENCLR_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *LPCOMP_Type) GetINTENCLR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *LPCOMP_Type) SetINTENCLR_UP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *LPCOMP_Type) GetINTENCLR_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *LPCOMP_Type) SetINTENCLR_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *LPCOMP_Type) GetINTENCLR_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}

// LPCOMP.RESULT: Compare result
func (o *LPCOMP_Type) SetRESULT(value uint32) {
	volatile.StoreUint32(&o.RESULT.Reg, volatile.LoadUint32(&o.RESULT.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetRESULT() uint32 {
	return volatile.LoadUint32(&o.RESULT.Reg) & 0x1
}

// LPCOMP.ENABLE: Enable LPCOMP
func (o *LPCOMP_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *LPCOMP_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// LPCOMP.PSEL: Input pin select
func (o *LPCOMP_Type) SetPSEL(value uint32) {
	volatile.StoreUint32(&o.PSEL.Reg, volatile.LoadUint32(&o.PSEL.Reg)&^(0x7)|value)
}
func (o *LPCOMP_Type) GetPSEL() uint32 {
	return volatile.LoadUint32(&o.PSEL.Reg) & 0x7
}

// LPCOMP.REFSEL: Reference select
func (o *LPCOMP_Type) SetREFSEL(value uint32) {
	volatile.StoreUint32(&o.REFSEL.Reg, volatile.LoadUint32(&o.REFSEL.Reg)&^(0xf)|value)
}
func (o *LPCOMP_Type) GetREFSEL() uint32 {
	return volatile.LoadUint32(&o.REFSEL.Reg) & 0xf
}

// LPCOMP.EXTREFSEL: External reference select
func (o *LPCOMP_Type) SetEXTREFSEL(value uint32) {
	volatile.StoreUint32(&o.EXTREFSEL.Reg, volatile.LoadUint32(&o.EXTREFSEL.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetEXTREFSEL() uint32 {
	return volatile.LoadUint32(&o.EXTREFSEL.Reg) & 0x1
}

// LPCOMP.ANADETECT: Analog detect configuration
func (o *LPCOMP_Type) SetANADETECT(value uint32) {
	volatile.StoreUint32(&o.ANADETECT.Reg, volatile.LoadUint32(&o.ANADETECT.Reg)&^(0x3)|value)
}
func (o *LPCOMP_Type) GetANADETECT() uint32 {
	return volatile.LoadUint32(&o.ANADETECT.Reg) & 0x3
}

// LPCOMP.HYST: Comparator hysteresis enable
func (o *LPCOMP_Type) SetHYST(value uint32) {
	volatile.StoreUint32(&o.HYST.Reg, volatile.LoadUint32(&o.HYST.Reg)&^(0x1)|value)
}
func (o *LPCOMP_Type) GetHYST() uint32 {
	return volatile.LoadUint32(&o.HYST.Reg) & 0x1
}

// Event generator unit 0
type EGU_Type struct {
	TASKS_TRIGGER     [16]volatile.Register32 // 0x0
	_                 [64]byte
	SUBSCRIBE_TRIGGER [16]volatile.Register32 // 0x80
	_                 [64]byte
	EVENTS_TRIGGERED  [16]volatile.Register32 // 0x100
	_                 [64]byte
	PUBLISH_TRIGGERED [16]volatile.Register32 // 0x180
	_                 [320]byte
	INTEN             volatile.Register32 // 0x300
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
}

// EGU.TASKS_TRIGGER: Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
func (o *EGU_Type) SetTASKS_TRIGGER(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_TRIGGER[idx].Reg, volatile.LoadUint32(&o.TASKS_TRIGGER[idx].Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetTASKS_TRIGGER(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_TRIGGER[idx].Reg) & 0x1
}

// EGU.SUBSCRIBE_TRIGGER: Description collection: Subscribe configuration for task TRIGGER[n]
func (o *EGU_Type) SetSUBSCRIBE_TRIGGER_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_TRIGGER[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_TRIGGER[idx].Reg)&^(0xff)|value)
}
func (o *EGU_Type) GetSUBSCRIBE_TRIGGER_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_TRIGGER[idx].Reg) & 0xff
}
func (o *EGU_Type) SetSUBSCRIBE_TRIGGER_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_TRIGGER[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_TRIGGER[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *EGU_Type) GetSUBSCRIBE_TRIGGER_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_TRIGGER[idx].Reg) & 0x80000000) >> 31
}

// EGU.EVENTS_TRIGGERED: Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
func (o *EGU_Type) SetEVENTS_TRIGGERED(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_TRIGGERED[idx].Reg, volatile.LoadUint32(&o.EVENTS_TRIGGERED[idx].Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetEVENTS_TRIGGERED(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_TRIGGERED[idx].Reg) & 0x1
}

// EGU.PUBLISH_TRIGGERED: Description collection: Publish configuration for event TRIGGERED[n]
func (o *EGU_Type) SetPUBLISH_TRIGGERED_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TRIGGERED[idx].Reg, volatile.LoadUint32(&o.PUBLISH_TRIGGERED[idx].Reg)&^(0xff)|value)
}
func (o *EGU_Type) GetPUBLISH_TRIGGERED_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TRIGGERED[idx].Reg) & 0xff
}
func (o *EGU_Type) SetPUBLISH_TRIGGERED_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TRIGGERED[idx].Reg, volatile.LoadUint32(&o.PUBLISH_TRIGGERED[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *EGU_Type) GetPUBLISH_TRIGGERED_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TRIGGERED[idx].Reg) & 0x80000000) >> 31
}

// EGU.INTEN: Enable or disable interrupt
func (o *EGU_Type) SetINTEN_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTEN_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *EGU_Type) SetINTEN_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTEN_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTEN_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTEN_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTEN_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTEN_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTEN_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTEN_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTEN_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTEN_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTEN_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTEN_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTEN_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTEN_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTEN_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTEN_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTEN_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTEN_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTEN_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTEN_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTEN_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTEN_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTEN_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTEN_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTEN_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTEN_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTEN_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTEN_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTEN_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTEN_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}

// EGU.INTENSET: Enable interrupt
func (o *EGU_Type) SetINTENSET_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *EGU_Type) SetINTENSET_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTENSET_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTENSET_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTENSET_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTENSET_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTENSET_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTENSET_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTENSET_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTENSET_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTENSET_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTENSET_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTENSET_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTENSET_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTENSET_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTENSET_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}

// EGU.INTENCLR: Disable interrupt
func (o *EGU_Type) SetINTENCLR_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// Pulse width modulation unit 0
type PWM_Type struct {
	_                    [4]byte
	TASKS_STOP           volatile.Register32    // 0x4
	TASKS_SEQSTART       [2]volatile.Register32 // 0x8
	TASKS_NEXTSTEP       volatile.Register32    // 0x10
	_                    [112]byte
	SUBSCRIBE_STOP       volatile.Register32    // 0x84
	SUBSCRIBE_SEQSTART   [2]volatile.Register32 // 0x88
	SUBSCRIBE_NEXTSTEP   volatile.Register32    // 0x90
	_                    [112]byte
	EVENTS_STOPPED       volatile.Register32    // 0x104
	EVENTS_SEQSTARTED    [2]volatile.Register32 // 0x108
	EVENTS_SEQEND        [2]volatile.Register32 // 0x110
	EVENTS_PWMPERIODEND  volatile.Register32    // 0x118
	EVENTS_LOOPSDONE     volatile.Register32    // 0x11C
	_                    [100]byte
	PUBLISH_STOPPED      volatile.Register32    // 0x184
	PUBLISH_SEQSTARTED   [2]volatile.Register32 // 0x188
	PUBLISH_SEQEND       [2]volatile.Register32 // 0x190
	PUBLISH_PWMPERIODEND volatile.Register32    // 0x198
	PUBLISH_LOOPSDONE    volatile.Register32    // 0x19C
	_                    [96]byte
	SHORTS               volatile.Register32 // 0x200
	_                    [252]byte
	INTEN                volatile.Register32 // 0x300
	INTENSET             volatile.Register32 // 0x304
	INTENCLR             volatile.Register32 // 0x308
	_                    [500]byte
	ENABLE               volatile.Register32 // 0x500
	MODE                 volatile.Register32 // 0x504
	COUNTERTOP           volatile.Register32 // 0x508
	PRESCALER            volatile.Register32 // 0x50C
	DECODER              volatile.Register32 // 0x510
	LOOP                 volatile.Register32 // 0x514
	_                    [8]byte
	SEQ                  [2]PWM_SEQ_Type // 0x520
	PSEL                 PWM_PSEL_Type   // 0x560
}

// PWM.TASKS_STOP: Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
func (o *PWM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// PWM.TASKS_SEQSTART: Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
func (o *PWM_Type) SetTASKS_SEQSTART(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_SEQSTART[idx].Reg, volatile.LoadUint32(&o.TASKS_SEQSTART[idx].Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetTASKS_SEQSTART(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_SEQSTART[idx].Reg) & 0x1
}

// PWM.TASKS_NEXTSTEP: Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
func (o *PWM_Type) SetTASKS_NEXTSTEP(value uint32) {
	volatile.StoreUint32(&o.TASKS_NEXTSTEP.Reg, volatile.LoadUint32(&o.TASKS_NEXTSTEP.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetTASKS_NEXTSTEP() uint32 {
	return volatile.LoadUint32(&o.TASKS_NEXTSTEP.Reg) & 0x1
}

// PWM.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *PWM_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *PWM_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// PWM.SUBSCRIBE_SEQSTART: Description collection: Subscribe configuration for task SEQSTART[n]
func (o *PWM_Type) SetSUBSCRIBE_SEQSTART_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SEQSTART[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_SEQSTART[idx].Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSUBSCRIBE_SEQSTART_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SEQSTART[idx].Reg) & 0xff
}
func (o *PWM_Type) SetSUBSCRIBE_SEQSTART_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SEQSTART[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_SEQSTART[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetSUBSCRIBE_SEQSTART_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SEQSTART[idx].Reg) & 0x80000000) >> 31
}

// PWM.SUBSCRIBE_NEXTSTEP: Subscribe configuration for task NEXTSTEP
func (o *PWM_Type) SetSUBSCRIBE_NEXTSTEP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_NEXTSTEP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_NEXTSTEP.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSUBSCRIBE_NEXTSTEP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_NEXTSTEP.Reg) & 0xff
}
func (o *PWM_Type) SetSUBSCRIBE_NEXTSTEP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_NEXTSTEP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_NEXTSTEP.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetSUBSCRIBE_NEXTSTEP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_NEXTSTEP.Reg) & 0x80000000) >> 31
}

// PWM.EVENTS_STOPPED: Response to STOP task, emitted when PWM pulses are no longer generated
func (o *PWM_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// PWM.EVENTS_SEQSTARTED: Description collection: First PWM period started on sequence n
func (o *PWM_Type) SetEVENTS_SEQSTARTED(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_SEQSTARTED[idx].Reg, volatile.LoadUint32(&o.EVENTS_SEQSTARTED[idx].Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetEVENTS_SEQSTARTED(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_SEQSTARTED[idx].Reg) & 0x1
}

// PWM.EVENTS_SEQEND: Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
func (o *PWM_Type) SetEVENTS_SEQEND(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_SEQEND[idx].Reg, volatile.LoadUint32(&o.EVENTS_SEQEND[idx].Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetEVENTS_SEQEND(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_SEQEND[idx].Reg) & 0x1
}

// PWM.EVENTS_PWMPERIODEND: Emitted at the end of each PWM period
func (o *PWM_Type) SetEVENTS_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.EVENTS_PWMPERIODEND.Reg, volatile.LoadUint32(&o.EVENTS_PWMPERIODEND.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetEVENTS_PWMPERIODEND() uint32 {
	return volatile.LoadUint32(&o.EVENTS_PWMPERIODEND.Reg) & 0x1
}

// PWM.EVENTS_LOOPSDONE: Concatenated sequences have been played the amount of times defined in LOOP.CNT
func (o *PWM_Type) SetEVENTS_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LOOPSDONE.Reg, volatile.LoadUint32(&o.EVENTS_LOOPSDONE.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetEVENTS_LOOPSDONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LOOPSDONE.Reg) & 0x1
}

// PWM.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *PWM_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *PWM_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// PWM.PUBLISH_SEQSTARTED: Description collection: Publish configuration for event SEQSTARTED[n]
func (o *PWM_Type) SetPUBLISH_SEQSTARTED_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SEQSTARTED[idx].Reg, volatile.LoadUint32(&o.PUBLISH_SEQSTARTED[idx].Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetPUBLISH_SEQSTARTED_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SEQSTARTED[idx].Reg) & 0xff
}
func (o *PWM_Type) SetPUBLISH_SEQSTARTED_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SEQSTARTED[idx].Reg, volatile.LoadUint32(&o.PUBLISH_SEQSTARTED[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetPUBLISH_SEQSTARTED_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SEQSTARTED[idx].Reg) & 0x80000000) >> 31
}

// PWM.PUBLISH_SEQEND: Description collection: Publish configuration for event SEQEND[n]
func (o *PWM_Type) SetPUBLISH_SEQEND_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SEQEND[idx].Reg, volatile.LoadUint32(&o.PUBLISH_SEQEND[idx].Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetPUBLISH_SEQEND_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SEQEND[idx].Reg) & 0xff
}
func (o *PWM_Type) SetPUBLISH_SEQEND_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SEQEND[idx].Reg, volatile.LoadUint32(&o.PUBLISH_SEQEND[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetPUBLISH_SEQEND_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SEQEND[idx].Reg) & 0x80000000) >> 31
}

// PWM.PUBLISH_PWMPERIODEND: Publish configuration for event PWMPERIODEND
func (o *PWM_Type) SetPUBLISH_PWMPERIODEND_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_PWMPERIODEND.Reg, volatile.LoadUint32(&o.PUBLISH_PWMPERIODEND.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetPUBLISH_PWMPERIODEND_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_PWMPERIODEND.Reg) & 0xff
}
func (o *PWM_Type) SetPUBLISH_PWMPERIODEND_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_PWMPERIODEND.Reg, volatile.LoadUint32(&o.PUBLISH_PWMPERIODEND.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetPUBLISH_PWMPERIODEND_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_PWMPERIODEND.Reg) & 0x80000000) >> 31
}

// PWM.PUBLISH_LOOPSDONE: Publish configuration for event LOOPSDONE
func (o *PWM_Type) SetPUBLISH_LOOPSDONE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LOOPSDONE.Reg, volatile.LoadUint32(&o.PUBLISH_LOOPSDONE.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetPUBLISH_LOOPSDONE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_LOOPSDONE.Reg) & 0xff
}
func (o *PWM_Type) SetPUBLISH_LOOPSDONE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_LOOPSDONE.Reg, volatile.LoadUint32(&o.PUBLISH_LOOPSDONE.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetPUBLISH_LOOPSDONE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_LOOPSDONE.Reg) & 0x80000000) >> 31
}

// PWM.SHORTS: Shortcuts between local events and tasks
func (o *PWM_Type) SetSHORTS_SEQEND0_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSHORTS_SEQEND0_STOP() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *PWM_Type) SetSHORTS_SEQEND1_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSHORTS_SEQEND1_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSHORTS_LOOPSDONE_SEQSTART0(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSHORTS_LOOPSDONE_SEQSTART0() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSHORTS_LOOPSDONE_SEQSTART1(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSHORTS_LOOPSDONE_SEQSTART1() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSHORTS_LOOPSDONE_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSHORTS_LOOPSDONE_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// PWM.INTEN: Enable or disable interrupt
func (o *PWM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTEN_SEQSTARTED0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTEN_SEQSTARTED0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTEN_SEQSTARTED1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTEN_SEQSTARTED1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTEN_SEQEND0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTEN_SEQEND0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTEN_SEQEND1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTEN_SEQEND1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTEN_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTEN_PWMPERIODEND() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTEN_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTEN_LOOPSDONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}

// PWM.INTENSET: Enable interrupt
func (o *PWM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTENSET_SEQSTARTED0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTENSET_SEQSTARTED0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTENSET_SEQSTARTED1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTENSET_SEQSTARTED1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTENSET_SEQEND0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTENSET_SEQEND0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTENSET_SEQEND1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTENSET_SEQEND1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTENSET_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTENSET_PWMPERIODEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTENSET_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTENSET_LOOPSDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}

// PWM.INTENCLR: Disable interrupt
func (o *PWM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTENCLR_SEQSTARTED0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTENCLR_SEQSTARTED0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTENCLR_SEQSTARTED1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTENCLR_SEQSTARTED1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTENCLR_SEQEND0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTENCLR_SEQEND0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTENCLR_SEQEND1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTENCLR_SEQEND1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTENCLR_PWMPERIODEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTENCLR_PWMPERIODEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTENCLR_LOOPSDONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTENCLR_LOOPSDONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}

// PWM.ENABLE: PWM module enable register
func (o *PWM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// PWM.MODE: Selects operating mode of the wave counter
func (o *PWM_Type) SetMODE_UPDOWN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetMODE_UPDOWN() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}

// PWM.COUNTERTOP: Value up to which the pulse generator counter counts
func (o *PWM_Type) SetCOUNTERTOP(value uint32) {
	volatile.StoreUint32(&o.COUNTERTOP.Reg, volatile.LoadUint32(&o.COUNTERTOP.Reg)&^(0x7fff)|value)
}
func (o *PWM_Type) GetCOUNTERTOP() uint32 {
	return volatile.LoadUint32(&o.COUNTERTOP.Reg) & 0x7fff
}

// PWM.PRESCALER: Configuration for PWM_CLK
func (o *PWM_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0x7)|value)
}
func (o *PWM_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0x7
}

// PWM.DECODER: Configuration of the decoder
func (o *PWM_Type) SetDECODER_LOAD(value uint32) {
	volatile.StoreUint32(&o.DECODER.Reg, volatile.LoadUint32(&o.DECODER.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetDECODER_LOAD() uint32 {
	return volatile.LoadUint32(&o.DECODER.Reg) & 0x3
}
func (o *PWM_Type) SetDECODER_MODE(value uint32) {
	volatile.StoreUint32(&o.DECODER.Reg, volatile.LoadUint32(&o.DECODER.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetDECODER_MODE() uint32 {
	return (volatile.LoadUint32(&o.DECODER.Reg) & 0x100) >> 8
}

// PWM.LOOP: Number of playbacks of a loop
func (o *PWM_Type) SetLOOP_CNT(value uint32) {
	volatile.StoreUint32(&o.LOOP.Reg, volatile.LoadUint32(&o.LOOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetLOOP_CNT() uint32 {
	return volatile.LoadUint32(&o.LOOP.Reg) & 0xffff
}

type PWM_SEQ_Type struct {
	PTR      volatile.Register32 // 0x520
	CNT      volatile.Register32 // 0x524
	REFRESH  volatile.Register32 // 0x528
	ENDDELAY volatile.Register32 // 0x52C
	_        [16]byte
}

// PWM_SEQ.PTR: Description cluster: Beginning address in RAM of this sequence
func (o *PWM_SEQ_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *PWM_SEQ_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// PWM_SEQ.CNT: Description cluster: Number of values (duty cycles) in this sequence
func (o *PWM_SEQ_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x7fff)|value)
}
func (o *PWM_SEQ_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0x7fff
}

// PWM_SEQ.REFRESH: Description cluster: Number of additional PWM periods between samples loaded into compare register
func (o *PWM_SEQ_Type) SetREFRESH_CNT(value uint32) {
	volatile.StoreUint32(&o.REFRESH.Reg, volatile.LoadUint32(&o.REFRESH.Reg)&^(0xffffff)|value)
}
func (o *PWM_SEQ_Type) GetREFRESH_CNT() uint32 {
	return volatile.LoadUint32(&o.REFRESH.Reg) & 0xffffff
}

// PWM_SEQ.ENDDELAY: Description cluster: Time added after the sequence
func (o *PWM_SEQ_Type) SetENDDELAY_CNT(value uint32) {
	volatile.StoreUint32(&o.ENDDELAY.Reg, volatile.LoadUint32(&o.ENDDELAY.Reg)&^(0xffffff)|value)
}
func (o *PWM_SEQ_Type) GetENDDELAY_CNT() uint32 {
	return volatile.LoadUint32(&o.ENDDELAY.Reg) & 0xffffff
}

type PWM_PSEL_Type struct {
	OUT [4]volatile.Register32 // 0x560
}

// Pulse Density Modulation (Digital Microphone) Interface 0
type PDM_Type struct {
	TASKS_START     volatile.Register32 // 0x0
	TASKS_STOP      volatile.Register32 // 0x4
	_               [120]byte
	SUBSCRIBE_START volatile.Register32 // 0x80
	SUBSCRIBE_STOP  volatile.Register32 // 0x84
	_               [120]byte
	EVENTS_STARTED  volatile.Register32 // 0x100
	EVENTS_STOPPED  volatile.Register32 // 0x104
	EVENTS_END      volatile.Register32 // 0x108
	_               [116]byte
	PUBLISH_STARTED volatile.Register32 // 0x180
	PUBLISH_STOPPED volatile.Register32 // 0x184
	PUBLISH_END     volatile.Register32 // 0x188
	_               [372]byte
	INTEN           volatile.Register32 // 0x300
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [500]byte
	ENABLE          volatile.Register32 // 0x500
	PDMCLKCTRL      volatile.Register32 // 0x504
	MODE            volatile.Register32 // 0x508
	_               [12]byte
	GAINL           volatile.Register32 // 0x518
	GAINR           volatile.Register32 // 0x51C
	RATIO           volatile.Register32 // 0x520
	_               [28]byte
	PSEL            PDM_PSEL_Type // 0x540
	_               [4]byte
	MCLKCONFIG      volatile.Register32 // 0x54C
	_               [16]byte
	SAMPLE          PDM_SAMPLE_Type // 0x560
}

// PDM.TASKS_START: Starts continuous PDM transfer
func (o *PDM_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// PDM.TASKS_STOP: Stops PDM transfer
func (o *PDM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// PDM.SUBSCRIBE_START: Subscribe configuration for task START
func (o *PDM_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *PDM_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *PDM_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// PDM.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *PDM_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *PDM_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *PDM_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// PDM.EVENTS_STARTED: PDM transfer has started
func (o *PDM_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// PDM.EVENTS_STOPPED: PDM transfer has finished
func (o *PDM_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// PDM.EVENTS_END: The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
func (o *PDM_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// PDM.PUBLISH_STARTED: Publish configuration for event STARTED
func (o *PDM_Type) SetPUBLISH_STARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0xff)|value)
}
func (o *PDM_Type) GetPUBLISH_STARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0xff
}
func (o *PDM_Type) SetPUBLISH_STARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_Type) GetPUBLISH_STARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0x80000000) >> 31
}

// PDM.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *PDM_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *PDM_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *PDM_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// PDM.PUBLISH_END: Publish configuration for event END
func (o *PDM_Type) SetPUBLISH_END_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0xff)|value)
}
func (o *PDM_Type) GetPUBLISH_END_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0xff
}
func (o *PDM_Type) SetPUBLISH_END_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_END.Reg, volatile.LoadUint32(&o.PUBLISH_END.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_Type) GetPUBLISH_END_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_END.Reg) & 0x80000000) >> 31
}

// PDM.INTEN: Enable or disable interrupt
func (o *PDM_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetINTEN_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *PDM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *PDM_Type) SetINTEN_END(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *PDM_Type) GetINTEN_END() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}

// PDM.INTENSET: Enable interrupt
func (o *PDM_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetINTENSET_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *PDM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *PDM_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *PDM_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// PDM.INTENCLR: Disable interrupt
func (o *PDM_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetINTENCLR_STARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *PDM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *PDM_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PDM_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// PDM.ENABLE: PDM module enable register
func (o *PDM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// PDM.PDMCLKCTRL: PDM clock generator control
func (o *PDM_Type) SetPDMCLKCTRL(value uint32) {
	volatile.StoreUint32(&o.PDMCLKCTRL.Reg, value)
}
func (o *PDM_Type) GetPDMCLKCTRL() uint32 {
	return volatile.LoadUint32(&o.PDMCLKCTRL.Reg)
}

// PDM.MODE: Defines the routing of the connected PDM microphones' signals
func (o *PDM_Type) SetMODE_OPERATION(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetMODE_OPERATION() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *PDM_Type) SetMODE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x2)|value<<1)
}
func (o *PDM_Type) GetMODE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x2) >> 1
}

// PDM.GAINL: Left output gain adjustment
func (o *PDM_Type) SetGAINL(value uint32) {
	volatile.StoreUint32(&o.GAINL.Reg, volatile.LoadUint32(&o.GAINL.Reg)&^(0x7f)|value)
}
func (o *PDM_Type) GetGAINL() uint32 {
	return volatile.LoadUint32(&o.GAINL.Reg) & 0x7f
}

// PDM.GAINR: Right output gain adjustment
func (o *PDM_Type) SetGAINR(value uint32) {
	volatile.StoreUint32(&o.GAINR.Reg, volatile.LoadUint32(&o.GAINR.Reg)&^(0x7f)|value)
}
func (o *PDM_Type) GetGAINR() uint32 {
	return volatile.LoadUint32(&o.GAINR.Reg) & 0x7f
}

// PDM.RATIO: Selects the ratio between PDM_CLK and output sample rate. Change PDMCLKCTRL accordingly.
func (o *PDM_Type) SetRATIO(value uint32) {
	volatile.StoreUint32(&o.RATIO.Reg, volatile.LoadUint32(&o.RATIO.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetRATIO() uint32 {
	return volatile.LoadUint32(&o.RATIO.Reg) & 0x1
}

// PDM.MCLKCONFIG: Master clock generator configuration
func (o *PDM_Type) SetMCLKCONFIG_SRC(value uint32) {
	volatile.StoreUint32(&o.MCLKCONFIG.Reg, volatile.LoadUint32(&o.MCLKCONFIG.Reg)&^(0x1)|value)
}
func (o *PDM_Type) GetMCLKCONFIG_SRC() uint32 {
	return volatile.LoadUint32(&o.MCLKCONFIG.Reg) & 0x1
}

type PDM_PSEL_Type struct {
	CLK volatile.Register32 // 0x540
	DIN volatile.Register32 // 0x544
}

// PDM_PSEL.CLK: Pin number configuration for PDM CLK signal
func (o *PDM_PSEL_Type) SetCLK_PIN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1f)|value)
}
func (o *PDM_PSEL_Type) GetCLK_PIN() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1f
}
func (o *PDM_PSEL_Type) SetCLK_PORT(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x20)|value<<5)
}
func (o *PDM_PSEL_Type) GetCLK_PORT() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x20) >> 5
}
func (o *PDM_PSEL_Type) SetCLK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_PSEL_Type) GetCLK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x80000000) >> 31
}

// PDM_PSEL.DIN: Pin number configuration for PDM DIN signal
func (o *PDM_PSEL_Type) SetDIN_PIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, volatile.LoadUint32(&o.DIN.Reg)&^(0x1f)|value)
}
func (o *PDM_PSEL_Type) GetDIN_PIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg) & 0x1f
}
func (o *PDM_PSEL_Type) SetDIN_PORT(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, volatile.LoadUint32(&o.DIN.Reg)&^(0x20)|value<<5)
}
func (o *PDM_PSEL_Type) GetDIN_PORT() uint32 {
	return (volatile.LoadUint32(&o.DIN.Reg) & 0x20) >> 5
}
func (o *PDM_PSEL_Type) SetDIN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, volatile.LoadUint32(&o.DIN.Reg)&^(0x80000000)|value<<31)
}
func (o *PDM_PSEL_Type) GetDIN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.DIN.Reg) & 0x80000000) >> 31
}

type PDM_SAMPLE_Type struct {
	PTR    volatile.Register32 // 0x560
	MAXCNT volatile.Register32 // 0x564
}

// PDM_SAMPLE.PTR: RAM address pointer to write samples to with EasyDMA
func (o *PDM_SAMPLE_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *PDM_SAMPLE_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// PDM_SAMPLE.MAXCNT: Number of samples to allocate memory for in EasyDMA mode
func (o *PDM_SAMPLE_Type) SetMAXCNT_BUFFSIZE(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *PDM_SAMPLE_Type) GetMAXCNT_BUFFSIZE() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// Inter-IC Sound 0
type I2S_Type struct {
	TASKS_START        volatile.Register32 // 0x0
	TASKS_STOP         volatile.Register32 // 0x4
	_                  [120]byte
	SUBSCRIBE_START    volatile.Register32 // 0x80
	SUBSCRIBE_STOP     volatile.Register32 // 0x84
	_                  [124]byte
	EVENTS_RXPTRUPD    volatile.Register32 // 0x104
	EVENTS_STOPPED     volatile.Register32 // 0x108
	_                  [8]byte
	EVENTS_TXPTRUPD    volatile.Register32 // 0x114
	_                  [4]byte
	EVENTS_FRAMESTART  volatile.Register32 // 0x11C
	_                  [100]byte
	PUBLISH_RXPTRUPD   volatile.Register32 // 0x184
	PUBLISH_STOPPED    volatile.Register32 // 0x188
	_                  [8]byte
	PUBLISH_TXPTRUPD   volatile.Register32 // 0x194
	_                  [4]byte
	PUBLISH_FRAMESTART volatile.Register32 // 0x19C
	_                  [352]byte
	INTEN              volatile.Register32 // 0x300
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [500]byte
	ENABLE             volatile.Register32 // 0x500
	CONFIG             I2S_CONFIG_Type     // 0x504
	_                  [8]byte
	RXD                I2S_RXD_Type // 0x538
	_                  [4]byte
	TXD                I2S_TXD_Type // 0x540
	_                  [12]byte
	RXTXD              I2S_RXTXD_Type // 0x550
	_                  [12]byte
	PSEL               I2S_PSEL_Type // 0x560
}

// I2S.TASKS_START: Starts continuous I2S transfer. Also starts MCK generator when this is enabled
func (o *I2S_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// I2S.TASKS_STOP: Stops I2S transfer and MCK generator. Triggering this task will cause the event STOPPED to be generated.
func (o *I2S_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// I2S.SUBSCRIBE_START: Subscribe configuration for task START
func (o *I2S_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *I2S_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// I2S.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *I2S_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *I2S_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// I2S.EVENTS_RXPTRUPD: The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words received on the SDIN pin.
func (o *I2S_Type) SetEVENTS_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXPTRUPD.Reg, volatile.LoadUint32(&o.EVENTS_RXPTRUPD.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetEVENTS_RXPTRUPD() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXPTRUPD.Reg) & 0x1
}

// I2S.EVENTS_STOPPED: I2S transfer stopped.
func (o *I2S_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// I2S.EVENTS_TXPTRUPD: The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
func (o *I2S_Type) SetEVENTS_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXPTRUPD.Reg, volatile.LoadUint32(&o.EVENTS_TXPTRUPD.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetEVENTS_TXPTRUPD() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXPTRUPD.Reg) & 0x1
}

// I2S.EVENTS_FRAMESTART: Frame start event, generated on the active edge of LRCK
func (o *I2S_Type) SetEVENTS_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.EVENTS_FRAMESTART.Reg, volatile.LoadUint32(&o.EVENTS_FRAMESTART.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetEVENTS_FRAMESTART() uint32 {
	return volatile.LoadUint32(&o.EVENTS_FRAMESTART.Reg) & 0x1
}

// I2S.PUBLISH_RXPTRUPD: Publish configuration for event RXPTRUPD
func (o *I2S_Type) SetPUBLISH_RXPTRUPD_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXPTRUPD.Reg, volatile.LoadUint32(&o.PUBLISH_RXPTRUPD.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetPUBLISH_RXPTRUPD_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXPTRUPD.Reg) & 0xff
}
func (o *I2S_Type) SetPUBLISH_RXPTRUPD_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXPTRUPD.Reg, volatile.LoadUint32(&o.PUBLISH_RXPTRUPD.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetPUBLISH_RXPTRUPD_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXPTRUPD.Reg) & 0x80000000) >> 31
}

// I2S.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *I2S_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *I2S_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// I2S.PUBLISH_TXPTRUPD: Publish configuration for event TXPTRUPD
func (o *I2S_Type) SetPUBLISH_TXPTRUPD_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXPTRUPD.Reg, volatile.LoadUint32(&o.PUBLISH_TXPTRUPD.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetPUBLISH_TXPTRUPD_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXPTRUPD.Reg) & 0xff
}
func (o *I2S_Type) SetPUBLISH_TXPTRUPD_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXPTRUPD.Reg, volatile.LoadUint32(&o.PUBLISH_TXPTRUPD.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetPUBLISH_TXPTRUPD_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXPTRUPD.Reg) & 0x80000000) >> 31
}

// I2S.PUBLISH_FRAMESTART: Publish configuration for event FRAMESTART
func (o *I2S_Type) SetPUBLISH_FRAMESTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FRAMESTART.Reg, volatile.LoadUint32(&o.PUBLISH_FRAMESTART.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetPUBLISH_FRAMESTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_FRAMESTART.Reg) & 0xff
}
func (o *I2S_Type) SetPUBLISH_FRAMESTART_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FRAMESTART.Reg, volatile.LoadUint32(&o.PUBLISH_FRAMESTART.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetPUBLISH_FRAMESTART_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_FRAMESTART.Reg) & 0x80000000) >> 31
}

// I2S.INTEN: Enable or disable interrupt
func (o *I2S_Type) SetINTEN_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTEN_RXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINTEN_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTEN_TXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINTEN_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINTEN_FRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}

// I2S.INTENSET: Enable interrupt
func (o *I2S_Type) SetINTENSET_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTENSET_RXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINTENSET_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTENSET_TXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINTENSET_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINTENSET_FRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}

// I2S.INTENCLR: Disable interrupt
func (o *I2S_Type) SetINTENCLR_RXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTENCLR_RXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINTENCLR_TXPTRUPD(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTENCLR_TXPTRUPD() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINTENCLR_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINTENCLR_FRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}

// I2S.ENABLE: Enable I2S module
func (o *I2S_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

type I2S_CONFIG_Type struct {
	MODE      volatile.Register32 // 0x504
	RXEN      volatile.Register32 // 0x508
	TXEN      volatile.Register32 // 0x50C
	MCKEN     volatile.Register32 // 0x510
	MCKFREQ   volatile.Register32 // 0x514
	RATIO     volatile.Register32 // 0x518
	SWIDTH    volatile.Register32 // 0x51C
	ALIGN     volatile.Register32 // 0x520
	FORMAT    volatile.Register32 // 0x524
	CHANNELS  volatile.Register32 // 0x528
	CLKCONFIG volatile.Register32 // 0x52C
}

// I2S_CONFIG.MODE: I2S mode
func (o *I2S_CONFIG_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}

// I2S_CONFIG.RXEN: Reception (RX) enable
func (o *I2S_CONFIG_Type) SetRXEN(value uint32) {
	volatile.StoreUint32(&o.RXEN.Reg, volatile.LoadUint32(&o.RXEN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetRXEN() uint32 {
	return volatile.LoadUint32(&o.RXEN.Reg) & 0x1
}

// I2S_CONFIG.TXEN: Transmission (TX) enable
func (o *I2S_CONFIG_Type) SetTXEN(value uint32) {
	volatile.StoreUint32(&o.TXEN.Reg, volatile.LoadUint32(&o.TXEN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetTXEN() uint32 {
	return volatile.LoadUint32(&o.TXEN.Reg) & 0x1
}

// I2S_CONFIG.MCKEN: Master clock generator enable
func (o *I2S_CONFIG_Type) SetMCKEN(value uint32) {
	volatile.StoreUint32(&o.MCKEN.Reg, volatile.LoadUint32(&o.MCKEN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetMCKEN() uint32 {
	return volatile.LoadUint32(&o.MCKEN.Reg) & 0x1
}

// I2S_CONFIG.MCKFREQ: I2S clock generator control
func (o *I2S_CONFIG_Type) SetMCKFREQ(value uint32) {
	volatile.StoreUint32(&o.MCKFREQ.Reg, value)
}
func (o *I2S_CONFIG_Type) GetMCKFREQ() uint32 {
	return volatile.LoadUint32(&o.MCKFREQ.Reg)
}

// I2S_CONFIG.RATIO: MCK / LRCK ratio
func (o *I2S_CONFIG_Type) SetRATIO(value uint32) {
	volatile.StoreUint32(&o.RATIO.Reg, volatile.LoadUint32(&o.RATIO.Reg)&^(0xf)|value)
}
func (o *I2S_CONFIG_Type) GetRATIO() uint32 {
	return volatile.LoadUint32(&o.RATIO.Reg) & 0xf
}

// I2S_CONFIG.SWIDTH: Sample width
func (o *I2S_CONFIG_Type) SetSWIDTH(value uint32) {
	volatile.StoreUint32(&o.SWIDTH.Reg, volatile.LoadUint32(&o.SWIDTH.Reg)&^(0x7)|value)
}
func (o *I2S_CONFIG_Type) GetSWIDTH() uint32 {
	return volatile.LoadUint32(&o.SWIDTH.Reg) & 0x7
}

// I2S_CONFIG.ALIGN: Alignment of sample within a frame
func (o *I2S_CONFIG_Type) SetALIGN(value uint32) {
	volatile.StoreUint32(&o.ALIGN.Reg, volatile.LoadUint32(&o.ALIGN.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetALIGN() uint32 {
	return volatile.LoadUint32(&o.ALIGN.Reg) & 0x1
}

// I2S_CONFIG.FORMAT: Frame format
func (o *I2S_CONFIG_Type) SetFORMAT(value uint32) {
	volatile.StoreUint32(&o.FORMAT.Reg, volatile.LoadUint32(&o.FORMAT.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetFORMAT() uint32 {
	return volatile.LoadUint32(&o.FORMAT.Reg) & 0x1
}

// I2S_CONFIG.CHANNELS: Enable channels
func (o *I2S_CONFIG_Type) SetCHANNELS(value uint32) {
	volatile.StoreUint32(&o.CHANNELS.Reg, volatile.LoadUint32(&o.CHANNELS.Reg)&^(0x3)|value)
}
func (o *I2S_CONFIG_Type) GetCHANNELS() uint32 {
	return volatile.LoadUint32(&o.CHANNELS.Reg) & 0x3
}

// I2S_CONFIG.CLKCONFIG: Clock source selection for the I2S module
func (o *I2S_CONFIG_Type) SetCLKCONFIG_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.CLKCONFIG.Reg, volatile.LoadUint32(&o.CLKCONFIG.Reg)&^(0x1)|value)
}
func (o *I2S_CONFIG_Type) GetCLKCONFIG_CLKSRC() uint32 {
	return volatile.LoadUint32(&o.CLKCONFIG.Reg) & 0x1
}
func (o *I2S_CONFIG_Type) SetCLKCONFIG_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CLKCONFIG.Reg, volatile.LoadUint32(&o.CLKCONFIG.Reg)&^(0x100)|value<<8)
}
func (o *I2S_CONFIG_Type) GetCLKCONFIG_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CLKCONFIG.Reg) & 0x100) >> 8
}

type I2S_RXD_Type struct {
	PTR volatile.Register32 // 0x538
}

// I2S_RXD.PTR: Receive buffer RAM start address.
func (o *I2S_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *I2S_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

type I2S_TXD_Type struct {
	PTR volatile.Register32 // 0x540
}

// I2S_TXD.PTR: Transmit buffer RAM start address
func (o *I2S_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *I2S_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

type I2S_RXTXD_Type struct {
	MAXCNT volatile.Register32 // 0x550
}

// I2S_RXTXD.MAXCNT: Size of RXD and TXD buffers
func (o *I2S_RXTXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3fff)|value)
}
func (o *I2S_RXTXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3fff
}

type I2S_PSEL_Type struct {
	MCK   volatile.Register32 // 0x560
	SCK   volatile.Register32 // 0x564
	LRCK  volatile.Register32 // 0x568
	SDIN  volatile.Register32 // 0x56C
	SDOUT volatile.Register32 // 0x570
}

// I2S_PSEL.MCK: Pin select for MCK signal
func (o *I2S_PSEL_Type) SetMCK_PIN(value uint32) {
	volatile.StoreUint32(&o.MCK.Reg, volatile.LoadUint32(&o.MCK.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetMCK_PIN() uint32 {
	return volatile.LoadUint32(&o.MCK.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetMCK_PORT(value uint32) {
	volatile.StoreUint32(&o.MCK.Reg, volatile.LoadUint32(&o.MCK.Reg)&^(0x20)|value<<5)
}
func (o *I2S_PSEL_Type) GetMCK_PORT() uint32 {
	return (volatile.LoadUint32(&o.MCK.Reg) & 0x20) >> 5
}
func (o *I2S_PSEL_Type) SetMCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MCK.Reg, volatile.LoadUint32(&o.MCK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetMCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MCK.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.SCK: Pin select for SCK signal
func (o *I2S_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetSCK_PORT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x20)|value<<5)
}
func (o *I2S_PSEL_Type) GetSCK_PORT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x20) >> 5
}
func (o *I2S_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.LRCK: Pin select for LRCK signal
func (o *I2S_PSEL_Type) SetLRCK_PIN(value uint32) {
	volatile.StoreUint32(&o.LRCK.Reg, volatile.LoadUint32(&o.LRCK.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetLRCK_PIN() uint32 {
	return volatile.LoadUint32(&o.LRCK.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetLRCK_PORT(value uint32) {
	volatile.StoreUint32(&o.LRCK.Reg, volatile.LoadUint32(&o.LRCK.Reg)&^(0x20)|value<<5)
}
func (o *I2S_PSEL_Type) GetLRCK_PORT() uint32 {
	return (volatile.LoadUint32(&o.LRCK.Reg) & 0x20) >> 5
}
func (o *I2S_PSEL_Type) SetLRCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.LRCK.Reg, volatile.LoadUint32(&o.LRCK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetLRCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.LRCK.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.SDIN: Pin select for SDIN signal
func (o *I2S_PSEL_Type) SetSDIN_PIN(value uint32) {
	volatile.StoreUint32(&o.SDIN.Reg, volatile.LoadUint32(&o.SDIN.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetSDIN_PIN() uint32 {
	return volatile.LoadUint32(&o.SDIN.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetSDIN_PORT(value uint32) {
	volatile.StoreUint32(&o.SDIN.Reg, volatile.LoadUint32(&o.SDIN.Reg)&^(0x20)|value<<5)
}
func (o *I2S_PSEL_Type) GetSDIN_PORT() uint32 {
	return (volatile.LoadUint32(&o.SDIN.Reg) & 0x20) >> 5
}
func (o *I2S_PSEL_Type) SetSDIN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDIN.Reg, volatile.LoadUint32(&o.SDIN.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetSDIN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDIN.Reg) & 0x80000000) >> 31
}

// I2S_PSEL.SDOUT: Pin select for SDOUT signal
func (o *I2S_PSEL_Type) SetSDOUT_PIN(value uint32) {
	volatile.StoreUint32(&o.SDOUT.Reg, volatile.LoadUint32(&o.SDOUT.Reg)&^(0x1f)|value)
}
func (o *I2S_PSEL_Type) GetSDOUT_PIN() uint32 {
	return volatile.LoadUint32(&o.SDOUT.Reg) & 0x1f
}
func (o *I2S_PSEL_Type) SetSDOUT_PORT(value uint32) {
	volatile.StoreUint32(&o.SDOUT.Reg, volatile.LoadUint32(&o.SDOUT.Reg)&^(0x20)|value<<5)
}
func (o *I2S_PSEL_Type) GetSDOUT_PORT() uint32 {
	return (volatile.LoadUint32(&o.SDOUT.Reg) & 0x20) >> 5
}
func (o *I2S_PSEL_Type) SetSDOUT_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDOUT.Reg, volatile.LoadUint32(&o.SDOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_PSEL_Type) GetSDOUT_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDOUT.Reg) & 0x80000000) >> 31
}

// Interprocessor communication 0
type IPC_Type struct {
	TASKS_SEND      [16]volatile.Register32 // 0x0
	_               [64]byte
	SUBSCRIBE_SEND  [16]volatile.Register32 // 0x80
	_               [64]byte
	EVENTS_RECEIVE  [16]volatile.Register32 // 0x100
	_               [64]byte
	PUBLISH_RECEIVE [16]volatile.Register32 // 0x180
	_               [320]byte
	INTEN           volatile.Register32 // 0x300
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	INTPEND         volatile.Register32 // 0x30C
	_               [512]byte
	SEND_CNF        [16]volatile.Register32 // 0x510
	_               [64]byte
	RECEIVE_CNF     [16]volatile.Register32 // 0x590
	_               [64]byte
	GPMEM           [2]volatile.Register32 // 0x610
}

// IPC.TASKS_SEND: Description collection: Trigger events on IPC channel enabled in SEND_CNF[n]
func (o *IPC_Type) SetTASKS_SEND(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_SEND[idx].Reg, volatile.LoadUint32(&o.TASKS_SEND[idx].Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetTASKS_SEND(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_SEND[idx].Reg) & 0x1
}

// IPC.SUBSCRIBE_SEND: Description collection: Subscribe configuration for task SEND[n]
func (o *IPC_Type) SetSUBSCRIBE_SEND_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SEND[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_SEND[idx].Reg)&^(0xff)|value)
}
func (o *IPC_Type) GetSUBSCRIBE_SEND_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SEND[idx].Reg) & 0xff
}
func (o *IPC_Type) SetSUBSCRIBE_SEND_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SEND[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_SEND[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *IPC_Type) GetSUBSCRIBE_SEND_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SEND[idx].Reg) & 0x80000000) >> 31
}

// IPC.EVENTS_RECEIVE: Description collection: Event received on one or more of the enabled IPC channels in RECEIVE_CNF[n]
func (o *IPC_Type) SetEVENTS_RECEIVE(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_RECEIVE[idx].Reg, volatile.LoadUint32(&o.EVENTS_RECEIVE[idx].Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetEVENTS_RECEIVE(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_RECEIVE[idx].Reg) & 0x1
}

// IPC.PUBLISH_RECEIVE: Description collection: Publish configuration for event RECEIVE[n]
func (o *IPC_Type) SetPUBLISH_RECEIVE_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RECEIVE[idx].Reg, volatile.LoadUint32(&o.PUBLISH_RECEIVE[idx].Reg)&^(0xff)|value)
}
func (o *IPC_Type) GetPUBLISH_RECEIVE_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RECEIVE[idx].Reg) & 0xff
}
func (o *IPC_Type) SetPUBLISH_RECEIVE_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RECEIVE[idx].Reg, volatile.LoadUint32(&o.PUBLISH_RECEIVE[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *IPC_Type) GetPUBLISH_RECEIVE_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RECEIVE[idx].Reg) & 0x80000000) >> 31
}

// IPC.INTEN: Enable or disable interrupt
func (o *IPC_Type) SetINTEN_RECEIVE0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetINTEN_RECEIVE0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *IPC_Type) SetINTEN_RECEIVE1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *IPC_Type) GetINTEN_RECEIVE1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *IPC_Type) SetINTEN_RECEIVE2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *IPC_Type) GetINTEN_RECEIVE2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *IPC_Type) SetINTEN_RECEIVE3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *IPC_Type) GetINTEN_RECEIVE3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *IPC_Type) SetINTEN_RECEIVE4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *IPC_Type) GetINTEN_RECEIVE4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *IPC_Type) SetINTEN_RECEIVE5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *IPC_Type) GetINTEN_RECEIVE5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *IPC_Type) SetINTEN_RECEIVE6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *IPC_Type) GetINTEN_RECEIVE6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *IPC_Type) SetINTEN_RECEIVE7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *IPC_Type) GetINTEN_RECEIVE7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *IPC_Type) SetINTEN_RECEIVE8(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *IPC_Type) GetINTEN_RECEIVE8() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *IPC_Type) SetINTEN_RECEIVE9(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *IPC_Type) GetINTEN_RECEIVE9() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *IPC_Type) SetINTEN_RECEIVE10(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *IPC_Type) GetINTEN_RECEIVE10() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *IPC_Type) SetINTEN_RECEIVE11(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *IPC_Type) GetINTEN_RECEIVE11() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *IPC_Type) SetINTEN_RECEIVE12(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *IPC_Type) GetINTEN_RECEIVE12() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *IPC_Type) SetINTEN_RECEIVE13(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *IPC_Type) GetINTEN_RECEIVE13() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *IPC_Type) SetINTEN_RECEIVE14(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *IPC_Type) GetINTEN_RECEIVE14() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *IPC_Type) SetINTEN_RECEIVE15(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *IPC_Type) GetINTEN_RECEIVE15() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}

// IPC.INTENSET: Enable interrupt
func (o *IPC_Type) SetINTENSET_RECEIVE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetINTENSET_RECEIVE0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *IPC_Type) SetINTENSET_RECEIVE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *IPC_Type) GetINTENSET_RECEIVE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *IPC_Type) SetINTENSET_RECEIVE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *IPC_Type) GetINTENSET_RECEIVE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *IPC_Type) SetINTENSET_RECEIVE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *IPC_Type) GetINTENSET_RECEIVE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *IPC_Type) SetINTENSET_RECEIVE4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *IPC_Type) GetINTENSET_RECEIVE4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *IPC_Type) SetINTENSET_RECEIVE5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *IPC_Type) GetINTENSET_RECEIVE5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *IPC_Type) SetINTENSET_RECEIVE6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *IPC_Type) GetINTENSET_RECEIVE6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *IPC_Type) SetINTENSET_RECEIVE7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *IPC_Type) GetINTENSET_RECEIVE7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *IPC_Type) SetINTENSET_RECEIVE8(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *IPC_Type) GetINTENSET_RECEIVE8() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *IPC_Type) SetINTENSET_RECEIVE9(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *IPC_Type) GetINTENSET_RECEIVE9() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *IPC_Type) SetINTENSET_RECEIVE10(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *IPC_Type) GetINTENSET_RECEIVE10() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *IPC_Type) SetINTENSET_RECEIVE11(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *IPC_Type) GetINTENSET_RECEIVE11() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *IPC_Type) SetINTENSET_RECEIVE12(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *IPC_Type) GetINTENSET_RECEIVE12() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *IPC_Type) SetINTENSET_RECEIVE13(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *IPC_Type) GetINTENSET_RECEIVE13() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *IPC_Type) SetINTENSET_RECEIVE14(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *IPC_Type) GetINTENSET_RECEIVE14() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *IPC_Type) SetINTENSET_RECEIVE15(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *IPC_Type) GetINTENSET_RECEIVE15() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}

// IPC.INTENCLR: Disable interrupt
func (o *IPC_Type) SetINTENCLR_RECEIVE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *IPC_Type) SetINTENCLR_RECEIVE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *IPC_Type) SetINTENCLR_RECEIVE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *IPC_Type) SetINTENCLR_RECEIVE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *IPC_Type) SetINTENCLR_RECEIVE4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *IPC_Type) SetINTENCLR_RECEIVE5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *IPC_Type) SetINTENCLR_RECEIVE6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *IPC_Type) SetINTENCLR_RECEIVE7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *IPC_Type) SetINTENCLR_RECEIVE8(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE8() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *IPC_Type) SetINTENCLR_RECEIVE9(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE9() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *IPC_Type) SetINTENCLR_RECEIVE10(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE10() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *IPC_Type) SetINTENCLR_RECEIVE11(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE11() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *IPC_Type) SetINTENCLR_RECEIVE12(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE12() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *IPC_Type) SetINTENCLR_RECEIVE13(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE13() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *IPC_Type) SetINTENCLR_RECEIVE14(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE14() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *IPC_Type) SetINTENCLR_RECEIVE15(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *IPC_Type) GetINTENCLR_RECEIVE15() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// IPC.INTPEND: Pending interrupts
func (o *IPC_Type) SetINTPEND_RECEIVE0(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetINTPEND_RECEIVE0() uint32 {
	return volatile.LoadUint32(&o.INTPEND.Reg) & 0x1
}
func (o *IPC_Type) SetINTPEND_RECEIVE1(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x2)|value<<1)
}
func (o *IPC_Type) GetINTPEND_RECEIVE1() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x2) >> 1
}
func (o *IPC_Type) SetINTPEND_RECEIVE2(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x4)|value<<2)
}
func (o *IPC_Type) GetINTPEND_RECEIVE2() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x4) >> 2
}
func (o *IPC_Type) SetINTPEND_RECEIVE3(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x8)|value<<3)
}
func (o *IPC_Type) GetINTPEND_RECEIVE3() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x8) >> 3
}
func (o *IPC_Type) SetINTPEND_RECEIVE4(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x10)|value<<4)
}
func (o *IPC_Type) GetINTPEND_RECEIVE4() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x10) >> 4
}
func (o *IPC_Type) SetINTPEND_RECEIVE5(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x20)|value<<5)
}
func (o *IPC_Type) GetINTPEND_RECEIVE5() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x20) >> 5
}
func (o *IPC_Type) SetINTPEND_RECEIVE6(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x40)|value<<6)
}
func (o *IPC_Type) GetINTPEND_RECEIVE6() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x40) >> 6
}
func (o *IPC_Type) SetINTPEND_RECEIVE7(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x80)|value<<7)
}
func (o *IPC_Type) GetINTPEND_RECEIVE7() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x80) >> 7
}
func (o *IPC_Type) SetINTPEND_RECEIVE8(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x100)|value<<8)
}
func (o *IPC_Type) GetINTPEND_RECEIVE8() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x100) >> 8
}
func (o *IPC_Type) SetINTPEND_RECEIVE9(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x200)|value<<9)
}
func (o *IPC_Type) GetINTPEND_RECEIVE9() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x200) >> 9
}
func (o *IPC_Type) SetINTPEND_RECEIVE10(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x400)|value<<10)
}
func (o *IPC_Type) GetINTPEND_RECEIVE10() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x400) >> 10
}
func (o *IPC_Type) SetINTPEND_RECEIVE11(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x800)|value<<11)
}
func (o *IPC_Type) GetINTPEND_RECEIVE11() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x800) >> 11
}
func (o *IPC_Type) SetINTPEND_RECEIVE12(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x1000)|value<<12)
}
func (o *IPC_Type) GetINTPEND_RECEIVE12() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x1000) >> 12
}
func (o *IPC_Type) SetINTPEND_RECEIVE13(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x2000)|value<<13)
}
func (o *IPC_Type) GetINTPEND_RECEIVE13() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x2000) >> 13
}
func (o *IPC_Type) SetINTPEND_RECEIVE14(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x4000)|value<<14)
}
func (o *IPC_Type) GetINTPEND_RECEIVE14() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x4000) >> 14
}
func (o *IPC_Type) SetINTPEND_RECEIVE15(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x8000)|value<<15)
}
func (o *IPC_Type) GetINTPEND_RECEIVE15() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x8000) >> 15
}

// IPC.SEND_CNF: Description collection: Send event configuration for TASKS_SEND[n]
func (o *IPC_Type) SetSEND_CNF_CHEN0(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetSEND_CNF_CHEN0(idx int) uint32 {
	return volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x1
}
func (o *IPC_Type) SetSEND_CNF_CHEN1(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x2)|value<<1)
}
func (o *IPC_Type) GetSEND_CNF_CHEN1(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x2) >> 1
}
func (o *IPC_Type) SetSEND_CNF_CHEN2(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x4)|value<<2)
}
func (o *IPC_Type) GetSEND_CNF_CHEN2(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x4) >> 2
}
func (o *IPC_Type) SetSEND_CNF_CHEN3(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x8)|value<<3)
}
func (o *IPC_Type) GetSEND_CNF_CHEN3(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x8) >> 3
}
func (o *IPC_Type) SetSEND_CNF_CHEN4(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x10)|value<<4)
}
func (o *IPC_Type) GetSEND_CNF_CHEN4(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x10) >> 4
}
func (o *IPC_Type) SetSEND_CNF_CHEN5(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x20)|value<<5)
}
func (o *IPC_Type) GetSEND_CNF_CHEN5(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x20) >> 5
}
func (o *IPC_Type) SetSEND_CNF_CHEN6(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x40)|value<<6)
}
func (o *IPC_Type) GetSEND_CNF_CHEN6(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x40) >> 6
}
func (o *IPC_Type) SetSEND_CNF_CHEN7(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x80)|value<<7)
}
func (o *IPC_Type) GetSEND_CNF_CHEN7(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x80) >> 7
}
func (o *IPC_Type) SetSEND_CNF_CHEN8(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x100)|value<<8)
}
func (o *IPC_Type) GetSEND_CNF_CHEN8(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x100) >> 8
}
func (o *IPC_Type) SetSEND_CNF_CHEN9(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x200)|value<<9)
}
func (o *IPC_Type) GetSEND_CNF_CHEN9(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x200) >> 9
}
func (o *IPC_Type) SetSEND_CNF_CHEN10(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x400)|value<<10)
}
func (o *IPC_Type) GetSEND_CNF_CHEN10(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x400) >> 10
}
func (o *IPC_Type) SetSEND_CNF_CHEN11(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x800)|value<<11)
}
func (o *IPC_Type) GetSEND_CNF_CHEN11(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x800) >> 11
}
func (o *IPC_Type) SetSEND_CNF_CHEN12(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x1000)|value<<12)
}
func (o *IPC_Type) GetSEND_CNF_CHEN12(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x1000) >> 12
}
func (o *IPC_Type) SetSEND_CNF_CHEN13(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x2000)|value<<13)
}
func (o *IPC_Type) GetSEND_CNF_CHEN13(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x2000) >> 13
}
func (o *IPC_Type) SetSEND_CNF_CHEN14(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x4000)|value<<14)
}
func (o *IPC_Type) GetSEND_CNF_CHEN14(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x4000) >> 14
}
func (o *IPC_Type) SetSEND_CNF_CHEN15(idx int, value uint32) {
	volatile.StoreUint32(&o.SEND_CNF[idx].Reg, volatile.LoadUint32(&o.SEND_CNF[idx].Reg)&^(0x8000)|value<<15)
}
func (o *IPC_Type) GetSEND_CNF_CHEN15(idx int) uint32 {
	return (volatile.LoadUint32(&o.SEND_CNF[idx].Reg) & 0x8000) >> 15
}

// IPC.RECEIVE_CNF: Description collection: Receive event configuration for EVENTS_RECEIVE[n]
func (o *IPC_Type) SetRECEIVE_CNF_CHEN0(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x1)|value)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN0(idx int) uint32 {
	return volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x1
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN1(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x2)|value<<1)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN1(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x2) >> 1
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN2(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x4)|value<<2)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN2(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x4) >> 2
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN3(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x8)|value<<3)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN3(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x8) >> 3
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN4(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x10)|value<<4)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN4(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x10) >> 4
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN5(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x20)|value<<5)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN5(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x20) >> 5
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN6(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x40)|value<<6)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN6(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x40) >> 6
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN7(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x80)|value<<7)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN7(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x80) >> 7
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN8(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x100)|value<<8)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN8(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x100) >> 8
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN9(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x200)|value<<9)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN9(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x200) >> 9
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN10(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x400)|value<<10)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN10(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x400) >> 10
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN11(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x800)|value<<11)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN11(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x800) >> 11
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN12(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x1000)|value<<12)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN12(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x1000) >> 12
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN13(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x2000)|value<<13)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN13(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x2000) >> 13
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN14(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x4000)|value<<14)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN14(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x4000) >> 14
}
func (o *IPC_Type) SetRECEIVE_CNF_CHEN15(idx int, value uint32) {
	volatile.StoreUint32(&o.RECEIVE_CNF[idx].Reg, volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg)&^(0x8000)|value<<15)
}
func (o *IPC_Type) GetRECEIVE_CNF_CHEN15(idx int) uint32 {
	return (volatile.LoadUint32(&o.RECEIVE_CNF[idx].Reg) & 0x8000) >> 15
}

// IPC.GPMEM: Description collection: General purpose memory
func (o *IPC_Type) SetGPMEM(idx int, value uint32) {
	volatile.StoreUint32(&o.GPMEM[idx].Reg, value)
}
func (o *IPC_Type) GetGPMEM(idx int) uint32 {
	return volatile.LoadUint32(&o.GPMEM[idx].Reg)
}

// External flash interface 0
type QSPI_Type struct {
	TASKS_ACTIVATE       volatile.Register32 // 0x0
	TASKS_READSTART      volatile.Register32 // 0x4
	TASKS_WRITESTART     volatile.Register32 // 0x8
	TASKS_ERASESTART     volatile.Register32 // 0xC
	TASKS_DEACTIVATE     volatile.Register32 // 0x10
	_                    [108]byte
	SUBSCRIBE_ACTIVATE   volatile.Register32 // 0x80
	SUBSCRIBE_READSTART  volatile.Register32 // 0x84
	SUBSCRIBE_WRITESTART volatile.Register32 // 0x88
	SUBSCRIBE_ERASESTART volatile.Register32 // 0x8C
	SUBSCRIBE_DEACTIVATE volatile.Register32 // 0x90
	_                    [108]byte
	EVENTS_READY         volatile.Register32 // 0x100
	_                    [124]byte
	PUBLISH_READY        volatile.Register32 // 0x180
	_                    [380]byte
	INTEN                volatile.Register32 // 0x300
	INTENSET             volatile.Register32 // 0x304
	INTENCLR             volatile.Register32 // 0x308
	_                    [500]byte
	ENABLE               volatile.Register32 // 0x500
	READ                 QSPI_READ_Type      // 0x504
	WRITE                QSPI_WRITE_Type     // 0x510
	ERASE                QSPI_ERASE_Type     // 0x51C
	PSEL                 QSPI_PSEL_Type      // 0x524
	XIPOFFSET            volatile.Register32 // 0x540
	IFCONFIG0            volatile.Register32 // 0x544
	_                    [4]byte
	XIPEN                volatile.Register32 // 0x54C
	_                    [16]byte
	XIP_ENC              QSPI_XIP_ENC_Type // 0x560
	DMA_ENC              QSPI_DMA_ENC_Type // 0x580
	_                    [96]byte
	IFCONFIG1            volatile.Register32 // 0x600
	STATUS               volatile.Register32 // 0x604
	_                    [12]byte
	DPMDUR               volatile.Register32 // 0x614
	_                    [12]byte
	ADDRCONF             volatile.Register32 // 0x624
	_                    [12]byte
	CINSTRCONF           volatile.Register32 // 0x634
	CINSTRDAT0           volatile.Register32 // 0x638
	CINSTRDAT1           volatile.Register32 // 0x63C
	IFTIMING             volatile.Register32 // 0x640
}

// QSPI.TASKS_ACTIVATE: Activate QSPI interface
func (o *QSPI_Type) SetTASKS_ACTIVATE(value uint32) {
	volatile.StoreUint32(&o.TASKS_ACTIVATE.Reg, volatile.LoadUint32(&o.TASKS_ACTIVATE.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetTASKS_ACTIVATE() uint32 {
	return volatile.LoadUint32(&o.TASKS_ACTIVATE.Reg) & 0x1
}

// QSPI.TASKS_READSTART: Start transfer from external flash memory to internal RAM
func (o *QSPI_Type) SetTASKS_READSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_READSTART.Reg, volatile.LoadUint32(&o.TASKS_READSTART.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetTASKS_READSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_READSTART.Reg) & 0x1
}

// QSPI.TASKS_WRITESTART: Start transfer from internal RAM to external flash memory
func (o *QSPI_Type) SetTASKS_WRITESTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_WRITESTART.Reg, volatile.LoadUint32(&o.TASKS_WRITESTART.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetTASKS_WRITESTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_WRITESTART.Reg) & 0x1
}

// QSPI.TASKS_ERASESTART: Start external flash memory erase operation
func (o *QSPI_Type) SetTASKS_ERASESTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_ERASESTART.Reg, volatile.LoadUint32(&o.TASKS_ERASESTART.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetTASKS_ERASESTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_ERASESTART.Reg) & 0x1
}

// QSPI.TASKS_DEACTIVATE: Deactivate QSPI interface
func (o *QSPI_Type) SetTASKS_DEACTIVATE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DEACTIVATE.Reg, volatile.LoadUint32(&o.TASKS_DEACTIVATE.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetTASKS_DEACTIVATE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DEACTIVATE.Reg) & 0x1
}

// QSPI.SUBSCRIBE_ACTIVATE: Subscribe configuration for task ACTIVATE
func (o *QSPI_Type) SetSUBSCRIBE_ACTIVATE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ACTIVATE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSUBSCRIBE_ACTIVATE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg) & 0xff
}
func (o *QSPI_Type) SetSUBSCRIBE_ACTIVATE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ACTIVATE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_Type) GetSUBSCRIBE_ACTIVATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg) & 0x80000000) >> 31
}

// QSPI.SUBSCRIBE_READSTART: Subscribe configuration for task READSTART
func (o *QSPI_Type) SetSUBSCRIBE_READSTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_READSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_READSTART.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSUBSCRIBE_READSTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_READSTART.Reg) & 0xff
}
func (o *QSPI_Type) SetSUBSCRIBE_READSTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_READSTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_READSTART.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_Type) GetSUBSCRIBE_READSTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_READSTART.Reg) & 0x80000000) >> 31
}

// QSPI.SUBSCRIBE_WRITESTART: Subscribe configuration for task WRITESTART
func (o *QSPI_Type) SetSUBSCRIBE_WRITESTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_WRITESTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_WRITESTART.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSUBSCRIBE_WRITESTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_WRITESTART.Reg) & 0xff
}
func (o *QSPI_Type) SetSUBSCRIBE_WRITESTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_WRITESTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_WRITESTART.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_Type) GetSUBSCRIBE_WRITESTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_WRITESTART.Reg) & 0x80000000) >> 31
}

// QSPI.SUBSCRIBE_ERASESTART: Subscribe configuration for task ERASESTART
func (o *QSPI_Type) SetSUBSCRIBE_ERASESTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ERASESTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ERASESTART.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSUBSCRIBE_ERASESTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_ERASESTART.Reg) & 0xff
}
func (o *QSPI_Type) SetSUBSCRIBE_ERASESTART_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ERASESTART.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ERASESTART.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_Type) GetSUBSCRIBE_ERASESTART_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_ERASESTART.Reg) & 0x80000000) >> 31
}

// QSPI.SUBSCRIBE_DEACTIVATE: Subscribe configuration for task DEACTIVATE
func (o *QSPI_Type) SetSUBSCRIBE_DEACTIVATE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DEACTIVATE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DEACTIVATE.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSUBSCRIBE_DEACTIVATE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_DEACTIVATE.Reg) & 0xff
}
func (o *QSPI_Type) SetSUBSCRIBE_DEACTIVATE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DEACTIVATE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DEACTIVATE.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_Type) GetSUBSCRIBE_DEACTIVATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_DEACTIVATE.Reg) & 0x80000000) >> 31
}

// QSPI.EVENTS_READY: QSPI peripheral is ready. This event will be generated as a response to all QSPI tasks except DEACTIVATE.
func (o *QSPI_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// QSPI.PUBLISH_READY: Publish configuration for event READY
func (o *QSPI_Type) SetPUBLISH_READY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetPUBLISH_READY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0xff
}
func (o *QSPI_Type) SetPUBLISH_READY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_Type) GetPUBLISH_READY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0x80000000) >> 31
}

// QSPI.INTEN: Enable or disable interrupt
func (o *QSPI_Type) SetINTEN_READY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetINTEN_READY() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}

// QSPI.INTENSET: Enable interrupt
func (o *QSPI_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// QSPI.INTENCLR: Disable interrupt
func (o *QSPI_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// QSPI.ENABLE: Enable QSPI peripheral and acquire the pins selected in PSELn registers
func (o *QSPI_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// QSPI.XIPOFFSET: Address offset into the external memory for Execute in Place operation.
func (o *QSPI_Type) SetXIPOFFSET(value uint32) {
	volatile.StoreUint32(&o.XIPOFFSET.Reg, value)
}
func (o *QSPI_Type) GetXIPOFFSET() uint32 {
	return volatile.LoadUint32(&o.XIPOFFSET.Reg)
}

// QSPI.IFCONFIG0: Interface configuration.
func (o *QSPI_Type) SetIFCONFIG0_READOC(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG0.Reg, volatile.LoadUint32(&o.IFCONFIG0.Reg)&^(0x7)|value)
}
func (o *QSPI_Type) GetIFCONFIG0_READOC() uint32 {
	return volatile.LoadUint32(&o.IFCONFIG0.Reg) & 0x7
}
func (o *QSPI_Type) SetIFCONFIG0_WRITEOC(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG0.Reg, volatile.LoadUint32(&o.IFCONFIG0.Reg)&^(0x38)|value<<3)
}
func (o *QSPI_Type) GetIFCONFIG0_WRITEOC() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG0.Reg) & 0x38) >> 3
}
func (o *QSPI_Type) SetIFCONFIG0_ADDRMODE(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG0.Reg, volatile.LoadUint32(&o.IFCONFIG0.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetIFCONFIG0_ADDRMODE() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG0.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetIFCONFIG0_DPMENABLE(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG0.Reg, volatile.LoadUint32(&o.IFCONFIG0.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetIFCONFIG0_DPMENABLE() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG0.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetIFCONFIG0_PPSIZE(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG0.Reg, volatile.LoadUint32(&o.IFCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *QSPI_Type) GetIFCONFIG0_PPSIZE() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG0.Reg) & 0x1000) >> 12
}

// QSPI.XIPEN: Enable Execute in Place operation.
func (o *QSPI_Type) SetXIPEN(value uint32) {
	volatile.StoreUint32(&o.XIPEN.Reg, volatile.LoadUint32(&o.XIPEN.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetXIPEN() uint32 {
	return volatile.LoadUint32(&o.XIPEN.Reg) & 0x1
}

// QSPI.IFCONFIG1: Interface configuration.
func (o *QSPI_Type) SetIFCONFIG1_SCKDELAY(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG1.Reg, volatile.LoadUint32(&o.IFCONFIG1.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetIFCONFIG1_SCKDELAY() uint32 {
	return volatile.LoadUint32(&o.IFCONFIG1.Reg) & 0xff
}
func (o *QSPI_Type) SetIFCONFIG1_DPMEN(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG1.Reg, volatile.LoadUint32(&o.IFCONFIG1.Reg)&^(0x1000000)|value<<24)
}
func (o *QSPI_Type) GetIFCONFIG1_DPMEN() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG1.Reg) & 0x1000000) >> 24
}
func (o *QSPI_Type) SetIFCONFIG1_SPIMODE(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG1.Reg, volatile.LoadUint32(&o.IFCONFIG1.Reg)&^(0x2000000)|value<<25)
}
func (o *QSPI_Type) GetIFCONFIG1_SPIMODE() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG1.Reg) & 0x2000000) >> 25
}
func (o *QSPI_Type) SetIFCONFIG1_SCKFREQ(value uint32) {
	volatile.StoreUint32(&o.IFCONFIG1.Reg, volatile.LoadUint32(&o.IFCONFIG1.Reg)&^(0xf0000000)|value<<28)
}
func (o *QSPI_Type) GetIFCONFIG1_SCKFREQ() uint32 {
	return (volatile.LoadUint32(&o.IFCONFIG1.Reg) & 0xf0000000) >> 28
}

// QSPI.STATUS: Status register.
func (o *QSPI_Type) SetSTATUS_DPM(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetSTATUS_DPM() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetSTATUS_READY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetSTATUS_READY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetSTATUS_SREG(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xff000000)|value<<24)
}
func (o *QSPI_Type) GetSTATUS_SREG() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xff000000) >> 24
}

// QSPI.DPMDUR: Set the duration required to enter/exit deep power-down mode (DPM).
func (o *QSPI_Type) SetDPMDUR_ENTER(value uint32) {
	volatile.StoreUint32(&o.DPMDUR.Reg, volatile.LoadUint32(&o.DPMDUR.Reg)&^(0xffff)|value)
}
func (o *QSPI_Type) GetDPMDUR_ENTER() uint32 {
	return volatile.LoadUint32(&o.DPMDUR.Reg) & 0xffff
}
func (o *QSPI_Type) SetDPMDUR_EXIT(value uint32) {
	volatile.StoreUint32(&o.DPMDUR.Reg, volatile.LoadUint32(&o.DPMDUR.Reg)&^(0xffff0000)|value<<16)
}
func (o *QSPI_Type) GetDPMDUR_EXIT() uint32 {
	return (volatile.LoadUint32(&o.DPMDUR.Reg) & 0xffff0000) >> 16
}

// QSPI.ADDRCONF: Extended address configuration.
func (o *QSPI_Type) SetADDRCONF_OPCODE(value uint32) {
	volatile.StoreUint32(&o.ADDRCONF.Reg, volatile.LoadUint32(&o.ADDRCONF.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetADDRCONF_OPCODE() uint32 {
	return volatile.LoadUint32(&o.ADDRCONF.Reg) & 0xff
}
func (o *QSPI_Type) SetADDRCONF_BYTE0(value uint32) {
	volatile.StoreUint32(&o.ADDRCONF.Reg, volatile.LoadUint32(&o.ADDRCONF.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetADDRCONF_BYTE0() uint32 {
	return (volatile.LoadUint32(&o.ADDRCONF.Reg) & 0xff00) >> 8
}
func (o *QSPI_Type) SetADDRCONF_BYTE1(value uint32) {
	volatile.StoreUint32(&o.ADDRCONF.Reg, volatile.LoadUint32(&o.ADDRCONF.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetADDRCONF_BYTE1() uint32 {
	return (volatile.LoadUint32(&o.ADDRCONF.Reg) & 0xff0000) >> 16
}
func (o *QSPI_Type) SetADDRCONF_MODE(value uint32) {
	volatile.StoreUint32(&o.ADDRCONF.Reg, volatile.LoadUint32(&o.ADDRCONF.Reg)&^(0x3000000)|value<<24)
}
func (o *QSPI_Type) GetADDRCONF_MODE() uint32 {
	return (volatile.LoadUint32(&o.ADDRCONF.Reg) & 0x3000000) >> 24
}
func (o *QSPI_Type) SetADDRCONF_WIPWAIT(value uint32) {
	volatile.StoreUint32(&o.ADDRCONF.Reg, volatile.LoadUint32(&o.ADDRCONF.Reg)&^(0x4000000)|value<<26)
}
func (o *QSPI_Type) GetADDRCONF_WIPWAIT() uint32 {
	return (volatile.LoadUint32(&o.ADDRCONF.Reg) & 0x4000000) >> 26
}
func (o *QSPI_Type) SetADDRCONF_WREN(value uint32) {
	volatile.StoreUint32(&o.ADDRCONF.Reg, volatile.LoadUint32(&o.ADDRCONF.Reg)&^(0x8000000)|value<<27)
}
func (o *QSPI_Type) GetADDRCONF_WREN() uint32 {
	return (volatile.LoadUint32(&o.ADDRCONF.Reg) & 0x8000000) >> 27
}

// QSPI.CINSTRCONF: Custom instruction configuration register.
func (o *QSPI_Type) SetCINSTRCONF_OPCODE(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetCINSTRCONF_OPCODE() uint32 {
	return volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0xff
}
func (o *QSPI_Type) SetCINSTRCONF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0xf00)|value<<8)
}
func (o *QSPI_Type) GetCINSTRCONF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0xf00) >> 8
}
func (o *QSPI_Type) SetCINSTRCONF_LIO2(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0x1000)|value<<12)
}
func (o *QSPI_Type) GetCINSTRCONF_LIO2() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0x1000) >> 12
}
func (o *QSPI_Type) SetCINSTRCONF_LIO3(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0x2000)|value<<13)
}
func (o *QSPI_Type) GetCINSTRCONF_LIO3() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0x2000) >> 13
}
func (o *QSPI_Type) SetCINSTRCONF_WIPWAIT(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0x4000)|value<<14)
}
func (o *QSPI_Type) GetCINSTRCONF_WIPWAIT() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0x4000) >> 14
}
func (o *QSPI_Type) SetCINSTRCONF_WREN(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0x8000)|value<<15)
}
func (o *QSPI_Type) GetCINSTRCONF_WREN() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0x8000) >> 15
}
func (o *QSPI_Type) SetCINSTRCONF_LFEN(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0x10000)|value<<16)
}
func (o *QSPI_Type) GetCINSTRCONF_LFEN() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0x10000) >> 16
}
func (o *QSPI_Type) SetCINSTRCONF_LFSTOP(value uint32) {
	volatile.StoreUint32(&o.CINSTRCONF.Reg, volatile.LoadUint32(&o.CINSTRCONF.Reg)&^(0x20000)|value<<17)
}
func (o *QSPI_Type) GetCINSTRCONF_LFSTOP() uint32 {
	return (volatile.LoadUint32(&o.CINSTRCONF.Reg) & 0x20000) >> 17
}

// QSPI.CINSTRDAT0: Custom instruction data register 0.
func (o *QSPI_Type) SetCINSTRDAT0_BYTE0(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT0.Reg, volatile.LoadUint32(&o.CINSTRDAT0.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetCINSTRDAT0_BYTE0() uint32 {
	return volatile.LoadUint32(&o.CINSTRDAT0.Reg) & 0xff
}
func (o *QSPI_Type) SetCINSTRDAT0_BYTE1(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT0.Reg, volatile.LoadUint32(&o.CINSTRDAT0.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetCINSTRDAT0_BYTE1() uint32 {
	return (volatile.LoadUint32(&o.CINSTRDAT0.Reg) & 0xff00) >> 8
}
func (o *QSPI_Type) SetCINSTRDAT0_BYTE2(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT0.Reg, volatile.LoadUint32(&o.CINSTRDAT0.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetCINSTRDAT0_BYTE2() uint32 {
	return (volatile.LoadUint32(&o.CINSTRDAT0.Reg) & 0xff0000) >> 16
}
func (o *QSPI_Type) SetCINSTRDAT0_BYTE3(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT0.Reg, volatile.LoadUint32(&o.CINSTRDAT0.Reg)&^(0xff000000)|value<<24)
}
func (o *QSPI_Type) GetCINSTRDAT0_BYTE3() uint32 {
	return (volatile.LoadUint32(&o.CINSTRDAT0.Reg) & 0xff000000) >> 24
}

// QSPI.CINSTRDAT1: Custom instruction data register 1.
func (o *QSPI_Type) SetCINSTRDAT1_BYTE4(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT1.Reg, volatile.LoadUint32(&o.CINSTRDAT1.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetCINSTRDAT1_BYTE4() uint32 {
	return volatile.LoadUint32(&o.CINSTRDAT1.Reg) & 0xff
}
func (o *QSPI_Type) SetCINSTRDAT1_BYTE5(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT1.Reg, volatile.LoadUint32(&o.CINSTRDAT1.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetCINSTRDAT1_BYTE5() uint32 {
	return (volatile.LoadUint32(&o.CINSTRDAT1.Reg) & 0xff00) >> 8
}
func (o *QSPI_Type) SetCINSTRDAT1_BYTE6(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT1.Reg, volatile.LoadUint32(&o.CINSTRDAT1.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetCINSTRDAT1_BYTE6() uint32 {
	return (volatile.LoadUint32(&o.CINSTRDAT1.Reg) & 0xff0000) >> 16
}
func (o *QSPI_Type) SetCINSTRDAT1_BYTE7(value uint32) {
	volatile.StoreUint32(&o.CINSTRDAT1.Reg, volatile.LoadUint32(&o.CINSTRDAT1.Reg)&^(0xff000000)|value<<24)
}
func (o *QSPI_Type) GetCINSTRDAT1_BYTE7() uint32 {
	return (volatile.LoadUint32(&o.CINSTRDAT1.Reg) & 0xff000000) >> 24
}

type QSPI_READ_Type struct {
	SRC volatile.Register32 // 0x504
	DST volatile.Register32 // 0x508
	CNT volatile.Register32 // 0x50C
}

// QSPI_READ.SRC: Flash memory source address
func (o *QSPI_READ_Type) SetSRC(value uint32) {
	volatile.StoreUint32(&o.SRC.Reg, value)
}
func (o *QSPI_READ_Type) GetSRC() uint32 {
	return volatile.LoadUint32(&o.SRC.Reg)
}

// QSPI_READ.DST: RAM destination address
func (o *QSPI_READ_Type) SetDST(value uint32) {
	volatile.StoreUint32(&o.DST.Reg, value)
}
func (o *QSPI_READ_Type) GetDST() uint32 {
	return volatile.LoadUint32(&o.DST.Reg)
}

// QSPI_READ.CNT: Read transfer length
func (o *QSPI_READ_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x1fffff)|value)
}
func (o *QSPI_READ_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0x1fffff
}

type QSPI_WRITE_Type struct {
	DST volatile.Register32 // 0x510
	SRC volatile.Register32 // 0x514
	CNT volatile.Register32 // 0x518
}

// QSPI_WRITE.DST: Flash destination address
func (o *QSPI_WRITE_Type) SetDST(value uint32) {
	volatile.StoreUint32(&o.DST.Reg, value)
}
func (o *QSPI_WRITE_Type) GetDST() uint32 {
	return volatile.LoadUint32(&o.DST.Reg)
}

// QSPI_WRITE.SRC: RAM source address
func (o *QSPI_WRITE_Type) SetSRC(value uint32) {
	volatile.StoreUint32(&o.SRC.Reg, value)
}
func (o *QSPI_WRITE_Type) GetSRC() uint32 {
	return volatile.LoadUint32(&o.SRC.Reg)
}

// QSPI_WRITE.CNT: Write transfer length
func (o *QSPI_WRITE_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x1fffff)|value)
}
func (o *QSPI_WRITE_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0x1fffff
}

type QSPI_ERASE_Type struct {
	PTR volatile.Register32 // 0x51C
	LEN volatile.Register32 // 0x520
}

// QSPI_ERASE.PTR: Start address of flash block to be erased
func (o *QSPI_ERASE_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *QSPI_ERASE_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// QSPI_ERASE.LEN: Size of block to be erased.
func (o *QSPI_ERASE_Type) SetLEN(value uint32) {
	volatile.StoreUint32(&o.LEN.Reg, volatile.LoadUint32(&o.LEN.Reg)&^(0x3)|value)
}
func (o *QSPI_ERASE_Type) GetLEN() uint32 {
	return volatile.LoadUint32(&o.LEN.Reg) & 0x3
}

type QSPI_PSEL_Type struct {
	SCK volatile.Register32 // 0x524
	CSN volatile.Register32 // 0x528
	_   [4]byte
	IO0 volatile.Register32 // 0x530
	IO1 volatile.Register32 // 0x534
	IO2 volatile.Register32 // 0x538
	IO3 volatile.Register32 // 0x53C
}

// QSPI_PSEL.SCK: Pin select for serial clock SCK
func (o *QSPI_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *QSPI_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *QSPI_PSEL_Type) SetSCK_PORT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_PSEL_Type) GetSCK_PORT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x20) >> 5
}
func (o *QSPI_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// QSPI_PSEL.CSN: Pin select for chip select signal CSN.
func (o *QSPI_PSEL_Type) SetCSN_PIN(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x1f)|value)
}
func (o *QSPI_PSEL_Type) GetCSN_PIN() uint32 {
	return volatile.LoadUint32(&o.CSN.Reg) & 0x1f
}
func (o *QSPI_PSEL_Type) SetCSN_PORT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_PSEL_Type) GetCSN_PORT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x20) >> 5
}
func (o *QSPI_PSEL_Type) SetCSN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_PSEL_Type) GetCSN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x80000000) >> 31
}

// QSPI_PSEL.IO0: Pin select for serial data MOSI/IO0.
func (o *QSPI_PSEL_Type) SetIO0_PIN(value uint32) {
	volatile.StoreUint32(&o.IO0.Reg, volatile.LoadUint32(&o.IO0.Reg)&^(0x1f)|value)
}
func (o *QSPI_PSEL_Type) GetIO0_PIN() uint32 {
	return volatile.LoadUint32(&o.IO0.Reg) & 0x1f
}
func (o *QSPI_PSEL_Type) SetIO0_PORT(value uint32) {
	volatile.StoreUint32(&o.IO0.Reg, volatile.LoadUint32(&o.IO0.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_PSEL_Type) GetIO0_PORT() uint32 {
	return (volatile.LoadUint32(&o.IO0.Reg) & 0x20) >> 5
}
func (o *QSPI_PSEL_Type) SetIO0_CONNECT(value uint32) {
	volatile.StoreUint32(&o.IO0.Reg, volatile.LoadUint32(&o.IO0.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_PSEL_Type) GetIO0_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.IO0.Reg) & 0x80000000) >> 31
}

// QSPI_PSEL.IO1: Pin select for serial data MISO/IO1.
func (o *QSPI_PSEL_Type) SetIO1_PIN(value uint32) {
	volatile.StoreUint32(&o.IO1.Reg, volatile.LoadUint32(&o.IO1.Reg)&^(0x1f)|value)
}
func (o *QSPI_PSEL_Type) GetIO1_PIN() uint32 {
	return volatile.LoadUint32(&o.IO1.Reg) & 0x1f
}
func (o *QSPI_PSEL_Type) SetIO1_PORT(value uint32) {
	volatile.StoreUint32(&o.IO1.Reg, volatile.LoadUint32(&o.IO1.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_PSEL_Type) GetIO1_PORT() uint32 {
	return (volatile.LoadUint32(&o.IO1.Reg) & 0x20) >> 5
}
func (o *QSPI_PSEL_Type) SetIO1_CONNECT(value uint32) {
	volatile.StoreUint32(&o.IO1.Reg, volatile.LoadUint32(&o.IO1.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_PSEL_Type) GetIO1_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.IO1.Reg) & 0x80000000) >> 31
}

// QSPI_PSEL.IO2: Pin select for serial data IO2.
func (o *QSPI_PSEL_Type) SetIO2_PIN(value uint32) {
	volatile.StoreUint32(&o.IO2.Reg, volatile.LoadUint32(&o.IO2.Reg)&^(0x1f)|value)
}
func (o *QSPI_PSEL_Type) GetIO2_PIN() uint32 {
	return volatile.LoadUint32(&o.IO2.Reg) & 0x1f
}
func (o *QSPI_PSEL_Type) SetIO2_PORT(value uint32) {
	volatile.StoreUint32(&o.IO2.Reg, volatile.LoadUint32(&o.IO2.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_PSEL_Type) GetIO2_PORT() uint32 {
	return (volatile.LoadUint32(&o.IO2.Reg) & 0x20) >> 5
}
func (o *QSPI_PSEL_Type) SetIO2_CONNECT(value uint32) {
	volatile.StoreUint32(&o.IO2.Reg, volatile.LoadUint32(&o.IO2.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_PSEL_Type) GetIO2_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.IO2.Reg) & 0x80000000) >> 31
}

// QSPI_PSEL.IO3: Pin select for serial data IO3.
func (o *QSPI_PSEL_Type) SetIO3_PIN(value uint32) {
	volatile.StoreUint32(&o.IO3.Reg, volatile.LoadUint32(&o.IO3.Reg)&^(0x1f)|value)
}
func (o *QSPI_PSEL_Type) GetIO3_PIN() uint32 {
	return volatile.LoadUint32(&o.IO3.Reg) & 0x1f
}
func (o *QSPI_PSEL_Type) SetIO3_PORT(value uint32) {
	volatile.StoreUint32(&o.IO3.Reg, volatile.LoadUint32(&o.IO3.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_PSEL_Type) GetIO3_PORT() uint32 {
	return (volatile.LoadUint32(&o.IO3.Reg) & 0x20) >> 5
}
func (o *QSPI_PSEL_Type) SetIO3_CONNECT(value uint32) {
	volatile.StoreUint32(&o.IO3.Reg, volatile.LoadUint32(&o.IO3.Reg)&^(0x80000000)|value<<31)
}
func (o *QSPI_PSEL_Type) GetIO3_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.IO3.Reg) & 0x80000000) >> 31
}

type QSPI_XIP_ENC_Type struct {
	KEY0   volatile.Register32 // 0x560
	KEY1   volatile.Register32 // 0x564
	KEY2   volatile.Register32 // 0x568
	KEY3   volatile.Register32 // 0x56C
	NONCE0 volatile.Register32 // 0x570
	NONCE1 volatile.Register32 // 0x574
	NONCE2 volatile.Register32 // 0x578
	ENABLE volatile.Register32 // 0x57C
}

// QSPI_XIP_ENC.KEY0: Bits 31:0 of XIP AES KEY
func (o *QSPI_XIP_ENC_Type) SetKEY0(value uint32) {
	volatile.StoreUint32(&o.KEY0.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetKEY0() uint32 {
	return volatile.LoadUint32(&o.KEY0.Reg)
}

// QSPI_XIP_ENC.KEY1: Bits 63:32 of XIP AES KEY
func (o *QSPI_XIP_ENC_Type) SetKEY1(value uint32) {
	volatile.StoreUint32(&o.KEY1.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetKEY1() uint32 {
	return volatile.LoadUint32(&o.KEY1.Reg)
}

// QSPI_XIP_ENC.KEY2: Bits 95:64 of XIP AES KEY
func (o *QSPI_XIP_ENC_Type) SetKEY2(value uint32) {
	volatile.StoreUint32(&o.KEY2.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetKEY2() uint32 {
	return volatile.LoadUint32(&o.KEY2.Reg)
}

// QSPI_XIP_ENC.KEY3: Bits 127:96 of XIP AES KEY
func (o *QSPI_XIP_ENC_Type) SetKEY3(value uint32) {
	volatile.StoreUint32(&o.KEY3.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetKEY3() uint32 {
	return volatile.LoadUint32(&o.KEY3.Reg)
}

// QSPI_XIP_ENC.NONCE0: Bits 31:0 of XIP NONCE
func (o *QSPI_XIP_ENC_Type) SetNONCE0(value uint32) {
	volatile.StoreUint32(&o.NONCE0.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetNONCE0() uint32 {
	return volatile.LoadUint32(&o.NONCE0.Reg)
}

// QSPI_XIP_ENC.NONCE1: Bits 63:32 of XIP NONCE
func (o *QSPI_XIP_ENC_Type) SetNONCE1(value uint32) {
	volatile.StoreUint32(&o.NONCE1.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetNONCE1() uint32 {
	return volatile.LoadUint32(&o.NONCE1.Reg)
}

// QSPI_XIP_ENC.NONCE2: Bits 95:64 of XIP NONCE
func (o *QSPI_XIP_ENC_Type) SetNONCE2(value uint32) {
	volatile.StoreUint32(&o.NONCE2.Reg, value)
}
func (o *QSPI_XIP_ENC_Type) GetNONCE2() uint32 {
	return volatile.LoadUint32(&o.NONCE2.Reg)
}

// QSPI_XIP_ENC.ENABLE: Enable stream cipher for XIP
func (o *QSPI_XIP_ENC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *QSPI_XIP_ENC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

type QSPI_DMA_ENC_Type struct {
	KEY0   volatile.Register32 // 0x580
	KEY1   volatile.Register32 // 0x584
	KEY2   volatile.Register32 // 0x588
	KEY3   volatile.Register32 // 0x58C
	NONCE0 volatile.Register32 // 0x590
	NONCE1 volatile.Register32 // 0x594
	NONCE2 volatile.Register32 // 0x598
	ENABLE volatile.Register32 // 0x59C
}

// QSPI_DMA_ENC.KEY0: Bits 31:0 of DMA AES KEY
func (o *QSPI_DMA_ENC_Type) SetKEY0(value uint32) {
	volatile.StoreUint32(&o.KEY0.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetKEY0() uint32 {
	return volatile.LoadUint32(&o.KEY0.Reg)
}

// QSPI_DMA_ENC.KEY1: Bits 63:32 of DMA AES KEY
func (o *QSPI_DMA_ENC_Type) SetKEY1(value uint32) {
	volatile.StoreUint32(&o.KEY1.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetKEY1() uint32 {
	return volatile.LoadUint32(&o.KEY1.Reg)
}

// QSPI_DMA_ENC.KEY2: Bits 95:64 of DMA AES KEY
func (o *QSPI_DMA_ENC_Type) SetKEY2(value uint32) {
	volatile.StoreUint32(&o.KEY2.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetKEY2() uint32 {
	return volatile.LoadUint32(&o.KEY2.Reg)
}

// QSPI_DMA_ENC.KEY3: Bits 127:96 of DMA AES KEY
func (o *QSPI_DMA_ENC_Type) SetKEY3(value uint32) {
	volatile.StoreUint32(&o.KEY3.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetKEY3() uint32 {
	return volatile.LoadUint32(&o.KEY3.Reg)
}

// QSPI_DMA_ENC.NONCE0: Bits 31:0 of DMA NONCE
func (o *QSPI_DMA_ENC_Type) SetNONCE0(value uint32) {
	volatile.StoreUint32(&o.NONCE0.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetNONCE0() uint32 {
	return volatile.LoadUint32(&o.NONCE0.Reg)
}

// QSPI_DMA_ENC.NONCE1: Bits 63:32 of DMA NONCE
func (o *QSPI_DMA_ENC_Type) SetNONCE1(value uint32) {
	volatile.StoreUint32(&o.NONCE1.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetNONCE1() uint32 {
	return volatile.LoadUint32(&o.NONCE1.Reg)
}

// QSPI_DMA_ENC.NONCE2: Bits 95:64 of DMA NONCE
func (o *QSPI_DMA_ENC_Type) SetNONCE2(value uint32) {
	volatile.StoreUint32(&o.NONCE2.Reg, value)
}
func (o *QSPI_DMA_ENC_Type) GetNONCE2() uint32 {
	return volatile.LoadUint32(&o.NONCE2.Reg)
}

// QSPI_DMA_ENC.ENABLE: Enable stream cipher for EasyDMA
func (o *QSPI_DMA_ENC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *QSPI_DMA_ENC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// NFC-A compatible radio 0
type NFCT_Type struct {
	TASKS_ACTIVATE            volatile.Register32 // 0x0
	TASKS_DISABLE             volatile.Register32 // 0x4
	TASKS_SENSE               volatile.Register32 // 0x8
	TASKS_STARTTX             volatile.Register32 // 0xC
	_                         [12]byte
	TASKS_ENABLERXDATA        volatile.Register32 // 0x1C
	_                         [4]byte
	TASKS_GOIDLE              volatile.Register32 // 0x24
	TASKS_GOSLEEP             volatile.Register32 // 0x28
	_                         [84]byte
	SUBSCRIBE_ACTIVATE        volatile.Register32 // 0x80
	SUBSCRIBE_DISABLE         volatile.Register32 // 0x84
	SUBSCRIBE_SENSE           volatile.Register32 // 0x88
	SUBSCRIBE_STARTTX         volatile.Register32 // 0x8C
	_                         [12]byte
	SUBSCRIBE_ENABLERXDATA    volatile.Register32 // 0x9C
	_                         [4]byte
	SUBSCRIBE_GOIDLE          volatile.Register32 // 0xA4
	SUBSCRIBE_GOSLEEP         volatile.Register32 // 0xA8
	_                         [84]byte
	EVENTS_READY              volatile.Register32 // 0x100
	EVENTS_FIELDDETECTED      volatile.Register32 // 0x104
	EVENTS_FIELDLOST          volatile.Register32 // 0x108
	EVENTS_TXFRAMESTART       volatile.Register32 // 0x10C
	EVENTS_TXFRAMEEND         volatile.Register32 // 0x110
	EVENTS_RXFRAMESTART       volatile.Register32 // 0x114
	EVENTS_RXFRAMEEND         volatile.Register32 // 0x118
	EVENTS_ERROR              volatile.Register32 // 0x11C
	_                         [8]byte
	EVENTS_RXERROR            volatile.Register32 // 0x128
	EVENTS_ENDRX              volatile.Register32 // 0x12C
	EVENTS_ENDTX              volatile.Register32 // 0x130
	_                         [4]byte
	EVENTS_AUTOCOLRESSTARTED  volatile.Register32 // 0x138
	_                         [12]byte
	EVENTS_COLLISION          volatile.Register32 // 0x148
	EVENTS_SELECTED           volatile.Register32 // 0x14C
	EVENTS_STARTED            volatile.Register32 // 0x150
	_                         [44]byte
	PUBLISH_READY             volatile.Register32 // 0x180
	PUBLISH_FIELDDETECTED     volatile.Register32 // 0x184
	PUBLISH_FIELDLOST         volatile.Register32 // 0x188
	PUBLISH_TXFRAMESTART      volatile.Register32 // 0x18C
	PUBLISH_TXFRAMEEND        volatile.Register32 // 0x190
	PUBLISH_RXFRAMESTART      volatile.Register32 // 0x194
	PUBLISH_RXFRAMEEND        volatile.Register32 // 0x198
	PUBLISH_ERROR             volatile.Register32 // 0x19C
	_                         [8]byte
	PUBLISH_RXERROR           volatile.Register32 // 0x1A8
	PUBLISH_ENDRX             volatile.Register32 // 0x1AC
	PUBLISH_ENDTX             volatile.Register32 // 0x1B0
	_                         [4]byte
	PUBLISH_AUTOCOLRESSTARTED volatile.Register32 // 0x1B8
	_                         [12]byte
	PUBLISH_COLLISION         volatile.Register32 // 0x1C8
	PUBLISH_SELECTED          volatile.Register32 // 0x1CC
	PUBLISH_STARTED           volatile.Register32 // 0x1D0
	_                         [44]byte
	SHORTS                    volatile.Register32 // 0x200
	_                         [252]byte
	INTEN                     volatile.Register32 // 0x300
	INTENSET                  volatile.Register32 // 0x304
	INTENCLR                  volatile.Register32 // 0x308
	_                         [248]byte
	ERRORSTATUS               volatile.Register32 // 0x404
	_                         [4]byte
	FRAMESTATUS               NFCT_FRAMESTATUS_Type // 0x40C
	NFCTAGSTATE               volatile.Register32   // 0x410
	_                         [12]byte
	SLEEPSTATE                volatile.Register32 // 0x420
	_                         [24]byte
	FIELDPRESENT              volatile.Register32 // 0x43C
	_                         [196]byte
	FRAMEDELAYMIN             volatile.Register32 // 0x504
	FRAMEDELAYMAX             volatile.Register32 // 0x508
	FRAMEDELAYMODE            volatile.Register32 // 0x50C
	PACKETPTR                 volatile.Register32 // 0x510
	MAXLEN                    volatile.Register32 // 0x514
	TXD                       NFCT_TXD_Type       // 0x518
	RXD                       NFCT_RXD_Type       // 0x520
	_                         [4]byte
	MODULATIONCTRL            volatile.Register32 // 0x52C
	_                         [8]byte
	MODULATIONPSEL            volatile.Register32 // 0x538
	_                         [84]byte
	NFCID1_LAST               volatile.Register32 // 0x590
	NFCID1_2ND_LAST           volatile.Register32 // 0x594
	NFCID1_3RD_LAST           volatile.Register32 // 0x598
	AUTOCOLRESCONFIG          volatile.Register32 // 0x59C
	SENSRES                   volatile.Register32 // 0x5A0
	SELRES                    volatile.Register32 // 0x5A4
}

// NFCT.TASKS_ACTIVATE: Activate NFCT peripheral for incoming and outgoing frames, change state to activated
func (o *NFCT_Type) SetTASKS_ACTIVATE(value uint32) {
	volatile.StoreUint32(&o.TASKS_ACTIVATE.Reg, volatile.LoadUint32(&o.TASKS_ACTIVATE.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_ACTIVATE() uint32 {
	return volatile.LoadUint32(&o.TASKS_ACTIVATE.Reg) & 0x1
}

// NFCT.TASKS_DISABLE: Disable NFCT peripheral
func (o *NFCT_Type) SetTASKS_DISABLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DISABLE.Reg, volatile.LoadUint32(&o.TASKS_DISABLE.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_DISABLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DISABLE.Reg) & 0x1
}

// NFCT.TASKS_SENSE: Enable NFC sense field mode, change state to sense mode
func (o *NFCT_Type) SetTASKS_SENSE(value uint32) {
	volatile.StoreUint32(&o.TASKS_SENSE.Reg, volatile.LoadUint32(&o.TASKS_SENSE.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_SENSE() uint32 {
	return volatile.LoadUint32(&o.TASKS_SENSE.Reg) & 0x1
}

// NFCT.TASKS_STARTTX: Start transmission of an outgoing frame, change state to transmit
func (o *NFCT_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// NFCT.TASKS_ENABLERXDATA: Initializes the EasyDMA for receive.
func (o *NFCT_Type) SetTASKS_ENABLERXDATA(value uint32) {
	volatile.StoreUint32(&o.TASKS_ENABLERXDATA.Reg, volatile.LoadUint32(&o.TASKS_ENABLERXDATA.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_ENABLERXDATA() uint32 {
	return volatile.LoadUint32(&o.TASKS_ENABLERXDATA.Reg) & 0x1
}

// NFCT.TASKS_GOIDLE: Force state machine to IDLE state
func (o *NFCT_Type) SetTASKS_GOIDLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_GOIDLE.Reg, volatile.LoadUint32(&o.TASKS_GOIDLE.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_GOIDLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_GOIDLE.Reg) & 0x1
}

// NFCT.TASKS_GOSLEEP: Force state machine to SLEEP_A state
func (o *NFCT_Type) SetTASKS_GOSLEEP(value uint32) {
	volatile.StoreUint32(&o.TASKS_GOSLEEP.Reg, volatile.LoadUint32(&o.TASKS_GOSLEEP.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetTASKS_GOSLEEP() uint32 {
	return volatile.LoadUint32(&o.TASKS_GOSLEEP.Reg) & 0x1
}

// NFCT.SUBSCRIBE_ACTIVATE: Subscribe configuration for task ACTIVATE
func (o *NFCT_Type) SetSUBSCRIBE_ACTIVATE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ACTIVATE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_ACTIVATE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_ACTIVATE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ACTIVATE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_ACTIVATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_ACTIVATE.Reg) & 0x80000000) >> 31
}

// NFCT.SUBSCRIBE_DISABLE: Subscribe configuration for task DISABLE
func (o *NFCT_Type) SetSUBSCRIBE_DISABLE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DISABLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DISABLE.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_DISABLE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_DISABLE.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_DISABLE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DISABLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DISABLE.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_DISABLE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_DISABLE.Reg) & 0x80000000) >> 31
}

// NFCT.SUBSCRIBE_SENSE: Subscribe configuration for task SENSE
func (o *NFCT_Type) SetSUBSCRIBE_SENSE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SENSE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SENSE.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_SENSE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_SENSE.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_SENSE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_SENSE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_SENSE.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_SENSE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_SENSE.Reg) & 0x80000000) >> 31
}

// NFCT.SUBSCRIBE_STARTTX: Subscribe configuration for task STARTTX
func (o *NFCT_Type) SetSUBSCRIBE_STARTTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_STARTTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_STARTTX_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTTX.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_STARTTX_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTTX.Reg) & 0x80000000) >> 31
}

// NFCT.SUBSCRIBE_ENABLERXDATA: Subscribe configuration for task ENABLERXDATA
func (o *NFCT_Type) SetSUBSCRIBE_ENABLERXDATA_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ENABLERXDATA.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ENABLERXDATA.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_ENABLERXDATA_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_ENABLERXDATA.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_ENABLERXDATA_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_ENABLERXDATA.Reg, volatile.LoadUint32(&o.SUBSCRIBE_ENABLERXDATA.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_ENABLERXDATA_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_ENABLERXDATA.Reg) & 0x80000000) >> 31
}

// NFCT.SUBSCRIBE_GOIDLE: Subscribe configuration for task GOIDLE
func (o *NFCT_Type) SetSUBSCRIBE_GOIDLE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_GOIDLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_GOIDLE.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_GOIDLE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_GOIDLE.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_GOIDLE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_GOIDLE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_GOIDLE.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_GOIDLE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_GOIDLE.Reg) & 0x80000000) >> 31
}

// NFCT.SUBSCRIBE_GOSLEEP: Subscribe configuration for task GOSLEEP
func (o *NFCT_Type) SetSUBSCRIBE_GOSLEEP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_GOSLEEP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_GOSLEEP.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetSUBSCRIBE_GOSLEEP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_GOSLEEP.Reg) & 0xff
}
func (o *NFCT_Type) SetSUBSCRIBE_GOSLEEP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_GOSLEEP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_GOSLEEP.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetSUBSCRIBE_GOSLEEP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_GOSLEEP.Reg) & 0x80000000) >> 31
}

// NFCT.EVENTS_READY: The NFCT peripheral is ready to receive and send frames
func (o *NFCT_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// NFCT.EVENTS_FIELDDETECTED: Remote NFC field detected
func (o *NFCT_Type) SetEVENTS_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_FIELDDETECTED.Reg, volatile.LoadUint32(&o.EVENTS_FIELDDETECTED.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_FIELDDETECTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_FIELDDETECTED.Reg) & 0x1
}

// NFCT.EVENTS_FIELDLOST: Remote NFC field lost
func (o *NFCT_Type) SetEVENTS_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.EVENTS_FIELDLOST.Reg, volatile.LoadUint32(&o.EVENTS_FIELDLOST.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_FIELDLOST() uint32 {
	return volatile.LoadUint32(&o.EVENTS_FIELDLOST.Reg) & 0x1
}

// NFCT.EVENTS_TXFRAMESTART: Marks the start of the first symbol of a transmitted frame
func (o *NFCT_Type) SetEVENTS_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXFRAMESTART.Reg, volatile.LoadUint32(&o.EVENTS_TXFRAMESTART.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_TXFRAMESTART() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXFRAMESTART.Reg) & 0x1
}

// NFCT.EVENTS_TXFRAMEEND: Marks the end of the last transmitted on-air symbol of a frame
func (o *NFCT_Type) SetEVENTS_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXFRAMEEND.Reg, volatile.LoadUint32(&o.EVENTS_TXFRAMEEND.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_TXFRAMEEND() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXFRAMEEND.Reg) & 0x1
}

// NFCT.EVENTS_RXFRAMESTART: Marks the end of the first symbol of a received frame
func (o *NFCT_Type) SetEVENTS_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXFRAMESTART.Reg, volatile.LoadUint32(&o.EVENTS_RXFRAMESTART.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_RXFRAMESTART() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXFRAMESTART.Reg) & 0x1
}

// NFCT.EVENTS_RXFRAMEEND: Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
func (o *NFCT_Type) SetEVENTS_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXFRAMEEND.Reg, volatile.LoadUint32(&o.EVENTS_RXFRAMEEND.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_RXFRAMEEND() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXFRAMEEND.Reg) & 0x1
}

// NFCT.EVENTS_ERROR: NFC error reported. The ERRORSTATUS register contains details on the source of the error.
func (o *NFCT_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// NFCT.EVENTS_RXERROR: NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
func (o *NFCT_Type) SetEVENTS_RXERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXERROR.Reg, volatile.LoadUint32(&o.EVENTS_RXERROR.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_RXERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXERROR.Reg) & 0x1
}

// NFCT.EVENTS_ENDRX: RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
func (o *NFCT_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// NFCT.EVENTS_ENDTX: Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
func (o *NFCT_Type) SetEVENTS_ENDTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDTX.Reg, volatile.LoadUint32(&o.EVENTS_ENDTX.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_ENDTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDTX.Reg) & 0x1
}

// NFCT.EVENTS_AUTOCOLRESSTARTED: Auto collision resolution process has started
func (o *NFCT_Type) SetEVENTS_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_AUTOCOLRESSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_AUTOCOLRESSTARTED.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_AUTOCOLRESSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_AUTOCOLRESSTARTED.Reg) & 0x1
}

// NFCT.EVENTS_COLLISION: NFC auto collision resolution error reported.
func (o *NFCT_Type) SetEVENTS_COLLISION(value uint32) {
	volatile.StoreUint32(&o.EVENTS_COLLISION.Reg, volatile.LoadUint32(&o.EVENTS_COLLISION.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_COLLISION() uint32 {
	return volatile.LoadUint32(&o.EVENTS_COLLISION.Reg) & 0x1
}

// NFCT.EVENTS_SELECTED: NFC auto collision resolution successfully completed
func (o *NFCT_Type) SetEVENTS_SELECTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SELECTED.Reg, volatile.LoadUint32(&o.EVENTS_SELECTED.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_SELECTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SELECTED.Reg) & 0x1
}

// NFCT.EVENTS_STARTED: EasyDMA is ready to receive or send frames.
func (o *NFCT_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// NFCT.PUBLISH_READY: Publish configuration for event READY
func (o *NFCT_Type) SetPUBLISH_READY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_READY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_READY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_READY.Reg, volatile.LoadUint32(&o.PUBLISH_READY.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_READY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_READY.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_FIELDDETECTED: Publish configuration for event FIELDDETECTED
func (o *NFCT_Type) SetPUBLISH_FIELDDETECTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FIELDDETECTED.Reg, volatile.LoadUint32(&o.PUBLISH_FIELDDETECTED.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_FIELDDETECTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_FIELDDETECTED.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_FIELDDETECTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FIELDDETECTED.Reg, volatile.LoadUint32(&o.PUBLISH_FIELDDETECTED.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_FIELDDETECTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_FIELDDETECTED.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_FIELDLOST: Publish configuration for event FIELDLOST
func (o *NFCT_Type) SetPUBLISH_FIELDLOST_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FIELDLOST.Reg, volatile.LoadUint32(&o.PUBLISH_FIELDLOST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_FIELDLOST_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_FIELDLOST.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_FIELDLOST_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_FIELDLOST.Reg, volatile.LoadUint32(&o.PUBLISH_FIELDLOST.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_FIELDLOST_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_FIELDLOST.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_TXFRAMESTART: Publish configuration for event TXFRAMESTART
func (o *NFCT_Type) SetPUBLISH_TXFRAMESTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXFRAMESTART.Reg, volatile.LoadUint32(&o.PUBLISH_TXFRAMESTART.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_TXFRAMESTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXFRAMESTART.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_TXFRAMESTART_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXFRAMESTART.Reg, volatile.LoadUint32(&o.PUBLISH_TXFRAMESTART.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_TXFRAMESTART_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXFRAMESTART.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_TXFRAMEEND: Publish configuration for event TXFRAMEEND
func (o *NFCT_Type) SetPUBLISH_TXFRAMEEND_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXFRAMEEND.Reg, volatile.LoadUint32(&o.PUBLISH_TXFRAMEEND.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_TXFRAMEEND_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_TXFRAMEEND.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_TXFRAMEEND_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_TXFRAMEEND.Reg, volatile.LoadUint32(&o.PUBLISH_TXFRAMEEND.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_TXFRAMEEND_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_TXFRAMEEND.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_RXFRAMESTART: Publish configuration for event RXFRAMESTART
func (o *NFCT_Type) SetPUBLISH_RXFRAMESTART_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXFRAMESTART.Reg, volatile.LoadUint32(&o.PUBLISH_RXFRAMESTART.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_RXFRAMESTART_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXFRAMESTART.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_RXFRAMESTART_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXFRAMESTART.Reg, volatile.LoadUint32(&o.PUBLISH_RXFRAMESTART.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_RXFRAMESTART_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXFRAMESTART.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_RXFRAMEEND: Publish configuration for event RXFRAMEEND
func (o *NFCT_Type) SetPUBLISH_RXFRAMEEND_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXFRAMEEND.Reg, volatile.LoadUint32(&o.PUBLISH_RXFRAMEEND.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_RXFRAMEEND_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXFRAMEEND.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_RXFRAMEEND_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXFRAMEEND.Reg, volatile.LoadUint32(&o.PUBLISH_RXFRAMEEND.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_RXFRAMEEND_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXFRAMEEND.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_ERROR: Publish configuration for event ERROR
func (o *NFCT_Type) SetPUBLISH_ERROR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_ERROR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ERROR.Reg, volatile.LoadUint32(&o.PUBLISH_ERROR.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ERROR.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_RXERROR: Publish configuration for event RXERROR
func (o *NFCT_Type) SetPUBLISH_RXERROR_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXERROR.Reg, volatile.LoadUint32(&o.PUBLISH_RXERROR.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_RXERROR_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_RXERROR.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_RXERROR_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_RXERROR.Reg, volatile.LoadUint32(&o.PUBLISH_RXERROR.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_RXERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_RXERROR.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_ENDRX: Publish configuration for event ENDRX
func (o *NFCT_Type) SetPUBLISH_ENDRX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_ENDRX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_ENDRX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDRX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_ENDRX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDRX.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_ENDTX: Publish configuration for event ENDTX
func (o *NFCT_Type) SetPUBLISH_ENDTX_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDTX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_ENDTX_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_ENDTX_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDTX.Reg, volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_ENDTX_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDTX.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_AUTOCOLRESSTARTED: Publish configuration for event AUTOCOLRESSTARTED
func (o *NFCT_Type) SetPUBLISH_AUTOCOLRESSTARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_AUTOCOLRESSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_AUTOCOLRESSTARTED.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_AUTOCOLRESSTARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_AUTOCOLRESSTARTED.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_AUTOCOLRESSTARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_AUTOCOLRESSTARTED.Reg, volatile.LoadUint32(&o.PUBLISH_AUTOCOLRESSTARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_AUTOCOLRESSTARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_AUTOCOLRESSTARTED.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_COLLISION: Publish configuration for event COLLISION
func (o *NFCT_Type) SetPUBLISH_COLLISION_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_COLLISION.Reg, volatile.LoadUint32(&o.PUBLISH_COLLISION.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_COLLISION_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_COLLISION.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_COLLISION_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_COLLISION.Reg, volatile.LoadUint32(&o.PUBLISH_COLLISION.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_COLLISION_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_COLLISION.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_SELECTED: Publish configuration for event SELECTED
func (o *NFCT_Type) SetPUBLISH_SELECTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SELECTED.Reg, volatile.LoadUint32(&o.PUBLISH_SELECTED.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_SELECTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SELECTED.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_SELECTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SELECTED.Reg, volatile.LoadUint32(&o.PUBLISH_SELECTED.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_SELECTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SELECTED.Reg) & 0x80000000) >> 31
}

// NFCT.PUBLISH_STARTED: Publish configuration for event STARTED
func (o *NFCT_Type) SetPUBLISH_STARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetPUBLISH_STARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0xff
}
func (o *NFCT_Type) SetPUBLISH_STARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetPUBLISH_STARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0x80000000) >> 31
}

// NFCT.SHORTS: Shortcuts between local events and tasks
func (o *NFCT_Type) SetSHORTS_FIELDDETECTED_ACTIVATE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetSHORTS_FIELDDETECTED_ACTIVATE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *NFCT_Type) SetSHORTS_FIELDLOST_SENSE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetSHORTS_FIELDLOST_SENSE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetSHORTS_TXFRAMEEND_ENABLERXDATA(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetSHORTS_TXFRAMEEND_ENABLERXDATA() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}

// NFCT.INTEN: Enable or disable interrupt
func (o *NFCT_Type) SetINTEN_READY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetINTEN_READY() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *NFCT_Type) SetINTEN_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetINTEN_FIELDDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetINTEN_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetINTEN_FIELDLOST() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetINTEN_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetINTEN_TXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *NFCT_Type) SetINTEN_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_Type) GetINTEN_TXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *NFCT_Type) SetINTEN_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetINTEN_RXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetINTEN_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *NFCT_Type) GetINTEN_RXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *NFCT_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *NFCT_Type) SetINTEN_RXERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *NFCT_Type) GetINTEN_RXERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *NFCT_Type) SetINTEN_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *NFCT_Type) GetINTEN_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *NFCT_Type) SetINTEN_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *NFCT_Type) GetINTEN_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *NFCT_Type) SetINTEN_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *NFCT_Type) GetINTEN_AUTOCOLRESSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *NFCT_Type) SetINTEN_COLLISION(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *NFCT_Type) GetINTEN_COLLISION() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *NFCT_Type) SetINTEN_SELECTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *NFCT_Type) GetINTEN_SELECTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *NFCT_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *NFCT_Type) GetINTEN_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}

// NFCT.INTENSET: Enable interrupt
func (o *NFCT_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *NFCT_Type) SetINTENSET_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetINTENSET_FIELDDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetINTENSET_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetINTENSET_FIELDLOST() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetINTENSET_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetINTENSET_TXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *NFCT_Type) SetINTENSET_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_Type) GetINTENSET_TXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *NFCT_Type) SetINTENSET_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetINTENSET_RXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetINTENSET_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *NFCT_Type) GetINTENSET_RXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *NFCT_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *NFCT_Type) SetINTENSET_RXERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *NFCT_Type) GetINTENSET_RXERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *NFCT_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *NFCT_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *NFCT_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *NFCT_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *NFCT_Type) SetINTENSET_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *NFCT_Type) GetINTENSET_AUTOCOLRESSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *NFCT_Type) SetINTENSET_COLLISION(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *NFCT_Type) GetINTENSET_COLLISION() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *NFCT_Type) SetINTENSET_SELECTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *NFCT_Type) GetINTENSET_SELECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *NFCT_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *NFCT_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}

// NFCT.INTENCLR: Disable interrupt
func (o *NFCT_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *NFCT_Type) SetINTENCLR_FIELDDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetINTENCLR_FIELDDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *NFCT_Type) SetINTENCLR_FIELDLOST(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetINTENCLR_FIELDLOST() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetINTENCLR_TXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_Type) GetINTENCLR_TXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *NFCT_Type) SetINTENCLR_TXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_Type) GetINTENCLR_TXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *NFCT_Type) SetINTENCLR_RXFRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetINTENCLR_RXFRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetINTENCLR_RXFRAMEEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *NFCT_Type) GetINTENCLR_RXFRAMEEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *NFCT_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *NFCT_Type) SetINTENCLR_RXERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *NFCT_Type) GetINTENCLR_RXERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *NFCT_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *NFCT_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *NFCT_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *NFCT_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *NFCT_Type) SetINTENCLR_AUTOCOLRESSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *NFCT_Type) GetINTENCLR_AUTOCOLRESSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *NFCT_Type) SetINTENCLR_COLLISION(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *NFCT_Type) GetINTENCLR_COLLISION() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *NFCT_Type) SetINTENCLR_SELECTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *NFCT_Type) GetINTENCLR_SELECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *NFCT_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *NFCT_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}

// NFCT.ERRORSTATUS: NFC Error Status register
func (o *NFCT_Type) SetERRORSTATUS_FRAMEDELAYTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ERRORSTATUS.Reg, volatile.LoadUint32(&o.ERRORSTATUS.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetERRORSTATUS_FRAMEDELAYTIMEOUT() uint32 {
	return volatile.LoadUint32(&o.ERRORSTATUS.Reg) & 0x1
}

// NFCT.NFCTAGSTATE: NfcTag state register
func (o *NFCT_Type) SetNFCTAGSTATE(value uint32) {
	volatile.StoreUint32(&o.NFCTAGSTATE.Reg, volatile.LoadUint32(&o.NFCTAGSTATE.Reg)&^(0x7)|value)
}
func (o *NFCT_Type) GetNFCTAGSTATE() uint32 {
	return volatile.LoadUint32(&o.NFCTAGSTATE.Reg) & 0x7
}

// NFCT.SLEEPSTATE: Sleep state during automatic collision resolution
func (o *NFCT_Type) SetSLEEPSTATE(value uint32) {
	volatile.StoreUint32(&o.SLEEPSTATE.Reg, volatile.LoadUint32(&o.SLEEPSTATE.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetSLEEPSTATE() uint32 {
	return volatile.LoadUint32(&o.SLEEPSTATE.Reg) & 0x1
}

// NFCT.FIELDPRESENT: Indicates the presence or not of a valid field
func (o *NFCT_Type) SetFIELDPRESENT(value uint32) {
	volatile.StoreUint32(&o.FIELDPRESENT.Reg, volatile.LoadUint32(&o.FIELDPRESENT.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetFIELDPRESENT() uint32 {
	return volatile.LoadUint32(&o.FIELDPRESENT.Reg) & 0x1
}
func (o *NFCT_Type) SetFIELDPRESENT_LOCKDETECT(value uint32) {
	volatile.StoreUint32(&o.FIELDPRESENT.Reg, volatile.LoadUint32(&o.FIELDPRESENT.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_Type) GetFIELDPRESENT_LOCKDETECT() uint32 {
	return (volatile.LoadUint32(&o.FIELDPRESENT.Reg) & 0x2) >> 1
}

// NFCT.FRAMEDELAYMIN: Minimum frame delay
func (o *NFCT_Type) SetFRAMEDELAYMIN(value uint32) {
	volatile.StoreUint32(&o.FRAMEDELAYMIN.Reg, volatile.LoadUint32(&o.FRAMEDELAYMIN.Reg)&^(0xffff)|value)
}
func (o *NFCT_Type) GetFRAMEDELAYMIN() uint32 {
	return volatile.LoadUint32(&o.FRAMEDELAYMIN.Reg) & 0xffff
}

// NFCT.FRAMEDELAYMAX: Maximum frame delay
func (o *NFCT_Type) SetFRAMEDELAYMAX(value uint32) {
	volatile.StoreUint32(&o.FRAMEDELAYMAX.Reg, volatile.LoadUint32(&o.FRAMEDELAYMAX.Reg)&^(0xfffff)|value)
}
func (o *NFCT_Type) GetFRAMEDELAYMAX() uint32 {
	return volatile.LoadUint32(&o.FRAMEDELAYMAX.Reg) & 0xfffff
}

// NFCT.FRAMEDELAYMODE: Configuration register for the Frame Delay Timer
func (o *NFCT_Type) SetFRAMEDELAYMODE(value uint32) {
	volatile.StoreUint32(&o.FRAMEDELAYMODE.Reg, volatile.LoadUint32(&o.FRAMEDELAYMODE.Reg)&^(0x3)|value)
}
func (o *NFCT_Type) GetFRAMEDELAYMODE() uint32 {
	return volatile.LoadUint32(&o.FRAMEDELAYMODE.Reg) & 0x3
}

// NFCT.PACKETPTR: Packet pointer for TXD and RXD data storage in Data RAM
func (o *NFCT_Type) SetPACKETPTR(value uint32) {
	volatile.StoreUint32(&o.PACKETPTR.Reg, value)
}
func (o *NFCT_Type) GetPACKETPTR() uint32 {
	return volatile.LoadUint32(&o.PACKETPTR.Reg)
}

// NFCT.MAXLEN: Size of the RAM buffer allocated to TXD and RXD data storage each
func (o *NFCT_Type) SetMAXLEN(value uint32) {
	volatile.StoreUint32(&o.MAXLEN.Reg, volatile.LoadUint32(&o.MAXLEN.Reg)&^(0x1ff)|value)
}
func (o *NFCT_Type) GetMAXLEN() uint32 {
	return volatile.LoadUint32(&o.MAXLEN.Reg) & 0x1ff
}

// NFCT.MODULATIONCTRL: Enables the modulation output to a GPIO pin which can be connected to a second external antenna.
func (o *NFCT_Type) SetMODULATIONCTRL(value uint32) {
	volatile.StoreUint32(&o.MODULATIONCTRL.Reg, volatile.LoadUint32(&o.MODULATIONCTRL.Reg)&^(0x3)|value)
}
func (o *NFCT_Type) GetMODULATIONCTRL() uint32 {
	return volatile.LoadUint32(&o.MODULATIONCTRL.Reg) & 0x3
}

// NFCT.MODULATIONPSEL: Pin select for Modulation control.
func (o *NFCT_Type) SetMODULATIONPSEL_PIN(value uint32) {
	volatile.StoreUint32(&o.MODULATIONPSEL.Reg, volatile.LoadUint32(&o.MODULATIONPSEL.Reg)&^(0x1f)|value)
}
func (o *NFCT_Type) GetMODULATIONPSEL_PIN() uint32 {
	return volatile.LoadUint32(&o.MODULATIONPSEL.Reg) & 0x1f
}
func (o *NFCT_Type) SetMODULATIONPSEL_PORT(value uint32) {
	volatile.StoreUint32(&o.MODULATIONPSEL.Reg, volatile.LoadUint32(&o.MODULATIONPSEL.Reg)&^(0x60)|value<<5)
}
func (o *NFCT_Type) GetMODULATIONPSEL_PORT() uint32 {
	return (volatile.LoadUint32(&o.MODULATIONPSEL.Reg) & 0x60) >> 5
}
func (o *NFCT_Type) SetMODULATIONPSEL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MODULATIONPSEL.Reg, volatile.LoadUint32(&o.MODULATIONPSEL.Reg)&^(0x80000000)|value<<31)
}
func (o *NFCT_Type) GetMODULATIONPSEL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MODULATIONPSEL.Reg) & 0x80000000) >> 31
}

// NFCT.NFCID1_LAST: Last NFCID1 part (4, 7 or 10 bytes ID)
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_Z(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_Z() uint32 {
	return volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff
}
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_Y(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff00)|value<<8)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_Y() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff00) >> 8
}
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_X(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff0000)|value<<16)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_X() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff0000) >> 16
}
func (o *NFCT_Type) SetNFCID1_LAST_NFCID1_W(value uint32) {
	volatile.StoreUint32(&o.NFCID1_LAST.Reg, volatile.LoadUint32(&o.NFCID1_LAST.Reg)&^(0xff000000)|value<<24)
}
func (o *NFCT_Type) GetNFCID1_LAST_NFCID1_W() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_LAST.Reg) & 0xff000000) >> 24
}

// NFCT.NFCID1_2ND_LAST: Second last NFCID1 part (7 or 10 bytes ID)
func (o *NFCT_Type) SetNFCID1_2ND_LAST_NFCID1_V(value uint32) {
	volatile.StoreUint32(&o.NFCID1_2ND_LAST.Reg, volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetNFCID1_2ND_LAST_NFCID1_V() uint32 {
	return volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg) & 0xff
}
func (o *NFCT_Type) SetNFCID1_2ND_LAST_NFCID1_U(value uint32) {
	volatile.StoreUint32(&o.NFCID1_2ND_LAST.Reg, volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg)&^(0xff00)|value<<8)
}
func (o *NFCT_Type) GetNFCID1_2ND_LAST_NFCID1_U() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg) & 0xff00) >> 8
}
func (o *NFCT_Type) SetNFCID1_2ND_LAST_NFCID1_T(value uint32) {
	volatile.StoreUint32(&o.NFCID1_2ND_LAST.Reg, volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg)&^(0xff0000)|value<<16)
}
func (o *NFCT_Type) GetNFCID1_2ND_LAST_NFCID1_T() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_2ND_LAST.Reg) & 0xff0000) >> 16
}

// NFCT.NFCID1_3RD_LAST: Third last NFCID1 part (10 bytes ID)
func (o *NFCT_Type) SetNFCID1_3RD_LAST_NFCID1_S(value uint32) {
	volatile.StoreUint32(&o.NFCID1_3RD_LAST.Reg, volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg)&^(0xff)|value)
}
func (o *NFCT_Type) GetNFCID1_3RD_LAST_NFCID1_S() uint32 {
	return volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg) & 0xff
}
func (o *NFCT_Type) SetNFCID1_3RD_LAST_NFCID1_R(value uint32) {
	volatile.StoreUint32(&o.NFCID1_3RD_LAST.Reg, volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg)&^(0xff00)|value<<8)
}
func (o *NFCT_Type) GetNFCID1_3RD_LAST_NFCID1_R() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg) & 0xff00) >> 8
}
func (o *NFCT_Type) SetNFCID1_3RD_LAST_NFCID1_Q(value uint32) {
	volatile.StoreUint32(&o.NFCID1_3RD_LAST.Reg, volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg)&^(0xff0000)|value<<16)
}
func (o *NFCT_Type) GetNFCID1_3RD_LAST_NFCID1_Q() uint32 {
	return (volatile.LoadUint32(&o.NFCID1_3RD_LAST.Reg) & 0xff0000) >> 16
}

// NFCT.AUTOCOLRESCONFIG: Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated.
func (o *NFCT_Type) SetAUTOCOLRESCONFIG_MODE(value uint32) {
	volatile.StoreUint32(&o.AUTOCOLRESCONFIG.Reg, volatile.LoadUint32(&o.AUTOCOLRESCONFIG.Reg)&^(0x1)|value)
}
func (o *NFCT_Type) GetAUTOCOLRESCONFIG_MODE() uint32 {
	return volatile.LoadUint32(&o.AUTOCOLRESCONFIG.Reg) & 0x1
}

// NFCT.SENSRES: NFC-A SENS_RES auto-response settings
func (o *NFCT_Type) SetSENSRES_BITFRAMESDD(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0x1f)|value)
}
func (o *NFCT_Type) GetSENSRES_BITFRAMESDD() uint32 {
	return volatile.LoadUint32(&o.SENSRES.Reg) & 0x1f
}
func (o *NFCT_Type) SetSENSRES_RFU5(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0x20)|value<<5)
}
func (o *NFCT_Type) GetSENSRES_RFU5() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0x20) >> 5
}
func (o *NFCT_Type) SetSENSRES_NFCIDSIZE(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0xc0)|value<<6)
}
func (o *NFCT_Type) GetSENSRES_NFCIDSIZE() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0xc0) >> 6
}
func (o *NFCT_Type) SetSENSRES_PLATFCONFIG(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0xf00)|value<<8)
}
func (o *NFCT_Type) GetSENSRES_PLATFCONFIG() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0xf00) >> 8
}
func (o *NFCT_Type) SetSENSRES_RFU74(value uint32) {
	volatile.StoreUint32(&o.SENSRES.Reg, volatile.LoadUint32(&o.SENSRES.Reg)&^(0xf000)|value<<12)
}
func (o *NFCT_Type) GetSENSRES_RFU74() uint32 {
	return (volatile.LoadUint32(&o.SENSRES.Reg) & 0xf000) >> 12
}

// NFCT.SELRES: NFC-A SEL_RES auto-response settings
func (o *NFCT_Type) SetSELRES_RFU10(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x3)|value)
}
func (o *NFCT_Type) GetSELRES_RFU10() uint32 {
	return volatile.LoadUint32(&o.SELRES.Reg) & 0x3
}
func (o *NFCT_Type) SetSELRES_CASCADE(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_Type) GetSELRES_CASCADE() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x4) >> 2
}
func (o *NFCT_Type) SetSELRES_RFU43(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x18)|value<<3)
}
func (o *NFCT_Type) GetSELRES_RFU43() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x18) >> 3
}
func (o *NFCT_Type) SetSELRES_PROTOCOL(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x60)|value<<5)
}
func (o *NFCT_Type) GetSELRES_PROTOCOL() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x60) >> 5
}
func (o *NFCT_Type) SetSELRES_RFU7(value uint32) {
	volatile.StoreUint32(&o.SELRES.Reg, volatile.LoadUint32(&o.SELRES.Reg)&^(0x80)|value<<7)
}
func (o *NFCT_Type) GetSELRES_RFU7() uint32 {
	return (volatile.LoadUint32(&o.SELRES.Reg) & 0x80) >> 7
}

type NFCT_FRAMESTATUS_Type struct {
	RX volatile.Register32 // 0x40C
}

// NFCT_FRAMESTATUS.RX: Result of last incoming frame
func (o *NFCT_FRAMESTATUS_Type) SetRX_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x1)|value)
}
func (o *NFCT_FRAMESTATUS_Type) GetRX_CRCERROR() uint32 {
	return volatile.LoadUint32(&o.RX.Reg) & 0x1
}
func (o *NFCT_FRAMESTATUS_Type) SetRX_PARITYSTATUS(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_FRAMESTATUS_Type) GetRX_PARITYSTATUS() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x4) >> 2
}
func (o *NFCT_FRAMESTATUS_Type) SetRX_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x8)|value<<3)
}
func (o *NFCT_FRAMESTATUS_Type) GetRX_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x8) >> 3
}

type NFCT_TXD_Type struct {
	FRAMECONFIG volatile.Register32 // 0x518
	AMOUNT      volatile.Register32 // 0x51C
}

// NFCT_TXD.FRAMECONFIG: Configuration of outgoing frames
func (o *NFCT_TXD_Type) SetFRAMECONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x1)|value)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_PARITY() uint32 {
	return volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x1
}
func (o *NFCT_TXD_Type) SetFRAMECONFIG_DISCARDMODE(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x2)|value<<1)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_DISCARDMODE() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x2) >> 1
}
func (o *NFCT_TXD_Type) SetFRAMECONFIG_SOF(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_SOF() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x4) >> 2
}
func (o *NFCT_TXD_Type) SetFRAMECONFIG_CRCMODETX(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_TXD_Type) GetFRAMECONFIG_CRCMODETX() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x10) >> 4
}

// NFCT_TXD.AMOUNT: Size of outgoing frame
func (o *NFCT_TXD_Type) SetAMOUNT_TXDATABITS(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7)|value)
}
func (o *NFCT_TXD_Type) GetAMOUNT_TXDATABITS() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7
}
func (o *NFCT_TXD_Type) SetAMOUNT_TXDATABYTES(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff8)|value<<3)
}
func (o *NFCT_TXD_Type) GetAMOUNT_TXDATABYTES() uint32 {
	return (volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff8) >> 3
}

type NFCT_RXD_Type struct {
	FRAMECONFIG volatile.Register32 // 0x520
	AMOUNT      volatile.Register32 // 0x524
}

// NFCT_RXD.FRAMECONFIG: Configuration of incoming frames
func (o *NFCT_RXD_Type) SetFRAMECONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x1)|value)
}
func (o *NFCT_RXD_Type) GetFRAMECONFIG_PARITY() uint32 {
	return volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x1
}
func (o *NFCT_RXD_Type) SetFRAMECONFIG_SOF(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x4)|value<<2)
}
func (o *NFCT_RXD_Type) GetFRAMECONFIG_SOF() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x4) >> 2
}
func (o *NFCT_RXD_Type) SetFRAMECONFIG_CRCMODERX(value uint32) {
	volatile.StoreUint32(&o.FRAMECONFIG.Reg, volatile.LoadUint32(&o.FRAMECONFIG.Reg)&^(0x10)|value<<4)
}
func (o *NFCT_RXD_Type) GetFRAMECONFIG_CRCMODERX() uint32 {
	return (volatile.LoadUint32(&o.FRAMECONFIG.Reg) & 0x10) >> 4
}

// NFCT_RXD.AMOUNT: Size of last incoming frame
func (o *NFCT_RXD_Type) SetAMOUNT_RXDATABITS(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7)|value)
}
func (o *NFCT_RXD_Type) GetAMOUNT_RXDATABITS() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7
}
func (o *NFCT_RXD_Type) SetAMOUNT_RXDATABYTES(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xff8)|value<<3)
}
func (o *NFCT_RXD_Type) GetAMOUNT_RXDATABYTES() uint32 {
	return (volatile.LoadUint32(&o.AMOUNT.Reg) & 0xff8) >> 3
}

// MUTEX 0
type MUTEX_Type struct {
	_     [1024]byte
	MUTEX [16]volatile.Register32 // 0x400
}

// MUTEX.MUTEX: Description collection: Mutex register
func (o *MUTEX_Type) SetMUTEX(idx int, value uint32) {
	volatile.StoreUint32(&o.MUTEX[idx].Reg, volatile.LoadUint32(&o.MUTEX[idx].Reg)&^(0x1)|value)
}
func (o *MUTEX_Type) GetMUTEX(idx int) uint32 {
	return volatile.LoadUint32(&o.MUTEX[idx].Reg) & 0x1
}

// Quadrature Decoder 0
type QDEC_Type struct {
	TASKS_START          volatile.Register32 // 0x0
	TASKS_STOP           volatile.Register32 // 0x4
	TASKS_READCLRACC     volatile.Register32 // 0x8
	TASKS_RDCLRACC       volatile.Register32 // 0xC
	TASKS_RDCLRDBL       volatile.Register32 // 0x10
	_                    [108]byte
	SUBSCRIBE_START      volatile.Register32 // 0x80
	SUBSCRIBE_STOP       volatile.Register32 // 0x84
	SUBSCRIBE_READCLRACC volatile.Register32 // 0x88
	SUBSCRIBE_RDCLRACC   volatile.Register32 // 0x8C
	SUBSCRIBE_RDCLRDBL   volatile.Register32 // 0x90
	_                    [108]byte
	EVENTS_SAMPLERDY     volatile.Register32 // 0x100
	EVENTS_REPORTRDY     volatile.Register32 // 0x104
	EVENTS_ACCOF         volatile.Register32 // 0x108
	EVENTS_DBLRDY        volatile.Register32 // 0x10C
	EVENTS_STOPPED       volatile.Register32 // 0x110
	_                    [108]byte
	PUBLISH_SAMPLERDY    volatile.Register32 // 0x180
	PUBLISH_REPORTRDY    volatile.Register32 // 0x184
	PUBLISH_ACCOF        volatile.Register32 // 0x188
	PUBLISH_DBLRDY       volatile.Register32 // 0x18C
	PUBLISH_STOPPED      volatile.Register32 // 0x190
	_                    [108]byte
	SHORTS               volatile.Register32 // 0x200
	_                    [256]byte
	INTENSET             volatile.Register32 // 0x304
	INTENCLR             volatile.Register32 // 0x308
	_                    [500]byte
	ENABLE               volatile.Register32 // 0x500
	LEDPOL               volatile.Register32 // 0x504
	SAMPLEPER            volatile.Register32 // 0x508
	SAMPLE               volatile.Register32 // 0x50C
	REPORTPER            volatile.Register32 // 0x510
	ACC                  volatile.Register32 // 0x514
	ACCREAD              volatile.Register32 // 0x518
	PSEL                 QDEC_PSEL_Type      // 0x51C
	DBFEN                volatile.Register32 // 0x528
	_                    [20]byte
	LEDPRE               volatile.Register32 // 0x540
	ACCDBL               volatile.Register32 // 0x544
	ACCDBLREAD           volatile.Register32 // 0x548
}

// QDEC.TASKS_START: Task starting the quadrature decoder
func (o *QDEC_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// QDEC.TASKS_STOP: Task stopping the quadrature decoder
func (o *QDEC_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// QDEC.TASKS_READCLRACC: Read and clear ACC and ACCDBL
func (o *QDEC_Type) SetTASKS_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.TASKS_READCLRACC.Reg, volatile.LoadUint32(&o.TASKS_READCLRACC.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_READCLRACC() uint32 {
	return volatile.LoadUint32(&o.TASKS_READCLRACC.Reg) & 0x1
}

// QDEC.TASKS_RDCLRACC: Read and clear ACC
func (o *QDEC_Type) SetTASKS_RDCLRACC(value uint32) {
	volatile.StoreUint32(&o.TASKS_RDCLRACC.Reg, volatile.LoadUint32(&o.TASKS_RDCLRACC.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_RDCLRACC() uint32 {
	return volatile.LoadUint32(&o.TASKS_RDCLRACC.Reg) & 0x1
}

// QDEC.TASKS_RDCLRDBL: Read and clear ACCDBL
func (o *QDEC_Type) SetTASKS_RDCLRDBL(value uint32) {
	volatile.StoreUint32(&o.TASKS_RDCLRDBL.Reg, volatile.LoadUint32(&o.TASKS_RDCLRDBL.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_RDCLRDBL() uint32 {
	return volatile.LoadUint32(&o.TASKS_RDCLRDBL.Reg) & 0x1
}

// QDEC.SUBSCRIBE_START: Subscribe configuration for task START
func (o *QDEC_Type) SetSUBSCRIBE_START_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetSUBSCRIBE_START_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0xff
}
func (o *QDEC_Type) SetSUBSCRIBE_START_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_START.Reg, volatile.LoadUint32(&o.SUBSCRIBE_START.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetSUBSCRIBE_START_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_START.Reg) & 0x80000000) >> 31
}

// QDEC.SUBSCRIBE_STOP: Subscribe configuration for task STOP
func (o *QDEC_Type) SetSUBSCRIBE_STOP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetSUBSCRIBE_STOP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0xff
}
func (o *QDEC_Type) SetSUBSCRIBE_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STOP.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetSUBSCRIBE_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STOP.Reg) & 0x80000000) >> 31
}

// QDEC.SUBSCRIBE_READCLRACC: Subscribe configuration for task READCLRACC
func (o *QDEC_Type) SetSUBSCRIBE_READCLRACC_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_READCLRACC.Reg, volatile.LoadUint32(&o.SUBSCRIBE_READCLRACC.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetSUBSCRIBE_READCLRACC_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_READCLRACC.Reg) & 0xff
}
func (o *QDEC_Type) SetSUBSCRIBE_READCLRACC_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_READCLRACC.Reg, volatile.LoadUint32(&o.SUBSCRIBE_READCLRACC.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetSUBSCRIBE_READCLRACC_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_READCLRACC.Reg) & 0x80000000) >> 31
}

// QDEC.SUBSCRIBE_RDCLRACC: Subscribe configuration for task RDCLRACC
func (o *QDEC_Type) SetSUBSCRIBE_RDCLRACC_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RDCLRACC.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RDCLRACC.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetSUBSCRIBE_RDCLRACC_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_RDCLRACC.Reg) & 0xff
}
func (o *QDEC_Type) SetSUBSCRIBE_RDCLRACC_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RDCLRACC.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RDCLRACC.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetSUBSCRIBE_RDCLRACC_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_RDCLRACC.Reg) & 0x80000000) >> 31
}

// QDEC.SUBSCRIBE_RDCLRDBL: Subscribe configuration for task RDCLRDBL
func (o *QDEC_Type) SetSUBSCRIBE_RDCLRDBL_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RDCLRDBL.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RDCLRDBL.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetSUBSCRIBE_RDCLRDBL_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_RDCLRDBL.Reg) & 0xff
}
func (o *QDEC_Type) SetSUBSCRIBE_RDCLRDBL_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_RDCLRDBL.Reg, volatile.LoadUint32(&o.SUBSCRIBE_RDCLRDBL.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetSUBSCRIBE_RDCLRDBL_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_RDCLRDBL.Reg) & 0x80000000) >> 31
}

// QDEC.EVENTS_SAMPLERDY: Event being generated for every new sample value written to the SAMPLE register
func (o *QDEC_Type) SetEVENTS_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SAMPLERDY.Reg, volatile.LoadUint32(&o.EVENTS_SAMPLERDY.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SAMPLERDY.Reg) & 0x1
}

// QDEC.EVENTS_REPORTRDY: Non-null report ready
func (o *QDEC_Type) SetEVENTS_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_REPORTRDY.Reg, volatile.LoadUint32(&o.EVENTS_REPORTRDY.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_REPORTRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_REPORTRDY.Reg) & 0x1
}

// QDEC.EVENTS_ACCOF: ACC or ACCDBL register overflow
func (o *QDEC_Type) SetEVENTS_ACCOF(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ACCOF.Reg, volatile.LoadUint32(&o.EVENTS_ACCOF.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_ACCOF() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ACCOF.Reg) & 0x1
}

// QDEC.EVENTS_DBLRDY: Double displacement(s) detected
func (o *QDEC_Type) SetEVENTS_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DBLRDY.Reg, volatile.LoadUint32(&o.EVENTS_DBLRDY.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_DBLRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DBLRDY.Reg) & 0x1
}

// QDEC.EVENTS_STOPPED: QDEC has been stopped
func (o *QDEC_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// QDEC.PUBLISH_SAMPLERDY: Publish configuration for event SAMPLERDY
func (o *QDEC_Type) SetPUBLISH_SAMPLERDY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SAMPLERDY.Reg, volatile.LoadUint32(&o.PUBLISH_SAMPLERDY.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetPUBLISH_SAMPLERDY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SAMPLERDY.Reg) & 0xff
}
func (o *QDEC_Type) SetPUBLISH_SAMPLERDY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SAMPLERDY.Reg, volatile.LoadUint32(&o.PUBLISH_SAMPLERDY.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetPUBLISH_SAMPLERDY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SAMPLERDY.Reg) & 0x80000000) >> 31
}

// QDEC.PUBLISH_REPORTRDY: Publish configuration for event REPORTRDY
func (o *QDEC_Type) SetPUBLISH_REPORTRDY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_REPORTRDY.Reg, volatile.LoadUint32(&o.PUBLISH_REPORTRDY.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetPUBLISH_REPORTRDY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_REPORTRDY.Reg) & 0xff
}
func (o *QDEC_Type) SetPUBLISH_REPORTRDY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_REPORTRDY.Reg, volatile.LoadUint32(&o.PUBLISH_REPORTRDY.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetPUBLISH_REPORTRDY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_REPORTRDY.Reg) & 0x80000000) >> 31
}

// QDEC.PUBLISH_ACCOF: Publish configuration for event ACCOF
func (o *QDEC_Type) SetPUBLISH_ACCOF_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ACCOF.Reg, volatile.LoadUint32(&o.PUBLISH_ACCOF.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetPUBLISH_ACCOF_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ACCOF.Reg) & 0xff
}
func (o *QDEC_Type) SetPUBLISH_ACCOF_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ACCOF.Reg, volatile.LoadUint32(&o.PUBLISH_ACCOF.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetPUBLISH_ACCOF_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ACCOF.Reg) & 0x80000000) >> 31
}

// QDEC.PUBLISH_DBLRDY: Publish configuration for event DBLRDY
func (o *QDEC_Type) SetPUBLISH_DBLRDY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DBLRDY.Reg, volatile.LoadUint32(&o.PUBLISH_DBLRDY.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetPUBLISH_DBLRDY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_DBLRDY.Reg) & 0xff
}
func (o *QDEC_Type) SetPUBLISH_DBLRDY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_DBLRDY.Reg, volatile.LoadUint32(&o.PUBLISH_DBLRDY.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetPUBLISH_DBLRDY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_DBLRDY.Reg) & 0x80000000) >> 31
}

// QDEC.PUBLISH_STOPPED: Publish configuration for event STOPPED
func (o *QDEC_Type) SetPUBLISH_STOPPED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0xff)|value)
}
func (o *QDEC_Type) GetPUBLISH_STOPPED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0xff
}
func (o *QDEC_Type) SetPUBLISH_STOPPED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STOPPED.Reg, volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_Type) GetPUBLISH_STOPPED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STOPPED.Reg) & 0x80000000) >> 31
}

// QDEC.SHORTS: Shortcuts between local events and tasks
func (o *QDEC_Type) SetSHORTS_REPORTRDY_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_READCLRACC() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *QDEC_Type) SetSHORTS_SAMPLERDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetSHORTS_SAMPLERDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetSHORTS_REPORTRDY_RDCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_RDCLRACC() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetSHORTS_REPORTRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetSHORTS_DBLRDY_RDCLRDBL(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetSHORTS_DBLRDY_RDCLRDBL() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *QDEC_Type) SetSHORTS_DBLRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_Type) GetSHORTS_DBLRDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *QDEC_Type) SetSHORTS_SAMPLERDY_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *QDEC_Type) GetSHORTS_SAMPLERDY_READCLRACC() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}

// QDEC.INTENSET: Enable interrupt
func (o *QDEC_Type) SetINTENSET_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTENSET_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *QDEC_Type) SetINTENSET_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTENSET_REPORTRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTENSET_ACCOF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTENSET_ACCOF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTENSET_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTENSET_DBLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}

// QDEC.INTENCLR: Disable interrupt
func (o *QDEC_Type) SetINTENCLR_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTENCLR_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *QDEC_Type) SetINTENCLR_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTENCLR_REPORTRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTENCLR_ACCOF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTENCLR_ACCOF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTENCLR_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTENCLR_DBLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}

// QDEC.ENABLE: Enable the quadrature decoder
func (o *QDEC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// QDEC.LEDPOL: LED output pin polarity
func (o *QDEC_Type) SetLEDPOL(value uint32) {
	volatile.StoreUint32(&o.LEDPOL.Reg, volatile.LoadUint32(&o.LEDPOL.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetLEDPOL() uint32 {
	return volatile.LoadUint32(&o.LEDPOL.Reg) & 0x1
}

// QDEC.SAMPLEPER: Sample period
func (o *QDEC_Type) SetSAMPLEPER(value uint32) {
	volatile.StoreUint32(&o.SAMPLEPER.Reg, volatile.LoadUint32(&o.SAMPLEPER.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetSAMPLEPER() uint32 {
	return volatile.LoadUint32(&o.SAMPLEPER.Reg) & 0xf
}

// QDEC.SAMPLE: Motion sample value
func (o *QDEC_Type) SetSAMPLE(value uint32) {
	volatile.StoreUint32(&o.SAMPLE.Reg, value)
}
func (o *QDEC_Type) GetSAMPLE() uint32 {
	return volatile.LoadUint32(&o.SAMPLE.Reg)
}

// QDEC.REPORTPER: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
func (o *QDEC_Type) SetREPORTPER(value uint32) {
	volatile.StoreUint32(&o.REPORTPER.Reg, volatile.LoadUint32(&o.REPORTPER.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetREPORTPER() uint32 {
	return volatile.LoadUint32(&o.REPORTPER.Reg) & 0xf
}

// QDEC.ACC: Register accumulating the valid transitions
func (o *QDEC_Type) SetACC(value uint32) {
	volatile.StoreUint32(&o.ACC.Reg, value)
}
func (o *QDEC_Type) GetACC() uint32 {
	return volatile.LoadUint32(&o.ACC.Reg)
}

// QDEC.ACCREAD: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
func (o *QDEC_Type) SetACCREAD(value uint32) {
	volatile.StoreUint32(&o.ACCREAD.Reg, value)
}
func (o *QDEC_Type) GetACCREAD() uint32 {
	return volatile.LoadUint32(&o.ACCREAD.Reg)
}

// QDEC.DBFEN: Enable input debounce filters
func (o *QDEC_Type) SetDBFEN(value uint32) {
	volatile.StoreUint32(&o.DBFEN.Reg, volatile.LoadUint32(&o.DBFEN.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetDBFEN() uint32 {
	return volatile.LoadUint32(&o.DBFEN.Reg) & 0x1
}

// QDEC.LEDPRE: Time period the LED is switched ON prior to sampling
func (o *QDEC_Type) SetLEDPRE(value uint32) {
	volatile.StoreUint32(&o.LEDPRE.Reg, volatile.LoadUint32(&o.LEDPRE.Reg)&^(0x1ff)|value)
}
func (o *QDEC_Type) GetLEDPRE() uint32 {
	return volatile.LoadUint32(&o.LEDPRE.Reg) & 0x1ff
}

// QDEC.ACCDBL: Register accumulating the number of detected double transitions
func (o *QDEC_Type) SetACCDBL(value uint32) {
	volatile.StoreUint32(&o.ACCDBL.Reg, volatile.LoadUint32(&o.ACCDBL.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetACCDBL() uint32 {
	return volatile.LoadUint32(&o.ACCDBL.Reg) & 0xf
}

// QDEC.ACCDBLREAD: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
func (o *QDEC_Type) SetACCDBLREAD(value uint32) {
	volatile.StoreUint32(&o.ACCDBLREAD.Reg, volatile.LoadUint32(&o.ACCDBLREAD.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetACCDBLREAD() uint32 {
	return volatile.LoadUint32(&o.ACCDBLREAD.Reg) & 0xf
}

type QDEC_PSEL_Type struct {
	LED volatile.Register32 // 0x51C
	A   volatile.Register32 // 0x520
	B   volatile.Register32 // 0x524
}

// QDEC_PSEL.LED: Pin select for LED signal
func (o *QDEC_PSEL_Type) SetLED_PIN(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetLED_PIN() uint32 {
	return volatile.LoadUint32(&o.LED.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetLED_PORT(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_PSEL_Type) GetLED_PORT() uint32 {
	return (volatile.LoadUint32(&o.LED.Reg) & 0x20) >> 5
}
func (o *QDEC_PSEL_Type) SetLED_CONNECT(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetLED_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.LED.Reg) & 0x80000000) >> 31
}

// QDEC_PSEL.A: Pin select for A signal
func (o *QDEC_PSEL_Type) SetA_PIN(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetA_PIN() uint32 {
	return volatile.LoadUint32(&o.A.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetA_PORT(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_PSEL_Type) GetA_PORT() uint32 {
	return (volatile.LoadUint32(&o.A.Reg) & 0x20) >> 5
}
func (o *QDEC_PSEL_Type) SetA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.A.Reg) & 0x80000000) >> 31
}

// QDEC_PSEL.B: Pin select for B signal
func (o *QDEC_PSEL_Type) SetB_PIN(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetB_PIN() uint32 {
	return volatile.LoadUint32(&o.B.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetB_PORT(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_PSEL_Type) GetB_PORT() uint32 {
	return (volatile.LoadUint32(&o.B.Reg) & 0x20) >> 5
}
func (o *QDEC_PSEL_Type) SetB_CONNECT(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetB_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.B.Reg) & 0x80000000) >> 31
}

// Universal serial bus device 0
type USBD_Type struct {
	_                     [4]byte
	TASKS_STARTEPIN       [8]volatile.Register32 // 0x4
	TASKS_STARTISOIN      volatile.Register32    // 0x24
	TASKS_STARTEPOUT      [8]volatile.Register32 // 0x28
	TASKS_STARTISOOUT     volatile.Register32    // 0x48
	TASKS_EP0RCVOUT       volatile.Register32    // 0x4C
	TASKS_EP0STATUS       volatile.Register32    // 0x50
	TASKS_EP0STALL        volatile.Register32    // 0x54
	TASKS_DPDMDRIVE       volatile.Register32    // 0x58
	TASKS_DPDMNODRIVE     volatile.Register32    // 0x5C
	_                     [36]byte
	SUBSCRIBE_STARTEPIN   [8]volatile.Register32 // 0x84
	SUBSCRIBE_STARTISOIN  volatile.Register32    // 0xA4
	SUBSCRIBE_STARTEPOUT  [8]volatile.Register32 // 0xA8
	SUBSCRIBE_STARTISOOUT volatile.Register32    // 0xC8
	SUBSCRIBE_EP0RCVOUT   volatile.Register32    // 0xCC
	SUBSCRIBE_EP0STATUS   volatile.Register32    // 0xD0
	SUBSCRIBE_EP0STALL    volatile.Register32    // 0xD4
	SUBSCRIBE_DPDMDRIVE   volatile.Register32    // 0xD8
	SUBSCRIBE_DPDMNODRIVE volatile.Register32    // 0xDC
	_                     [32]byte
	EVENTS_USBRESET       volatile.Register32    // 0x100
	EVENTS_STARTED        volatile.Register32    // 0x104
	EVENTS_ENDEPIN        [8]volatile.Register32 // 0x108
	EVENTS_EP0DATADONE    volatile.Register32    // 0x128
	EVENTS_ENDISOIN       volatile.Register32    // 0x12C
	EVENTS_ENDEPOUT       [8]volatile.Register32 // 0x130
	EVENTS_ENDISOOUT      volatile.Register32    // 0x150
	EVENTS_SOF            volatile.Register32    // 0x154
	EVENTS_USBEVENT       volatile.Register32    // 0x158
	EVENTS_EP0SETUP       volatile.Register32    // 0x15C
	EVENTS_EPDATA         volatile.Register32    // 0x160
	_                     [28]byte
	PUBLISH_USBRESET      volatile.Register32    // 0x180
	PUBLISH_STARTED       volatile.Register32    // 0x184
	PUBLISH_ENDEPIN       [8]volatile.Register32 // 0x188
	PUBLISH_EP0DATADONE   volatile.Register32    // 0x1A8
	PUBLISH_ENDISOIN      volatile.Register32    // 0x1AC
	PUBLISH_ENDEPOUT      [8]volatile.Register32 // 0x1B0
	PUBLISH_ENDISOOUT     volatile.Register32    // 0x1D0
	PUBLISH_SOF           volatile.Register32    // 0x1D4
	PUBLISH_USBEVENT      volatile.Register32    // 0x1D8
	PUBLISH_EP0SETUP      volatile.Register32    // 0x1DC
	PUBLISH_EPDATA        volatile.Register32    // 0x1E0
	_                     [28]byte
	SHORTS                volatile.Register32 // 0x200
	_                     [252]byte
	INTEN                 volatile.Register32 // 0x300
	INTENSET              volatile.Register32 // 0x304
	INTENCLR              volatile.Register32 // 0x308
	_                     [244]byte
	EVENTCAUSE            volatile.Register32 // 0x400
	_                     [28]byte
	HALTED                USBD_HALTED_Type // 0x420
	_                     [4]byte
	EPSTATUS              volatile.Register32 // 0x468
	EPDATASTATUS          volatile.Register32 // 0x46C
	USBADDR               volatile.Register32 // 0x470
	_                     [12]byte
	BMREQUESTTYPE         volatile.Register32 // 0x480
	BREQUEST              volatile.Register32 // 0x484
	WVALUEL               volatile.Register32 // 0x488
	WVALUEH               volatile.Register32 // 0x48C
	WINDEXL               volatile.Register32 // 0x490
	WINDEXH               volatile.Register32 // 0x494
	WLENGTHL              volatile.Register32 // 0x498
	WLENGTHH              volatile.Register32 // 0x49C
	SIZE                  USBD_SIZE_Type      // 0x4A0
	_                     [60]byte
	ENABLE                volatile.Register32 // 0x500
	USBPULLUP             volatile.Register32 // 0x504
	DPDMVALUE             volatile.Register32 // 0x508
	DTOGGLE               volatile.Register32 // 0x50C
	EPINEN                volatile.Register32 // 0x510
	EPOUTEN               volatile.Register32 // 0x514
	EPSTALL               volatile.Register32 // 0x518
	ISOSPLIT              volatile.Register32 // 0x51C
	FRAMECNTR             volatile.Register32 // 0x520
	_                     [8]byte
	LOWPOWER              volatile.Register32 // 0x52C
	ISOINCONFIG           volatile.Register32 // 0x530
	_                     [204]byte
	EPIN                  [8]USBD_EPIN_Type // 0x600
	ISOIN                 USBD_ISOIN_Type   // 0x6A0
	_                     [84]byte
	EPOUT                 [8]USBD_EPOUT_Type // 0x700
	ISOOUT                USBD_ISOOUT_Type   // 0x7A0
}

// USBD.TASKS_STARTEPIN: Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
func (o *USBD_Type) SetTASKS_STARTEPIN(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTEPIN[idx].Reg, volatile.LoadUint32(&o.TASKS_STARTEPIN[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTEPIN(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTEPIN[idx].Reg) & 0x1
}

// USBD.TASKS_STARTISOIN: Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
func (o *USBD_Type) SetTASKS_STARTISOIN(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTISOIN.Reg, volatile.LoadUint32(&o.TASKS_STARTISOIN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTISOIN() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTISOIN.Reg) & 0x1
}

// USBD.TASKS_STARTEPOUT: Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
func (o *USBD_Type) SetTASKS_STARTEPOUT(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTEPOUT[idx].Reg, volatile.LoadUint32(&o.TASKS_STARTEPOUT[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTEPOUT(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTEPOUT[idx].Reg) & 0x1
}

// USBD.TASKS_STARTISOOUT: Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
func (o *USBD_Type) SetTASKS_STARTISOOUT(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTISOOUT.Reg, volatile.LoadUint32(&o.TASKS_STARTISOOUT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTISOOUT() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTISOOUT.Reg) & 0x1
}

// USBD.TASKS_EP0RCVOUT: Allows OUT data stage on control endpoint 0
func (o *USBD_Type) SetTASKS_EP0RCVOUT(value uint32) {
	volatile.StoreUint32(&o.TASKS_EP0RCVOUT.Reg, volatile.LoadUint32(&o.TASKS_EP0RCVOUT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_EP0RCVOUT() uint32 {
	return volatile.LoadUint32(&o.TASKS_EP0RCVOUT.Reg) & 0x1
}

// USBD.TASKS_EP0STATUS: Allows status stage on control endpoint 0
func (o *USBD_Type) SetTASKS_EP0STATUS(value uint32) {
	volatile.StoreUint32(&o.TASKS_EP0STATUS.Reg, volatile.LoadUint32(&o.TASKS_EP0STATUS.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_EP0STATUS() uint32 {
	return volatile.LoadUint32(&o.TASKS_EP0STATUS.Reg) & 0x1
}

// USBD.TASKS_EP0STALL: Stalls data and status stage on control endpoint 0
func (o *USBD_Type) SetTASKS_EP0STALL(value uint32) {
	volatile.StoreUint32(&o.TASKS_EP0STALL.Reg, volatile.LoadUint32(&o.TASKS_EP0STALL.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_EP0STALL() uint32 {
	return volatile.LoadUint32(&o.TASKS_EP0STALL.Reg) & 0x1
}

// USBD.TASKS_DPDMDRIVE: Forces D+ and D- lines into the state defined in the DPDMVALUE register
func (o *USBD_Type) SetTASKS_DPDMDRIVE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DPDMDRIVE.Reg, volatile.LoadUint32(&o.TASKS_DPDMDRIVE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_DPDMDRIVE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DPDMDRIVE.Reg) & 0x1
}

// USBD.TASKS_DPDMNODRIVE: Stops forcing D+ and D- lines into any state (USB engine takes control)
func (o *USBD_Type) SetTASKS_DPDMNODRIVE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DPDMNODRIVE.Reg, volatile.LoadUint32(&o.TASKS_DPDMNODRIVE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_DPDMNODRIVE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DPDMNODRIVE.Reg) & 0x1
}

// USBD.SUBSCRIBE_STARTEPIN: Description collection: Subscribe configuration for task STARTEPIN[n]
func (o *USBD_Type) SetSUBSCRIBE_STARTEPIN_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTEPIN[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTEPIN[idx].Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTEPIN_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTEPIN[idx].Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_STARTEPIN_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTEPIN[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTEPIN[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTEPIN_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTEPIN[idx].Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_STARTISOIN: Subscribe configuration for task STARTISOIN
func (o *USBD_Type) SetSUBSCRIBE_STARTISOIN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTISOIN.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTISOIN.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTISOIN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTISOIN.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_STARTISOIN_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTISOIN.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTISOIN.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTISOIN_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTISOIN.Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_STARTEPOUT: Description collection: Subscribe configuration for task STARTEPOUT[n]
func (o *USBD_Type) SetSUBSCRIBE_STARTEPOUT_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTEPOUT[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTEPOUT[idx].Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTEPOUT_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTEPOUT[idx].Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_STARTEPOUT_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTEPOUT[idx].Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTEPOUT[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTEPOUT_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTEPOUT[idx].Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_STARTISOOUT: Subscribe configuration for task STARTISOOUT
func (o *USBD_Type) SetSUBSCRIBE_STARTISOOUT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTISOOUT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTISOOUT.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTISOOUT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_STARTISOOUT.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_STARTISOOUT_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_STARTISOOUT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_STARTISOOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_STARTISOOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_STARTISOOUT.Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_EP0RCVOUT: Subscribe configuration for task EP0RCVOUT
func (o *USBD_Type) SetSUBSCRIBE_EP0RCVOUT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_EP0RCVOUT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_EP0RCVOUT.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_EP0RCVOUT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_EP0RCVOUT.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_EP0RCVOUT_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_EP0RCVOUT.Reg, volatile.LoadUint32(&o.SUBSCRIBE_EP0RCVOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_EP0RCVOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_EP0RCVOUT.Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_EP0STATUS: Subscribe configuration for task EP0STATUS
func (o *USBD_Type) SetSUBSCRIBE_EP0STATUS_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_EP0STATUS.Reg, volatile.LoadUint32(&o.SUBSCRIBE_EP0STATUS.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_EP0STATUS_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_EP0STATUS.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_EP0STATUS_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_EP0STATUS.Reg, volatile.LoadUint32(&o.SUBSCRIBE_EP0STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_EP0STATUS_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_EP0STATUS.Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_EP0STALL: Subscribe configuration for task EP0STALL
func (o *USBD_Type) SetSUBSCRIBE_EP0STALL_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_EP0STALL.Reg, volatile.LoadUint32(&o.SUBSCRIBE_EP0STALL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_EP0STALL_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_EP0STALL.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_EP0STALL_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_EP0STALL.Reg, volatile.LoadUint32(&o.SUBSCRIBE_EP0STALL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_EP0STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_EP0STALL.Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_DPDMDRIVE: Subscribe configuration for task DPDMDRIVE
func (o *USBD_Type) SetSUBSCRIBE_DPDMDRIVE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DPDMDRIVE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DPDMDRIVE.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_DPDMDRIVE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_DPDMDRIVE.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_DPDMDRIVE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DPDMDRIVE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DPDMDRIVE.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_DPDMDRIVE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_DPDMDRIVE.Reg) & 0x80000000) >> 31
}

// USBD.SUBSCRIBE_DPDMNODRIVE: Subscribe configuration for task DPDMNODRIVE
func (o *USBD_Type) SetSUBSCRIBE_DPDMNODRIVE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DPDMNODRIVE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DPDMNODRIVE.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetSUBSCRIBE_DPDMNODRIVE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.SUBSCRIBE_DPDMNODRIVE.Reg) & 0xff
}
func (o *USBD_Type) SetSUBSCRIBE_DPDMNODRIVE_EN(value uint32) {
	volatile.StoreUint32(&o.SUBSCRIBE_DPDMNODRIVE.Reg, volatile.LoadUint32(&o.SUBSCRIBE_DPDMNODRIVE.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetSUBSCRIBE_DPDMNODRIVE_EN() uint32 {
	return (volatile.LoadUint32(&o.SUBSCRIBE_DPDMNODRIVE.Reg) & 0x80000000) >> 31
}

// USBD.EVENTS_USBRESET: Signals that a USB reset condition has been detected on USB lines
func (o *USBD_Type) SetEVENTS_USBRESET(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBRESET.Reg, volatile.LoadUint32(&o.EVENTS_USBRESET.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_USBRESET() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBRESET.Reg) & 0x1
}

// USBD.EVENTS_STARTED: Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
func (o *USBD_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// USBD.EVENTS_ENDEPIN: Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDEPIN(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDEPIN[idx].Reg, volatile.LoadUint32(&o.EVENTS_ENDEPIN[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDEPIN(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDEPIN[idx].Reg) & 0x1
}

// USBD.EVENTS_EP0DATADONE: An acknowledged data transfer has taken place on the control endpoint
func (o *USBD_Type) SetEVENTS_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EP0DATADONE.Reg, volatile.LoadUint32(&o.EVENTS_EP0DATADONE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_EP0DATADONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EP0DATADONE.Reg) & 0x1
}

// USBD.EVENTS_ENDISOIN: The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDISOIN.Reg, volatile.LoadUint32(&o.EVENTS_ENDISOIN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDISOIN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDISOIN.Reg) & 0x1
}

// USBD.EVENTS_ENDEPOUT: Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDEPOUT(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDEPOUT[idx].Reg, volatile.LoadUint32(&o.EVENTS_ENDEPOUT[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDEPOUT(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDEPOUT[idx].Reg) & 0x1
}

// USBD.EVENTS_ENDISOOUT: The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDISOOUT.Reg, volatile.LoadUint32(&o.EVENTS_ENDISOOUT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDISOOUT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDISOOUT.Reg) & 0x1
}

// USBD.EVENTS_SOF: Signals that a SOF (start of frame) condition has been detected on USB lines
func (o *USBD_Type) SetEVENTS_SOF(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SOF.Reg, volatile.LoadUint32(&o.EVENTS_SOF.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_SOF() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SOF.Reg) & 0x1
}

// USBD.EVENTS_USBEVENT: An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
func (o *USBD_Type) SetEVENTS_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBEVENT.Reg, volatile.LoadUint32(&o.EVENTS_USBEVENT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_USBEVENT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBEVENT.Reg) & 0x1
}

// USBD.EVENTS_EP0SETUP: A valid SETUP token has been received (and acknowledged) on the control endpoint
func (o *USBD_Type) SetEVENTS_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EP0SETUP.Reg, volatile.LoadUint32(&o.EVENTS_EP0SETUP.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_EP0SETUP() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EP0SETUP.Reg) & 0x1
}

// USBD.EVENTS_EPDATA: A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
func (o *USBD_Type) SetEVENTS_EPDATA(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EPDATA.Reg, volatile.LoadUint32(&o.EVENTS_EPDATA.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_EPDATA() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EPDATA.Reg) & 0x1
}

// USBD.PUBLISH_USBRESET: Publish configuration for event USBRESET
func (o *USBD_Type) SetPUBLISH_USBRESET_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBRESET.Reg, volatile.LoadUint32(&o.PUBLISH_USBRESET.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_USBRESET_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_USBRESET.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_USBRESET_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBRESET.Reg, volatile.LoadUint32(&o.PUBLISH_USBRESET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_USBRESET_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_USBRESET.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_STARTED: Publish configuration for event STARTED
func (o *USBD_Type) SetPUBLISH_STARTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_STARTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_STARTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_STARTED.Reg, volatile.LoadUint32(&o.PUBLISH_STARTED.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_STARTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_STARTED.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_ENDEPIN: Description collection: Publish configuration for event ENDEPIN[n]
func (o *USBD_Type) SetPUBLISH_ENDEPIN_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDEPIN[idx].Reg, volatile.LoadUint32(&o.PUBLISH_ENDEPIN[idx].Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_ENDEPIN_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDEPIN[idx].Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_ENDEPIN_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDEPIN[idx].Reg, volatile.LoadUint32(&o.PUBLISH_ENDEPIN[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_ENDEPIN_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDEPIN[idx].Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_EP0DATADONE: Publish configuration for event EP0DATADONE
func (o *USBD_Type) SetPUBLISH_EP0DATADONE_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_EP0DATADONE.Reg, volatile.LoadUint32(&o.PUBLISH_EP0DATADONE.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_EP0DATADONE_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_EP0DATADONE.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_EP0DATADONE_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_EP0DATADONE.Reg, volatile.LoadUint32(&o.PUBLISH_EP0DATADONE.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_EP0DATADONE_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_EP0DATADONE.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_ENDISOIN: Publish configuration for event ENDISOIN
func (o *USBD_Type) SetPUBLISH_ENDISOIN_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDISOIN.Reg, volatile.LoadUint32(&o.PUBLISH_ENDISOIN.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_ENDISOIN_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDISOIN.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_ENDISOIN_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDISOIN.Reg, volatile.LoadUint32(&o.PUBLISH_ENDISOIN.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_ENDISOIN_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDISOIN.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_ENDEPOUT: Description collection: Publish configuration for event ENDEPOUT[n]
func (o *USBD_Type) SetPUBLISH_ENDEPOUT_CHIDX(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDEPOUT[idx].Reg, volatile.LoadUint32(&o.PUBLISH_ENDEPOUT[idx].Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_ENDEPOUT_CHIDX(idx int) uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDEPOUT[idx].Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_ENDEPOUT_EN(idx int, value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDEPOUT[idx].Reg, volatile.LoadUint32(&o.PUBLISH_ENDEPOUT[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_ENDEPOUT_EN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDEPOUT[idx].Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_ENDISOOUT: Publish configuration for event ENDISOOUT
func (o *USBD_Type) SetPUBLISH_ENDISOOUT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDISOOUT.Reg, volatile.LoadUint32(&o.PUBLISH_ENDISOOUT.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_ENDISOOUT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_ENDISOOUT.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_ENDISOOUT_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_ENDISOOUT.Reg, volatile.LoadUint32(&o.PUBLISH_ENDISOOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_ENDISOOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_ENDISOOUT.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_SOF: Publish configuration for event SOF
func (o *USBD_Type) SetPUBLISH_SOF_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SOF.Reg, volatile.LoadUint32(&o.PUBLISH_SOF.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_SOF_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_SOF.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_SOF_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_SOF.Reg, volatile.LoadUint32(&o.PUBLISH_SOF.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_SOF_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_SOF.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_USBEVENT: Publish configuration for event USBEVENT
func (o *USBD_Type) SetPUBLISH_USBEVENT_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBEVENT.Reg, volatile.LoadUint32(&o.PUBLISH_USBEVENT.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_USBEVENT_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_USBEVENT.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_USBEVENT_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBEVENT.Reg, volatile.LoadUint32(&o.PUBLISH_USBEVENT.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_USBEVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_USBEVENT.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_EP0SETUP: Publish configuration for event EP0SETUP
func (o *USBD_Type) SetPUBLISH_EP0SETUP_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_EP0SETUP.Reg, volatile.LoadUint32(&o.PUBLISH_EP0SETUP.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_EP0SETUP_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_EP0SETUP.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_EP0SETUP_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_EP0SETUP.Reg, volatile.LoadUint32(&o.PUBLISH_EP0SETUP.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_EP0SETUP_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_EP0SETUP.Reg) & 0x80000000) >> 31
}

// USBD.PUBLISH_EPDATA: Publish configuration for event EPDATA
func (o *USBD_Type) SetPUBLISH_EPDATA_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_EPDATA.Reg, volatile.LoadUint32(&o.PUBLISH_EPDATA.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetPUBLISH_EPDATA_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_EPDATA.Reg) & 0xff
}
func (o *USBD_Type) SetPUBLISH_EPDATA_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_EPDATA.Reg, volatile.LoadUint32(&o.PUBLISH_EPDATA.Reg)&^(0x80000000)|value<<31)
}
func (o *USBD_Type) GetPUBLISH_EPDATA_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_EPDATA.Reg) & 0x80000000) >> 31
}

// USBD.SHORTS: Shortcuts between local events and tasks
func (o *USBD_Type) SetSHORTS_EP0DATADONE_STARTEPIN0(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetSHORTS_EP0DATADONE_STARTEPIN0() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *USBD_Type) SetSHORTS_EP0DATADONE_STARTEPOUT0(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetSHORTS_EP0DATADONE_STARTEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetSHORTS_EP0DATADONE_EP0STATUS(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetSHORTS_EP0DATADONE_EP0STATUS() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetSHORTS_ENDEPOUT0_EP0STATUS(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetSHORTS_ENDEPOUT0_EP0STATUS() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetSHORTS_ENDEPOUT0_EP0RCVOUT(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetSHORTS_ENDEPOUT0_EP0RCVOUT() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// USBD.INTEN: Enable or disable interrupt
func (o *USBD_Type) SetINTEN_USBRESET(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetINTEN_USBRESET() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *USBD_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetINTEN_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetINTEN_ENDEPIN0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetINTEN_ENDEPIN0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetINTEN_ENDEPIN1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetINTEN_ENDEPIN1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetINTEN_ENDEPIN2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetINTEN_ENDEPIN2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetINTEN_ENDEPIN3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetINTEN_ENDEPIN3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetINTEN_ENDEPIN4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetINTEN_ENDEPIN4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetINTEN_ENDEPIN5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetINTEN_ENDEPIN5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetINTEN_ENDEPIN6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetINTEN_ENDEPIN6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetINTEN_ENDEPIN7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetINTEN_ENDEPIN7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetINTEN_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetINTEN_EP0DATADONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetINTEN_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetINTEN_ENDISOIN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *USBD_Type) SetINTEN_ENDEPOUT0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *USBD_Type) SetINTEN_ENDEPOUT1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *USBD_Type) SetINTEN_ENDEPOUT2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *USBD_Type) SetINTEN_ENDEPOUT3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}
func (o *USBD_Type) SetINTEN_ENDEPOUT4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetINTEN_ENDEPOUT5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetINTEN_ENDEPOUT6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetINTEN_ENDEPOUT7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetINTEN_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetINTEN_ENDISOOUT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetINTEN_SOF(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetINTEN_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetINTEN_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetINTEN_USBEVENT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetINTEN_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetINTEN_EP0SETUP() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetINTEN_EPDATA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetINTEN_EPDATA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}

// USBD.INTENSET: Enable interrupt
func (o *USBD_Type) SetINTENSET_USBRESET(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetINTENSET_USBRESET() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *USBD_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetINTENSET_ENDEPIN0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetINTENSET_ENDEPIN1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetINTENSET_ENDEPIN2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetINTENSET_ENDEPIN3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetINTENSET_ENDEPIN4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetINTENSET_ENDEPIN5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetINTENSET_ENDEPIN6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetINTENSET_ENDEPIN7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetINTENSET_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetINTENSET_EP0DATADONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetINTENSET_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetINTENSET_ENDISOIN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetINTENSET_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetINTENSET_ENDISOOUT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetINTENSET_SOF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetINTENSET_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetINTENSET_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetINTENSET_USBEVENT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetINTENSET_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetINTENSET_EP0SETUP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetINTENSET_EPDATA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetINTENSET_EPDATA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}

// USBD.INTENCLR: Disable interrupt
func (o *USBD_Type) SetINTENCLR_USBRESET(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetINTENCLR_USBRESET() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *USBD_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetINTENCLR_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetINTENCLR_EP0DATADONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetINTENCLR_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetINTENCLR_ENDISOIN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetINTENCLR_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetINTENCLR_ENDISOOUT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetINTENCLR_SOF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetINTENCLR_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetINTENCLR_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetINTENCLR_USBEVENT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetINTENCLR_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetINTENCLR_EP0SETUP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetINTENCLR_EPDATA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetINTENCLR_EPDATA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}

// USBD.EVENTCAUSE: Details on what caused the USBEVENT event
func (o *USBD_Type) SetEVENTCAUSE_ISOOUTCRC(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTCAUSE_ISOOUTCRC() uint32 {
	return volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x1
}
func (o *USBD_Type) SetEVENTCAUSE_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEVENTCAUSE_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetEVENTCAUSE_RESUME(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetEVENTCAUSE_RESUME() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetEVENTCAUSE_USBWUALLOWED(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetEVENTCAUSE_USBWUALLOWED() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetEVENTCAUSE_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetEVENTCAUSE_READY() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x800) >> 11
}

// USBD.EPSTATUS: Provides information on which endpoint's EasyDMA registers have been captured
func (o *USBD_Type) SetEPSTATUS_EPIN0(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEPSTATUS_EPIN0() uint32 {
	return volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x1
}
func (o *USBD_Type) SetEPSTATUS_EPIN1(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPSTATUS_EPIN1() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPSTATUS_EPIN2(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPSTATUS_EPIN2() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPSTATUS_EPIN3(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPSTATUS_EPIN3() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPSTATUS_EPIN4(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPSTATUS_EPIN4() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPSTATUS_EPIN5(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPSTATUS_EPIN5() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPSTATUS_EPIN6(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPSTATUS_EPIN6() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPSTATUS_EPIN7(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPSTATUS_EPIN7() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPSTATUS_EPIN8(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPSTATUS_EPIN8() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetEPSTATUS_EPOUT0(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT0() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetEPSTATUS_EPOUT1(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT1() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetEPSTATUS_EPOUT2(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT2() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetEPSTATUS_EPOUT3(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT3() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetEPSTATUS_EPOUT4(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT4() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetEPSTATUS_EPOUT5(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT5() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetEPSTATUS_EPOUT6(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT6() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetEPSTATUS_EPOUT7(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT7() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetEPSTATUS_EPOUT8(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT8() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x1000000) >> 24
}

// USBD.EPDATASTATUS: Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)
func (o *USBD_Type) SetEPDATASTATUS_EPIN1(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN1() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN2(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN2() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN3(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN3() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN4(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN4() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN5(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN5() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN6(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN6() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN7(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN7() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT1(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT1() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT2(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT2() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT3(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT3() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT4(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT4() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT5(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT5() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT6(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT6() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT7(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT7() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x800000) >> 23
}

// USBD.USBADDR: Device USB address
func (o *USBD_Type) SetUSBADDR_ADDR(value uint32) {
	volatile.StoreUint32(&o.USBADDR.Reg, volatile.LoadUint32(&o.USBADDR.Reg)&^(0x7f)|value)
}
func (o *USBD_Type) GetUSBADDR_ADDR() uint32 {
	return volatile.LoadUint32(&o.USBADDR.Reg) & 0x7f
}

// USBD.BMREQUESTTYPE: SETUP data, byte 0, bmRequestType
func (o *USBD_Type) SetBMREQUESTTYPE_RECIPIENT(value uint32) {
	volatile.StoreUint32(&o.BMREQUESTTYPE.Reg, volatile.LoadUint32(&o.BMREQUESTTYPE.Reg)&^(0x1f)|value)
}
func (o *USBD_Type) GetBMREQUESTTYPE_RECIPIENT() uint32 {
	return volatile.LoadUint32(&o.BMREQUESTTYPE.Reg) & 0x1f
}
func (o *USBD_Type) SetBMREQUESTTYPE_TYPE(value uint32) {
	volatile.StoreUint32(&o.BMREQUESTTYPE.Reg, volatile.LoadUint32(&o.BMREQUESTTYPE.Reg)&^(0x60)|value<<5)
}
func (o *USBD_Type) GetBMREQUESTTYPE_TYPE() uint32 {
	return (volatile.LoadUint32(&o.BMREQUESTTYPE.Reg) & 0x60) >> 5
}
func (o *USBD_Type) SetBMREQUESTTYPE_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.BMREQUESTTYPE.Reg, volatile.LoadUint32(&o.BMREQUESTTYPE.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetBMREQUESTTYPE_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.BMREQUESTTYPE.Reg) & 0x80) >> 7
}

// USBD.BREQUEST: SETUP data, byte 1, bRequest
func (o *USBD_Type) SetBREQUEST(value uint32) {
	volatile.StoreUint32(&o.BREQUEST.Reg, volatile.LoadUint32(&o.BREQUEST.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetBREQUEST() uint32 {
	return volatile.LoadUint32(&o.BREQUEST.Reg) & 0xff
}

// USBD.WVALUEL: SETUP data, byte 2, LSB of wValue
func (o *USBD_Type) SetWVALUEL(value uint32) {
	volatile.StoreUint32(&o.WVALUEL.Reg, volatile.LoadUint32(&o.WVALUEL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWVALUEL() uint32 {
	return volatile.LoadUint32(&o.WVALUEL.Reg) & 0xff
}

// USBD.WVALUEH: SETUP data, byte 3, MSB of wValue
func (o *USBD_Type) SetWVALUEH(value uint32) {
	volatile.StoreUint32(&o.WVALUEH.Reg, volatile.LoadUint32(&o.WVALUEH.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWVALUEH() uint32 {
	return volatile.LoadUint32(&o.WVALUEH.Reg) & 0xff
}

// USBD.WINDEXL: SETUP data, byte 4, LSB of wIndex
func (o *USBD_Type) SetWINDEXL(value uint32) {
	volatile.StoreUint32(&o.WINDEXL.Reg, volatile.LoadUint32(&o.WINDEXL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWINDEXL() uint32 {
	return volatile.LoadUint32(&o.WINDEXL.Reg) & 0xff
}

// USBD.WINDEXH: SETUP data, byte 5, MSB of wIndex
func (o *USBD_Type) SetWINDEXH(value uint32) {
	volatile.StoreUint32(&o.WINDEXH.Reg, volatile.LoadUint32(&o.WINDEXH.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWINDEXH() uint32 {
	return volatile.LoadUint32(&o.WINDEXH.Reg) & 0xff
}

// USBD.WLENGTHL: SETUP data, byte 6, LSB of wLength
func (o *USBD_Type) SetWLENGTHL(value uint32) {
	volatile.StoreUint32(&o.WLENGTHL.Reg, volatile.LoadUint32(&o.WLENGTHL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWLENGTHL() uint32 {
	return volatile.LoadUint32(&o.WLENGTHL.Reg) & 0xff
}

// USBD.WLENGTHH: SETUP data, byte 7, MSB of wLength
func (o *USBD_Type) SetWLENGTHH(value uint32) {
	volatile.StoreUint32(&o.WLENGTHH.Reg, volatile.LoadUint32(&o.WLENGTHH.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWLENGTHH() uint32 {
	return volatile.LoadUint32(&o.WLENGTHH.Reg) & 0xff
}

// USBD.ENABLE: Enable USB
func (o *USBD_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// USBD.USBPULLUP: Control of the USB pull-up
func (o *USBD_Type) SetUSBPULLUP_CONNECT(value uint32) {
	volatile.StoreUint32(&o.USBPULLUP.Reg, volatile.LoadUint32(&o.USBPULLUP.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetUSBPULLUP_CONNECT() uint32 {
	return volatile.LoadUint32(&o.USBPULLUP.Reg) & 0x1
}

// USBD.DPDMVALUE: State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing).
func (o *USBD_Type) SetDPDMVALUE_STATE(value uint32) {
	volatile.StoreUint32(&o.DPDMVALUE.Reg, volatile.LoadUint32(&o.DPDMVALUE.Reg)&^(0x1f)|value)
}
func (o *USBD_Type) GetDPDMVALUE_STATE() uint32 {
	return volatile.LoadUint32(&o.DPDMVALUE.Reg) & 0x1f
}

// USBD.DTOGGLE: Data toggle control and status
func (o *USBD_Type) SetDTOGGLE_EP(value uint32) {
	volatile.StoreUint32(&o.DTOGGLE.Reg, volatile.LoadUint32(&o.DTOGGLE.Reg)&^(0x7)|value)
}
func (o *USBD_Type) GetDTOGGLE_EP() uint32 {
	return volatile.LoadUint32(&o.DTOGGLE.Reg) & 0x7
}
func (o *USBD_Type) SetDTOGGLE_IO(value uint32) {
	volatile.StoreUint32(&o.DTOGGLE.Reg, volatile.LoadUint32(&o.DTOGGLE.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetDTOGGLE_IO() uint32 {
	return (volatile.LoadUint32(&o.DTOGGLE.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetDTOGGLE_VALUE(value uint32) {
	volatile.StoreUint32(&o.DTOGGLE.Reg, volatile.LoadUint32(&o.DTOGGLE.Reg)&^(0x300)|value<<8)
}
func (o *USBD_Type) GetDTOGGLE_VALUE() uint32 {
	return (volatile.LoadUint32(&o.DTOGGLE.Reg) & 0x300) >> 8
}

// USBD.EPINEN: Endpoint IN enable
func (o *USBD_Type) SetEPINEN_IN0(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEPINEN_IN0() uint32 {
	return volatile.LoadUint32(&o.EPINEN.Reg) & 0x1
}
func (o *USBD_Type) SetEPINEN_IN1(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPINEN_IN1() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPINEN_IN2(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPINEN_IN2() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPINEN_IN3(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPINEN_IN3() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPINEN_IN4(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPINEN_IN4() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPINEN_IN5(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPINEN_IN5() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPINEN_IN6(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPINEN_IN6() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPINEN_IN7(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPINEN_IN7() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPINEN_ISOIN(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPINEN_ISOIN() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x100) >> 8
}

// USBD.EPOUTEN: Endpoint OUT enable
func (o *USBD_Type) SetEPOUTEN_OUT0(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEPOUTEN_OUT0() uint32 {
	return volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x1
}
func (o *USBD_Type) SetEPOUTEN_OUT1(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPOUTEN_OUT1() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPOUTEN_OUT2(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPOUTEN_OUT2() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPOUTEN_OUT3(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPOUTEN_OUT3() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPOUTEN_OUT4(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPOUTEN_OUT4() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPOUTEN_OUT5(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPOUTEN_OUT5() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPOUTEN_OUT6(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPOUTEN_OUT6() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPOUTEN_OUT7(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPOUTEN_OUT7() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPOUTEN_ISOOUT(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPOUTEN_ISOOUT() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x100) >> 8
}

// USBD.EPSTALL: STALL endpoints
func (o *USBD_Type) SetEPSTALL_EP(value uint32) {
	volatile.StoreUint32(&o.EPSTALL.Reg, volatile.LoadUint32(&o.EPSTALL.Reg)&^(0x7)|value)
}
func (o *USBD_Type) GetEPSTALL_EP() uint32 {
	return volatile.LoadUint32(&o.EPSTALL.Reg) & 0x7
}
func (o *USBD_Type) SetEPSTALL_IO(value uint32) {
	volatile.StoreUint32(&o.EPSTALL.Reg, volatile.LoadUint32(&o.EPSTALL.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPSTALL_IO() uint32 {
	return (volatile.LoadUint32(&o.EPSTALL.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPSTALL_STALL(value uint32) {
	volatile.StoreUint32(&o.EPSTALL.Reg, volatile.LoadUint32(&o.EPSTALL.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPSTALL_STALL() uint32 {
	return (volatile.LoadUint32(&o.EPSTALL.Reg) & 0x100) >> 8
}

// USBD.ISOSPLIT: Controls the split of ISO buffers
func (o *USBD_Type) SetISOSPLIT_SPLIT(value uint32) {
	volatile.StoreUint32(&o.ISOSPLIT.Reg, volatile.LoadUint32(&o.ISOSPLIT.Reg)&^(0xffff)|value)
}
func (o *USBD_Type) GetISOSPLIT_SPLIT() uint32 {
	return volatile.LoadUint32(&o.ISOSPLIT.Reg) & 0xffff
}

// USBD.FRAMECNTR: Returns the current value of the start of frame counter
func (o *USBD_Type) SetFRAMECNTR(value uint32) {
	volatile.StoreUint32(&o.FRAMECNTR.Reg, volatile.LoadUint32(&o.FRAMECNTR.Reg)&^(0x7ff)|value)
}
func (o *USBD_Type) GetFRAMECNTR() uint32 {
	return volatile.LoadUint32(&o.FRAMECNTR.Reg) & 0x7ff
}

// USBD.LOWPOWER: Controls USBD peripheral low power mode during USB suspend
func (o *USBD_Type) SetLOWPOWER(value uint32) {
	volatile.StoreUint32(&o.LOWPOWER.Reg, volatile.LoadUint32(&o.LOWPOWER.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetLOWPOWER() uint32 {
	return volatile.LoadUint32(&o.LOWPOWER.Reg) & 0x1
}

// USBD.ISOINCONFIG: Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
func (o *USBD_Type) SetISOINCONFIG_RESPONSE(value uint32) {
	volatile.StoreUint32(&o.ISOINCONFIG.Reg, volatile.LoadUint32(&o.ISOINCONFIG.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetISOINCONFIG_RESPONSE() uint32 {
	return volatile.LoadUint32(&o.ISOINCONFIG.Reg) & 0x1
}

type USBD_HALTED_Type struct {
	EPIN  [8]volatile.Register32 // 0x420
	_     [4]byte
	EPOUT [8]volatile.Register32 // 0x444
}

type USBD_SIZE_Type struct {
	EPOUT  [8]volatile.Register32 // 0x4A0
	ISOOUT volatile.Register32    // 0x4C0
}

// USBD_SIZE.ISOOUT: Number of bytes received last on this ISO OUT data endpoint
func (o *USBD_SIZE_Type) SetISOOUT_SIZE(value uint32) {
	volatile.StoreUint32(&o.ISOOUT.Reg, volatile.LoadUint32(&o.ISOOUT.Reg)&^(0x3ff)|value)
}
func (o *USBD_SIZE_Type) GetISOOUT_SIZE() uint32 {
	return volatile.LoadUint32(&o.ISOOUT.Reg) & 0x3ff
}
func (o *USBD_SIZE_Type) SetISOOUT_ZERO(value uint32) {
	volatile.StoreUint32(&o.ISOOUT.Reg, volatile.LoadUint32(&o.ISOOUT.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_SIZE_Type) GetISOOUT_ZERO() uint32 {
	return (volatile.LoadUint32(&o.ISOOUT.Reg) & 0x10000) >> 16
}

type USBD_EPIN_Type struct {
	PTR    volatile.Register32 // 0x600
	MAXCNT volatile.Register32 // 0x604
	AMOUNT volatile.Register32 // 0x608
	_      [8]byte
}

// USBD_EPIN.PTR: Description cluster: Data pointer
func (o *USBD_EPIN_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_EPIN_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_EPIN.MAXCNT: Description cluster: Maximum number of bytes to transfer
func (o *USBD_EPIN_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPIN_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7f
}

// USBD_EPIN.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
func (o *USBD_EPIN_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPIN_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7f
}

type USBD_ISOIN_Type struct {
	PTR    volatile.Register32 // 0x6A0
	MAXCNT volatile.Register32 // 0x6A4
	AMOUNT volatile.Register32 // 0x6A8
}

// USBD_ISOIN.PTR: Data pointer
func (o *USBD_ISOIN_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_ISOIN_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_ISOIN.MAXCNT: Maximum number of bytes to transfer
func (o *USBD_ISOIN_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOIN_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3ff
}

// USBD_ISOIN.AMOUNT: Number of bytes transferred in the last transaction
func (o *USBD_ISOIN_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOIN_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x3ff
}

type USBD_EPOUT_Type struct {
	PTR    volatile.Register32 // 0x700
	MAXCNT volatile.Register32 // 0x704
	AMOUNT volatile.Register32 // 0x708
	_      [8]byte
}

// USBD_EPOUT.PTR: Description cluster: Data pointer
func (o *USBD_EPOUT_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_EPOUT_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_EPOUT.MAXCNT: Description cluster: Maximum number of bytes to transfer
func (o *USBD_EPOUT_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPOUT_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7f
}

// USBD_EPOUT.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
func (o *USBD_EPOUT_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPOUT_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7f
}

type USBD_ISOOUT_Type struct {
	PTR    volatile.Register32 // 0x7A0
	MAXCNT volatile.Register32 // 0x7A4
	AMOUNT volatile.Register32 // 0x7A8
}

// USBD_ISOOUT.PTR: Data pointer
func (o *USBD_ISOOUT_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_ISOOUT_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_ISOOUT.MAXCNT: Maximum number of bytes to transfer
func (o *USBD_ISOOUT_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOOUT_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3ff
}

// USBD_ISOOUT.AMOUNT: Number of bytes transferred in the last transaction
func (o *USBD_ISOOUT_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOOUT_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x3ff
}

// USB Regulator 0
type USBREG_Type struct {
	_                   [256]byte
	EVENTS_USBDETECTED  volatile.Register32 // 0x100
	EVENTS_USBREMOVED   volatile.Register32 // 0x104
	EVENTS_USBPWRRDY    volatile.Register32 // 0x108
	_                   [116]byte
	PUBLISH_USBDETECTED volatile.Register32 // 0x180
	PUBLISH_USBREMOVED  volatile.Register32 // 0x184
	PUBLISH_USBPWRRDY   volatile.Register32 // 0x188
	_                   [372]byte
	INTEN               volatile.Register32 // 0x300
	INTENSET            volatile.Register32 // 0x304
	INTENCLR            volatile.Register32 // 0x308
	_                   [244]byte
	USBREGSTATUS        volatile.Register32 // 0x400
}

// USBREG.EVENTS_USBDETECTED: Voltage supply detected on VBUS
func (o *USBREG_Type) SetEVENTS_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBDETECTED.Reg, volatile.LoadUint32(&o.EVENTS_USBDETECTED.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetEVENTS_USBDETECTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBDETECTED.Reg) & 0x1
}

// USBREG.EVENTS_USBREMOVED: Voltage supply removed from VBUS
func (o *USBREG_Type) SetEVENTS_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBREMOVED.Reg, volatile.LoadUint32(&o.EVENTS_USBREMOVED.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetEVENTS_USBREMOVED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBREMOVED.Reg) & 0x1
}

// USBREG.EVENTS_USBPWRRDY: USB 3.3 V supply ready
func (o *USBREG_Type) SetEVENTS_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBPWRRDY.Reg, volatile.LoadUint32(&o.EVENTS_USBPWRRDY.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetEVENTS_USBPWRRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBPWRRDY.Reg) & 0x1
}

// USBREG.PUBLISH_USBDETECTED: Publish configuration for event USBDETECTED
func (o *USBREG_Type) SetPUBLISH_USBDETECTED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBDETECTED.Reg, volatile.LoadUint32(&o.PUBLISH_USBDETECTED.Reg)&^(0xff)|value)
}
func (o *USBREG_Type) GetPUBLISH_USBDETECTED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_USBDETECTED.Reg) & 0xff
}
func (o *USBREG_Type) SetPUBLISH_USBDETECTED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBDETECTED.Reg, volatile.LoadUint32(&o.PUBLISH_USBDETECTED.Reg)&^(0x80000000)|value<<31)
}
func (o *USBREG_Type) GetPUBLISH_USBDETECTED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_USBDETECTED.Reg) & 0x80000000) >> 31
}

// USBREG.PUBLISH_USBREMOVED: Publish configuration for event USBREMOVED
func (o *USBREG_Type) SetPUBLISH_USBREMOVED_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBREMOVED.Reg, volatile.LoadUint32(&o.PUBLISH_USBREMOVED.Reg)&^(0xff)|value)
}
func (o *USBREG_Type) GetPUBLISH_USBREMOVED_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_USBREMOVED.Reg) & 0xff
}
func (o *USBREG_Type) SetPUBLISH_USBREMOVED_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBREMOVED.Reg, volatile.LoadUint32(&o.PUBLISH_USBREMOVED.Reg)&^(0x80000000)|value<<31)
}
func (o *USBREG_Type) GetPUBLISH_USBREMOVED_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_USBREMOVED.Reg) & 0x80000000) >> 31
}

// USBREG.PUBLISH_USBPWRRDY: Publish configuration for event USBPWRRDY
func (o *USBREG_Type) SetPUBLISH_USBPWRRDY_CHIDX(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBPWRRDY.Reg, volatile.LoadUint32(&o.PUBLISH_USBPWRRDY.Reg)&^(0xff)|value)
}
func (o *USBREG_Type) GetPUBLISH_USBPWRRDY_CHIDX() uint32 {
	return volatile.LoadUint32(&o.PUBLISH_USBPWRRDY.Reg) & 0xff
}
func (o *USBREG_Type) SetPUBLISH_USBPWRRDY_EN(value uint32) {
	volatile.StoreUint32(&o.PUBLISH_USBPWRRDY.Reg, volatile.LoadUint32(&o.PUBLISH_USBPWRRDY.Reg)&^(0x80000000)|value<<31)
}
func (o *USBREG_Type) GetPUBLISH_USBPWRRDY_EN() uint32 {
	return (volatile.LoadUint32(&o.PUBLISH_USBPWRRDY.Reg) & 0x80000000) >> 31
}

// USBREG.INTEN: Enable or disable interrupt
func (o *USBREG_Type) SetINTEN_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetINTEN_USBDETECTED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *USBREG_Type) SetINTEN_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *USBREG_Type) GetINTEN_USBREMOVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *USBREG_Type) SetINTEN_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *USBREG_Type) GetINTEN_USBPWRRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}

// USBREG.INTENSET: Enable interrupt
func (o *USBREG_Type) SetINTENSET_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetINTENSET_USBDETECTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *USBREG_Type) SetINTENSET_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USBREG_Type) GetINTENSET_USBREMOVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *USBREG_Type) SetINTENSET_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USBREG_Type) GetINTENSET_USBPWRRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// USBREG.INTENCLR: Disable interrupt
func (o *USBREG_Type) SetINTENCLR_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetINTENCLR_USBDETECTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *USBREG_Type) SetINTENCLR_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USBREG_Type) GetINTENCLR_USBREMOVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *USBREG_Type) SetINTENCLR_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USBREG_Type) GetINTENCLR_USBPWRRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// USBREG.USBREGSTATUS: USB supply status
func (o *USBREG_Type) SetUSBREGSTATUS_VBUSDETECT(value uint32) {
	volatile.StoreUint32(&o.USBREGSTATUS.Reg, volatile.LoadUint32(&o.USBREGSTATUS.Reg)&^(0x1)|value)
}
func (o *USBREG_Type) GetUSBREGSTATUS_VBUSDETECT() uint32 {
	return volatile.LoadUint32(&o.USBREGSTATUS.Reg) & 0x1
}
func (o *USBREG_Type) SetUSBREGSTATUS_OUTPUTRDY(value uint32) {
	volatile.StoreUint32(&o.USBREGSTATUS.Reg, volatile.LoadUint32(&o.USBREGSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBREG_Type) GetUSBREGSTATUS_OUTPUTRDY() uint32 {
	return (volatile.LoadUint32(&o.USBREGSTATUS.Reg) & 0x2) >> 1
}

// Key management unit 0
type KMU_Type struct {
	TASKS_PUSH_KEYSLOT     volatile.Register32 // 0x0
	_                      [252]byte
	EVENTS_KEYSLOT_PUSHED  volatile.Register32 // 0x100
	EVENTS_KEYSLOT_REVOKED volatile.Register32 // 0x104
	EVENTS_KEYSLOT_ERROR   volatile.Register32 // 0x108
	_                      [500]byte
	INTEN                  volatile.Register32 // 0x300
	INTENSET               volatile.Register32 // 0x304
	INTENCLR               volatile.Register32 // 0x308
	INTPEND                volatile.Register32 // 0x30C
	_                      [252]byte
	STATUS                 volatile.Register32 // 0x40C
	_                      [240]byte
	SELECTKEYSLOT          volatile.Register32 // 0x500
}

// KMU.TASKS_PUSH_KEYSLOT: Push a key slot over secure APB
func (o *KMU_Type) SetTASKS_PUSH_KEYSLOT(value uint32) {
	volatile.StoreUint32(&o.TASKS_PUSH_KEYSLOT.Reg, volatile.LoadUint32(&o.TASKS_PUSH_KEYSLOT.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetTASKS_PUSH_KEYSLOT() uint32 {
	return volatile.LoadUint32(&o.TASKS_PUSH_KEYSLOT.Reg) & 0x1
}

// KMU.EVENTS_KEYSLOT_PUSHED: Key slot successfully pushed over secure APB
func (o *KMU_Type) SetEVENTS_KEYSLOT_PUSHED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_KEYSLOT_PUSHED.Reg, volatile.LoadUint32(&o.EVENTS_KEYSLOT_PUSHED.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetEVENTS_KEYSLOT_PUSHED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_KEYSLOT_PUSHED.Reg) & 0x1
}

// KMU.EVENTS_KEYSLOT_REVOKED: Key slot has been revoked and cannot be tasked for selection
func (o *KMU_Type) SetEVENTS_KEYSLOT_REVOKED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_KEYSLOT_REVOKED.Reg, volatile.LoadUint32(&o.EVENTS_KEYSLOT_REVOKED.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetEVENTS_KEYSLOT_REVOKED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_KEYSLOT_REVOKED.Reg) & 0x1
}

// KMU.EVENTS_KEYSLOT_ERROR: No key slot selected, no destination address defined, or error during push operation
func (o *KMU_Type) SetEVENTS_KEYSLOT_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_KEYSLOT_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_KEYSLOT_ERROR.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetEVENTS_KEYSLOT_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_KEYSLOT_ERROR.Reg) & 0x1
}

// KMU.INTEN: Enable or disable interrupt
func (o *KMU_Type) SetINTEN_KEYSLOT_PUSHED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetINTEN_KEYSLOT_PUSHED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *KMU_Type) SetINTEN_KEYSLOT_REVOKED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *KMU_Type) GetINTEN_KEYSLOT_REVOKED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *KMU_Type) SetINTEN_KEYSLOT_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *KMU_Type) GetINTEN_KEYSLOT_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}

// KMU.INTENSET: Enable interrupt
func (o *KMU_Type) SetINTENSET_KEYSLOT_PUSHED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetINTENSET_KEYSLOT_PUSHED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *KMU_Type) SetINTENSET_KEYSLOT_REVOKED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *KMU_Type) GetINTENSET_KEYSLOT_REVOKED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *KMU_Type) SetINTENSET_KEYSLOT_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *KMU_Type) GetINTENSET_KEYSLOT_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// KMU.INTENCLR: Disable interrupt
func (o *KMU_Type) SetINTENCLR_KEYSLOT_PUSHED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetINTENCLR_KEYSLOT_PUSHED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *KMU_Type) SetINTENCLR_KEYSLOT_REVOKED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *KMU_Type) GetINTENCLR_KEYSLOT_REVOKED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *KMU_Type) SetINTENCLR_KEYSLOT_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *KMU_Type) GetINTENCLR_KEYSLOT_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// KMU.INTPEND: Pending interrupts
func (o *KMU_Type) SetINTPEND_KEYSLOT_PUSHED(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetINTPEND_KEYSLOT_PUSHED() uint32 {
	return volatile.LoadUint32(&o.INTPEND.Reg) & 0x1
}
func (o *KMU_Type) SetINTPEND_KEYSLOT_REVOKED(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x2)|value<<1)
}
func (o *KMU_Type) GetINTPEND_KEYSLOT_REVOKED() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x2) >> 1
}
func (o *KMU_Type) SetINTPEND_KEYSLOT_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTPEND.Reg, volatile.LoadUint32(&o.INTPEND.Reg)&^(0x4)|value<<2)
}
func (o *KMU_Type) GetINTPEND_KEYSLOT_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTPEND.Reg) & 0x4) >> 2
}

// KMU.STATUS: Status bits for KMU operation
func (o *KMU_Type) SetSTATUS_SELECTED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *KMU_Type) GetSTATUS_SELECTED() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *KMU_Type) SetSTATUS_BLOCKED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *KMU_Type) GetSTATUS_BLOCKED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}

// KMU.SELECTKEYSLOT: Select key slot to be read over AHB or pushed over secure APB when TASKS_PUSH_KEYSLOT is started
func (o *KMU_Type) SetSELECTKEYSLOT_ID(value uint32) {
	volatile.StoreUint32(&o.SELECTKEYSLOT.Reg, volatile.LoadUint32(&o.SELECTKEYSLOT.Reg)&^(0xff)|value)
}
func (o *KMU_Type) GetSELECTKEYSLOT_ID() uint32 {
	return volatile.LoadUint32(&o.SELECTKEYSLOT.Reg) & 0xff
}

// Non-volatile memory controller 0
type NVMC_Type struct {
	_                   [1024]byte
	READY               volatile.Register32 // 0x400
	_                   [4]byte
	READYNEXT           volatile.Register32 // 0x408
	_                   [248]byte
	CONFIG              volatile.Register32 // 0x504
	_                   [4]byte
	ERASEALL            volatile.Register32 // 0x50C
	_                   [12]byte
	ERASEPAGEPARTIALCFG volatile.Register32 // 0x51C
	_                   [100]byte
	CONFIGNS            volatile.Register32 // 0x584
	WRITEUICRNS         volatile.Register32 // 0x588
}

// NVMC.READY: Ready flag
func (o *NVMC_Type) SetREADY(value uint32) {
	volatile.StoreUint32(&o.READY.Reg, volatile.LoadUint32(&o.READY.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetREADY() uint32 {
	return volatile.LoadUint32(&o.READY.Reg) & 0x1
}

// NVMC.READYNEXT: Ready flag
func (o *NVMC_Type) SetREADYNEXT(value uint32) {
	volatile.StoreUint32(&o.READYNEXT.Reg, volatile.LoadUint32(&o.READYNEXT.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetREADYNEXT() uint32 {
	return volatile.LoadUint32(&o.READYNEXT.Reg) & 0x1
}

// NVMC.CONFIG: Configuration register
func (o *NVMC_Type) SetCONFIG_WEN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x7)|value)
}
func (o *NVMC_Type) GetCONFIG_WEN() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x7
}

// NVMC.ERASEALL: Register for erasing all non-volatile user memory
func (o *NVMC_Type) SetERASEALL(value uint32) {
	volatile.StoreUint32(&o.ERASEALL.Reg, volatile.LoadUint32(&o.ERASEALL.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetERASEALL() uint32 {
	return volatile.LoadUint32(&o.ERASEALL.Reg) & 0x1
}

// NVMC.ERASEPAGEPARTIALCFG: Register for partial erase configuration
func (o *NVMC_Type) SetERASEPAGEPARTIALCFG_DURATION(value uint32) {
	volatile.StoreUint32(&o.ERASEPAGEPARTIALCFG.Reg, volatile.LoadUint32(&o.ERASEPAGEPARTIALCFG.Reg)&^(0x7f)|value)
}
func (o *NVMC_Type) GetERASEPAGEPARTIALCFG_DURATION() uint32 {
	return volatile.LoadUint32(&o.ERASEPAGEPARTIALCFG.Reg) & 0x7f
}

// NVMC.CONFIGNS: Unspecified
func (o *NVMC_Type) SetCONFIGNS_WEN(value uint32) {
	volatile.StoreUint32(&o.CONFIGNS.Reg, volatile.LoadUint32(&o.CONFIGNS.Reg)&^(0x3)|value)
}
func (o *NVMC_Type) GetCONFIGNS_WEN() uint32 {
	return volatile.LoadUint32(&o.CONFIGNS.Reg) & 0x3
}

// NVMC.WRITEUICRNS: Non-secure APPROTECT enable register
func (o *NVMC_Type) SetWRITEUICRNS_SET(value uint32) {
	volatile.StoreUint32(&o.WRITEUICRNS.Reg, volatile.LoadUint32(&o.WRITEUICRNS.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetWRITEUICRNS_SET() uint32 {
	return volatile.LoadUint32(&o.WRITEUICRNS.Reg) & 0x1
}
func (o *NVMC_Type) SetWRITEUICRNS_KEY(value uint32) {
	volatile.StoreUint32(&o.WRITEUICRNS.Reg, volatile.LoadUint32(&o.WRITEUICRNS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *NVMC_Type) GetWRITEUICRNS_KEY() uint32 {
	return (volatile.LoadUint32(&o.WRITEUICRNS.Reg) & 0xfffffff0) >> 4
}

// GPIO Port 0
type GPIO_Type struct {
	_              [4]byte
	OUT            volatile.Register32 // 0x4
	OUTSET         volatile.Register32 // 0x8
	OUTCLR         volatile.Register32 // 0xC
	IN             volatile.Register32 // 0x10
	DIR            volatile.Register32 // 0x14
	DIRSET         volatile.Register32 // 0x18
	DIRCLR         volatile.Register32 // 0x1C
	LATCH          volatile.Register32 // 0x20
	DETECTMODE     volatile.Register32 // 0x24
	DETECTMODE_SEC volatile.Register32 // 0x28
	_              [468]byte
	PIN_CNF        [32]volatile.Register32 // 0x200
}

// GPIO.OUT: Write GPIO port
func (o *GPIO_Type) SetOUT_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUT_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg) & 0x1
}
func (o *GPIO_Type) SetOUT_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUT_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUT_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUT_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUT_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUT_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUT_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUT_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUT_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUT_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUT_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUT_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUT_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUT_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUT_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUT_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUT_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUT_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUT_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUT_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUT_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUT_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUT_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUT_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUT_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUT_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUT_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUT_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUT_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUT_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUT_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUT_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUT_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUT_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUT_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUT_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUT_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUT_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUT_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUT_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUT_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUT_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUT_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUT_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUT_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUT_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUT_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUT_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUT_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUT_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUT_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUT_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUT_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUT_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUT_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUT_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUT_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUT_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUT_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUT_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUT_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUT_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80000000) >> 31
}

// GPIO.OUTSET: Set individual bits in GPIO port
func (o *GPIO_Type) SetOUTSET_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTSET_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUTSET.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTSET_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTSET_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTSET_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTSET_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTSET_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTSET_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTSET_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTSET_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTSET_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTSET_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTSET_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTSET_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTSET_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTSET_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUTSET_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUTSET_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUTSET_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUTSET_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUTSET_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUTSET_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUTSET_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUTSET_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUTSET_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUTSET_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUTSET_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUTSET_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUTSET_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUTSET_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUTSET_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUTSET_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUTSET_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUTSET_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUTSET_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUTSET_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUTSET_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUTSET_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUTSET_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUTSET_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUTSET_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUTSET_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUTSET_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUTSET_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUTSET_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUTSET_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUTSET_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUTSET_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUTSET_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUTSET_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUTSET_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUTSET_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUTSET_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUTSET_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUTSET_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUTSET_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUTSET_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUTSET_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUTSET_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUTSET_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUTSET_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUTSET_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUTSET_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUTSET_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80000000) >> 31
}

// GPIO.OUTCLR: Clear individual bits in GPIO port
func (o *GPIO_Type) SetOUTCLR_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTCLR_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTCLR_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTCLR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTCLR_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTCLR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTCLR_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTCLR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTCLR_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTCLR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTCLR_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTCLR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTCLR_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTCLR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTCLR_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTCLR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUTCLR_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUTCLR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUTCLR_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUTCLR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUTCLR_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUTCLR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUTCLR_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUTCLR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUTCLR_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUTCLR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUTCLR_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUTCLR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUTCLR_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUTCLR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUTCLR_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUTCLR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUTCLR_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUTCLR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUTCLR_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUTCLR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUTCLR_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUTCLR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUTCLR_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUTCLR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUTCLR_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUTCLR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUTCLR_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUTCLR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUTCLR_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUTCLR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUTCLR_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUTCLR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUTCLR_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUTCLR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUTCLR_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUTCLR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUTCLR_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUTCLR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUTCLR_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUTCLR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUTCLR_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUTCLR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUTCLR_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUTCLR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUTCLR_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUTCLR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUTCLR_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUTCLR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80000000) >> 31
}

// GPIO.IN: Read GPIO port
func (o *GPIO_Type) SetIN_PIN0(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIN_PIN0() uint32 {
	return volatile.LoadUint32(&o.IN.Reg) & 0x1
}
func (o *GPIO_Type) SetIN_PIN1(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIN_PIN1() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIN_PIN2(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIN_PIN2() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIN_PIN3(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIN_PIN3() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIN_PIN4(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIN_PIN4() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIN_PIN5(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIN_PIN5() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIN_PIN6(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIN_PIN6() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIN_PIN7(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIN_PIN7() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIN_PIN8(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIN_PIN8() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIN_PIN9(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIN_PIN9() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIN_PIN10(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIN_PIN10() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIN_PIN11(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIN_PIN11() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIN_PIN12(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIN_PIN12() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIN_PIN13(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIN_PIN13() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIN_PIN14(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIN_PIN14() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIN_PIN15(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIN_PIN15() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIN_PIN16(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetIN_PIN16() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetIN_PIN17(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetIN_PIN17() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetIN_PIN18(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetIN_PIN18() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetIN_PIN19(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetIN_PIN19() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetIN_PIN20(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetIN_PIN20() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetIN_PIN21(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetIN_PIN21() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetIN_PIN22(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetIN_PIN22() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetIN_PIN23(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetIN_PIN23() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetIN_PIN24(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetIN_PIN24() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetIN_PIN25(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetIN_PIN25() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetIN_PIN26(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetIN_PIN26() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetIN_PIN27(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetIN_PIN27() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetIN_PIN28(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetIN_PIN28() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetIN_PIN29(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetIN_PIN29() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetIN_PIN30(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetIN_PIN30() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetIN_PIN31(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetIN_PIN31() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80000000) >> 31
}

// GPIO.DIR: Direction of GPIO pins
func (o *GPIO_Type) SetDIR_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80000000) >> 31
}

// GPIO.DIRSET: DIR set register
func (o *GPIO_Type) SetDIRSET_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIRSET_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIRSET.Reg) & 0x1
}
func (o *GPIO_Type) SetDIRSET_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIRSET_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIRSET_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIRSET_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIRSET_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIRSET_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIRSET_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIRSET_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIRSET_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIRSET_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIRSET_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIRSET_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIRSET_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIRSET_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIRSET_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIRSET_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIRSET_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIRSET_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIRSET_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIRSET_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIRSET_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIRSET_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIRSET_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIRSET_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIRSET_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIRSET_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIRSET_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIRSET_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIRSET_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIRSET_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIRSET_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIRSET_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIRSET_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIRSET_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIRSET_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIRSET_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIRSET_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIRSET_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIRSET_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIRSET_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIRSET_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIRSET_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIRSET_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIRSET_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIRSET_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIRSET_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIRSET_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIRSET_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIRSET_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIRSET_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIRSET_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIRSET_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIRSET_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIRSET_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIRSET_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIRSET_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIRSET_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIRSET_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIRSET_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIRSET_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIRSET_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIRSET_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80000000) >> 31
}

// GPIO.DIRCLR: DIR clear register
func (o *GPIO_Type) SetDIRCLR_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIRCLR_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIRCLR_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIRCLR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIRCLR_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIRCLR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIRCLR_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIRCLR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIRCLR_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIRCLR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIRCLR_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIRCLR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIRCLR_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIRCLR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIRCLR_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIRCLR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIRCLR_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIRCLR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIRCLR_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIRCLR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIRCLR_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIRCLR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIRCLR_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIRCLR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIRCLR_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIRCLR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIRCLR_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIRCLR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIRCLR_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIRCLR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIRCLR_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIRCLR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIRCLR_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIRCLR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIRCLR_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIRCLR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIRCLR_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIRCLR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIRCLR_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIRCLR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIRCLR_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIRCLR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIRCLR_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIRCLR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIRCLR_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIRCLR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIRCLR_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIRCLR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIRCLR_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIRCLR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIRCLR_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIRCLR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIRCLR_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIRCLR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIRCLR_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIRCLR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIRCLR_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIRCLR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIRCLR_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIRCLR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIRCLR_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIRCLR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIRCLR_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIRCLR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80000000) >> 31
}

// GPIO.LATCH: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
func (o *GPIO_Type) SetLATCH_PIN0(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLATCH_PIN0() uint32 {
	return volatile.LoadUint32(&o.LATCH.Reg) & 0x1
}
func (o *GPIO_Type) SetLATCH_PIN1(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLATCH_PIN1() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLATCH_PIN2(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLATCH_PIN2() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLATCH_PIN3(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLATCH_PIN3() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLATCH_PIN4(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLATCH_PIN4() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLATCH_PIN5(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLATCH_PIN5() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLATCH_PIN6(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLATCH_PIN6() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLATCH_PIN7(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLATCH_PIN7() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLATCH_PIN8(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLATCH_PIN8() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLATCH_PIN9(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLATCH_PIN9() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLATCH_PIN10(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLATCH_PIN10() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLATCH_PIN11(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLATCH_PIN11() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLATCH_PIN12(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLATCH_PIN12() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLATCH_PIN13(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLATCH_PIN13() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLATCH_PIN14(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLATCH_PIN14() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLATCH_PIN15(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLATCH_PIN15() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLATCH_PIN16(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLATCH_PIN16() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLATCH_PIN17(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetLATCH_PIN17() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetLATCH_PIN18(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetLATCH_PIN18() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetLATCH_PIN19(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetLATCH_PIN19() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetLATCH_PIN20(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetLATCH_PIN20() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetLATCH_PIN21(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetLATCH_PIN21() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetLATCH_PIN22(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetLATCH_PIN22() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetLATCH_PIN23(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetLATCH_PIN23() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetLATCH_PIN24(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetLATCH_PIN24() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetLATCH_PIN25(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetLATCH_PIN25() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetLATCH_PIN26(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetLATCH_PIN26() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetLATCH_PIN27(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetLATCH_PIN27() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetLATCH_PIN28(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetLATCH_PIN28() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetLATCH_PIN29(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetLATCH_PIN29() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetLATCH_PIN30(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetLATCH_PIN30() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetLATCH_PIN31(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetLATCH_PIN31() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80000000) >> 31
}

// GPIO.DETECTMODE: Select between default DETECT signal behavior and LDETECT mode (For non-secure pin only)
func (o *GPIO_Type) SetDETECTMODE(value uint32) {
	volatile.StoreUint32(&o.DETECTMODE.Reg, volatile.LoadUint32(&o.DETECTMODE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDETECTMODE() uint32 {
	return volatile.LoadUint32(&o.DETECTMODE.Reg) & 0x1
}

// GPIO.DETECTMODE_SEC: Select between default DETECT signal behavior and LDETECT mode (For secure pin only)
func (o *GPIO_Type) SetDETECTMODE_SEC_DETECTMODE(value uint32) {
	volatile.StoreUint32(&o.DETECTMODE_SEC.Reg, volatile.LoadUint32(&o.DETECTMODE_SEC.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDETECTMODE_SEC_DETECTMODE() uint32 {
	return volatile.LoadUint32(&o.DETECTMODE_SEC.Reg) & 0x1
}

// GPIO.PIN_CNF: Description collection: Configuration of GPIO pins
func (o *GPIO_Type) SetPIN_CNF_DIR(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN_CNF_DIR(idx int) uint32 {
	return volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x1
}
func (o *GPIO_Type) SetPIN_CNF_INPUT(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN_CNF_INPUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN_CNF_PULL(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPIN_CNF_PULL(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPIN_CNF_DRIVE(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetPIN_CNF_DRIVE(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetPIN_CNF_SENSE(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPIN_CNF_SENSE(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetPIN_CNF_MCUSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x70000000)|value<<28)
}
func (o *GPIO_Type) GetPIN_CNF_MCUSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x70000000) >> 28
}

// ARM TrustZone CryptoCell register interface
type CRYPTOCELL_Type struct {
	_      [1280]byte
	ENABLE volatile.Register32 // 0x500
}

// CRYPTOCELL.ENABLE: Enable CRYPTOCELL subsystem.
func (o *CRYPTOCELL_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *CRYPTOCELL_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// Volatile Memory controller 0
type VMC_Type struct {
	_   [1536]byte
	RAM [8]VMC_RAM_Type // 0x600
}

type VMC_RAM_Type struct {
	POWER    volatile.Register32 // 0x600
	POWERSET volatile.Register32 // 0x604
	POWERCLR volatile.Register32 // 0x608
	_        [4]byte
}

// VMC_RAM.POWER: Description cluster: RAM[n] power control register
func (o *VMC_RAM_Type) SetPOWER_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1)|value)
}
func (o *VMC_RAM_Type) GetPOWER_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x1
}
func (o *VMC_RAM_Type) SetPOWER_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x2)|value<<1)
}
func (o *VMC_RAM_Type) GetPOWER_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x2) >> 1
}
func (o *VMC_RAM_Type) SetPOWER_S2POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x4)|value<<2)
}
func (o *VMC_RAM_Type) GetPOWER_S2POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x4) >> 2
}
func (o *VMC_RAM_Type) SetPOWER_S3POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x8)|value<<3)
}
func (o *VMC_RAM_Type) GetPOWER_S3POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x8) >> 3
}
func (o *VMC_RAM_Type) SetPOWER_S4POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x10)|value<<4)
}
func (o *VMC_RAM_Type) GetPOWER_S4POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x10) >> 4
}
func (o *VMC_RAM_Type) SetPOWER_S5POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x20)|value<<5)
}
func (o *VMC_RAM_Type) GetPOWER_S5POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x20) >> 5
}
func (o *VMC_RAM_Type) SetPOWER_S6POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x40)|value<<6)
}
func (o *VMC_RAM_Type) GetPOWER_S6POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x40) >> 6
}
func (o *VMC_RAM_Type) SetPOWER_S7POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x80)|value<<7)
}
func (o *VMC_RAM_Type) GetPOWER_S7POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x80) >> 7
}
func (o *VMC_RAM_Type) SetPOWER_S8POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x100)|value<<8)
}
func (o *VMC_RAM_Type) GetPOWER_S8POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x100) >> 8
}
func (o *VMC_RAM_Type) SetPOWER_S9POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x200)|value<<9)
}
func (o *VMC_RAM_Type) GetPOWER_S9POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x200) >> 9
}
func (o *VMC_RAM_Type) SetPOWER_S10POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x400)|value<<10)
}
func (o *VMC_RAM_Type) GetPOWER_S10POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x400) >> 10
}
func (o *VMC_RAM_Type) SetPOWER_S11POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x800)|value<<11)
}
func (o *VMC_RAM_Type) GetPOWER_S11POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x800) >> 11
}
func (o *VMC_RAM_Type) SetPOWER_S12POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1000)|value<<12)
}
func (o *VMC_RAM_Type) GetPOWER_S12POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x1000) >> 12
}
func (o *VMC_RAM_Type) SetPOWER_S13POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x2000)|value<<13)
}
func (o *VMC_RAM_Type) GetPOWER_S13POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x2000) >> 13
}
func (o *VMC_RAM_Type) SetPOWER_S14POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x4000)|value<<14)
}
func (o *VMC_RAM_Type) GetPOWER_S14POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x4000) >> 14
}
func (o *VMC_RAM_Type) SetPOWER_S15POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x8000)|value<<15)
}
func (o *VMC_RAM_Type) GetPOWER_S15POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x8000) >> 15
}
func (o *VMC_RAM_Type) SetPOWER_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x10000)|value<<16)
}
func (o *VMC_RAM_Type) GetPOWER_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x10000) >> 16
}
func (o *VMC_RAM_Type) SetPOWER_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x20000)|value<<17)
}
func (o *VMC_RAM_Type) GetPOWER_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x20000) >> 17
}
func (o *VMC_RAM_Type) SetPOWER_S2RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x40000)|value<<18)
}
func (o *VMC_RAM_Type) GetPOWER_S2RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x40000) >> 18
}
func (o *VMC_RAM_Type) SetPOWER_S3RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x80000)|value<<19)
}
func (o *VMC_RAM_Type) GetPOWER_S3RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x80000) >> 19
}
func (o *VMC_RAM_Type) SetPOWER_S4RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x100000)|value<<20)
}
func (o *VMC_RAM_Type) GetPOWER_S4RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x100000) >> 20
}
func (o *VMC_RAM_Type) SetPOWER_S5RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x200000)|value<<21)
}
func (o *VMC_RAM_Type) GetPOWER_S5RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x200000) >> 21
}
func (o *VMC_RAM_Type) SetPOWER_S6RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x400000)|value<<22)
}
func (o *VMC_RAM_Type) GetPOWER_S6RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x400000) >> 22
}
func (o *VMC_RAM_Type) SetPOWER_S7RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x800000)|value<<23)
}
func (o *VMC_RAM_Type) GetPOWER_S7RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x800000) >> 23
}
func (o *VMC_RAM_Type) SetPOWER_S8RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1000000)|value<<24)
}
func (o *VMC_RAM_Type) GetPOWER_S8RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x1000000) >> 24
}
func (o *VMC_RAM_Type) SetPOWER_S9RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x2000000)|value<<25)
}
func (o *VMC_RAM_Type) GetPOWER_S9RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x2000000) >> 25
}
func (o *VMC_RAM_Type) SetPOWER_S10RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x4000000)|value<<26)
}
func (o *VMC_RAM_Type) GetPOWER_S10RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x4000000) >> 26
}
func (o *VMC_RAM_Type) SetPOWER_S11RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *VMC_RAM_Type) GetPOWER_S11RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x8000000) >> 27
}
func (o *VMC_RAM_Type) SetPOWER_S12RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *VMC_RAM_Type) GetPOWER_S12RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x10000000) >> 28
}
func (o *VMC_RAM_Type) SetPOWER_S13RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *VMC_RAM_Type) GetPOWER_S13RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x20000000) >> 29
}
func (o *VMC_RAM_Type) SetPOWER_S14RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *VMC_RAM_Type) GetPOWER_S14RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x40000000) >> 30
}
func (o *VMC_RAM_Type) SetPOWER_S15RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *VMC_RAM_Type) GetPOWER_S15RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x80000000) >> 31
}

// VMC_RAM.POWERSET: Description cluster: RAM[n] power control set register
func (o *VMC_RAM_Type) SetPOWERSET_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x1)|value)
}
func (o *VMC_RAM_Type) GetPOWERSET_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWERSET.Reg) & 0x1
}
func (o *VMC_RAM_Type) SetPOWERSET_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x2)|value<<1)
}
func (o *VMC_RAM_Type) GetPOWERSET_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x2) >> 1
}
func (o *VMC_RAM_Type) SetPOWERSET_S2POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x4)|value<<2)
}
func (o *VMC_RAM_Type) GetPOWERSET_S2POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x4) >> 2
}
func (o *VMC_RAM_Type) SetPOWERSET_S3POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x8)|value<<3)
}
func (o *VMC_RAM_Type) GetPOWERSET_S3POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x8) >> 3
}
func (o *VMC_RAM_Type) SetPOWERSET_S4POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x10)|value<<4)
}
func (o *VMC_RAM_Type) GetPOWERSET_S4POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x10) >> 4
}
func (o *VMC_RAM_Type) SetPOWERSET_S5POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x20)|value<<5)
}
func (o *VMC_RAM_Type) GetPOWERSET_S5POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x20) >> 5
}
func (o *VMC_RAM_Type) SetPOWERSET_S6POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x40)|value<<6)
}
func (o *VMC_RAM_Type) GetPOWERSET_S6POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x40) >> 6
}
func (o *VMC_RAM_Type) SetPOWERSET_S7POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x80)|value<<7)
}
func (o *VMC_RAM_Type) GetPOWERSET_S7POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x80) >> 7
}
func (o *VMC_RAM_Type) SetPOWERSET_S8POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x100)|value<<8)
}
func (o *VMC_RAM_Type) GetPOWERSET_S8POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x100) >> 8
}
func (o *VMC_RAM_Type) SetPOWERSET_S9POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x200)|value<<9)
}
func (o *VMC_RAM_Type) GetPOWERSET_S9POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x200) >> 9
}
func (o *VMC_RAM_Type) SetPOWERSET_S10POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x400)|value<<10)
}
func (o *VMC_RAM_Type) GetPOWERSET_S10POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x400) >> 10
}
func (o *VMC_RAM_Type) SetPOWERSET_S11POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x800)|value<<11)
}
func (o *VMC_RAM_Type) GetPOWERSET_S11POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x800) >> 11
}
func (o *VMC_RAM_Type) SetPOWERSET_S12POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x1000)|value<<12)
}
func (o *VMC_RAM_Type) GetPOWERSET_S12POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x1000) >> 12
}
func (o *VMC_RAM_Type) SetPOWERSET_S13POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x2000)|value<<13)
}
func (o *VMC_RAM_Type) GetPOWERSET_S13POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x2000) >> 13
}
func (o *VMC_RAM_Type) SetPOWERSET_S14POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x4000)|value<<14)
}
func (o *VMC_RAM_Type) GetPOWERSET_S14POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x4000) >> 14
}
func (o *VMC_RAM_Type) SetPOWERSET_S15POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x8000)|value<<15)
}
func (o *VMC_RAM_Type) GetPOWERSET_S15POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x8000) >> 15
}
func (o *VMC_RAM_Type) SetPOWERSET_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x10000)|value<<16)
}
func (o *VMC_RAM_Type) GetPOWERSET_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x10000) >> 16
}
func (o *VMC_RAM_Type) SetPOWERSET_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x20000)|value<<17)
}
func (o *VMC_RAM_Type) GetPOWERSET_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x20000) >> 17
}
func (o *VMC_RAM_Type) SetPOWERSET_S2RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x40000)|value<<18)
}
func (o *VMC_RAM_Type) GetPOWERSET_S2RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x40000) >> 18
}
func (o *VMC_RAM_Type) SetPOWERSET_S3RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x80000)|value<<19)
}
func (o *VMC_RAM_Type) GetPOWERSET_S3RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x80000) >> 19
}
func (o *VMC_RAM_Type) SetPOWERSET_S4RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x100000)|value<<20)
}
func (o *VMC_RAM_Type) GetPOWERSET_S4RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x100000) >> 20
}
func (o *VMC_RAM_Type) SetPOWERSET_S5RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x200000)|value<<21)
}
func (o *VMC_RAM_Type) GetPOWERSET_S5RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x200000) >> 21
}
func (o *VMC_RAM_Type) SetPOWERSET_S6RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x400000)|value<<22)
}
func (o *VMC_RAM_Type) GetPOWERSET_S6RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x400000) >> 22
}
func (o *VMC_RAM_Type) SetPOWERSET_S7RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x800000)|value<<23)
}
func (o *VMC_RAM_Type) GetPOWERSET_S7RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x800000) >> 23
}
func (o *VMC_RAM_Type) SetPOWERSET_S8RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x1000000)|value<<24)
}
func (o *VMC_RAM_Type) GetPOWERSET_S8RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x1000000) >> 24
}
func (o *VMC_RAM_Type) SetPOWERSET_S9RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x2000000)|value<<25)
}
func (o *VMC_RAM_Type) GetPOWERSET_S9RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x2000000) >> 25
}
func (o *VMC_RAM_Type) SetPOWERSET_S10RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x4000000)|value<<26)
}
func (o *VMC_RAM_Type) GetPOWERSET_S10RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x4000000) >> 26
}
func (o *VMC_RAM_Type) SetPOWERSET_S11RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x8000000)|value<<27)
}
func (o *VMC_RAM_Type) GetPOWERSET_S11RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x8000000) >> 27
}
func (o *VMC_RAM_Type) SetPOWERSET_S12RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x10000000)|value<<28)
}
func (o *VMC_RAM_Type) GetPOWERSET_S12RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x10000000) >> 28
}
func (o *VMC_RAM_Type) SetPOWERSET_S13RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x20000000)|value<<29)
}
func (o *VMC_RAM_Type) GetPOWERSET_S13RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x20000000) >> 29
}
func (o *VMC_RAM_Type) SetPOWERSET_S14RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x40000000)|value<<30)
}
func (o *VMC_RAM_Type) GetPOWERSET_S14RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x40000000) >> 30
}
func (o *VMC_RAM_Type) SetPOWERSET_S15RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x80000000)|value<<31)
}
func (o *VMC_RAM_Type) GetPOWERSET_S15RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x80000000) >> 31
}

// VMC_RAM.POWERCLR: Description cluster: RAM[n] power control clear register
func (o *VMC_RAM_Type) SetPOWERCLR_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x1)|value)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWERCLR.Reg) & 0x1
}
func (o *VMC_RAM_Type) SetPOWERCLR_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x2)|value<<1)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x2) >> 1
}
func (o *VMC_RAM_Type) SetPOWERCLR_S2POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x4)|value<<2)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S2POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x4) >> 2
}
func (o *VMC_RAM_Type) SetPOWERCLR_S3POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x8)|value<<3)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S3POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x8) >> 3
}
func (o *VMC_RAM_Type) SetPOWERCLR_S4POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x10)|value<<4)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S4POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x10) >> 4
}
func (o *VMC_RAM_Type) SetPOWERCLR_S5POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x20)|value<<5)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S5POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x20) >> 5
}
func (o *VMC_RAM_Type) SetPOWERCLR_S6POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x40)|value<<6)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S6POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x40) >> 6
}
func (o *VMC_RAM_Type) SetPOWERCLR_S7POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x80)|value<<7)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S7POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x80) >> 7
}
func (o *VMC_RAM_Type) SetPOWERCLR_S8POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x100)|value<<8)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S8POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x100) >> 8
}
func (o *VMC_RAM_Type) SetPOWERCLR_S9POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x200)|value<<9)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S9POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x200) >> 9
}
func (o *VMC_RAM_Type) SetPOWERCLR_S10POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x400)|value<<10)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S10POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x400) >> 10
}
func (o *VMC_RAM_Type) SetPOWERCLR_S11POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x800)|value<<11)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S11POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x800) >> 11
}
func (o *VMC_RAM_Type) SetPOWERCLR_S12POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x1000)|value<<12)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S12POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x1000) >> 12
}
func (o *VMC_RAM_Type) SetPOWERCLR_S13POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x2000)|value<<13)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S13POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x2000) >> 13
}
func (o *VMC_RAM_Type) SetPOWERCLR_S14POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x4000)|value<<14)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S14POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x4000) >> 14
}
func (o *VMC_RAM_Type) SetPOWERCLR_S15POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x8000)|value<<15)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S15POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x8000) >> 15
}
func (o *VMC_RAM_Type) SetPOWERCLR_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x10000)|value<<16)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x10000) >> 16
}
func (o *VMC_RAM_Type) SetPOWERCLR_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x20000)|value<<17)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x20000) >> 17
}
func (o *VMC_RAM_Type) SetPOWERCLR_S2RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x40000)|value<<18)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S2RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x40000) >> 18
}
func (o *VMC_RAM_Type) SetPOWERCLR_S3RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x80000)|value<<19)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S3RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x80000) >> 19
}
func (o *VMC_RAM_Type) SetPOWERCLR_S4RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x100000)|value<<20)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S4RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x100000) >> 20
}
func (o *VMC_RAM_Type) SetPOWERCLR_S5RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x200000)|value<<21)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S5RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x200000) >> 21
}
func (o *VMC_RAM_Type) SetPOWERCLR_S6RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x400000)|value<<22)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S6RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x400000) >> 22
}
func (o *VMC_RAM_Type) SetPOWERCLR_S7RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x800000)|value<<23)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S7RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x800000) >> 23
}
func (o *VMC_RAM_Type) SetPOWERCLR_S8RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S8RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x1000000) >> 24
}
func (o *VMC_RAM_Type) SetPOWERCLR_S9RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S9RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x2000000) >> 25
}
func (o *VMC_RAM_Type) SetPOWERCLR_S10RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S10RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x4000000) >> 26
}
func (o *VMC_RAM_Type) SetPOWERCLR_S11RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S11RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x8000000) >> 27
}
func (o *VMC_RAM_Type) SetPOWERCLR_S12RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S12RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x10000000) >> 28
}
func (o *VMC_RAM_Type) SetPOWERCLR_S13RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S13RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x20000000) >> 29
}
func (o *VMC_RAM_Type) SetPOWERCLR_S14RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S14RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x40000000) >> 30
}
func (o *VMC_RAM_Type) SetPOWERCLR_S15RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *VMC_RAM_Type) GetPOWERCLR_S15RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x80000000) >> 31
}

// Constants for CACHEDATA_S: CACHEDATA
const ()

// Constants for CACHEINFO_S: CACHEINFO
const (
	// SET.WAY: Description collection: Cache information for SET[n], WAY[o].
	// Position of TAG field.
	CACHEINFO_SET_WAY_TAG_Pos = 0x0
	// Bit mask of TAG field.
	CACHEINFO_SET_WAY_TAG_Msk = 0x1ffff
	// Position of V field.
	CACHEINFO_SET_WAY_V_Pos = 0x1e
	// Bit mask of V field.
	CACHEINFO_SET_WAY_V_Msk = 0x40000000
	// Bit V.
	CACHEINFO_SET_WAY_V = 0x40000000
	// Invalid cache line
	CACHEINFO_SET_WAY_V_Invalid = 0x0
	// Valid cache line
	CACHEINFO_SET_WAY_V_Valid = 0x1
	// Position of MRU field.
	CACHEINFO_SET_WAY_MRU_Pos = 0x1f
	// Bit mask of MRU field.
	CACHEINFO_SET_WAY_MRU_Msk = 0x80000000
	// Bit MRU.
	CACHEINFO_SET_WAY_MRU = 0x80000000
	// Way0 was most recently used
	CACHEINFO_SET_WAY_MRU_Way0 = 0x0
	// Way1 was most recently used
	CACHEINFO_SET_WAY_MRU_Way1 = 0x1
)

// Constants for FICR_S: Factory Information Configuration Registers
const (
	// INFO.CONFIGID: Configuration identifier
	// Position of HWID field.
	FICR_INFO_CONFIGID_HWID_Pos = 0x0
	// Bit mask of HWID field.
	FICR_INFO_CONFIGID_HWID_Msk = 0xffff

	// INFO.DEVICEID: Description collection: Device identifier
	// Position of DEVICEID field.
	FICR_INFO_DEVICEID_DEVICEID_Pos = 0x0
	// Bit mask of DEVICEID field.
	FICR_INFO_DEVICEID_DEVICEID_Msk = 0xffffffff

	// INFO.PART: Part code
	// Position of PART field.
	FICR_INFO_PART_PART_Pos = 0x0
	// Bit mask of PART field.
	FICR_INFO_PART_PART_Msk = 0xffffffff
	// nRF5340
	FICR_INFO_PART_PART_N5340 = 0x5340
	// Unspecified
	FICR_INFO_PART_PART_Unspecified = 0xffffffff

	// INFO.VARIANT: Part Variant, Hardware version and Production configuration
	// Position of VARIANT field.
	FICR_INFO_VARIANT_VARIANT_Pos = 0x0
	// Bit mask of VARIANT field.
	FICR_INFO_VARIANT_VARIANT_Msk = 0xffffffff
	// QKAA
	FICR_INFO_VARIANT_VARIANT_QKAA = 0x514b4141
	// Unspecified
	FICR_INFO_VARIANT_VARIANT_Unspecified = 0xffffffff

	// INFO.PACKAGE: Package option
	// Position of PACKAGE field.
	FICR_INFO_PACKAGE_PACKAGE_Pos = 0x0
	// Bit mask of PACKAGE field.
	FICR_INFO_PACKAGE_PACKAGE_Msk = 0xffffffff
	// QFxx - 94 pin QFN
	FICR_INFO_PACKAGE_PACKAGE_QF = 0x2000
	// Unspecified
	FICR_INFO_PACKAGE_PACKAGE_Unspecified = 0xffffffff

	// INFO.RAM: RAM variant
	// Position of RAM field.
	FICR_INFO_RAM_RAM_Pos = 0x0
	// Bit mask of RAM field.
	FICR_INFO_RAM_RAM_Msk = 0xffffffff
	// 16 kByte RAM
	FICR_INFO_RAM_RAM_K16 = 0x10
	// 32 kByte RAM
	FICR_INFO_RAM_RAM_K32 = 0x20
	// 64 kByte RAM
	FICR_INFO_RAM_RAM_K64 = 0x40
	// 128 kByte RAM
	FICR_INFO_RAM_RAM_K128 = 0x80
	// 256 kByte RAM
	FICR_INFO_RAM_RAM_K256 = 0x100
	// 512 kByte RAM
	FICR_INFO_RAM_RAM_K512 = 0x200
	// Unspecified
	FICR_INFO_RAM_RAM_Unspecified = 0xffffffff

	// INFO.FLASH: Flash variant
	// Position of FLASH field.
	FICR_INFO_FLASH_FLASH_Pos = 0x0
	// Bit mask of FLASH field.
	FICR_INFO_FLASH_FLASH_Msk = 0xffffffff
	// 128 kByte FLASH
	FICR_INFO_FLASH_FLASH_K128 = 0x80
	// 256 kByte FLASH
	FICR_INFO_FLASH_FLASH_K256 = 0x100
	// 512 kByte FLASH
	FICR_INFO_FLASH_FLASH_K512 = 0x200
	// 1 MByte FLASH
	FICR_INFO_FLASH_FLASH_K1024 = 0x400
	// 2 MByte FLASH
	FICR_INFO_FLASH_FLASH_K2048 = 0x800
	// Unspecified
	FICR_INFO_FLASH_FLASH_Unspecified = 0xffffffff

	// INFO.CODEPAGESIZE: Code memory page size in bytes
	// Position of CODEPAGESIZE field.
	FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Pos = 0x0
	// Bit mask of CODEPAGESIZE field.
	FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk = 0xffffffff
	// 4 kByte
	FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_K4096 = 0x1000

	// INFO.CODESIZE: Code memory size
	// Position of CODESIZE field.
	FICR_INFO_CODESIZE_CODESIZE_Pos = 0x0
	// Bit mask of CODESIZE field.
	FICR_INFO_CODESIZE_CODESIZE_Msk = 0xffffffff
	// 256 pages
	FICR_INFO_CODESIZE_CODESIZE_P256 = 0x100

	// INFO.DEVICETYPE: Device type
	// Position of DEVICETYPE field.
	FICR_INFO_DEVICETYPE_DEVICETYPE_Pos = 0x0
	// Bit mask of DEVICETYPE field.
	FICR_INFO_DEVICETYPE_DEVICETYPE_Msk = 0xffffffff
	// Device is an physical DIE
	FICR_INFO_DEVICETYPE_DEVICETYPE_Die = 0x0
	// Device is an FPGA
	FICR_INFO_DEVICETYPE_DEVICETYPE_FPGA = 0xffffffff

	// TRIMCNF.ADDR: Description cluster: Address of the PAR register which will be written
	// Position of Address field.
	FICR_TRIMCNF_ADDR_Address_Pos = 0x0
	// Bit mask of Address field.
	FICR_TRIMCNF_ADDR_Address_Msk = 0xffffffff

	// TRIMCNF.DATA: Description cluster: Data
	// Position of Data field.
	FICR_TRIMCNF_DATA_Data_Pos = 0x0
	// Bit mask of Data field.
	FICR_TRIMCNF_DATA_Data_Msk = 0xffffffff

	// NFC.TAGHEADER0: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of MFGID field.
	FICR_NFC_TAGHEADER0_MFGID_Pos = 0x0
	// Bit mask of MFGID field.
	FICR_NFC_TAGHEADER0_MFGID_Msk = 0xff
	// Position of UD1 field.
	FICR_NFC_TAGHEADER0_UD1_Pos = 0x8
	// Bit mask of UD1 field.
	FICR_NFC_TAGHEADER0_UD1_Msk = 0xff00
	// Position of UD2 field.
	FICR_NFC_TAGHEADER0_UD2_Pos = 0x10
	// Bit mask of UD2 field.
	FICR_NFC_TAGHEADER0_UD2_Msk = 0xff0000
	// Position of UD3 field.
	FICR_NFC_TAGHEADER0_UD3_Pos = 0x18
	// Bit mask of UD3 field.
	FICR_NFC_TAGHEADER0_UD3_Msk = 0xff000000

	// NFC.TAGHEADER1: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of UD4 field.
	FICR_NFC_TAGHEADER1_UD4_Pos = 0x0
	// Bit mask of UD4 field.
	FICR_NFC_TAGHEADER1_UD4_Msk = 0xff
	// Position of UD5 field.
	FICR_NFC_TAGHEADER1_UD5_Pos = 0x8
	// Bit mask of UD5 field.
	FICR_NFC_TAGHEADER1_UD5_Msk = 0xff00
	// Position of UD6 field.
	FICR_NFC_TAGHEADER1_UD6_Pos = 0x10
	// Bit mask of UD6 field.
	FICR_NFC_TAGHEADER1_UD6_Msk = 0xff0000
	// Position of UD7 field.
	FICR_NFC_TAGHEADER1_UD7_Pos = 0x18
	// Bit mask of UD7 field.
	FICR_NFC_TAGHEADER1_UD7_Msk = 0xff000000

	// NFC.TAGHEADER2: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of UD8 field.
	FICR_NFC_TAGHEADER2_UD8_Pos = 0x0
	// Bit mask of UD8 field.
	FICR_NFC_TAGHEADER2_UD8_Msk = 0xff
	// Position of UD9 field.
	FICR_NFC_TAGHEADER2_UD9_Pos = 0x8
	// Bit mask of UD9 field.
	FICR_NFC_TAGHEADER2_UD9_Msk = 0xff00
	// Position of UD10 field.
	FICR_NFC_TAGHEADER2_UD10_Pos = 0x10
	// Bit mask of UD10 field.
	FICR_NFC_TAGHEADER2_UD10_Msk = 0xff0000
	// Position of UD11 field.
	FICR_NFC_TAGHEADER2_UD11_Pos = 0x18
	// Bit mask of UD11 field.
	FICR_NFC_TAGHEADER2_UD11_Msk = 0xff000000

	// NFC.TAGHEADER3: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
	// Position of UD12 field.
	FICR_NFC_TAGHEADER3_UD12_Pos = 0x0
	// Bit mask of UD12 field.
	FICR_NFC_TAGHEADER3_UD12_Msk = 0xff
	// Position of UD13 field.
	FICR_NFC_TAGHEADER3_UD13_Pos = 0x8
	// Bit mask of UD13 field.
	FICR_NFC_TAGHEADER3_UD13_Msk = 0xff00
	// Position of UD14 field.
	FICR_NFC_TAGHEADER3_UD14_Pos = 0x10
	// Bit mask of UD14 field.
	FICR_NFC_TAGHEADER3_UD14_Msk = 0xff0000
	// Position of UD15 field.
	FICR_NFC_TAGHEADER3_UD15_Pos = 0x18
	// Bit mask of UD15 field.
	FICR_NFC_TAGHEADER3_UD15_Msk = 0xff000000

	// TRNG90B.BYTES: Amount of bytes for the required entropy bits
	// Position of BYTES field.
	FICR_TRNG90B_BYTES_BYTES_Pos = 0x0
	// Bit mask of BYTES field.
	FICR_TRNG90B_BYTES_BYTES_Msk = 0xffffffff

	// TRNG90B.RCCUTOFF: Repetition counter cutoff
	// Position of RCCUTOFF field.
	FICR_TRNG90B_RCCUTOFF_RCCUTOFF_Pos = 0x0
	// Bit mask of RCCUTOFF field.
	FICR_TRNG90B_RCCUTOFF_RCCUTOFF_Msk = 0xffffffff

	// TRNG90B.APCUTOFF: Adaptive proportion cutoff
	// Position of APCUTOFF field.
	FICR_TRNG90B_APCUTOFF_APCUTOFF_Pos = 0x0
	// Bit mask of APCUTOFF field.
	FICR_TRNG90B_APCUTOFF_APCUTOFF_Msk = 0xffffffff

	// TRNG90B.STARTUP: Amount of bytes for the startup tests
	// Position of STARTUP field.
	FICR_TRNG90B_STARTUP_STARTUP_Pos = 0x0
	// Bit mask of STARTUP field.
	FICR_TRNG90B_STARTUP_STARTUP_Msk = 0xffffffff

	// TRNG90B.ROSC1: Sample count for ring oscillator 1
	// Position of ROSC1 field.
	FICR_TRNG90B_ROSC1_ROSC1_Pos = 0x0
	// Bit mask of ROSC1 field.
	FICR_TRNG90B_ROSC1_ROSC1_Msk = 0xffffffff

	// TRNG90B.ROSC2: Sample count for ring oscillator 2
	// Position of ROSC2 field.
	FICR_TRNG90B_ROSC2_ROSC2_Pos = 0x0
	// Bit mask of ROSC2 field.
	FICR_TRNG90B_ROSC2_ROSC2_Msk = 0xffffffff

	// TRNG90B.ROSC3: Sample count for ring oscillator 3
	// Position of ROSC3 field.
	FICR_TRNG90B_ROSC3_ROSC3_Pos = 0x0
	// Bit mask of ROSC3 field.
	FICR_TRNG90B_ROSC3_ROSC3_Msk = 0xffffffff

	// TRNG90B.ROSC4: Sample count for ring oscillator 4
	// Position of ROSC4 field.
	FICR_TRNG90B_ROSC4_ROSC4_Pos = 0x0
	// Bit mask of ROSC4 field.
	FICR_TRNG90B_ROSC4_ROSC4_Msk = 0xffffffff

	// XOSC32MTRIM: XOSC32M capacitor selection trim values
	// Position of SLOPE field.
	FICR_XOSC32MTRIM_SLOPE_Pos = 0x0
	// Bit mask of SLOPE field.
	FICR_XOSC32MTRIM_SLOPE_Msk = 0x1f
	// Position of OFFSET field.
	FICR_XOSC32MTRIM_OFFSET_Pos = 0x5
	// Bit mask of OFFSET field.
	FICR_XOSC32MTRIM_OFFSET_Msk = 0x3e0
)

// Constants for UICR_S: User Information Configuration Registers User information configuration registers
const (
	// APPROTECT: Access port protection
	// Position of PALL field.
	UICR_APPROTECT_PALL_Pos = 0x0
	// Bit mask of PALL field.
	UICR_APPROTECT_PALL_Msk = 0xffffffff
	// Unprotected
	UICR_APPROTECT_PALL_Unprotected = 0xffffffff
	// Protected
	UICR_APPROTECT_PALL_Protected = 0x0

	// EXTSUPPLY: Enable external circuitry to be supplied from VDD pin. Applicable in 'High voltage mode' only.
	// Position of EXTSUPPLY field.
	UICR_EXTSUPPLY_EXTSUPPLY_Pos = 0x0
	// Bit mask of EXTSUPPLY field.
	UICR_EXTSUPPLY_EXTSUPPLY_Msk = 0x1
	// Bit EXTSUPPLY.
	UICR_EXTSUPPLY_EXTSUPPLY = 0x1
	// No current can be drawn from the VDD pin.
	UICR_EXTSUPPLY_EXTSUPPLY_Disabled = 0x1
	// It is allowed to supply external circuitry from the VDD pin.
	UICR_EXTSUPPLY_EXTSUPPLY_Enabled = 0x0

	// VREGHVOUT: GPIO reference voltage / external output supply voltage in 'High voltage mode'.
	// Position of VREGHVOUT field.
	UICR_VREGHVOUT_VREGHVOUT_Pos = 0x0
	// Bit mask of VREGHVOUT field.
	UICR_VREGHVOUT_VREGHVOUT_Msk = 0x7
	// 1.8 V
	UICR_VREGHVOUT_VREGHVOUT_1V8 = 0x0
	// 2.1 V
	UICR_VREGHVOUT_VREGHVOUT_2V1 = 0x1
	// 2.4 V
	UICR_VREGHVOUT_VREGHVOUT_2V4 = 0x2
	// 2.7 V
	UICR_VREGHVOUT_VREGHVOUT_2V7 = 0x3
	// 3.0 V
	UICR_VREGHVOUT_VREGHVOUT_3V0 = 0x4
	// 3.3 V
	UICR_VREGHVOUT_VREGHVOUT_3V3 = 0x5
	// Default voltage: 1.8 V
	UICR_VREGHVOUT_VREGHVOUT_DEFAULT = 0x7

	// HFXOCNT: HFXO startup counter
	// Position of HFXOCNT field.
	UICR_HFXOCNT_HFXOCNT_Pos = 0x0
	// Bit mask of HFXOCNT field.
	UICR_HFXOCNT_HFXOCNT_Msk = 0xff
	// Min debounce time = (0*64 us + 0.5 us)
	UICR_HFXOCNT_HFXOCNT_MinDebounceTime = 0x0
	// Max debounce time = (254*64 us + 0.5 us)
	UICR_HFXOCNT_HFXOCNT_MaxDebounceTime = 0xfe
	// Default debounce time for erased UICR = 4*64 us + 0.5 us
	UICR_HFXOCNT_HFXOCNT_DefaultDebounceTime = 0xff

	// SECUREAPPROTECT: Secure access port protection
	// Position of PALL field.
	UICR_SECUREAPPROTECT_PALL_Pos = 0x0
	// Bit mask of PALL field.
	UICR_SECUREAPPROTECT_PALL_Msk = 0xffffffff
	// Unprotected
	UICR_SECUREAPPROTECT_PALL_Unprotected = 0xffffffff
	// Protected
	UICR_SECUREAPPROTECT_PALL_Protected = 0x0

	// ERASEPROTECT: Erase protection
	// Position of PALL field.
	UICR_ERASEPROTECT_PALL_Pos = 0x0
	// Bit mask of PALL field.
	UICR_ERASEPROTECT_PALL_Msk = 0xffffffff
	// Unprotected
	UICR_ERASEPROTECT_PALL_Unprotected = 0xffffffff
	// Protected
	UICR_ERASEPROTECT_PALL_Protected = 0x0

	// TINSTANCE: SW-DP Target instance
	// Position of TINSTANCE field.
	UICR_TINSTANCE_TINSTANCE_Pos = 0x1c
	// Bit mask of TINSTANCE field.
	UICR_TINSTANCE_TINSTANCE_Msk = 0xf0000000

	// NFCPINS: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
	// Position of PROTECT field.
	UICR_NFCPINS_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	UICR_NFCPINS_PROTECT_Msk = 0x1
	// Bit PROTECT.
	UICR_NFCPINS_PROTECT = 0x1
	// Operation as GPIO pins. Same protection as normal GPIO pins
	UICR_NFCPINS_PROTECT_Disabled = 0x0
	// Operation as NFC antenna pins. Configures the protection for NFC operation
	UICR_NFCPINS_PROTECT_NFC = 0x1

	// OTP: Description collection: One time programmable memory
	// Position of LOWER field.
	UICR_OTP_LOWER_Pos = 0x0
	// Bit mask of LOWER field.
	UICR_OTP_LOWER_Msk = 0xffff
	// Position of UPPER field.
	UICR_OTP_UPPER_Pos = 0x10
	// Bit mask of UPPER field.
	UICR_OTP_UPPER_Msk = 0xffff0000
)

// Constants for CTI_S: Cross-Trigger Interface control. NOTE: this is not a separate peripheral, but describes CM33 functionality.
const (
	// CTICONTROL: CTI Control register
	// Position of GLBEN field.
	CTI_CTICONTROL_GLBEN_Pos = 0x0
	// Bit mask of GLBEN field.
	CTI_CTICONTROL_GLBEN_Msk = 0x1
	// Bit GLBEN.
	CTI_CTICONTROL_GLBEN = 0x1
	// All cross-triggering mapping logic functionality is disabled.
	CTI_CTICONTROL_GLBEN_Disabled = 0x0
	// Cross-triggering mapping logic functionality is enabled.
	CTI_CTICONTROL_GLBEN_Enabled = 0x1

	// CTIINTACK: CTI Interrupt Acknowledge register
	// Position of DEBUGREQ field.
	CTI_CTIINTACK_DEBUGREQ_Pos = 0x0
	// Bit mask of DEBUGREQ field.
	CTI_CTIINTACK_DEBUGREQ_Msk = 0x1
	// Bit DEBUGREQ.
	CTI_CTIINTACK_DEBUGREQ = 0x1
	// Clears the ctitrigout.
	CTI_CTIINTACK_DEBUGREQ_Acknowledge = 0x1
	// Position of CPURESTART field.
	CTI_CTIINTACK_CPURESTART_Pos = 0x1
	// Bit mask of CPURESTART field.
	CTI_CTIINTACK_CPURESTART_Msk = 0x2
	// Bit CPURESTART.
	CTI_CTIINTACK_CPURESTART = 0x2
	// Clears the ctitrigout.
	CTI_CTIINTACK_CPURESTART_Acknowledge = 0x1
	// Position of UNUSED0 field.
	CTI_CTIINTACK_UNUSED0_Pos = 0x2
	// Bit mask of UNUSED0 field.
	CTI_CTIINTACK_UNUSED0_Msk = 0x4
	// Bit UNUSED0.
	CTI_CTIINTACK_UNUSED0 = 0x4
	// Clears the ctitrigout.
	CTI_CTIINTACK_UNUSED0_Acknowledge = 0x1
	// Position of UNUSED1 field.
	CTI_CTIINTACK_UNUSED1_Pos = 0x3
	// Bit mask of UNUSED1 field.
	CTI_CTIINTACK_UNUSED1_Msk = 0x8
	// Bit UNUSED1.
	CTI_CTIINTACK_UNUSED1 = 0x8
	// Clears the ctitrigout.
	CTI_CTIINTACK_UNUSED1_Acknowledge = 0x1
	// Position of ETMEVTIN0 field.
	CTI_CTIINTACK_ETMEVTIN0_Pos = 0x4
	// Bit mask of ETMEVTIN0 field.
	CTI_CTIINTACK_ETMEVTIN0_Msk = 0x10
	// Bit ETMEVTIN0.
	CTI_CTIINTACK_ETMEVTIN0 = 0x10
	// Clears the ctitrigout.
	CTI_CTIINTACK_ETMEVTIN0_Acknowledge = 0x1
	// Position of ETMEVTIN1 field.
	CTI_CTIINTACK_ETMEVTIN1_Pos = 0x5
	// Bit mask of ETMEVTIN1 field.
	CTI_CTIINTACK_ETMEVTIN1_Msk = 0x20
	// Bit ETMEVTIN1.
	CTI_CTIINTACK_ETMEVTIN1 = 0x20
	// Clears the ctitrigout.
	CTI_CTIINTACK_ETMEVTIN1_Acknowledge = 0x1
	// Position of ETMEVTIN2 field.
	CTI_CTIINTACK_ETMEVTIN2_Pos = 0x6
	// Bit mask of ETMEVTIN2 field.
	CTI_CTIINTACK_ETMEVTIN2_Msk = 0x40
	// Bit ETMEVTIN2.
	CTI_CTIINTACK_ETMEVTIN2 = 0x40
	// Clears the ctitrigout.
	CTI_CTIINTACK_ETMEVTIN2_Acknowledge = 0x1
	// Position of ETMEVTIN3 field.
	CTI_CTIINTACK_ETMEVTIN3_Pos = 0x7
	// Bit mask of ETMEVTIN3 field.
	CTI_CTIINTACK_ETMEVTIN3_Msk = 0x80
	// Bit ETMEVTIN3.
	CTI_CTIINTACK_ETMEVTIN3 = 0x80
	// Clears the ctitrigout.
	CTI_CTIINTACK_ETMEVTIN3_Acknowledge = 0x1

	// CTIAPPSET: CTI Application Trigger Set register
	// Position of APPSET_0 field.
	CTI_CTIAPPSET_APPSET_0_Pos = 0x0
	// Bit mask of APPSET_0 field.
	CTI_CTIAPPSET_APPSET_0_Msk = 0x1
	// Bit APPSET_0.
	CTI_CTIAPPSET_APPSET_0 = 0x1
	// Application trigger 0 is inactive.
	CTI_CTIAPPSET_APPSET_0_Inactive = 0x0
	// Application trigger 0 is active.
	CTI_CTIAPPSET_APPSET_0_Active = 0x1
	// Generate channel event for channel 0.
	CTI_CTIAPPSET_APPSET_0_Activate = 0x1
	// Position of APPSET_1 field.
	CTI_CTIAPPSET_APPSET_1_Pos = 0x1
	// Bit mask of APPSET_1 field.
	CTI_CTIAPPSET_APPSET_1_Msk = 0x2
	// Bit APPSET_1.
	CTI_CTIAPPSET_APPSET_1 = 0x2
	// Application trigger 1 is inactive.
	CTI_CTIAPPSET_APPSET_1_Inactive = 0x0
	// Application trigger 1 is active.
	CTI_CTIAPPSET_APPSET_1_Active = 0x1
	// Generate channel event for channel 1.
	CTI_CTIAPPSET_APPSET_1_Activate = 0x1
	// Position of APPSET_2 field.
	CTI_CTIAPPSET_APPSET_2_Pos = 0x2
	// Bit mask of APPSET_2 field.
	CTI_CTIAPPSET_APPSET_2_Msk = 0x4
	// Bit APPSET_2.
	CTI_CTIAPPSET_APPSET_2 = 0x4
	// Application trigger 2 is inactive.
	CTI_CTIAPPSET_APPSET_2_Inactive = 0x0
	// Application trigger 2 is active.
	CTI_CTIAPPSET_APPSET_2_Active = 0x1
	// Generate channel event for channel 2.
	CTI_CTIAPPSET_APPSET_2_Activate = 0x1
	// Position of APPSET_3 field.
	CTI_CTIAPPSET_APPSET_3_Pos = 0x3
	// Bit mask of APPSET_3 field.
	CTI_CTIAPPSET_APPSET_3_Msk = 0x8
	// Bit APPSET_3.
	CTI_CTIAPPSET_APPSET_3 = 0x8
	// Application trigger 3 is inactive.
	CTI_CTIAPPSET_APPSET_3_Inactive = 0x0
	// Application trigger 3 is active.
	CTI_CTIAPPSET_APPSET_3_Active = 0x1
	// Generate channel event for channel 3.
	CTI_CTIAPPSET_APPSET_3_Activate = 0x1

	// CTIAPPCLEAR: CTI Application Trigger Clear register
	// Position of APPCLEAR_0 field.
	CTI_CTIAPPCLEAR_APPCLEAR_0_Pos = 0x0
	// Bit mask of APPCLEAR_0 field.
	CTI_CTIAPPCLEAR_APPCLEAR_0_Msk = 0x1
	// Bit APPCLEAR_0.
	CTI_CTIAPPCLEAR_APPCLEAR_0 = 0x1
	// Clears the event for channel 0.
	CTI_CTIAPPCLEAR_APPCLEAR_0_Clear = 0x1
	// Position of APPCLEAR_1 field.
	CTI_CTIAPPCLEAR_APPCLEAR_1_Pos = 0x1
	// Bit mask of APPCLEAR_1 field.
	CTI_CTIAPPCLEAR_APPCLEAR_1_Msk = 0x2
	// Bit APPCLEAR_1.
	CTI_CTIAPPCLEAR_APPCLEAR_1 = 0x2
	// Clears the event for channel 1.
	CTI_CTIAPPCLEAR_APPCLEAR_1_Clear = 0x1
	// Position of APPCLEAR_2 field.
	CTI_CTIAPPCLEAR_APPCLEAR_2_Pos = 0x2
	// Bit mask of APPCLEAR_2 field.
	CTI_CTIAPPCLEAR_APPCLEAR_2_Msk = 0x4
	// Bit APPCLEAR_2.
	CTI_CTIAPPCLEAR_APPCLEAR_2 = 0x4
	// Clears the event for channel 2.
	CTI_CTIAPPCLEAR_APPCLEAR_2_Clear = 0x1
	// Position of APPCLEAR_3 field.
	CTI_CTIAPPCLEAR_APPCLEAR_3_Pos = 0x3
	// Bit mask of APPCLEAR_3 field.
	CTI_CTIAPPCLEAR_APPCLEAR_3_Msk = 0x8
	// Bit APPCLEAR_3.
	CTI_CTIAPPCLEAR_APPCLEAR_3 = 0x8
	// Clears the event for channel 3.
	CTI_CTIAPPCLEAR_APPCLEAR_3_Clear = 0x1

	// CTIAPPPULSE: CTI Application Pulse register
	// Position of APPULSE_0 field.
	CTI_CTIAPPPULSE_APPULSE_0_Pos = 0x0
	// Bit mask of APPULSE_0 field.
	CTI_CTIAPPPULSE_APPULSE_0_Msk = 0x1
	// Bit APPULSE_0.
	CTI_CTIAPPPULSE_APPULSE_0 = 0x1
	// Generates an event pulse on channel 0.
	CTI_CTIAPPPULSE_APPULSE_0_Generate = 0x1
	// Position of APPULSE_1 field.
	CTI_CTIAPPPULSE_APPULSE_1_Pos = 0x1
	// Bit mask of APPULSE_1 field.
	CTI_CTIAPPPULSE_APPULSE_1_Msk = 0x2
	// Bit APPULSE_1.
	CTI_CTIAPPPULSE_APPULSE_1 = 0x2
	// Generates an event pulse on channel 1.
	CTI_CTIAPPPULSE_APPULSE_1_Generate = 0x1
	// Position of APPULSE_2 field.
	CTI_CTIAPPPULSE_APPULSE_2_Pos = 0x2
	// Bit mask of APPULSE_2 field.
	CTI_CTIAPPPULSE_APPULSE_2_Msk = 0x4
	// Bit APPULSE_2.
	CTI_CTIAPPPULSE_APPULSE_2 = 0x4
	// Generates an event pulse on channel 2.
	CTI_CTIAPPPULSE_APPULSE_2_Generate = 0x1
	// Position of APPULSE_3 field.
	CTI_CTIAPPPULSE_APPULSE_3_Pos = 0x3
	// Bit mask of APPULSE_3 field.
	CTI_CTIAPPPULSE_APPULSE_3_Msk = 0x8
	// Bit APPULSE_3.
	CTI_CTIAPPPULSE_APPULSE_3 = 0x8
	// Generates an event pulse on channel 3.
	CTI_CTIAPPPULSE_APPULSE_3_Generate = 0x1

	// CTIINEN: Description collection: CTI Trigger input
	// Position of TRIGINEN_0 field.
	CTI_CTIINEN_TRIGINEN_0_Pos = 0x0
	// Bit mask of TRIGINEN_0 field.
	CTI_CTIINEN_TRIGINEN_0_Msk = 0x1
	// Bit TRIGINEN_0.
	CTI_CTIINEN_TRIGINEN_0 = 0x1
	// Input trigger n events are ignored by channel 0.
	CTI_CTIINEN_TRIGINEN_0_Disabled = 0x0
	// When an event is received on input trigger n (ctitrigin[n]), generate an event on channel 0.
	CTI_CTIINEN_TRIGINEN_0_Enabled = 0x1
	// Position of TRIGINEN_1 field.
	CTI_CTIINEN_TRIGINEN_1_Pos = 0x1
	// Bit mask of TRIGINEN_1 field.
	CTI_CTIINEN_TRIGINEN_1_Msk = 0x2
	// Bit TRIGINEN_1.
	CTI_CTIINEN_TRIGINEN_1 = 0x2
	// Input trigger n events are ignored by channel 1.
	CTI_CTIINEN_TRIGINEN_1_Disabled = 0x0
	// When an event is received on input trigger n (ctitrigin[n]), generate an event on channel 1.
	CTI_CTIINEN_TRIGINEN_1_Enabled = 0x1
	// Position of TRIGINEN_2 field.
	CTI_CTIINEN_TRIGINEN_2_Pos = 0x2
	// Bit mask of TRIGINEN_2 field.
	CTI_CTIINEN_TRIGINEN_2_Msk = 0x4
	// Bit TRIGINEN_2.
	CTI_CTIINEN_TRIGINEN_2 = 0x4
	// Input trigger n events are ignored by channel 2.
	CTI_CTIINEN_TRIGINEN_2_Disabled = 0x0
	// When an event is received on input trigger n (ctitrigin[n]), generate an event on channel 2.
	CTI_CTIINEN_TRIGINEN_2_Enabled = 0x1
	// Position of TRIGINEN_3 field.
	CTI_CTIINEN_TRIGINEN_3_Pos = 0x3
	// Bit mask of TRIGINEN_3 field.
	CTI_CTIINEN_TRIGINEN_3_Msk = 0x8
	// Bit TRIGINEN_3.
	CTI_CTIINEN_TRIGINEN_3 = 0x8
	// Input trigger n events are ignored by channel 3.
	CTI_CTIINEN_TRIGINEN_3_Disabled = 0x0
	// When an event is received on input trigger n (ctitrigin[n]), generate an event on channel 3.
	CTI_CTIINEN_TRIGINEN_3_Enabled = 0x1

	// CTIOUTEN: Description collection: CTI Trigger output
	// Position of TRIGOUTEN_0 field.
	CTI_CTIOUTEN_TRIGOUTEN_0_Pos = 0x0
	// Bit mask of TRIGOUTEN_0 field.
	CTI_CTIOUTEN_TRIGOUTEN_0_Msk = 0x1
	// Bit TRIGOUTEN_0.
	CTI_CTIOUTEN_TRIGOUTEN_0 = 0x1
	// Channel 0 is ignored by output trigger n.
	CTI_CTIOUTEN_TRIGOUTEN_0_Disabled = 0x0
	// When an event occurs on channel 0, generate an event on output event n (ctitrigout[n]).
	CTI_CTIOUTEN_TRIGOUTEN_0_Enabled = 0x1
	// Position of TRIGOUTEN_1 field.
	CTI_CTIOUTEN_TRIGOUTEN_1_Pos = 0x1
	// Bit mask of TRIGOUTEN_1 field.
	CTI_CTIOUTEN_TRIGOUTEN_1_Msk = 0x2
	// Bit TRIGOUTEN_1.
	CTI_CTIOUTEN_TRIGOUTEN_1 = 0x2
	// Channel 1 is ignored by output trigger n.
	CTI_CTIOUTEN_TRIGOUTEN_1_Disabled = 0x0
	// When an event occurs on channel 1, generate an event on output event n (ctitrigout[n]).
	CTI_CTIOUTEN_TRIGOUTEN_1_Enabled = 0x1
	// Position of TRIGOUTEN_2 field.
	CTI_CTIOUTEN_TRIGOUTEN_2_Pos = 0x2
	// Bit mask of TRIGOUTEN_2 field.
	CTI_CTIOUTEN_TRIGOUTEN_2_Msk = 0x4
	// Bit TRIGOUTEN_2.
	CTI_CTIOUTEN_TRIGOUTEN_2 = 0x4
	// Channel 2 is ignored by output trigger n.
	CTI_CTIOUTEN_TRIGOUTEN_2_Disabled = 0x0
	// When an event occurs on channel 2, generate an event on output event n (ctitrigout[n]).
	CTI_CTIOUTEN_TRIGOUTEN_2_Enabled = 0x1
	// Position of TRIGOUTEN_3 field.
	CTI_CTIOUTEN_TRIGOUTEN_3_Pos = 0x3
	// Bit mask of TRIGOUTEN_3 field.
	CTI_CTIOUTEN_TRIGOUTEN_3_Msk = 0x8
	// Bit TRIGOUTEN_3.
	CTI_CTIOUTEN_TRIGOUTEN_3 = 0x8
	// Channel 3 is ignored by output trigger n.
	CTI_CTIOUTEN_TRIGOUTEN_3_Disabled = 0x0
	// When an event occurs on channel 3, generate an event on output event n (ctitrigout[n]).
	CTI_CTIOUTEN_TRIGOUTEN_3_Enabled = 0x1

	// CTITRIGINSTATUS: CTI Trigger In Status register
	// Position of CPUHALTED field.
	CTI_CTITRIGINSTATUS_CPUHALTED_Pos = 0x0
	// Bit mask of CPUHALTED field.
	CTI_CTITRIGINSTATUS_CPUHALTED_Msk = 0x1
	// Bit CPUHALTED.
	CTI_CTITRIGINSTATUS_CPUHALTED = 0x1
	// Ctitrigin 0 is active.
	CTI_CTITRIGINSTATUS_CPUHALTED_Active = 0x1
	// Ctitrigin 0 is inactive.
	CTI_CTITRIGINSTATUS_CPUHALTED_Inactive = 0x0
	// Position of DWTCOMPOUT0 field.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT0_Pos = 0x1
	// Bit mask of DWTCOMPOUT0 field.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT0_Msk = 0x2
	// Bit DWTCOMPOUT0.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT0 = 0x2
	// Ctitrigin 1 is active.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT0_Active = 0x1
	// Ctitrigin 1 is inactive.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT0_Inactive = 0x0
	// Position of DWTCOMPOUT1 field.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT1_Pos = 0x2
	// Bit mask of DWTCOMPOUT1 field.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT1_Msk = 0x4
	// Bit DWTCOMPOUT1.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT1 = 0x4
	// Ctitrigin 2 is active.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT1_Active = 0x1
	// Ctitrigin 2 is inactive.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT1_Inactive = 0x0
	// Position of DWTCOMPOUT2 field.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT2_Pos = 0x3
	// Bit mask of DWTCOMPOUT2 field.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT2_Msk = 0x8
	// Bit DWTCOMPOUT2.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT2 = 0x8
	// Ctitrigin 3 is active.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT2_Active = 0x1
	// Ctitrigin 3 is inactive.
	CTI_CTITRIGINSTATUS_DWTCOMPOUT2_Inactive = 0x0
	// Position of ETMEVTOUT0 field.
	CTI_CTITRIGINSTATUS_ETMEVTOUT0_Pos = 0x4
	// Bit mask of ETMEVTOUT0 field.
	CTI_CTITRIGINSTATUS_ETMEVTOUT0_Msk = 0x10
	// Bit ETMEVTOUT0.
	CTI_CTITRIGINSTATUS_ETMEVTOUT0 = 0x10
	// Ctitrigin 4 is active.
	CTI_CTITRIGINSTATUS_ETMEVTOUT0_Active = 0x1
	// Ctitrigin 4 is inactive.
	CTI_CTITRIGINSTATUS_ETMEVTOUT0_Inactive = 0x0
	// Position of ETMEVTOUT1 field.
	CTI_CTITRIGINSTATUS_ETMEVTOUT1_Pos = 0x5
	// Bit mask of ETMEVTOUT1 field.
	CTI_CTITRIGINSTATUS_ETMEVTOUT1_Msk = 0x20
	// Bit ETMEVTOUT1.
	CTI_CTITRIGINSTATUS_ETMEVTOUT1 = 0x20
	// Ctitrigin 5 is active.
	CTI_CTITRIGINSTATUS_ETMEVTOUT1_Active = 0x1
	// Ctitrigin 5 is inactive.
	CTI_CTITRIGINSTATUS_ETMEVTOUT1_Inactive = 0x0
	// Position of UNUSED0 field.
	CTI_CTITRIGINSTATUS_UNUSED0_Pos = 0x6
	// Bit mask of UNUSED0 field.
	CTI_CTITRIGINSTATUS_UNUSED0_Msk = 0x40
	// Bit UNUSED0.
	CTI_CTITRIGINSTATUS_UNUSED0 = 0x40
	// Ctitrigin 6 is active.
	CTI_CTITRIGINSTATUS_UNUSED0_Active = 0x1
	// Ctitrigin 6 is inactive.
	CTI_CTITRIGINSTATUS_UNUSED0_Inactive = 0x0
	// Position of UNUSED1 field.
	CTI_CTITRIGINSTATUS_UNUSED1_Pos = 0x7
	// Bit mask of UNUSED1 field.
	CTI_CTITRIGINSTATUS_UNUSED1_Msk = 0x80
	// Bit UNUSED1.
	CTI_CTITRIGINSTATUS_UNUSED1 = 0x80
	// Ctitrigin 7 is active.
	CTI_CTITRIGINSTATUS_UNUSED1_Active = 0x1
	// Ctitrigin 7 is inactive.
	CTI_CTITRIGINSTATUS_UNUSED1_Inactive = 0x0

	// CTITRIGOUTSTATUS: CTI Trigger Out Status register
	// Position of DEBUGREQ field.
	CTI_CTITRIGOUTSTATUS_DEBUGREQ_Pos = 0x0
	// Bit mask of DEBUGREQ field.
	CTI_CTITRIGOUTSTATUS_DEBUGREQ_Msk = 0x1
	// Bit DEBUGREQ.
	CTI_CTITRIGOUTSTATUS_DEBUGREQ = 0x1
	// Ctitrigout 0 is active.
	CTI_CTITRIGOUTSTATUS_DEBUGREQ_Active = 0x1
	// Ctitrigout 0 is inactive.
	CTI_CTITRIGOUTSTATUS_DEBUGREQ_Inactive = 0x0
	// Position of CPURESTART field.
	CTI_CTITRIGOUTSTATUS_CPURESTART_Pos = 0x1
	// Bit mask of CPURESTART field.
	CTI_CTITRIGOUTSTATUS_CPURESTART_Msk = 0x2
	// Bit CPURESTART.
	CTI_CTITRIGOUTSTATUS_CPURESTART = 0x2
	// Ctitrigout 1 is active.
	CTI_CTITRIGOUTSTATUS_CPURESTART_Active = 0x1
	// Ctitrigout 1 is inactive.
	CTI_CTITRIGOUTSTATUS_CPURESTART_Inactive = 0x0
	// Position of UNUSED0 field.
	CTI_CTITRIGOUTSTATUS_UNUSED0_Pos = 0x2
	// Bit mask of UNUSED0 field.
	CTI_CTITRIGOUTSTATUS_UNUSED0_Msk = 0x4
	// Bit UNUSED0.
	CTI_CTITRIGOUTSTATUS_UNUSED0 = 0x4
	// Ctitrigout 2 is active.
	CTI_CTITRIGOUTSTATUS_UNUSED0_Active = 0x1
	// Ctitrigout 2 is inactive.
	CTI_CTITRIGOUTSTATUS_UNUSED0_Inactive = 0x0
	// Position of UNUSED1 field.
	CTI_CTITRIGOUTSTATUS_UNUSED1_Pos = 0x3
	// Bit mask of UNUSED1 field.
	CTI_CTITRIGOUTSTATUS_UNUSED1_Msk = 0x8
	// Bit UNUSED1.
	CTI_CTITRIGOUTSTATUS_UNUSED1 = 0x8
	// Ctitrigout 3 is active.
	CTI_CTITRIGOUTSTATUS_UNUSED1_Active = 0x1
	// Ctitrigout 3 is inactive.
	CTI_CTITRIGOUTSTATUS_UNUSED1_Inactive = 0x0
	// Position of ETMEVTIN0 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN0_Pos = 0x4
	// Bit mask of ETMEVTIN0 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN0_Msk = 0x10
	// Bit ETMEVTIN0.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN0 = 0x10
	// Ctitrigout 4 is active.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN0_Active = 0x1
	// Ctitrigout 4 is inactive.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN0_Inactive = 0x0
	// Position of ETMEVTIN1 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN1_Pos = 0x5
	// Bit mask of ETMEVTIN1 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN1_Msk = 0x20
	// Bit ETMEVTIN1.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN1 = 0x20
	// Ctitrigout 5 is active.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN1_Active = 0x1
	// Ctitrigout 5 is inactive.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN1_Inactive = 0x0
	// Position of ETMEVTIN2 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN2_Pos = 0x6
	// Bit mask of ETMEVTIN2 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN2_Msk = 0x40
	// Bit ETMEVTIN2.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN2 = 0x40
	// Ctitrigout 6 is active.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN2_Active = 0x1
	// Ctitrigout 6 is inactive.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN2_Inactive = 0x0
	// Position of ETMEVTIN3 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN3_Pos = 0x7
	// Bit mask of ETMEVTIN3 field.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN3_Msk = 0x80
	// Bit ETMEVTIN3.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN3 = 0x80
	// Ctitrigout 7 is active.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN3_Active = 0x1
	// Ctitrigout 7 is inactive.
	CTI_CTITRIGOUTSTATUS_ETMEVTIN3_Inactive = 0x0

	// CTICHINSTATUS: CTI Channel In Status register
	// Position of CTICHINSTATUS_0 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_0_Pos = 0x0
	// Bit mask of CTICHINSTATUS_0 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_0_Msk = 0x1
	// Bit CTICHINSTATUS_0.
	CTI_CTICHINSTATUS_CTICHINSTATUS_0 = 0x1
	// Ctichin 0 is active.
	CTI_CTICHINSTATUS_CTICHINSTATUS_0_Active = 0x1
	// Ctichin 0 is inactive.
	CTI_CTICHINSTATUS_CTICHINSTATUS_0_Inactive = 0x0
	// Position of CTICHINSTATUS_1 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_1_Pos = 0x1
	// Bit mask of CTICHINSTATUS_1 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_1_Msk = 0x2
	// Bit CTICHINSTATUS_1.
	CTI_CTICHINSTATUS_CTICHINSTATUS_1 = 0x2
	// Ctichin 1 is active.
	CTI_CTICHINSTATUS_CTICHINSTATUS_1_Active = 0x1
	// Ctichin 1 is inactive.
	CTI_CTICHINSTATUS_CTICHINSTATUS_1_Inactive = 0x0
	// Position of CTICHINSTATUS_2 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_2_Pos = 0x2
	// Bit mask of CTICHINSTATUS_2 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_2_Msk = 0x4
	// Bit CTICHINSTATUS_2.
	CTI_CTICHINSTATUS_CTICHINSTATUS_2 = 0x4
	// Ctichin 2 is active.
	CTI_CTICHINSTATUS_CTICHINSTATUS_2_Active = 0x1
	// Ctichin 2 is inactive.
	CTI_CTICHINSTATUS_CTICHINSTATUS_2_Inactive = 0x0
	// Position of CTICHINSTATUS_3 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_3_Pos = 0x3
	// Bit mask of CTICHINSTATUS_3 field.
	CTI_CTICHINSTATUS_CTICHINSTATUS_3_Msk = 0x8
	// Bit CTICHINSTATUS_3.
	CTI_CTICHINSTATUS_CTICHINSTATUS_3 = 0x8
	// Ctichin 3 is active.
	CTI_CTICHINSTATUS_CTICHINSTATUS_3_Active = 0x1
	// Ctichin 3 is inactive.
	CTI_CTICHINSTATUS_CTICHINSTATUS_3_Inactive = 0x0

	// CTIGATE: Enable CTI Channel Gate register
	// Position of CTIGATEEN_0 field.
	CTI_CTIGATE_CTIGATEEN_0_Pos = 0x0
	// Bit mask of CTIGATEEN_0 field.
	CTI_CTIGATE_CTIGATEEN_0_Msk = 0x1
	// Bit CTIGATEEN_0.
	CTI_CTIGATE_CTIGATEEN_0 = 0x1
	// Enable ctichout channel 0 propagation.
	CTI_CTIGATE_CTIGATEEN_0_Enabled = 0x1
	// Disable ctichout channel 0 propagation.
	CTI_CTIGATE_CTIGATEEN_0_Disabled = 0x0
	// Position of CTIGATEEN_1 field.
	CTI_CTIGATE_CTIGATEEN_1_Pos = 0x1
	// Bit mask of CTIGATEEN_1 field.
	CTI_CTIGATE_CTIGATEEN_1_Msk = 0x2
	// Bit CTIGATEEN_1.
	CTI_CTIGATE_CTIGATEEN_1 = 0x2
	// Enable ctichout channel 1 propagation.
	CTI_CTIGATE_CTIGATEEN_1_Enabled = 0x1
	// Disable ctichout channel 1 propagation.
	CTI_CTIGATE_CTIGATEEN_1_Disabled = 0x0
	// Position of CTIGATEEN_2 field.
	CTI_CTIGATE_CTIGATEEN_2_Pos = 0x2
	// Bit mask of CTIGATEEN_2 field.
	CTI_CTIGATE_CTIGATEEN_2_Msk = 0x4
	// Bit CTIGATEEN_2.
	CTI_CTIGATE_CTIGATEEN_2 = 0x4
	// Enable ctichout channel 2 propagation.
	CTI_CTIGATE_CTIGATEEN_2_Enabled = 0x1
	// Disable ctichout channel 2 propagation.
	CTI_CTIGATE_CTIGATEEN_2_Disabled = 0x0
	// Position of CTIGATEEN_3 field.
	CTI_CTIGATE_CTIGATEEN_3_Pos = 0x3
	// Bit mask of CTIGATEEN_3 field.
	CTI_CTIGATE_CTIGATEEN_3_Msk = 0x8
	// Bit CTIGATEEN_3.
	CTI_CTIGATE_CTIGATEEN_3 = 0x8
	// Enable ctichout channel 3 propagation.
	CTI_CTIGATE_CTIGATEEN_3_Enabled = 0x1
	// Disable ctichout channel 3 propagation.
	CTI_CTIGATE_CTIGATEEN_3_Disabled = 0x0

	// DEVARCH: Device Architecture register
	// Position of Architecture field.
	CTI_DEVARCH_Architecture_Pos = 0x0
	// Bit mask of Architecture field.
	CTI_DEVARCH_Architecture_Msk = 0x1
	// Bit Architecture.
	CTI_DEVARCH_Architecture = 0x1

	// DEVID: Device Configuration register
	// Position of EXTMUXNUM field.
	CTI_DEVID_EXTMUXNUM_Pos = 0x0
	// Bit mask of EXTMUXNUM field.
	CTI_DEVID_EXTMUXNUM_Msk = 0x1f
	// Position of NUMTRIG field.
	CTI_DEVID_NUMTRIG_Pos = 0x8
	// Bit mask of NUMTRIG field.
	CTI_DEVID_NUMTRIG_Msk = 0xff00
	// Position of NUMCH field.
	CTI_DEVID_NUMCH_Pos = 0x10
	// Bit mask of NUMCH field.
	CTI_DEVID_NUMCH_Msk = 0xf0000

	// DEVTYPE: Device Type Identifier register
	// Position of MAJOR field.
	CTI_DEVTYPE_MAJOR_Pos = 0x0
	// Bit mask of MAJOR field.
	CTI_DEVTYPE_MAJOR_Msk = 0xf
	// Indicates that this component allows a debugger to control other components in a CoreSight SoC-400 system.
	CTI_DEVTYPE_MAJOR_Controller = 0x4
	// Position of SUB field.
	CTI_DEVTYPE_SUB_Pos = 0x4
	// Bit mask of SUB field.
	CTI_DEVTYPE_SUB_Msk = 0xf0
	// Indicates that this component is a sub-triggering component.
	CTI_DEVTYPE_SUB_Crosstrigger = 0x1

	// PIDR4: Peripheral ID4 Register
	// Position of DES_2 field.
	CTI_PIDR4_DES_2_Pos = 0x0
	// Bit mask of DES_2 field.
	CTI_PIDR4_DES_2_Msk = 0xf
	// JEDEC continuation code
	CTI_PIDR4_DES_2_Code = 0x4
	// Position of SIZE field.
	CTI_PIDR4_SIZE_Pos = 0x4
	// Bit mask of SIZE field.
	CTI_PIDR4_SIZE_Msk = 0xf0

	// PIDR0: Peripheral ID0 Register
	// Position of PART_0 field.
	CTI_PIDR0_PART_0_Pos = 0x0
	// Bit mask of PART_0 field.
	CTI_PIDR0_PART_0_Msk = 0xff
	// Indicates bits[7:0] of the part number of the component.
	CTI_PIDR0_PART_0_PartnumberL = 0x21

	// PIDR1: Peripheral ID1 Register
	// Position of PART_1 field.
	CTI_PIDR1_PART_1_Pos = 0x0
	// Bit mask of PART_1 field.
	CTI_PIDR1_PART_1_Msk = 0xf
	// Indicates bits[11:8] of the part number of the component.
	CTI_PIDR1_PART_1_PartnumberH = 0xd
	// Position of DES_0 field.
	CTI_PIDR1_DES_0_Pos = 0x4
	// Bit mask of DES_0 field.
	CTI_PIDR1_DES_0_Msk = 0xf0
	// ARM. Bits[3:0] of the JEDEC JEP106 Identity Code
	CTI_PIDR1_DES_0_Arm = 0xb

	// PIDR2: Peripheral ID2 Register
	// Position of DES_1 field.
	CTI_PIDR2_DES_1_Pos = 0x0
	// Bit mask of DES_1 field.
	CTI_PIDR2_DES_1_Msk = 0x7
	// ARM. Bits[6:4] of the JEDEC JEP106 Identity Code
	CTI_PIDR2_DES_1_Arm = 0x3
	// Position of JEDEC field.
	CTI_PIDR2_JEDEC_Pos = 0x3
	// Bit mask of JEDEC field.
	CTI_PIDR2_JEDEC_Msk = 0x8
	// Bit JEDEC.
	CTI_PIDR2_JEDEC = 0x8
	// Position of REVISION field.
	CTI_PIDR2_REVISION_Pos = 0x4
	// Bit mask of REVISION field.
	CTI_PIDR2_REVISION_Msk = 0xf0
	// This device is at r0p0
	CTI_PIDR2_REVISION_Rev0p0 = 0x0

	// PIDR3: Peripheral ID3 Register
	// Position of CMOD field.
	CTI_PIDR3_CMOD_Pos = 0x0
	// Bit mask of CMOD field.
	CTI_PIDR3_CMOD_Msk = 0xf
	// Indicates that the customer has not modified this component.
	CTI_PIDR3_CMOD_Unmodified = 0x0
	// Position of REVAND field.
	CTI_PIDR3_REVAND_Pos = 0x4
	// Bit mask of REVAND field.
	CTI_PIDR3_REVAND_Msk = 0xf0
	// Indicates that there are no errata fixes to this component.
	CTI_PIDR3_REVAND_NoErrata = 0x0

	// CIDR0: Component ID0 Register
	// Position of PRMBL_0 field.
	CTI_CIDR0_PRMBL_0_Pos = 0x0
	// Bit mask of PRMBL_0 field.
	CTI_CIDR0_PRMBL_0_Msk = 0xff
	// Bits[7:0] of the identification code.
	CTI_CIDR0_PRMBL_0_Value = 0xd

	// CIDR1: Component ID1 Register
	// Position of PRMBL_1 field.
	CTI_CIDR1_PRMBL_1_Pos = 0x0
	// Bit mask of PRMBL_1 field.
	CTI_CIDR1_PRMBL_1_Msk = 0xf
	// Bits[11:8] of the identification code.
	CTI_CIDR1_PRMBL_1_Value = 0x0
	// Position of CLASS field.
	CTI_CIDR1_CLASS_Pos = 0x4
	// Bit mask of CLASS field.
	CTI_CIDR1_CLASS_Msk = 0xf0
	// Indicates that the component is a CoreSight component.
	CTI_CIDR1_CLASS_Coresight = 0x9

	// CIDR2: Component ID2 Register
	// Position of PRMBL_2 field.
	CTI_CIDR2_PRMBL_2_Pos = 0x0
	// Bit mask of PRMBL_2 field.
	CTI_CIDR2_PRMBL_2_Msk = 0xff
	// Bits[23:16] of the identification code.
	CTI_CIDR2_PRMBL_2_Value = 0x5

	// CIDR3: Component ID3 Register
	// Position of PRMBL_3 field.
	CTI_CIDR3_PRMBL_3_Pos = 0x0
	// Bit mask of PRMBL_3 field.
	CTI_CIDR3_PRMBL_3_Msk = 0xff
	// Bits[31:24] of the identification code.
	CTI_CIDR3_PRMBL_3_Value = 0xb1
)

// Constants for TAD_S: Trace and debug control
const (
	// CLOCKSTART: Start all trace and debug clocks.
	// Position of START field.
	TAD_CLOCKSTART_START_Pos = 0x0
	// Bit mask of START field.
	TAD_CLOCKSTART_START_Msk = 0x1
	// Bit START.
	TAD_CLOCKSTART_START = 0x1
	// Start all trace and debug clocks.
	TAD_CLOCKSTART_START_Start = 0x1

	// CLOCKSTOP: Stop all trace and debug clocks.
	// Position of STOP field.
	TAD_CLOCKSTOP_STOP_Pos = 0x0
	// Bit mask of STOP field.
	TAD_CLOCKSTOP_STOP_Msk = 0x1
	// Bit STOP.
	TAD_CLOCKSTOP_STOP = 0x1
	// Stop all trace and debug clocks.
	TAD_CLOCKSTOP_STOP_Stop = 0x1

	// ENABLE: Enable debug domain and aquire selected GPIOs
	// Position of ENABLE field.
	TAD_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TAD_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	TAD_ENABLE_ENABLE = 0x1
	// Disable debug domain and release selected GPIOs
	TAD_ENABLE_ENABLE_DISABLED = 0x0
	// Enable debug domain and aquire selected GPIOs
	TAD_ENABLE_ENABLE_ENABLED = 0x1

	// PSEL.TRACECLK: Pin configuration for TRACECLK
	// Position of PIN field.
	TAD_PSEL_TRACECLK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TAD_PSEL_TRACECLK_PIN_Msk = 0x1f
	// TRACECLK pin
	TAD_PSEL_TRACECLK_PIN_Traceclk = 0xc
	// Position of CONNECT field.
	TAD_PSEL_TRACECLK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TAD_PSEL_TRACECLK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TAD_PSEL_TRACECLK_CONNECT = 0x80000000
	// Disconnect
	TAD_PSEL_TRACECLK_CONNECT_Disconnected = 0x1
	// Connect
	TAD_PSEL_TRACECLK_CONNECT_Connected = 0x0

	// PSEL.TRACEDATA0: Pin configuration for TRACEDATA[0] and SWO
	// Position of PIN field.
	TAD_PSEL_TRACEDATA0_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TAD_PSEL_TRACEDATA0_PIN_Msk = 0x1f
	// TRACEDATA0/SWO pin
	TAD_PSEL_TRACEDATA0_PIN_Tracedata0 = 0xb
	// Position of CONNECT field.
	TAD_PSEL_TRACEDATA0_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TAD_PSEL_TRACEDATA0_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TAD_PSEL_TRACEDATA0_CONNECT = 0x80000000
	// Disconnect
	TAD_PSEL_TRACEDATA0_CONNECT_Disconnected = 0x1
	// Connect
	TAD_PSEL_TRACEDATA0_CONNECT_Connected = 0x0

	// PSEL.TRACEDATA1: Pin configuration for TRACEDATA[1]
	// Position of PIN field.
	TAD_PSEL_TRACEDATA1_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TAD_PSEL_TRACEDATA1_PIN_Msk = 0x1f
	// TRACEDATA1 pin
	TAD_PSEL_TRACEDATA1_PIN_Tracedata1 = 0xa
	// Position of CONNECT field.
	TAD_PSEL_TRACEDATA1_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TAD_PSEL_TRACEDATA1_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TAD_PSEL_TRACEDATA1_CONNECT = 0x80000000
	// Disconnect
	TAD_PSEL_TRACEDATA1_CONNECT_Disconnected = 0x1
	// Connect
	TAD_PSEL_TRACEDATA1_CONNECT_Connected = 0x0

	// PSEL.TRACEDATA2: Pin configuration for TRACEDATA[2]
	// Position of PIN field.
	TAD_PSEL_TRACEDATA2_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TAD_PSEL_TRACEDATA2_PIN_Msk = 0x1f
	// TRACEDATA2 pin
	TAD_PSEL_TRACEDATA2_PIN_Tracedata2 = 0x9
	// Position of CONNECT field.
	TAD_PSEL_TRACEDATA2_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TAD_PSEL_TRACEDATA2_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TAD_PSEL_TRACEDATA2_CONNECT = 0x80000000
	// Disconnect
	TAD_PSEL_TRACEDATA2_CONNECT_Disconnected = 0x1
	// Connect
	TAD_PSEL_TRACEDATA2_CONNECT_Connected = 0x0

	// PSEL.TRACEDATA3: Pin configuration for TRACEDATA[3]
	// Position of PIN field.
	TAD_PSEL_TRACEDATA3_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TAD_PSEL_TRACEDATA3_PIN_Msk = 0x1f
	// TRACEDATA3 pin
	TAD_PSEL_TRACEDATA3_PIN_Tracedata3 = 0x8
	// Position of CONNECT field.
	TAD_PSEL_TRACEDATA3_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TAD_PSEL_TRACEDATA3_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TAD_PSEL_TRACEDATA3_CONNECT = 0x80000000
	// Disconnect
	TAD_PSEL_TRACEDATA3_CONNECT_Disconnected = 0x1
	// Connect
	TAD_PSEL_TRACEDATA3_CONNECT_Connected = 0x0

	// TRACEPORTSPEED: Clocking options for the Trace Port debug interface.
	// Position of TRACEPORTSPEED field.
	TAD_TRACEPORTSPEED_TRACEPORTSPEED_Pos = 0x0
	// Bit mask of TRACEPORTSPEED field.
	TAD_TRACEPORTSPEED_TRACEPORTSPEED_Msk = 0x3
	// Trace Port clock is: 64MHz
	TAD_TRACEPORTSPEED_TRACEPORTSPEED_64MHz = 0x0
	// Trace Port clock is: 32MHz
	TAD_TRACEPORTSPEED_TRACEPORTSPEED_32MHz = 0x1
	// Trace Port clock is: 8MHz
	TAD_TRACEPORTSPEED_TRACEPORTSPEED_8MHz = 0x2
	// Trace Port clock is: 4MHz
	TAD_TRACEPORTSPEED_TRACEPORTSPEED_4MHz = 0x3
)

// Constants for DCNF_NS: Domain configuration management 0
const (
	// CPUID: CPU ID of this subsystem
	// Position of CPUID field.
	DCNF_CPUID_CPUID_Pos = 0x0
	// Bit mask of CPUID field.
	DCNF_CPUID_CPUID_Msk = 0xff

	// EXTPERI.PROTECT: Description cluster: Control access for master connected to AMLI master port EXTPERI[n]
	// Position of SLAVE0 field.
	DCNF_EXTPERI_PROTECT_SLAVE0_Pos = 0x0
	// Bit mask of SLAVE0 field.
	DCNF_EXTPERI_PROTECT_SLAVE0_Msk = 0x1
	// Bit SLAVE0.
	DCNF_EXTPERI_PROTECT_SLAVE0 = 0x1
	// Access to slave is allowed
	DCNF_EXTPERI_PROTECT_SLAVE0_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTPERI_PROTECT_SLAVE0_Blocked = 0x1

	// EXTRAM.PROTECT: Description cluster: Control access from master connected to AMLI master port EXTRAM[n]
	// Position of SLAVE0 field.
	DCNF_EXTRAM_PROTECT_SLAVE0_Pos = 0x0
	// Bit mask of SLAVE0 field.
	DCNF_EXTRAM_PROTECT_SLAVE0_Msk = 0x1
	// Bit SLAVE0.
	DCNF_EXTRAM_PROTECT_SLAVE0 = 0x1
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE0_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE0_Blocked = 0x1
	// Position of SLAVE1 field.
	DCNF_EXTRAM_PROTECT_SLAVE1_Pos = 0x1
	// Bit mask of SLAVE1 field.
	DCNF_EXTRAM_PROTECT_SLAVE1_Msk = 0x2
	// Bit SLAVE1.
	DCNF_EXTRAM_PROTECT_SLAVE1 = 0x2
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE1_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE1_Blocked = 0x1
	// Position of SLAVE2 field.
	DCNF_EXTRAM_PROTECT_SLAVE2_Pos = 0x2
	// Bit mask of SLAVE2 field.
	DCNF_EXTRAM_PROTECT_SLAVE2_Msk = 0x4
	// Bit SLAVE2.
	DCNF_EXTRAM_PROTECT_SLAVE2 = 0x4
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE2_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE2_Blocked = 0x1
	// Position of SLAVE3 field.
	DCNF_EXTRAM_PROTECT_SLAVE3_Pos = 0x3
	// Bit mask of SLAVE3 field.
	DCNF_EXTRAM_PROTECT_SLAVE3_Msk = 0x8
	// Bit SLAVE3.
	DCNF_EXTRAM_PROTECT_SLAVE3 = 0x8
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE3_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE3_Blocked = 0x1
	// Position of SLAVE4 field.
	DCNF_EXTRAM_PROTECT_SLAVE4_Pos = 0x4
	// Bit mask of SLAVE4 field.
	DCNF_EXTRAM_PROTECT_SLAVE4_Msk = 0x10
	// Bit SLAVE4.
	DCNF_EXTRAM_PROTECT_SLAVE4 = 0x10
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE4_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE4_Blocked = 0x1
	// Position of SLAVE5 field.
	DCNF_EXTRAM_PROTECT_SLAVE5_Pos = 0x5
	// Bit mask of SLAVE5 field.
	DCNF_EXTRAM_PROTECT_SLAVE5_Msk = 0x20
	// Bit SLAVE5.
	DCNF_EXTRAM_PROTECT_SLAVE5 = 0x20
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE5_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE5_Blocked = 0x1
	// Position of SLAVE6 field.
	DCNF_EXTRAM_PROTECT_SLAVE6_Pos = 0x6
	// Bit mask of SLAVE6 field.
	DCNF_EXTRAM_PROTECT_SLAVE6_Msk = 0x40
	// Bit SLAVE6.
	DCNF_EXTRAM_PROTECT_SLAVE6 = 0x40
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE6_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE6_Blocked = 0x1
	// Position of SLAVE7 field.
	DCNF_EXTRAM_PROTECT_SLAVE7_Pos = 0x7
	// Bit mask of SLAVE7 field.
	DCNF_EXTRAM_PROTECT_SLAVE7_Msk = 0x80
	// Bit SLAVE7.
	DCNF_EXTRAM_PROTECT_SLAVE7 = 0x80
	// Access to slave is allowed
	DCNF_EXTRAM_PROTECT_SLAVE7_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTRAM_PROTECT_SLAVE7_Blocked = 0x1

	// EXTCODE.PROTECT: Description cluster: Control access from master connected to AMLI master port EXTCODE[n]
	// Position of SLAVE0 field.
	DCNF_EXTCODE_PROTECT_SLAVE0_Pos = 0x0
	// Bit mask of SLAVE0 field.
	DCNF_EXTCODE_PROTECT_SLAVE0_Msk = 0x1
	// Bit SLAVE0.
	DCNF_EXTCODE_PROTECT_SLAVE0 = 0x1
	// Access to slave is allowed
	DCNF_EXTCODE_PROTECT_SLAVE0_Allowed = 0x0
	// Access to slave is blocked
	DCNF_EXTCODE_PROTECT_SLAVE0_Blocked = 0x1
)

// Constants for FPU_NS: FPU control peripheral 0
const (
	// EVENTS_INVALIDOPERATION: An FPUIOC exception triggered by an invalid operation has occurred in the FPU
	// Position of EVENTS_INVALIDOPERATION field.
	FPU_EVENTS_INVALIDOPERATION_EVENTS_INVALIDOPERATION_Pos = 0x0
	// Bit mask of EVENTS_INVALIDOPERATION field.
	FPU_EVENTS_INVALIDOPERATION_EVENTS_INVALIDOPERATION_Msk = 0x1
	// Bit EVENTS_INVALIDOPERATION.
	FPU_EVENTS_INVALIDOPERATION_EVENTS_INVALIDOPERATION = 0x1
	// Event not generated
	FPU_EVENTS_INVALIDOPERATION_EVENTS_INVALIDOPERATION_NotGenerated = 0x0
	// Event generated
	FPU_EVENTS_INVALIDOPERATION_EVENTS_INVALIDOPERATION_Generated = 0x1

	// EVENTS_DIVIDEBYZERO: An FPUDZC exception triggered by a floating-point divide-by-zero operation has occurred in the FPU
	// Position of EVENTS_DIVIDEBYZERO field.
	FPU_EVENTS_DIVIDEBYZERO_EVENTS_DIVIDEBYZERO_Pos = 0x0
	// Bit mask of EVENTS_DIVIDEBYZERO field.
	FPU_EVENTS_DIVIDEBYZERO_EVENTS_DIVIDEBYZERO_Msk = 0x1
	// Bit EVENTS_DIVIDEBYZERO.
	FPU_EVENTS_DIVIDEBYZERO_EVENTS_DIVIDEBYZERO = 0x1
	// Event not generated
	FPU_EVENTS_DIVIDEBYZERO_EVENTS_DIVIDEBYZERO_NotGenerated = 0x0
	// Event generated
	FPU_EVENTS_DIVIDEBYZERO_EVENTS_DIVIDEBYZERO_Generated = 0x1

	// EVENTS_OVERFLOW: An FPUOFC exception triggered by a floating-point overflow has occurred in the FPU
	// Position of EVENTS_OVERFLOW field.
	FPU_EVENTS_OVERFLOW_EVENTS_OVERFLOW_Pos = 0x0
	// Bit mask of EVENTS_OVERFLOW field.
	FPU_EVENTS_OVERFLOW_EVENTS_OVERFLOW_Msk = 0x1
	// Bit EVENTS_OVERFLOW.
	FPU_EVENTS_OVERFLOW_EVENTS_OVERFLOW = 0x1
	// Event not generated
	FPU_EVENTS_OVERFLOW_EVENTS_OVERFLOW_NotGenerated = 0x0
	// Event generated
	FPU_EVENTS_OVERFLOW_EVENTS_OVERFLOW_Generated = 0x1

	// EVENTS_UNDERFLOW: An FPUUFC exception triggered by a floating-point underflow has occurred in the FPU
	// Position of EVENTS_UNDERFLOW field.
	FPU_EVENTS_UNDERFLOW_EVENTS_UNDERFLOW_Pos = 0x0
	// Bit mask of EVENTS_UNDERFLOW field.
	FPU_EVENTS_UNDERFLOW_EVENTS_UNDERFLOW_Msk = 0x1
	// Bit EVENTS_UNDERFLOW.
	FPU_EVENTS_UNDERFLOW_EVENTS_UNDERFLOW = 0x1
	// Event not generated
	FPU_EVENTS_UNDERFLOW_EVENTS_UNDERFLOW_NotGenerated = 0x0
	// Event generated
	FPU_EVENTS_UNDERFLOW_EVENTS_UNDERFLOW_Generated = 0x1

	// EVENTS_INEXACT: An FPUIXC exception triggered by an inexact floating-point operation has occurred in the FPU
	// Position of EVENTS_INEXACT field.
	FPU_EVENTS_INEXACT_EVENTS_INEXACT_Pos = 0x0
	// Bit mask of EVENTS_INEXACT field.
	FPU_EVENTS_INEXACT_EVENTS_INEXACT_Msk = 0x1
	// Bit EVENTS_INEXACT.
	FPU_EVENTS_INEXACT_EVENTS_INEXACT = 0x1
	// Event not generated
	FPU_EVENTS_INEXACT_EVENTS_INEXACT_NotGenerated = 0x0
	// Event generated
	FPU_EVENTS_INEXACT_EVENTS_INEXACT_Generated = 0x1

	// EVENTS_DENORMALINPUT: An FPUIDC exception triggered by a denormal floating-point input has occurred in the FPU
	// Position of EVENTS_DENORMALINPUT field.
	FPU_EVENTS_DENORMALINPUT_EVENTS_DENORMALINPUT_Pos = 0x0
	// Bit mask of EVENTS_DENORMALINPUT field.
	FPU_EVENTS_DENORMALINPUT_EVENTS_DENORMALINPUT_Msk = 0x1
	// Bit EVENTS_DENORMALINPUT.
	FPU_EVENTS_DENORMALINPUT_EVENTS_DENORMALINPUT = 0x1
	// Event not generated
	FPU_EVENTS_DENORMALINPUT_EVENTS_DENORMALINPUT_NotGenerated = 0x0
	// Event generated
	FPU_EVENTS_DENORMALINPUT_EVENTS_DENORMALINPUT_Generated = 0x1

	// INTEN: Enable or disable interrupt
	// Position of INVALIDOPERATION field.
	FPU_INTEN_INVALIDOPERATION_Pos = 0x0
	// Bit mask of INVALIDOPERATION field.
	FPU_INTEN_INVALIDOPERATION_Msk = 0x1
	// Bit INVALIDOPERATION.
	FPU_INTEN_INVALIDOPERATION = 0x1
	// Disable
	FPU_INTEN_INVALIDOPERATION_Disabled = 0x0
	// Enable
	FPU_INTEN_INVALIDOPERATION_Enabled = 0x1
	// Position of DIVIDEBYZERO field.
	FPU_INTEN_DIVIDEBYZERO_Pos = 0x1
	// Bit mask of DIVIDEBYZERO field.
	FPU_INTEN_DIVIDEBYZERO_Msk = 0x2
	// Bit DIVIDEBYZERO.
	FPU_INTEN_DIVIDEBYZERO = 0x2
	// Disable
	FPU_INTEN_DIVIDEBYZERO_Disabled = 0x0
	// Enable
	FPU_INTEN_DIVIDEBYZERO_Enabled = 0x1
	// Position of OVERFLOW field.
	FPU_INTEN_OVERFLOW_Pos = 0x2
	// Bit mask of OVERFLOW field.
	FPU_INTEN_OVERFLOW_Msk = 0x4
	// Bit OVERFLOW.
	FPU_INTEN_OVERFLOW = 0x4
	// Disable
	FPU_INTEN_OVERFLOW_Disabled = 0x0
	// Enable
	FPU_INTEN_OVERFLOW_Enabled = 0x1
	// Position of UNDERFLOW field.
	FPU_INTEN_UNDERFLOW_Pos = 0x3
	// Bit mask of UNDERFLOW field.
	FPU_INTEN_UNDERFLOW_Msk = 0x8
	// Bit UNDERFLOW.
	FPU_INTEN_UNDERFLOW = 0x8
	// Disable
	FPU_INTEN_UNDERFLOW_Disabled = 0x0
	// Enable
	FPU_INTEN_UNDERFLOW_Enabled = 0x1
	// Position of INEXACT field.
	FPU_INTEN_INEXACT_Pos = 0x4
	// Bit mask of INEXACT field.
	FPU_INTEN_INEXACT_Msk = 0x10
	// Bit INEXACT.
	FPU_INTEN_INEXACT = 0x10
	// Disable
	FPU_INTEN_INEXACT_Disabled = 0x0
	// Enable
	FPU_INTEN_INEXACT_Enabled = 0x1
	// Position of DENORMALINPUT field.
	FPU_INTEN_DENORMALINPUT_Pos = 0x5
	// Bit mask of DENORMALINPUT field.
	FPU_INTEN_DENORMALINPUT_Msk = 0x20
	// Bit DENORMALINPUT.
	FPU_INTEN_DENORMALINPUT = 0x20
	// Disable
	FPU_INTEN_DENORMALINPUT_Disabled = 0x0
	// Enable
	FPU_INTEN_DENORMALINPUT_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of INVALIDOPERATION field.
	FPU_INTENSET_INVALIDOPERATION_Pos = 0x0
	// Bit mask of INVALIDOPERATION field.
	FPU_INTENSET_INVALIDOPERATION_Msk = 0x1
	// Bit INVALIDOPERATION.
	FPU_INTENSET_INVALIDOPERATION = 0x1
	// Read: Disabled
	FPU_INTENSET_INVALIDOPERATION_Disabled = 0x0
	// Read: Enabled
	FPU_INTENSET_INVALIDOPERATION_Enabled = 0x1
	// Enable
	FPU_INTENSET_INVALIDOPERATION_Set = 0x1
	// Position of DIVIDEBYZERO field.
	FPU_INTENSET_DIVIDEBYZERO_Pos = 0x1
	// Bit mask of DIVIDEBYZERO field.
	FPU_INTENSET_DIVIDEBYZERO_Msk = 0x2
	// Bit DIVIDEBYZERO.
	FPU_INTENSET_DIVIDEBYZERO = 0x2
	// Read: Disabled
	FPU_INTENSET_DIVIDEBYZERO_Disabled = 0x0
	// Read: Enabled
	FPU_INTENSET_DIVIDEBYZERO_Enabled = 0x1
	// Enable
	FPU_INTENSET_DIVIDEBYZERO_Set = 0x1
	// Position of OVERFLOW field.
	FPU_INTENSET_OVERFLOW_Pos = 0x2
	// Bit mask of OVERFLOW field.
	FPU_INTENSET_OVERFLOW_Msk = 0x4
	// Bit OVERFLOW.
	FPU_INTENSET_OVERFLOW = 0x4
	// Read: Disabled
	FPU_INTENSET_OVERFLOW_Disabled = 0x0
	// Read: Enabled
	FPU_INTENSET_OVERFLOW_Enabled = 0x1
	// Enable
	FPU_INTENSET_OVERFLOW_Set = 0x1
	// Position of UNDERFLOW field.
	FPU_INTENSET_UNDERFLOW_Pos = 0x3
	// Bit mask of UNDERFLOW field.
	FPU_INTENSET_UNDERFLOW_Msk = 0x8
	// Bit UNDERFLOW.
	FPU_INTENSET_UNDERFLOW = 0x8
	// Read: Disabled
	FPU_INTENSET_UNDERFLOW_Disabled = 0x0
	// Read: Enabled
	FPU_INTENSET_UNDERFLOW_Enabled = 0x1
	// Enable
	FPU_INTENSET_UNDERFLOW_Set = 0x1
	// Position of INEXACT field.
	FPU_INTENSET_INEXACT_Pos = 0x4
	// Bit mask of INEXACT field.
	FPU_INTENSET_INEXACT_Msk = 0x10
	// Bit INEXACT.
	FPU_INTENSET_INEXACT = 0x10
	// Read: Disabled
	FPU_INTENSET_INEXACT_Disabled = 0x0
	// Read: Enabled
	FPU_INTENSET_INEXACT_Enabled = 0x1
	// Enable
	FPU_INTENSET_INEXACT_Set = 0x1
	// Position of DENORMALINPUT field.
	FPU_INTENSET_DENORMALINPUT_Pos = 0x5
	// Bit mask of DENORMALINPUT field.
	FPU_INTENSET_DENORMALINPUT_Msk = 0x20
	// Bit DENORMALINPUT.
	FPU_INTENSET_DENORMALINPUT = 0x20
	// Read: Disabled
	FPU_INTENSET_DENORMALINPUT_Disabled = 0x0
	// Read: Enabled
	FPU_INTENSET_DENORMALINPUT_Enabled = 0x1
	// Enable
	FPU_INTENSET_DENORMALINPUT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of INVALIDOPERATION field.
	FPU_INTENCLR_INVALIDOPERATION_Pos = 0x0
	// Bit mask of INVALIDOPERATION field.
	FPU_INTENCLR_INVALIDOPERATION_Msk = 0x1
	// Bit INVALIDOPERATION.
	FPU_INTENCLR_INVALIDOPERATION = 0x1
	// Read: Disabled
	FPU_INTENCLR_INVALIDOPERATION_Disabled = 0x0
	// Read: Enabled
	FPU_INTENCLR_INVALIDOPERATION_Enabled = 0x1
	// Disable
	FPU_INTENCLR_INVALIDOPERATION_Clear = 0x1
	// Position of DIVIDEBYZERO field.
	FPU_INTENCLR_DIVIDEBYZERO_Pos = 0x1
	// Bit mask of DIVIDEBYZERO field.
	FPU_INTENCLR_DIVIDEBYZERO_Msk = 0x2
	// Bit DIVIDEBYZERO.
	FPU_INTENCLR_DIVIDEBYZERO = 0x2
	// Read: Disabled
	FPU_INTENCLR_DIVIDEBYZERO_Disabled = 0x0
	// Read: Enabled
	FPU_INTENCLR_DIVIDEBYZERO_Enabled = 0x1
	// Disable
	FPU_INTENCLR_DIVIDEBYZERO_Clear = 0x1
	// Position of OVERFLOW field.
	FPU_INTENCLR_OVERFLOW_Pos = 0x2
	// Bit mask of OVERFLOW field.
	FPU_INTENCLR_OVERFLOW_Msk = 0x4
	// Bit OVERFLOW.
	FPU_INTENCLR_OVERFLOW = 0x4
	// Read: Disabled
	FPU_INTENCLR_OVERFLOW_Disabled = 0x0
	// Read: Enabled
	FPU_INTENCLR_OVERFLOW_Enabled = 0x1
	// Disable
	FPU_INTENCLR_OVERFLOW_Clear = 0x1
	// Position of UNDERFLOW field.
	FPU_INTENCLR_UNDERFLOW_Pos = 0x3
	// Bit mask of UNDERFLOW field.
	FPU_INTENCLR_UNDERFLOW_Msk = 0x8
	// Bit UNDERFLOW.
	FPU_INTENCLR_UNDERFLOW = 0x8
	// Read: Disabled
	FPU_INTENCLR_UNDERFLOW_Disabled = 0x0
	// Read: Enabled
	FPU_INTENCLR_UNDERFLOW_Enabled = 0x1
	// Disable
	FPU_INTENCLR_UNDERFLOW_Clear = 0x1
	// Position of INEXACT field.
	FPU_INTENCLR_INEXACT_Pos = 0x4
	// Bit mask of INEXACT field.
	FPU_INTENCLR_INEXACT_Msk = 0x10
	// Bit INEXACT.
	FPU_INTENCLR_INEXACT = 0x10
	// Read: Disabled
	FPU_INTENCLR_INEXACT_Disabled = 0x0
	// Read: Enabled
	FPU_INTENCLR_INEXACT_Enabled = 0x1
	// Disable
	FPU_INTENCLR_INEXACT_Clear = 0x1
	// Position of DENORMALINPUT field.
	FPU_INTENCLR_DENORMALINPUT_Pos = 0x5
	// Bit mask of DENORMALINPUT field.
	FPU_INTENCLR_DENORMALINPUT_Msk = 0x20
	// Bit DENORMALINPUT.
	FPU_INTENCLR_DENORMALINPUT = 0x20
	// Read: Disabled
	FPU_INTENCLR_DENORMALINPUT_Disabled = 0x0
	// Read: Enabled
	FPU_INTENCLR_DENORMALINPUT_Enabled = 0x1
	// Disable
	FPU_INTENCLR_DENORMALINPUT_Clear = 0x1
)

// Constants for CACHE_S: Cache
const (
	// PROFILING.IHIT: Description cluster: Instruction fetch cache hit counter for cache region n, where n=0 means Flash and n=1 means XIP.
	// Position of HITS field.
	CACHE_PROFILING_IHIT_HITS_Pos = 0x0
	// Bit mask of HITS field.
	CACHE_PROFILING_IHIT_HITS_Msk = 0xffffffff

	// PROFILING.IMISS: Description cluster: Instruction fetch cache miss counter for cache region n, where n=0 means Flash and n=1 means XIP.
	// Position of MISSES field.
	CACHE_PROFILING_IMISS_MISSES_Pos = 0x0
	// Bit mask of MISSES field.
	CACHE_PROFILING_IMISS_MISSES_Msk = 0xffffffff

	// PROFILING.DHIT: Description cluster: Data fetch cache hit counter for cache region n, where n=0 means Flash and n=1 means XIP.
	// Position of HITS field.
	CACHE_PROFILING_DHIT_HITS_Pos = 0x0
	// Bit mask of HITS field.
	CACHE_PROFILING_DHIT_HITS_Msk = 0xffffffff

	// PROFILING.DMISS: Description cluster: Data fetch cache miss counter for cache region n, where n=0 means Flash and n=1 means XIP.
	// Position of MISSES field.
	CACHE_PROFILING_DMISS_MISSES_Pos = 0x0
	// Bit mask of MISSES field.
	CACHE_PROFILING_DMISS_MISSES_Msk = 0xffffffff

	// ENABLE: Enable cache
	// Position of ENABLE field.
	CACHE_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CACHE_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	CACHE_ENABLE_ENABLE = 0x1
	// Disable cache
	CACHE_ENABLE_ENABLE_Disabled = 0x0
	// Enable cache
	CACHE_ENABLE_ENABLE_Enabled = 0x1

	// INVALIDATE: Invalidate the cache
	// Position of INVALIDATE field.
	CACHE_INVALIDATE_INVALIDATE_Pos = 0x0
	// Bit mask of INVALIDATE field.
	CACHE_INVALIDATE_INVALIDATE_Msk = 0x1
	// Bit INVALIDATE.
	CACHE_INVALIDATE_INVALIDATE = 0x1
	// Invalidate the cache
	CACHE_INVALIDATE_INVALIDATE_Invalidate = 0x1

	// ERASE: Erase the cache
	// Position of ERASE field.
	CACHE_ERASE_ERASE_Pos = 0x0
	// Bit mask of ERASE field.
	CACHE_ERASE_ERASE_Msk = 0x1
	// Bit ERASE.
	CACHE_ERASE_ERASE = 0x1
	// Erase cache
	CACHE_ERASE_ERASE_Erase = 0x1

	// PROFILINGENABLE: Enable the profiling counters
	// Position of ENABLE field.
	CACHE_PROFILINGENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CACHE_PROFILINGENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	CACHE_PROFILINGENABLE_ENABLE = 0x1
	// Disable profiling
	CACHE_PROFILINGENABLE_ENABLE_Disable = 0x0
	// Enable profiling
	CACHE_PROFILINGENABLE_ENABLE_Enable = 0x1

	// PROFILINGCLEAR: Clear the profiling counters
	// Position of CLEAR field.
	CACHE_PROFILINGCLEAR_CLEAR_Pos = 0x0
	// Bit mask of CLEAR field.
	CACHE_PROFILINGCLEAR_CLEAR_Msk = 0x1
	// Bit CLEAR.
	CACHE_PROFILINGCLEAR_CLEAR = 0x1
	// Clear the profiling counters
	CACHE_PROFILINGCLEAR_CLEAR_Clear = 0x1

	// MODE: Cache mode. Switching from Cache to RAM mode causes the RAM to be cleared. Switching from RAM to Cache mode causes the cache to be invalidated.
	// Position of MODE field.
	CACHE_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	CACHE_MODE_MODE_Msk = 0x1
	// Bit MODE.
	CACHE_MODE_MODE = 0x1
	// Cache mode
	CACHE_MODE_MODE_Cache = 0x0
	// RAM mode
	CACHE_MODE_MODE_Ram = 0x1

	// DEBUGLOCK: Lock debug mode Ignored in RAM mode.
	// Position of DEBUGLOCK field.
	CACHE_DEBUGLOCK_DEBUGLOCK_Pos = 0x0
	// Bit mask of DEBUGLOCK field.
	CACHE_DEBUGLOCK_DEBUGLOCK_Msk = 0x1
	// Bit DEBUGLOCK.
	CACHE_DEBUGLOCK_DEBUGLOCK = 0x1
	// Debug mode unlocked
	CACHE_DEBUGLOCK_DEBUGLOCK_Unlocked = 0x0
	// Debug mode locked
	CACHE_DEBUGLOCK_DEBUGLOCK_Locked = 0x1

	// ERASESTATUS: Cache erase status
	// Position of ERASESTATUS field.
	CACHE_ERASESTATUS_ERASESTATUS_Pos = 0x0
	// Bit mask of ERASESTATUS field.
	CACHE_ERASESTATUS_ERASESTATUS_Msk = 0x1
	// Bit ERASESTATUS.
	CACHE_ERASESTATUS_ERASESTATUS = 0x1
	// Erase is not complete or hasn't started
	CACHE_ERASESTATUS_ERASESTATUS_Idle = 0x0
	// Cache erase is finished
	CACHE_ERASESTATUS_ERASESTATUS_Finished = 0x1

	// WRITELOCK: Lock cache updates. Prevents updating of cache content on cache misses, but will continue to lookup instruction/data fetches in content already present in the cache. Ignored in RAM mode.
	// Position of WRITELOCK field.
	CACHE_WRITELOCK_WRITELOCK_Pos = 0x0
	// Bit mask of WRITELOCK field.
	CACHE_WRITELOCK_WRITELOCK_Msk = 0x1
	// Bit WRITELOCK.
	CACHE_WRITELOCK_WRITELOCK = 0x1
	// Cache updates unlocked
	CACHE_WRITELOCK_WRITELOCK_Unlocked = 0x0
	// Cache updates locked
	CACHE_WRITELOCK_WRITELOCK_Locked = 0x1
)

// Constants for SPU_S: System protection unit
const (
	// EVENTS_RAMACCERR: A security violation has been detected for the RAM memory space
	// Position of EVENTS_RAMACCERR field.
	SPU_EVENTS_RAMACCERR_EVENTS_RAMACCERR_Pos = 0x0
	// Bit mask of EVENTS_RAMACCERR field.
	SPU_EVENTS_RAMACCERR_EVENTS_RAMACCERR_Msk = 0x1
	// Bit EVENTS_RAMACCERR.
	SPU_EVENTS_RAMACCERR_EVENTS_RAMACCERR = 0x1
	// Event not generated
	SPU_EVENTS_RAMACCERR_EVENTS_RAMACCERR_NotGenerated = 0x0
	// Event generated
	SPU_EVENTS_RAMACCERR_EVENTS_RAMACCERR_Generated = 0x1

	// EVENTS_FLASHACCERR: A security violation has been detected for the flash memory space
	// Position of EVENTS_FLASHACCERR field.
	SPU_EVENTS_FLASHACCERR_EVENTS_FLASHACCERR_Pos = 0x0
	// Bit mask of EVENTS_FLASHACCERR field.
	SPU_EVENTS_FLASHACCERR_EVENTS_FLASHACCERR_Msk = 0x1
	// Bit EVENTS_FLASHACCERR.
	SPU_EVENTS_FLASHACCERR_EVENTS_FLASHACCERR = 0x1
	// Event not generated
	SPU_EVENTS_FLASHACCERR_EVENTS_FLASHACCERR_NotGenerated = 0x0
	// Event generated
	SPU_EVENTS_FLASHACCERR_EVENTS_FLASHACCERR_Generated = 0x1

	// EVENTS_PERIPHACCERR: A security violation has been detected on one or several peripherals
	// Position of EVENTS_PERIPHACCERR field.
	SPU_EVENTS_PERIPHACCERR_EVENTS_PERIPHACCERR_Pos = 0x0
	// Bit mask of EVENTS_PERIPHACCERR field.
	SPU_EVENTS_PERIPHACCERR_EVENTS_PERIPHACCERR_Msk = 0x1
	// Bit EVENTS_PERIPHACCERR.
	SPU_EVENTS_PERIPHACCERR_EVENTS_PERIPHACCERR = 0x1
	// Event not generated
	SPU_EVENTS_PERIPHACCERR_EVENTS_PERIPHACCERR_NotGenerated = 0x0
	// Event generated
	SPU_EVENTS_PERIPHACCERR_EVENTS_PERIPHACCERR_Generated = 0x1

	// PUBLISH_RAMACCERR: Publish configuration for event RAMACCERR
	// Position of CHIDX field.
	SPU_PUBLISH_RAMACCERR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPU_PUBLISH_RAMACCERR_CHIDX_Msk = 0xff
	// Position of EN field.
	SPU_PUBLISH_RAMACCERR_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPU_PUBLISH_RAMACCERR_EN_Msk = 0x80000000
	// Bit EN.
	SPU_PUBLISH_RAMACCERR_EN = 0x80000000
	// Disable publishing
	SPU_PUBLISH_RAMACCERR_EN_Disabled = 0x0
	// Enable publishing
	SPU_PUBLISH_RAMACCERR_EN_Enabled = 0x1

	// PUBLISH_FLASHACCERR: Publish configuration for event FLASHACCERR
	// Position of CHIDX field.
	SPU_PUBLISH_FLASHACCERR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPU_PUBLISH_FLASHACCERR_CHIDX_Msk = 0xff
	// Position of EN field.
	SPU_PUBLISH_FLASHACCERR_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPU_PUBLISH_FLASHACCERR_EN_Msk = 0x80000000
	// Bit EN.
	SPU_PUBLISH_FLASHACCERR_EN = 0x80000000
	// Disable publishing
	SPU_PUBLISH_FLASHACCERR_EN_Disabled = 0x0
	// Enable publishing
	SPU_PUBLISH_FLASHACCERR_EN_Enabled = 0x1

	// PUBLISH_PERIPHACCERR: Publish configuration for event PERIPHACCERR
	// Position of CHIDX field.
	SPU_PUBLISH_PERIPHACCERR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPU_PUBLISH_PERIPHACCERR_CHIDX_Msk = 0xff
	// Position of EN field.
	SPU_PUBLISH_PERIPHACCERR_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPU_PUBLISH_PERIPHACCERR_EN_Msk = 0x80000000
	// Bit EN.
	SPU_PUBLISH_PERIPHACCERR_EN = 0x80000000
	// Disable publishing
	SPU_PUBLISH_PERIPHACCERR_EN_Disabled = 0x0
	// Enable publishing
	SPU_PUBLISH_PERIPHACCERR_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of RAMACCERR field.
	SPU_INTEN_RAMACCERR_Pos = 0x0
	// Bit mask of RAMACCERR field.
	SPU_INTEN_RAMACCERR_Msk = 0x1
	// Bit RAMACCERR.
	SPU_INTEN_RAMACCERR = 0x1
	// Disable
	SPU_INTEN_RAMACCERR_Disabled = 0x0
	// Enable
	SPU_INTEN_RAMACCERR_Enabled = 0x1
	// Position of FLASHACCERR field.
	SPU_INTEN_FLASHACCERR_Pos = 0x1
	// Bit mask of FLASHACCERR field.
	SPU_INTEN_FLASHACCERR_Msk = 0x2
	// Bit FLASHACCERR.
	SPU_INTEN_FLASHACCERR = 0x2
	// Disable
	SPU_INTEN_FLASHACCERR_Disabled = 0x0
	// Enable
	SPU_INTEN_FLASHACCERR_Enabled = 0x1
	// Position of PERIPHACCERR field.
	SPU_INTEN_PERIPHACCERR_Pos = 0x2
	// Bit mask of PERIPHACCERR field.
	SPU_INTEN_PERIPHACCERR_Msk = 0x4
	// Bit PERIPHACCERR.
	SPU_INTEN_PERIPHACCERR = 0x4
	// Disable
	SPU_INTEN_PERIPHACCERR_Disabled = 0x0
	// Enable
	SPU_INTEN_PERIPHACCERR_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of RAMACCERR field.
	SPU_INTENSET_RAMACCERR_Pos = 0x0
	// Bit mask of RAMACCERR field.
	SPU_INTENSET_RAMACCERR_Msk = 0x1
	// Bit RAMACCERR.
	SPU_INTENSET_RAMACCERR = 0x1
	// Read: Disabled
	SPU_INTENSET_RAMACCERR_Disabled = 0x0
	// Read: Enabled
	SPU_INTENSET_RAMACCERR_Enabled = 0x1
	// Enable
	SPU_INTENSET_RAMACCERR_Set = 0x1
	// Position of FLASHACCERR field.
	SPU_INTENSET_FLASHACCERR_Pos = 0x1
	// Bit mask of FLASHACCERR field.
	SPU_INTENSET_FLASHACCERR_Msk = 0x2
	// Bit FLASHACCERR.
	SPU_INTENSET_FLASHACCERR = 0x2
	// Read: Disabled
	SPU_INTENSET_FLASHACCERR_Disabled = 0x0
	// Read: Enabled
	SPU_INTENSET_FLASHACCERR_Enabled = 0x1
	// Enable
	SPU_INTENSET_FLASHACCERR_Set = 0x1
	// Position of PERIPHACCERR field.
	SPU_INTENSET_PERIPHACCERR_Pos = 0x2
	// Bit mask of PERIPHACCERR field.
	SPU_INTENSET_PERIPHACCERR_Msk = 0x4
	// Bit PERIPHACCERR.
	SPU_INTENSET_PERIPHACCERR = 0x4
	// Read: Disabled
	SPU_INTENSET_PERIPHACCERR_Disabled = 0x0
	// Read: Enabled
	SPU_INTENSET_PERIPHACCERR_Enabled = 0x1
	// Enable
	SPU_INTENSET_PERIPHACCERR_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of RAMACCERR field.
	SPU_INTENCLR_RAMACCERR_Pos = 0x0
	// Bit mask of RAMACCERR field.
	SPU_INTENCLR_RAMACCERR_Msk = 0x1
	// Bit RAMACCERR.
	SPU_INTENCLR_RAMACCERR = 0x1
	// Read: Disabled
	SPU_INTENCLR_RAMACCERR_Disabled = 0x0
	// Read: Enabled
	SPU_INTENCLR_RAMACCERR_Enabled = 0x1
	// Disable
	SPU_INTENCLR_RAMACCERR_Clear = 0x1
	// Position of FLASHACCERR field.
	SPU_INTENCLR_FLASHACCERR_Pos = 0x1
	// Bit mask of FLASHACCERR field.
	SPU_INTENCLR_FLASHACCERR_Msk = 0x2
	// Bit FLASHACCERR.
	SPU_INTENCLR_FLASHACCERR = 0x2
	// Read: Disabled
	SPU_INTENCLR_FLASHACCERR_Disabled = 0x0
	// Read: Enabled
	SPU_INTENCLR_FLASHACCERR_Enabled = 0x1
	// Disable
	SPU_INTENCLR_FLASHACCERR_Clear = 0x1
	// Position of PERIPHACCERR field.
	SPU_INTENCLR_PERIPHACCERR_Pos = 0x2
	// Bit mask of PERIPHACCERR field.
	SPU_INTENCLR_PERIPHACCERR_Msk = 0x4
	// Bit PERIPHACCERR.
	SPU_INTENCLR_PERIPHACCERR = 0x4
	// Read: Disabled
	SPU_INTENCLR_PERIPHACCERR_Disabled = 0x0
	// Read: Enabled
	SPU_INTENCLR_PERIPHACCERR_Enabled = 0x1
	// Disable
	SPU_INTENCLR_PERIPHACCERR_Clear = 0x1

	// CAP: Show implemented features for the current device
	// Position of TZM field.
	SPU_CAP_TZM_Pos = 0x0
	// Bit mask of TZM field.
	SPU_CAP_TZM_Msk = 0x1
	// Bit TZM.
	SPU_CAP_TZM = 0x1
	// ARM TrustZone support not available
	SPU_CAP_TZM_NotAvailable = 0x0
	// ARM TrustZone support is available
	SPU_CAP_TZM_Enabled = 0x1

	// CPULOCK: Configure bits to lock down CPU features at runtime
	// Position of LOCKSVTAIRCR field.
	SPU_CPULOCK_LOCKSVTAIRCR_Pos = 0x0
	// Bit mask of LOCKSVTAIRCR field.
	SPU_CPULOCK_LOCKSVTAIRCR_Msk = 0x1
	// Bit LOCKSVTAIRCR.
	SPU_CPULOCK_LOCKSVTAIRCR = 0x1
	// Disables writes to the VTOR_S, AIRCR.PRIS, and AIRCR.BFHFNMINS registers
	SPU_CPULOCK_LOCKSVTAIRCR_Locked = 0x1
	// These registers can be updated
	SPU_CPULOCK_LOCKSVTAIRCR_Unlocked = 0x0
	// Position of LOCKNSVTOR field.
	SPU_CPULOCK_LOCKNSVTOR_Pos = 0x1
	// Bit mask of LOCKNSVTOR field.
	SPU_CPULOCK_LOCKNSVTOR_Msk = 0x2
	// Bit LOCKNSVTOR.
	SPU_CPULOCK_LOCKNSVTOR = 0x2
	// The address of the non-secure vector table is locked
	SPU_CPULOCK_LOCKNSVTOR_Locked = 0x1
	// The address of the non-secure vector table can be updated
	SPU_CPULOCK_LOCKNSVTOR_Unlocked = 0x0
	// Position of LOCKSMPU field.
	SPU_CPULOCK_LOCKSMPU_Pos = 0x2
	// Bit mask of LOCKSMPU field.
	SPU_CPULOCK_LOCKSMPU_Msk = 0x4
	// Bit LOCKSMPU.
	SPU_CPULOCK_LOCKSMPU = 0x4
	// Disables writes to the MPU_CTRL, MPU_RNR, MPU_RBAR, MPU_RLAR, MPU_RBAR_An and MPU_RLAR_An from software or from a debug agent connected to the processor in Secure state
	SPU_CPULOCK_LOCKSMPU_Locked = 0x1
	// These registers can be updated
	SPU_CPULOCK_LOCKSMPU_Unlocked = 0x0
	// Position of LOCKNSMPU field.
	SPU_CPULOCK_LOCKNSMPU_Pos = 0x3
	// Bit mask of LOCKNSMPU field.
	SPU_CPULOCK_LOCKNSMPU_Msk = 0x8
	// Bit LOCKNSMPU.
	SPU_CPULOCK_LOCKNSMPU = 0x8
	// Disables writes to the MPU_CTRL_NS, MPU_RNR_NS, MPU_RBAR_NS, MPU_RLAR_NS, MPU_RBAR_A_NSn and MPU_RLAR_A_NSn from software or from a debug agent connected to the processor
	SPU_CPULOCK_LOCKNSMPU_Locked = 0x1
	// These registers can be updated
	SPU_CPULOCK_LOCKNSMPU_Unlocked = 0x0
	// Position of LOCKSAU field.
	SPU_CPULOCK_LOCKSAU_Pos = 0x4
	// Bit mask of LOCKSAU field.
	SPU_CPULOCK_LOCKSAU_Msk = 0x10
	// Bit LOCKSAU.
	SPU_CPULOCK_LOCKSAU = 0x10
	// Disables writes to the SAU_CTRL, SAU_RNR, SAU_RBAR and SAU_RLAR registers from software or from a debug agent connected to the processor
	SPU_CPULOCK_LOCKSAU_Locked = 0x1
	// These registers can be updated
	SPU_CPULOCK_LOCKSAU_Unlocked = 0x0

	// EXTDOMAIN.PERM: Description cluster: Access for bus access generated from the external domain n List capabilities of the external domain n
	// Position of SECUREMAPPING field.
	SPU_EXTDOMAIN_PERM_SECUREMAPPING_Pos = 0x0
	// Bit mask of SECUREMAPPING field.
	SPU_EXTDOMAIN_PERM_SECUREMAPPING_Msk = 0x3
	// The bus access from this external domain always have the non-secure attribute set
	SPU_EXTDOMAIN_PERM_SECUREMAPPING_NonSecure = 0x0
	// The bus access from this external domain always have the secure attribute set
	SPU_EXTDOMAIN_PERM_SECUREMAPPING_Secure = 0x1
	// Non-secure or secure attribute for bus access from this domain is defined by the EXTDOMAIN[n].PERM register
	SPU_EXTDOMAIN_PERM_SECUREMAPPING_UserSelectable = 0x2
	// Position of SECATTR field.
	SPU_EXTDOMAIN_PERM_SECATTR_Pos = 0x4
	// Bit mask of SECATTR field.
	SPU_EXTDOMAIN_PERM_SECATTR_Msk = 0x10
	// Bit SECATTR.
	SPU_EXTDOMAIN_PERM_SECATTR = 0x10
	// Bus accesses from this domain have the non-secure attribute set
	SPU_EXTDOMAIN_PERM_SECATTR_NonSecure = 0x0
	// Bus accesses from this domain have secure attribute set
	SPU_EXTDOMAIN_PERM_SECATTR_Secure = 0x1
	// Position of LOCK field.
	SPU_EXTDOMAIN_PERM_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_EXTDOMAIN_PERM_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_EXTDOMAIN_PERM_LOCK = 0x100
	// This register can be updated
	SPU_EXTDOMAIN_PERM_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_EXTDOMAIN_PERM_LOCK_Locked = 0x1

	// DPPI.PERM: Description cluster: Select between secure and non-secure attribute for the DPPI channels.
	// Position of CHANNEL0 field.
	SPU_DPPI_PERM_CHANNEL0_Pos = 0x0
	// Bit mask of CHANNEL0 field.
	SPU_DPPI_PERM_CHANNEL0_Msk = 0x1
	// Bit CHANNEL0.
	SPU_DPPI_PERM_CHANNEL0 = 0x1
	// Channel0 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL0_Secure = 0x1
	// Channel0 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL0_NonSecure = 0x0
	// Position of CHANNEL1 field.
	SPU_DPPI_PERM_CHANNEL1_Pos = 0x1
	// Bit mask of CHANNEL1 field.
	SPU_DPPI_PERM_CHANNEL1_Msk = 0x2
	// Bit CHANNEL1.
	SPU_DPPI_PERM_CHANNEL1 = 0x2
	// Channel1 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL1_Secure = 0x1
	// Channel1 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL1_NonSecure = 0x0
	// Position of CHANNEL2 field.
	SPU_DPPI_PERM_CHANNEL2_Pos = 0x2
	// Bit mask of CHANNEL2 field.
	SPU_DPPI_PERM_CHANNEL2_Msk = 0x4
	// Bit CHANNEL2.
	SPU_DPPI_PERM_CHANNEL2 = 0x4
	// Channel2 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL2_Secure = 0x1
	// Channel2 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL2_NonSecure = 0x0
	// Position of CHANNEL3 field.
	SPU_DPPI_PERM_CHANNEL3_Pos = 0x3
	// Bit mask of CHANNEL3 field.
	SPU_DPPI_PERM_CHANNEL3_Msk = 0x8
	// Bit CHANNEL3.
	SPU_DPPI_PERM_CHANNEL3 = 0x8
	// Channel3 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL3_Secure = 0x1
	// Channel3 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL3_NonSecure = 0x0
	// Position of CHANNEL4 field.
	SPU_DPPI_PERM_CHANNEL4_Pos = 0x4
	// Bit mask of CHANNEL4 field.
	SPU_DPPI_PERM_CHANNEL4_Msk = 0x10
	// Bit CHANNEL4.
	SPU_DPPI_PERM_CHANNEL4 = 0x10
	// Channel4 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL4_Secure = 0x1
	// Channel4 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL4_NonSecure = 0x0
	// Position of CHANNEL5 field.
	SPU_DPPI_PERM_CHANNEL5_Pos = 0x5
	// Bit mask of CHANNEL5 field.
	SPU_DPPI_PERM_CHANNEL5_Msk = 0x20
	// Bit CHANNEL5.
	SPU_DPPI_PERM_CHANNEL5 = 0x20
	// Channel5 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL5_Secure = 0x1
	// Channel5 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL5_NonSecure = 0x0
	// Position of CHANNEL6 field.
	SPU_DPPI_PERM_CHANNEL6_Pos = 0x6
	// Bit mask of CHANNEL6 field.
	SPU_DPPI_PERM_CHANNEL6_Msk = 0x40
	// Bit CHANNEL6.
	SPU_DPPI_PERM_CHANNEL6 = 0x40
	// Channel6 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL6_Secure = 0x1
	// Channel6 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL6_NonSecure = 0x0
	// Position of CHANNEL7 field.
	SPU_DPPI_PERM_CHANNEL7_Pos = 0x7
	// Bit mask of CHANNEL7 field.
	SPU_DPPI_PERM_CHANNEL7_Msk = 0x80
	// Bit CHANNEL7.
	SPU_DPPI_PERM_CHANNEL7 = 0x80
	// Channel7 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL7_Secure = 0x1
	// Channel7 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL7_NonSecure = 0x0
	// Position of CHANNEL8 field.
	SPU_DPPI_PERM_CHANNEL8_Pos = 0x8
	// Bit mask of CHANNEL8 field.
	SPU_DPPI_PERM_CHANNEL8_Msk = 0x100
	// Bit CHANNEL8.
	SPU_DPPI_PERM_CHANNEL8 = 0x100
	// Channel8 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL8_Secure = 0x1
	// Channel8 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL8_NonSecure = 0x0
	// Position of CHANNEL9 field.
	SPU_DPPI_PERM_CHANNEL9_Pos = 0x9
	// Bit mask of CHANNEL9 field.
	SPU_DPPI_PERM_CHANNEL9_Msk = 0x200
	// Bit CHANNEL9.
	SPU_DPPI_PERM_CHANNEL9 = 0x200
	// Channel9 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL9_Secure = 0x1
	// Channel9 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL9_NonSecure = 0x0
	// Position of CHANNEL10 field.
	SPU_DPPI_PERM_CHANNEL10_Pos = 0xa
	// Bit mask of CHANNEL10 field.
	SPU_DPPI_PERM_CHANNEL10_Msk = 0x400
	// Bit CHANNEL10.
	SPU_DPPI_PERM_CHANNEL10 = 0x400
	// Channel10 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL10_Secure = 0x1
	// Channel10 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL10_NonSecure = 0x0
	// Position of CHANNEL11 field.
	SPU_DPPI_PERM_CHANNEL11_Pos = 0xb
	// Bit mask of CHANNEL11 field.
	SPU_DPPI_PERM_CHANNEL11_Msk = 0x800
	// Bit CHANNEL11.
	SPU_DPPI_PERM_CHANNEL11 = 0x800
	// Channel11 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL11_Secure = 0x1
	// Channel11 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL11_NonSecure = 0x0
	// Position of CHANNEL12 field.
	SPU_DPPI_PERM_CHANNEL12_Pos = 0xc
	// Bit mask of CHANNEL12 field.
	SPU_DPPI_PERM_CHANNEL12_Msk = 0x1000
	// Bit CHANNEL12.
	SPU_DPPI_PERM_CHANNEL12 = 0x1000
	// Channel12 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL12_Secure = 0x1
	// Channel12 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL12_NonSecure = 0x0
	// Position of CHANNEL13 field.
	SPU_DPPI_PERM_CHANNEL13_Pos = 0xd
	// Bit mask of CHANNEL13 field.
	SPU_DPPI_PERM_CHANNEL13_Msk = 0x2000
	// Bit CHANNEL13.
	SPU_DPPI_PERM_CHANNEL13 = 0x2000
	// Channel13 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL13_Secure = 0x1
	// Channel13 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL13_NonSecure = 0x0
	// Position of CHANNEL14 field.
	SPU_DPPI_PERM_CHANNEL14_Pos = 0xe
	// Bit mask of CHANNEL14 field.
	SPU_DPPI_PERM_CHANNEL14_Msk = 0x4000
	// Bit CHANNEL14.
	SPU_DPPI_PERM_CHANNEL14 = 0x4000
	// Channel14 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL14_Secure = 0x1
	// Channel14 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL14_NonSecure = 0x0
	// Position of CHANNEL15 field.
	SPU_DPPI_PERM_CHANNEL15_Pos = 0xf
	// Bit mask of CHANNEL15 field.
	SPU_DPPI_PERM_CHANNEL15_Msk = 0x8000
	// Bit CHANNEL15.
	SPU_DPPI_PERM_CHANNEL15 = 0x8000
	// Channel15 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL15_Secure = 0x1
	// Channel15 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL15_NonSecure = 0x0
	// Position of CHANNEL16 field.
	SPU_DPPI_PERM_CHANNEL16_Pos = 0x10
	// Bit mask of CHANNEL16 field.
	SPU_DPPI_PERM_CHANNEL16_Msk = 0x10000
	// Bit CHANNEL16.
	SPU_DPPI_PERM_CHANNEL16 = 0x10000
	// Channel16 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL16_Secure = 0x1
	// Channel16 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL16_NonSecure = 0x0
	// Position of CHANNEL17 field.
	SPU_DPPI_PERM_CHANNEL17_Pos = 0x11
	// Bit mask of CHANNEL17 field.
	SPU_DPPI_PERM_CHANNEL17_Msk = 0x20000
	// Bit CHANNEL17.
	SPU_DPPI_PERM_CHANNEL17 = 0x20000
	// Channel17 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL17_Secure = 0x1
	// Channel17 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL17_NonSecure = 0x0
	// Position of CHANNEL18 field.
	SPU_DPPI_PERM_CHANNEL18_Pos = 0x12
	// Bit mask of CHANNEL18 field.
	SPU_DPPI_PERM_CHANNEL18_Msk = 0x40000
	// Bit CHANNEL18.
	SPU_DPPI_PERM_CHANNEL18 = 0x40000
	// Channel18 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL18_Secure = 0x1
	// Channel18 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL18_NonSecure = 0x0
	// Position of CHANNEL19 field.
	SPU_DPPI_PERM_CHANNEL19_Pos = 0x13
	// Bit mask of CHANNEL19 field.
	SPU_DPPI_PERM_CHANNEL19_Msk = 0x80000
	// Bit CHANNEL19.
	SPU_DPPI_PERM_CHANNEL19 = 0x80000
	// Channel19 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL19_Secure = 0x1
	// Channel19 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL19_NonSecure = 0x0
	// Position of CHANNEL20 field.
	SPU_DPPI_PERM_CHANNEL20_Pos = 0x14
	// Bit mask of CHANNEL20 field.
	SPU_DPPI_PERM_CHANNEL20_Msk = 0x100000
	// Bit CHANNEL20.
	SPU_DPPI_PERM_CHANNEL20 = 0x100000
	// Channel20 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL20_Secure = 0x1
	// Channel20 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL20_NonSecure = 0x0
	// Position of CHANNEL21 field.
	SPU_DPPI_PERM_CHANNEL21_Pos = 0x15
	// Bit mask of CHANNEL21 field.
	SPU_DPPI_PERM_CHANNEL21_Msk = 0x200000
	// Bit CHANNEL21.
	SPU_DPPI_PERM_CHANNEL21 = 0x200000
	// Channel21 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL21_Secure = 0x1
	// Channel21 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL21_NonSecure = 0x0
	// Position of CHANNEL22 field.
	SPU_DPPI_PERM_CHANNEL22_Pos = 0x16
	// Bit mask of CHANNEL22 field.
	SPU_DPPI_PERM_CHANNEL22_Msk = 0x400000
	// Bit CHANNEL22.
	SPU_DPPI_PERM_CHANNEL22 = 0x400000
	// Channel22 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL22_Secure = 0x1
	// Channel22 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL22_NonSecure = 0x0
	// Position of CHANNEL23 field.
	SPU_DPPI_PERM_CHANNEL23_Pos = 0x17
	// Bit mask of CHANNEL23 field.
	SPU_DPPI_PERM_CHANNEL23_Msk = 0x800000
	// Bit CHANNEL23.
	SPU_DPPI_PERM_CHANNEL23 = 0x800000
	// Channel23 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL23_Secure = 0x1
	// Channel23 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL23_NonSecure = 0x0
	// Position of CHANNEL24 field.
	SPU_DPPI_PERM_CHANNEL24_Pos = 0x18
	// Bit mask of CHANNEL24 field.
	SPU_DPPI_PERM_CHANNEL24_Msk = 0x1000000
	// Bit CHANNEL24.
	SPU_DPPI_PERM_CHANNEL24 = 0x1000000
	// Channel24 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL24_Secure = 0x1
	// Channel24 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL24_NonSecure = 0x0
	// Position of CHANNEL25 field.
	SPU_DPPI_PERM_CHANNEL25_Pos = 0x19
	// Bit mask of CHANNEL25 field.
	SPU_DPPI_PERM_CHANNEL25_Msk = 0x2000000
	// Bit CHANNEL25.
	SPU_DPPI_PERM_CHANNEL25 = 0x2000000
	// Channel25 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL25_Secure = 0x1
	// Channel25 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL25_NonSecure = 0x0
	// Position of CHANNEL26 field.
	SPU_DPPI_PERM_CHANNEL26_Pos = 0x1a
	// Bit mask of CHANNEL26 field.
	SPU_DPPI_PERM_CHANNEL26_Msk = 0x4000000
	// Bit CHANNEL26.
	SPU_DPPI_PERM_CHANNEL26 = 0x4000000
	// Channel26 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL26_Secure = 0x1
	// Channel26 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL26_NonSecure = 0x0
	// Position of CHANNEL27 field.
	SPU_DPPI_PERM_CHANNEL27_Pos = 0x1b
	// Bit mask of CHANNEL27 field.
	SPU_DPPI_PERM_CHANNEL27_Msk = 0x8000000
	// Bit CHANNEL27.
	SPU_DPPI_PERM_CHANNEL27 = 0x8000000
	// Channel27 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL27_Secure = 0x1
	// Channel27 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL27_NonSecure = 0x0
	// Position of CHANNEL28 field.
	SPU_DPPI_PERM_CHANNEL28_Pos = 0x1c
	// Bit mask of CHANNEL28 field.
	SPU_DPPI_PERM_CHANNEL28_Msk = 0x10000000
	// Bit CHANNEL28.
	SPU_DPPI_PERM_CHANNEL28 = 0x10000000
	// Channel28 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL28_Secure = 0x1
	// Channel28 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL28_NonSecure = 0x0
	// Position of CHANNEL29 field.
	SPU_DPPI_PERM_CHANNEL29_Pos = 0x1d
	// Bit mask of CHANNEL29 field.
	SPU_DPPI_PERM_CHANNEL29_Msk = 0x20000000
	// Bit CHANNEL29.
	SPU_DPPI_PERM_CHANNEL29 = 0x20000000
	// Channel29 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL29_Secure = 0x1
	// Channel29 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL29_NonSecure = 0x0
	// Position of CHANNEL30 field.
	SPU_DPPI_PERM_CHANNEL30_Pos = 0x1e
	// Bit mask of CHANNEL30 field.
	SPU_DPPI_PERM_CHANNEL30_Msk = 0x40000000
	// Bit CHANNEL30.
	SPU_DPPI_PERM_CHANNEL30 = 0x40000000
	// Channel30 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL30_Secure = 0x1
	// Channel30 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL30_NonSecure = 0x0
	// Position of CHANNEL31 field.
	SPU_DPPI_PERM_CHANNEL31_Pos = 0x1f
	// Bit mask of CHANNEL31 field.
	SPU_DPPI_PERM_CHANNEL31_Msk = 0x80000000
	// Bit CHANNEL31.
	SPU_DPPI_PERM_CHANNEL31 = 0x80000000
	// Channel31 has its secure attribute set
	SPU_DPPI_PERM_CHANNEL31_Secure = 0x1
	// Channel31 has its non-secure attribute set
	SPU_DPPI_PERM_CHANNEL31_NonSecure = 0x0

	// DPPI.LOCK: Description cluster: Prevent further modification of the corresponding PERM register
	// Position of LOCK field.
	SPU_DPPI_LOCK_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	SPU_DPPI_LOCK_LOCK_Msk = 0x1
	// Bit LOCK.
	SPU_DPPI_LOCK_LOCK = 0x1
	// DPPI[n].PERM register can't be changed until next reset
	SPU_DPPI_LOCK_LOCK_Locked = 0x1
	// DPPI[n].PERM register content can be changed
	SPU_DPPI_LOCK_LOCK_Unlocked = 0x0

	// GPIOPORT.PERM: Description cluster: Select between secure and non-secure attribute for pins 0 to 31 of port n.
	// Position of PIN0 field.
	SPU_GPIOPORT_PERM_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	SPU_GPIOPORT_PERM_PIN0_Msk = 0x1
	// Bit PIN0.
	SPU_GPIOPORT_PERM_PIN0 = 0x1
	// Pin 0 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN0_Secure = 0x1
	// Pin 0 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN0_NonSecure = 0x0
	// Position of PIN1 field.
	SPU_GPIOPORT_PERM_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	SPU_GPIOPORT_PERM_PIN1_Msk = 0x2
	// Bit PIN1.
	SPU_GPIOPORT_PERM_PIN1 = 0x2
	// Pin 1 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN1_Secure = 0x1
	// Pin 1 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN1_NonSecure = 0x0
	// Position of PIN2 field.
	SPU_GPIOPORT_PERM_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	SPU_GPIOPORT_PERM_PIN2_Msk = 0x4
	// Bit PIN2.
	SPU_GPIOPORT_PERM_PIN2 = 0x4
	// Pin 2 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN2_Secure = 0x1
	// Pin 2 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN2_NonSecure = 0x0
	// Position of PIN3 field.
	SPU_GPIOPORT_PERM_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	SPU_GPIOPORT_PERM_PIN3_Msk = 0x8
	// Bit PIN3.
	SPU_GPIOPORT_PERM_PIN3 = 0x8
	// Pin 3 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN3_Secure = 0x1
	// Pin 3 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN3_NonSecure = 0x0
	// Position of PIN4 field.
	SPU_GPIOPORT_PERM_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	SPU_GPIOPORT_PERM_PIN4_Msk = 0x10
	// Bit PIN4.
	SPU_GPIOPORT_PERM_PIN4 = 0x10
	// Pin 4 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN4_Secure = 0x1
	// Pin 4 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN4_NonSecure = 0x0
	// Position of PIN5 field.
	SPU_GPIOPORT_PERM_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	SPU_GPIOPORT_PERM_PIN5_Msk = 0x20
	// Bit PIN5.
	SPU_GPIOPORT_PERM_PIN5 = 0x20
	// Pin 5 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN5_Secure = 0x1
	// Pin 5 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN5_NonSecure = 0x0
	// Position of PIN6 field.
	SPU_GPIOPORT_PERM_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	SPU_GPIOPORT_PERM_PIN6_Msk = 0x40
	// Bit PIN6.
	SPU_GPIOPORT_PERM_PIN6 = 0x40
	// Pin 6 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN6_Secure = 0x1
	// Pin 6 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN6_NonSecure = 0x0
	// Position of PIN7 field.
	SPU_GPIOPORT_PERM_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	SPU_GPIOPORT_PERM_PIN7_Msk = 0x80
	// Bit PIN7.
	SPU_GPIOPORT_PERM_PIN7 = 0x80
	// Pin 7 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN7_Secure = 0x1
	// Pin 7 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN7_NonSecure = 0x0
	// Position of PIN8 field.
	SPU_GPIOPORT_PERM_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	SPU_GPIOPORT_PERM_PIN8_Msk = 0x100
	// Bit PIN8.
	SPU_GPIOPORT_PERM_PIN8 = 0x100
	// Pin 8 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN8_Secure = 0x1
	// Pin 8 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN8_NonSecure = 0x0
	// Position of PIN9 field.
	SPU_GPIOPORT_PERM_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	SPU_GPIOPORT_PERM_PIN9_Msk = 0x200
	// Bit PIN9.
	SPU_GPIOPORT_PERM_PIN9 = 0x200
	// Pin 9 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN9_Secure = 0x1
	// Pin 9 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN9_NonSecure = 0x0
	// Position of PIN10 field.
	SPU_GPIOPORT_PERM_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	SPU_GPIOPORT_PERM_PIN10_Msk = 0x400
	// Bit PIN10.
	SPU_GPIOPORT_PERM_PIN10 = 0x400
	// Pin 10 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN10_Secure = 0x1
	// Pin 10 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN10_NonSecure = 0x0
	// Position of PIN11 field.
	SPU_GPIOPORT_PERM_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	SPU_GPIOPORT_PERM_PIN11_Msk = 0x800
	// Bit PIN11.
	SPU_GPIOPORT_PERM_PIN11 = 0x800
	// Pin 11 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN11_Secure = 0x1
	// Pin 11 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN11_NonSecure = 0x0
	// Position of PIN12 field.
	SPU_GPIOPORT_PERM_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	SPU_GPIOPORT_PERM_PIN12_Msk = 0x1000
	// Bit PIN12.
	SPU_GPIOPORT_PERM_PIN12 = 0x1000
	// Pin 12 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN12_Secure = 0x1
	// Pin 12 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN12_NonSecure = 0x0
	// Position of PIN13 field.
	SPU_GPIOPORT_PERM_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	SPU_GPIOPORT_PERM_PIN13_Msk = 0x2000
	// Bit PIN13.
	SPU_GPIOPORT_PERM_PIN13 = 0x2000
	// Pin 13 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN13_Secure = 0x1
	// Pin 13 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN13_NonSecure = 0x0
	// Position of PIN14 field.
	SPU_GPIOPORT_PERM_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	SPU_GPIOPORT_PERM_PIN14_Msk = 0x4000
	// Bit PIN14.
	SPU_GPIOPORT_PERM_PIN14 = 0x4000
	// Pin 14 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN14_Secure = 0x1
	// Pin 14 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN14_NonSecure = 0x0
	// Position of PIN15 field.
	SPU_GPIOPORT_PERM_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	SPU_GPIOPORT_PERM_PIN15_Msk = 0x8000
	// Bit PIN15.
	SPU_GPIOPORT_PERM_PIN15 = 0x8000
	// Pin 15 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN15_Secure = 0x1
	// Pin 15 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN15_NonSecure = 0x0
	// Position of PIN16 field.
	SPU_GPIOPORT_PERM_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	SPU_GPIOPORT_PERM_PIN16_Msk = 0x10000
	// Bit PIN16.
	SPU_GPIOPORT_PERM_PIN16 = 0x10000
	// Pin 16 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN16_Secure = 0x1
	// Pin 16 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN16_NonSecure = 0x0
	// Position of PIN17 field.
	SPU_GPIOPORT_PERM_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	SPU_GPIOPORT_PERM_PIN17_Msk = 0x20000
	// Bit PIN17.
	SPU_GPIOPORT_PERM_PIN17 = 0x20000
	// Pin 17 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN17_Secure = 0x1
	// Pin 17 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN17_NonSecure = 0x0
	// Position of PIN18 field.
	SPU_GPIOPORT_PERM_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	SPU_GPIOPORT_PERM_PIN18_Msk = 0x40000
	// Bit PIN18.
	SPU_GPIOPORT_PERM_PIN18 = 0x40000
	// Pin 18 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN18_Secure = 0x1
	// Pin 18 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN18_NonSecure = 0x0
	// Position of PIN19 field.
	SPU_GPIOPORT_PERM_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	SPU_GPIOPORT_PERM_PIN19_Msk = 0x80000
	// Bit PIN19.
	SPU_GPIOPORT_PERM_PIN19 = 0x80000
	// Pin 19 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN19_Secure = 0x1
	// Pin 19 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN19_NonSecure = 0x0
	// Position of PIN20 field.
	SPU_GPIOPORT_PERM_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	SPU_GPIOPORT_PERM_PIN20_Msk = 0x100000
	// Bit PIN20.
	SPU_GPIOPORT_PERM_PIN20 = 0x100000
	// Pin 20 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN20_Secure = 0x1
	// Pin 20 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN20_NonSecure = 0x0
	// Position of PIN21 field.
	SPU_GPIOPORT_PERM_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	SPU_GPIOPORT_PERM_PIN21_Msk = 0x200000
	// Bit PIN21.
	SPU_GPIOPORT_PERM_PIN21 = 0x200000
	// Pin 21 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN21_Secure = 0x1
	// Pin 21 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN21_NonSecure = 0x0
	// Position of PIN22 field.
	SPU_GPIOPORT_PERM_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	SPU_GPIOPORT_PERM_PIN22_Msk = 0x400000
	// Bit PIN22.
	SPU_GPIOPORT_PERM_PIN22 = 0x400000
	// Pin 22 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN22_Secure = 0x1
	// Pin 22 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN22_NonSecure = 0x0
	// Position of PIN23 field.
	SPU_GPIOPORT_PERM_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	SPU_GPIOPORT_PERM_PIN23_Msk = 0x800000
	// Bit PIN23.
	SPU_GPIOPORT_PERM_PIN23 = 0x800000
	// Pin 23 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN23_Secure = 0x1
	// Pin 23 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN23_NonSecure = 0x0
	// Position of PIN24 field.
	SPU_GPIOPORT_PERM_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	SPU_GPIOPORT_PERM_PIN24_Msk = 0x1000000
	// Bit PIN24.
	SPU_GPIOPORT_PERM_PIN24 = 0x1000000
	// Pin 24 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN24_Secure = 0x1
	// Pin 24 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN24_NonSecure = 0x0
	// Position of PIN25 field.
	SPU_GPIOPORT_PERM_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	SPU_GPIOPORT_PERM_PIN25_Msk = 0x2000000
	// Bit PIN25.
	SPU_GPIOPORT_PERM_PIN25 = 0x2000000
	// Pin 25 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN25_Secure = 0x1
	// Pin 25 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN25_NonSecure = 0x0
	// Position of PIN26 field.
	SPU_GPIOPORT_PERM_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	SPU_GPIOPORT_PERM_PIN26_Msk = 0x4000000
	// Bit PIN26.
	SPU_GPIOPORT_PERM_PIN26 = 0x4000000
	// Pin 26 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN26_Secure = 0x1
	// Pin 26 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN26_NonSecure = 0x0
	// Position of PIN27 field.
	SPU_GPIOPORT_PERM_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	SPU_GPIOPORT_PERM_PIN27_Msk = 0x8000000
	// Bit PIN27.
	SPU_GPIOPORT_PERM_PIN27 = 0x8000000
	// Pin 27 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN27_Secure = 0x1
	// Pin 27 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN27_NonSecure = 0x0
	// Position of PIN28 field.
	SPU_GPIOPORT_PERM_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	SPU_GPIOPORT_PERM_PIN28_Msk = 0x10000000
	// Bit PIN28.
	SPU_GPIOPORT_PERM_PIN28 = 0x10000000
	// Pin 28 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN28_Secure = 0x1
	// Pin 28 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN28_NonSecure = 0x0
	// Position of PIN29 field.
	SPU_GPIOPORT_PERM_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	SPU_GPIOPORT_PERM_PIN29_Msk = 0x20000000
	// Bit PIN29.
	SPU_GPIOPORT_PERM_PIN29 = 0x20000000
	// Pin 29 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN29_Secure = 0x1
	// Pin 29 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN29_NonSecure = 0x0
	// Position of PIN30 field.
	SPU_GPIOPORT_PERM_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	SPU_GPIOPORT_PERM_PIN30_Msk = 0x40000000
	// Bit PIN30.
	SPU_GPIOPORT_PERM_PIN30 = 0x40000000
	// Pin 30 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN30_Secure = 0x1
	// Pin 30 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN30_NonSecure = 0x0
	// Position of PIN31 field.
	SPU_GPIOPORT_PERM_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	SPU_GPIOPORT_PERM_PIN31_Msk = 0x80000000
	// Bit PIN31.
	SPU_GPIOPORT_PERM_PIN31 = 0x80000000
	// Pin 31 has its secure attribute set
	SPU_GPIOPORT_PERM_PIN31_Secure = 0x1
	// Pin 31 has its non-secure attribute set
	SPU_GPIOPORT_PERM_PIN31_NonSecure = 0x0

	// GPIOPORT.LOCK: Description cluster: Prevent further modification of the corresponding PERM register
	// Position of LOCK field.
	SPU_GPIOPORT_LOCK_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	SPU_GPIOPORT_LOCK_LOCK_Msk = 0x1
	// Bit LOCK.
	SPU_GPIOPORT_LOCK_LOCK = 0x1
	// GPIOPORT[n].PERM register can't be changed until next reset
	SPU_GPIOPORT_LOCK_LOCK_Locked = 0x1
	// GPIOPORT[n].PERM register content can be changed
	SPU_GPIOPORT_LOCK_LOCK_Unlocked = 0x0

	// FLASHNSC.REGION: Description cluster: Define which flash region can contain the non-secure callable (NSC) region n
	// Position of REGION field.
	SPU_FLASHNSC_REGION_REGION_Pos = 0x0
	// Bit mask of REGION field.
	SPU_FLASHNSC_REGION_REGION_Msk = 0x3f
	// Position of LOCK field.
	SPU_FLASHNSC_REGION_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_FLASHNSC_REGION_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_FLASHNSC_REGION_LOCK = 0x100
	// This register can be updated
	SPU_FLASHNSC_REGION_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_FLASHNSC_REGION_LOCK_Locked = 0x1

	// FLASHNSC.SIZE: Description cluster: Define the size of the non-secure callable (NSC) region n
	// Position of SIZE field.
	SPU_FLASHNSC_SIZE_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	SPU_FLASHNSC_SIZE_SIZE_Msk = 0xf
	// The region n is not defined as a non-secure callable region. Normal security attributes (secure or non-secure) are enforced.
	SPU_FLASHNSC_SIZE_SIZE_Disabled = 0x0
	// The region n is defined as non-secure callable with a 32-byte size
	SPU_FLASHNSC_SIZE_SIZE_32 = 0x1
	// The region n is defined as non-secure callable with a 64-byte size
	SPU_FLASHNSC_SIZE_SIZE_64 = 0x2
	// The region n is defined as non-secure callable with a 128-byte size
	SPU_FLASHNSC_SIZE_SIZE_128 = 0x3
	// The region n is defined as non-secure callable with a 256-byte size
	SPU_FLASHNSC_SIZE_SIZE_256 = 0x4
	// The region n is defined as non-secure callable with a 512-byte size
	SPU_FLASHNSC_SIZE_SIZE_512 = 0x5
	// The region n is defined as non-secure callable with a 1024-byte size
	SPU_FLASHNSC_SIZE_SIZE_1024 = 0x6
	// The region n is defined as non-secure callable with a 2048-byte size
	SPU_FLASHNSC_SIZE_SIZE_2048 = 0x7
	// The region n is defined as non-secure callable with a 4096-byte size
	SPU_FLASHNSC_SIZE_SIZE_4096 = 0x8
	// Position of LOCK field.
	SPU_FLASHNSC_SIZE_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_FLASHNSC_SIZE_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_FLASHNSC_SIZE_LOCK = 0x100
	// This register can be updated
	SPU_FLASHNSC_SIZE_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_FLASHNSC_SIZE_LOCK_Locked = 0x1

	// RAMNSC.REGION: Description cluster: Define which RAM region can contain the non-secure callable (NSC) region n
	// Position of REGION field.
	SPU_RAMNSC_REGION_REGION_Pos = 0x0
	// Bit mask of REGION field.
	SPU_RAMNSC_REGION_REGION_Msk = 0x3f
	// Position of LOCK field.
	SPU_RAMNSC_REGION_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_RAMNSC_REGION_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_RAMNSC_REGION_LOCK = 0x100
	// This register can be updated
	SPU_RAMNSC_REGION_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_RAMNSC_REGION_LOCK_Locked = 0x1

	// RAMNSC.SIZE: Description cluster: Define the size of the non-secure callable (NSC) region n
	// Position of SIZE field.
	SPU_RAMNSC_SIZE_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	SPU_RAMNSC_SIZE_SIZE_Msk = 0xf
	// The region n is not defined as a non-secure callable region. Normal security attributes (secure or non-secure) are enforced.
	SPU_RAMNSC_SIZE_SIZE_Disabled = 0x0
	// The region n is defined as non-secure callable with a 32-byte size
	SPU_RAMNSC_SIZE_SIZE_32 = 0x1
	// The region n is defined as non-secure callable with a 64-byte size
	SPU_RAMNSC_SIZE_SIZE_64 = 0x2
	// The region n is defined as non-secure callable with a 128-byte size
	SPU_RAMNSC_SIZE_SIZE_128 = 0x3
	// The region n is defined as non-secure callable with a 256-byte size
	SPU_RAMNSC_SIZE_SIZE_256 = 0x4
	// The region n is defined as non-secure callable with a 512-byte size
	SPU_RAMNSC_SIZE_SIZE_512 = 0x5
	// The region n is defined as non-secure callable with a 1024-byte size
	SPU_RAMNSC_SIZE_SIZE_1024 = 0x6
	// The region n is defined as non-secure callable with a 2048-byte size
	SPU_RAMNSC_SIZE_SIZE_2048 = 0x7
	// The region n is defined as non-secure callable with a 4096-byte size
	SPU_RAMNSC_SIZE_SIZE_4096 = 0x8
	// Position of LOCK field.
	SPU_RAMNSC_SIZE_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_RAMNSC_SIZE_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_RAMNSC_SIZE_LOCK = 0x100
	// This register can be updated
	SPU_RAMNSC_SIZE_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_RAMNSC_SIZE_LOCK_Locked = 0x1

	// FLASHREGION.PERM: Description cluster: Access permissions for flash region n
	// Position of EXECUTE field.
	SPU_FLASHREGION_PERM_EXECUTE_Pos = 0x0
	// Bit mask of EXECUTE field.
	SPU_FLASHREGION_PERM_EXECUTE_Msk = 0x1
	// Bit EXECUTE.
	SPU_FLASHREGION_PERM_EXECUTE = 0x1
	// Allow instruction fetches from flash region n
	SPU_FLASHREGION_PERM_EXECUTE_Enable = 0x1
	// Block instruction fetches from flash region n
	SPU_FLASHREGION_PERM_EXECUTE_Disable = 0x0
	// Position of WRITE field.
	SPU_FLASHREGION_PERM_WRITE_Pos = 0x1
	// Bit mask of WRITE field.
	SPU_FLASHREGION_PERM_WRITE_Msk = 0x2
	// Bit WRITE.
	SPU_FLASHREGION_PERM_WRITE = 0x2
	// Allow write operation to region n
	SPU_FLASHREGION_PERM_WRITE_Enable = 0x1
	// Block write operation to region n
	SPU_FLASHREGION_PERM_WRITE_Disable = 0x0
	// Position of READ field.
	SPU_FLASHREGION_PERM_READ_Pos = 0x2
	// Bit mask of READ field.
	SPU_FLASHREGION_PERM_READ_Msk = 0x4
	// Bit READ.
	SPU_FLASHREGION_PERM_READ = 0x4
	// Allow read operation from flash region n
	SPU_FLASHREGION_PERM_READ_Enable = 0x1
	// Block read operation from flash region n
	SPU_FLASHREGION_PERM_READ_Disable = 0x0
	// Position of SECATTR field.
	SPU_FLASHREGION_PERM_SECATTR_Pos = 0x4
	// Bit mask of SECATTR field.
	SPU_FLASHREGION_PERM_SECATTR_Msk = 0x10
	// Bit SECATTR.
	SPU_FLASHREGION_PERM_SECATTR = 0x10
	// Flash region n security attribute is non-secure
	SPU_FLASHREGION_PERM_SECATTR_Non_Secure = 0x0
	// Flash region n security attribute is secure
	SPU_FLASHREGION_PERM_SECATTR_Secure = 0x1
	// Position of LOCK field.
	SPU_FLASHREGION_PERM_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_FLASHREGION_PERM_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_FLASHREGION_PERM_LOCK = 0x100
	// This register can be updated
	SPU_FLASHREGION_PERM_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_FLASHREGION_PERM_LOCK_Locked = 0x1

	// RAMREGION.PERM: Description cluster: Access permissions for RAM region n
	// Position of EXECUTE field.
	SPU_RAMREGION_PERM_EXECUTE_Pos = 0x0
	// Bit mask of EXECUTE field.
	SPU_RAMREGION_PERM_EXECUTE_Msk = 0x1
	// Bit EXECUTE.
	SPU_RAMREGION_PERM_EXECUTE = 0x1
	// Allow instruction fetches from RAM region n
	SPU_RAMREGION_PERM_EXECUTE_Enable = 0x1
	// Block instruction fetches from RAM region n
	SPU_RAMREGION_PERM_EXECUTE_Disable = 0x0
	// Position of WRITE field.
	SPU_RAMREGION_PERM_WRITE_Pos = 0x1
	// Bit mask of WRITE field.
	SPU_RAMREGION_PERM_WRITE_Msk = 0x2
	// Bit WRITE.
	SPU_RAMREGION_PERM_WRITE = 0x2
	// Allow write operation to RAM region n
	SPU_RAMREGION_PERM_WRITE_Enable = 0x1
	// Block write operation to RAM region n
	SPU_RAMREGION_PERM_WRITE_Disable = 0x0
	// Position of READ field.
	SPU_RAMREGION_PERM_READ_Pos = 0x2
	// Bit mask of READ field.
	SPU_RAMREGION_PERM_READ_Msk = 0x4
	// Bit READ.
	SPU_RAMREGION_PERM_READ = 0x4
	// Allow read operation from RAM region n
	SPU_RAMREGION_PERM_READ_Enable = 0x1
	// Block read operation from RAM region n
	SPU_RAMREGION_PERM_READ_Disable = 0x0
	// Position of SECATTR field.
	SPU_RAMREGION_PERM_SECATTR_Pos = 0x4
	// Bit mask of SECATTR field.
	SPU_RAMREGION_PERM_SECATTR_Msk = 0x10
	// Bit SECATTR.
	SPU_RAMREGION_PERM_SECATTR = 0x10
	// RAM region n security attribute is non-secure
	SPU_RAMREGION_PERM_SECATTR_Non_Secure = 0x0
	// RAM region n security attribute is secure
	SPU_RAMREGION_PERM_SECATTR_Secure = 0x1
	// Position of LOCK field.
	SPU_RAMREGION_PERM_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_RAMREGION_PERM_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_RAMREGION_PERM_LOCK = 0x100
	// This register can be updated
	SPU_RAMREGION_PERM_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_RAMREGION_PERM_LOCK_Locked = 0x1

	// PERIPHID.PERM: Description cluster: List capabilities and access permissions for the peripheral with ID n
	// Position of SECUREMAPPING field.
	SPU_PERIPHID_PERM_SECUREMAPPING_Pos = 0x0
	// Bit mask of SECUREMAPPING field.
	SPU_PERIPHID_PERM_SECUREMAPPING_Msk = 0x3
	// This peripheral is always accessible as a non-secure peripheral
	SPU_PERIPHID_PERM_SECUREMAPPING_NonSecure = 0x0
	// This peripheral is always accessible as a secure peripheral
	SPU_PERIPHID_PERM_SECUREMAPPING_Secure = 0x1
	// Non-secure or secure attribute for this peripheral is defined by the PERIPHID[n].PERM register
	SPU_PERIPHID_PERM_SECUREMAPPING_UserSelectable = 0x2
	// This peripheral implements the split security mechanism. Non-secure or secure attribute for this peripheral is defined by the PERIPHID[n].PERM register.
	SPU_PERIPHID_PERM_SECUREMAPPING_Split = 0x3
	// Position of DMA field.
	SPU_PERIPHID_PERM_DMA_Pos = 0x2
	// Bit mask of DMA field.
	SPU_PERIPHID_PERM_DMA_Msk = 0xc
	// Peripheral has no DMA capability
	SPU_PERIPHID_PERM_DMA_NoDMA = 0x0
	// Peripheral has DMA and DMA transfers always have the same security attribute as assigned to the peripheral
	SPU_PERIPHID_PERM_DMA_NoSeparateAttribute = 0x1
	// Peripheral has DMA and DMA transfers can have a different security attribute than the one assigned to the peripheral
	SPU_PERIPHID_PERM_DMA_SeparateAttribute = 0x2
	// Position of SECATTR field.
	SPU_PERIPHID_PERM_SECATTR_Pos = 0x4
	// Bit mask of SECATTR field.
	SPU_PERIPHID_PERM_SECATTR_Msk = 0x10
	// Bit SECATTR.
	SPU_PERIPHID_PERM_SECATTR = 0x10
	// Peripheral is mapped in secure peripheral address space
	SPU_PERIPHID_PERM_SECATTR_Secure = 0x1
	// If SECUREMAPPING == UserSelectable: Peripheral is mapped in non-secure peripheral address space. If SECUREMAPPING == Split: Peripheral is mapped in non-secure and secure peripheral address space.
	SPU_PERIPHID_PERM_SECATTR_NonSecure = 0x0
	// Position of DMASEC field.
	SPU_PERIPHID_PERM_DMASEC_Pos = 0x5
	// Bit mask of DMASEC field.
	SPU_PERIPHID_PERM_DMASEC_Msk = 0x20
	// Bit DMASEC.
	SPU_PERIPHID_PERM_DMASEC = 0x20
	// DMA transfers initiated by this peripheral have the secure attribute set
	SPU_PERIPHID_PERM_DMASEC_Secure = 0x1
	// DMA transfers initiated by this peripheral have the non-secure attribute set
	SPU_PERIPHID_PERM_DMASEC_NonSecure = 0x0
	// Position of LOCK field.
	SPU_PERIPHID_PERM_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	SPU_PERIPHID_PERM_LOCK_Msk = 0x100
	// Bit LOCK.
	SPU_PERIPHID_PERM_LOCK = 0x100
	// This register can be updated
	SPU_PERIPHID_PERM_LOCK_Unlocked = 0x0
	// The content of this register can't be changed until the next reset
	SPU_PERIPHID_PERM_LOCK_Locked = 0x1
	// Position of PRESENT field.
	SPU_PERIPHID_PERM_PRESENT_Pos = 0x1f
	// Bit mask of PRESENT field.
	SPU_PERIPHID_PERM_PRESENT_Msk = 0x80000000
	// Bit PRESENT.
	SPU_PERIPHID_PERM_PRESENT = 0x80000000
	// Peripheral is not present
	SPU_PERIPHID_PERM_PRESENT_NotPresent = 0x0
	// Peripheral is present
	SPU_PERIPHID_PERM_PRESENT_IsPresent = 0x1
)

// Constants for OSCILLATORS_NS: Oscillator control 0
const (
	// XOSC32MCAPS: Programmable capacitance of XC1 and XC2
	// Position of CAPVALUE field.
	OSCILLATORS_XOSC32MCAPS_CAPVALUE_Pos = 0x0
	// Bit mask of CAPVALUE field.
	OSCILLATORS_XOSC32MCAPS_CAPVALUE_Msk = 0x1f
	// Position of ENABLE field.
	OSCILLATORS_XOSC32MCAPS_ENABLE_Pos = 0x8
	// Bit mask of ENABLE field.
	OSCILLATORS_XOSC32MCAPS_ENABLE_Msk = 0x100
	// Bit ENABLE.
	OSCILLATORS_XOSC32MCAPS_ENABLE = 0x100
	// Capacitor disabled (use external caps)
	OSCILLATORS_XOSC32MCAPS_ENABLE_Disabled = 0x0
	// Capacitor enabled
	OSCILLATORS_XOSC32MCAPS_ENABLE_Enabled = 0x1

	// XOSC32KI.BYPASS: Enable or disable bypass of LFCLK crystal oscillator with external clock source
	// Position of BYPASS field.
	OSCILLATORS_XOSC32KI_BYPASS_BYPASS_Pos = 0x0
	// Bit mask of BYPASS field.
	OSCILLATORS_XOSC32KI_BYPASS_BYPASS_Msk = 0x1
	// Bit BYPASS.
	OSCILLATORS_XOSC32KI_BYPASS_BYPASS = 0x1
	// Disable (use with crystal or low-swing external source)
	OSCILLATORS_XOSC32KI_BYPASS_BYPASS_Disabled = 0x0
	// Enable (use with rail-to-rail external source)
	OSCILLATORS_XOSC32KI_BYPASS_BYPASS_Enabled = 0x1

	// XOSC32KI.INTCAP: Control usage of internal load capacitors
	// Position of INTCAP field.
	OSCILLATORS_XOSC32KI_INTCAP_INTCAP_Pos = 0x0
	// Bit mask of INTCAP field.
	OSCILLATORS_XOSC32KI_INTCAP_INTCAP_Msk = 0x3
	// Use external load capacitors
	OSCILLATORS_XOSC32KI_INTCAP_INTCAP_External = 0x0
	// 6 pF internal load capacitance
	OSCILLATORS_XOSC32KI_INTCAP_INTCAP_C6PF = 0x1
	// 7 pF internal load capacitance
	OSCILLATORS_XOSC32KI_INTCAP_INTCAP_C7PF = 0x2
	// 11 pF internal load capacitance
	OSCILLATORS_XOSC32KI_INTCAP_INTCAP_C11PF = 0x3
)

// Constants for REGULATORS_NS: Voltage regulators 0
const (
	// MAINREGSTATUS: Main supply status
	// Position of VREGH field.
	REGULATORS_MAINREGSTATUS_VREGH_Pos = 0x0
	// Bit mask of VREGH field.
	REGULATORS_MAINREGSTATUS_VREGH_Msk = 0x1
	// Bit VREGH.
	REGULATORS_MAINREGSTATUS_VREGH = 0x1
	// Normal voltage mode. Voltage supplied on VDD and VDDH.
	REGULATORS_MAINREGSTATUS_VREGH_Inactive = 0x0
	// High voltage mode. Voltage supplied on VDDH.
	REGULATORS_MAINREGSTATUS_VREGH_Active = 0x1

	// SYSTEMOFF: System OFF register
	// Position of SYSTEMOFF field.
	REGULATORS_SYSTEMOFF_SYSTEMOFF_Pos = 0x0
	// Bit mask of SYSTEMOFF field.
	REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk = 0x1
	// Bit SYSTEMOFF.
	REGULATORS_SYSTEMOFF_SYSTEMOFF = 0x1
	// Enable System OFF mode
	REGULATORS_SYSTEMOFF_SYSTEMOFF_Enter = 0x1

	// POFCON: Power-fail comparator configuration
	// Position of POF field.
	REGULATORS_POFCON_POF_Pos = 0x0
	// Bit mask of POF field.
	REGULATORS_POFCON_POF_Msk = 0x1
	// Bit POF.
	REGULATORS_POFCON_POF = 0x1
	// Disable
	REGULATORS_POFCON_POF_Disabled = 0x0
	// Enable
	REGULATORS_POFCON_POF_Enabled = 0x1
	// Position of THRESHOLD field.
	REGULATORS_POFCON_THRESHOLD_Pos = 0x1
	// Bit mask of THRESHOLD field.
	REGULATORS_POFCON_THRESHOLD_Msk = 0x1e
	// Set threshold to 1.9 V
	REGULATORS_POFCON_THRESHOLD_V19 = 0x6
	// Set threshold to 2.0 V
	REGULATORS_POFCON_THRESHOLD_V20 = 0x7
	// Set threshold to 2.1 V
	REGULATORS_POFCON_THRESHOLD_V21 = 0x8
	// Set threshold to 2.2 V
	REGULATORS_POFCON_THRESHOLD_V22 = 0x9
	// Set threshold to 2.3 V
	REGULATORS_POFCON_THRESHOLD_V23 = 0xa
	// Set threshold to 2.4 V
	REGULATORS_POFCON_THRESHOLD_V24 = 0xb
	// Set threshold to 2.5 V
	REGULATORS_POFCON_THRESHOLD_V25 = 0xc
	// Set threshold to 2.6 V
	REGULATORS_POFCON_THRESHOLD_V26 = 0xd
	// Set threshold to 2.7 V
	REGULATORS_POFCON_THRESHOLD_V27 = 0xe
	// Set threshold to 2.8 V
	REGULATORS_POFCON_THRESHOLD_V28 = 0xf
	// Position of THRESHOLDVDDH field.
	REGULATORS_POFCON_THRESHOLDVDDH_Pos = 0x8
	// Bit mask of THRESHOLDVDDH field.
	REGULATORS_POFCON_THRESHOLDVDDH_Msk = 0xf00
	// Set threshold to 2.7 V
	REGULATORS_POFCON_THRESHOLDVDDH_V27 = 0x0
	// Set threshold to 2.8 V
	REGULATORS_POFCON_THRESHOLDVDDH_V28 = 0x1
	// Set threshold to 2.9 V
	REGULATORS_POFCON_THRESHOLDVDDH_V29 = 0x2
	// Set threshold to 3.0 V
	REGULATORS_POFCON_THRESHOLDVDDH_V30 = 0x3
	// Set threshold to 3.1 V
	REGULATORS_POFCON_THRESHOLDVDDH_V31 = 0x4
	// Set threshold to 3.2 V
	REGULATORS_POFCON_THRESHOLDVDDH_V32 = 0x5
	// Set threshold to 3.3 V
	REGULATORS_POFCON_THRESHOLDVDDH_V33 = 0x6
	// Set threshold to 3.4 V
	REGULATORS_POFCON_THRESHOLDVDDH_V34 = 0x7
	// Set threshold to 3.5 V
	REGULATORS_POFCON_THRESHOLDVDDH_V35 = 0x8
	// Set threshold to 3.6 V
	REGULATORS_POFCON_THRESHOLDVDDH_V36 = 0x9
	// Set threshold to 3.7 V
	REGULATORS_POFCON_THRESHOLDVDDH_V37 = 0xa
	// Set threshold to 3.8 V
	REGULATORS_POFCON_THRESHOLDVDDH_V38 = 0xb
	// Set threshold to 3.9 V
	REGULATORS_POFCON_THRESHOLDVDDH_V39 = 0xc
	// Set threshold to 4.0 V
	REGULATORS_POFCON_THRESHOLDVDDH_V40 = 0xd
	// Set threshold to 4.1 V
	REGULATORS_POFCON_THRESHOLDVDDH_V41 = 0xe
	// Set threshold to 4.2 V
	REGULATORS_POFCON_THRESHOLDVDDH_V42 = 0xf

	// VREGMAIN.DCDCEN: DC/DC enable register for VREGMAIN
	// Position of DCDCEN field.
	REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Pos = 0x0
	// Bit mask of DCDCEN field.
	REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk = 0x1
	// Bit DCDCEN.
	REGULATORS_VREGMAIN_DCDCEN_DCDCEN = 0x1
	// Disable
	REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Disabled = 0x0
	// Enable
	REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Enabled = 0x1

	// VREGRADIO.DCDCEN: DC/DC enable register for VREGRADIO
	// Position of DCDCEN field.
	REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Pos = 0x0
	// Bit mask of DCDCEN field.
	REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Msk = 0x1
	// Bit DCDCEN.
	REGULATORS_VREGRADIO_DCDCEN_DCDCEN = 0x1
	// Disable
	REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Disabled = 0x0
	// Enable
	REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled = 0x1

	// VREGH.DCDCEN: DC/DC enable register for VREGH
	// Position of DCDCEN field.
	REGULATORS_VREGH_DCDCEN_DCDCEN_Pos = 0x0
	// Bit mask of DCDCEN field.
	REGULATORS_VREGH_DCDCEN_DCDCEN_Msk = 0x1
	// Bit DCDCEN.
	REGULATORS_VREGH_DCDCEN_DCDCEN = 0x1
	// Disable
	REGULATORS_VREGH_DCDCEN_DCDCEN_Disabled = 0x0
	// Enable
	REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled = 0x1
)

// Constants for CLOCK_NS: Clock management 0
const (
	// TASKS_HFCLKSTART: Start HFCLK128M/HFCLK64M source as selected in HFCLKSRC
	// Position of TASKS_HFCLKSTART field.
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Pos = 0x0
	// Bit mask of TASKS_HFCLKSTART field.
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Msk = 0x1
	// Bit TASKS_HFCLKSTART.
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Trigger = 0x1

	// TASKS_HFCLKSTOP: Stop HFCLK128M/HFCLK64M source
	// Position of TASKS_HFCLKSTOP field.
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Pos = 0x0
	// Bit mask of TASKS_HFCLKSTOP field.
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Msk = 0x1
	// Bit TASKS_HFCLKSTOP.
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Trigger = 0x1

	// TASKS_LFCLKSTART: Start LFCLK source as selected in LFCLKSRC
	// Position of TASKS_LFCLKSTART field.
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Pos = 0x0
	// Bit mask of TASKS_LFCLKSTART field.
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Msk = 0x1
	// Bit TASKS_LFCLKSTART.
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART = 0x1
	// Trigger task
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Trigger = 0x1

	// TASKS_LFCLKSTOP: Stop LFCLK source
	// Position of TASKS_LFCLKSTOP field.
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Pos = 0x0
	// Bit mask of TASKS_LFCLKSTOP field.
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Msk = 0x1
	// Bit TASKS_LFCLKSTOP.
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Trigger = 0x1

	// TASKS_CAL: Start calibration of LFRC oscillator
	// Position of TASKS_CAL field.
	CLOCK_TASKS_CAL_TASKS_CAL_Pos = 0x0
	// Bit mask of TASKS_CAL field.
	CLOCK_TASKS_CAL_TASKS_CAL_Msk = 0x1
	// Bit TASKS_CAL.
	CLOCK_TASKS_CAL_TASKS_CAL = 0x1
	// Trigger task
	CLOCK_TASKS_CAL_TASKS_CAL_Trigger = 0x1

	// TASKS_HFCLKAUDIOSTART: Start HFCLKAUDIO source
	// Position of TASKS_HFCLKAUDIOSTART field.
	CLOCK_TASKS_HFCLKAUDIOSTART_TASKS_HFCLKAUDIOSTART_Pos = 0x0
	// Bit mask of TASKS_HFCLKAUDIOSTART field.
	CLOCK_TASKS_HFCLKAUDIOSTART_TASKS_HFCLKAUDIOSTART_Msk = 0x1
	// Bit TASKS_HFCLKAUDIOSTART.
	CLOCK_TASKS_HFCLKAUDIOSTART_TASKS_HFCLKAUDIOSTART = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLKAUDIOSTART_TASKS_HFCLKAUDIOSTART_Trigger = 0x1

	// TASKS_HFCLKAUDIOSTOP: Stop HFCLKAUDIO source
	// Position of TASKS_HFCLKAUDIOSTOP field.
	CLOCK_TASKS_HFCLKAUDIOSTOP_TASKS_HFCLKAUDIOSTOP_Pos = 0x0
	// Bit mask of TASKS_HFCLKAUDIOSTOP field.
	CLOCK_TASKS_HFCLKAUDIOSTOP_TASKS_HFCLKAUDIOSTOP_Msk = 0x1
	// Bit TASKS_HFCLKAUDIOSTOP.
	CLOCK_TASKS_HFCLKAUDIOSTOP_TASKS_HFCLKAUDIOSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLKAUDIOSTOP_TASKS_HFCLKAUDIOSTOP_Trigger = 0x1

	// TASKS_HFCLK192MSTART: Start HFCLK192M source as selected in HFCLK192MSRC
	// Position of TASKS_HFCLK192MSTART field.
	CLOCK_TASKS_HFCLK192MSTART_TASKS_HFCLK192MSTART_Pos = 0x0
	// Bit mask of TASKS_HFCLK192MSTART field.
	CLOCK_TASKS_HFCLK192MSTART_TASKS_HFCLK192MSTART_Msk = 0x1
	// Bit TASKS_HFCLK192MSTART.
	CLOCK_TASKS_HFCLK192MSTART_TASKS_HFCLK192MSTART = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLK192MSTART_TASKS_HFCLK192MSTART_Trigger = 0x1

	// TASKS_HFCLK192MSTOP: Stop HFCLK192M source
	// Position of TASKS_HFCLK192MSTOP field.
	CLOCK_TASKS_HFCLK192MSTOP_TASKS_HFCLK192MSTOP_Pos = 0x0
	// Bit mask of TASKS_HFCLK192MSTOP field.
	CLOCK_TASKS_HFCLK192MSTOP_TASKS_HFCLK192MSTOP_Msk = 0x1
	// Bit TASKS_HFCLK192MSTOP.
	CLOCK_TASKS_HFCLK192MSTOP_TASKS_HFCLK192MSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLK192MSTOP_TASKS_HFCLK192MSTOP_Trigger = 0x1

	// SUBSCRIBE_HFCLKSTART: Subscribe configuration for task HFCLKSTART
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKSTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKSTART_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_HFCLKSTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_HFCLKSTART_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_HFCLKSTART_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_HFCLKSTART_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_HFCLKSTART_EN_Enabled = 0x1

	// SUBSCRIBE_HFCLKSTOP: Subscribe configuration for task HFCLKSTOP
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKSTOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKSTOP_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_HFCLKSTOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_HFCLKSTOP_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_HFCLKSTOP_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_HFCLKSTOP_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_HFCLKSTOP_EN_Enabled = 0x1

	// SUBSCRIBE_LFCLKSTART: Subscribe configuration for task LFCLKSTART
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_LFCLKSTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_LFCLKSTART_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_LFCLKSTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_LFCLKSTART_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_LFCLKSTART_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_LFCLKSTART_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_LFCLKSTART_EN_Enabled = 0x1

	// SUBSCRIBE_LFCLKSTOP: Subscribe configuration for task LFCLKSTOP
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_LFCLKSTOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_LFCLKSTOP_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_LFCLKSTOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_LFCLKSTOP_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_LFCLKSTOP_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_LFCLKSTOP_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_LFCLKSTOP_EN_Enabled = 0x1

	// SUBSCRIBE_CAL: Subscribe configuration for task CAL
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_CAL_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_CAL_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_CAL_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_CAL_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_CAL_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_CAL_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_CAL_EN_Enabled = 0x1

	// SUBSCRIBE_HFCLKAUDIOSTART: Subscribe configuration for task HFCLKAUDIOSTART
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTART_EN_Enabled = 0x1

	// SUBSCRIBE_HFCLKAUDIOSTOP: Subscribe configuration for task HFCLKAUDIOSTOP
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_HFCLKAUDIOSTOP_EN_Enabled = 0x1

	// SUBSCRIBE_HFCLK192MSTART: Subscribe configuration for task HFCLK192MSTART
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLK192MSTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLK192MSTART_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_HFCLK192MSTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_HFCLK192MSTART_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_HFCLK192MSTART_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_HFCLK192MSTART_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_HFCLK192MSTART_EN_Enabled = 0x1

	// SUBSCRIBE_HFCLK192MSTOP: Subscribe configuration for task HFCLK192MSTOP
	// Position of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_EN = 0x80000000
	// Disable subscription
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_EN_Disabled = 0x0
	// Enable subscription
	CLOCK_SUBSCRIBE_HFCLK192MSTOP_EN_Enabled = 0x1

	// EVENTS_HFCLKSTARTED: HFCLK128M/HFCLK64M source started
	// Position of EVENTS_HFCLKSTARTED field.
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Pos = 0x0
	// Bit mask of EVENTS_HFCLKSTARTED field.
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Msk = 0x1
	// Bit EVENTS_HFCLKSTARTED.
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Generated = 0x1

	// EVENTS_LFCLKSTARTED: LFCLK source started
	// Position of EVENTS_LFCLKSTARTED field.
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Pos = 0x0
	// Bit mask of EVENTS_LFCLKSTARTED field.
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Msk = 0x1
	// Bit EVENTS_LFCLKSTARTED.
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Generated = 0x1

	// EVENTS_DONE: Calibration of LFRC oscillator complete event
	// Position of EVENTS_DONE field.
	CLOCK_EVENTS_DONE_EVENTS_DONE_Pos = 0x0
	// Bit mask of EVENTS_DONE field.
	CLOCK_EVENTS_DONE_EVENTS_DONE_Msk = 0x1
	// Bit EVENTS_DONE.
	CLOCK_EVENTS_DONE_EVENTS_DONE = 0x1
	// Event not generated
	CLOCK_EVENTS_DONE_EVENTS_DONE_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_DONE_EVENTS_DONE_Generated = 0x1

	// EVENTS_HFCLKAUDIOSTARTED: HFCLKAUDIO source started
	// Position of EVENTS_HFCLKAUDIOSTARTED field.
	CLOCK_EVENTS_HFCLKAUDIOSTARTED_EVENTS_HFCLKAUDIOSTARTED_Pos = 0x0
	// Bit mask of EVENTS_HFCLKAUDIOSTARTED field.
	CLOCK_EVENTS_HFCLKAUDIOSTARTED_EVENTS_HFCLKAUDIOSTARTED_Msk = 0x1
	// Bit EVENTS_HFCLKAUDIOSTARTED.
	CLOCK_EVENTS_HFCLKAUDIOSTARTED_EVENTS_HFCLKAUDIOSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_HFCLKAUDIOSTARTED_EVENTS_HFCLKAUDIOSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_HFCLKAUDIOSTARTED_EVENTS_HFCLKAUDIOSTARTED_Generated = 0x1

	// EVENTS_HFCLK192MSTARTED: HFCLK192M source started
	// Position of EVENTS_HFCLK192MSTARTED field.
	CLOCK_EVENTS_HFCLK192MSTARTED_EVENTS_HFCLK192MSTARTED_Pos = 0x0
	// Bit mask of EVENTS_HFCLK192MSTARTED field.
	CLOCK_EVENTS_HFCLK192MSTARTED_EVENTS_HFCLK192MSTARTED_Msk = 0x1
	// Bit EVENTS_HFCLK192MSTARTED.
	CLOCK_EVENTS_HFCLK192MSTARTED_EVENTS_HFCLK192MSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_HFCLK192MSTARTED_EVENTS_HFCLK192MSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_HFCLK192MSTARTED_EVENTS_HFCLK192MSTARTED_Generated = 0x1

	// PUBLISH_HFCLKSTARTED: Publish configuration for event HFCLKSTARTED
	// Position of CHIDX field.
	CLOCK_PUBLISH_HFCLKSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_PUBLISH_HFCLKSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_PUBLISH_HFCLKSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_PUBLISH_HFCLKSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_PUBLISH_HFCLKSTARTED_EN = 0x80000000
	// Disable publishing
	CLOCK_PUBLISH_HFCLKSTARTED_EN_Disabled = 0x0
	// Enable publishing
	CLOCK_PUBLISH_HFCLKSTARTED_EN_Enabled = 0x1

	// PUBLISH_LFCLKSTARTED: Publish configuration for event LFCLKSTARTED
	// Position of CHIDX field.
	CLOCK_PUBLISH_LFCLKSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_PUBLISH_LFCLKSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_PUBLISH_LFCLKSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_PUBLISH_LFCLKSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_PUBLISH_LFCLKSTARTED_EN = 0x80000000
	// Disable publishing
	CLOCK_PUBLISH_LFCLKSTARTED_EN_Disabled = 0x0
	// Enable publishing
	CLOCK_PUBLISH_LFCLKSTARTED_EN_Enabled = 0x1

	// PUBLISH_DONE: Publish configuration for event DONE
	// Position of CHIDX field.
	CLOCK_PUBLISH_DONE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_PUBLISH_DONE_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_PUBLISH_DONE_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_PUBLISH_DONE_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_PUBLISH_DONE_EN = 0x80000000
	// Disable publishing
	CLOCK_PUBLISH_DONE_EN_Disabled = 0x0
	// Enable publishing
	CLOCK_PUBLISH_DONE_EN_Enabled = 0x1

	// PUBLISH_HFCLKAUDIOSTARTED: Publish configuration for event HFCLKAUDIOSTARTED
	// Position of CHIDX field.
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_EN = 0x80000000
	// Disable publishing
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_EN_Disabled = 0x0
	// Enable publishing
	CLOCK_PUBLISH_HFCLKAUDIOSTARTED_EN_Enabled = 0x1

	// PUBLISH_HFCLK192MSTARTED: Publish configuration for event HFCLK192MSTARTED
	// Position of CHIDX field.
	CLOCK_PUBLISH_HFCLK192MSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	CLOCK_PUBLISH_HFCLK192MSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	CLOCK_PUBLISH_HFCLK192MSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	CLOCK_PUBLISH_HFCLK192MSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	CLOCK_PUBLISH_HFCLK192MSTARTED_EN = 0x80000000
	// Disable publishing
	CLOCK_PUBLISH_HFCLK192MSTARTED_EN_Disabled = 0x0
	// Enable publishing
	CLOCK_PUBLISH_HFCLK192MSTARTED_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTEN_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTEN_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTEN_HFCLKSTARTED = 0x1
	// Disable
	CLOCK_INTEN_HFCLKSTARTED_Disabled = 0x0
	// Enable
	CLOCK_INTEN_HFCLKSTARTED_Enabled = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTEN_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTEN_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTEN_LFCLKSTARTED = 0x2
	// Disable
	CLOCK_INTEN_LFCLKSTARTED_Disabled = 0x0
	// Enable
	CLOCK_INTEN_LFCLKSTARTED_Enabled = 0x1
	// Position of DONE field.
	CLOCK_INTEN_DONE_Pos = 0x7
	// Bit mask of DONE field.
	CLOCK_INTEN_DONE_Msk = 0x80
	// Bit DONE.
	CLOCK_INTEN_DONE = 0x80
	// Disable
	CLOCK_INTEN_DONE_Disabled = 0x0
	// Enable
	CLOCK_INTEN_DONE_Enabled = 0x1
	// Position of HFCLKAUDIOSTARTED field.
	CLOCK_INTEN_HFCLKAUDIOSTARTED_Pos = 0x8
	// Bit mask of HFCLKAUDIOSTARTED field.
	CLOCK_INTEN_HFCLKAUDIOSTARTED_Msk = 0x100
	// Bit HFCLKAUDIOSTARTED.
	CLOCK_INTEN_HFCLKAUDIOSTARTED = 0x100
	// Disable
	CLOCK_INTEN_HFCLKAUDIOSTARTED_Disabled = 0x0
	// Enable
	CLOCK_INTEN_HFCLKAUDIOSTARTED_Enabled = 0x1
	// Position of HFCLK192MSTARTED field.
	CLOCK_INTEN_HFCLK192MSTARTED_Pos = 0x9
	// Bit mask of HFCLK192MSTARTED field.
	CLOCK_INTEN_HFCLK192MSTARTED_Msk = 0x200
	// Bit HFCLK192MSTARTED.
	CLOCK_INTEN_HFCLK192MSTARTED = 0x200
	// Disable
	CLOCK_INTEN_HFCLK192MSTARTED_Disabled = 0x0
	// Enable
	CLOCK_INTEN_HFCLK192MSTARTED_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTENSET_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTENSET_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTENSET_HFCLKSTARTED = 0x1
	// Read: Disabled
	CLOCK_INTENSET_HFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_HFCLKSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_HFCLKSTARTED_Set = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTENSET_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTENSET_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTENSET_LFCLKSTARTED = 0x2
	// Read: Disabled
	CLOCK_INTENSET_LFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_LFCLKSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_LFCLKSTARTED_Set = 0x1
	// Position of DONE field.
	CLOCK_INTENSET_DONE_Pos = 0x7
	// Bit mask of DONE field.
	CLOCK_INTENSET_DONE_Msk = 0x80
	// Bit DONE.
	CLOCK_INTENSET_DONE = 0x80
	// Read: Disabled
	CLOCK_INTENSET_DONE_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_DONE_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_DONE_Set = 0x1
	// Position of HFCLKAUDIOSTARTED field.
	CLOCK_INTENSET_HFCLKAUDIOSTARTED_Pos = 0x8
	// Bit mask of HFCLKAUDIOSTARTED field.
	CLOCK_INTENSET_HFCLKAUDIOSTARTED_Msk = 0x100
	// Bit HFCLKAUDIOSTARTED.
	CLOCK_INTENSET_HFCLKAUDIOSTARTED = 0x100
	// Read: Disabled
	CLOCK_INTENSET_HFCLKAUDIOSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_HFCLKAUDIOSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_HFCLKAUDIOSTARTED_Set = 0x1
	// Position of HFCLK192MSTARTED field.
	CLOCK_INTENSET_HFCLK192MSTARTED_Pos = 0x9
	// Bit mask of HFCLK192MSTARTED field.
	CLOCK_INTENSET_HFCLK192MSTARTED_Msk = 0x200
	// Bit HFCLK192MSTARTED.
	CLOCK_INTENSET_HFCLK192MSTARTED = 0x200
	// Read: Disabled
	CLOCK_INTENSET_HFCLK192MSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_HFCLK192MSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_HFCLK192MSTARTED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTENCLR_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTENCLR_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTENCLR_HFCLKSTARTED = 0x1
	// Read: Disabled
	CLOCK_INTENCLR_HFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_HFCLKSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_HFCLKSTARTED_Clear = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTENCLR_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTENCLR_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTENCLR_LFCLKSTARTED = 0x2
	// Read: Disabled
	CLOCK_INTENCLR_LFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_LFCLKSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_LFCLKSTARTED_Clear = 0x1
	// Position of DONE field.
	CLOCK_INTENCLR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	CLOCK_INTENCLR_DONE_Msk = 0x80
	// Bit DONE.
	CLOCK_INTENCLR_DONE = 0x80
	// Read: Disabled
	CLOCK_INTENCLR_DONE_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_DONE_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_DONE_Clear = 0x1
	// Position of HFCLKAUDIOSTARTED field.
	CLOCK_INTENCLR_HFCLKAUDIOSTARTED_Pos = 0x8
	// Bit mask of HFCLKAUDIOSTARTED field.
	CLOCK_INTENCLR_HFCLKAUDIOSTARTED_Msk = 0x100
	// Bit HFCLKAUDIOSTARTED.
	CLOCK_INTENCLR_HFCLKAUDIOSTARTED = 0x100
	// Read: Disabled
	CLOCK_INTENCLR_HFCLKAUDIOSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_HFCLKAUDIOSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_HFCLKAUDIOSTARTED_Clear = 0x1
	// Position of HFCLK192MSTARTED field.
	CLOCK_INTENCLR_HFCLK192MSTARTED_Pos = 0x9
	// Bit mask of HFCLK192MSTARTED field.
	CLOCK_INTENCLR_HFCLK192MSTARTED_Msk = 0x200
	// Bit HFCLK192MSTARTED.
	CLOCK_INTENCLR_HFCLK192MSTARTED = 0x200
	// Read: Disabled
	CLOCK_INTENCLR_HFCLK192MSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_HFCLK192MSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_HFCLK192MSTARTED_Clear = 0x1

	// INTPEND: Pending interrupts
	// Position of HFCLKSTARTED field.
	CLOCK_INTPEND_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTPEND_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTPEND_HFCLKSTARTED = 0x1
	// Read: Not pending
	CLOCK_INTPEND_HFCLKSTARTED_NotPending = 0x0
	// Read: Pending
	CLOCK_INTPEND_HFCLKSTARTED_Pending = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTPEND_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTPEND_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTPEND_LFCLKSTARTED = 0x2
	// Read: Not pending
	CLOCK_INTPEND_LFCLKSTARTED_NotPending = 0x0
	// Read: Pending
	CLOCK_INTPEND_LFCLKSTARTED_Pending = 0x1
	// Position of DONE field.
	CLOCK_INTPEND_DONE_Pos = 0x7
	// Bit mask of DONE field.
	CLOCK_INTPEND_DONE_Msk = 0x80
	// Bit DONE.
	CLOCK_INTPEND_DONE = 0x80
	// Read: Not pending
	CLOCK_INTPEND_DONE_NotPending = 0x0
	// Read: Pending
	CLOCK_INTPEND_DONE_Pending = 0x1
	// Position of HFCLKAUDIOSTARTED field.
	CLOCK_INTPEND_HFCLKAUDIOSTARTED_Pos = 0x8
	// Bit mask of HFCLKAUDIOSTARTED field.
	CLOCK_INTPEND_HFCLKAUDIOSTARTED_Msk = 0x100
	// Bit HFCLKAUDIOSTARTED.
	CLOCK_INTPEND_HFCLKAUDIOSTARTED = 0x100
	// Read: Not pending
	CLOCK_INTPEND_HFCLKAUDIOSTARTED_NotPending = 0x0
	// Read: Pending
	CLOCK_INTPEND_HFCLKAUDIOSTARTED_Pending = 0x1
	// Position of HFCLK192MSTARTED field.
	CLOCK_INTPEND_HFCLK192MSTARTED_Pos = 0x9
	// Bit mask of HFCLK192MSTARTED field.
	CLOCK_INTPEND_HFCLK192MSTARTED_Msk = 0x200
	// Bit HFCLK192MSTARTED.
	CLOCK_INTPEND_HFCLK192MSTARTED = 0x200
	// Read: Not pending
	CLOCK_INTPEND_HFCLK192MSTARTED_NotPending = 0x0
	// Read: Pending
	CLOCK_INTPEND_HFCLK192MSTARTED_Pending = 0x1

	// HFCLKRUN: Status indicating that HFCLKSTART task has been triggered
	// Position of STATUS field.
	CLOCK_HFCLKRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_HFCLKRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_HFCLKRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_HFCLKRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_HFCLKRUN_STATUS_Triggered = 0x1

	// HFCLKSTAT: Status indicating which HFCLK128M/HFCLK64M source is running This register value in any CLOCK instance reflects status only due to configurations/actions in that CLOCK instance.
	// Position of SRC field.
	CLOCK_HFCLKSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_HFCLKSTAT_SRC_Msk = 0x1
	// Bit SRC.
	CLOCK_HFCLKSTAT_SRC = 0x1
	// Clock source: HFINT - 128 MHz on-chip oscillator
	CLOCK_HFCLKSTAT_SRC_HFINT = 0x0
	// Clock source: HFXO - 128 MHz clock derived from external 32 MHz crystal oscillator
	CLOCK_HFCLKSTAT_SRC_HFXO = 0x1
	// Position of ALWAYSRUNNING field.
	CLOCK_HFCLKSTAT_ALWAYSRUNNING_Pos = 0x4
	// Bit mask of ALWAYSRUNNING field.
	CLOCK_HFCLKSTAT_ALWAYSRUNNING_Msk = 0x10
	// Bit ALWAYSRUNNING.
	CLOCK_HFCLKSTAT_ALWAYSRUNNING = 0x10
	// Automatic clock control enabled
	CLOCK_HFCLKSTAT_ALWAYSRUNNING_NotRunning = 0x0
	// Oscillator is always running
	CLOCK_HFCLKSTAT_ALWAYSRUNNING_Running = 0x1
	// Position of STATE field.
	CLOCK_HFCLKSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_HFCLKSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_HFCLKSTAT_STATE = 0x10000
	// HFCLK not running
	CLOCK_HFCLKSTAT_STATE_NotRunning = 0x0
	// HFCLK running
	CLOCK_HFCLKSTAT_STATE_Running = 0x1

	// LFCLKRUN: Status indicating that LFCLKSTART task has been triggered
	// Position of STATUS field.
	CLOCK_LFCLKRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_LFCLKRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_LFCLKRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_LFCLKRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_LFCLKRUN_STATUS_Triggered = 0x1

	// LFCLKSTAT: Status indicating which LFCLK source is running This register value in any CLOCK instance reflects status only due to configurations/actions in that CLOCK instance.
	// Position of SRC field.
	CLOCK_LFCLKSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSTAT_SRC_Msk = 0x3
	// 32.768 kHz ultra-low power RC oscillator
	CLOCK_LFCLKSTAT_SRC_LFULP = 0x0
	// 32.768 kHz RC oscillator
	CLOCK_LFCLKSTAT_SRC_LFRC = 0x1
	// 32.768 kHz crystal oscillator
	CLOCK_LFCLKSTAT_SRC_LFXO = 0x2
	// 32.768 kHz synthesized from HFCLK
	CLOCK_LFCLKSTAT_SRC_LFSYNT = 0x3
	// Position of ALWAYSRUNNING field.
	CLOCK_LFCLKSTAT_ALWAYSRUNNING_Pos = 0x4
	// Bit mask of ALWAYSRUNNING field.
	CLOCK_LFCLKSTAT_ALWAYSRUNNING_Msk = 0x10
	// Bit ALWAYSRUNNING.
	CLOCK_LFCLKSTAT_ALWAYSRUNNING = 0x10
	// Automatic clock control enabled
	CLOCK_LFCLKSTAT_ALWAYSRUNNING_NotRunning = 0x0
	// Oscillator is always running
	CLOCK_LFCLKSTAT_ALWAYSRUNNING_Running = 0x1
	// Position of STATE field.
	CLOCK_LFCLKSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_LFCLKSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_LFCLKSTAT_STATE = 0x10000
	// LFCLK not running
	CLOCK_LFCLKSTAT_STATE_NotRunning = 0x0
	// LFCLK running
	CLOCK_LFCLKSTAT_STATE_Running = 0x1

	// LFCLKSRCCOPY: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
	// Position of SRC field.
	CLOCK_LFCLKSRCCOPY_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSRCCOPY_SRC_Msk = 0x3
	// 32.768 kHz ultra-low power RC oscillator
	CLOCK_LFCLKSRCCOPY_SRC_LFULP = 0x0
	// 32.768 kHz RC oscillator
	CLOCK_LFCLKSRCCOPY_SRC_LFRC = 0x1
	// 32.768 kHz crystal oscillator
	CLOCK_LFCLKSRCCOPY_SRC_LFXO = 0x2
	// 32.768 kHz synthesized from HFCLK
	CLOCK_LFCLKSRCCOPY_SRC_LFSYNT = 0x3

	// HFCLKAUDIORUN: Status indicating that HFCLKAUDIOSTART task has been triggered
	// Position of STATUS field.
	CLOCK_HFCLKAUDIORUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_HFCLKAUDIORUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_HFCLKAUDIORUN_STATUS = 0x1
	// Task not triggered
	CLOCK_HFCLKAUDIORUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_HFCLKAUDIORUN_STATUS_Triggered = 0x1

	// HFCLKAUDIOSTAT: Status indicating which HFCLKAUDIO source is running
	// Position of ALWAYSRUNNING field.
	CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Pos = 0x4
	// Bit mask of ALWAYSRUNNING field.
	CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Msk = 0x10
	// Bit ALWAYSRUNNING.
	CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING = 0x10
	// Automatic clock control enabled
	CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_NotRunning = 0x0
	// Oscillator is always running
	CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Running = 0x1
	// Position of STATE field.
	CLOCK_HFCLKAUDIOSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_HFCLKAUDIOSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_HFCLKAUDIOSTAT_STATE = 0x10000
	// HFCLKAUDIO not running
	CLOCK_HFCLKAUDIOSTAT_STATE_NotRunning = 0x0
	// HFCLKAUDIO running
	CLOCK_HFCLKAUDIOSTAT_STATE_Running = 0x1

	// HFCLK192MRUN: Status indicating that HFCLK192MSTART task has been triggered
	// Position of STATUS field.
	CLOCK_HFCLK192MRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_HFCLK192MRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_HFCLK192MRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_HFCLK192MRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_HFCLK192MRUN_STATUS_Triggered = 0x1

	// HFCLK192MSTAT: Status indicating which HFCLK192M source is running
	// Position of SRC field.
	CLOCK_HFCLK192MSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_HFCLK192MSTAT_SRC_Msk = 0x1
	// Bit SRC.
	CLOCK_HFCLK192MSTAT_SRC = 0x1
	// Clock source: HFINT - on-chip oscillator
	CLOCK_HFCLK192MSTAT_SRC_HFINT = 0x0
	// Clock source: HFXO - derived from external 32 MHz crystal oscillator
	CLOCK_HFCLK192MSTAT_SRC_HFXO = 0x1
	// Position of ALWAYSRUNNING field.
	CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Pos = 0x4
	// Bit mask of ALWAYSRUNNING field.
	CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Msk = 0x10
	// Bit ALWAYSRUNNING.
	CLOCK_HFCLK192MSTAT_ALWAYSRUNNING = 0x10
	// Automatic clock control enabled
	CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_NotRunning = 0x0
	// Oscillator is always running
	CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Running = 0x1
	// Position of STATE field.
	CLOCK_HFCLK192MSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_HFCLK192MSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_HFCLK192MSTAT_STATE = 0x10000
	// HFCLK192M not running
	CLOCK_HFCLK192MSTAT_STATE_NotRunning = 0x0
	// HFCLK192M running
	CLOCK_HFCLK192MSTAT_STATE_Running = 0x1

	// HFCLKSRC: Clock source for HFCLK128M/HFCLK64M
	// Position of SRC field.
	CLOCK_HFCLKSRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_HFCLKSRC_SRC_Msk = 0x1
	// Bit SRC.
	CLOCK_HFCLKSRC_SRC = 0x1
	// HFCLKSTART task starts HFINT oscillator
	CLOCK_HFCLKSRC_SRC_HFINT = 0x0
	// HFCLKSTART task starts HFXO oscillator
	CLOCK_HFCLKSRC_SRC_HFXO = 0x1

	// LFCLKSRC: Clock source for LFCLK
	// Position of SRC field.
	CLOCK_LFCLKSRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSRC_SRC_Msk = 0x3
	// 32.768 kHz ultra-low power RC oscillator
	CLOCK_LFCLKSRC_SRC_LFULP = 0x0
	// 32.768 kHz RC oscillator
	CLOCK_LFCLKSRC_SRC_LFRC = 0x1
	// 32.768 kHz crystal oscillator
	CLOCK_LFCLKSRC_SRC_LFXO = 0x2
	// 32.768 kHz synthesized from HFCLK
	CLOCK_LFCLKSRC_SRC_LFSYNT = 0x3

	// HFCLKCTRL: HFCLK128M frequency configuration
	// Position of HCLK field.
	CLOCK_HFCLKCTRL_HCLK_Pos = 0x0
	// Bit mask of HCLK field.
	CLOCK_HFCLKCTRL_HCLK_Msk = 0x3
	// Divide HFCLK by 1
	CLOCK_HFCLKCTRL_HCLK_Div1 = 0x0
	// Divide HFCLK by 2
	CLOCK_HFCLKCTRL_HCLK_Div2 = 0x1

	// HFCLKAUDIO.FREQUENCY: Audio PLL frequency in 11.176 MHz - 11.402 MHz or 12.165 MHz - 12.411 MHz frequency bands
	// Position of FREQUENCY field.
	CLOCK_HFCLKAUDIO_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	CLOCK_HFCLKAUDIO_FREQUENCY_FREQUENCY_Msk = 0xffff

	// HFCLKALWAYSRUN: Automatic or manual control of HFCLK128M/HFCLK64M
	// Position of ALWAYSRUN field.
	CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Pos = 0x0
	// Bit mask of ALWAYSRUN field.
	CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Msk = 0x1
	// Bit ALWAYSRUN.
	CLOCK_HFCLKALWAYSRUN_ALWAYSRUN = 0x1
	// Use automatic clock control
	CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Automatic = 0x0
	// Ensure clock is always running
	CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_AlwaysRun = 0x1

	// LFCLKALWAYSRUN: Automatic or manual control of LFCLK
	// Position of ALWAYSRUN field.
	CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Pos = 0x0
	// Bit mask of ALWAYSRUN field.
	CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk = 0x1
	// Bit ALWAYSRUN.
	CLOCK_LFCLKALWAYSRUN_ALWAYSRUN = 0x1
	// Use automatic clock control
	CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Automatic = 0x0
	// Ensure clock is always running
	CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_AlwaysRun = 0x1

	// HFCLKAUDIOALWAYSRUN: Automatic or manual control of HFCLKAUDIO
	// Position of ALWAYSRUN field.
	CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Pos = 0x0
	// Bit mask of ALWAYSRUN field.
	CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Msk = 0x1
	// Bit ALWAYSRUN.
	CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN = 0x1
	// Use automatic clock control
	CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Automatic = 0x0
	// Ensure clock is always running
	CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_AlwaysRun = 0x1

	// HFCLK192MSRC: Clock source for HFCLK192M
	// Position of SRC field.
	CLOCK_HFCLK192MSRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_HFCLK192MSRC_SRC_Msk = 0x1
	// Bit SRC.
	CLOCK_HFCLK192MSRC_SRC = 0x1
	// HFCLK192MSTART task starts HFINT oscillator
	CLOCK_HFCLK192MSRC_SRC_HFINT = 0x0
	// HFCLK192MSTART task starts HFXO oscillator
	CLOCK_HFCLK192MSRC_SRC_HFXO = 0x1

	// HFCLK192MALWAYSRUN: Automatic or manual control of HFCLK192M
	// Position of ALWAYSRUN field.
	CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Pos = 0x0
	// Bit mask of ALWAYSRUN field.
	CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Msk = 0x1
	// Bit ALWAYSRUN.
	CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN = 0x1
	// Use automatic clock control
	CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Automatic = 0x0
	// Ensure clock is always running
	CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_AlwaysRun = 0x1

	// HFCLK192MCTRL: HFCLK192M frequency configuration
	// Position of HCLK192M field.
	CLOCK_HFCLK192MCTRL_HCLK192M_Pos = 0x0
	// Bit mask of HCLK192M field.
	CLOCK_HFCLK192MCTRL_HCLK192M_Msk = 0x3
	// Divide HFCLK192M by 1
	CLOCK_HFCLK192MCTRL_HCLK192M_Div1 = 0x0
	// Divide HFCLK192M by 2
	CLOCK_HFCLK192MCTRL_HCLK192M_Div2 = 0x1
	// Divide HFCLK192M by 4
	CLOCK_HFCLK192MCTRL_HCLK192M_Div4 = 0x2
)

// Constants for POWER_NS: Power control 0
const (
	// TASKS_CONSTLAT: Enable Constant Latency mode
	// Position of TASKS_CONSTLAT field.
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Pos = 0x0
	// Bit mask of TASKS_CONSTLAT field.
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Msk = 0x1
	// Bit TASKS_CONSTLAT.
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT = 0x1
	// Trigger task
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Trigger = 0x1

	// TASKS_LOWPWR: Enable Low-Power mode (variable latency)
	// Position of TASKS_LOWPWR field.
	POWER_TASKS_LOWPWR_TASKS_LOWPWR_Pos = 0x0
	// Bit mask of TASKS_LOWPWR field.
	POWER_TASKS_LOWPWR_TASKS_LOWPWR_Msk = 0x1
	// Bit TASKS_LOWPWR.
	POWER_TASKS_LOWPWR_TASKS_LOWPWR = 0x1
	// Trigger task
	POWER_TASKS_LOWPWR_TASKS_LOWPWR_Trigger = 0x1

	// SUBSCRIBE_CONSTLAT: Subscribe configuration for task CONSTLAT
	// Position of CHIDX field.
	POWER_SUBSCRIBE_CONSTLAT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	POWER_SUBSCRIBE_CONSTLAT_CHIDX_Msk = 0xff
	// Position of EN field.
	POWER_SUBSCRIBE_CONSTLAT_EN_Pos = 0x1f
	// Bit mask of EN field.
	POWER_SUBSCRIBE_CONSTLAT_EN_Msk = 0x80000000
	// Bit EN.
	POWER_SUBSCRIBE_CONSTLAT_EN = 0x80000000
	// Disable subscription
	POWER_SUBSCRIBE_CONSTLAT_EN_Disabled = 0x0
	// Enable subscription
	POWER_SUBSCRIBE_CONSTLAT_EN_Enabled = 0x1

	// SUBSCRIBE_LOWPWR: Subscribe configuration for task LOWPWR
	// Position of CHIDX field.
	POWER_SUBSCRIBE_LOWPWR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	POWER_SUBSCRIBE_LOWPWR_CHIDX_Msk = 0xff
	// Position of EN field.
	POWER_SUBSCRIBE_LOWPWR_EN_Pos = 0x1f
	// Bit mask of EN field.
	POWER_SUBSCRIBE_LOWPWR_EN_Msk = 0x80000000
	// Bit EN.
	POWER_SUBSCRIBE_LOWPWR_EN = 0x80000000
	// Disable subscription
	POWER_SUBSCRIBE_LOWPWR_EN_Disabled = 0x0
	// Enable subscription
	POWER_SUBSCRIBE_LOWPWR_EN_Enabled = 0x1

	// EVENTS_POFWARN: Power failure warning
	// Position of EVENTS_POFWARN field.
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_Pos = 0x0
	// Bit mask of EVENTS_POFWARN field.
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_Msk = 0x1
	// Bit EVENTS_POFWARN.
	POWER_EVENTS_POFWARN_EVENTS_POFWARN = 0x1
	// Event not generated
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_Generated = 0x1

	// EVENTS_SLEEPENTER: CPU entered WFI/WFE sleep
	// Position of EVENTS_SLEEPENTER field.
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos = 0x0
	// Bit mask of EVENTS_SLEEPENTER field.
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Msk = 0x1
	// Bit EVENTS_SLEEPENTER.
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER = 0x1
	// Event not generated
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Generated = 0x1

	// EVENTS_SLEEPEXIT: CPU exited WFI/WFE sleep
	// Position of EVENTS_SLEEPEXIT field.
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos = 0x0
	// Bit mask of EVENTS_SLEEPEXIT field.
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Msk = 0x1
	// Bit EVENTS_SLEEPEXIT.
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT = 0x1
	// Event not generated
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Generated = 0x1

	// PUBLISH_POFWARN: Publish configuration for event POFWARN
	// Position of CHIDX field.
	POWER_PUBLISH_POFWARN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	POWER_PUBLISH_POFWARN_CHIDX_Msk = 0xff
	// Position of EN field.
	POWER_PUBLISH_POFWARN_EN_Pos = 0x1f
	// Bit mask of EN field.
	POWER_PUBLISH_POFWARN_EN_Msk = 0x80000000
	// Bit EN.
	POWER_PUBLISH_POFWARN_EN = 0x80000000
	// Disable publishing
	POWER_PUBLISH_POFWARN_EN_Disabled = 0x0
	// Enable publishing
	POWER_PUBLISH_POFWARN_EN_Enabled = 0x1

	// PUBLISH_SLEEPENTER: Publish configuration for event SLEEPENTER
	// Position of CHIDX field.
	POWER_PUBLISH_SLEEPENTER_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	POWER_PUBLISH_SLEEPENTER_CHIDX_Msk = 0xff
	// Position of EN field.
	POWER_PUBLISH_SLEEPENTER_EN_Pos = 0x1f
	// Bit mask of EN field.
	POWER_PUBLISH_SLEEPENTER_EN_Msk = 0x80000000
	// Bit EN.
	POWER_PUBLISH_SLEEPENTER_EN = 0x80000000
	// Disable publishing
	POWER_PUBLISH_SLEEPENTER_EN_Disabled = 0x0
	// Enable publishing
	POWER_PUBLISH_SLEEPENTER_EN_Enabled = 0x1

	// PUBLISH_SLEEPEXIT: Publish configuration for event SLEEPEXIT
	// Position of CHIDX field.
	POWER_PUBLISH_SLEEPEXIT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	POWER_PUBLISH_SLEEPEXIT_CHIDX_Msk = 0xff
	// Position of EN field.
	POWER_PUBLISH_SLEEPEXIT_EN_Pos = 0x1f
	// Bit mask of EN field.
	POWER_PUBLISH_SLEEPEXIT_EN_Msk = 0x80000000
	// Bit EN.
	POWER_PUBLISH_SLEEPEXIT_EN = 0x80000000
	// Disable publishing
	POWER_PUBLISH_SLEEPEXIT_EN_Disabled = 0x0
	// Enable publishing
	POWER_PUBLISH_SLEEPEXIT_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of POFWARN field.
	POWER_INTEN_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTEN_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTEN_POFWARN = 0x4
	// Disable
	POWER_INTEN_POFWARN_Disabled = 0x0
	// Enable
	POWER_INTEN_POFWARN_Enabled = 0x1
	// Position of SLEEPENTER field.
	POWER_INTEN_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTEN_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTEN_SLEEPENTER = 0x20
	// Disable
	POWER_INTEN_SLEEPENTER_Disabled = 0x0
	// Enable
	POWER_INTEN_SLEEPENTER_Enabled = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTEN_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTEN_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTEN_SLEEPEXIT = 0x40
	// Disable
	POWER_INTEN_SLEEPEXIT_Disabled = 0x0
	// Enable
	POWER_INTEN_SLEEPEXIT_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of POFWARN field.
	POWER_INTENSET_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTENSET_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTENSET_POFWARN = 0x4
	// Read: Disabled
	POWER_INTENSET_POFWARN_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_POFWARN_Enabled = 0x1
	// Enable
	POWER_INTENSET_POFWARN_Set = 0x1
	// Position of SLEEPENTER field.
	POWER_INTENSET_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTENSET_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTENSET_SLEEPENTER = 0x20
	// Read: Disabled
	POWER_INTENSET_SLEEPENTER_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_SLEEPENTER_Enabled = 0x1
	// Enable
	POWER_INTENSET_SLEEPENTER_Set = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTENSET_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTENSET_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTENSET_SLEEPEXIT = 0x40
	// Read: Disabled
	POWER_INTENSET_SLEEPEXIT_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_SLEEPEXIT_Enabled = 0x1
	// Enable
	POWER_INTENSET_SLEEPEXIT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of POFWARN field.
	POWER_INTENCLR_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTENCLR_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTENCLR_POFWARN = 0x4
	// Read: Disabled
	POWER_INTENCLR_POFWARN_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_POFWARN_Enabled = 0x1
	// Disable
	POWER_INTENCLR_POFWARN_Clear = 0x1
	// Position of SLEEPENTER field.
	POWER_INTENCLR_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTENCLR_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTENCLR_SLEEPENTER = 0x20
	// Read: Disabled
	POWER_INTENCLR_SLEEPENTER_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_SLEEPENTER_Enabled = 0x1
	// Disable
	POWER_INTENCLR_SLEEPENTER_Clear = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTENCLR_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTENCLR_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTENCLR_SLEEPEXIT = 0x40
	// Read: Disabled
	POWER_INTENCLR_SLEEPEXIT_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_SLEEPEXIT_Enabled = 0x1
	// Disable
	POWER_INTENCLR_SLEEPEXIT_Clear = 0x1

	// GPREGRET: Description collection: General purpose retention register
	// Position of GPREGRET field.
	POWER_GPREGRET_GPREGRET_Pos = 0x0
	// Bit mask of GPREGRET field.
	POWER_GPREGRET_GPREGRET_Msk = 0xff
)

// Constants for RESET_NS: Reset control 0
const (
	// RESETREAS: Reset reason
	// Position of RESETPIN field.
	RESET_RESETREAS_RESETPIN_Pos = 0x0
	// Bit mask of RESETPIN field.
	RESET_RESETREAS_RESETPIN_Msk = 0x1
	// Bit RESETPIN.
	RESET_RESETREAS_RESETPIN = 0x1
	// Not detected
	RESET_RESETREAS_RESETPIN_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_RESETPIN_Detected = 0x1
	// Position of DOG0 field.
	RESET_RESETREAS_DOG0_Pos = 0x1
	// Bit mask of DOG0 field.
	RESET_RESETREAS_DOG0_Msk = 0x2
	// Bit DOG0.
	RESET_RESETREAS_DOG0 = 0x2
	// Not detected
	RESET_RESETREAS_DOG0_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_DOG0_Detected = 0x1
	// Position of CTRLAP field.
	RESET_RESETREAS_CTRLAP_Pos = 0x2
	// Bit mask of CTRLAP field.
	RESET_RESETREAS_CTRLAP_Msk = 0x4
	// Bit CTRLAP.
	RESET_RESETREAS_CTRLAP = 0x4
	// Not detected
	RESET_RESETREAS_CTRLAP_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_CTRLAP_Detected = 0x1
	// Position of SREQ field.
	RESET_RESETREAS_SREQ_Pos = 0x3
	// Bit mask of SREQ field.
	RESET_RESETREAS_SREQ_Msk = 0x8
	// Bit SREQ.
	RESET_RESETREAS_SREQ = 0x8
	// Not detected
	RESET_RESETREAS_SREQ_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_SREQ_Detected = 0x1
	// Position of LOCKUP field.
	RESET_RESETREAS_LOCKUP_Pos = 0x4
	// Bit mask of LOCKUP field.
	RESET_RESETREAS_LOCKUP_Msk = 0x10
	// Bit LOCKUP.
	RESET_RESETREAS_LOCKUP = 0x10
	// Not detected
	RESET_RESETREAS_LOCKUP_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_LOCKUP_Detected = 0x1
	// Position of OFF field.
	RESET_RESETREAS_OFF_Pos = 0x5
	// Bit mask of OFF field.
	RESET_RESETREAS_OFF_Msk = 0x20
	// Bit OFF.
	RESET_RESETREAS_OFF = 0x20
	// Not detected
	RESET_RESETREAS_OFF_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_OFF_Detected = 0x1
	// Position of LPCOMP field.
	RESET_RESETREAS_LPCOMP_Pos = 0x6
	// Bit mask of LPCOMP field.
	RESET_RESETREAS_LPCOMP_Msk = 0x40
	// Bit LPCOMP.
	RESET_RESETREAS_LPCOMP = 0x40
	// Not detected
	RESET_RESETREAS_LPCOMP_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_LPCOMP_Detected = 0x1
	// Position of DIF field.
	RESET_RESETREAS_DIF_Pos = 0x7
	// Bit mask of DIF field.
	RESET_RESETREAS_DIF_Msk = 0x80
	// Bit DIF.
	RESET_RESETREAS_DIF = 0x80
	// Not detected
	RESET_RESETREAS_DIF_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_DIF_Detected = 0x1
	// Position of NFC field.
	RESET_RESETREAS_NFC_Pos = 0x18
	// Bit mask of NFC field.
	RESET_RESETREAS_NFC_Msk = 0x1000000
	// Bit NFC.
	RESET_RESETREAS_NFC = 0x1000000
	// Not detected
	RESET_RESETREAS_NFC_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_NFC_Detected = 0x1
	// Position of DOG1 field.
	RESET_RESETREAS_DOG1_Pos = 0x19
	// Bit mask of DOG1 field.
	RESET_RESETREAS_DOG1_Msk = 0x2000000
	// Bit DOG1.
	RESET_RESETREAS_DOG1 = 0x2000000
	// Not detected
	RESET_RESETREAS_DOG1_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_DOG1_Detected = 0x1
	// Position of VBUS field.
	RESET_RESETREAS_VBUS_Pos = 0x1a
	// Bit mask of VBUS field.
	RESET_RESETREAS_VBUS_Msk = 0x4000000
	// Bit VBUS.
	RESET_RESETREAS_VBUS = 0x4000000
	// Not detected
	RESET_RESETREAS_VBUS_NotDetected = 0x0
	// Detected
	RESET_RESETREAS_VBUS_Detected = 0x1

	// NETWORK.FORCEOFF: Force network core off
	// Position of FORCEOFF field.
	RESET_NETWORK_FORCEOFF_FORCEOFF_Pos = 0x0
	// Bit mask of FORCEOFF field.
	RESET_NETWORK_FORCEOFF_FORCEOFF_Msk = 0x1
	// Bit FORCEOFF.
	RESET_NETWORK_FORCEOFF_FORCEOFF = 0x1
	// Release Force-OFF
	RESET_NETWORK_FORCEOFF_FORCEOFF_Release = 0x0
	// Hold Force-OFF
	RESET_NETWORK_FORCEOFF_FORCEOFF_Hold = 0x1
)

// Constants for CTRLAP_NS: Control access port 0
const (
	// MAILBOX.RXDATA: Data sent from the debugger to the CPU.
	// Position of RXDATA field.
	CTRLAPPERI_MAILBOX_RXDATA_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	CTRLAPPERI_MAILBOX_RXDATA_RXDATA_Msk = 0xffffffff

	// MAILBOX.RXSTATUS: This register shows a status that indicates if data sent from the debugger to the CPU has been read.
	// Position of RXSTATUS field.
	CTRLAPPERI_MAILBOX_RXSTATUS_RXSTATUS_Pos = 0x0
	// Bit mask of RXSTATUS field.
	CTRLAPPERI_MAILBOX_RXSTATUS_RXSTATUS_Msk = 0x1
	// Bit RXSTATUS.
	CTRLAPPERI_MAILBOX_RXSTATUS_RXSTATUS = 0x1
	// No data pending in register RXDATA
	CTRLAPPERI_MAILBOX_RXSTATUS_RXSTATUS_NoDataPending = 0x0
	// Data pending in register RXDATA
	CTRLAPPERI_MAILBOX_RXSTATUS_RXSTATUS_DataPending = 0x1

	// MAILBOX.TXDATA: Data sent from the CPU to the debugger.
	// Position of TXDATA field.
	CTRLAPPERI_MAILBOX_TXDATA_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	CTRLAPPERI_MAILBOX_TXDATA_TXDATA_Msk = 0xffffffff

	// MAILBOX.TXSTATUS: This register shows a status that indicates if the data sent from the CPU to the debugger has been read.
	// Position of TXSTATUS field.
	CTRLAPPERI_MAILBOX_TXSTATUS_TXSTATUS_Pos = 0x0
	// Bit mask of TXSTATUS field.
	CTRLAPPERI_MAILBOX_TXSTATUS_TXSTATUS_Msk = 0x1
	// Bit TXSTATUS.
	CTRLAPPERI_MAILBOX_TXSTATUS_TXSTATUS = 0x1
	// No data pending in register TXDATA
	CTRLAPPERI_MAILBOX_TXSTATUS_TXSTATUS_NoDataPending = 0x0
	// Data pending in register TXDATA
	CTRLAPPERI_MAILBOX_TXSTATUS_TXSTATUS_DataPending = 0x1

	// ERASEPROTECT.LOCK: This register locks the ERASEPROTECT.DISABLE register from being written until next reset.
	// Position of LOCK field.
	CTRLAPPERI_ERASEPROTECT_LOCK_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	CTRLAPPERI_ERASEPROTECT_LOCK_LOCK_Msk = 0x1
	// Bit LOCK.
	CTRLAPPERI_ERASEPROTECT_LOCK_LOCK = 0x1
	// Register ERASEPROTECT.DISABLE is writeable
	CTRLAPPERI_ERASEPROTECT_LOCK_LOCK_Unlocked = 0x0
	// Register ERASEPROTECT.DISABLE is read-only
	CTRLAPPERI_ERASEPROTECT_LOCK_LOCK_Locked = 0x1

	// ERASEPROTECT.DISABLE: This register disables the ERASEPROTECT register and performs an ERASEALL operation.
	// Position of KEY field.
	CTRLAPPERI_ERASEPROTECT_DISABLE_KEY_Pos = 0x0
	// Bit mask of KEY field.
	CTRLAPPERI_ERASEPROTECT_DISABLE_KEY_Msk = 0xffffffff

	// APPROTECT.LOCK: This register locks the APPROTECT.DISABLE register from being written to until next reset.
	// Position of LOCK field.
	CTRLAPPERI_APPROTECT_LOCK_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	CTRLAPPERI_APPROTECT_LOCK_LOCK_Msk = 0x1
	// Bit LOCK.
	CTRLAPPERI_APPROTECT_LOCK_LOCK = 0x1
	// Register APPROTECT.DISABLE is writeable
	CTRLAPPERI_APPROTECT_LOCK_LOCK_Unlocked = 0x0
	// Register APPROTECT.DISABLE is read-only
	CTRLAPPERI_APPROTECT_LOCK_LOCK_Locked = 0x1

	// APPROTECT.DISABLE: This register disables the APPROTECT register and enables debug access to non-secure mode.
	// Position of KEY field.
	CTRLAPPERI_APPROTECT_DISABLE_KEY_Pos = 0x0
	// Bit mask of KEY field.
	CTRLAPPERI_APPROTECT_DISABLE_KEY_Msk = 0xffffffff

	// SECUREAPPROTECT.LOCK: This register locks the SECUREAPPROTECT.DISABLE register from being written until next reset.
	// Position of LOCK field.
	CTRLAPPERI_SECUREAPPROTECT_LOCK_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	CTRLAPPERI_SECUREAPPROTECT_LOCK_LOCK_Msk = 0x1
	// Bit LOCK.
	CTRLAPPERI_SECUREAPPROTECT_LOCK_LOCK = 0x1
	// Register SECUREAPPROTECT.DISABLE is writeable
	CTRLAPPERI_SECUREAPPROTECT_LOCK_LOCK_Unlocked = 0x0
	// Register SECUREAPPROTECT.DISABLE is read-only
	CTRLAPPERI_SECUREAPPROTECT_LOCK_LOCK_Locked = 0x1

	// SECUREAPPROTECT.DISABLE: This register disables the SECUREAPPROTECT register and enables debug access to secure mode.
	// Position of KEY field.
	CTRLAPPERI_SECUREAPPROTECT_DISABLE_KEY_Pos = 0x0
	// Bit mask of KEY field.
	CTRLAPPERI_SECUREAPPROTECT_DISABLE_KEY_Msk = 0xffffffff

	// STATUS: Status bits for CTRL-AP peripheral
	// Position of APPROTECT field.
	CTRLAPPERI_STATUS_APPROTECT_Pos = 0x0
	// Bit mask of APPROTECT field.
	CTRLAPPERI_STATUS_APPROTECT_Msk = 0x1
	// Bit APPROTECT.
	CTRLAPPERI_STATUS_APPROTECT = 0x1
	// Non-secure mode access port protection is currently disabled
	CTRLAPPERI_STATUS_APPROTECT_Disabled = 0x0
	// Non-secure mode access port protection is currently enabled
	CTRLAPPERI_STATUS_APPROTECT_Enabled = 0x1
	// Position of SECUREAPPROTECT field.
	CTRLAPPERI_STATUS_SECUREAPPROTECT_Pos = 0x1
	// Bit mask of SECUREAPPROTECT field.
	CTRLAPPERI_STATUS_SECUREAPPROTECT_Msk = 0x2
	// Bit SECUREAPPROTECT.
	CTRLAPPERI_STATUS_SECUREAPPROTECT = 0x2
	// Secure mode access port protection is currently disabled
	CTRLAPPERI_STATUS_SECUREAPPROTECT_Disabled = 0x0
	// Secure mode access port protection is currently enabled
	CTRLAPPERI_STATUS_SECUREAPPROTECT_Enabled = 0x1
	// Position of DBGIFACEMODE field.
	CTRLAPPERI_STATUS_DBGIFACEMODE_Pos = 0x2
	// Bit mask of DBGIFACEMODE field.
	CTRLAPPERI_STATUS_DBGIFACEMODE_Msk = 0x4
	// Bit DBGIFACEMODE.
	CTRLAPPERI_STATUS_DBGIFACEMODE = 0x4
	// No debugger attached
	CTRLAPPERI_STATUS_DBGIFACEMODE_Disabled = 0x0
	// Debugger is attached and device is in debug interface mode
	CTRLAPPERI_STATUS_DBGIFACEMODE_Enabled = 0x1
)

// Constants for SPIM0_NS: Serial Peripheral Interface Master with EasyDMA 0
const (
	// TASKS_START: Start SPI transaction
	// Position of TASKS_START field.
	SPIM_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	SPIM_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	SPIM_TASKS_START_TASKS_START = 0x1
	// Trigger task
	SPIM_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop SPI transaction
	// Position of TASKS_STOP field.
	SPIM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	SPIM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	SPIM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	SPIM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend SPI transaction
	// Position of TASKS_SUSPEND field.
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume SPI transaction
	// Position of TASKS_RESUME field.
	SPIM_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	SPIM_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	SPIM_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	SPIM_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	SPIM_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	SPIM_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	SPIM_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	SPIM_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	SPIM_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	SPIM_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_SUSPEND: Subscribe configuration for task SUSPEND
	// Position of CHIDX field.
	SPIM_SUBSCRIBE_SUSPEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_SUBSCRIBE_SUSPEND_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_SUBSCRIBE_SUSPEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_SUBSCRIBE_SUSPEND_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_SUBSCRIBE_SUSPEND_EN = 0x80000000
	// Disable subscription
	SPIM_SUBSCRIBE_SUSPEND_EN_Disabled = 0x0
	// Enable subscription
	SPIM_SUBSCRIBE_SUSPEND_EN_Enabled = 0x1

	// SUBSCRIBE_RESUME: Subscribe configuration for task RESUME
	// Position of CHIDX field.
	SPIM_SUBSCRIBE_RESUME_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_SUBSCRIBE_RESUME_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_SUBSCRIBE_RESUME_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_SUBSCRIBE_RESUME_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_SUBSCRIBE_RESUME_EN = 0x80000000
	// Disable subscription
	SPIM_SUBSCRIBE_RESUME_EN_Disabled = 0x0
	// Enable subscription
	SPIM_SUBSCRIBE_RESUME_EN_Enabled = 0x1

	// EVENTS_STOPPED: SPI transaction has stopped
	// Position of EVENTS_STOPPED field.
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_ENDRX: End of RXD buffer reached
	// Position of EVENTS_ENDRX field.
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_END: End of RXD buffer and TXD buffer reached
	// Position of EVENTS_END field.
	SPIM_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	SPIM_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	SPIM_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	SPIM_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_ENDTX: End of TXD buffer reached
	// Position of EVENTS_ENDTX field.
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Pos = 0x0
	// Bit mask of EVENTS_ENDTX field.
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Msk = 0x1
	// Bit EVENTS_ENDTX.
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX = 0x1
	// Event not generated
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Generated = 0x1

	// EVENTS_STARTED: Transaction started
	// Position of EVENTS_STARTED field.
	SPIM_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	SPIM_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	SPIM_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	SPIM_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	SPIM_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	SPIM_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	SPIM_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_ENDRX: Publish configuration for event ENDRX
	// Position of CHIDX field.
	SPIM_PUBLISH_ENDRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_PUBLISH_ENDRX_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_PUBLISH_ENDRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_PUBLISH_ENDRX_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_PUBLISH_ENDRX_EN = 0x80000000
	// Disable publishing
	SPIM_PUBLISH_ENDRX_EN_Disabled = 0x0
	// Enable publishing
	SPIM_PUBLISH_ENDRX_EN_Enabled = 0x1

	// PUBLISH_END: Publish configuration for event END
	// Position of CHIDX field.
	SPIM_PUBLISH_END_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_PUBLISH_END_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_PUBLISH_END_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_PUBLISH_END_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_PUBLISH_END_EN = 0x80000000
	// Disable publishing
	SPIM_PUBLISH_END_EN_Disabled = 0x0
	// Enable publishing
	SPIM_PUBLISH_END_EN_Enabled = 0x1

	// PUBLISH_ENDTX: Publish configuration for event ENDTX
	// Position of CHIDX field.
	SPIM_PUBLISH_ENDTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_PUBLISH_ENDTX_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_PUBLISH_ENDTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_PUBLISH_ENDTX_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_PUBLISH_ENDTX_EN = 0x80000000
	// Disable publishing
	SPIM_PUBLISH_ENDTX_EN_Disabled = 0x0
	// Enable publishing
	SPIM_PUBLISH_ENDTX_EN_Enabled = 0x1

	// PUBLISH_STARTED: Publish configuration for event STARTED
	// Position of CHIDX field.
	SPIM_PUBLISH_STARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIM_PUBLISH_STARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIM_PUBLISH_STARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIM_PUBLISH_STARTED_EN_Msk = 0x80000000
	// Bit EN.
	SPIM_PUBLISH_STARTED_EN = 0x80000000
	// Disable publishing
	SPIM_PUBLISH_STARTED_EN_Disabled = 0x0
	// Enable publishing
	SPIM_PUBLISH_STARTED_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of END_START field.
	SPIM_SHORTS_END_START_Pos = 0x11
	// Bit mask of END_START field.
	SPIM_SHORTS_END_START_Msk = 0x20000
	// Bit END_START.
	SPIM_SHORTS_END_START = 0x20000
	// Disable shortcut
	SPIM_SHORTS_END_START_Disabled = 0x0
	// Enable shortcut
	SPIM_SHORTS_END_START_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	SPIM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	SPIM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	SPIM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	SPIM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	SPIM_INTENSET_STOPPED_Set = 0x1
	// Position of ENDRX field.
	SPIM_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIM_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIM_INTENSET_ENDRX = 0x10
	// Read: Disabled
	SPIM_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	SPIM_INTENSET_ENDRX_Set = 0x1
	// Position of END field.
	SPIM_INTENSET_END_Pos = 0x6
	// Bit mask of END field.
	SPIM_INTENSET_END_Msk = 0x40
	// Bit END.
	SPIM_INTENSET_END = 0x40
	// Read: Disabled
	SPIM_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_END_Enabled = 0x1
	// Enable
	SPIM_INTENSET_END_Set = 0x1
	// Position of ENDTX field.
	SPIM_INTENSET_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	SPIM_INTENSET_ENDTX_Msk = 0x100
	// Bit ENDTX.
	SPIM_INTENSET_ENDTX = 0x100
	// Read: Disabled
	SPIM_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	SPIM_INTENSET_ENDTX_Set = 0x1
	// Position of STARTED field.
	SPIM_INTENSET_STARTED_Pos = 0x13
	// Bit mask of STARTED field.
	SPIM_INTENSET_STARTED_Msk = 0x80000
	// Bit STARTED.
	SPIM_INTENSET_STARTED = 0x80000
	// Read: Disabled
	SPIM_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_STARTED_Enabled = 0x1
	// Enable
	SPIM_INTENSET_STARTED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	SPIM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	SPIM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	SPIM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	SPIM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_STOPPED_Clear = 0x1
	// Position of ENDRX field.
	SPIM_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIM_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIM_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	SPIM_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_ENDRX_Clear = 0x1
	// Position of END field.
	SPIM_INTENCLR_END_Pos = 0x6
	// Bit mask of END field.
	SPIM_INTENCLR_END_Msk = 0x40
	// Bit END.
	SPIM_INTENCLR_END = 0x40
	// Read: Disabled
	SPIM_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_END_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_END_Clear = 0x1
	// Position of ENDTX field.
	SPIM_INTENCLR_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	SPIM_INTENCLR_ENDTX_Msk = 0x100
	// Bit ENDTX.
	SPIM_INTENCLR_ENDTX = 0x100
	// Read: Disabled
	SPIM_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_ENDTX_Clear = 0x1
	// Position of STARTED field.
	SPIM_INTENCLR_STARTED_Pos = 0x13
	// Bit mask of STARTED field.
	SPIM_INTENCLR_STARTED_Msk = 0x80000
	// Bit STARTED.
	SPIM_INTENCLR_STARTED = 0x80000
	// Read: Disabled
	SPIM_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_STARTED_Clear = 0x1

	// STALLSTAT: Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU.
	// Position of TX field.
	SPIM_STALLSTAT_TX_Pos = 0x0
	// Bit mask of TX field.
	SPIM_STALLSTAT_TX_Msk = 0x1
	// Bit TX.
	SPIM_STALLSTAT_TX = 0x1
	// No stall
	SPIM_STALLSTAT_TX_NOSTALL = 0x0
	// A stall has occurred
	SPIM_STALLSTAT_TX_STALL = 0x1
	// Position of RX field.
	SPIM_STALLSTAT_RX_Pos = 0x1
	// Bit mask of RX field.
	SPIM_STALLSTAT_RX_Msk = 0x2
	// Bit RX.
	SPIM_STALLSTAT_RX = 0x2
	// No stall
	SPIM_STALLSTAT_RX_NOSTALL = 0x0
	// A stall has occurred
	SPIM_STALLSTAT_RX_STALL = 0x1

	// ENABLE: Enable SPIM
	// Position of ENABLE field.
	SPIM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPIM_ENABLE_ENABLE_Msk = 0xf
	// Disable SPIM
	SPIM_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPIM
	SPIM_ENABLE_ENABLE_Enabled = 0x7

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPIM_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_SCK_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIM_PSEL_SCK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIM_PSEL_SCK_PORT_Msk = 0x20
	// Bit PORT.
	SPIM_PSEL_SCK_PORT = 0x20
	// Position of CONNECT field.
	SPIM_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPIM_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIM_PSEL_MOSI_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIM_PSEL_MOSI_PORT_Msk = 0x20
	// Bit PORT.
	SPIM_PSEL_MOSI_PORT = 0x20
	// Position of CONNECT field.
	SPIM_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPIM_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_MISO_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIM_PSEL_MISO_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIM_PSEL_MISO_PORT_Msk = 0x20
	// Bit PORT.
	SPIM_PSEL_MISO_PORT = 0x20
	// Position of CONNECT field.
	SPIM_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_MISO_CONNECT_Connected = 0x0

	// PSEL.CSN: Pin select for CSN
	// Position of PIN field.
	SPIM_PSEL_CSN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_CSN_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIM_PSEL_CSN_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIM_PSEL_CSN_PORT_Msk = 0x20
	// Bit PORT.
	SPIM_PSEL_CSN_PORT = 0x20
	// Position of CONNECT field.
	SPIM_PSEL_CSN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_CSN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_CSN_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_CSN_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_CSN_CONNECT_Connected = 0x0

	// FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	SPIM_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	SPIM_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 125 kbps
	SPIM_FREQUENCY_FREQUENCY_K125 = 0x2000000
	// 250 kbps
	SPIM_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 500 kbps
	SPIM_FREQUENCY_FREQUENCY_K500 = 0x8000000
	// 1 Mbps
	SPIM_FREQUENCY_FREQUENCY_M1 = 0x10000000
	// 2 Mbps
	SPIM_FREQUENCY_FREQUENCY_M2 = 0x20000000
	// 4 Mbps
	SPIM_FREQUENCY_FREQUENCY_M4 = 0x40000000
	// 8 Mbps
	SPIM_FREQUENCY_FREQUENCY_M8 = 0x80000000
	// 16 Mbps
	SPIM_FREQUENCY_FREQUENCY_M16 = 0xa000000
	// 32 Mbps
	SPIM_FREQUENCY_FREQUENCY_M32 = 0x14000000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	SPIM_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIM_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	SPIM_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIM_RXD_MAXCNT_MAXCNT_Msk = 0xffff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	SPIM_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIM_RXD_AMOUNT_AMOUNT_Msk = 0xffff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIM_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIM_RXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIM_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIM_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: Data pointer
	// Position of PTR field.
	SPIM_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIM_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Number of bytes in transmit buffer
	// Position of MAXCNT field.
	SPIM_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIM_TXD_MAXCNT_MAXCNT_Msk = 0xffff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	SPIM_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIM_TXD_AMOUNT_AMOUNT_Msk = 0xffff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIM_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIM_TXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIM_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIM_TXD_LIST_LIST_ArrayList = 0x1

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPIM_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPIM_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPIM_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPIM_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPIM_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPIM_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPIM_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPIM_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPIM_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPIM_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPIM_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPIM_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPIM_CONFIG_CPOL = 0x4
	// Active high
	SPIM_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPIM_CONFIG_CPOL_ActiveLow = 0x1

	// IFTIMING.RXDELAY: Sample delay for input serial data on MISO
	// Position of RXDELAY field.
	SPIM_IFTIMING_RXDELAY_RXDELAY_Pos = 0x0
	// Bit mask of RXDELAY field.
	SPIM_IFTIMING_RXDELAY_RXDELAY_Msk = 0x7

	// IFTIMING.CSNDUR: Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions
	// Position of CSNDUR field.
	SPIM_IFTIMING_CSNDUR_CSNDUR_Pos = 0x0
	// Bit mask of CSNDUR field.
	SPIM_IFTIMING_CSNDUR_CSNDUR_Msk = 0xff

	// CSNPOL: Polarity of CSN output
	// Position of CSNPOL field.
	SPIM_CSNPOL_CSNPOL_Pos = 0x0
	// Bit mask of CSNPOL field.
	SPIM_CSNPOL_CSNPOL_Msk = 0x1
	// Bit CSNPOL.
	SPIM_CSNPOL_CSNPOL = 0x1
	// Active low (idle state high)
	SPIM_CSNPOL_CSNPOL_LOW = 0x0
	// Active high (idle state low)
	SPIM_CSNPOL_CSNPOL_HIGH = 0x1

	// PSELDCX: Pin select for DCX signal
	// Position of PIN field.
	SPIM_PSELDCX_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSELDCX_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIM_PSELDCX_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIM_PSELDCX_PORT_Msk = 0x20
	// Bit PORT.
	SPIM_PSELDCX_PORT = 0x20
	// Position of CONNECT field.
	SPIM_PSELDCX_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSELDCX_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSELDCX_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSELDCX_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSELDCX_CONNECT_Connected = 0x0

	// DCXCNT: DCX configuration
	// Position of DCXCNT field.
	SPIM_DCXCNT_DCXCNT_Pos = 0x0
	// Bit mask of DCXCNT field.
	SPIM_DCXCNT_DCXCNT_Msk = 0xf

	// ORC: Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
	// Position of ORC field.
	SPIM_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	SPIM_ORC_ORC_Msk = 0xff
)

// Constants for SPIS0_NS: SPI Slave 0
const (
	// TASKS_ACQUIRE: Acquire SPI semaphore
	// Position of TASKS_ACQUIRE field.
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Pos = 0x0
	// Bit mask of TASKS_ACQUIRE field.
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Msk = 0x1
	// Bit TASKS_ACQUIRE.
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE = 0x1
	// Trigger task
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Trigger = 0x1

	// TASKS_RELEASE: Release SPI semaphore, enabling the SPI slave to acquire it
	// Position of TASKS_RELEASE field.
	SPIS_TASKS_RELEASE_TASKS_RELEASE_Pos = 0x0
	// Bit mask of TASKS_RELEASE field.
	SPIS_TASKS_RELEASE_TASKS_RELEASE_Msk = 0x1
	// Bit TASKS_RELEASE.
	SPIS_TASKS_RELEASE_TASKS_RELEASE = 0x1
	// Trigger task
	SPIS_TASKS_RELEASE_TASKS_RELEASE_Trigger = 0x1

	// SUBSCRIBE_ACQUIRE: Subscribe configuration for task ACQUIRE
	// Position of CHIDX field.
	SPIS_SUBSCRIBE_ACQUIRE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIS_SUBSCRIBE_ACQUIRE_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIS_SUBSCRIBE_ACQUIRE_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIS_SUBSCRIBE_ACQUIRE_EN_Msk = 0x80000000
	// Bit EN.
	SPIS_SUBSCRIBE_ACQUIRE_EN = 0x80000000
	// Disable subscription
	SPIS_SUBSCRIBE_ACQUIRE_EN_Disabled = 0x0
	// Enable subscription
	SPIS_SUBSCRIBE_ACQUIRE_EN_Enabled = 0x1

	// SUBSCRIBE_RELEASE: Subscribe configuration for task RELEASE
	// Position of CHIDX field.
	SPIS_SUBSCRIBE_RELEASE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIS_SUBSCRIBE_RELEASE_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIS_SUBSCRIBE_RELEASE_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIS_SUBSCRIBE_RELEASE_EN_Msk = 0x80000000
	// Bit EN.
	SPIS_SUBSCRIBE_RELEASE_EN = 0x80000000
	// Disable subscription
	SPIS_SUBSCRIBE_RELEASE_EN_Disabled = 0x0
	// Enable subscription
	SPIS_SUBSCRIBE_RELEASE_EN_Enabled = 0x1

	// EVENTS_END: Granted transaction completed
	// Position of EVENTS_END field.
	SPIS_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	SPIS_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	SPIS_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	SPIS_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	SPIS_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_ENDRX: End of RXD buffer reached
	// Position of EVENTS_ENDRX field.
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_ACQUIRED: Semaphore acquired
	// Position of EVENTS_ACQUIRED field.
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Pos = 0x0
	// Bit mask of EVENTS_ACQUIRED field.
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Msk = 0x1
	// Bit EVENTS_ACQUIRED.
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED = 0x1
	// Event not generated
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_NotGenerated = 0x0
	// Event generated
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Generated = 0x1

	// PUBLISH_END: Publish configuration for event END
	// Position of CHIDX field.
	SPIS_PUBLISH_END_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIS_PUBLISH_END_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIS_PUBLISH_END_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIS_PUBLISH_END_EN_Msk = 0x80000000
	// Bit EN.
	SPIS_PUBLISH_END_EN = 0x80000000
	// Disable publishing
	SPIS_PUBLISH_END_EN_Disabled = 0x0
	// Enable publishing
	SPIS_PUBLISH_END_EN_Enabled = 0x1

	// PUBLISH_ENDRX: Publish configuration for event ENDRX
	// Position of CHIDX field.
	SPIS_PUBLISH_ENDRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIS_PUBLISH_ENDRX_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIS_PUBLISH_ENDRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIS_PUBLISH_ENDRX_EN_Msk = 0x80000000
	// Bit EN.
	SPIS_PUBLISH_ENDRX_EN = 0x80000000
	// Disable publishing
	SPIS_PUBLISH_ENDRX_EN_Disabled = 0x0
	// Enable publishing
	SPIS_PUBLISH_ENDRX_EN_Enabled = 0x1

	// PUBLISH_ACQUIRED: Publish configuration for event ACQUIRED
	// Position of CHIDX field.
	SPIS_PUBLISH_ACQUIRED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SPIS_PUBLISH_ACQUIRED_CHIDX_Msk = 0xff
	// Position of EN field.
	SPIS_PUBLISH_ACQUIRED_EN_Pos = 0x1f
	// Bit mask of EN field.
	SPIS_PUBLISH_ACQUIRED_EN_Msk = 0x80000000
	// Bit EN.
	SPIS_PUBLISH_ACQUIRED_EN = 0x80000000
	// Disable publishing
	SPIS_PUBLISH_ACQUIRED_EN_Disabled = 0x0
	// Enable publishing
	SPIS_PUBLISH_ACQUIRED_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of END_ACQUIRE field.
	SPIS_SHORTS_END_ACQUIRE_Pos = 0x2
	// Bit mask of END_ACQUIRE field.
	SPIS_SHORTS_END_ACQUIRE_Msk = 0x4
	// Bit END_ACQUIRE.
	SPIS_SHORTS_END_ACQUIRE = 0x4
	// Disable shortcut
	SPIS_SHORTS_END_ACQUIRE_Disabled = 0x0
	// Enable shortcut
	SPIS_SHORTS_END_ACQUIRE_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of END field.
	SPIS_INTENSET_END_Pos = 0x1
	// Bit mask of END field.
	SPIS_INTENSET_END_Msk = 0x2
	// Bit END.
	SPIS_INTENSET_END = 0x2
	// Read: Disabled
	SPIS_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_END_Enabled = 0x1
	// Enable
	SPIS_INTENSET_END_Set = 0x1
	// Position of ENDRX field.
	SPIS_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIS_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIS_INTENSET_ENDRX = 0x10
	// Read: Disabled
	SPIS_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	SPIS_INTENSET_ENDRX_Set = 0x1
	// Position of ACQUIRED field.
	SPIS_INTENSET_ACQUIRED_Pos = 0xa
	// Bit mask of ACQUIRED field.
	SPIS_INTENSET_ACQUIRED_Msk = 0x400
	// Bit ACQUIRED.
	SPIS_INTENSET_ACQUIRED = 0x400
	// Read: Disabled
	SPIS_INTENSET_ACQUIRED_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_ACQUIRED_Enabled = 0x1
	// Enable
	SPIS_INTENSET_ACQUIRED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of END field.
	SPIS_INTENCLR_END_Pos = 0x1
	// Bit mask of END field.
	SPIS_INTENCLR_END_Msk = 0x2
	// Bit END.
	SPIS_INTENCLR_END = 0x2
	// Read: Disabled
	SPIS_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_END_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_END_Clear = 0x1
	// Position of ENDRX field.
	SPIS_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIS_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIS_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	SPIS_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_ENDRX_Clear = 0x1
	// Position of ACQUIRED field.
	SPIS_INTENCLR_ACQUIRED_Pos = 0xa
	// Bit mask of ACQUIRED field.
	SPIS_INTENCLR_ACQUIRED_Msk = 0x400
	// Bit ACQUIRED.
	SPIS_INTENCLR_ACQUIRED = 0x400
	// Read: Disabled
	SPIS_INTENCLR_ACQUIRED_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_ACQUIRED_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_ACQUIRED_Clear = 0x1

	// SEMSTAT: Semaphore status register
	// Position of SEMSTAT field.
	SPIS_SEMSTAT_SEMSTAT_Pos = 0x0
	// Bit mask of SEMSTAT field.
	SPIS_SEMSTAT_SEMSTAT_Msk = 0x3
	// Semaphore is free
	SPIS_SEMSTAT_SEMSTAT_Free = 0x0
	// Semaphore is assigned to CPU
	SPIS_SEMSTAT_SEMSTAT_CPU = 0x1
	// Semaphore is assigned to SPI slave
	SPIS_SEMSTAT_SEMSTAT_SPIS = 0x2
	// Semaphore is assigned to SPI but a handover to the CPU is pending
	SPIS_SEMSTAT_SEMSTAT_CPUPending = 0x3

	// STATUS: Status from last transaction
	// Position of OVERREAD field.
	SPIS_STATUS_OVERREAD_Pos = 0x0
	// Bit mask of OVERREAD field.
	SPIS_STATUS_OVERREAD_Msk = 0x1
	// Bit OVERREAD.
	SPIS_STATUS_OVERREAD = 0x1
	// Read: error not present
	SPIS_STATUS_OVERREAD_NotPresent = 0x0
	// Read: error present
	SPIS_STATUS_OVERREAD_Present = 0x1
	// Write: clear error on writing '1'
	SPIS_STATUS_OVERREAD_Clear = 0x1
	// Position of OVERFLOW field.
	SPIS_STATUS_OVERFLOW_Pos = 0x1
	// Bit mask of OVERFLOW field.
	SPIS_STATUS_OVERFLOW_Msk = 0x2
	// Bit OVERFLOW.
	SPIS_STATUS_OVERFLOW = 0x2
	// Read: error not present
	SPIS_STATUS_OVERFLOW_NotPresent = 0x0
	// Read: error present
	SPIS_STATUS_OVERFLOW_Present = 0x1
	// Write: clear error on writing '1'
	SPIS_STATUS_OVERFLOW_Clear = 0x1

	// ENABLE: Enable SPI slave
	// Position of ENABLE field.
	SPIS_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPIS_ENABLE_ENABLE_Msk = 0xf
	// Disable SPI slave
	SPIS_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPI slave
	SPIS_ENABLE_ENABLE_Enabled = 0x2

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPIS_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_SCK_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIS_PSEL_SCK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIS_PSEL_SCK_PORT_Msk = 0x20
	// Bit PORT.
	SPIS_PSEL_SCK_PORT = 0x20
	// Position of CONNECT field.
	SPIS_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPIS_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_MISO_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIS_PSEL_MISO_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIS_PSEL_MISO_PORT_Msk = 0x20
	// Bit PORT.
	SPIS_PSEL_MISO_PORT = 0x20
	// Position of CONNECT field.
	SPIS_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_MISO_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPIS_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIS_PSEL_MOSI_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIS_PSEL_MOSI_PORT_Msk = 0x20
	// Bit PORT.
	SPIS_PSEL_MOSI_PORT = 0x20
	// Position of CONNECT field.
	SPIS_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.CSN: Pin select for CSN signal
	// Position of PIN field.
	SPIS_PSEL_CSN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_CSN_PIN_Msk = 0x1f
	// Position of PORT field.
	SPIS_PSEL_CSN_PORT_Pos = 0x5
	// Bit mask of PORT field.
	SPIS_PSEL_CSN_PORT_Msk = 0x20
	// Bit PORT.
	SPIS_PSEL_CSN_PORT = 0x20
	// Position of CONNECT field.
	SPIS_PSEL_CSN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_CSN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_CSN_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_CSN_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_CSN_CONNECT_Connected = 0x0

	// RXD.PTR: RXD data pointer
	// Position of PTR field.
	SPIS_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIS_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	SPIS_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIS_RXD_MAXCNT_MAXCNT_Msk = 0xffff

	// RXD.AMOUNT: Number of bytes received in last granted transaction
	// Position of AMOUNT field.
	SPIS_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIS_RXD_AMOUNT_AMOUNT_Msk = 0xffff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIS_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIS_RXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIS_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIS_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: TXD data pointer
	// Position of PTR field.
	SPIS_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIS_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	SPIS_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIS_TXD_MAXCNT_MAXCNT_Msk = 0xffff

	// TXD.AMOUNT: Number of bytes transmitted in last granted transaction
	// Position of AMOUNT field.
	SPIS_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIS_TXD_AMOUNT_AMOUNT_Msk = 0xffff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIS_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIS_TXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIS_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIS_TXD_LIST_LIST_ArrayList = 0x1

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPIS_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPIS_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPIS_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPIS_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPIS_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPIS_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPIS_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPIS_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPIS_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPIS_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPIS_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPIS_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPIS_CONFIG_CPOL = 0x4
	// Active high
	SPIS_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPIS_CONFIG_CPOL_ActiveLow = 0x1

	// DEF: Default character. Character clocked out in case of an ignored transaction.
	// Position of DEF field.
	SPIS_DEF_DEF_Pos = 0x0
	// Bit mask of DEF field.
	SPIS_DEF_DEF_Msk = 0xff

	// ORC: Over-read character
	// Position of ORC field.
	SPIS_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	SPIS_ORC_ORC_Msk = 0xff
)

// Constants for TWIM0_NS: I2C compatible Two-Wire Master Interface with EasyDMA 0
const (
	// TASKS_STARTRX: Start TWI receive sequence
	// Position of TASKS_STARTRX field.
	TWIM_TASKS_STARTRX_TASKS_STARTRX_Pos = 0x0
	// Bit mask of TASKS_STARTRX field.
	TWIM_TASKS_STARTRX_TASKS_STARTRX_Msk = 0x1
	// Bit TASKS_STARTRX.
	TWIM_TASKS_STARTRX_TASKS_STARTRX = 0x1
	// Trigger task
	TWIM_TASKS_STARTRX_TASKS_STARTRX_Trigger = 0x1

	// TASKS_STARTTX: Start TWI transmit sequence
	// Position of TASKS_STARTTX field.
	TWIM_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	TWIM_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	TWIM_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	TWIM_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_STOP: Stop TWI transaction. Must be issued while the TWI master is not suspended.
	// Position of TASKS_STOP field.
	TWIM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TWIM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TWIM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TWIM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend TWI transaction
	// Position of TASKS_SUSPEND field.
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume TWI transaction
	// Position of TASKS_RESUME field.
	TWIM_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	TWIM_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	TWIM_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	TWIM_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// SUBSCRIBE_STARTRX: Subscribe configuration for task STARTRX
	// Position of CHIDX field.
	TWIM_SUBSCRIBE_STARTRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_SUBSCRIBE_STARTRX_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_SUBSCRIBE_STARTRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_SUBSCRIBE_STARTRX_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_SUBSCRIBE_STARTRX_EN = 0x80000000
	// Disable subscription
	TWIM_SUBSCRIBE_STARTRX_EN_Disabled = 0x0
	// Enable subscription
	TWIM_SUBSCRIBE_STARTRX_EN_Enabled = 0x1

	// SUBSCRIBE_STARTTX: Subscribe configuration for task STARTTX
	// Position of CHIDX field.
	TWIM_SUBSCRIBE_STARTTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_SUBSCRIBE_STARTTX_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_SUBSCRIBE_STARTTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_SUBSCRIBE_STARTTX_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_SUBSCRIBE_STARTTX_EN = 0x80000000
	// Disable subscription
	TWIM_SUBSCRIBE_STARTTX_EN_Disabled = 0x0
	// Enable subscription
	TWIM_SUBSCRIBE_STARTTX_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	TWIM_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	TWIM_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	TWIM_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_SUSPEND: Subscribe configuration for task SUSPEND
	// Position of CHIDX field.
	TWIM_SUBSCRIBE_SUSPEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_SUBSCRIBE_SUSPEND_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_SUBSCRIBE_SUSPEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_SUBSCRIBE_SUSPEND_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_SUBSCRIBE_SUSPEND_EN = 0x80000000
	// Disable subscription
	TWIM_SUBSCRIBE_SUSPEND_EN_Disabled = 0x0
	// Enable subscription
	TWIM_SUBSCRIBE_SUSPEND_EN_Enabled = 0x1

	// SUBSCRIBE_RESUME: Subscribe configuration for task RESUME
	// Position of CHIDX field.
	TWIM_SUBSCRIBE_RESUME_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_SUBSCRIBE_RESUME_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_SUBSCRIBE_RESUME_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_SUBSCRIBE_RESUME_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_SUBSCRIBE_RESUME_EN = 0x80000000
	// Disable subscription
	TWIM_SUBSCRIBE_RESUME_EN_Disabled = 0x0
	// Enable subscription
	TWIM_SUBSCRIBE_RESUME_EN_Enabled = 0x1

	// EVENTS_STOPPED: TWI stopped
	// Position of EVENTS_STOPPED field.
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_ERROR: TWI error
	// Position of EVENTS_ERROR field.
	TWIM_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	TWIM_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	TWIM_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	TWIM_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_SUSPENDED: SUSPEND task has been issued, TWI traffic is now suspended.
	// Position of EVENTS_SUSPENDED field.
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos = 0x0
	// Bit mask of EVENTS_SUSPENDED field.
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Msk = 0x1
	// Bit EVENTS_SUSPENDED.
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED = 0x1
	// Event not generated
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Generated = 0x1

	// EVENTS_RXSTARTED: Receive sequence started
	// Position of EVENTS_RXSTARTED field.
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_RXSTARTED field.
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk = 0x1
	// Bit EVENTS_RXSTARTED.
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED = 0x1
	// Event not generated
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated = 0x1

	// EVENTS_TXSTARTED: Transmit sequence started
	// Position of EVENTS_TXSTARTED field.
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_TXSTARTED field.
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk = 0x1
	// Bit EVENTS_TXSTARTED.
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED = 0x1
	// Event not generated
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated = 0x1

	// EVENTS_LASTRX: Byte boundary, starting to receive the last byte
	// Position of EVENTS_LASTRX field.
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Pos = 0x0
	// Bit mask of EVENTS_LASTRX field.
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Msk = 0x1
	// Bit EVENTS_LASTRX.
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX = 0x1
	// Event not generated
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Generated = 0x1

	// EVENTS_LASTTX: Byte boundary, starting to transmit the last byte
	// Position of EVENTS_LASTTX field.
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Pos = 0x0
	// Bit mask of EVENTS_LASTTX field.
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Msk = 0x1
	// Bit EVENTS_LASTTX.
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX = 0x1
	// Event not generated
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Generated = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	TWIM_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_ERROR: Publish configuration for event ERROR
	// Position of CHIDX field.
	TWIM_PUBLISH_ERROR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_ERROR_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_ERROR_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_ERROR_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_ERROR_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_ERROR_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_ERROR_EN_Enabled = 0x1

	// PUBLISH_SUSPENDED: Publish configuration for event SUSPENDED
	// Position of CHIDX field.
	TWIM_PUBLISH_SUSPENDED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_SUSPENDED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_SUSPENDED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_SUSPENDED_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_SUSPENDED_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_SUSPENDED_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_SUSPENDED_EN_Enabled = 0x1

	// PUBLISH_RXSTARTED: Publish configuration for event RXSTARTED
	// Position of CHIDX field.
	TWIM_PUBLISH_RXSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_RXSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_RXSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_RXSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_RXSTARTED_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_RXSTARTED_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_RXSTARTED_EN_Enabled = 0x1

	// PUBLISH_TXSTARTED: Publish configuration for event TXSTARTED
	// Position of CHIDX field.
	TWIM_PUBLISH_TXSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_TXSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_TXSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_TXSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_TXSTARTED_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_TXSTARTED_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_TXSTARTED_EN_Enabled = 0x1

	// PUBLISH_LASTRX: Publish configuration for event LASTRX
	// Position of CHIDX field.
	TWIM_PUBLISH_LASTRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_LASTRX_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_LASTRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_LASTRX_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_LASTRX_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_LASTRX_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_LASTRX_EN_Enabled = 0x1

	// PUBLISH_LASTTX: Publish configuration for event LASTTX
	// Position of CHIDX field.
	TWIM_PUBLISH_LASTTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIM_PUBLISH_LASTTX_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIM_PUBLISH_LASTTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIM_PUBLISH_LASTTX_EN_Msk = 0x80000000
	// Bit EN.
	TWIM_PUBLISH_LASTTX_EN = 0x80000000
	// Disable publishing
	TWIM_PUBLISH_LASTTX_EN_Disabled = 0x0
	// Enable publishing
	TWIM_PUBLISH_LASTTX_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of LASTTX_STARTRX field.
	TWIM_SHORTS_LASTTX_STARTRX_Pos = 0x7
	// Bit mask of LASTTX_STARTRX field.
	TWIM_SHORTS_LASTTX_STARTRX_Msk = 0x80
	// Bit LASTTX_STARTRX.
	TWIM_SHORTS_LASTTX_STARTRX = 0x80
	// Disable shortcut
	TWIM_SHORTS_LASTTX_STARTRX_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_STARTRX_Enabled = 0x1
	// Position of LASTTX_SUSPEND field.
	TWIM_SHORTS_LASTTX_SUSPEND_Pos = 0x8
	// Bit mask of LASTTX_SUSPEND field.
	TWIM_SHORTS_LASTTX_SUSPEND_Msk = 0x100
	// Bit LASTTX_SUSPEND.
	TWIM_SHORTS_LASTTX_SUSPEND = 0x100
	// Disable shortcut
	TWIM_SHORTS_LASTTX_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_SUSPEND_Enabled = 0x1
	// Position of LASTTX_STOP field.
	TWIM_SHORTS_LASTTX_STOP_Pos = 0x9
	// Bit mask of LASTTX_STOP field.
	TWIM_SHORTS_LASTTX_STOP_Msk = 0x200
	// Bit LASTTX_STOP.
	TWIM_SHORTS_LASTTX_STOP = 0x200
	// Disable shortcut
	TWIM_SHORTS_LASTTX_STOP_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_STOP_Enabled = 0x1
	// Position of LASTRX_STARTTX field.
	TWIM_SHORTS_LASTRX_STARTTX_Pos = 0xa
	// Bit mask of LASTRX_STARTTX field.
	TWIM_SHORTS_LASTRX_STARTTX_Msk = 0x400
	// Bit LASTRX_STARTTX.
	TWIM_SHORTS_LASTRX_STARTTX = 0x400
	// Disable shortcut
	TWIM_SHORTS_LASTRX_STARTTX_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_STARTTX_Enabled = 0x1
	// Position of LASTRX_SUSPEND field.
	TWIM_SHORTS_LASTRX_SUSPEND_Pos = 0xb
	// Bit mask of LASTRX_SUSPEND field.
	TWIM_SHORTS_LASTRX_SUSPEND_Msk = 0x800
	// Bit LASTRX_SUSPEND.
	TWIM_SHORTS_LASTRX_SUSPEND = 0x800
	// Disable shortcut
	TWIM_SHORTS_LASTRX_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_SUSPEND_Enabled = 0x1
	// Position of LASTRX_STOP field.
	TWIM_SHORTS_LASTRX_STOP_Pos = 0xc
	// Bit mask of LASTRX_STOP field.
	TWIM_SHORTS_LASTRX_STOP_Msk = 0x1000
	// Bit LASTRX_STOP.
	TWIM_SHORTS_LASTRX_STOP = 0x1000
	// Disable shortcut
	TWIM_SHORTS_LASTRX_STOP_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	TWIM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTEN_STOPPED = 0x2
	// Disable
	TWIM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	TWIM_INTEN_STOPPED_Enabled = 0x1
	// Position of ERROR field.
	TWIM_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTEN_ERROR = 0x200
	// Disable
	TWIM_INTEN_ERROR_Disabled = 0x0
	// Enable
	TWIM_INTEN_ERROR_Enabled = 0x1
	// Position of SUSPENDED field.
	TWIM_INTEN_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTEN_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTEN_SUSPENDED = 0x40000
	// Disable
	TWIM_INTEN_SUSPENDED_Disabled = 0x0
	// Enable
	TWIM_INTEN_SUSPENDED_Enabled = 0x1
	// Position of RXSTARTED field.
	TWIM_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTEN_RXSTARTED = 0x80000
	// Disable
	TWIM_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	TWIM_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	TWIM_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTEN_TXSTARTED = 0x100000
	// Disable
	TWIM_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	TWIM_INTEN_TXSTARTED_Enabled = 0x1
	// Position of LASTRX field.
	TWIM_INTEN_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTEN_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTEN_LASTRX = 0x800000
	// Disable
	TWIM_INTEN_LASTRX_Disabled = 0x0
	// Enable
	TWIM_INTEN_LASTRX_Enabled = 0x1
	// Position of LASTTX field.
	TWIM_INTEN_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTEN_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTEN_LASTTX = 0x1000000
	// Disable
	TWIM_INTEN_LASTTX_Disabled = 0x0
	// Enable
	TWIM_INTEN_LASTTX_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWIM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWIM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_STOPPED_Set = 0x1
	// Position of ERROR field.
	TWIM_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWIM_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWIM_INTENSET_ERROR_Set = 0x1
	// Position of SUSPENDED field.
	TWIM_INTENSET_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTENSET_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTENSET_SUSPENDED = 0x40000
	// Read: Disabled
	TWIM_INTENSET_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_SUSPENDED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_SUSPENDED_Set = 0x1
	// Position of RXSTARTED field.
	TWIM_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	TWIM_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	TWIM_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	TWIM_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_TXSTARTED_Set = 0x1
	// Position of LASTRX field.
	TWIM_INTENSET_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTENSET_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTENSET_LASTRX = 0x800000
	// Read: Disabled
	TWIM_INTENSET_LASTRX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_LASTRX_Enabled = 0x1
	// Enable
	TWIM_INTENSET_LASTRX_Set = 0x1
	// Position of LASTTX field.
	TWIM_INTENSET_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTENSET_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTENSET_LASTTX = 0x1000000
	// Read: Disabled
	TWIM_INTENSET_LASTTX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_LASTTX_Enabled = 0x1
	// Enable
	TWIM_INTENSET_LASTTX_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWIM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWIM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_STOPPED_Clear = 0x1
	// Position of ERROR field.
	TWIM_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWIM_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_ERROR_Clear = 0x1
	// Position of SUSPENDED field.
	TWIM_INTENCLR_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTENCLR_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTENCLR_SUSPENDED = 0x40000
	// Read: Disabled
	TWIM_INTENCLR_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_SUSPENDED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_SUSPENDED_Clear = 0x1
	// Position of RXSTARTED field.
	TWIM_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	TWIM_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	TWIM_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	TWIM_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of LASTRX field.
	TWIM_INTENCLR_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTENCLR_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTENCLR_LASTRX = 0x800000
	// Read: Disabled
	TWIM_INTENCLR_LASTRX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_LASTRX_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_LASTRX_Clear = 0x1
	// Position of LASTTX field.
	TWIM_INTENCLR_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTENCLR_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTENCLR_LASTTX = 0x1000000
	// Read: Disabled
	TWIM_INTENCLR_LASTTX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_LASTTX_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_LASTTX_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	TWIM_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	TWIM_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	TWIM_ERRORSRC_OVERRUN = 0x1
	// Error did not occur
	TWIM_ERRORSRC_OVERRUN_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_OVERRUN_Received = 0x1
	// Position of ANACK field.
	TWIM_ERRORSRC_ANACK_Pos = 0x1
	// Bit mask of ANACK field.
	TWIM_ERRORSRC_ANACK_Msk = 0x2
	// Bit ANACK.
	TWIM_ERRORSRC_ANACK = 0x2
	// Error did not occur
	TWIM_ERRORSRC_ANACK_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_ANACK_Received = 0x1
	// Position of DNACK field.
	TWIM_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWIM_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWIM_ERRORSRC_DNACK = 0x4
	// Error did not occur
	TWIM_ERRORSRC_DNACK_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_DNACK_Received = 0x1

	// ENABLE: Enable TWIM
	// Position of ENABLE field.
	TWIM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWIM_ENABLE_ENABLE_Msk = 0xf
	// Disable TWIM
	TWIM_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWIM
	TWIM_ENABLE_ENABLE_Enabled = 0x6

	// PSEL.SCL: Pin select for SCL signal
	// Position of PIN field.
	TWIM_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIM_PSEL_SCL_PIN_Msk = 0x1f
	// Position of PORT field.
	TWIM_PSEL_SCL_PORT_Pos = 0x5
	// Bit mask of PORT field.
	TWIM_PSEL_SCL_PORT_Msk = 0x20
	// Bit PORT.
	TWIM_PSEL_SCL_PORT = 0x20
	// Position of CONNECT field.
	TWIM_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIM_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIM_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWIM_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWIM_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA signal
	// Position of PIN field.
	TWIM_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIM_PSEL_SDA_PIN_Msk = 0x1f
	// Position of PORT field.
	TWIM_PSEL_SDA_PORT_Pos = 0x5
	// Bit mask of PORT field.
	TWIM_PSEL_SDA_PORT_Msk = 0x20
	// Bit PORT.
	TWIM_PSEL_SDA_PORT = 0x20
	// Position of CONNECT field.
	TWIM_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIM_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIM_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWIM_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWIM_PSEL_SDA_CONNECT_Connected = 0x0

	// FREQUENCY: TWI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	TWIM_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	TWIM_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 100 kbps
	TWIM_FREQUENCY_FREQUENCY_K100 = 0x1980000
	// 250 kbps
	TWIM_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 400 kbps
	TWIM_FREQUENCY_FREQUENCY_K400 = 0x6400000
	// 1000 kbps
	TWIM_FREQUENCY_FREQUENCY_K1000 = 0xff00000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	TWIM_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIM_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	TWIM_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIM_RXD_MAXCNT_MAXCNT_Msk = 0xffff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	TWIM_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIM_RXD_AMOUNT_AMOUNT_Msk = 0xffff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIM_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIM_RXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	TWIM_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIM_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: Data pointer
	// Position of PTR field.
	TWIM_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIM_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	TWIM_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIM_TXD_MAXCNT_MAXCNT_Msk = 0xffff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	TWIM_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIM_TXD_AMOUNT_AMOUNT_Msk = 0xffff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIM_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIM_TXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	TWIM_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIM_TXD_LIST_LIST_ArrayList = 0x1

	// ADDRESS: Address used in the TWI transfer
	// Position of ADDRESS field.
	TWIM_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWIM_ADDRESS_ADDRESS_Msk = 0x7f
)

// Constants for TWIS0_NS: I2C compatible Two-Wire Slave Interface with EasyDMA 0
const (
	// TASKS_STOP: Stop TWI transaction
	// Position of TASKS_STOP field.
	TWIS_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TWIS_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TWIS_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TWIS_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend TWI transaction
	// Position of TASKS_SUSPEND field.
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume TWI transaction
	// Position of TASKS_RESUME field.
	TWIS_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	TWIS_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	TWIS_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	TWIS_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// TASKS_PREPARERX: Prepare the TWI slave to respond to a write command
	// Position of TASKS_PREPARERX field.
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Pos = 0x0
	// Bit mask of TASKS_PREPARERX field.
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Msk = 0x1
	// Bit TASKS_PREPARERX.
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX = 0x1
	// Trigger task
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Trigger = 0x1

	// TASKS_PREPARETX: Prepare the TWI slave to respond to a read command
	// Position of TASKS_PREPARETX field.
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Pos = 0x0
	// Bit mask of TASKS_PREPARETX field.
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Msk = 0x1
	// Bit TASKS_PREPARETX.
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX = 0x1
	// Trigger task
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Trigger = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	TWIS_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	TWIS_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	TWIS_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_SUSPEND: Subscribe configuration for task SUSPEND
	// Position of CHIDX field.
	TWIS_SUBSCRIBE_SUSPEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_SUBSCRIBE_SUSPEND_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_SUBSCRIBE_SUSPEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_SUBSCRIBE_SUSPEND_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_SUBSCRIBE_SUSPEND_EN = 0x80000000
	// Disable subscription
	TWIS_SUBSCRIBE_SUSPEND_EN_Disabled = 0x0
	// Enable subscription
	TWIS_SUBSCRIBE_SUSPEND_EN_Enabled = 0x1

	// SUBSCRIBE_RESUME: Subscribe configuration for task RESUME
	// Position of CHIDX field.
	TWIS_SUBSCRIBE_RESUME_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_SUBSCRIBE_RESUME_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_SUBSCRIBE_RESUME_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_SUBSCRIBE_RESUME_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_SUBSCRIBE_RESUME_EN = 0x80000000
	// Disable subscription
	TWIS_SUBSCRIBE_RESUME_EN_Disabled = 0x0
	// Enable subscription
	TWIS_SUBSCRIBE_RESUME_EN_Enabled = 0x1

	// SUBSCRIBE_PREPARERX: Subscribe configuration for task PREPARERX
	// Position of CHIDX field.
	TWIS_SUBSCRIBE_PREPARERX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_SUBSCRIBE_PREPARERX_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_SUBSCRIBE_PREPARERX_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_SUBSCRIBE_PREPARERX_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_SUBSCRIBE_PREPARERX_EN = 0x80000000
	// Disable subscription
	TWIS_SUBSCRIBE_PREPARERX_EN_Disabled = 0x0
	// Enable subscription
	TWIS_SUBSCRIBE_PREPARERX_EN_Enabled = 0x1

	// SUBSCRIBE_PREPARETX: Subscribe configuration for task PREPARETX
	// Position of CHIDX field.
	TWIS_SUBSCRIBE_PREPARETX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_SUBSCRIBE_PREPARETX_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_SUBSCRIBE_PREPARETX_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_SUBSCRIBE_PREPARETX_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_SUBSCRIBE_PREPARETX_EN = 0x80000000
	// Disable subscription
	TWIS_SUBSCRIBE_PREPARETX_EN_Disabled = 0x0
	// Enable subscription
	TWIS_SUBSCRIBE_PREPARETX_EN_Enabled = 0x1

	// EVENTS_STOPPED: TWI stopped
	// Position of EVENTS_STOPPED field.
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_ERROR: TWI error
	// Position of EVENTS_ERROR field.
	TWIS_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	TWIS_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	TWIS_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	TWIS_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_RXSTARTED: Receive sequence started
	// Position of EVENTS_RXSTARTED field.
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_RXSTARTED field.
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk = 0x1
	// Bit EVENTS_RXSTARTED.
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED = 0x1
	// Event not generated
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated = 0x1

	// EVENTS_TXSTARTED: Transmit sequence started
	// Position of EVENTS_TXSTARTED field.
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_TXSTARTED field.
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk = 0x1
	// Bit EVENTS_TXSTARTED.
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED = 0x1
	// Event not generated
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated = 0x1

	// EVENTS_WRITE: Write command received
	// Position of EVENTS_WRITE field.
	TWIS_EVENTS_WRITE_EVENTS_WRITE_Pos = 0x0
	// Bit mask of EVENTS_WRITE field.
	TWIS_EVENTS_WRITE_EVENTS_WRITE_Msk = 0x1
	// Bit EVENTS_WRITE.
	TWIS_EVENTS_WRITE_EVENTS_WRITE = 0x1
	// Event not generated
	TWIS_EVENTS_WRITE_EVENTS_WRITE_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_WRITE_EVENTS_WRITE_Generated = 0x1

	// EVENTS_READ: Read command received
	// Position of EVENTS_READ field.
	TWIS_EVENTS_READ_EVENTS_READ_Pos = 0x0
	// Bit mask of EVENTS_READ field.
	TWIS_EVENTS_READ_EVENTS_READ_Msk = 0x1
	// Bit EVENTS_READ.
	TWIS_EVENTS_READ_EVENTS_READ = 0x1
	// Event not generated
	TWIS_EVENTS_READ_EVENTS_READ_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_READ_EVENTS_READ_Generated = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	TWIS_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	TWIS_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	TWIS_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_ERROR: Publish configuration for event ERROR
	// Position of CHIDX field.
	TWIS_PUBLISH_ERROR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_PUBLISH_ERROR_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_PUBLISH_ERROR_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_PUBLISH_ERROR_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_PUBLISH_ERROR_EN = 0x80000000
	// Disable publishing
	TWIS_PUBLISH_ERROR_EN_Disabled = 0x0
	// Enable publishing
	TWIS_PUBLISH_ERROR_EN_Enabled = 0x1

	// PUBLISH_RXSTARTED: Publish configuration for event RXSTARTED
	// Position of CHIDX field.
	TWIS_PUBLISH_RXSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_PUBLISH_RXSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_PUBLISH_RXSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_PUBLISH_RXSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_PUBLISH_RXSTARTED_EN = 0x80000000
	// Disable publishing
	TWIS_PUBLISH_RXSTARTED_EN_Disabled = 0x0
	// Enable publishing
	TWIS_PUBLISH_RXSTARTED_EN_Enabled = 0x1

	// PUBLISH_TXSTARTED: Publish configuration for event TXSTARTED
	// Position of CHIDX field.
	TWIS_PUBLISH_TXSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_PUBLISH_TXSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_PUBLISH_TXSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_PUBLISH_TXSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_PUBLISH_TXSTARTED_EN = 0x80000000
	// Disable publishing
	TWIS_PUBLISH_TXSTARTED_EN_Disabled = 0x0
	// Enable publishing
	TWIS_PUBLISH_TXSTARTED_EN_Enabled = 0x1

	// PUBLISH_WRITE: Publish configuration for event WRITE
	// Position of CHIDX field.
	TWIS_PUBLISH_WRITE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_PUBLISH_WRITE_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_PUBLISH_WRITE_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_PUBLISH_WRITE_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_PUBLISH_WRITE_EN = 0x80000000
	// Disable publishing
	TWIS_PUBLISH_WRITE_EN_Disabled = 0x0
	// Enable publishing
	TWIS_PUBLISH_WRITE_EN_Enabled = 0x1

	// PUBLISH_READ: Publish configuration for event READ
	// Position of CHIDX field.
	TWIS_PUBLISH_READ_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TWIS_PUBLISH_READ_CHIDX_Msk = 0xff
	// Position of EN field.
	TWIS_PUBLISH_READ_EN_Pos = 0x1f
	// Bit mask of EN field.
	TWIS_PUBLISH_READ_EN_Msk = 0x80000000
	// Bit EN.
	TWIS_PUBLISH_READ_EN = 0x80000000
	// Disable publishing
	TWIS_PUBLISH_READ_EN_Disabled = 0x0
	// Enable publishing
	TWIS_PUBLISH_READ_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of WRITE_SUSPEND field.
	TWIS_SHORTS_WRITE_SUSPEND_Pos = 0xd
	// Bit mask of WRITE_SUSPEND field.
	TWIS_SHORTS_WRITE_SUSPEND_Msk = 0x2000
	// Bit WRITE_SUSPEND.
	TWIS_SHORTS_WRITE_SUSPEND = 0x2000
	// Disable shortcut
	TWIS_SHORTS_WRITE_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIS_SHORTS_WRITE_SUSPEND_Enabled = 0x1
	// Position of READ_SUSPEND field.
	TWIS_SHORTS_READ_SUSPEND_Pos = 0xe
	// Bit mask of READ_SUSPEND field.
	TWIS_SHORTS_READ_SUSPEND_Msk = 0x4000
	// Bit READ_SUSPEND.
	TWIS_SHORTS_READ_SUSPEND = 0x4000
	// Disable shortcut
	TWIS_SHORTS_READ_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIS_SHORTS_READ_SUSPEND_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	TWIS_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTEN_STOPPED = 0x2
	// Disable
	TWIS_INTEN_STOPPED_Disabled = 0x0
	// Enable
	TWIS_INTEN_STOPPED_Enabled = 0x1
	// Position of ERROR field.
	TWIS_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTEN_ERROR = 0x200
	// Disable
	TWIS_INTEN_ERROR_Disabled = 0x0
	// Enable
	TWIS_INTEN_ERROR_Enabled = 0x1
	// Position of RXSTARTED field.
	TWIS_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTEN_RXSTARTED = 0x80000
	// Disable
	TWIS_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	TWIS_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	TWIS_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTEN_TXSTARTED = 0x100000
	// Disable
	TWIS_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	TWIS_INTEN_TXSTARTED_Enabled = 0x1
	// Position of WRITE field.
	TWIS_INTEN_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTEN_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTEN_WRITE = 0x2000000
	// Disable
	TWIS_INTEN_WRITE_Disabled = 0x0
	// Enable
	TWIS_INTEN_WRITE_Enabled = 0x1
	// Position of READ field.
	TWIS_INTEN_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTEN_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTEN_READ = 0x4000000
	// Disable
	TWIS_INTEN_READ_Disabled = 0x0
	// Enable
	TWIS_INTEN_READ_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWIS_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWIS_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_STOPPED_Set = 0x1
	// Position of ERROR field.
	TWIS_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWIS_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWIS_INTENSET_ERROR_Set = 0x1
	// Position of RXSTARTED field.
	TWIS_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	TWIS_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	TWIS_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	TWIS_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_TXSTARTED_Set = 0x1
	// Position of WRITE field.
	TWIS_INTENSET_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTENSET_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTENSET_WRITE = 0x2000000
	// Read: Disabled
	TWIS_INTENSET_WRITE_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_WRITE_Enabled = 0x1
	// Enable
	TWIS_INTENSET_WRITE_Set = 0x1
	// Position of READ field.
	TWIS_INTENSET_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTENSET_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTENSET_READ = 0x4000000
	// Read: Disabled
	TWIS_INTENSET_READ_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_READ_Enabled = 0x1
	// Enable
	TWIS_INTENSET_READ_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWIS_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWIS_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_STOPPED_Clear = 0x1
	// Position of ERROR field.
	TWIS_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWIS_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_ERROR_Clear = 0x1
	// Position of RXSTARTED field.
	TWIS_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	TWIS_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	TWIS_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	TWIS_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of WRITE field.
	TWIS_INTENCLR_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTENCLR_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTENCLR_WRITE = 0x2000000
	// Read: Disabled
	TWIS_INTENCLR_WRITE_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_WRITE_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_WRITE_Clear = 0x1
	// Position of READ field.
	TWIS_INTENCLR_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTENCLR_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTENCLR_READ = 0x4000000
	// Read: Disabled
	TWIS_INTENCLR_READ_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_READ_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_READ_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERFLOW field.
	TWIS_ERRORSRC_OVERFLOW_Pos = 0x0
	// Bit mask of OVERFLOW field.
	TWIS_ERRORSRC_OVERFLOW_Msk = 0x1
	// Bit OVERFLOW.
	TWIS_ERRORSRC_OVERFLOW = 0x1
	// Error did not occur
	TWIS_ERRORSRC_OVERFLOW_NotDetected = 0x0
	// Error occurred
	TWIS_ERRORSRC_OVERFLOW_Detected = 0x1
	// Position of DNACK field.
	TWIS_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWIS_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWIS_ERRORSRC_DNACK = 0x4
	// Error did not occur
	TWIS_ERRORSRC_DNACK_NotReceived = 0x0
	// Error occurred
	TWIS_ERRORSRC_DNACK_Received = 0x1
	// Position of OVERREAD field.
	TWIS_ERRORSRC_OVERREAD_Pos = 0x3
	// Bit mask of OVERREAD field.
	TWIS_ERRORSRC_OVERREAD_Msk = 0x8
	// Bit OVERREAD.
	TWIS_ERRORSRC_OVERREAD = 0x8
	// Error did not occur
	TWIS_ERRORSRC_OVERREAD_NotDetected = 0x0
	// Error occurred
	TWIS_ERRORSRC_OVERREAD_Detected = 0x1

	// MATCH: Status register indicating which address had a match
	// Position of MATCH field.
	TWIS_MATCH_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	TWIS_MATCH_MATCH_Msk = 0x1
	// Bit MATCH.
	TWIS_MATCH_MATCH = 0x1

	// ENABLE: Enable TWIS
	// Position of ENABLE field.
	TWIS_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWIS_ENABLE_ENABLE_Msk = 0xf
	// Disable TWIS
	TWIS_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWIS
	TWIS_ENABLE_ENABLE_Enabled = 0x9

	// PSEL.SCL: Pin select for SCL signal
	// Position of PIN field.
	TWIS_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIS_PSEL_SCL_PIN_Msk = 0x1f
	// Position of PORT field.
	TWIS_PSEL_SCL_PORT_Pos = 0x5
	// Bit mask of PORT field.
	TWIS_PSEL_SCL_PORT_Msk = 0x20
	// Bit PORT.
	TWIS_PSEL_SCL_PORT = 0x20
	// Position of CONNECT field.
	TWIS_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIS_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIS_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWIS_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWIS_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA signal
	// Position of PIN field.
	TWIS_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIS_PSEL_SDA_PIN_Msk = 0x1f
	// Position of PORT field.
	TWIS_PSEL_SDA_PORT_Pos = 0x5
	// Bit mask of PORT field.
	TWIS_PSEL_SDA_PORT_Msk = 0x20
	// Bit PORT.
	TWIS_PSEL_SDA_PORT = 0x20
	// Position of CONNECT field.
	TWIS_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIS_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIS_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWIS_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWIS_PSEL_SDA_CONNECT_Connected = 0x0

	// RXD.PTR: RXD Data pointer
	// Position of PTR field.
	TWIS_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIS_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in RXD buffer
	// Position of MAXCNT field.
	TWIS_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIS_RXD_MAXCNT_MAXCNT_Msk = 0xffff

	// RXD.AMOUNT: Number of bytes transferred in the last RXD transaction
	// Position of AMOUNT field.
	TWIS_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIS_RXD_AMOUNT_AMOUNT_Msk = 0xffff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIS_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIS_RXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	TWIS_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIS_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: TXD Data pointer
	// Position of PTR field.
	TWIS_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIS_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in TXD buffer
	// Position of MAXCNT field.
	TWIS_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIS_TXD_MAXCNT_MAXCNT_Msk = 0xffff

	// TXD.AMOUNT: Number of bytes transferred in the last TXD transaction
	// Position of AMOUNT field.
	TWIS_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIS_TXD_AMOUNT_AMOUNT_Msk = 0xffff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIS_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIS_TXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	TWIS_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIS_TXD_LIST_LIST_ArrayList = 0x1

	// ADDRESS: Description collection: TWI slave address n
	// Position of ADDRESS field.
	TWIS_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWIS_ADDRESS_ADDRESS_Msk = 0x7f

	// CONFIG: Configuration register for the address match mechanism
	// Position of ADDRESS0 field.
	TWIS_CONFIG_ADDRESS0_Pos = 0x0
	// Bit mask of ADDRESS0 field.
	TWIS_CONFIG_ADDRESS0_Msk = 0x1
	// Bit ADDRESS0.
	TWIS_CONFIG_ADDRESS0 = 0x1
	// Disabled
	TWIS_CONFIG_ADDRESS0_Disabled = 0x0
	// Enabled
	TWIS_CONFIG_ADDRESS0_Enabled = 0x1
	// Position of ADDRESS1 field.
	TWIS_CONFIG_ADDRESS1_Pos = 0x1
	// Bit mask of ADDRESS1 field.
	TWIS_CONFIG_ADDRESS1_Msk = 0x2
	// Bit ADDRESS1.
	TWIS_CONFIG_ADDRESS1 = 0x2
	// Disabled
	TWIS_CONFIG_ADDRESS1_Disabled = 0x0
	// Enabled
	TWIS_CONFIG_ADDRESS1_Enabled = 0x1

	// ORC: Over-read character. Character sent out in case of an over-read of the transmit buffer.
	// Position of ORC field.
	TWIS_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	TWIS_ORC_ORC_Msk = 0xff
)

// Constants for UARTE0_NS: UART with EasyDMA 0
const (
	// TASKS_STARTRX: Start UART receiver
	// Position of TASKS_STARTRX field.
	UARTE_TASKS_STARTRX_TASKS_STARTRX_Pos = 0x0
	// Bit mask of TASKS_STARTRX field.
	UARTE_TASKS_STARTRX_TASKS_STARTRX_Msk = 0x1
	// Bit TASKS_STARTRX.
	UARTE_TASKS_STARTRX_TASKS_STARTRX = 0x1
	// Trigger task
	UARTE_TASKS_STARTRX_TASKS_STARTRX_Trigger = 0x1

	// TASKS_STOPRX: Stop UART receiver
	// Position of TASKS_STOPRX field.
	UARTE_TASKS_STOPRX_TASKS_STOPRX_Pos = 0x0
	// Bit mask of TASKS_STOPRX field.
	UARTE_TASKS_STOPRX_TASKS_STOPRX_Msk = 0x1
	// Bit TASKS_STOPRX.
	UARTE_TASKS_STOPRX_TASKS_STOPRX = 0x1
	// Trigger task
	UARTE_TASKS_STOPRX_TASKS_STOPRX_Trigger = 0x1

	// TASKS_STARTTX: Start UART transmitter
	// Position of TASKS_STARTTX field.
	UARTE_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	UARTE_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	UARTE_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	UARTE_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_STOPTX: Stop UART transmitter
	// Position of TASKS_STOPTX field.
	UARTE_TASKS_STOPTX_TASKS_STOPTX_Pos = 0x0
	// Bit mask of TASKS_STOPTX field.
	UARTE_TASKS_STOPTX_TASKS_STOPTX_Msk = 0x1
	// Bit TASKS_STOPTX.
	UARTE_TASKS_STOPTX_TASKS_STOPTX = 0x1
	// Trigger task
	UARTE_TASKS_STOPTX_TASKS_STOPTX_Trigger = 0x1

	// TASKS_FLUSHRX: Flush RX FIFO into RX buffer
	// Position of TASKS_FLUSHRX field.
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Pos = 0x0
	// Bit mask of TASKS_FLUSHRX field.
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Msk = 0x1
	// Bit TASKS_FLUSHRX.
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX = 0x1
	// Trigger task
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Trigger = 0x1

	// SUBSCRIBE_STARTRX: Subscribe configuration for task STARTRX
	// Position of CHIDX field.
	UARTE_SUBSCRIBE_STARTRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_SUBSCRIBE_STARTRX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_SUBSCRIBE_STARTRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_SUBSCRIBE_STARTRX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_SUBSCRIBE_STARTRX_EN = 0x80000000
	// Disable subscription
	UARTE_SUBSCRIBE_STARTRX_EN_Disabled = 0x0
	// Enable subscription
	UARTE_SUBSCRIBE_STARTRX_EN_Enabled = 0x1

	// SUBSCRIBE_STOPRX: Subscribe configuration for task STOPRX
	// Position of CHIDX field.
	UARTE_SUBSCRIBE_STOPRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_SUBSCRIBE_STOPRX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_SUBSCRIBE_STOPRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_SUBSCRIBE_STOPRX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_SUBSCRIBE_STOPRX_EN = 0x80000000
	// Disable subscription
	UARTE_SUBSCRIBE_STOPRX_EN_Disabled = 0x0
	// Enable subscription
	UARTE_SUBSCRIBE_STOPRX_EN_Enabled = 0x1

	// SUBSCRIBE_STARTTX: Subscribe configuration for task STARTTX
	// Position of CHIDX field.
	UARTE_SUBSCRIBE_STARTTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_SUBSCRIBE_STARTTX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_SUBSCRIBE_STARTTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_SUBSCRIBE_STARTTX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_SUBSCRIBE_STARTTX_EN = 0x80000000
	// Disable subscription
	UARTE_SUBSCRIBE_STARTTX_EN_Disabled = 0x0
	// Enable subscription
	UARTE_SUBSCRIBE_STARTTX_EN_Enabled = 0x1

	// SUBSCRIBE_STOPTX: Subscribe configuration for task STOPTX
	// Position of CHIDX field.
	UARTE_SUBSCRIBE_STOPTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_SUBSCRIBE_STOPTX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_SUBSCRIBE_STOPTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_SUBSCRIBE_STOPTX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_SUBSCRIBE_STOPTX_EN = 0x80000000
	// Disable subscription
	UARTE_SUBSCRIBE_STOPTX_EN_Disabled = 0x0
	// Enable subscription
	UARTE_SUBSCRIBE_STOPTX_EN_Enabled = 0x1

	// SUBSCRIBE_FLUSHRX: Subscribe configuration for task FLUSHRX
	// Position of CHIDX field.
	UARTE_SUBSCRIBE_FLUSHRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_SUBSCRIBE_FLUSHRX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_SUBSCRIBE_FLUSHRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_SUBSCRIBE_FLUSHRX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_SUBSCRIBE_FLUSHRX_EN = 0x80000000
	// Disable subscription
	UARTE_SUBSCRIBE_FLUSHRX_EN_Disabled = 0x0
	// Enable subscription
	UARTE_SUBSCRIBE_FLUSHRX_EN_Enabled = 0x1

	// EVENTS_CTS: CTS is activated (set low). Clear To Send.
	// Position of EVENTS_CTS field.
	UARTE_EVENTS_CTS_EVENTS_CTS_Pos = 0x0
	// Bit mask of EVENTS_CTS field.
	UARTE_EVENTS_CTS_EVENTS_CTS_Msk = 0x1
	// Bit EVENTS_CTS.
	UARTE_EVENTS_CTS_EVENTS_CTS = 0x1
	// Event not generated
	UARTE_EVENTS_CTS_EVENTS_CTS_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_CTS_EVENTS_CTS_Generated = 0x1

	// EVENTS_NCTS: CTS is deactivated (set high). Not Clear To Send.
	// Position of EVENTS_NCTS field.
	UARTE_EVENTS_NCTS_EVENTS_NCTS_Pos = 0x0
	// Bit mask of EVENTS_NCTS field.
	UARTE_EVENTS_NCTS_EVENTS_NCTS_Msk = 0x1
	// Bit EVENTS_NCTS.
	UARTE_EVENTS_NCTS_EVENTS_NCTS = 0x1
	// Event not generated
	UARTE_EVENTS_NCTS_EVENTS_NCTS_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_NCTS_EVENTS_NCTS_Generated = 0x1

	// EVENTS_RXDRDY: Data received in RXD (but potentially not yet transferred to Data RAM)
	// Position of EVENTS_RXDRDY field.
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos = 0x0
	// Bit mask of EVENTS_RXDRDY field.
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Msk = 0x1
	// Bit EVENTS_RXDRDY.
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY = 0x1
	// Event not generated
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Generated = 0x1

	// EVENTS_ENDRX: Receive buffer is filled up
	// Position of EVENTS_ENDRX field.
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_TXDRDY: Data sent from TXD
	// Position of EVENTS_TXDRDY field.
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos = 0x0
	// Bit mask of EVENTS_TXDRDY field.
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Msk = 0x1
	// Bit EVENTS_TXDRDY.
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY = 0x1
	// Event not generated
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Generated = 0x1

	// EVENTS_ENDTX: Last TX byte transmitted
	// Position of EVENTS_ENDTX field.
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Pos = 0x0
	// Bit mask of EVENTS_ENDTX field.
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Msk = 0x1
	// Bit EVENTS_ENDTX.
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX = 0x1
	// Event not generated
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Generated = 0x1

	// EVENTS_ERROR: Error detected
	// Position of EVENTS_ERROR field.
	UARTE_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	UARTE_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	UARTE_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	UARTE_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_RXTO: Receiver timeout
	// Position of EVENTS_RXTO field.
	UARTE_EVENTS_RXTO_EVENTS_RXTO_Pos = 0x0
	// Bit mask of EVENTS_RXTO field.
	UARTE_EVENTS_RXTO_EVENTS_RXTO_Msk = 0x1
	// Bit EVENTS_RXTO.
	UARTE_EVENTS_RXTO_EVENTS_RXTO = 0x1
	// Event not generated
	UARTE_EVENTS_RXTO_EVENTS_RXTO_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_RXTO_EVENTS_RXTO_Generated = 0x1

	// EVENTS_RXSTARTED: UART receiver has started
	// Position of EVENTS_RXSTARTED field.
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_RXSTARTED field.
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk = 0x1
	// Bit EVENTS_RXSTARTED.
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED = 0x1
	// Event not generated
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated = 0x1

	// EVENTS_TXSTARTED: UART transmitter has started
	// Position of EVENTS_TXSTARTED field.
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_TXSTARTED field.
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk = 0x1
	// Bit EVENTS_TXSTARTED.
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED = 0x1
	// Event not generated
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated = 0x1

	// EVENTS_TXSTOPPED: Transmitter stopped
	// Position of EVENTS_TXSTOPPED field.
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Pos = 0x0
	// Bit mask of EVENTS_TXSTOPPED field.
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Msk = 0x1
	// Bit EVENTS_TXSTOPPED.
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED = 0x1
	// Event not generated
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Generated = 0x1

	// PUBLISH_CTS: Publish configuration for event CTS
	// Position of CHIDX field.
	UARTE_PUBLISH_CTS_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_CTS_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_CTS_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_CTS_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_CTS_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_CTS_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_CTS_EN_Enabled = 0x1

	// PUBLISH_NCTS: Publish configuration for event NCTS
	// Position of CHIDX field.
	UARTE_PUBLISH_NCTS_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_NCTS_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_NCTS_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_NCTS_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_NCTS_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_NCTS_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_NCTS_EN_Enabled = 0x1

	// PUBLISH_RXDRDY: Publish configuration for event RXDRDY
	// Position of CHIDX field.
	UARTE_PUBLISH_RXDRDY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_RXDRDY_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_RXDRDY_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_RXDRDY_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_RXDRDY_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_RXDRDY_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_RXDRDY_EN_Enabled = 0x1

	// PUBLISH_ENDRX: Publish configuration for event ENDRX
	// Position of CHIDX field.
	UARTE_PUBLISH_ENDRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_ENDRX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_ENDRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_ENDRX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_ENDRX_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_ENDRX_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_ENDRX_EN_Enabled = 0x1

	// PUBLISH_TXDRDY: Publish configuration for event TXDRDY
	// Position of CHIDX field.
	UARTE_PUBLISH_TXDRDY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_TXDRDY_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_TXDRDY_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_TXDRDY_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_TXDRDY_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_TXDRDY_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_TXDRDY_EN_Enabled = 0x1

	// PUBLISH_ENDTX: Publish configuration for event ENDTX
	// Position of CHIDX field.
	UARTE_PUBLISH_ENDTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_ENDTX_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_ENDTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_ENDTX_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_ENDTX_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_ENDTX_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_ENDTX_EN_Enabled = 0x1

	// PUBLISH_ERROR: Publish configuration for event ERROR
	// Position of CHIDX field.
	UARTE_PUBLISH_ERROR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_ERROR_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_ERROR_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_ERROR_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_ERROR_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_ERROR_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_ERROR_EN_Enabled = 0x1

	// PUBLISH_RXTO: Publish configuration for event RXTO
	// Position of CHIDX field.
	UARTE_PUBLISH_RXTO_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_RXTO_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_RXTO_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_RXTO_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_RXTO_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_RXTO_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_RXTO_EN_Enabled = 0x1

	// PUBLISH_RXSTARTED: Publish configuration for event RXSTARTED
	// Position of CHIDX field.
	UARTE_PUBLISH_RXSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_RXSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_RXSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_RXSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_RXSTARTED_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_RXSTARTED_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_RXSTARTED_EN_Enabled = 0x1

	// PUBLISH_TXSTARTED: Publish configuration for event TXSTARTED
	// Position of CHIDX field.
	UARTE_PUBLISH_TXSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_TXSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_TXSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_TXSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_TXSTARTED_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_TXSTARTED_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_TXSTARTED_EN_Enabled = 0x1

	// PUBLISH_TXSTOPPED: Publish configuration for event TXSTOPPED
	// Position of CHIDX field.
	UARTE_PUBLISH_TXSTOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	UARTE_PUBLISH_TXSTOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	UARTE_PUBLISH_TXSTOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	UARTE_PUBLISH_TXSTOPPED_EN_Msk = 0x80000000
	// Bit EN.
	UARTE_PUBLISH_TXSTOPPED_EN = 0x80000000
	// Disable publishing
	UARTE_PUBLISH_TXSTOPPED_EN_Disabled = 0x0
	// Enable publishing
	UARTE_PUBLISH_TXSTOPPED_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of ENDRX_STARTRX field.
	UARTE_SHORTS_ENDRX_STARTRX_Pos = 0x5
	// Bit mask of ENDRX_STARTRX field.
	UARTE_SHORTS_ENDRX_STARTRX_Msk = 0x20
	// Bit ENDRX_STARTRX.
	UARTE_SHORTS_ENDRX_STARTRX = 0x20
	// Disable shortcut
	UARTE_SHORTS_ENDRX_STARTRX_Disabled = 0x0
	// Enable shortcut
	UARTE_SHORTS_ENDRX_STARTRX_Enabled = 0x1
	// Position of ENDRX_STOPRX field.
	UARTE_SHORTS_ENDRX_STOPRX_Pos = 0x6
	// Bit mask of ENDRX_STOPRX field.
	UARTE_SHORTS_ENDRX_STOPRX_Msk = 0x40
	// Bit ENDRX_STOPRX.
	UARTE_SHORTS_ENDRX_STOPRX = 0x40
	// Disable shortcut
	UARTE_SHORTS_ENDRX_STOPRX_Disabled = 0x0
	// Enable shortcut
	UARTE_SHORTS_ENDRX_STOPRX_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of CTS field.
	UARTE_INTEN_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTEN_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTEN_CTS = 0x1
	// Disable
	UARTE_INTEN_CTS_Disabled = 0x0
	// Enable
	UARTE_INTEN_CTS_Enabled = 0x1
	// Position of NCTS field.
	UARTE_INTEN_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTEN_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTEN_NCTS = 0x2
	// Disable
	UARTE_INTEN_NCTS_Disabled = 0x0
	// Enable
	UARTE_INTEN_NCTS_Enabled = 0x1
	// Position of RXDRDY field.
	UARTE_INTEN_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTEN_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTEN_RXDRDY = 0x4
	// Disable
	UARTE_INTEN_RXDRDY_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXDRDY_Enabled = 0x1
	// Position of ENDRX field.
	UARTE_INTEN_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTEN_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTEN_ENDRX = 0x10
	// Disable
	UARTE_INTEN_ENDRX_Disabled = 0x0
	// Enable
	UARTE_INTEN_ENDRX_Enabled = 0x1
	// Position of TXDRDY field.
	UARTE_INTEN_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTEN_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTEN_TXDRDY = 0x80
	// Disable
	UARTE_INTEN_TXDRDY_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXDRDY_Enabled = 0x1
	// Position of ENDTX field.
	UARTE_INTEN_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTEN_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTEN_ENDTX = 0x100
	// Disable
	UARTE_INTEN_ENDTX_Disabled = 0x0
	// Enable
	UARTE_INTEN_ENDTX_Enabled = 0x1
	// Position of ERROR field.
	UARTE_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTEN_ERROR = 0x200
	// Disable
	UARTE_INTEN_ERROR_Disabled = 0x0
	// Enable
	UARTE_INTEN_ERROR_Enabled = 0x1
	// Position of RXTO field.
	UARTE_INTEN_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTEN_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTEN_RXTO = 0x20000
	// Disable
	UARTE_INTEN_RXTO_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXTO_Enabled = 0x1
	// Position of RXSTARTED field.
	UARTE_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTEN_RXSTARTED = 0x80000
	// Disable
	UARTE_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	UARTE_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTEN_TXSTARTED = 0x100000
	// Disable
	UARTE_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXSTARTED_Enabled = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTEN_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTEN_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTEN_TXSTOPPED = 0x400000
	// Disable
	UARTE_INTEN_TXSTOPPED_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXSTOPPED_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of CTS field.
	UARTE_INTENSET_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTENSET_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTENSET_CTS = 0x1
	// Read: Disabled
	UARTE_INTENSET_CTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_CTS_Enabled = 0x1
	// Enable
	UARTE_INTENSET_CTS_Set = 0x1
	// Position of NCTS field.
	UARTE_INTENSET_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTENSET_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTENSET_NCTS = 0x2
	// Read: Disabled
	UARTE_INTENSET_NCTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_NCTS_Enabled = 0x1
	// Enable
	UARTE_INTENSET_NCTS_Set = 0x1
	// Position of RXDRDY field.
	UARTE_INTENSET_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTENSET_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTENSET_RXDRDY = 0x4
	// Read: Disabled
	UARTE_INTENSET_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXDRDY_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXDRDY_Set = 0x1
	// Position of ENDRX field.
	UARTE_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTENSET_ENDRX = 0x10
	// Read: Disabled
	UARTE_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ENDRX_Set = 0x1
	// Position of TXDRDY field.
	UARTE_INTENSET_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTENSET_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTENSET_TXDRDY = 0x80
	// Read: Disabled
	UARTE_INTENSET_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXDRDY_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXDRDY_Set = 0x1
	// Position of ENDTX field.
	UARTE_INTENSET_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTENSET_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTENSET_ENDTX = 0x100
	// Read: Disabled
	UARTE_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ENDTX_Set = 0x1
	// Position of ERROR field.
	UARTE_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTENSET_ERROR = 0x200
	// Read: Disabled
	UARTE_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ERROR_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ERROR_Set = 0x1
	// Position of RXTO field.
	UARTE_INTENSET_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTENSET_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTENSET_RXTO = 0x20000
	// Read: Disabled
	UARTE_INTENSET_RXTO_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXTO_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXTO_Set = 0x1
	// Position of RXSTARTED field.
	UARTE_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	UARTE_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	UARTE_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	UARTE_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXSTARTED_Set = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTENSET_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTENSET_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTENSET_TXSTOPPED = 0x400000
	// Read: Disabled
	UARTE_INTENSET_TXSTOPPED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXSTOPPED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXSTOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of CTS field.
	UARTE_INTENCLR_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTENCLR_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTENCLR_CTS = 0x1
	// Read: Disabled
	UARTE_INTENCLR_CTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_CTS_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_CTS_Clear = 0x1
	// Position of NCTS field.
	UARTE_INTENCLR_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTENCLR_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTENCLR_NCTS = 0x2
	// Read: Disabled
	UARTE_INTENCLR_NCTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_NCTS_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_NCTS_Clear = 0x1
	// Position of RXDRDY field.
	UARTE_INTENCLR_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTENCLR_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTENCLR_RXDRDY = 0x4
	// Read: Disabled
	UARTE_INTENCLR_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXDRDY_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXDRDY_Clear = 0x1
	// Position of ENDRX field.
	UARTE_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	UARTE_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ENDRX_Clear = 0x1
	// Position of TXDRDY field.
	UARTE_INTENCLR_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTENCLR_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTENCLR_TXDRDY = 0x80
	// Read: Disabled
	UARTE_INTENCLR_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXDRDY_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXDRDY_Clear = 0x1
	// Position of ENDTX field.
	UARTE_INTENCLR_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTENCLR_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTENCLR_ENDTX = 0x100
	// Read: Disabled
	UARTE_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ENDTX_Clear = 0x1
	// Position of ERROR field.
	UARTE_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTENCLR_ERROR = 0x200
	// Read: Disabled
	UARTE_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ERROR_Clear = 0x1
	// Position of RXTO field.
	UARTE_INTENCLR_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTENCLR_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTENCLR_RXTO = 0x20000
	// Read: Disabled
	UARTE_INTENCLR_RXTO_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXTO_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXTO_Clear = 0x1
	// Position of RXSTARTED field.
	UARTE_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	UARTE_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	UARTE_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	UARTE_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTENCLR_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTENCLR_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTENCLR_TXSTOPPED = 0x400000
	// Read: Disabled
	UARTE_INTENCLR_TXSTOPPED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXSTOPPED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXSTOPPED_Clear = 0x1

	// ERRORSRC: Error source Note : this register is read / write one to clear.
	// Position of OVERRUN field.
	UARTE_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	UARTE_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	UARTE_ERRORSRC_OVERRUN = 0x1
	// Read: error not present
	UARTE_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_OVERRUN_Present = 0x1
	// Position of PARITY field.
	UARTE_ERRORSRC_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UARTE_ERRORSRC_PARITY_Msk = 0x2
	// Bit PARITY.
	UARTE_ERRORSRC_PARITY = 0x2
	// Read: error not present
	UARTE_ERRORSRC_PARITY_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_PARITY_Present = 0x1
	// Position of FRAMING field.
	UARTE_ERRORSRC_FRAMING_Pos = 0x2
	// Bit mask of FRAMING field.
	UARTE_ERRORSRC_FRAMING_Msk = 0x4
	// Bit FRAMING.
	UARTE_ERRORSRC_FRAMING = 0x4
	// Read: error not present
	UARTE_ERRORSRC_FRAMING_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_FRAMING_Present = 0x1
	// Position of BREAK field.
	UARTE_ERRORSRC_BREAK_Pos = 0x3
	// Bit mask of BREAK field.
	UARTE_ERRORSRC_BREAK_Msk = 0x8
	// Bit BREAK.
	UARTE_ERRORSRC_BREAK = 0x8
	// Read: error not present
	UARTE_ERRORSRC_BREAK_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_BREAK_Present = 0x1

	// ENABLE: Enable UART
	// Position of ENABLE field.
	UARTE_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	UARTE_ENABLE_ENABLE_Msk = 0xf
	// Disable UARTE
	UARTE_ENABLE_ENABLE_Disabled = 0x0
	// Enable UARTE
	UARTE_ENABLE_ENABLE_Enabled = 0x8

	// PSEL.RTS: Pin select for RTS signal
	// Position of PIN field.
	UARTE_PSEL_RTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_RTS_PIN_Msk = 0x1f
	// Position of PORT field.
	UARTE_PSEL_RTS_PORT_Pos = 0x5
	// Bit mask of PORT field.
	UARTE_PSEL_RTS_PORT_Msk = 0x20
	// Bit PORT.
	UARTE_PSEL_RTS_PORT = 0x20
	// Position of CONNECT field.
	UARTE_PSEL_RTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_RTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_RTS_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_RTS_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_RTS_CONNECT_Connected = 0x0

	// PSEL.TXD: Pin select for TXD signal
	// Position of PIN field.
	UARTE_PSEL_TXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_TXD_PIN_Msk = 0x1f
	// Position of PORT field.
	UARTE_PSEL_TXD_PORT_Pos = 0x5
	// Bit mask of PORT field.
	UARTE_PSEL_TXD_PORT_Msk = 0x20
	// Bit PORT.
	UARTE_PSEL_TXD_PORT = 0x20
	// Position of CONNECT field.
	UARTE_PSEL_TXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_TXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_TXD_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_TXD_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_TXD_CONNECT_Connected = 0x0

	// PSEL.CTS: Pin select for CTS signal
	// Position of PIN field.
	UARTE_PSEL_CTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_CTS_PIN_Msk = 0x1f
	// Position of PORT field.
	UARTE_PSEL_CTS_PORT_Pos = 0x5
	// Bit mask of PORT field.
	UARTE_PSEL_CTS_PORT_Msk = 0x20
	// Bit PORT.
	UARTE_PSEL_CTS_PORT = 0x20
	// Position of CONNECT field.
	UARTE_PSEL_CTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_CTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_CTS_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_CTS_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_CTS_CONNECT_Connected = 0x0

	// PSEL.RXD: Pin select for RXD signal
	// Position of PIN field.
	UARTE_PSEL_RXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_RXD_PIN_Msk = 0x1f
	// Position of PORT field.
	UARTE_PSEL_RXD_PORT_Pos = 0x5
	// Bit mask of PORT field.
	UARTE_PSEL_RXD_PORT_Msk = 0x20
	// Bit PORT.
	UARTE_PSEL_RXD_PORT = 0x20
	// Position of CONNECT field.
	UARTE_PSEL_RXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_RXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_RXD_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_RXD_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_RXD_CONNECT_Connected = 0x0

	// BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
	// Position of BAUDRATE field.
	UARTE_BAUDRATE_BAUDRATE_Pos = 0x0
	// Bit mask of BAUDRATE field.
	UARTE_BAUDRATE_BAUDRATE_Msk = 0xffffffff
	// 1200 baud (actual rate: 1205)
	UARTE_BAUDRATE_BAUDRATE_Baud1200 = 0x4f000
	// 2400 baud (actual rate: 2396)
	UARTE_BAUDRATE_BAUDRATE_Baud2400 = 0x9d000
	// 4800 baud (actual rate: 4808)
	UARTE_BAUDRATE_BAUDRATE_Baud4800 = 0x13b000
	// 9600 baud (actual rate: 9598)
	UARTE_BAUDRATE_BAUDRATE_Baud9600 = 0x275000
	// 14400 baud (actual rate: 14401)
	UARTE_BAUDRATE_BAUDRATE_Baud14400 = 0x3af000
	// 19200 baud (actual rate: 19208)
	UARTE_BAUDRATE_BAUDRATE_Baud19200 = 0x4ea000
	// 28800 baud (actual rate: 28777)
	UARTE_BAUDRATE_BAUDRATE_Baud28800 = 0x75c000
	// 31250 baud
	UARTE_BAUDRATE_BAUDRATE_Baud31250 = 0x800000
	// 38400 baud (actual rate: 38369)
	UARTE_BAUDRATE_BAUDRATE_Baud38400 = 0x9d0000
	// 56000 baud (actual rate: 55944)
	UARTE_BAUDRATE_BAUDRATE_Baud56000 = 0xe50000
	// 57600 baud (actual rate: 57554)
	UARTE_BAUDRATE_BAUDRATE_Baud57600 = 0xeb0000
	// 76800 baud (actual rate: 76923)
	UARTE_BAUDRATE_BAUDRATE_Baud76800 = 0x13a9000
	// 115200 baud (actual rate: 115108)
	UARTE_BAUDRATE_BAUDRATE_Baud115200 = 0x1d60000
	// 230400 baud (actual rate: 231884)
	UARTE_BAUDRATE_BAUDRATE_Baud230400 = 0x3b00000
	// 250000 baud
	UARTE_BAUDRATE_BAUDRATE_Baud250000 = 0x4000000
	// 460800 baud (actual rate: 457143)
	UARTE_BAUDRATE_BAUDRATE_Baud460800 = 0x7400000
	// 921600 baud (actual rate: 941176)
	UARTE_BAUDRATE_BAUDRATE_Baud921600 = 0xf000000
	// 1Mega baud
	UARTE_BAUDRATE_BAUDRATE_Baud1M = 0x10000000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	UARTE_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	UARTE_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	UARTE_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	UARTE_RXD_MAXCNT_MAXCNT_Msk = 0xffff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	UARTE_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	UARTE_RXD_AMOUNT_AMOUNT_Msk = 0xffff

	// TXD.PTR: Data pointer
	// Position of PTR field.
	UARTE_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	UARTE_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	UARTE_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	UARTE_TXD_MAXCNT_MAXCNT_Msk = 0xffff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	UARTE_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	UARTE_TXD_AMOUNT_AMOUNT_Msk = 0xffff

	// CONFIG: Configuration of parity and hardware flow control
	// Position of HWFC field.
	UARTE_CONFIG_HWFC_Pos = 0x0
	// Bit mask of HWFC field.
	UARTE_CONFIG_HWFC_Msk = 0x1
	// Bit HWFC.
	UARTE_CONFIG_HWFC = 0x1
	// Disabled
	UARTE_CONFIG_HWFC_Disabled = 0x0
	// Enabled
	UARTE_CONFIG_HWFC_Enabled = 0x1
	// Position of PARITY field.
	UARTE_CONFIG_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UARTE_CONFIG_PARITY_Msk = 0xe
	// Exclude parity bit
	UARTE_CONFIG_PARITY_Excluded = 0x0
	// Include even parity bit
	UARTE_CONFIG_PARITY_Included = 0x7
	// Position of STOP field.
	UARTE_CONFIG_STOP_Pos = 0x4
	// Bit mask of STOP field.
	UARTE_CONFIG_STOP_Msk = 0x10
	// Bit STOP.
	UARTE_CONFIG_STOP = 0x10
	// One stop bit
	UARTE_CONFIG_STOP_One = 0x0
	// Two stop bits
	UARTE_CONFIG_STOP_Two = 0x1
	// Position of PARITYTYPE field.
	UARTE_CONFIG_PARITYTYPE_Pos = 0x8
	// Bit mask of PARITYTYPE field.
	UARTE_CONFIG_PARITYTYPE_Msk = 0x100
	// Bit PARITYTYPE.
	UARTE_CONFIG_PARITYTYPE = 0x100
	// Even parity
	UARTE_CONFIG_PARITYTYPE_Even = 0x0
	// Odd parity
	UARTE_CONFIG_PARITYTYPE_Odd = 0x1
)

// Constants for GPIOTE0_S: GPIO Tasks and Events 0
const (
	// TASKS_OUT: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
	// Position of TASKS_OUT field.
	GPIOTE_TASKS_OUT_TASKS_OUT_Pos = 0x0
	// Bit mask of TASKS_OUT field.
	GPIOTE_TASKS_OUT_TASKS_OUT_Msk = 0x1
	// Bit TASKS_OUT.
	GPIOTE_TASKS_OUT_TASKS_OUT = 0x1
	// Trigger task
	GPIOTE_TASKS_OUT_TASKS_OUT_Trigger = 0x1

	// TASKS_SET: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
	// Position of TASKS_SET field.
	GPIOTE_TASKS_SET_TASKS_SET_Pos = 0x0
	// Bit mask of TASKS_SET field.
	GPIOTE_TASKS_SET_TASKS_SET_Msk = 0x1
	// Bit TASKS_SET.
	GPIOTE_TASKS_SET_TASKS_SET = 0x1
	// Trigger task
	GPIOTE_TASKS_SET_TASKS_SET_Trigger = 0x1

	// TASKS_CLR: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
	// Position of TASKS_CLR field.
	GPIOTE_TASKS_CLR_TASKS_CLR_Pos = 0x0
	// Bit mask of TASKS_CLR field.
	GPIOTE_TASKS_CLR_TASKS_CLR_Msk = 0x1
	// Bit TASKS_CLR.
	GPIOTE_TASKS_CLR_TASKS_CLR = 0x1
	// Trigger task
	GPIOTE_TASKS_CLR_TASKS_CLR_Trigger = 0x1

	// SUBSCRIBE_OUT: Description collection: Subscribe configuration for task OUT[n]
	// Position of CHIDX field.
	GPIOTE_SUBSCRIBE_OUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	GPIOTE_SUBSCRIBE_OUT_CHIDX_Msk = 0xff
	// Position of EN field.
	GPIOTE_SUBSCRIBE_OUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	GPIOTE_SUBSCRIBE_OUT_EN_Msk = 0x80000000
	// Bit EN.
	GPIOTE_SUBSCRIBE_OUT_EN = 0x80000000
	// Disable subscription
	GPIOTE_SUBSCRIBE_OUT_EN_Disabled = 0x0
	// Enable subscription
	GPIOTE_SUBSCRIBE_OUT_EN_Enabled = 0x1

	// SUBSCRIBE_SET: Description collection: Subscribe configuration for task SET[n]
	// Position of CHIDX field.
	GPIOTE_SUBSCRIBE_SET_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	GPIOTE_SUBSCRIBE_SET_CHIDX_Msk = 0xff
	// Position of EN field.
	GPIOTE_SUBSCRIBE_SET_EN_Pos = 0x1f
	// Bit mask of EN field.
	GPIOTE_SUBSCRIBE_SET_EN_Msk = 0x80000000
	// Bit EN.
	GPIOTE_SUBSCRIBE_SET_EN = 0x80000000
	// Disable subscription
	GPIOTE_SUBSCRIBE_SET_EN_Disabled = 0x0
	// Enable subscription
	GPIOTE_SUBSCRIBE_SET_EN_Enabled = 0x1

	// SUBSCRIBE_CLR: Description collection: Subscribe configuration for task CLR[n]
	// Position of CHIDX field.
	GPIOTE_SUBSCRIBE_CLR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	GPIOTE_SUBSCRIBE_CLR_CHIDX_Msk = 0xff
	// Position of EN field.
	GPIOTE_SUBSCRIBE_CLR_EN_Pos = 0x1f
	// Bit mask of EN field.
	GPIOTE_SUBSCRIBE_CLR_EN_Msk = 0x80000000
	// Bit EN.
	GPIOTE_SUBSCRIBE_CLR_EN = 0x80000000
	// Disable subscription
	GPIOTE_SUBSCRIBE_CLR_EN_Disabled = 0x0
	// Enable subscription
	GPIOTE_SUBSCRIBE_CLR_EN_Enabled = 0x1

	// EVENTS_IN: Description collection: Event generated from pin specified in CONFIG[n].PSEL
	// Position of EVENTS_IN field.
	GPIOTE_EVENTS_IN_EVENTS_IN_Pos = 0x0
	// Bit mask of EVENTS_IN field.
	GPIOTE_EVENTS_IN_EVENTS_IN_Msk = 0x1
	// Bit EVENTS_IN.
	GPIOTE_EVENTS_IN_EVENTS_IN = 0x1
	// Event not generated
	GPIOTE_EVENTS_IN_EVENTS_IN_NotGenerated = 0x0
	// Event generated
	GPIOTE_EVENTS_IN_EVENTS_IN_Generated = 0x1

	// EVENTS_PORT: Event generated from multiple input GPIO pins with SENSE mechanism enabled
	// Position of EVENTS_PORT field.
	GPIOTE_EVENTS_PORT_EVENTS_PORT_Pos = 0x0
	// Bit mask of EVENTS_PORT field.
	GPIOTE_EVENTS_PORT_EVENTS_PORT_Msk = 0x1
	// Bit EVENTS_PORT.
	GPIOTE_EVENTS_PORT_EVENTS_PORT = 0x1
	// Event not generated
	GPIOTE_EVENTS_PORT_EVENTS_PORT_NotGenerated = 0x0
	// Event generated
	GPIOTE_EVENTS_PORT_EVENTS_PORT_Generated = 0x1

	// PUBLISH_IN: Description collection: Publish configuration for event IN[n]
	// Position of CHIDX field.
	GPIOTE_PUBLISH_IN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	GPIOTE_PUBLISH_IN_CHIDX_Msk = 0xff
	// Position of EN field.
	GPIOTE_PUBLISH_IN_EN_Pos = 0x1f
	// Bit mask of EN field.
	GPIOTE_PUBLISH_IN_EN_Msk = 0x80000000
	// Bit EN.
	GPIOTE_PUBLISH_IN_EN = 0x80000000
	// Disable publishing
	GPIOTE_PUBLISH_IN_EN_Disabled = 0x0
	// Enable publishing
	GPIOTE_PUBLISH_IN_EN_Enabled = 0x1

	// PUBLISH_PORT: Publish configuration for event PORT
	// Position of CHIDX field.
	GPIOTE_PUBLISH_PORT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	GPIOTE_PUBLISH_PORT_CHIDX_Msk = 0xff
	// Position of EN field.
	GPIOTE_PUBLISH_PORT_EN_Pos = 0x1f
	// Bit mask of EN field.
	GPIOTE_PUBLISH_PORT_EN_Msk = 0x80000000
	// Bit EN.
	GPIOTE_PUBLISH_PORT_EN = 0x80000000
	// Disable publishing
	GPIOTE_PUBLISH_PORT_EN_Disabled = 0x0
	// Enable publishing
	GPIOTE_PUBLISH_PORT_EN_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of IN0 field.
	GPIOTE_INTENSET_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	GPIOTE_INTENSET_IN0_Msk = 0x1
	// Bit IN0.
	GPIOTE_INTENSET_IN0 = 0x1
	// Read: Disabled
	GPIOTE_INTENSET_IN0_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN0_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN0_Set = 0x1
	// Position of IN1 field.
	GPIOTE_INTENSET_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	GPIOTE_INTENSET_IN1_Msk = 0x2
	// Bit IN1.
	GPIOTE_INTENSET_IN1 = 0x2
	// Read: Disabled
	GPIOTE_INTENSET_IN1_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN1_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN1_Set = 0x1
	// Position of IN2 field.
	GPIOTE_INTENSET_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	GPIOTE_INTENSET_IN2_Msk = 0x4
	// Bit IN2.
	GPIOTE_INTENSET_IN2 = 0x4
	// Read: Disabled
	GPIOTE_INTENSET_IN2_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN2_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN2_Set = 0x1
	// Position of IN3 field.
	GPIOTE_INTENSET_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	GPIOTE_INTENSET_IN3_Msk = 0x8
	// Bit IN3.
	GPIOTE_INTENSET_IN3 = 0x8
	// Read: Disabled
	GPIOTE_INTENSET_IN3_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN3_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN3_Set = 0x1
	// Position of IN4 field.
	GPIOTE_INTENSET_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	GPIOTE_INTENSET_IN4_Msk = 0x10
	// Bit IN4.
	GPIOTE_INTENSET_IN4 = 0x10
	// Read: Disabled
	GPIOTE_INTENSET_IN4_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN4_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN4_Set = 0x1
	// Position of IN5 field.
	GPIOTE_INTENSET_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	GPIOTE_INTENSET_IN5_Msk = 0x20
	// Bit IN5.
	GPIOTE_INTENSET_IN5 = 0x20
	// Read: Disabled
	GPIOTE_INTENSET_IN5_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN5_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN5_Set = 0x1
	// Position of IN6 field.
	GPIOTE_INTENSET_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	GPIOTE_INTENSET_IN6_Msk = 0x40
	// Bit IN6.
	GPIOTE_INTENSET_IN6 = 0x40
	// Read: Disabled
	GPIOTE_INTENSET_IN6_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN6_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN6_Set = 0x1
	// Position of IN7 field.
	GPIOTE_INTENSET_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	GPIOTE_INTENSET_IN7_Msk = 0x80
	// Bit IN7.
	GPIOTE_INTENSET_IN7 = 0x80
	// Read: Disabled
	GPIOTE_INTENSET_IN7_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN7_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN7_Set = 0x1
	// Position of PORT field.
	GPIOTE_INTENSET_PORT_Pos = 0x1f
	// Bit mask of PORT field.
	GPIOTE_INTENSET_PORT_Msk = 0x80000000
	// Bit PORT.
	GPIOTE_INTENSET_PORT = 0x80000000
	// Read: Disabled
	GPIOTE_INTENSET_PORT_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_PORT_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_PORT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of IN0 field.
	GPIOTE_INTENCLR_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	GPIOTE_INTENCLR_IN0_Msk = 0x1
	// Bit IN0.
	GPIOTE_INTENCLR_IN0 = 0x1
	// Read: Disabled
	GPIOTE_INTENCLR_IN0_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN0_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN0_Clear = 0x1
	// Position of IN1 field.
	GPIOTE_INTENCLR_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	GPIOTE_INTENCLR_IN1_Msk = 0x2
	// Bit IN1.
	GPIOTE_INTENCLR_IN1 = 0x2
	// Read: Disabled
	GPIOTE_INTENCLR_IN1_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN1_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN1_Clear = 0x1
	// Position of IN2 field.
	GPIOTE_INTENCLR_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	GPIOTE_INTENCLR_IN2_Msk = 0x4
	// Bit IN2.
	GPIOTE_INTENCLR_IN2 = 0x4
	// Read: Disabled
	GPIOTE_INTENCLR_IN2_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN2_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN2_Clear = 0x1
	// Position of IN3 field.
	GPIOTE_INTENCLR_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	GPIOTE_INTENCLR_IN3_Msk = 0x8
	// Bit IN3.
	GPIOTE_INTENCLR_IN3 = 0x8
	// Read: Disabled
	GPIOTE_INTENCLR_IN3_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN3_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN3_Clear = 0x1
	// Position of IN4 field.
	GPIOTE_INTENCLR_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	GPIOTE_INTENCLR_IN4_Msk = 0x10
	// Bit IN4.
	GPIOTE_INTENCLR_IN4 = 0x10
	// Read: Disabled
	GPIOTE_INTENCLR_IN4_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN4_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN4_Clear = 0x1
	// Position of IN5 field.
	GPIOTE_INTENCLR_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	GPIOTE_INTENCLR_IN5_Msk = 0x20
	// Bit IN5.
	GPIOTE_INTENCLR_IN5 = 0x20
	// Read: Disabled
	GPIOTE_INTENCLR_IN5_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN5_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN5_Clear = 0x1
	// Position of IN6 field.
	GPIOTE_INTENCLR_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	GPIOTE_INTENCLR_IN6_Msk = 0x40
	// Bit IN6.
	GPIOTE_INTENCLR_IN6 = 0x40
	// Read: Disabled
	GPIOTE_INTENCLR_IN6_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN6_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN6_Clear = 0x1
	// Position of IN7 field.
	GPIOTE_INTENCLR_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	GPIOTE_INTENCLR_IN7_Msk = 0x80
	// Bit IN7.
	GPIOTE_INTENCLR_IN7 = 0x80
	// Read: Disabled
	GPIOTE_INTENCLR_IN7_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN7_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN7_Clear = 0x1
	// Position of PORT field.
	GPIOTE_INTENCLR_PORT_Pos = 0x1f
	// Bit mask of PORT field.
	GPIOTE_INTENCLR_PORT_Msk = 0x80000000
	// Bit PORT.
	GPIOTE_INTENCLR_PORT = 0x80000000
	// Read: Disabled
	GPIOTE_INTENCLR_PORT_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_PORT_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_PORT_Clear = 0x1

	// LATENCY: Latency selection for Event mode (MODE=Event) with rising or falling edge detection on the pin.
	// Position of LATENCY field.
	GPIOTE_LATENCY_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	GPIOTE_LATENCY_LATENCY_Msk = 0x1
	// Bit LATENCY.
	GPIOTE_LATENCY_LATENCY = 0x1
	// Low power setting, for signals with minimum hold time tGPIOTE,HOLD,LP; refer to Electrical specification section
	GPIOTE_LATENCY_LATENCY_LowPower = 0x0
	// Low latency setting, for signals with minimum hold time tGPIOTE,HOLD,LL; refer to Electrical specification section
	GPIOTE_LATENCY_LATENCY_LowLatency = 0x1

	// CONFIG: Description collection: Configuration for OUT[n], SET[n], and CLR[n] tasks and IN[n] event
	// Position of MODE field.
	GPIOTE_CONFIG_MODE_Pos = 0x0
	// Bit mask of MODE field.
	GPIOTE_CONFIG_MODE_Msk = 0x3
	// Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module.
	GPIOTE_CONFIG_MODE_Disabled = 0x0
	// Event mode
	GPIOTE_CONFIG_MODE_Event = 0x1
	// Task mode
	GPIOTE_CONFIG_MODE_Task = 0x3
	// Position of PSEL field.
	GPIOTE_CONFIG_PSEL_Pos = 0x8
	// Bit mask of PSEL field.
	GPIOTE_CONFIG_PSEL_Msk = 0x1f00
	// Position of PORT field.
	GPIOTE_CONFIG_PORT_Pos = 0xd
	// Bit mask of PORT field.
	GPIOTE_CONFIG_PORT_Msk = 0x2000
	// Bit PORT.
	GPIOTE_CONFIG_PORT = 0x2000
	// Position of POLARITY field.
	GPIOTE_CONFIG_POLARITY_Pos = 0x10
	// Bit mask of POLARITY field.
	GPIOTE_CONFIG_POLARITY_Msk = 0x30000
	// Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.
	GPIOTE_CONFIG_POLARITY_None = 0x0
	// Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.
	GPIOTE_CONFIG_POLARITY_LoToHi = 0x1
	// Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.
	GPIOTE_CONFIG_POLARITY_HiToLo = 0x2
	// Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.
	GPIOTE_CONFIG_POLARITY_Toggle = 0x3
	// Position of OUTINIT field.
	GPIOTE_CONFIG_OUTINIT_Pos = 0x14
	// Bit mask of OUTINIT field.
	GPIOTE_CONFIG_OUTINIT_Msk = 0x100000
	// Bit OUTINIT.
	GPIOTE_CONFIG_OUTINIT = 0x100000
	// Task mode: Initial value of pin before task triggering is low
	GPIOTE_CONFIG_OUTINIT_Low = 0x0
	// Task mode: Initial value of pin before task triggering is high
	GPIOTE_CONFIG_OUTINIT_High = 0x1
)

// Constants for SAADC_NS: Analog to Digital Converter 0
const (
	// TASKS_START: Start the ADC and prepare the result buffer in RAM
	// Position of TASKS_START field.
	SAADC_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	SAADC_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	SAADC_TASKS_START_TASKS_START = 0x1
	// Trigger task
	SAADC_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_SAMPLE: Take one ADC sample, if scan is enabled all channels are sampled
	// Position of TASKS_SAMPLE field.
	SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Pos = 0x0
	// Bit mask of TASKS_SAMPLE field.
	SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Msk = 0x1
	// Bit TASKS_SAMPLE.
	SAADC_TASKS_SAMPLE_TASKS_SAMPLE = 0x1
	// Trigger task
	SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Trigger = 0x1

	// TASKS_STOP: Stop the ADC and terminate any on-going conversion
	// Position of TASKS_STOP field.
	SAADC_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	SAADC_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	SAADC_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	SAADC_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_CALIBRATEOFFSET: Starts offset auto-calibration
	// Position of TASKS_CALIBRATEOFFSET field.
	SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Pos = 0x0
	// Bit mask of TASKS_CALIBRATEOFFSET field.
	SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Msk = 0x1
	// Bit TASKS_CALIBRATEOFFSET.
	SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET = 0x1
	// Trigger task
	SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	SAADC_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	SAADC_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	SAADC_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_SAMPLE: Subscribe configuration for task SAMPLE
	// Position of CHIDX field.
	SAADC_SUBSCRIBE_SAMPLE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_SUBSCRIBE_SAMPLE_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_SUBSCRIBE_SAMPLE_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_SUBSCRIBE_SAMPLE_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_SUBSCRIBE_SAMPLE_EN = 0x80000000
	// Disable subscription
	SAADC_SUBSCRIBE_SAMPLE_EN_Disabled = 0x0
	// Enable subscription
	SAADC_SUBSCRIBE_SAMPLE_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	SAADC_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	SAADC_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	SAADC_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_CALIBRATEOFFSET: Subscribe configuration for task CALIBRATEOFFSET
	// Position of CHIDX field.
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_EN = 0x80000000
	// Disable subscription
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_EN_Disabled = 0x0
	// Enable subscription
	SAADC_SUBSCRIBE_CALIBRATEOFFSET_EN_Enabled = 0x1

	// EVENTS_STARTED: The ADC has started
	// Position of EVENTS_STARTED field.
	SAADC_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	SAADC_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	SAADC_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	SAADC_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// EVENTS_END: The ADC has filled up the Result buffer
	// Position of EVENTS_END field.
	SAADC_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	SAADC_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	SAADC_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	SAADC_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_DONE: A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM.
	// Position of EVENTS_DONE field.
	SAADC_EVENTS_DONE_EVENTS_DONE_Pos = 0x0
	// Bit mask of EVENTS_DONE field.
	SAADC_EVENTS_DONE_EVENTS_DONE_Msk = 0x1
	// Bit EVENTS_DONE.
	SAADC_EVENTS_DONE_EVENTS_DONE = 0x1
	// Event not generated
	SAADC_EVENTS_DONE_EVENTS_DONE_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_DONE_EVENTS_DONE_Generated = 0x1

	// EVENTS_RESULTDONE: A result is ready to get transferred to RAM.
	// Position of EVENTS_RESULTDONE field.
	SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Pos = 0x0
	// Bit mask of EVENTS_RESULTDONE field.
	SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Msk = 0x1
	// Bit EVENTS_RESULTDONE.
	SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE = 0x1
	// Event not generated
	SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Generated = 0x1

	// EVENTS_CALIBRATEDONE: Calibration is complete
	// Position of EVENTS_CALIBRATEDONE field.
	SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Pos = 0x0
	// Bit mask of EVENTS_CALIBRATEDONE field.
	SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Msk = 0x1
	// Bit EVENTS_CALIBRATEDONE.
	SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE = 0x1
	// Event not generated
	SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Generated = 0x1

	// EVENTS_STOPPED: The ADC has stopped
	// Position of EVENTS_STOPPED field.
	SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	SAADC_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	SAADC_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_CH.LIMITH: Description cluster: Last results is equal or above CH[n].LIMIT.HIGH
	// Position of LIMITH field.
	SAADC_EVENTS_CH_LIMITH_LIMITH_Pos = 0x0
	// Bit mask of LIMITH field.
	SAADC_EVENTS_CH_LIMITH_LIMITH_Msk = 0x1
	// Bit LIMITH.
	SAADC_EVENTS_CH_LIMITH_LIMITH = 0x1
	// Event not generated
	SAADC_EVENTS_CH_LIMITH_LIMITH_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_CH_LIMITH_LIMITH_Generated = 0x1

	// EVENTS_CH.LIMITL: Description cluster: Last results is equal or below CH[n].LIMIT.LOW
	// Position of LIMITL field.
	SAADC_EVENTS_CH_LIMITL_LIMITL_Pos = 0x0
	// Bit mask of LIMITL field.
	SAADC_EVENTS_CH_LIMITL_LIMITL_Msk = 0x1
	// Bit LIMITL.
	SAADC_EVENTS_CH_LIMITL_LIMITL = 0x1
	// Event not generated
	SAADC_EVENTS_CH_LIMITL_LIMITL_NotGenerated = 0x0
	// Event generated
	SAADC_EVENTS_CH_LIMITL_LIMITL_Generated = 0x1

	// PUBLISH_STARTED: Publish configuration for event STARTED
	// Position of CHIDX field.
	SAADC_PUBLISH_STARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_STARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_STARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_STARTED_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_STARTED_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_STARTED_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_STARTED_EN_Enabled = 0x1

	// PUBLISH_END: Publish configuration for event END
	// Position of CHIDX field.
	SAADC_PUBLISH_END_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_END_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_END_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_END_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_END_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_END_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_END_EN_Enabled = 0x1

	// PUBLISH_DONE: Publish configuration for event DONE
	// Position of CHIDX field.
	SAADC_PUBLISH_DONE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_DONE_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_DONE_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_DONE_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_DONE_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_DONE_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_DONE_EN_Enabled = 0x1

	// PUBLISH_RESULTDONE: Publish configuration for event RESULTDONE
	// Position of CHIDX field.
	SAADC_PUBLISH_RESULTDONE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_RESULTDONE_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_RESULTDONE_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_RESULTDONE_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_RESULTDONE_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_RESULTDONE_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_RESULTDONE_EN_Enabled = 0x1

	// PUBLISH_CALIBRATEDONE: Publish configuration for event CALIBRATEDONE
	// Position of CHIDX field.
	SAADC_PUBLISH_CALIBRATEDONE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_CALIBRATEDONE_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_CALIBRATEDONE_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_CALIBRATEDONE_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_CALIBRATEDONE_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_CALIBRATEDONE_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_CALIBRATEDONE_EN_Enabled = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	SAADC_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_CH.LIMITH: Description cluster: Publish configuration for event CH[n].LIMITH
	// Position of CHIDX field.
	SAADC_PUBLISH_CH_LIMITH_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_CH_LIMITH_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_CH_LIMITH_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_CH_LIMITH_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_CH_LIMITH_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_CH_LIMITH_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_CH_LIMITH_EN_Enabled = 0x1

	// PUBLISH_CH.LIMITL: Description cluster: Publish configuration for event CH[n].LIMITL
	// Position of CHIDX field.
	SAADC_PUBLISH_CH_LIMITL_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	SAADC_PUBLISH_CH_LIMITL_CHIDX_Msk = 0xff
	// Position of EN field.
	SAADC_PUBLISH_CH_LIMITL_EN_Pos = 0x1f
	// Bit mask of EN field.
	SAADC_PUBLISH_CH_LIMITL_EN_Msk = 0x80000000
	// Bit EN.
	SAADC_PUBLISH_CH_LIMITL_EN = 0x80000000
	// Disable publishing
	SAADC_PUBLISH_CH_LIMITL_EN_Disabled = 0x0
	// Enable publishing
	SAADC_PUBLISH_CH_LIMITL_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STARTED field.
	SAADC_INTEN_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	SAADC_INTEN_STARTED_Msk = 0x1
	// Bit STARTED.
	SAADC_INTEN_STARTED = 0x1
	// Disable
	SAADC_INTEN_STARTED_Disabled = 0x0
	// Enable
	SAADC_INTEN_STARTED_Enabled = 0x1
	// Position of END field.
	SAADC_INTEN_END_Pos = 0x1
	// Bit mask of END field.
	SAADC_INTEN_END_Msk = 0x2
	// Bit END.
	SAADC_INTEN_END = 0x2
	// Disable
	SAADC_INTEN_END_Disabled = 0x0
	// Enable
	SAADC_INTEN_END_Enabled = 0x1
	// Position of DONE field.
	SAADC_INTEN_DONE_Pos = 0x2
	// Bit mask of DONE field.
	SAADC_INTEN_DONE_Msk = 0x4
	// Bit DONE.
	SAADC_INTEN_DONE = 0x4
	// Disable
	SAADC_INTEN_DONE_Disabled = 0x0
	// Enable
	SAADC_INTEN_DONE_Enabled = 0x1
	// Position of RESULTDONE field.
	SAADC_INTEN_RESULTDONE_Pos = 0x3
	// Bit mask of RESULTDONE field.
	SAADC_INTEN_RESULTDONE_Msk = 0x8
	// Bit RESULTDONE.
	SAADC_INTEN_RESULTDONE = 0x8
	// Disable
	SAADC_INTEN_RESULTDONE_Disabled = 0x0
	// Enable
	SAADC_INTEN_RESULTDONE_Enabled = 0x1
	// Position of CALIBRATEDONE field.
	SAADC_INTEN_CALIBRATEDONE_Pos = 0x4
	// Bit mask of CALIBRATEDONE field.
	SAADC_INTEN_CALIBRATEDONE_Msk = 0x10
	// Bit CALIBRATEDONE.
	SAADC_INTEN_CALIBRATEDONE = 0x10
	// Disable
	SAADC_INTEN_CALIBRATEDONE_Disabled = 0x0
	// Enable
	SAADC_INTEN_CALIBRATEDONE_Enabled = 0x1
	// Position of STOPPED field.
	SAADC_INTEN_STOPPED_Pos = 0x5
	// Bit mask of STOPPED field.
	SAADC_INTEN_STOPPED_Msk = 0x20
	// Bit STOPPED.
	SAADC_INTEN_STOPPED = 0x20
	// Disable
	SAADC_INTEN_STOPPED_Disabled = 0x0
	// Enable
	SAADC_INTEN_STOPPED_Enabled = 0x1
	// Position of CH0LIMITH field.
	SAADC_INTEN_CH0LIMITH_Pos = 0x6
	// Bit mask of CH0LIMITH field.
	SAADC_INTEN_CH0LIMITH_Msk = 0x40
	// Bit CH0LIMITH.
	SAADC_INTEN_CH0LIMITH = 0x40
	// Disable
	SAADC_INTEN_CH0LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH0LIMITH_Enabled = 0x1
	// Position of CH0LIMITL field.
	SAADC_INTEN_CH0LIMITL_Pos = 0x7
	// Bit mask of CH0LIMITL field.
	SAADC_INTEN_CH0LIMITL_Msk = 0x80
	// Bit CH0LIMITL.
	SAADC_INTEN_CH0LIMITL = 0x80
	// Disable
	SAADC_INTEN_CH0LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH0LIMITL_Enabled = 0x1
	// Position of CH1LIMITH field.
	SAADC_INTEN_CH1LIMITH_Pos = 0x8
	// Bit mask of CH1LIMITH field.
	SAADC_INTEN_CH1LIMITH_Msk = 0x100
	// Bit CH1LIMITH.
	SAADC_INTEN_CH1LIMITH = 0x100
	// Disable
	SAADC_INTEN_CH1LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH1LIMITH_Enabled = 0x1
	// Position of CH1LIMITL field.
	SAADC_INTEN_CH1LIMITL_Pos = 0x9
	// Bit mask of CH1LIMITL field.
	SAADC_INTEN_CH1LIMITL_Msk = 0x200
	// Bit CH1LIMITL.
	SAADC_INTEN_CH1LIMITL = 0x200
	// Disable
	SAADC_INTEN_CH1LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH1LIMITL_Enabled = 0x1
	// Position of CH2LIMITH field.
	SAADC_INTEN_CH2LIMITH_Pos = 0xa
	// Bit mask of CH2LIMITH field.
	SAADC_INTEN_CH2LIMITH_Msk = 0x400
	// Bit CH2LIMITH.
	SAADC_INTEN_CH2LIMITH = 0x400
	// Disable
	SAADC_INTEN_CH2LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH2LIMITH_Enabled = 0x1
	// Position of CH2LIMITL field.
	SAADC_INTEN_CH2LIMITL_Pos = 0xb
	// Bit mask of CH2LIMITL field.
	SAADC_INTEN_CH2LIMITL_Msk = 0x800
	// Bit CH2LIMITL.
	SAADC_INTEN_CH2LIMITL = 0x800
	// Disable
	SAADC_INTEN_CH2LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH2LIMITL_Enabled = 0x1
	// Position of CH3LIMITH field.
	SAADC_INTEN_CH3LIMITH_Pos = 0xc
	// Bit mask of CH3LIMITH field.
	SAADC_INTEN_CH3LIMITH_Msk = 0x1000
	// Bit CH3LIMITH.
	SAADC_INTEN_CH3LIMITH = 0x1000
	// Disable
	SAADC_INTEN_CH3LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH3LIMITH_Enabled = 0x1
	// Position of CH3LIMITL field.
	SAADC_INTEN_CH3LIMITL_Pos = 0xd
	// Bit mask of CH3LIMITL field.
	SAADC_INTEN_CH3LIMITL_Msk = 0x2000
	// Bit CH3LIMITL.
	SAADC_INTEN_CH3LIMITL = 0x2000
	// Disable
	SAADC_INTEN_CH3LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH3LIMITL_Enabled = 0x1
	// Position of CH4LIMITH field.
	SAADC_INTEN_CH4LIMITH_Pos = 0xe
	// Bit mask of CH4LIMITH field.
	SAADC_INTEN_CH4LIMITH_Msk = 0x4000
	// Bit CH4LIMITH.
	SAADC_INTEN_CH4LIMITH = 0x4000
	// Disable
	SAADC_INTEN_CH4LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH4LIMITH_Enabled = 0x1
	// Position of CH4LIMITL field.
	SAADC_INTEN_CH4LIMITL_Pos = 0xf
	// Bit mask of CH4LIMITL field.
	SAADC_INTEN_CH4LIMITL_Msk = 0x8000
	// Bit CH4LIMITL.
	SAADC_INTEN_CH4LIMITL = 0x8000
	// Disable
	SAADC_INTEN_CH4LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH4LIMITL_Enabled = 0x1
	// Position of CH5LIMITH field.
	SAADC_INTEN_CH5LIMITH_Pos = 0x10
	// Bit mask of CH5LIMITH field.
	SAADC_INTEN_CH5LIMITH_Msk = 0x10000
	// Bit CH5LIMITH.
	SAADC_INTEN_CH5LIMITH = 0x10000
	// Disable
	SAADC_INTEN_CH5LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH5LIMITH_Enabled = 0x1
	// Position of CH5LIMITL field.
	SAADC_INTEN_CH5LIMITL_Pos = 0x11
	// Bit mask of CH5LIMITL field.
	SAADC_INTEN_CH5LIMITL_Msk = 0x20000
	// Bit CH5LIMITL.
	SAADC_INTEN_CH5LIMITL = 0x20000
	// Disable
	SAADC_INTEN_CH5LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH5LIMITL_Enabled = 0x1
	// Position of CH6LIMITH field.
	SAADC_INTEN_CH6LIMITH_Pos = 0x12
	// Bit mask of CH6LIMITH field.
	SAADC_INTEN_CH6LIMITH_Msk = 0x40000
	// Bit CH6LIMITH.
	SAADC_INTEN_CH6LIMITH = 0x40000
	// Disable
	SAADC_INTEN_CH6LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH6LIMITH_Enabled = 0x1
	// Position of CH6LIMITL field.
	SAADC_INTEN_CH6LIMITL_Pos = 0x13
	// Bit mask of CH6LIMITL field.
	SAADC_INTEN_CH6LIMITL_Msk = 0x80000
	// Bit CH6LIMITL.
	SAADC_INTEN_CH6LIMITL = 0x80000
	// Disable
	SAADC_INTEN_CH6LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH6LIMITL_Enabled = 0x1
	// Position of CH7LIMITH field.
	SAADC_INTEN_CH7LIMITH_Pos = 0x14
	// Bit mask of CH7LIMITH field.
	SAADC_INTEN_CH7LIMITH_Msk = 0x100000
	// Bit CH7LIMITH.
	SAADC_INTEN_CH7LIMITH = 0x100000
	// Disable
	SAADC_INTEN_CH7LIMITH_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH7LIMITH_Enabled = 0x1
	// Position of CH7LIMITL field.
	SAADC_INTEN_CH7LIMITL_Pos = 0x15
	// Bit mask of CH7LIMITL field.
	SAADC_INTEN_CH7LIMITL_Msk = 0x200000
	// Bit CH7LIMITL.
	SAADC_INTEN_CH7LIMITL = 0x200000
	// Disable
	SAADC_INTEN_CH7LIMITL_Disabled = 0x0
	// Enable
	SAADC_INTEN_CH7LIMITL_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STARTED field.
	SAADC_INTENSET_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	SAADC_INTENSET_STARTED_Msk = 0x1
	// Bit STARTED.
	SAADC_INTENSET_STARTED = 0x1
	// Read: Disabled
	SAADC_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_STARTED_Enabled = 0x1
	// Enable
	SAADC_INTENSET_STARTED_Set = 0x1
	// Position of END field.
	SAADC_INTENSET_END_Pos = 0x1
	// Bit mask of END field.
	SAADC_INTENSET_END_Msk = 0x2
	// Bit END.
	SAADC_INTENSET_END = 0x2
	// Read: Disabled
	SAADC_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_END_Enabled = 0x1
	// Enable
	SAADC_INTENSET_END_Set = 0x1
	// Position of DONE field.
	SAADC_INTENSET_DONE_Pos = 0x2
	// Bit mask of DONE field.
	SAADC_INTENSET_DONE_Msk = 0x4
	// Bit DONE.
	SAADC_INTENSET_DONE = 0x4
	// Read: Disabled
	SAADC_INTENSET_DONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_DONE_Enabled = 0x1
	// Enable
	SAADC_INTENSET_DONE_Set = 0x1
	// Position of RESULTDONE field.
	SAADC_INTENSET_RESULTDONE_Pos = 0x3
	// Bit mask of RESULTDONE field.
	SAADC_INTENSET_RESULTDONE_Msk = 0x8
	// Bit RESULTDONE.
	SAADC_INTENSET_RESULTDONE = 0x8
	// Read: Disabled
	SAADC_INTENSET_RESULTDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_RESULTDONE_Enabled = 0x1
	// Enable
	SAADC_INTENSET_RESULTDONE_Set = 0x1
	// Position of CALIBRATEDONE field.
	SAADC_INTENSET_CALIBRATEDONE_Pos = 0x4
	// Bit mask of CALIBRATEDONE field.
	SAADC_INTENSET_CALIBRATEDONE_Msk = 0x10
	// Bit CALIBRATEDONE.
	SAADC_INTENSET_CALIBRATEDONE = 0x10
	// Read: Disabled
	SAADC_INTENSET_CALIBRATEDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CALIBRATEDONE_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CALIBRATEDONE_Set = 0x1
	// Position of STOPPED field.
	SAADC_INTENSET_STOPPED_Pos = 0x5
	// Bit mask of STOPPED field.
	SAADC_INTENSET_STOPPED_Msk = 0x20
	// Bit STOPPED.
	SAADC_INTENSET_STOPPED = 0x20
	// Read: Disabled
	SAADC_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	SAADC_INTENSET_STOPPED_Set = 0x1
	// Position of CH0LIMITH field.
	SAADC_INTENSET_CH0LIMITH_Pos = 0x6
	// Bit mask of CH0LIMITH field.
	SAADC_INTENSET_CH0LIMITH_Msk = 0x40
	// Bit CH0LIMITH.
	SAADC_INTENSET_CH0LIMITH = 0x40
	// Read: Disabled
	SAADC_INTENSET_CH0LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH0LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH0LIMITH_Set = 0x1
	// Position of CH0LIMITL field.
	SAADC_INTENSET_CH0LIMITL_Pos = 0x7
	// Bit mask of CH0LIMITL field.
	SAADC_INTENSET_CH0LIMITL_Msk = 0x80
	// Bit CH0LIMITL.
	SAADC_INTENSET_CH0LIMITL = 0x80
	// Read: Disabled
	SAADC_INTENSET_CH0LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH0LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH0LIMITL_Set = 0x1
	// Position of CH1LIMITH field.
	SAADC_INTENSET_CH1LIMITH_Pos = 0x8
	// Bit mask of CH1LIMITH field.
	SAADC_INTENSET_CH1LIMITH_Msk = 0x100
	// Bit CH1LIMITH.
	SAADC_INTENSET_CH1LIMITH = 0x100
	// Read: Disabled
	SAADC_INTENSET_CH1LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH1LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH1LIMITH_Set = 0x1
	// Position of CH1LIMITL field.
	SAADC_INTENSET_CH1LIMITL_Pos = 0x9
	// Bit mask of CH1LIMITL field.
	SAADC_INTENSET_CH1LIMITL_Msk = 0x200
	// Bit CH1LIMITL.
	SAADC_INTENSET_CH1LIMITL = 0x200
	// Read: Disabled
	SAADC_INTENSET_CH1LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH1LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH1LIMITL_Set = 0x1
	// Position of CH2LIMITH field.
	SAADC_INTENSET_CH2LIMITH_Pos = 0xa
	// Bit mask of CH2LIMITH field.
	SAADC_INTENSET_CH2LIMITH_Msk = 0x400
	// Bit CH2LIMITH.
	SAADC_INTENSET_CH2LIMITH = 0x400
	// Read: Disabled
	SAADC_INTENSET_CH2LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH2LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH2LIMITH_Set = 0x1
	// Position of CH2LIMITL field.
	SAADC_INTENSET_CH2LIMITL_Pos = 0xb
	// Bit mask of CH2LIMITL field.
	SAADC_INTENSET_CH2LIMITL_Msk = 0x800
	// Bit CH2LIMITL.
	SAADC_INTENSET_CH2LIMITL = 0x800
	// Read: Disabled
	SAADC_INTENSET_CH2LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH2LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH2LIMITL_Set = 0x1
	// Position of CH3LIMITH field.
	SAADC_INTENSET_CH3LIMITH_Pos = 0xc
	// Bit mask of CH3LIMITH field.
	SAADC_INTENSET_CH3LIMITH_Msk = 0x1000
	// Bit CH3LIMITH.
	SAADC_INTENSET_CH3LIMITH = 0x1000
	// Read: Disabled
	SAADC_INTENSET_CH3LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH3LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH3LIMITH_Set = 0x1
	// Position of CH3LIMITL field.
	SAADC_INTENSET_CH3LIMITL_Pos = 0xd
	// Bit mask of CH3LIMITL field.
	SAADC_INTENSET_CH3LIMITL_Msk = 0x2000
	// Bit CH3LIMITL.
	SAADC_INTENSET_CH3LIMITL = 0x2000
	// Read: Disabled
	SAADC_INTENSET_CH3LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH3LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH3LIMITL_Set = 0x1
	// Position of CH4LIMITH field.
	SAADC_INTENSET_CH4LIMITH_Pos = 0xe
	// Bit mask of CH4LIMITH field.
	SAADC_INTENSET_CH4LIMITH_Msk = 0x4000
	// Bit CH4LIMITH.
	SAADC_INTENSET_CH4LIMITH = 0x4000
	// Read: Disabled
	SAADC_INTENSET_CH4LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH4LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH4LIMITH_Set = 0x1
	// Position of CH4LIMITL field.
	SAADC_INTENSET_CH4LIMITL_Pos = 0xf
	// Bit mask of CH4LIMITL field.
	SAADC_INTENSET_CH4LIMITL_Msk = 0x8000
	// Bit CH4LIMITL.
	SAADC_INTENSET_CH4LIMITL = 0x8000
	// Read: Disabled
	SAADC_INTENSET_CH4LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH4LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH4LIMITL_Set = 0x1
	// Position of CH5LIMITH field.
	SAADC_INTENSET_CH5LIMITH_Pos = 0x10
	// Bit mask of CH5LIMITH field.
	SAADC_INTENSET_CH5LIMITH_Msk = 0x10000
	// Bit CH5LIMITH.
	SAADC_INTENSET_CH5LIMITH = 0x10000
	// Read: Disabled
	SAADC_INTENSET_CH5LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH5LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH5LIMITH_Set = 0x1
	// Position of CH5LIMITL field.
	SAADC_INTENSET_CH5LIMITL_Pos = 0x11
	// Bit mask of CH5LIMITL field.
	SAADC_INTENSET_CH5LIMITL_Msk = 0x20000
	// Bit CH5LIMITL.
	SAADC_INTENSET_CH5LIMITL = 0x20000
	// Read: Disabled
	SAADC_INTENSET_CH5LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH5LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH5LIMITL_Set = 0x1
	// Position of CH6LIMITH field.
	SAADC_INTENSET_CH6LIMITH_Pos = 0x12
	// Bit mask of CH6LIMITH field.
	SAADC_INTENSET_CH6LIMITH_Msk = 0x40000
	// Bit CH6LIMITH.
	SAADC_INTENSET_CH6LIMITH = 0x40000
	// Read: Disabled
	SAADC_INTENSET_CH6LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH6LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH6LIMITH_Set = 0x1
	// Position of CH6LIMITL field.
	SAADC_INTENSET_CH6LIMITL_Pos = 0x13
	// Bit mask of CH6LIMITL field.
	SAADC_INTENSET_CH6LIMITL_Msk = 0x80000
	// Bit CH6LIMITL.
	SAADC_INTENSET_CH6LIMITL = 0x80000
	// Read: Disabled
	SAADC_INTENSET_CH6LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH6LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH6LIMITL_Set = 0x1
	// Position of CH7LIMITH field.
	SAADC_INTENSET_CH7LIMITH_Pos = 0x14
	// Bit mask of CH7LIMITH field.
	SAADC_INTENSET_CH7LIMITH_Msk = 0x100000
	// Bit CH7LIMITH.
	SAADC_INTENSET_CH7LIMITH = 0x100000
	// Read: Disabled
	SAADC_INTENSET_CH7LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH7LIMITH_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH7LIMITH_Set = 0x1
	// Position of CH7LIMITL field.
	SAADC_INTENSET_CH7LIMITL_Pos = 0x15
	// Bit mask of CH7LIMITL field.
	SAADC_INTENSET_CH7LIMITL_Msk = 0x200000
	// Bit CH7LIMITL.
	SAADC_INTENSET_CH7LIMITL = 0x200000
	// Read: Disabled
	SAADC_INTENSET_CH7LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENSET_CH7LIMITL_Enabled = 0x1
	// Enable
	SAADC_INTENSET_CH7LIMITL_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STARTED field.
	SAADC_INTENCLR_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	SAADC_INTENCLR_STARTED_Msk = 0x1
	// Bit STARTED.
	SAADC_INTENCLR_STARTED = 0x1
	// Read: Disabled
	SAADC_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_STARTED_Clear = 0x1
	// Position of END field.
	SAADC_INTENCLR_END_Pos = 0x1
	// Bit mask of END field.
	SAADC_INTENCLR_END_Msk = 0x2
	// Bit END.
	SAADC_INTENCLR_END = 0x2
	// Read: Disabled
	SAADC_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_END_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_END_Clear = 0x1
	// Position of DONE field.
	SAADC_INTENCLR_DONE_Pos = 0x2
	// Bit mask of DONE field.
	SAADC_INTENCLR_DONE_Msk = 0x4
	// Bit DONE.
	SAADC_INTENCLR_DONE = 0x4
	// Read: Disabled
	SAADC_INTENCLR_DONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_DONE_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_DONE_Clear = 0x1
	// Position of RESULTDONE field.
	SAADC_INTENCLR_RESULTDONE_Pos = 0x3
	// Bit mask of RESULTDONE field.
	SAADC_INTENCLR_RESULTDONE_Msk = 0x8
	// Bit RESULTDONE.
	SAADC_INTENCLR_RESULTDONE = 0x8
	// Read: Disabled
	SAADC_INTENCLR_RESULTDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_RESULTDONE_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_RESULTDONE_Clear = 0x1
	// Position of CALIBRATEDONE field.
	SAADC_INTENCLR_CALIBRATEDONE_Pos = 0x4
	// Bit mask of CALIBRATEDONE field.
	SAADC_INTENCLR_CALIBRATEDONE_Msk = 0x10
	// Bit CALIBRATEDONE.
	SAADC_INTENCLR_CALIBRATEDONE = 0x10
	// Read: Disabled
	SAADC_INTENCLR_CALIBRATEDONE_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CALIBRATEDONE_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CALIBRATEDONE_Clear = 0x1
	// Position of STOPPED field.
	SAADC_INTENCLR_STOPPED_Pos = 0x5
	// Bit mask of STOPPED field.
	SAADC_INTENCLR_STOPPED_Msk = 0x20
	// Bit STOPPED.
	SAADC_INTENCLR_STOPPED = 0x20
	// Read: Disabled
	SAADC_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_STOPPED_Clear = 0x1
	// Position of CH0LIMITH field.
	SAADC_INTENCLR_CH0LIMITH_Pos = 0x6
	// Bit mask of CH0LIMITH field.
	SAADC_INTENCLR_CH0LIMITH_Msk = 0x40
	// Bit CH0LIMITH.
	SAADC_INTENCLR_CH0LIMITH = 0x40
	// Read: Disabled
	SAADC_INTENCLR_CH0LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH0LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH0LIMITH_Clear = 0x1
	// Position of CH0LIMITL field.
	SAADC_INTENCLR_CH0LIMITL_Pos = 0x7
	// Bit mask of CH0LIMITL field.
	SAADC_INTENCLR_CH0LIMITL_Msk = 0x80
	// Bit CH0LIMITL.
	SAADC_INTENCLR_CH0LIMITL = 0x80
	// Read: Disabled
	SAADC_INTENCLR_CH0LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH0LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH0LIMITL_Clear = 0x1
	// Position of CH1LIMITH field.
	SAADC_INTENCLR_CH1LIMITH_Pos = 0x8
	// Bit mask of CH1LIMITH field.
	SAADC_INTENCLR_CH1LIMITH_Msk = 0x100
	// Bit CH1LIMITH.
	SAADC_INTENCLR_CH1LIMITH = 0x100
	// Read: Disabled
	SAADC_INTENCLR_CH1LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH1LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH1LIMITH_Clear = 0x1
	// Position of CH1LIMITL field.
	SAADC_INTENCLR_CH1LIMITL_Pos = 0x9
	// Bit mask of CH1LIMITL field.
	SAADC_INTENCLR_CH1LIMITL_Msk = 0x200
	// Bit CH1LIMITL.
	SAADC_INTENCLR_CH1LIMITL = 0x200
	// Read: Disabled
	SAADC_INTENCLR_CH1LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH1LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH1LIMITL_Clear = 0x1
	// Position of CH2LIMITH field.
	SAADC_INTENCLR_CH2LIMITH_Pos = 0xa
	// Bit mask of CH2LIMITH field.
	SAADC_INTENCLR_CH2LIMITH_Msk = 0x400
	// Bit CH2LIMITH.
	SAADC_INTENCLR_CH2LIMITH = 0x400
	// Read: Disabled
	SAADC_INTENCLR_CH2LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH2LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH2LIMITH_Clear = 0x1
	// Position of CH2LIMITL field.
	SAADC_INTENCLR_CH2LIMITL_Pos = 0xb
	// Bit mask of CH2LIMITL field.
	SAADC_INTENCLR_CH2LIMITL_Msk = 0x800
	// Bit CH2LIMITL.
	SAADC_INTENCLR_CH2LIMITL = 0x800
	// Read: Disabled
	SAADC_INTENCLR_CH2LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH2LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH2LIMITL_Clear = 0x1
	// Position of CH3LIMITH field.
	SAADC_INTENCLR_CH3LIMITH_Pos = 0xc
	// Bit mask of CH3LIMITH field.
	SAADC_INTENCLR_CH3LIMITH_Msk = 0x1000
	// Bit CH3LIMITH.
	SAADC_INTENCLR_CH3LIMITH = 0x1000
	// Read: Disabled
	SAADC_INTENCLR_CH3LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH3LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH3LIMITH_Clear = 0x1
	// Position of CH3LIMITL field.
	SAADC_INTENCLR_CH3LIMITL_Pos = 0xd
	// Bit mask of CH3LIMITL field.
	SAADC_INTENCLR_CH3LIMITL_Msk = 0x2000
	// Bit CH3LIMITL.
	SAADC_INTENCLR_CH3LIMITL = 0x2000
	// Read: Disabled
	SAADC_INTENCLR_CH3LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH3LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH3LIMITL_Clear = 0x1
	// Position of CH4LIMITH field.
	SAADC_INTENCLR_CH4LIMITH_Pos = 0xe
	// Bit mask of CH4LIMITH field.
	SAADC_INTENCLR_CH4LIMITH_Msk = 0x4000
	// Bit CH4LIMITH.
	SAADC_INTENCLR_CH4LIMITH = 0x4000
	// Read: Disabled
	SAADC_INTENCLR_CH4LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH4LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH4LIMITH_Clear = 0x1
	// Position of CH4LIMITL field.
	SAADC_INTENCLR_CH4LIMITL_Pos = 0xf
	// Bit mask of CH4LIMITL field.
	SAADC_INTENCLR_CH4LIMITL_Msk = 0x8000
	// Bit CH4LIMITL.
	SAADC_INTENCLR_CH4LIMITL = 0x8000
	// Read: Disabled
	SAADC_INTENCLR_CH4LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH4LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH4LIMITL_Clear = 0x1
	// Position of CH5LIMITH field.
	SAADC_INTENCLR_CH5LIMITH_Pos = 0x10
	// Bit mask of CH5LIMITH field.
	SAADC_INTENCLR_CH5LIMITH_Msk = 0x10000
	// Bit CH5LIMITH.
	SAADC_INTENCLR_CH5LIMITH = 0x10000
	// Read: Disabled
	SAADC_INTENCLR_CH5LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH5LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH5LIMITH_Clear = 0x1
	// Position of CH5LIMITL field.
	SAADC_INTENCLR_CH5LIMITL_Pos = 0x11
	// Bit mask of CH5LIMITL field.
	SAADC_INTENCLR_CH5LIMITL_Msk = 0x20000
	// Bit CH5LIMITL.
	SAADC_INTENCLR_CH5LIMITL = 0x20000
	// Read: Disabled
	SAADC_INTENCLR_CH5LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH5LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH5LIMITL_Clear = 0x1
	// Position of CH6LIMITH field.
	SAADC_INTENCLR_CH6LIMITH_Pos = 0x12
	// Bit mask of CH6LIMITH field.
	SAADC_INTENCLR_CH6LIMITH_Msk = 0x40000
	// Bit CH6LIMITH.
	SAADC_INTENCLR_CH6LIMITH = 0x40000
	// Read: Disabled
	SAADC_INTENCLR_CH6LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH6LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH6LIMITH_Clear = 0x1
	// Position of CH6LIMITL field.
	SAADC_INTENCLR_CH6LIMITL_Pos = 0x13
	// Bit mask of CH6LIMITL field.
	SAADC_INTENCLR_CH6LIMITL_Msk = 0x80000
	// Bit CH6LIMITL.
	SAADC_INTENCLR_CH6LIMITL = 0x80000
	// Read: Disabled
	SAADC_INTENCLR_CH6LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH6LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH6LIMITL_Clear = 0x1
	// Position of CH7LIMITH field.
	SAADC_INTENCLR_CH7LIMITH_Pos = 0x14
	// Bit mask of CH7LIMITH field.
	SAADC_INTENCLR_CH7LIMITH_Msk = 0x100000
	// Bit CH7LIMITH.
	SAADC_INTENCLR_CH7LIMITH = 0x100000
	// Read: Disabled
	SAADC_INTENCLR_CH7LIMITH_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH7LIMITH_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH7LIMITH_Clear = 0x1
	// Position of CH7LIMITL field.
	SAADC_INTENCLR_CH7LIMITL_Pos = 0x15
	// Bit mask of CH7LIMITL field.
	SAADC_INTENCLR_CH7LIMITL_Msk = 0x200000
	// Bit CH7LIMITL.
	SAADC_INTENCLR_CH7LIMITL = 0x200000
	// Read: Disabled
	SAADC_INTENCLR_CH7LIMITL_Disabled = 0x0
	// Read: Enabled
	SAADC_INTENCLR_CH7LIMITL_Enabled = 0x1
	// Disable
	SAADC_INTENCLR_CH7LIMITL_Clear = 0x1

	// STATUS: Status
	// Position of STATUS field.
	SAADC_STATUS_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	SAADC_STATUS_STATUS_Msk = 0x1
	// Bit STATUS.
	SAADC_STATUS_STATUS = 0x1
	// ADC is ready. No on-going conversion.
	SAADC_STATUS_STATUS_Ready = 0x0
	// ADC is busy. Single conversion in progress.
	SAADC_STATUS_STATUS_Busy = 0x1

	// ENABLE: Enable or disable ADC
	// Position of ENABLE field.
	SAADC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SAADC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SAADC_ENABLE_ENABLE = 0x1
	// Disable ADC
	SAADC_ENABLE_ENABLE_Disabled = 0x0
	// Enable ADC
	SAADC_ENABLE_ENABLE_Enabled = 0x1

	// CH.PSELP: Description cluster: Input positive pin selection for CH[n]
	// Position of PSELP field.
	SAADC_CH_PSELP_PSELP_Pos = 0x0
	// Bit mask of PSELP field.
	SAADC_CH_PSELP_PSELP_Msk = 0x1f
	// Not connected
	SAADC_CH_PSELP_PSELP_NC = 0x0
	// AIN0
	SAADC_CH_PSELP_PSELP_AnalogInput0 = 0x1
	// AIN1
	SAADC_CH_PSELP_PSELP_AnalogInput1 = 0x2
	// AIN2
	SAADC_CH_PSELP_PSELP_AnalogInput2 = 0x3
	// AIN3
	SAADC_CH_PSELP_PSELP_AnalogInput3 = 0x4
	// AIN4
	SAADC_CH_PSELP_PSELP_AnalogInput4 = 0x5
	// AIN5
	SAADC_CH_PSELP_PSELP_AnalogInput5 = 0x6
	// AIN6
	SAADC_CH_PSELP_PSELP_AnalogInput6 = 0x7
	// AIN7
	SAADC_CH_PSELP_PSELP_AnalogInput7 = 0x8
	// VDD
	SAADC_CH_PSELP_PSELP_VDD = 0x9
	// VDDH/5
	SAADC_CH_PSELP_PSELP_VDDHDIV5 = 0xd

	// CH.PSELN: Description cluster: Input negative pin selection for CH[n]
	// Position of PSELN field.
	SAADC_CH_PSELN_PSELN_Pos = 0x0
	// Bit mask of PSELN field.
	SAADC_CH_PSELN_PSELN_Msk = 0x1f
	// Not connected
	SAADC_CH_PSELN_PSELN_NC = 0x0
	// AIN0
	SAADC_CH_PSELN_PSELN_AnalogInput0 = 0x1
	// AIN1
	SAADC_CH_PSELN_PSELN_AnalogInput1 = 0x2
	// AIN2
	SAADC_CH_PSELN_PSELN_AnalogInput2 = 0x3
	// AIN3
	SAADC_CH_PSELN_PSELN_AnalogInput3 = 0x4
	// AIN4
	SAADC_CH_PSELN_PSELN_AnalogInput4 = 0x5
	// AIN5
	SAADC_CH_PSELN_PSELN_AnalogInput5 = 0x6
	// AIN6
	SAADC_CH_PSELN_PSELN_AnalogInput6 = 0x7
	// AIN7
	SAADC_CH_PSELN_PSELN_AnalogInput7 = 0x8
	// VDD
	SAADC_CH_PSELN_PSELN_VDD = 0x9
	// VDDH/5
	SAADC_CH_PSELN_PSELN_VDDHDIV5 = 0xd

	// CH.CONFIG: Description cluster: Input configuration for CH[n]
	// Position of RESP field.
	SAADC_CH_CONFIG_RESP_Pos = 0x0
	// Bit mask of RESP field.
	SAADC_CH_CONFIG_RESP_Msk = 0x3
	// Bypass resistor ladder
	SAADC_CH_CONFIG_RESP_Bypass = 0x0
	// Pull-down to GND
	SAADC_CH_CONFIG_RESP_Pulldown = 0x1
	// Pull-up to VDD
	SAADC_CH_CONFIG_RESP_Pullup = 0x2
	// Set input at VDD/2
	SAADC_CH_CONFIG_RESP_VDD1_2 = 0x3
	// Position of RESN field.
	SAADC_CH_CONFIG_RESN_Pos = 0x4
	// Bit mask of RESN field.
	SAADC_CH_CONFIG_RESN_Msk = 0x30
	// Bypass resistor ladder
	SAADC_CH_CONFIG_RESN_Bypass = 0x0
	// Pull-down to GND
	SAADC_CH_CONFIG_RESN_Pulldown = 0x1
	// Pull-up to VDD
	SAADC_CH_CONFIG_RESN_Pullup = 0x2
	// Set input at VDD/2
	SAADC_CH_CONFIG_RESN_VDD1_2 = 0x3
	// Position of GAIN field.
	SAADC_CH_CONFIG_GAIN_Pos = 0x8
	// Bit mask of GAIN field.
	SAADC_CH_CONFIG_GAIN_Msk = 0x700
	// 1/6
	SAADC_CH_CONFIG_GAIN_Gain1_6 = 0x0
	// 1/5
	SAADC_CH_CONFIG_GAIN_Gain1_5 = 0x1
	// 1/4
	SAADC_CH_CONFIG_GAIN_Gain1_4 = 0x2
	// 1/3
	SAADC_CH_CONFIG_GAIN_Gain1_3 = 0x3
	// 1/2
	SAADC_CH_CONFIG_GAIN_Gain1_2 = 0x4
	// 1
	SAADC_CH_CONFIG_GAIN_Gain1 = 0x5
	// 2
	SAADC_CH_CONFIG_GAIN_Gain2 = 0x6
	// 4
	SAADC_CH_CONFIG_GAIN_Gain4 = 0x7
	// Position of REFSEL field.
	SAADC_CH_CONFIG_REFSEL_Pos = 0xc
	// Bit mask of REFSEL field.
	SAADC_CH_CONFIG_REFSEL_Msk = 0x1000
	// Bit REFSEL.
	SAADC_CH_CONFIG_REFSEL = 0x1000
	// Internal reference (0.6 V)
	SAADC_CH_CONFIG_REFSEL_Internal = 0x0
	// VDD/4 as reference
	SAADC_CH_CONFIG_REFSEL_VDD1_4 = 0x1
	// Position of TACQ field.
	SAADC_CH_CONFIG_TACQ_Pos = 0x10
	// Bit mask of TACQ field.
	SAADC_CH_CONFIG_TACQ_Msk = 0x70000
	// 3 us
	SAADC_CH_CONFIG_TACQ_3us = 0x0
	// 5 us
	SAADC_CH_CONFIG_TACQ_5us = 0x1
	// 10 us
	SAADC_CH_CONFIG_TACQ_10us = 0x2
	// 15 us
	SAADC_CH_CONFIG_TACQ_15us = 0x3
	// 20 us
	SAADC_CH_CONFIG_TACQ_20us = 0x4
	// 40 us
	SAADC_CH_CONFIG_TACQ_40us = 0x5
	// Position of MODE field.
	SAADC_CH_CONFIG_MODE_Pos = 0x14
	// Bit mask of MODE field.
	SAADC_CH_CONFIG_MODE_Msk = 0x100000
	// Bit MODE.
	SAADC_CH_CONFIG_MODE = 0x100000
	// Single ended, PSELN will be ignored, negative input to ADC shorted to GND
	SAADC_CH_CONFIG_MODE_SE = 0x0
	// Differential
	SAADC_CH_CONFIG_MODE_Diff = 0x1
	// Position of BURST field.
	SAADC_CH_CONFIG_BURST_Pos = 0x18
	// Bit mask of BURST field.
	SAADC_CH_CONFIG_BURST_Msk = 0x1000000
	// Bit BURST.
	SAADC_CH_CONFIG_BURST = 0x1000000
	// Burst mode is disabled (normal operation)
	SAADC_CH_CONFIG_BURST_Disabled = 0x0
	// Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM.
	SAADC_CH_CONFIG_BURST_Enabled = 0x1

	// CH.LIMIT: Description cluster: High/low limits for event monitoring a channel
	// Position of LOW field.
	SAADC_CH_LIMIT_LOW_Pos = 0x0
	// Bit mask of LOW field.
	SAADC_CH_LIMIT_LOW_Msk = 0xffff
	// Position of HIGH field.
	SAADC_CH_LIMIT_HIGH_Pos = 0x10
	// Bit mask of HIGH field.
	SAADC_CH_LIMIT_HIGH_Msk = 0xffff0000

	// RESOLUTION: Resolution configuration
	// Position of VAL field.
	SAADC_RESOLUTION_VAL_Pos = 0x0
	// Bit mask of VAL field.
	SAADC_RESOLUTION_VAL_Msk = 0x7
	// 8 bit
	SAADC_RESOLUTION_VAL_8bit = 0x0
	// 10 bit
	SAADC_RESOLUTION_VAL_10bit = 0x1
	// 12 bit
	SAADC_RESOLUTION_VAL_12bit = 0x2
	// 14 bit
	SAADC_RESOLUTION_VAL_14bit = 0x3

	// OVERSAMPLE: Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
	// Position of OVERSAMPLE field.
	SAADC_OVERSAMPLE_OVERSAMPLE_Pos = 0x0
	// Bit mask of OVERSAMPLE field.
	SAADC_OVERSAMPLE_OVERSAMPLE_Msk = 0xf
	// Bypass oversampling
	SAADC_OVERSAMPLE_OVERSAMPLE_Bypass = 0x0
	// Oversample 2x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over2x = 0x1
	// Oversample 4x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over4x = 0x2
	// Oversample 8x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over8x = 0x3
	// Oversample 16x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over16x = 0x4
	// Oversample 32x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over32x = 0x5
	// Oversample 64x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over64x = 0x6
	// Oversample 128x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over128x = 0x7
	// Oversample 256x
	SAADC_OVERSAMPLE_OVERSAMPLE_Over256x = 0x8

	// SAMPLERATE: Controls normal or continuous sample rate
	// Position of CC field.
	SAADC_SAMPLERATE_CC_Pos = 0x0
	// Bit mask of CC field.
	SAADC_SAMPLERATE_CC_Msk = 0x7ff
	// Position of MODE field.
	SAADC_SAMPLERATE_MODE_Pos = 0xc
	// Bit mask of MODE field.
	SAADC_SAMPLERATE_MODE_Msk = 0x1000
	// Bit MODE.
	SAADC_SAMPLERATE_MODE = 0x1000
	// Rate is controlled from SAMPLE task
	SAADC_SAMPLERATE_MODE_Task = 0x0
	// Rate is controlled from local timer (use CC to control the rate)
	SAADC_SAMPLERATE_MODE_Timers = 0x1

	// RESULT.PTR: Data pointer
	// Position of PTR field.
	SAADC_RESULT_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SAADC_RESULT_PTR_PTR_Msk = 0xffffffff

	// RESULT.MAXCNT: Maximum number of buffer words to transfer
	// Position of MAXCNT field.
	SAADC_RESULT_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SAADC_RESULT_MAXCNT_MAXCNT_Msk = 0x7fff

	// RESULT.AMOUNT: Number of buffer words transferred since last START
	// Position of AMOUNT field.
	SAADC_RESULT_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SAADC_RESULT_AMOUNT_AMOUNT_Msk = 0x7fff
)

// Constants for TIMER0_NS: Timer/Counter 0
const (
	// TASKS_START: Start Timer
	// Position of TASKS_START field.
	TIMER_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	TIMER_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	TIMER_TASKS_START_TASKS_START = 0x1
	// Trigger task
	TIMER_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop Timer
	// Position of TASKS_STOP field.
	TIMER_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TIMER_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TIMER_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TIMER_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_COUNT: Increment Timer (Counter mode only)
	// Position of TASKS_COUNT field.
	TIMER_TASKS_COUNT_TASKS_COUNT_Pos = 0x0
	// Bit mask of TASKS_COUNT field.
	TIMER_TASKS_COUNT_TASKS_COUNT_Msk = 0x1
	// Bit TASKS_COUNT.
	TIMER_TASKS_COUNT_TASKS_COUNT = 0x1
	// Trigger task
	TIMER_TASKS_COUNT_TASKS_COUNT_Trigger = 0x1

	// TASKS_CLEAR: Clear time
	// Position of TASKS_CLEAR field.
	TIMER_TASKS_CLEAR_TASKS_CLEAR_Pos = 0x0
	// Bit mask of TASKS_CLEAR field.
	TIMER_TASKS_CLEAR_TASKS_CLEAR_Msk = 0x1
	// Bit TASKS_CLEAR.
	TIMER_TASKS_CLEAR_TASKS_CLEAR = 0x1
	// Trigger task
	TIMER_TASKS_CLEAR_TASKS_CLEAR_Trigger = 0x1

	// TASKS_SHUTDOWN: Deprecated register - Shut down timer
	// Position of TASKS_SHUTDOWN field.
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Pos = 0x0
	// Bit mask of TASKS_SHUTDOWN field.
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Msk = 0x1
	// Bit TASKS_SHUTDOWN.
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN = 0x1
	// Trigger task
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Trigger = 0x1

	// TASKS_CAPTURE: Description collection: Capture Timer value to CC[n] register
	// Position of TASKS_CAPTURE field.
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Pos = 0x0
	// Bit mask of TASKS_CAPTURE field.
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Msk = 0x1
	// Bit TASKS_CAPTURE.
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE = 0x1
	// Trigger task
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	TIMER_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	TIMER_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	TIMER_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	TIMER_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	TIMER_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	TIMER_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_COUNT: Subscribe configuration for task COUNT
	// Position of CHIDX field.
	TIMER_SUBSCRIBE_COUNT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_SUBSCRIBE_COUNT_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_SUBSCRIBE_COUNT_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_SUBSCRIBE_COUNT_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_SUBSCRIBE_COUNT_EN = 0x80000000
	// Disable subscription
	TIMER_SUBSCRIBE_COUNT_EN_Disabled = 0x0
	// Enable subscription
	TIMER_SUBSCRIBE_COUNT_EN_Enabled = 0x1

	// SUBSCRIBE_CLEAR: Subscribe configuration for task CLEAR
	// Position of CHIDX field.
	TIMER_SUBSCRIBE_CLEAR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_SUBSCRIBE_CLEAR_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_SUBSCRIBE_CLEAR_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_SUBSCRIBE_CLEAR_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_SUBSCRIBE_CLEAR_EN = 0x80000000
	// Disable subscription
	TIMER_SUBSCRIBE_CLEAR_EN_Disabled = 0x0
	// Enable subscription
	TIMER_SUBSCRIBE_CLEAR_EN_Enabled = 0x1

	// SUBSCRIBE_SHUTDOWN: Deprecated register - Subscribe configuration for task SHUTDOWN
	// Position of CHIDX field.
	TIMER_SUBSCRIBE_SHUTDOWN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_SUBSCRIBE_SHUTDOWN_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_SUBSCRIBE_SHUTDOWN_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_SUBSCRIBE_SHUTDOWN_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_SUBSCRIBE_SHUTDOWN_EN = 0x80000000
	// Disable subscription
	TIMER_SUBSCRIBE_SHUTDOWN_EN_Disabled = 0x0
	// Enable subscription
	TIMER_SUBSCRIBE_SHUTDOWN_EN_Enabled = 0x1

	// SUBSCRIBE_CAPTURE: Description collection: Subscribe configuration for task CAPTURE[n]
	// Position of CHIDX field.
	TIMER_SUBSCRIBE_CAPTURE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_SUBSCRIBE_CAPTURE_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_SUBSCRIBE_CAPTURE_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_SUBSCRIBE_CAPTURE_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_SUBSCRIBE_CAPTURE_EN = 0x80000000
	// Disable subscription
	TIMER_SUBSCRIBE_CAPTURE_EN_Disabled = 0x0
	// Enable subscription
	TIMER_SUBSCRIBE_CAPTURE_EN_Enabled = 0x1

	// EVENTS_COMPARE: Description collection: Compare event on CC[n] match
	// Position of EVENTS_COMPARE field.
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Pos = 0x0
	// Bit mask of EVENTS_COMPARE field.
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Msk = 0x1
	// Bit EVENTS_COMPARE.
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE = 0x1
	// Event not generated
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_NotGenerated = 0x0
	// Event generated
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Generated = 0x1

	// PUBLISH_COMPARE: Description collection: Publish configuration for event COMPARE[n]
	// Position of CHIDX field.
	TIMER_PUBLISH_COMPARE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	TIMER_PUBLISH_COMPARE_CHIDX_Msk = 0xff
	// Position of EN field.
	TIMER_PUBLISH_COMPARE_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMER_PUBLISH_COMPARE_EN_Msk = 0x80000000
	// Bit EN.
	TIMER_PUBLISH_COMPARE_EN = 0x80000000
	// Disable publishing
	TIMER_PUBLISH_COMPARE_EN_Disabled = 0x0
	// Enable publishing
	TIMER_PUBLISH_COMPARE_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of COMPARE0_CLEAR field.
	TIMER_SHORTS_COMPARE0_CLEAR_Pos = 0x0
	// Bit mask of COMPARE0_CLEAR field.
	TIMER_SHORTS_COMPARE0_CLEAR_Msk = 0x1
	// Bit COMPARE0_CLEAR.
	TIMER_SHORTS_COMPARE0_CLEAR = 0x1
	// Disable shortcut
	TIMER_SHORTS_COMPARE0_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE0_CLEAR_Enabled = 0x1
	// Position of COMPARE1_CLEAR field.
	TIMER_SHORTS_COMPARE1_CLEAR_Pos = 0x1
	// Bit mask of COMPARE1_CLEAR field.
	TIMER_SHORTS_COMPARE1_CLEAR_Msk = 0x2
	// Bit COMPARE1_CLEAR.
	TIMER_SHORTS_COMPARE1_CLEAR = 0x2
	// Disable shortcut
	TIMER_SHORTS_COMPARE1_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE1_CLEAR_Enabled = 0x1
	// Position of COMPARE2_CLEAR field.
	TIMER_SHORTS_COMPARE2_CLEAR_Pos = 0x2
	// Bit mask of COMPARE2_CLEAR field.
	TIMER_SHORTS_COMPARE2_CLEAR_Msk = 0x4
	// Bit COMPARE2_CLEAR.
	TIMER_SHORTS_COMPARE2_CLEAR = 0x4
	// Disable shortcut
	TIMER_SHORTS_COMPARE2_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE2_CLEAR_Enabled = 0x1
	// Position of COMPARE3_CLEAR field.
	TIMER_SHORTS_COMPARE3_CLEAR_Pos = 0x3
	// Bit mask of COMPARE3_CLEAR field.
	TIMER_SHORTS_COMPARE3_CLEAR_Msk = 0x8
	// Bit COMPARE3_CLEAR.
	TIMER_SHORTS_COMPARE3_CLEAR = 0x8
	// Disable shortcut
	TIMER_SHORTS_COMPARE3_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE3_CLEAR_Enabled = 0x1
	// Position of COMPARE4_CLEAR field.
	TIMER_SHORTS_COMPARE4_CLEAR_Pos = 0x4
	// Bit mask of COMPARE4_CLEAR field.
	TIMER_SHORTS_COMPARE4_CLEAR_Msk = 0x10
	// Bit COMPARE4_CLEAR.
	TIMER_SHORTS_COMPARE4_CLEAR = 0x10
	// Disable shortcut
	TIMER_SHORTS_COMPARE4_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE4_CLEAR_Enabled = 0x1
	// Position of COMPARE5_CLEAR field.
	TIMER_SHORTS_COMPARE5_CLEAR_Pos = 0x5
	// Bit mask of COMPARE5_CLEAR field.
	TIMER_SHORTS_COMPARE5_CLEAR_Msk = 0x20
	// Bit COMPARE5_CLEAR.
	TIMER_SHORTS_COMPARE5_CLEAR = 0x20
	// Disable shortcut
	TIMER_SHORTS_COMPARE5_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE5_CLEAR_Enabled = 0x1
	// Position of COMPARE0_STOP field.
	TIMER_SHORTS_COMPARE0_STOP_Pos = 0x10
	// Bit mask of COMPARE0_STOP field.
	TIMER_SHORTS_COMPARE0_STOP_Msk = 0x10000
	// Bit COMPARE0_STOP.
	TIMER_SHORTS_COMPARE0_STOP = 0x10000
	// Disable shortcut
	TIMER_SHORTS_COMPARE0_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE0_STOP_Enabled = 0x1
	// Position of COMPARE1_STOP field.
	TIMER_SHORTS_COMPARE1_STOP_Pos = 0x11
	// Bit mask of COMPARE1_STOP field.
	TIMER_SHORTS_COMPARE1_STOP_Msk = 0x20000
	// Bit COMPARE1_STOP.
	TIMER_SHORTS_COMPARE1_STOP = 0x20000
	// Disable shortcut
	TIMER_SHORTS_COMPARE1_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE1_STOP_Enabled = 0x1
	// Position of COMPARE2_STOP field.
	TIMER_SHORTS_COMPARE2_STOP_Pos = 0x12
	// Bit mask of COMPARE2_STOP field.
	TIMER_SHORTS_COMPARE2_STOP_Msk = 0x40000
	// Bit COMPARE2_STOP.
	TIMER_SHORTS_COMPARE2_STOP = 0x40000
	// Disable shortcut
	TIMER_SHORTS_COMPARE2_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE2_STOP_Enabled = 0x1
	// Position of COMPARE3_STOP field.
	TIMER_SHORTS_COMPARE3_STOP_Pos = 0x13
	// Bit mask of COMPARE3_STOP field.
	TIMER_SHORTS_COMPARE3_STOP_Msk = 0x80000
	// Bit COMPARE3_STOP.
	TIMER_SHORTS_COMPARE3_STOP = 0x80000
	// Disable shortcut
	TIMER_SHORTS_COMPARE3_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE3_STOP_Enabled = 0x1
	// Position of COMPARE4_STOP field.
	TIMER_SHORTS_COMPARE4_STOP_Pos = 0x14
	// Bit mask of COMPARE4_STOP field.
	TIMER_SHORTS_COMPARE4_STOP_Msk = 0x100000
	// Bit COMPARE4_STOP.
	TIMER_SHORTS_COMPARE4_STOP = 0x100000
	// Disable shortcut
	TIMER_SHORTS_COMPARE4_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE4_STOP_Enabled = 0x1
	// Position of COMPARE5_STOP field.
	TIMER_SHORTS_COMPARE5_STOP_Pos = 0x15
	// Bit mask of COMPARE5_STOP field.
	TIMER_SHORTS_COMPARE5_STOP_Msk = 0x200000
	// Bit COMPARE5_STOP.
	TIMER_SHORTS_COMPARE5_STOP = 0x200000
	// Disable shortcut
	TIMER_SHORTS_COMPARE5_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE5_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of COMPARE0 field.
	TIMER_INTEN_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTEN_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTEN_COMPARE0 = 0x10000
	// Disable
	TIMER_INTEN_COMPARE0_Disabled = 0x0
	// Enable
	TIMER_INTEN_COMPARE0_Enabled = 0x1
	// Position of COMPARE1 field.
	TIMER_INTEN_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTEN_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTEN_COMPARE1 = 0x20000
	// Disable
	TIMER_INTEN_COMPARE1_Disabled = 0x0
	// Enable
	TIMER_INTEN_COMPARE1_Enabled = 0x1
	// Position of COMPARE2 field.
	TIMER_INTEN_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTEN_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTEN_COMPARE2 = 0x40000
	// Disable
	TIMER_INTEN_COMPARE2_Disabled = 0x0
	// Enable
	TIMER_INTEN_COMPARE2_Enabled = 0x1
	// Position of COMPARE3 field.
	TIMER_INTEN_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTEN_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTEN_COMPARE3 = 0x80000
	// Disable
	TIMER_INTEN_COMPARE3_Disabled = 0x0
	// Enable
	TIMER_INTEN_COMPARE3_Enabled = 0x1
	// Position of COMPARE4 field.
	TIMER_INTEN_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTEN_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTEN_COMPARE4 = 0x100000
	// Disable
	TIMER_INTEN_COMPARE4_Disabled = 0x0
	// Enable
	TIMER_INTEN_COMPARE4_Enabled = 0x1
	// Position of COMPARE5 field.
	TIMER_INTEN_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTEN_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTEN_COMPARE5 = 0x200000
	// Disable
	TIMER_INTEN_COMPARE5_Disabled = 0x0
	// Enable
	TIMER_INTEN_COMPARE5_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of COMPARE0 field.
	TIMER_INTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	TIMER_INTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE0_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	TIMER_INTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	TIMER_INTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE1_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	TIMER_INTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	TIMER_INTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE2_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	TIMER_INTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	TIMER_INTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE3_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE3_Set = 0x1
	// Position of COMPARE4 field.
	TIMER_INTENSET_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTENSET_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTENSET_COMPARE4 = 0x100000
	// Read: Disabled
	TIMER_INTENSET_COMPARE4_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE4_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE4_Set = 0x1
	// Position of COMPARE5 field.
	TIMER_INTENSET_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTENSET_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTENSET_COMPARE5 = 0x200000
	// Read: Disabled
	TIMER_INTENSET_COMPARE5_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE5_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE5_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of COMPARE0 field.
	TIMER_INTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	TIMER_INTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	TIMER_INTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	TIMER_INTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE3_Clear = 0x1
	// Position of COMPARE4 field.
	TIMER_INTENCLR_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTENCLR_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTENCLR_COMPARE4 = 0x100000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE4_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE4_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE4_Clear = 0x1
	// Position of COMPARE5 field.
	TIMER_INTENCLR_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTENCLR_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTENCLR_COMPARE5 = 0x200000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE5_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE5_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE5_Clear = 0x1

	// MODE: Timer mode selection
	// Position of MODE field.
	TIMER_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	TIMER_MODE_MODE_Msk = 0x3
	// Select Timer mode
	TIMER_MODE_MODE_Timer = 0x0
	// Deprecated enumerator - Select Counter mode
	TIMER_MODE_MODE_Counter = 0x1
	// Select Low Power Counter mode
	TIMER_MODE_MODE_LowPowerCounter = 0x2

	// BITMODE: Configure the number of bits used by the TIMER
	// Position of BITMODE field.
	TIMER_BITMODE_BITMODE_Pos = 0x0
	// Bit mask of BITMODE field.
	TIMER_BITMODE_BITMODE_Msk = 0x3
	// 16 bit timer bit width
	TIMER_BITMODE_BITMODE_16Bit = 0x0
	// 8 bit timer bit width
	TIMER_BITMODE_BITMODE_08Bit = 0x1
	// 24 bit timer bit width
	TIMER_BITMODE_BITMODE_24Bit = 0x2
	// 32 bit timer bit width
	TIMER_BITMODE_BITMODE_32Bit = 0x3

	// PRESCALER: Timer prescaler register
	// Position of PRESCALER field.
	TIMER_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	TIMER_PRESCALER_PRESCALER_Msk = 0xf

	// CC: Description collection: Capture/Compare register n
	// Position of CC field.
	TIMER_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TIMER_CC_CC_Msk = 0xffffffff

	// ONESHOTEN: Description collection: Enable one-shot operation for Capture/Compare channel n
	// Position of ONESHOTEN field.
	TIMER_ONESHOTEN_ONESHOTEN_Pos = 0x0
	// Bit mask of ONESHOTEN field.
	TIMER_ONESHOTEN_ONESHOTEN_Msk = 0x1
	// Bit ONESHOTEN.
	TIMER_ONESHOTEN_ONESHOTEN = 0x1
	// Disable one-shot operation
	TIMER_ONESHOTEN_ONESHOTEN_Disable = 0x0
	// Enable one-shot operation
	TIMER_ONESHOTEN_ONESHOTEN_Enable = 0x1
)

// Constants for RTC0_NS: Real-time counter 0
const (
	// TASKS_START: Start RTC counter
	// Position of TASKS_START field.
	RTC_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	RTC_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	RTC_TASKS_START_TASKS_START = 0x1
	// Trigger task
	RTC_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop RTC counter
	// Position of TASKS_STOP field.
	RTC_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	RTC_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	RTC_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	RTC_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_CLEAR: Clear RTC counter
	// Position of TASKS_CLEAR field.
	RTC_TASKS_CLEAR_TASKS_CLEAR_Pos = 0x0
	// Bit mask of TASKS_CLEAR field.
	RTC_TASKS_CLEAR_TASKS_CLEAR_Msk = 0x1
	// Bit TASKS_CLEAR.
	RTC_TASKS_CLEAR_TASKS_CLEAR = 0x1
	// Trigger task
	RTC_TASKS_CLEAR_TASKS_CLEAR_Trigger = 0x1

	// TASKS_TRIGOVRFLW: Set counter to 0xFFFFF0
	// Position of TASKS_TRIGOVRFLW field.
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Pos = 0x0
	// Bit mask of TASKS_TRIGOVRFLW field.
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Msk = 0x1
	// Bit TASKS_TRIGOVRFLW.
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW = 0x1
	// Trigger task
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Trigger = 0x1

	// TASKS_CAPTURE: Description collection: Capture RTC counter to CC[n] register
	// Position of TASKS_CAPTURE field.
	RTC_TASKS_CAPTURE_TASKS_CAPTURE_Pos = 0x0
	// Bit mask of TASKS_CAPTURE field.
	RTC_TASKS_CAPTURE_TASKS_CAPTURE_Msk = 0x1
	// Bit TASKS_CAPTURE.
	RTC_TASKS_CAPTURE_TASKS_CAPTURE = 0x1
	// Trigger task
	RTC_TASKS_CAPTURE_TASKS_CAPTURE_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	RTC_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	RTC_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	RTC_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	RTC_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	RTC_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	RTC_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	RTC_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	RTC_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_CLEAR: Subscribe configuration for task CLEAR
	// Position of CHIDX field.
	RTC_SUBSCRIBE_CLEAR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_SUBSCRIBE_CLEAR_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_SUBSCRIBE_CLEAR_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_SUBSCRIBE_CLEAR_EN_Msk = 0x80000000
	// Bit EN.
	RTC_SUBSCRIBE_CLEAR_EN = 0x80000000
	// Disable subscription
	RTC_SUBSCRIBE_CLEAR_EN_Disabled = 0x0
	// Enable subscription
	RTC_SUBSCRIBE_CLEAR_EN_Enabled = 0x1

	// SUBSCRIBE_TRIGOVRFLW: Subscribe configuration for task TRIGOVRFLW
	// Position of CHIDX field.
	RTC_SUBSCRIBE_TRIGOVRFLW_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_SUBSCRIBE_TRIGOVRFLW_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_SUBSCRIBE_TRIGOVRFLW_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_SUBSCRIBE_TRIGOVRFLW_EN_Msk = 0x80000000
	// Bit EN.
	RTC_SUBSCRIBE_TRIGOVRFLW_EN = 0x80000000
	// Disable subscription
	RTC_SUBSCRIBE_TRIGOVRFLW_EN_Disabled = 0x0
	// Enable subscription
	RTC_SUBSCRIBE_TRIGOVRFLW_EN_Enabled = 0x1

	// SUBSCRIBE_CAPTURE: Description collection: Subscribe configuration for task CAPTURE[n]
	// Position of CHIDX field.
	RTC_SUBSCRIBE_CAPTURE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_SUBSCRIBE_CAPTURE_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_SUBSCRIBE_CAPTURE_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_SUBSCRIBE_CAPTURE_EN_Msk = 0x80000000
	// Bit EN.
	RTC_SUBSCRIBE_CAPTURE_EN = 0x80000000
	// Disable subscription
	RTC_SUBSCRIBE_CAPTURE_EN_Disabled = 0x0
	// Enable subscription
	RTC_SUBSCRIBE_CAPTURE_EN_Enabled = 0x1

	// EVENTS_TICK: Event on counter increment
	// Position of EVENTS_TICK field.
	RTC_EVENTS_TICK_EVENTS_TICK_Pos = 0x0
	// Bit mask of EVENTS_TICK field.
	RTC_EVENTS_TICK_EVENTS_TICK_Msk = 0x1
	// Bit EVENTS_TICK.
	RTC_EVENTS_TICK_EVENTS_TICK = 0x1
	// Event not generated
	RTC_EVENTS_TICK_EVENTS_TICK_NotGenerated = 0x0
	// Event generated
	RTC_EVENTS_TICK_EVENTS_TICK_Generated = 0x1

	// EVENTS_OVRFLW: Event on counter overflow
	// Position of EVENTS_OVRFLW field.
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Pos = 0x0
	// Bit mask of EVENTS_OVRFLW field.
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Msk = 0x1
	// Bit EVENTS_OVRFLW.
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW = 0x1
	// Event not generated
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_NotGenerated = 0x0
	// Event generated
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Generated = 0x1

	// EVENTS_COMPARE: Description collection: Compare event on CC[n] match
	// Position of EVENTS_COMPARE field.
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_Pos = 0x0
	// Bit mask of EVENTS_COMPARE field.
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_Msk = 0x1
	// Bit EVENTS_COMPARE.
	RTC_EVENTS_COMPARE_EVENTS_COMPARE = 0x1
	// Event not generated
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_NotGenerated = 0x0
	// Event generated
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_Generated = 0x1

	// PUBLISH_TICK: Publish configuration for event TICK
	// Position of CHIDX field.
	RTC_PUBLISH_TICK_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_PUBLISH_TICK_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_PUBLISH_TICK_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_PUBLISH_TICK_EN_Msk = 0x80000000
	// Bit EN.
	RTC_PUBLISH_TICK_EN = 0x80000000
	// Disable publishing
	RTC_PUBLISH_TICK_EN_Disabled = 0x0
	// Enable publishing
	RTC_PUBLISH_TICK_EN_Enabled = 0x1

	// PUBLISH_OVRFLW: Publish configuration for event OVRFLW
	// Position of CHIDX field.
	RTC_PUBLISH_OVRFLW_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_PUBLISH_OVRFLW_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_PUBLISH_OVRFLW_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_PUBLISH_OVRFLW_EN_Msk = 0x80000000
	// Bit EN.
	RTC_PUBLISH_OVRFLW_EN = 0x80000000
	// Disable publishing
	RTC_PUBLISH_OVRFLW_EN_Disabled = 0x0
	// Enable publishing
	RTC_PUBLISH_OVRFLW_EN_Enabled = 0x1

	// PUBLISH_COMPARE: Description collection: Publish configuration for event COMPARE[n]
	// Position of CHIDX field.
	RTC_PUBLISH_COMPARE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	RTC_PUBLISH_COMPARE_CHIDX_Msk = 0xff
	// Position of EN field.
	RTC_PUBLISH_COMPARE_EN_Pos = 0x1f
	// Bit mask of EN field.
	RTC_PUBLISH_COMPARE_EN_Msk = 0x80000000
	// Bit EN.
	RTC_PUBLISH_COMPARE_EN = 0x80000000
	// Disable publishing
	RTC_PUBLISH_COMPARE_EN_Disabled = 0x0
	// Enable publishing
	RTC_PUBLISH_COMPARE_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of COMPARE0_CLEAR field.
	RTC_SHORTS_COMPARE0_CLEAR_Pos = 0x0
	// Bit mask of COMPARE0_CLEAR field.
	RTC_SHORTS_COMPARE0_CLEAR_Msk = 0x1
	// Bit COMPARE0_CLEAR.
	RTC_SHORTS_COMPARE0_CLEAR = 0x1
	// Disable shortcut
	RTC_SHORTS_COMPARE0_CLEAR_Disabled = 0x0
	// Enable shortcut
	RTC_SHORTS_COMPARE0_CLEAR_Enabled = 0x1
	// Position of COMPARE1_CLEAR field.
	RTC_SHORTS_COMPARE1_CLEAR_Pos = 0x1
	// Bit mask of COMPARE1_CLEAR field.
	RTC_SHORTS_COMPARE1_CLEAR_Msk = 0x2
	// Bit COMPARE1_CLEAR.
	RTC_SHORTS_COMPARE1_CLEAR = 0x2
	// Disable shortcut
	RTC_SHORTS_COMPARE1_CLEAR_Disabled = 0x0
	// Enable shortcut
	RTC_SHORTS_COMPARE1_CLEAR_Enabled = 0x1
	// Position of COMPARE2_CLEAR field.
	RTC_SHORTS_COMPARE2_CLEAR_Pos = 0x2
	// Bit mask of COMPARE2_CLEAR field.
	RTC_SHORTS_COMPARE2_CLEAR_Msk = 0x4
	// Bit COMPARE2_CLEAR.
	RTC_SHORTS_COMPARE2_CLEAR = 0x4
	// Disable shortcut
	RTC_SHORTS_COMPARE2_CLEAR_Disabled = 0x0
	// Enable shortcut
	RTC_SHORTS_COMPARE2_CLEAR_Enabled = 0x1
	// Position of COMPARE3_CLEAR field.
	RTC_SHORTS_COMPARE3_CLEAR_Pos = 0x3
	// Bit mask of COMPARE3_CLEAR field.
	RTC_SHORTS_COMPARE3_CLEAR_Msk = 0x8
	// Bit COMPARE3_CLEAR.
	RTC_SHORTS_COMPARE3_CLEAR = 0x8
	// Disable shortcut
	RTC_SHORTS_COMPARE3_CLEAR_Disabled = 0x0
	// Enable shortcut
	RTC_SHORTS_COMPARE3_CLEAR_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of TICK field.
	RTC_INTENSET_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_INTENSET_TICK_Msk = 0x1
	// Bit TICK.
	RTC_INTENSET_TICK = 0x1
	// Read: Disabled
	RTC_INTENSET_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_TICK_Enabled = 0x1
	// Enable
	RTC_INTENSET_TICK_Set = 0x1
	// Position of OVRFLW field.
	RTC_INTENSET_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_INTENSET_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_INTENSET_OVRFLW = 0x2
	// Read: Disabled
	RTC_INTENSET_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_OVRFLW_Enabled = 0x1
	// Enable
	RTC_INTENSET_OVRFLW_Set = 0x1
	// Position of COMPARE0 field.
	RTC_INTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_INTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_INTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_INTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE0_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	RTC_INTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_INTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_INTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_INTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE1_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	RTC_INTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_INTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_INTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_INTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE2_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	RTC_INTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_INTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_INTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_INTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE3_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE3_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TICK field.
	RTC_INTENCLR_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_INTENCLR_TICK_Msk = 0x1
	// Bit TICK.
	RTC_INTENCLR_TICK = 0x1
	// Read: Disabled
	RTC_INTENCLR_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_TICK_Enabled = 0x1
	// Disable
	RTC_INTENCLR_TICK_Clear = 0x1
	// Position of OVRFLW field.
	RTC_INTENCLR_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_INTENCLR_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_INTENCLR_OVRFLW = 0x2
	// Read: Disabled
	RTC_INTENCLR_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_OVRFLW_Enabled = 0x1
	// Disable
	RTC_INTENCLR_OVRFLW_Clear = 0x1
	// Position of COMPARE0 field.
	RTC_INTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_INTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_INTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_INTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	RTC_INTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_INTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_INTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_INTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	RTC_INTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_INTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_INTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_INTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	RTC_INTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_INTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_INTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_INTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE3_Clear = 0x1

	// EVTEN: Enable or disable event routing
	// Position of TICK field.
	RTC_EVTEN_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTEN_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTEN_TICK = 0x1
	// Disable
	RTC_EVTEN_TICK_Disabled = 0x0
	// Enable
	RTC_EVTEN_TICK_Enabled = 0x1
	// Position of OVRFLW field.
	RTC_EVTEN_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTEN_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTEN_OVRFLW = 0x2
	// Disable
	RTC_EVTEN_OVRFLW_Disabled = 0x0
	// Enable
	RTC_EVTEN_OVRFLW_Enabled = 0x1
	// Position of COMPARE0 field.
	RTC_EVTEN_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTEN_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTEN_COMPARE0 = 0x10000
	// Disable
	RTC_EVTEN_COMPARE0_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE0_Enabled = 0x1
	// Position of COMPARE1 field.
	RTC_EVTEN_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTEN_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTEN_COMPARE1 = 0x20000
	// Disable
	RTC_EVTEN_COMPARE1_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE1_Enabled = 0x1
	// Position of COMPARE2 field.
	RTC_EVTEN_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTEN_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTEN_COMPARE2 = 0x40000
	// Disable
	RTC_EVTEN_COMPARE2_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE2_Enabled = 0x1
	// Position of COMPARE3 field.
	RTC_EVTEN_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTEN_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTEN_COMPARE3 = 0x80000
	// Disable
	RTC_EVTEN_COMPARE3_Disabled = 0x0
	// Enable
	RTC_EVTEN_COMPARE3_Enabled = 0x1

	// EVTENSET: Enable event routing
	// Position of TICK field.
	RTC_EVTENSET_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTENSET_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTENSET_TICK = 0x1
	// Read: Disabled
	RTC_EVTENSET_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_TICK_Enabled = 0x1
	// Enable
	RTC_EVTENSET_TICK_Set = 0x1
	// Position of OVRFLW field.
	RTC_EVTENSET_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTENSET_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTENSET_OVRFLW = 0x2
	// Read: Disabled
	RTC_EVTENSET_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_OVRFLW_Enabled = 0x1
	// Enable
	RTC_EVTENSET_OVRFLW_Set = 0x1
	// Position of COMPARE0 field.
	RTC_EVTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_EVTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE0_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	RTC_EVTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_EVTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE1_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	RTC_EVTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_EVTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE2_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	RTC_EVTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_EVTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE3_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE3_Set = 0x1

	// EVTENCLR: Disable event routing
	// Position of TICK field.
	RTC_EVTENCLR_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTENCLR_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTENCLR_TICK = 0x1
	// Read: Disabled
	RTC_EVTENCLR_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_TICK_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_TICK_Clear = 0x1
	// Position of OVRFLW field.
	RTC_EVTENCLR_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTENCLR_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTENCLR_OVRFLW = 0x2
	// Read: Disabled
	RTC_EVTENCLR_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_OVRFLW_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_OVRFLW_Clear = 0x1
	// Position of COMPARE0 field.
	RTC_EVTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	RTC_EVTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	RTC_EVTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	RTC_EVTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE3_Clear = 0x1

	// COUNTER: Current counter value
	// Position of COUNTER field.
	RTC_COUNTER_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	RTC_COUNTER_COUNTER_Msk = 0xffffff

	// PRESCALER: 12-bit prescaler for counter frequency (32768/(PRESCALER+1)). Must be written when RTC is stopped.
	// Position of PRESCALER field.
	RTC_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	RTC_PRESCALER_PRESCALER_Msk = 0xfff

	// CC: Description collection: Compare register n
	// Position of COMPARE field.
	RTC_CC_COMPARE_Pos = 0x0
	// Bit mask of COMPARE field.
	RTC_CC_COMPARE_Msk = 0xffffff
)

// Constants for DPPIC_NS: Distributed programmable peripheral interconnect controller 0
const (
	// TASKS_CHG.EN: Description cluster: Enable channel group n
	// Position of EN field.
	DPPIC_TASKS_CHG_EN_EN_Pos = 0x0
	// Bit mask of EN field.
	DPPIC_TASKS_CHG_EN_EN_Msk = 0x1
	// Bit EN.
	DPPIC_TASKS_CHG_EN_EN = 0x1
	// Trigger task
	DPPIC_TASKS_CHG_EN_EN_Trigger = 0x1

	// TASKS_CHG.DIS: Description cluster: Disable channel group n
	// Position of DIS field.
	DPPIC_TASKS_CHG_DIS_DIS_Pos = 0x0
	// Bit mask of DIS field.
	DPPIC_TASKS_CHG_DIS_DIS_Msk = 0x1
	// Bit DIS.
	DPPIC_TASKS_CHG_DIS_DIS = 0x1
	// Trigger task
	DPPIC_TASKS_CHG_DIS_DIS_Trigger = 0x1

	// SUBSCRIBE_CHG.EN: Description cluster: Subscribe configuration for task CHG[n].EN
	// Position of CHIDX field.
	DPPIC_SUBSCRIBE_CHG_EN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	DPPIC_SUBSCRIBE_CHG_EN_CHIDX_Msk = 0xff
	// Position of EN field.
	DPPIC_SUBSCRIBE_CHG_EN_EN_Pos = 0x1f
	// Bit mask of EN field.
	DPPIC_SUBSCRIBE_CHG_EN_EN_Msk = 0x80000000
	// Bit EN.
	DPPIC_SUBSCRIBE_CHG_EN_EN = 0x80000000
	// Disable subscription
	DPPIC_SUBSCRIBE_CHG_EN_EN_Disabled = 0x0
	// Enable subscription
	DPPIC_SUBSCRIBE_CHG_EN_EN_Enabled = 0x1

	// SUBSCRIBE_CHG.DIS: Description cluster: Subscribe configuration for task CHG[n].DIS
	// Position of CHIDX field.
	DPPIC_SUBSCRIBE_CHG_DIS_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	DPPIC_SUBSCRIBE_CHG_DIS_CHIDX_Msk = 0xff
	// Position of EN field.
	DPPIC_SUBSCRIBE_CHG_DIS_EN_Pos = 0x1f
	// Bit mask of EN field.
	DPPIC_SUBSCRIBE_CHG_DIS_EN_Msk = 0x80000000
	// Bit EN.
	DPPIC_SUBSCRIBE_CHG_DIS_EN = 0x80000000
	// Disable subscription
	DPPIC_SUBSCRIBE_CHG_DIS_EN_Disabled = 0x0
	// Enable subscription
	DPPIC_SUBSCRIBE_CHG_DIS_EN_Enabled = 0x1

	// CHEN: Channel enable register
	// Position of CH0 field.
	DPPIC_CHEN_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DPPIC_CHEN_CH0_Msk = 0x1
	// Bit CH0.
	DPPIC_CHEN_CH0 = 0x1
	// Disable channel
	DPPIC_CHEN_CH0_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH0_Enabled = 0x1
	// Position of CH1 field.
	DPPIC_CHEN_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DPPIC_CHEN_CH1_Msk = 0x2
	// Bit CH1.
	DPPIC_CHEN_CH1 = 0x2
	// Disable channel
	DPPIC_CHEN_CH1_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH1_Enabled = 0x1
	// Position of CH2 field.
	DPPIC_CHEN_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	DPPIC_CHEN_CH2_Msk = 0x4
	// Bit CH2.
	DPPIC_CHEN_CH2 = 0x4
	// Disable channel
	DPPIC_CHEN_CH2_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH2_Enabled = 0x1
	// Position of CH3 field.
	DPPIC_CHEN_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	DPPIC_CHEN_CH3_Msk = 0x8
	// Bit CH3.
	DPPIC_CHEN_CH3 = 0x8
	// Disable channel
	DPPIC_CHEN_CH3_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH3_Enabled = 0x1
	// Position of CH4 field.
	DPPIC_CHEN_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	DPPIC_CHEN_CH4_Msk = 0x10
	// Bit CH4.
	DPPIC_CHEN_CH4 = 0x10
	// Disable channel
	DPPIC_CHEN_CH4_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH4_Enabled = 0x1
	// Position of CH5 field.
	DPPIC_CHEN_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	DPPIC_CHEN_CH5_Msk = 0x20
	// Bit CH5.
	DPPIC_CHEN_CH5 = 0x20
	// Disable channel
	DPPIC_CHEN_CH5_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH5_Enabled = 0x1
	// Position of CH6 field.
	DPPIC_CHEN_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	DPPIC_CHEN_CH6_Msk = 0x40
	// Bit CH6.
	DPPIC_CHEN_CH6 = 0x40
	// Disable channel
	DPPIC_CHEN_CH6_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH6_Enabled = 0x1
	// Position of CH7 field.
	DPPIC_CHEN_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	DPPIC_CHEN_CH7_Msk = 0x80
	// Bit CH7.
	DPPIC_CHEN_CH7 = 0x80
	// Disable channel
	DPPIC_CHEN_CH7_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH7_Enabled = 0x1
	// Position of CH8 field.
	DPPIC_CHEN_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	DPPIC_CHEN_CH8_Msk = 0x100
	// Bit CH8.
	DPPIC_CHEN_CH8 = 0x100
	// Disable channel
	DPPIC_CHEN_CH8_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH8_Enabled = 0x1
	// Position of CH9 field.
	DPPIC_CHEN_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	DPPIC_CHEN_CH9_Msk = 0x200
	// Bit CH9.
	DPPIC_CHEN_CH9 = 0x200
	// Disable channel
	DPPIC_CHEN_CH9_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH9_Enabled = 0x1
	// Position of CH10 field.
	DPPIC_CHEN_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	DPPIC_CHEN_CH10_Msk = 0x400
	// Bit CH10.
	DPPIC_CHEN_CH10 = 0x400
	// Disable channel
	DPPIC_CHEN_CH10_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH10_Enabled = 0x1
	// Position of CH11 field.
	DPPIC_CHEN_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	DPPIC_CHEN_CH11_Msk = 0x800
	// Bit CH11.
	DPPIC_CHEN_CH11 = 0x800
	// Disable channel
	DPPIC_CHEN_CH11_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH11_Enabled = 0x1
	// Position of CH12 field.
	DPPIC_CHEN_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	DPPIC_CHEN_CH12_Msk = 0x1000
	// Bit CH12.
	DPPIC_CHEN_CH12 = 0x1000
	// Disable channel
	DPPIC_CHEN_CH12_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH12_Enabled = 0x1
	// Position of CH13 field.
	DPPIC_CHEN_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	DPPIC_CHEN_CH13_Msk = 0x2000
	// Bit CH13.
	DPPIC_CHEN_CH13 = 0x2000
	// Disable channel
	DPPIC_CHEN_CH13_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH13_Enabled = 0x1
	// Position of CH14 field.
	DPPIC_CHEN_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	DPPIC_CHEN_CH14_Msk = 0x4000
	// Bit CH14.
	DPPIC_CHEN_CH14 = 0x4000
	// Disable channel
	DPPIC_CHEN_CH14_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH14_Enabled = 0x1
	// Position of CH15 field.
	DPPIC_CHEN_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	DPPIC_CHEN_CH15_Msk = 0x8000
	// Bit CH15.
	DPPIC_CHEN_CH15 = 0x8000
	// Disable channel
	DPPIC_CHEN_CH15_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH15_Enabled = 0x1
	// Position of CH16 field.
	DPPIC_CHEN_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	DPPIC_CHEN_CH16_Msk = 0x10000
	// Bit CH16.
	DPPIC_CHEN_CH16 = 0x10000
	// Disable channel
	DPPIC_CHEN_CH16_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH16_Enabled = 0x1
	// Position of CH17 field.
	DPPIC_CHEN_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	DPPIC_CHEN_CH17_Msk = 0x20000
	// Bit CH17.
	DPPIC_CHEN_CH17 = 0x20000
	// Disable channel
	DPPIC_CHEN_CH17_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH17_Enabled = 0x1
	// Position of CH18 field.
	DPPIC_CHEN_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	DPPIC_CHEN_CH18_Msk = 0x40000
	// Bit CH18.
	DPPIC_CHEN_CH18 = 0x40000
	// Disable channel
	DPPIC_CHEN_CH18_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH18_Enabled = 0x1
	// Position of CH19 field.
	DPPIC_CHEN_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	DPPIC_CHEN_CH19_Msk = 0x80000
	// Bit CH19.
	DPPIC_CHEN_CH19 = 0x80000
	// Disable channel
	DPPIC_CHEN_CH19_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH19_Enabled = 0x1
	// Position of CH20 field.
	DPPIC_CHEN_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	DPPIC_CHEN_CH20_Msk = 0x100000
	// Bit CH20.
	DPPIC_CHEN_CH20 = 0x100000
	// Disable channel
	DPPIC_CHEN_CH20_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH20_Enabled = 0x1
	// Position of CH21 field.
	DPPIC_CHEN_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	DPPIC_CHEN_CH21_Msk = 0x200000
	// Bit CH21.
	DPPIC_CHEN_CH21 = 0x200000
	// Disable channel
	DPPIC_CHEN_CH21_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH21_Enabled = 0x1
	// Position of CH22 field.
	DPPIC_CHEN_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	DPPIC_CHEN_CH22_Msk = 0x400000
	// Bit CH22.
	DPPIC_CHEN_CH22 = 0x400000
	// Disable channel
	DPPIC_CHEN_CH22_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH22_Enabled = 0x1
	// Position of CH23 field.
	DPPIC_CHEN_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	DPPIC_CHEN_CH23_Msk = 0x800000
	// Bit CH23.
	DPPIC_CHEN_CH23 = 0x800000
	// Disable channel
	DPPIC_CHEN_CH23_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH23_Enabled = 0x1
	// Position of CH24 field.
	DPPIC_CHEN_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	DPPIC_CHEN_CH24_Msk = 0x1000000
	// Bit CH24.
	DPPIC_CHEN_CH24 = 0x1000000
	// Disable channel
	DPPIC_CHEN_CH24_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH24_Enabled = 0x1
	// Position of CH25 field.
	DPPIC_CHEN_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	DPPIC_CHEN_CH25_Msk = 0x2000000
	// Bit CH25.
	DPPIC_CHEN_CH25 = 0x2000000
	// Disable channel
	DPPIC_CHEN_CH25_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH25_Enabled = 0x1
	// Position of CH26 field.
	DPPIC_CHEN_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	DPPIC_CHEN_CH26_Msk = 0x4000000
	// Bit CH26.
	DPPIC_CHEN_CH26 = 0x4000000
	// Disable channel
	DPPIC_CHEN_CH26_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH26_Enabled = 0x1
	// Position of CH27 field.
	DPPIC_CHEN_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	DPPIC_CHEN_CH27_Msk = 0x8000000
	// Bit CH27.
	DPPIC_CHEN_CH27 = 0x8000000
	// Disable channel
	DPPIC_CHEN_CH27_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH27_Enabled = 0x1
	// Position of CH28 field.
	DPPIC_CHEN_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	DPPIC_CHEN_CH28_Msk = 0x10000000
	// Bit CH28.
	DPPIC_CHEN_CH28 = 0x10000000
	// Disable channel
	DPPIC_CHEN_CH28_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH28_Enabled = 0x1
	// Position of CH29 field.
	DPPIC_CHEN_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	DPPIC_CHEN_CH29_Msk = 0x20000000
	// Bit CH29.
	DPPIC_CHEN_CH29 = 0x20000000
	// Disable channel
	DPPIC_CHEN_CH29_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH29_Enabled = 0x1
	// Position of CH30 field.
	DPPIC_CHEN_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	DPPIC_CHEN_CH30_Msk = 0x40000000
	// Bit CH30.
	DPPIC_CHEN_CH30 = 0x40000000
	// Disable channel
	DPPIC_CHEN_CH30_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH30_Enabled = 0x1
	// Position of CH31 field.
	DPPIC_CHEN_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	DPPIC_CHEN_CH31_Msk = 0x80000000
	// Bit CH31.
	DPPIC_CHEN_CH31 = 0x80000000
	// Disable channel
	DPPIC_CHEN_CH31_Disabled = 0x0
	// Enable channel
	DPPIC_CHEN_CH31_Enabled = 0x1

	// CHENSET: Channel enable set register
	// Position of CH0 field.
	DPPIC_CHENSET_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DPPIC_CHENSET_CH0_Msk = 0x1
	// Bit CH0.
	DPPIC_CHENSET_CH0 = 0x1
	// Read: Channel disabled
	DPPIC_CHENSET_CH0_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH0_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH0_Set = 0x1
	// Position of CH1 field.
	DPPIC_CHENSET_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DPPIC_CHENSET_CH1_Msk = 0x2
	// Bit CH1.
	DPPIC_CHENSET_CH1 = 0x2
	// Read: Channel disabled
	DPPIC_CHENSET_CH1_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH1_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH1_Set = 0x1
	// Position of CH2 field.
	DPPIC_CHENSET_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	DPPIC_CHENSET_CH2_Msk = 0x4
	// Bit CH2.
	DPPIC_CHENSET_CH2 = 0x4
	// Read: Channel disabled
	DPPIC_CHENSET_CH2_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH2_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH2_Set = 0x1
	// Position of CH3 field.
	DPPIC_CHENSET_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	DPPIC_CHENSET_CH3_Msk = 0x8
	// Bit CH3.
	DPPIC_CHENSET_CH3 = 0x8
	// Read: Channel disabled
	DPPIC_CHENSET_CH3_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH3_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH3_Set = 0x1
	// Position of CH4 field.
	DPPIC_CHENSET_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	DPPIC_CHENSET_CH4_Msk = 0x10
	// Bit CH4.
	DPPIC_CHENSET_CH4 = 0x10
	// Read: Channel disabled
	DPPIC_CHENSET_CH4_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH4_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH4_Set = 0x1
	// Position of CH5 field.
	DPPIC_CHENSET_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	DPPIC_CHENSET_CH5_Msk = 0x20
	// Bit CH5.
	DPPIC_CHENSET_CH5 = 0x20
	// Read: Channel disabled
	DPPIC_CHENSET_CH5_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH5_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH5_Set = 0x1
	// Position of CH6 field.
	DPPIC_CHENSET_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	DPPIC_CHENSET_CH6_Msk = 0x40
	// Bit CH6.
	DPPIC_CHENSET_CH6 = 0x40
	// Read: Channel disabled
	DPPIC_CHENSET_CH6_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH6_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH6_Set = 0x1
	// Position of CH7 field.
	DPPIC_CHENSET_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	DPPIC_CHENSET_CH7_Msk = 0x80
	// Bit CH7.
	DPPIC_CHENSET_CH7 = 0x80
	// Read: Channel disabled
	DPPIC_CHENSET_CH7_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH7_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH7_Set = 0x1
	// Position of CH8 field.
	DPPIC_CHENSET_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	DPPIC_CHENSET_CH8_Msk = 0x100
	// Bit CH8.
	DPPIC_CHENSET_CH8 = 0x100
	// Read: Channel disabled
	DPPIC_CHENSET_CH8_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH8_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH8_Set = 0x1
	// Position of CH9 field.
	DPPIC_CHENSET_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	DPPIC_CHENSET_CH9_Msk = 0x200
	// Bit CH9.
	DPPIC_CHENSET_CH9 = 0x200
	// Read: Channel disabled
	DPPIC_CHENSET_CH9_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH9_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH9_Set = 0x1
	// Position of CH10 field.
	DPPIC_CHENSET_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	DPPIC_CHENSET_CH10_Msk = 0x400
	// Bit CH10.
	DPPIC_CHENSET_CH10 = 0x400
	// Read: Channel disabled
	DPPIC_CHENSET_CH10_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH10_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH10_Set = 0x1
	// Position of CH11 field.
	DPPIC_CHENSET_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	DPPIC_CHENSET_CH11_Msk = 0x800
	// Bit CH11.
	DPPIC_CHENSET_CH11 = 0x800
	// Read: Channel disabled
	DPPIC_CHENSET_CH11_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH11_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH11_Set = 0x1
	// Position of CH12 field.
	DPPIC_CHENSET_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	DPPIC_CHENSET_CH12_Msk = 0x1000
	// Bit CH12.
	DPPIC_CHENSET_CH12 = 0x1000
	// Read: Channel disabled
	DPPIC_CHENSET_CH12_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH12_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH12_Set = 0x1
	// Position of CH13 field.
	DPPIC_CHENSET_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	DPPIC_CHENSET_CH13_Msk = 0x2000
	// Bit CH13.
	DPPIC_CHENSET_CH13 = 0x2000
	// Read: Channel disabled
	DPPIC_CHENSET_CH13_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH13_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH13_Set = 0x1
	// Position of CH14 field.
	DPPIC_CHENSET_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	DPPIC_CHENSET_CH14_Msk = 0x4000
	// Bit CH14.
	DPPIC_CHENSET_CH14 = 0x4000
	// Read: Channel disabled
	DPPIC_CHENSET_CH14_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH14_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH14_Set = 0x1
	// Position of CH15 field.
	DPPIC_CHENSET_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	DPPIC_CHENSET_CH15_Msk = 0x8000
	// Bit CH15.
	DPPIC_CHENSET_CH15 = 0x8000
	// Read: Channel disabled
	DPPIC_CHENSET_CH15_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH15_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH15_Set = 0x1
	// Position of CH16 field.
	DPPIC_CHENSET_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	DPPIC_CHENSET_CH16_Msk = 0x10000
	// Bit CH16.
	DPPIC_CHENSET_CH16 = 0x10000
	// Read: Channel disabled
	DPPIC_CHENSET_CH16_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH16_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH16_Set = 0x1
	// Position of CH17 field.
	DPPIC_CHENSET_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	DPPIC_CHENSET_CH17_Msk = 0x20000
	// Bit CH17.
	DPPIC_CHENSET_CH17 = 0x20000
	// Read: Channel disabled
	DPPIC_CHENSET_CH17_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH17_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH17_Set = 0x1
	// Position of CH18 field.
	DPPIC_CHENSET_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	DPPIC_CHENSET_CH18_Msk = 0x40000
	// Bit CH18.
	DPPIC_CHENSET_CH18 = 0x40000
	// Read: Channel disabled
	DPPIC_CHENSET_CH18_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH18_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH18_Set = 0x1
	// Position of CH19 field.
	DPPIC_CHENSET_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	DPPIC_CHENSET_CH19_Msk = 0x80000
	// Bit CH19.
	DPPIC_CHENSET_CH19 = 0x80000
	// Read: Channel disabled
	DPPIC_CHENSET_CH19_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH19_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH19_Set = 0x1
	// Position of CH20 field.
	DPPIC_CHENSET_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	DPPIC_CHENSET_CH20_Msk = 0x100000
	// Bit CH20.
	DPPIC_CHENSET_CH20 = 0x100000
	// Read: Channel disabled
	DPPIC_CHENSET_CH20_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH20_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH20_Set = 0x1
	// Position of CH21 field.
	DPPIC_CHENSET_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	DPPIC_CHENSET_CH21_Msk = 0x200000
	// Bit CH21.
	DPPIC_CHENSET_CH21 = 0x200000
	// Read: Channel disabled
	DPPIC_CHENSET_CH21_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH21_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH21_Set = 0x1
	// Position of CH22 field.
	DPPIC_CHENSET_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	DPPIC_CHENSET_CH22_Msk = 0x400000
	// Bit CH22.
	DPPIC_CHENSET_CH22 = 0x400000
	// Read: Channel disabled
	DPPIC_CHENSET_CH22_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH22_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH22_Set = 0x1
	// Position of CH23 field.
	DPPIC_CHENSET_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	DPPIC_CHENSET_CH23_Msk = 0x800000
	// Bit CH23.
	DPPIC_CHENSET_CH23 = 0x800000
	// Read: Channel disabled
	DPPIC_CHENSET_CH23_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH23_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH23_Set = 0x1
	// Position of CH24 field.
	DPPIC_CHENSET_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	DPPIC_CHENSET_CH24_Msk = 0x1000000
	// Bit CH24.
	DPPIC_CHENSET_CH24 = 0x1000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH24_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH24_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH24_Set = 0x1
	// Position of CH25 field.
	DPPIC_CHENSET_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	DPPIC_CHENSET_CH25_Msk = 0x2000000
	// Bit CH25.
	DPPIC_CHENSET_CH25 = 0x2000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH25_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH25_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH25_Set = 0x1
	// Position of CH26 field.
	DPPIC_CHENSET_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	DPPIC_CHENSET_CH26_Msk = 0x4000000
	// Bit CH26.
	DPPIC_CHENSET_CH26 = 0x4000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH26_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH26_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH26_Set = 0x1
	// Position of CH27 field.
	DPPIC_CHENSET_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	DPPIC_CHENSET_CH27_Msk = 0x8000000
	// Bit CH27.
	DPPIC_CHENSET_CH27 = 0x8000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH27_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH27_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH27_Set = 0x1
	// Position of CH28 field.
	DPPIC_CHENSET_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	DPPIC_CHENSET_CH28_Msk = 0x10000000
	// Bit CH28.
	DPPIC_CHENSET_CH28 = 0x10000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH28_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH28_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH28_Set = 0x1
	// Position of CH29 field.
	DPPIC_CHENSET_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	DPPIC_CHENSET_CH29_Msk = 0x20000000
	// Bit CH29.
	DPPIC_CHENSET_CH29 = 0x20000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH29_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH29_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH29_Set = 0x1
	// Position of CH30 field.
	DPPIC_CHENSET_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	DPPIC_CHENSET_CH30_Msk = 0x40000000
	// Bit CH30.
	DPPIC_CHENSET_CH30 = 0x40000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH30_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH30_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH30_Set = 0x1
	// Position of CH31 field.
	DPPIC_CHENSET_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	DPPIC_CHENSET_CH31_Msk = 0x80000000
	// Bit CH31.
	DPPIC_CHENSET_CH31 = 0x80000000
	// Read: Channel disabled
	DPPIC_CHENSET_CH31_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENSET_CH31_Enabled = 0x1
	// Write: Enable channel
	DPPIC_CHENSET_CH31_Set = 0x1

	// CHENCLR: Channel enable clear register
	// Position of CH0 field.
	DPPIC_CHENCLR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DPPIC_CHENCLR_CH0_Msk = 0x1
	// Bit CH0.
	DPPIC_CHENCLR_CH0 = 0x1
	// Read: Channel disabled
	DPPIC_CHENCLR_CH0_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH0_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH0_Clear = 0x1
	// Position of CH1 field.
	DPPIC_CHENCLR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DPPIC_CHENCLR_CH1_Msk = 0x2
	// Bit CH1.
	DPPIC_CHENCLR_CH1 = 0x2
	// Read: Channel disabled
	DPPIC_CHENCLR_CH1_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH1_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH1_Clear = 0x1
	// Position of CH2 field.
	DPPIC_CHENCLR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	DPPIC_CHENCLR_CH2_Msk = 0x4
	// Bit CH2.
	DPPIC_CHENCLR_CH2 = 0x4
	// Read: Channel disabled
	DPPIC_CHENCLR_CH2_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH2_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH2_Clear = 0x1
	// Position of CH3 field.
	DPPIC_CHENCLR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	DPPIC_CHENCLR_CH3_Msk = 0x8
	// Bit CH3.
	DPPIC_CHENCLR_CH3 = 0x8
	// Read: Channel disabled
	DPPIC_CHENCLR_CH3_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH3_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH3_Clear = 0x1
	// Position of CH4 field.
	DPPIC_CHENCLR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	DPPIC_CHENCLR_CH4_Msk = 0x10
	// Bit CH4.
	DPPIC_CHENCLR_CH4 = 0x10
	// Read: Channel disabled
	DPPIC_CHENCLR_CH4_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH4_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH4_Clear = 0x1
	// Position of CH5 field.
	DPPIC_CHENCLR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	DPPIC_CHENCLR_CH5_Msk = 0x20
	// Bit CH5.
	DPPIC_CHENCLR_CH5 = 0x20
	// Read: Channel disabled
	DPPIC_CHENCLR_CH5_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH5_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH5_Clear = 0x1
	// Position of CH6 field.
	DPPIC_CHENCLR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	DPPIC_CHENCLR_CH6_Msk = 0x40
	// Bit CH6.
	DPPIC_CHENCLR_CH6 = 0x40
	// Read: Channel disabled
	DPPIC_CHENCLR_CH6_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH6_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH6_Clear = 0x1
	// Position of CH7 field.
	DPPIC_CHENCLR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	DPPIC_CHENCLR_CH7_Msk = 0x80
	// Bit CH7.
	DPPIC_CHENCLR_CH7 = 0x80
	// Read: Channel disabled
	DPPIC_CHENCLR_CH7_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH7_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH7_Clear = 0x1
	// Position of CH8 field.
	DPPIC_CHENCLR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	DPPIC_CHENCLR_CH8_Msk = 0x100
	// Bit CH8.
	DPPIC_CHENCLR_CH8 = 0x100
	// Read: Channel disabled
	DPPIC_CHENCLR_CH8_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH8_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH8_Clear = 0x1
	// Position of CH9 field.
	DPPIC_CHENCLR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	DPPIC_CHENCLR_CH9_Msk = 0x200
	// Bit CH9.
	DPPIC_CHENCLR_CH9 = 0x200
	// Read: Channel disabled
	DPPIC_CHENCLR_CH9_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH9_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH9_Clear = 0x1
	// Position of CH10 field.
	DPPIC_CHENCLR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	DPPIC_CHENCLR_CH10_Msk = 0x400
	// Bit CH10.
	DPPIC_CHENCLR_CH10 = 0x400
	// Read: Channel disabled
	DPPIC_CHENCLR_CH10_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH10_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH10_Clear = 0x1
	// Position of CH11 field.
	DPPIC_CHENCLR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	DPPIC_CHENCLR_CH11_Msk = 0x800
	// Bit CH11.
	DPPIC_CHENCLR_CH11 = 0x800
	// Read: Channel disabled
	DPPIC_CHENCLR_CH11_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH11_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH11_Clear = 0x1
	// Position of CH12 field.
	DPPIC_CHENCLR_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	DPPIC_CHENCLR_CH12_Msk = 0x1000
	// Bit CH12.
	DPPIC_CHENCLR_CH12 = 0x1000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH12_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH12_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH12_Clear = 0x1
	// Position of CH13 field.
	DPPIC_CHENCLR_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	DPPIC_CHENCLR_CH13_Msk = 0x2000
	// Bit CH13.
	DPPIC_CHENCLR_CH13 = 0x2000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH13_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH13_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH13_Clear = 0x1
	// Position of CH14 field.
	DPPIC_CHENCLR_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	DPPIC_CHENCLR_CH14_Msk = 0x4000
	// Bit CH14.
	DPPIC_CHENCLR_CH14 = 0x4000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH14_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH14_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH14_Clear = 0x1
	// Position of CH15 field.
	DPPIC_CHENCLR_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	DPPIC_CHENCLR_CH15_Msk = 0x8000
	// Bit CH15.
	DPPIC_CHENCLR_CH15 = 0x8000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH15_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH15_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH15_Clear = 0x1
	// Position of CH16 field.
	DPPIC_CHENCLR_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	DPPIC_CHENCLR_CH16_Msk = 0x10000
	// Bit CH16.
	DPPIC_CHENCLR_CH16 = 0x10000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH16_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH16_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH16_Clear = 0x1
	// Position of CH17 field.
	DPPIC_CHENCLR_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	DPPIC_CHENCLR_CH17_Msk = 0x20000
	// Bit CH17.
	DPPIC_CHENCLR_CH17 = 0x20000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH17_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH17_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH17_Clear = 0x1
	// Position of CH18 field.
	DPPIC_CHENCLR_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	DPPIC_CHENCLR_CH18_Msk = 0x40000
	// Bit CH18.
	DPPIC_CHENCLR_CH18 = 0x40000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH18_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH18_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH18_Clear = 0x1
	// Position of CH19 field.
	DPPIC_CHENCLR_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	DPPIC_CHENCLR_CH19_Msk = 0x80000
	// Bit CH19.
	DPPIC_CHENCLR_CH19 = 0x80000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH19_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH19_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH19_Clear = 0x1
	// Position of CH20 field.
	DPPIC_CHENCLR_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	DPPIC_CHENCLR_CH20_Msk = 0x100000
	// Bit CH20.
	DPPIC_CHENCLR_CH20 = 0x100000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH20_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH20_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH20_Clear = 0x1
	// Position of CH21 field.
	DPPIC_CHENCLR_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	DPPIC_CHENCLR_CH21_Msk = 0x200000
	// Bit CH21.
	DPPIC_CHENCLR_CH21 = 0x200000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH21_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH21_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH21_Clear = 0x1
	// Position of CH22 field.
	DPPIC_CHENCLR_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	DPPIC_CHENCLR_CH22_Msk = 0x400000
	// Bit CH22.
	DPPIC_CHENCLR_CH22 = 0x400000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH22_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH22_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH22_Clear = 0x1
	// Position of CH23 field.
	DPPIC_CHENCLR_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	DPPIC_CHENCLR_CH23_Msk = 0x800000
	// Bit CH23.
	DPPIC_CHENCLR_CH23 = 0x800000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH23_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH23_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH23_Clear = 0x1
	// Position of CH24 field.
	DPPIC_CHENCLR_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	DPPIC_CHENCLR_CH24_Msk = 0x1000000
	// Bit CH24.
	DPPIC_CHENCLR_CH24 = 0x1000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH24_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH24_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH24_Clear = 0x1
	// Position of CH25 field.
	DPPIC_CHENCLR_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	DPPIC_CHENCLR_CH25_Msk = 0x2000000
	// Bit CH25.
	DPPIC_CHENCLR_CH25 = 0x2000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH25_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH25_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH25_Clear = 0x1
	// Position of CH26 field.
	DPPIC_CHENCLR_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	DPPIC_CHENCLR_CH26_Msk = 0x4000000
	// Bit CH26.
	DPPIC_CHENCLR_CH26 = 0x4000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH26_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH26_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH26_Clear = 0x1
	// Position of CH27 field.
	DPPIC_CHENCLR_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	DPPIC_CHENCLR_CH27_Msk = 0x8000000
	// Bit CH27.
	DPPIC_CHENCLR_CH27 = 0x8000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH27_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH27_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH27_Clear = 0x1
	// Position of CH28 field.
	DPPIC_CHENCLR_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	DPPIC_CHENCLR_CH28_Msk = 0x10000000
	// Bit CH28.
	DPPIC_CHENCLR_CH28 = 0x10000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH28_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH28_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH28_Clear = 0x1
	// Position of CH29 field.
	DPPIC_CHENCLR_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	DPPIC_CHENCLR_CH29_Msk = 0x20000000
	// Bit CH29.
	DPPIC_CHENCLR_CH29 = 0x20000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH29_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH29_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH29_Clear = 0x1
	// Position of CH30 field.
	DPPIC_CHENCLR_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	DPPIC_CHENCLR_CH30_Msk = 0x40000000
	// Bit CH30.
	DPPIC_CHENCLR_CH30 = 0x40000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH30_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH30_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH30_Clear = 0x1
	// Position of CH31 field.
	DPPIC_CHENCLR_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	DPPIC_CHENCLR_CH31_Msk = 0x80000000
	// Bit CH31.
	DPPIC_CHENCLR_CH31 = 0x80000000
	// Read: Channel disabled
	DPPIC_CHENCLR_CH31_Disabled = 0x0
	// Read: Channel enabled
	DPPIC_CHENCLR_CH31_Enabled = 0x1
	// Write: Disable channel
	DPPIC_CHENCLR_CH31_Clear = 0x1

	// CHG: Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG[n].EN or SUBSCRIBE_CHG[n].DIS is enabled
	// Position of CH0 field.
	DPPIC_CHG_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DPPIC_CHG_CH0_Msk = 0x1
	// Bit CH0.
	DPPIC_CHG_CH0 = 0x1
	// Exclude
	DPPIC_CHG_CH0_Excluded = 0x0
	// Include
	DPPIC_CHG_CH0_Included = 0x1
	// Position of CH1 field.
	DPPIC_CHG_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DPPIC_CHG_CH1_Msk = 0x2
	// Bit CH1.
	DPPIC_CHG_CH1 = 0x2
	// Exclude
	DPPIC_CHG_CH1_Excluded = 0x0
	// Include
	DPPIC_CHG_CH1_Included = 0x1
	// Position of CH2 field.
	DPPIC_CHG_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	DPPIC_CHG_CH2_Msk = 0x4
	// Bit CH2.
	DPPIC_CHG_CH2 = 0x4
	// Exclude
	DPPIC_CHG_CH2_Excluded = 0x0
	// Include
	DPPIC_CHG_CH2_Included = 0x1
	// Position of CH3 field.
	DPPIC_CHG_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	DPPIC_CHG_CH3_Msk = 0x8
	// Bit CH3.
	DPPIC_CHG_CH3 = 0x8
	// Exclude
	DPPIC_CHG_CH3_Excluded = 0x0
	// Include
	DPPIC_CHG_CH3_Included = 0x1
	// Position of CH4 field.
	DPPIC_CHG_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	DPPIC_CHG_CH4_Msk = 0x10
	// Bit CH4.
	DPPIC_CHG_CH4 = 0x10
	// Exclude
	DPPIC_CHG_CH4_Excluded = 0x0
	// Include
	DPPIC_CHG_CH4_Included = 0x1
	// Position of CH5 field.
	DPPIC_CHG_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	DPPIC_CHG_CH5_Msk = 0x20
	// Bit CH5.
	DPPIC_CHG_CH5 = 0x20
	// Exclude
	DPPIC_CHG_CH5_Excluded = 0x0
	// Include
	DPPIC_CHG_CH5_Included = 0x1
	// Position of CH6 field.
	DPPIC_CHG_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	DPPIC_CHG_CH6_Msk = 0x40
	// Bit CH6.
	DPPIC_CHG_CH6 = 0x40
	// Exclude
	DPPIC_CHG_CH6_Excluded = 0x0
	// Include
	DPPIC_CHG_CH6_Included = 0x1
	// Position of CH7 field.
	DPPIC_CHG_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	DPPIC_CHG_CH7_Msk = 0x80
	// Bit CH7.
	DPPIC_CHG_CH7 = 0x80
	// Exclude
	DPPIC_CHG_CH7_Excluded = 0x0
	// Include
	DPPIC_CHG_CH7_Included = 0x1
	// Position of CH8 field.
	DPPIC_CHG_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	DPPIC_CHG_CH8_Msk = 0x100
	// Bit CH8.
	DPPIC_CHG_CH8 = 0x100
	// Exclude
	DPPIC_CHG_CH8_Excluded = 0x0
	// Include
	DPPIC_CHG_CH8_Included = 0x1
	// Position of CH9 field.
	DPPIC_CHG_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	DPPIC_CHG_CH9_Msk = 0x200
	// Bit CH9.
	DPPIC_CHG_CH9 = 0x200
	// Exclude
	DPPIC_CHG_CH9_Excluded = 0x0
	// Include
	DPPIC_CHG_CH9_Included = 0x1
	// Position of CH10 field.
	DPPIC_CHG_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	DPPIC_CHG_CH10_Msk = 0x400
	// Bit CH10.
	DPPIC_CHG_CH10 = 0x400
	// Exclude
	DPPIC_CHG_CH10_Excluded = 0x0
	// Include
	DPPIC_CHG_CH10_Included = 0x1
	// Position of CH11 field.
	DPPIC_CHG_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	DPPIC_CHG_CH11_Msk = 0x800
	// Bit CH11.
	DPPIC_CHG_CH11 = 0x800
	// Exclude
	DPPIC_CHG_CH11_Excluded = 0x0
	// Include
	DPPIC_CHG_CH11_Included = 0x1
	// Position of CH12 field.
	DPPIC_CHG_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	DPPIC_CHG_CH12_Msk = 0x1000
	// Bit CH12.
	DPPIC_CHG_CH12 = 0x1000
	// Exclude
	DPPIC_CHG_CH12_Excluded = 0x0
	// Include
	DPPIC_CHG_CH12_Included = 0x1
	// Position of CH13 field.
	DPPIC_CHG_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	DPPIC_CHG_CH13_Msk = 0x2000
	// Bit CH13.
	DPPIC_CHG_CH13 = 0x2000
	// Exclude
	DPPIC_CHG_CH13_Excluded = 0x0
	// Include
	DPPIC_CHG_CH13_Included = 0x1
	// Position of CH14 field.
	DPPIC_CHG_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	DPPIC_CHG_CH14_Msk = 0x4000
	// Bit CH14.
	DPPIC_CHG_CH14 = 0x4000
	// Exclude
	DPPIC_CHG_CH14_Excluded = 0x0
	// Include
	DPPIC_CHG_CH14_Included = 0x1
	// Position of CH15 field.
	DPPIC_CHG_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	DPPIC_CHG_CH15_Msk = 0x8000
	// Bit CH15.
	DPPIC_CHG_CH15 = 0x8000
	// Exclude
	DPPIC_CHG_CH15_Excluded = 0x0
	// Include
	DPPIC_CHG_CH15_Included = 0x1
	// Position of CH16 field.
	DPPIC_CHG_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	DPPIC_CHG_CH16_Msk = 0x10000
	// Bit CH16.
	DPPIC_CHG_CH16 = 0x10000
	// Exclude
	DPPIC_CHG_CH16_Excluded = 0x0
	// Include
	DPPIC_CHG_CH16_Included = 0x1
	// Position of CH17 field.
	DPPIC_CHG_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	DPPIC_CHG_CH17_Msk = 0x20000
	// Bit CH17.
	DPPIC_CHG_CH17 = 0x20000
	// Exclude
	DPPIC_CHG_CH17_Excluded = 0x0
	// Include
	DPPIC_CHG_CH17_Included = 0x1
	// Position of CH18 field.
	DPPIC_CHG_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	DPPIC_CHG_CH18_Msk = 0x40000
	// Bit CH18.
	DPPIC_CHG_CH18 = 0x40000
	// Exclude
	DPPIC_CHG_CH18_Excluded = 0x0
	// Include
	DPPIC_CHG_CH18_Included = 0x1
	// Position of CH19 field.
	DPPIC_CHG_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	DPPIC_CHG_CH19_Msk = 0x80000
	// Bit CH19.
	DPPIC_CHG_CH19 = 0x80000
	// Exclude
	DPPIC_CHG_CH19_Excluded = 0x0
	// Include
	DPPIC_CHG_CH19_Included = 0x1
	// Position of CH20 field.
	DPPIC_CHG_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	DPPIC_CHG_CH20_Msk = 0x100000
	// Bit CH20.
	DPPIC_CHG_CH20 = 0x100000
	// Exclude
	DPPIC_CHG_CH20_Excluded = 0x0
	// Include
	DPPIC_CHG_CH20_Included = 0x1
	// Position of CH21 field.
	DPPIC_CHG_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	DPPIC_CHG_CH21_Msk = 0x200000
	// Bit CH21.
	DPPIC_CHG_CH21 = 0x200000
	// Exclude
	DPPIC_CHG_CH21_Excluded = 0x0
	// Include
	DPPIC_CHG_CH21_Included = 0x1
	// Position of CH22 field.
	DPPIC_CHG_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	DPPIC_CHG_CH22_Msk = 0x400000
	// Bit CH22.
	DPPIC_CHG_CH22 = 0x400000
	// Exclude
	DPPIC_CHG_CH22_Excluded = 0x0
	// Include
	DPPIC_CHG_CH22_Included = 0x1
	// Position of CH23 field.
	DPPIC_CHG_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	DPPIC_CHG_CH23_Msk = 0x800000
	// Bit CH23.
	DPPIC_CHG_CH23 = 0x800000
	// Exclude
	DPPIC_CHG_CH23_Excluded = 0x0
	// Include
	DPPIC_CHG_CH23_Included = 0x1
	// Position of CH24 field.
	DPPIC_CHG_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	DPPIC_CHG_CH24_Msk = 0x1000000
	// Bit CH24.
	DPPIC_CHG_CH24 = 0x1000000
	// Exclude
	DPPIC_CHG_CH24_Excluded = 0x0
	// Include
	DPPIC_CHG_CH24_Included = 0x1
	// Position of CH25 field.
	DPPIC_CHG_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	DPPIC_CHG_CH25_Msk = 0x2000000
	// Bit CH25.
	DPPIC_CHG_CH25 = 0x2000000
	// Exclude
	DPPIC_CHG_CH25_Excluded = 0x0
	// Include
	DPPIC_CHG_CH25_Included = 0x1
	// Position of CH26 field.
	DPPIC_CHG_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	DPPIC_CHG_CH26_Msk = 0x4000000
	// Bit CH26.
	DPPIC_CHG_CH26 = 0x4000000
	// Exclude
	DPPIC_CHG_CH26_Excluded = 0x0
	// Include
	DPPIC_CHG_CH26_Included = 0x1
	// Position of CH27 field.
	DPPIC_CHG_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	DPPIC_CHG_CH27_Msk = 0x8000000
	// Bit CH27.
	DPPIC_CHG_CH27 = 0x8000000
	// Exclude
	DPPIC_CHG_CH27_Excluded = 0x0
	// Include
	DPPIC_CHG_CH27_Included = 0x1
	// Position of CH28 field.
	DPPIC_CHG_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	DPPIC_CHG_CH28_Msk = 0x10000000
	// Bit CH28.
	DPPIC_CHG_CH28 = 0x10000000
	// Exclude
	DPPIC_CHG_CH28_Excluded = 0x0
	// Include
	DPPIC_CHG_CH28_Included = 0x1
	// Position of CH29 field.
	DPPIC_CHG_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	DPPIC_CHG_CH29_Msk = 0x20000000
	// Bit CH29.
	DPPIC_CHG_CH29 = 0x20000000
	// Exclude
	DPPIC_CHG_CH29_Excluded = 0x0
	// Include
	DPPIC_CHG_CH29_Included = 0x1
	// Position of CH30 field.
	DPPIC_CHG_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	DPPIC_CHG_CH30_Msk = 0x40000000
	// Bit CH30.
	DPPIC_CHG_CH30 = 0x40000000
	// Exclude
	DPPIC_CHG_CH30_Excluded = 0x0
	// Include
	DPPIC_CHG_CH30_Included = 0x1
	// Position of CH31 field.
	DPPIC_CHG_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	DPPIC_CHG_CH31_Msk = 0x80000000
	// Bit CH31.
	DPPIC_CHG_CH31 = 0x80000000
	// Exclude
	DPPIC_CHG_CH31_Excluded = 0x0
	// Include
	DPPIC_CHG_CH31_Included = 0x1
)

// Constants for WDT0_NS: Watchdog Timer 0
const (
	// TASKS_START: Start the watchdog
	// Position of TASKS_START field.
	WDT_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	WDT_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	WDT_TASKS_START_TASKS_START = 0x1
	// Trigger task
	WDT_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop the watchdog timer.
	// Position of TASKS_STOP field.
	WDT_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	WDT_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	WDT_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	WDT_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	WDT_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	WDT_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	WDT_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	WDT_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	WDT_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	WDT_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	WDT_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	WDT_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	WDT_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	WDT_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	WDT_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	WDT_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	WDT_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	WDT_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// EVENTS_TIMEOUT: Watchdog timeout
	// Position of EVENTS_TIMEOUT field.
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Pos = 0x0
	// Bit mask of EVENTS_TIMEOUT field.
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Msk = 0x1
	// Bit EVENTS_TIMEOUT.
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT = 0x1
	// Event not generated
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_NotGenerated = 0x0
	// Event generated
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Generated = 0x1

	// EVENTS_STOPPED: Watchdog stopped
	// Position of EVENTS_STOPPED field.
	WDT_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	WDT_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	WDT_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	WDT_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	WDT_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// PUBLISH_TIMEOUT: Publish configuration for event TIMEOUT
	// Position of CHIDX field.
	WDT_PUBLISH_TIMEOUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	WDT_PUBLISH_TIMEOUT_CHIDX_Msk = 0xff
	// Position of EN field.
	WDT_PUBLISH_TIMEOUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	WDT_PUBLISH_TIMEOUT_EN_Msk = 0x80000000
	// Bit EN.
	WDT_PUBLISH_TIMEOUT_EN = 0x80000000
	// Disable publishing
	WDT_PUBLISH_TIMEOUT_EN_Disabled = 0x0
	// Enable publishing
	WDT_PUBLISH_TIMEOUT_EN_Enabled = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	WDT_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	WDT_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	WDT_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	WDT_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	WDT_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	WDT_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	WDT_PUBLISH_STOPPED_EN_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of TIMEOUT field.
	WDT_INTENSET_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_INTENSET_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_INTENSET_TIMEOUT = 0x1
	// Read: Disabled
	WDT_INTENSET_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_INTENSET_TIMEOUT_Enabled = 0x1
	// Enable
	WDT_INTENSET_TIMEOUT_Set = 0x1
	// Position of STOPPED field.
	WDT_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	WDT_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	WDT_INTENSET_STOPPED = 0x2
	// Read: Disabled
	WDT_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	WDT_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	WDT_INTENSET_STOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TIMEOUT field.
	WDT_INTENCLR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_INTENCLR_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_INTENCLR_TIMEOUT = 0x1
	// Read: Disabled
	WDT_INTENCLR_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_INTENCLR_TIMEOUT_Enabled = 0x1
	// Disable
	WDT_INTENCLR_TIMEOUT_Clear = 0x1
	// Position of STOPPED field.
	WDT_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	WDT_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	WDT_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	WDT_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	WDT_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	WDT_INTENCLR_STOPPED_Clear = 0x1

	// NMIENSET: Enable interrupt
	// Position of TIMEOUT field.
	WDT_NMIENSET_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_NMIENSET_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_NMIENSET_TIMEOUT = 0x1
	// Read: Disabled
	WDT_NMIENSET_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_NMIENSET_TIMEOUT_Enabled = 0x1
	// Enable
	WDT_NMIENSET_TIMEOUT_Set = 0x1
	// Position of STOPPED field.
	WDT_NMIENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	WDT_NMIENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	WDT_NMIENSET_STOPPED = 0x2
	// Read: Disabled
	WDT_NMIENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	WDT_NMIENSET_STOPPED_Enabled = 0x1
	// Enable
	WDT_NMIENSET_STOPPED_Set = 0x1

	// NMIENCLR: Disable interrupt
	// Position of TIMEOUT field.
	WDT_NMIENCLR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_NMIENCLR_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_NMIENCLR_TIMEOUT = 0x1
	// Read: Disabled
	WDT_NMIENCLR_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_NMIENCLR_TIMEOUT_Enabled = 0x1
	// Disable
	WDT_NMIENCLR_TIMEOUT_Clear = 0x1
	// Position of STOPPED field.
	WDT_NMIENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	WDT_NMIENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	WDT_NMIENCLR_STOPPED = 0x2
	// Read: Disabled
	WDT_NMIENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	WDT_NMIENCLR_STOPPED_Enabled = 0x1
	// Disable
	WDT_NMIENCLR_STOPPED_Clear = 0x1

	// RUNSTATUS: Run status
	// Position of RUNSTATUSWDT field.
	WDT_RUNSTATUS_RUNSTATUSWDT_Pos = 0x0
	// Bit mask of RUNSTATUSWDT field.
	WDT_RUNSTATUS_RUNSTATUSWDT_Msk = 0x1
	// Bit RUNSTATUSWDT.
	WDT_RUNSTATUS_RUNSTATUSWDT = 0x1
	// Watchdog not running
	WDT_RUNSTATUS_RUNSTATUSWDT_NotRunning = 0x0
	// Watchdog is running
	WDT_RUNSTATUS_RUNSTATUSWDT_Running = 0x1

	// REQSTATUS: Request status
	// Position of RR0 field.
	WDT_REQSTATUS_RR0_Pos = 0x0
	// Bit mask of RR0 field.
	WDT_REQSTATUS_RR0_Msk = 0x1
	// Bit RR0.
	WDT_REQSTATUS_RR0 = 0x1
	// RR[0] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR0_DisabledOrRequested = 0x0
	// RR[0] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR0_EnabledAndUnrequested = 0x1
	// Position of RR1 field.
	WDT_REQSTATUS_RR1_Pos = 0x1
	// Bit mask of RR1 field.
	WDT_REQSTATUS_RR1_Msk = 0x2
	// Bit RR1.
	WDT_REQSTATUS_RR1 = 0x2
	// RR[1] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR1_DisabledOrRequested = 0x0
	// RR[1] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR1_EnabledAndUnrequested = 0x1
	// Position of RR2 field.
	WDT_REQSTATUS_RR2_Pos = 0x2
	// Bit mask of RR2 field.
	WDT_REQSTATUS_RR2_Msk = 0x4
	// Bit RR2.
	WDT_REQSTATUS_RR2 = 0x4
	// RR[2] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR2_DisabledOrRequested = 0x0
	// RR[2] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR2_EnabledAndUnrequested = 0x1
	// Position of RR3 field.
	WDT_REQSTATUS_RR3_Pos = 0x3
	// Bit mask of RR3 field.
	WDT_REQSTATUS_RR3_Msk = 0x8
	// Bit RR3.
	WDT_REQSTATUS_RR3 = 0x8
	// RR[3] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR3_DisabledOrRequested = 0x0
	// RR[3] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR3_EnabledAndUnrequested = 0x1
	// Position of RR4 field.
	WDT_REQSTATUS_RR4_Pos = 0x4
	// Bit mask of RR4 field.
	WDT_REQSTATUS_RR4_Msk = 0x10
	// Bit RR4.
	WDT_REQSTATUS_RR4 = 0x10
	// RR[4] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR4_DisabledOrRequested = 0x0
	// RR[4] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR4_EnabledAndUnrequested = 0x1
	// Position of RR5 field.
	WDT_REQSTATUS_RR5_Pos = 0x5
	// Bit mask of RR5 field.
	WDT_REQSTATUS_RR5_Msk = 0x20
	// Bit RR5.
	WDT_REQSTATUS_RR5 = 0x20
	// RR[5] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR5_DisabledOrRequested = 0x0
	// RR[5] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR5_EnabledAndUnrequested = 0x1
	// Position of RR6 field.
	WDT_REQSTATUS_RR6_Pos = 0x6
	// Bit mask of RR6 field.
	WDT_REQSTATUS_RR6_Msk = 0x40
	// Bit RR6.
	WDT_REQSTATUS_RR6 = 0x40
	// RR[6] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR6_DisabledOrRequested = 0x0
	// RR[6] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR6_EnabledAndUnrequested = 0x1
	// Position of RR7 field.
	WDT_REQSTATUS_RR7_Pos = 0x7
	// Bit mask of RR7 field.
	WDT_REQSTATUS_RR7_Msk = 0x80
	// Bit RR7.
	WDT_REQSTATUS_RR7 = 0x80
	// RR[7] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR7_DisabledOrRequested = 0x0
	// RR[7] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR7_EnabledAndUnrequested = 0x1

	// CRV: Counter reload value
	// Position of CRV field.
	WDT_CRV_CRV_Pos = 0x0
	// Bit mask of CRV field.
	WDT_CRV_CRV_Msk = 0xffffffff

	// RREN: Enable register for reload request registers
	// Position of RR0 field.
	WDT_RREN_RR0_Pos = 0x0
	// Bit mask of RR0 field.
	WDT_RREN_RR0_Msk = 0x1
	// Bit RR0.
	WDT_RREN_RR0 = 0x1
	// Disable RR[0] register
	WDT_RREN_RR0_Disabled = 0x0
	// Enable RR[0] register
	WDT_RREN_RR0_Enabled = 0x1
	// Position of RR1 field.
	WDT_RREN_RR1_Pos = 0x1
	// Bit mask of RR1 field.
	WDT_RREN_RR1_Msk = 0x2
	// Bit RR1.
	WDT_RREN_RR1 = 0x2
	// Disable RR[1] register
	WDT_RREN_RR1_Disabled = 0x0
	// Enable RR[1] register
	WDT_RREN_RR1_Enabled = 0x1
	// Position of RR2 field.
	WDT_RREN_RR2_Pos = 0x2
	// Bit mask of RR2 field.
	WDT_RREN_RR2_Msk = 0x4
	// Bit RR2.
	WDT_RREN_RR2 = 0x4
	// Disable RR[2] register
	WDT_RREN_RR2_Disabled = 0x0
	// Enable RR[2] register
	WDT_RREN_RR2_Enabled = 0x1
	// Position of RR3 field.
	WDT_RREN_RR3_Pos = 0x3
	// Bit mask of RR3 field.
	WDT_RREN_RR3_Msk = 0x8
	// Bit RR3.
	WDT_RREN_RR3 = 0x8
	// Disable RR[3] register
	WDT_RREN_RR3_Disabled = 0x0
	// Enable RR[3] register
	WDT_RREN_RR3_Enabled = 0x1
	// Position of RR4 field.
	WDT_RREN_RR4_Pos = 0x4
	// Bit mask of RR4 field.
	WDT_RREN_RR4_Msk = 0x10
	// Bit RR4.
	WDT_RREN_RR4 = 0x10
	// Disable RR[4] register
	WDT_RREN_RR4_Disabled = 0x0
	// Enable RR[4] register
	WDT_RREN_RR4_Enabled = 0x1
	// Position of RR5 field.
	WDT_RREN_RR5_Pos = 0x5
	// Bit mask of RR5 field.
	WDT_RREN_RR5_Msk = 0x20
	// Bit RR5.
	WDT_RREN_RR5 = 0x20
	// Disable RR[5] register
	WDT_RREN_RR5_Disabled = 0x0
	// Enable RR[5] register
	WDT_RREN_RR5_Enabled = 0x1
	// Position of RR6 field.
	WDT_RREN_RR6_Pos = 0x6
	// Bit mask of RR6 field.
	WDT_RREN_RR6_Msk = 0x40
	// Bit RR6.
	WDT_RREN_RR6 = 0x40
	// Disable RR[6] register
	WDT_RREN_RR6_Disabled = 0x0
	// Enable RR[6] register
	WDT_RREN_RR6_Enabled = 0x1
	// Position of RR7 field.
	WDT_RREN_RR7_Pos = 0x7
	// Bit mask of RR7 field.
	WDT_RREN_RR7_Msk = 0x80
	// Bit RR7.
	WDT_RREN_RR7 = 0x80
	// Disable RR[7] register
	WDT_RREN_RR7_Disabled = 0x0
	// Enable RR[7] register
	WDT_RREN_RR7_Enabled = 0x1

	// CONFIG: Configuration register
	// Position of SLEEP field.
	WDT_CONFIG_SLEEP_Pos = 0x0
	// Bit mask of SLEEP field.
	WDT_CONFIG_SLEEP_Msk = 0x1
	// Bit SLEEP.
	WDT_CONFIG_SLEEP = 0x1
	// Pause watchdog while the CPU is sleeping
	WDT_CONFIG_SLEEP_Pause = 0x0
	// Keep the watchdog running while the CPU is sleeping
	WDT_CONFIG_SLEEP_Run = 0x1
	// Position of HALT field.
	WDT_CONFIG_HALT_Pos = 0x3
	// Bit mask of HALT field.
	WDT_CONFIG_HALT_Msk = 0x8
	// Bit HALT.
	WDT_CONFIG_HALT = 0x8
	// Pause watchdog while the CPU is halted by the debugger
	WDT_CONFIG_HALT_Pause = 0x0
	// Keep the watchdog running while the CPU is halted by the debugger
	WDT_CONFIG_HALT_Run = 0x1
	// Position of STOPEN field.
	WDT_CONFIG_STOPEN_Pos = 0x6
	// Bit mask of STOPEN field.
	WDT_CONFIG_STOPEN_Msk = 0x40
	// Bit STOPEN.
	WDT_CONFIG_STOPEN = 0x40
	// Do not allow stopping the watchdog
	WDT_CONFIG_STOPEN_Disable = 0x0
	// Allow stopping the watchdog
	WDT_CONFIG_STOPEN_Enable = 0x1

	// TSEN: Task Stop Enable
	// Position of TSEN field.
	WDT_TSEN_TSEN_Pos = 0x0
	// Bit mask of TSEN field.
	WDT_TSEN_TSEN_Msk = 0xffffffff
	// Value to allow stopping the watchdog
	WDT_TSEN_TSEN_Enable = 0x6e524635

	// RR: Description collection: Reload request n
	// Position of RR field.
	WDT_RR_RR_Pos = 0x0
	// Bit mask of RR field.
	WDT_RR_RR_Msk = 0xffffffff
	// Value to request a reload of the watchdog timer
	WDT_RR_RR_Reload = 0x6e524635
)

// Constants for COMP_NS: Comparator 0
const (
	// TASKS_START: Start comparator
	// Position of TASKS_START field.
	COMP_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	COMP_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	COMP_TASKS_START_TASKS_START = 0x1
	// Trigger task
	COMP_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop comparator
	// Position of TASKS_STOP field.
	COMP_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	COMP_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	COMP_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	COMP_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SAMPLE: Sample comparator value
	// Position of TASKS_SAMPLE field.
	COMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos = 0x0
	// Bit mask of TASKS_SAMPLE field.
	COMP_TASKS_SAMPLE_TASKS_SAMPLE_Msk = 0x1
	// Bit TASKS_SAMPLE.
	COMP_TASKS_SAMPLE_TASKS_SAMPLE = 0x1
	// Trigger task
	COMP_TASKS_SAMPLE_TASKS_SAMPLE_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	COMP_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	COMP_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	COMP_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	COMP_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	COMP_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	COMP_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	COMP_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	COMP_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_SAMPLE: Subscribe configuration for task SAMPLE
	// Position of CHIDX field.
	COMP_SUBSCRIBE_SAMPLE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_SUBSCRIBE_SAMPLE_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_SUBSCRIBE_SAMPLE_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_SUBSCRIBE_SAMPLE_EN_Msk = 0x80000000
	// Bit EN.
	COMP_SUBSCRIBE_SAMPLE_EN = 0x80000000
	// Disable subscription
	COMP_SUBSCRIBE_SAMPLE_EN_Disabled = 0x0
	// Enable subscription
	COMP_SUBSCRIBE_SAMPLE_EN_Enabled = 0x1

	// EVENTS_READY: COMP is ready and output is valid
	// Position of EVENTS_READY field.
	COMP_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	COMP_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	COMP_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	COMP_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// EVENTS_DOWN: Downward crossing
	// Position of EVENTS_DOWN field.
	COMP_EVENTS_DOWN_EVENTS_DOWN_Pos = 0x0
	// Bit mask of EVENTS_DOWN field.
	COMP_EVENTS_DOWN_EVENTS_DOWN_Msk = 0x1
	// Bit EVENTS_DOWN.
	COMP_EVENTS_DOWN_EVENTS_DOWN = 0x1
	// Event not generated
	COMP_EVENTS_DOWN_EVENTS_DOWN_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_DOWN_EVENTS_DOWN_Generated = 0x1

	// EVENTS_UP: Upward crossing
	// Position of EVENTS_UP field.
	COMP_EVENTS_UP_EVENTS_UP_Pos = 0x0
	// Bit mask of EVENTS_UP field.
	COMP_EVENTS_UP_EVENTS_UP_Msk = 0x1
	// Bit EVENTS_UP.
	COMP_EVENTS_UP_EVENTS_UP = 0x1
	// Event not generated
	COMP_EVENTS_UP_EVENTS_UP_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_UP_EVENTS_UP_Generated = 0x1

	// EVENTS_CROSS: Downward or upward crossing
	// Position of EVENTS_CROSS field.
	COMP_EVENTS_CROSS_EVENTS_CROSS_Pos = 0x0
	// Bit mask of EVENTS_CROSS field.
	COMP_EVENTS_CROSS_EVENTS_CROSS_Msk = 0x1
	// Bit EVENTS_CROSS.
	COMP_EVENTS_CROSS_EVENTS_CROSS = 0x1
	// Event not generated
	COMP_EVENTS_CROSS_EVENTS_CROSS_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_CROSS_EVENTS_CROSS_Generated = 0x1

	// PUBLISH_READY: Publish configuration for event READY
	// Position of CHIDX field.
	COMP_PUBLISH_READY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_PUBLISH_READY_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_PUBLISH_READY_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_PUBLISH_READY_EN_Msk = 0x80000000
	// Bit EN.
	COMP_PUBLISH_READY_EN = 0x80000000
	// Disable publishing
	COMP_PUBLISH_READY_EN_Disabled = 0x0
	// Enable publishing
	COMP_PUBLISH_READY_EN_Enabled = 0x1

	// PUBLISH_DOWN: Publish configuration for event DOWN
	// Position of CHIDX field.
	COMP_PUBLISH_DOWN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_PUBLISH_DOWN_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_PUBLISH_DOWN_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_PUBLISH_DOWN_EN_Msk = 0x80000000
	// Bit EN.
	COMP_PUBLISH_DOWN_EN = 0x80000000
	// Disable publishing
	COMP_PUBLISH_DOWN_EN_Disabled = 0x0
	// Enable publishing
	COMP_PUBLISH_DOWN_EN_Enabled = 0x1

	// PUBLISH_UP: Publish configuration for event UP
	// Position of CHIDX field.
	COMP_PUBLISH_UP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_PUBLISH_UP_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_PUBLISH_UP_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_PUBLISH_UP_EN_Msk = 0x80000000
	// Bit EN.
	COMP_PUBLISH_UP_EN = 0x80000000
	// Disable publishing
	COMP_PUBLISH_UP_EN_Disabled = 0x0
	// Enable publishing
	COMP_PUBLISH_UP_EN_Enabled = 0x1

	// PUBLISH_CROSS: Publish configuration for event CROSS
	// Position of CHIDX field.
	COMP_PUBLISH_CROSS_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	COMP_PUBLISH_CROSS_CHIDX_Msk = 0xff
	// Position of EN field.
	COMP_PUBLISH_CROSS_EN_Pos = 0x1f
	// Bit mask of EN field.
	COMP_PUBLISH_CROSS_EN_Msk = 0x80000000
	// Bit EN.
	COMP_PUBLISH_CROSS_EN = 0x80000000
	// Disable publishing
	COMP_PUBLISH_CROSS_EN_Disabled = 0x0
	// Enable publishing
	COMP_PUBLISH_CROSS_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of READY_SAMPLE field.
	COMP_SHORTS_READY_SAMPLE_Pos = 0x0
	// Bit mask of READY_SAMPLE field.
	COMP_SHORTS_READY_SAMPLE_Msk = 0x1
	// Bit READY_SAMPLE.
	COMP_SHORTS_READY_SAMPLE = 0x1
	// Disable shortcut
	COMP_SHORTS_READY_SAMPLE_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_READY_SAMPLE_Enabled = 0x1
	// Position of READY_STOP field.
	COMP_SHORTS_READY_STOP_Pos = 0x1
	// Bit mask of READY_STOP field.
	COMP_SHORTS_READY_STOP_Msk = 0x2
	// Bit READY_STOP.
	COMP_SHORTS_READY_STOP = 0x2
	// Disable shortcut
	COMP_SHORTS_READY_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_READY_STOP_Enabled = 0x1
	// Position of DOWN_STOP field.
	COMP_SHORTS_DOWN_STOP_Pos = 0x2
	// Bit mask of DOWN_STOP field.
	COMP_SHORTS_DOWN_STOP_Msk = 0x4
	// Bit DOWN_STOP.
	COMP_SHORTS_DOWN_STOP = 0x4
	// Disable shortcut
	COMP_SHORTS_DOWN_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_DOWN_STOP_Enabled = 0x1
	// Position of UP_STOP field.
	COMP_SHORTS_UP_STOP_Pos = 0x3
	// Bit mask of UP_STOP field.
	COMP_SHORTS_UP_STOP_Msk = 0x8
	// Bit UP_STOP.
	COMP_SHORTS_UP_STOP = 0x8
	// Disable shortcut
	COMP_SHORTS_UP_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_UP_STOP_Enabled = 0x1
	// Position of CROSS_STOP field.
	COMP_SHORTS_CROSS_STOP_Pos = 0x4
	// Bit mask of CROSS_STOP field.
	COMP_SHORTS_CROSS_STOP_Msk = 0x10
	// Bit CROSS_STOP.
	COMP_SHORTS_CROSS_STOP = 0x10
	// Disable shortcut
	COMP_SHORTS_CROSS_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_CROSS_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of READY field.
	COMP_INTEN_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTEN_READY_Msk = 0x1
	// Bit READY.
	COMP_INTEN_READY = 0x1
	// Disable
	COMP_INTEN_READY_Disabled = 0x0
	// Enable
	COMP_INTEN_READY_Enabled = 0x1
	// Position of DOWN field.
	COMP_INTEN_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTEN_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTEN_DOWN = 0x2
	// Disable
	COMP_INTEN_DOWN_Disabled = 0x0
	// Enable
	COMP_INTEN_DOWN_Enabled = 0x1
	// Position of UP field.
	COMP_INTEN_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTEN_UP_Msk = 0x4
	// Bit UP.
	COMP_INTEN_UP = 0x4
	// Disable
	COMP_INTEN_UP_Disabled = 0x0
	// Enable
	COMP_INTEN_UP_Enabled = 0x1
	// Position of CROSS field.
	COMP_INTEN_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTEN_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTEN_CROSS = 0x8
	// Disable
	COMP_INTEN_CROSS_Disabled = 0x0
	// Enable
	COMP_INTEN_CROSS_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	COMP_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTENSET_READY_Msk = 0x1
	// Bit READY.
	COMP_INTENSET_READY = 0x1
	// Read: Disabled
	COMP_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_READY_Enabled = 0x1
	// Enable
	COMP_INTENSET_READY_Set = 0x1
	// Position of DOWN field.
	COMP_INTENSET_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTENSET_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTENSET_DOWN = 0x2
	// Read: Disabled
	COMP_INTENSET_DOWN_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_DOWN_Enabled = 0x1
	// Enable
	COMP_INTENSET_DOWN_Set = 0x1
	// Position of UP field.
	COMP_INTENSET_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTENSET_UP_Msk = 0x4
	// Bit UP.
	COMP_INTENSET_UP = 0x4
	// Read: Disabled
	COMP_INTENSET_UP_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_UP_Enabled = 0x1
	// Enable
	COMP_INTENSET_UP_Set = 0x1
	// Position of CROSS field.
	COMP_INTENSET_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTENSET_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTENSET_CROSS = 0x8
	// Read: Disabled
	COMP_INTENSET_CROSS_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_CROSS_Enabled = 0x1
	// Enable
	COMP_INTENSET_CROSS_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	COMP_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	COMP_INTENCLR_READY = 0x1
	// Read: Disabled
	COMP_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_READY_Enabled = 0x1
	// Disable
	COMP_INTENCLR_READY_Clear = 0x1
	// Position of DOWN field.
	COMP_INTENCLR_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTENCLR_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTENCLR_DOWN = 0x2
	// Read: Disabled
	COMP_INTENCLR_DOWN_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_DOWN_Enabled = 0x1
	// Disable
	COMP_INTENCLR_DOWN_Clear = 0x1
	// Position of UP field.
	COMP_INTENCLR_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTENCLR_UP_Msk = 0x4
	// Bit UP.
	COMP_INTENCLR_UP = 0x4
	// Read: Disabled
	COMP_INTENCLR_UP_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_UP_Enabled = 0x1
	// Disable
	COMP_INTENCLR_UP_Clear = 0x1
	// Position of CROSS field.
	COMP_INTENCLR_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTENCLR_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTENCLR_CROSS = 0x8
	// Read: Disabled
	COMP_INTENCLR_CROSS_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_CROSS_Enabled = 0x1
	// Disable
	COMP_INTENCLR_CROSS_Clear = 0x1

	// RESULT: Compare result
	// Position of RESULT field.
	COMP_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	COMP_RESULT_RESULT_Msk = 0x1
	// Bit RESULT.
	COMP_RESULT_RESULT = 0x1
	// Input voltage is below the threshold (VIN+ &lt; VIN-)
	COMP_RESULT_RESULT_Below = 0x0
	// Input voltage is above the threshold (VIN+ &gt; VIN-)
	COMP_RESULT_RESULT_Above = 0x1

	// ENABLE: COMP enable
	// Position of ENABLE field.
	COMP_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	COMP_ENABLE_ENABLE_Msk = 0x3
	// Disable
	COMP_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	COMP_ENABLE_ENABLE_Enabled = 0x2

	// PSEL: Pin select
	// Position of PSEL field.
	COMP_PSEL_PSEL_Pos = 0x0
	// Bit mask of PSEL field.
	COMP_PSEL_PSEL_Msk = 0x7
	// AIN0 selected as analog input
	COMP_PSEL_PSEL_AnalogInput0 = 0x0
	// AIN1 selected as analog input
	COMP_PSEL_PSEL_AnalogInput1 = 0x1
	// AIN2 selected as analog input
	COMP_PSEL_PSEL_AnalogInput2 = 0x2
	// AIN3 selected as analog input
	COMP_PSEL_PSEL_AnalogInput3 = 0x3
	// AIN4 selected as analog input
	COMP_PSEL_PSEL_AnalogInput4 = 0x4
	// AIN5 selected as analog input
	COMP_PSEL_PSEL_AnalogInput5 = 0x5
	// AIN6 selected as analog input
	COMP_PSEL_PSEL_AnalogInput6 = 0x6
	// AIN7 selected as analog input
	COMP_PSEL_PSEL_AnalogInput7 = 0x7

	// REFSEL: Reference source select for single-ended mode
	// Position of REFSEL field.
	COMP_REFSEL_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	COMP_REFSEL_REFSEL_Msk = 0x7
	// VREF = internal 1.2 V reference (VDD &gt;= 1.7 V)
	COMP_REFSEL_REFSEL_Int1V2 = 0x0
	// VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V)
	COMP_REFSEL_REFSEL_Int1V8 = 0x1
	// VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V)
	COMP_REFSEL_REFSEL_Int2V4 = 0x2
	// VREF = VDD
	COMP_REFSEL_REFSEL_VDD = 0x4
	// VREF = AREF
	COMP_REFSEL_REFSEL_ARef = 0x5

	// EXTREFSEL: External reference select
	// Position of EXTREFSEL field.
	COMP_EXTREFSEL_EXTREFSEL_Pos = 0x0
	// Bit mask of EXTREFSEL field.
	COMP_EXTREFSEL_EXTREFSEL_Msk = 0x7
	// Use AIN0 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 = 0x0
	// Use AIN1 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 = 0x1
	// Use AIN2 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference2 = 0x2
	// Use AIN3 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference3 = 0x3
	// Use AIN4 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference4 = 0x4
	// Use AIN5 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference5 = 0x5
	// Use AIN6 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference6 = 0x6
	// Use AIN7 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference7 = 0x7

	// TH: Threshold configuration for hysteresis unit
	// Position of THDOWN field.
	COMP_TH_THDOWN_Pos = 0x0
	// Bit mask of THDOWN field.
	COMP_TH_THDOWN_Msk = 0x3f
	// Position of THUP field.
	COMP_TH_THUP_Pos = 0x8
	// Bit mask of THUP field.
	COMP_TH_THUP_Msk = 0x3f00

	// MODE: Mode configuration
	// Position of SP field.
	COMP_MODE_SP_Pos = 0x0
	// Bit mask of SP field.
	COMP_MODE_SP_Msk = 0x3
	// Low-power mode
	COMP_MODE_SP_Low = 0x0
	// Normal mode
	COMP_MODE_SP_Normal = 0x1
	// High-speed mode
	COMP_MODE_SP_High = 0x2
	// Position of MAIN field.
	COMP_MODE_MAIN_Pos = 0x8
	// Bit mask of MAIN field.
	COMP_MODE_MAIN_Msk = 0x100
	// Bit MAIN.
	COMP_MODE_MAIN = 0x100
	// Single-ended mode
	COMP_MODE_MAIN_SE = 0x0
	// Differential mode
	COMP_MODE_MAIN_Diff = 0x1

	// HYST: Comparator hysteresis enable
	// Position of HYST field.
	COMP_HYST_HYST_Pos = 0x0
	// Bit mask of HYST field.
	COMP_HYST_HYST_Msk = 0x1
	// Bit HYST.
	COMP_HYST_HYST = 0x1
	// Comparator hysteresis disabled
	COMP_HYST_HYST_NoHyst = 0x0
	// Comparator hysteresis enabled
	COMP_HYST_HYST_Hyst50mV = 0x1

	// ISOURCE: Current source select on analog input
	// Position of ISOURCE field.
	COMP_ISOURCE_ISOURCE_Pos = 0x0
	// Bit mask of ISOURCE field.
	COMP_ISOURCE_ISOURCE_Msk = 0x3
	// Current source disabled
	COMP_ISOURCE_ISOURCE_Off = 0x0
	// Current source enabled (+/- 2.5 uA)
	COMP_ISOURCE_ISOURCE_Ien2mA5 = 0x1
	// Current source enabled (+/- 5 uA)
	COMP_ISOURCE_ISOURCE_Ien5mA = 0x2
	// Current source enabled (+/- 10 uA)
	COMP_ISOURCE_ISOURCE_Ien10mA = 0x3
)

// Constants for LPCOMP_NS: Low-power comparator 0
const (
	// TASKS_START: Start comparator
	// Position of TASKS_START field.
	LPCOMP_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	LPCOMP_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	LPCOMP_TASKS_START_TASKS_START = 0x1
	// Trigger task
	LPCOMP_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop comparator
	// Position of TASKS_STOP field.
	LPCOMP_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	LPCOMP_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	LPCOMP_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	LPCOMP_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SAMPLE: Sample comparator value
	// Position of TASKS_SAMPLE field.
	LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos = 0x0
	// Bit mask of TASKS_SAMPLE field.
	LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Msk = 0x1
	// Bit TASKS_SAMPLE.
	LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE = 0x1
	// Trigger task
	LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	LPCOMP_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	LPCOMP_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	LPCOMP_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	LPCOMP_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	LPCOMP_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	LPCOMP_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_SAMPLE: Subscribe configuration for task SAMPLE
	// Position of CHIDX field.
	LPCOMP_SUBSCRIBE_SAMPLE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_SUBSCRIBE_SAMPLE_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_SUBSCRIBE_SAMPLE_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_SUBSCRIBE_SAMPLE_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_SUBSCRIBE_SAMPLE_EN = 0x80000000
	// Disable subscription
	LPCOMP_SUBSCRIBE_SAMPLE_EN_Disabled = 0x0
	// Enable subscription
	LPCOMP_SUBSCRIBE_SAMPLE_EN_Enabled = 0x1

	// EVENTS_READY: LPCOMP is ready and output is valid
	// Position of EVENTS_READY field.
	LPCOMP_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	LPCOMP_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	LPCOMP_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	LPCOMP_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	LPCOMP_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// EVENTS_DOWN: Downward crossing
	// Position of EVENTS_DOWN field.
	LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Pos = 0x0
	// Bit mask of EVENTS_DOWN field.
	LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Msk = 0x1
	// Bit EVENTS_DOWN.
	LPCOMP_EVENTS_DOWN_EVENTS_DOWN = 0x1
	// Event not generated
	LPCOMP_EVENTS_DOWN_EVENTS_DOWN_NotGenerated = 0x0
	// Event generated
	LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Generated = 0x1

	// EVENTS_UP: Upward crossing
	// Position of EVENTS_UP field.
	LPCOMP_EVENTS_UP_EVENTS_UP_Pos = 0x0
	// Bit mask of EVENTS_UP field.
	LPCOMP_EVENTS_UP_EVENTS_UP_Msk = 0x1
	// Bit EVENTS_UP.
	LPCOMP_EVENTS_UP_EVENTS_UP = 0x1
	// Event not generated
	LPCOMP_EVENTS_UP_EVENTS_UP_NotGenerated = 0x0
	// Event generated
	LPCOMP_EVENTS_UP_EVENTS_UP_Generated = 0x1

	// EVENTS_CROSS: Downward or upward crossing
	// Position of EVENTS_CROSS field.
	LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Pos = 0x0
	// Bit mask of EVENTS_CROSS field.
	LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Msk = 0x1
	// Bit EVENTS_CROSS.
	LPCOMP_EVENTS_CROSS_EVENTS_CROSS = 0x1
	// Event not generated
	LPCOMP_EVENTS_CROSS_EVENTS_CROSS_NotGenerated = 0x0
	// Event generated
	LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Generated = 0x1

	// PUBLISH_READY: Publish configuration for event READY
	// Position of CHIDX field.
	LPCOMP_PUBLISH_READY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_PUBLISH_READY_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_PUBLISH_READY_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_PUBLISH_READY_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_PUBLISH_READY_EN = 0x80000000
	// Disable publishing
	LPCOMP_PUBLISH_READY_EN_Disabled = 0x0
	// Enable publishing
	LPCOMP_PUBLISH_READY_EN_Enabled = 0x1

	// PUBLISH_DOWN: Publish configuration for event DOWN
	// Position of CHIDX field.
	LPCOMP_PUBLISH_DOWN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_PUBLISH_DOWN_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_PUBLISH_DOWN_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_PUBLISH_DOWN_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_PUBLISH_DOWN_EN = 0x80000000
	// Disable publishing
	LPCOMP_PUBLISH_DOWN_EN_Disabled = 0x0
	// Enable publishing
	LPCOMP_PUBLISH_DOWN_EN_Enabled = 0x1

	// PUBLISH_UP: Publish configuration for event UP
	// Position of CHIDX field.
	LPCOMP_PUBLISH_UP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_PUBLISH_UP_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_PUBLISH_UP_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_PUBLISH_UP_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_PUBLISH_UP_EN = 0x80000000
	// Disable publishing
	LPCOMP_PUBLISH_UP_EN_Disabled = 0x0
	// Enable publishing
	LPCOMP_PUBLISH_UP_EN_Enabled = 0x1

	// PUBLISH_CROSS: Publish configuration for event CROSS
	// Position of CHIDX field.
	LPCOMP_PUBLISH_CROSS_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	LPCOMP_PUBLISH_CROSS_CHIDX_Msk = 0xff
	// Position of EN field.
	LPCOMP_PUBLISH_CROSS_EN_Pos = 0x1f
	// Bit mask of EN field.
	LPCOMP_PUBLISH_CROSS_EN_Msk = 0x80000000
	// Bit EN.
	LPCOMP_PUBLISH_CROSS_EN = 0x80000000
	// Disable publishing
	LPCOMP_PUBLISH_CROSS_EN_Disabled = 0x0
	// Enable publishing
	LPCOMP_PUBLISH_CROSS_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of READY_SAMPLE field.
	LPCOMP_SHORTS_READY_SAMPLE_Pos = 0x0
	// Bit mask of READY_SAMPLE field.
	LPCOMP_SHORTS_READY_SAMPLE_Msk = 0x1
	// Bit READY_SAMPLE.
	LPCOMP_SHORTS_READY_SAMPLE = 0x1
	// Disable shortcut
	LPCOMP_SHORTS_READY_SAMPLE_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_READY_SAMPLE_Enabled = 0x1
	// Position of READY_STOP field.
	LPCOMP_SHORTS_READY_STOP_Pos = 0x1
	// Bit mask of READY_STOP field.
	LPCOMP_SHORTS_READY_STOP_Msk = 0x2
	// Bit READY_STOP.
	LPCOMP_SHORTS_READY_STOP = 0x2
	// Disable shortcut
	LPCOMP_SHORTS_READY_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_READY_STOP_Enabled = 0x1
	// Position of DOWN_STOP field.
	LPCOMP_SHORTS_DOWN_STOP_Pos = 0x2
	// Bit mask of DOWN_STOP field.
	LPCOMP_SHORTS_DOWN_STOP_Msk = 0x4
	// Bit DOWN_STOP.
	LPCOMP_SHORTS_DOWN_STOP = 0x4
	// Disable shortcut
	LPCOMP_SHORTS_DOWN_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_DOWN_STOP_Enabled = 0x1
	// Position of UP_STOP field.
	LPCOMP_SHORTS_UP_STOP_Pos = 0x3
	// Bit mask of UP_STOP field.
	LPCOMP_SHORTS_UP_STOP_Msk = 0x8
	// Bit UP_STOP.
	LPCOMP_SHORTS_UP_STOP = 0x8
	// Disable shortcut
	LPCOMP_SHORTS_UP_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_UP_STOP_Enabled = 0x1
	// Position of CROSS_STOP field.
	LPCOMP_SHORTS_CROSS_STOP_Pos = 0x4
	// Bit mask of CROSS_STOP field.
	LPCOMP_SHORTS_CROSS_STOP_Msk = 0x10
	// Bit CROSS_STOP.
	LPCOMP_SHORTS_CROSS_STOP = 0x10
	// Disable shortcut
	LPCOMP_SHORTS_CROSS_STOP_Disabled = 0x0
	// Enable shortcut
	LPCOMP_SHORTS_CROSS_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	LPCOMP_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	LPCOMP_INTENSET_READY_Msk = 0x1
	// Bit READY.
	LPCOMP_INTENSET_READY = 0x1
	// Read: Disabled
	LPCOMP_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_READY_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_READY_Set = 0x1
	// Position of DOWN field.
	LPCOMP_INTENSET_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	LPCOMP_INTENSET_DOWN_Msk = 0x2
	// Bit DOWN.
	LPCOMP_INTENSET_DOWN = 0x2
	// Read: Disabled
	LPCOMP_INTENSET_DOWN_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_DOWN_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_DOWN_Set = 0x1
	// Position of UP field.
	LPCOMP_INTENSET_UP_Pos = 0x2
	// Bit mask of UP field.
	LPCOMP_INTENSET_UP_Msk = 0x4
	// Bit UP.
	LPCOMP_INTENSET_UP = 0x4
	// Read: Disabled
	LPCOMP_INTENSET_UP_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_UP_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_UP_Set = 0x1
	// Position of CROSS field.
	LPCOMP_INTENSET_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	LPCOMP_INTENSET_CROSS_Msk = 0x8
	// Bit CROSS.
	LPCOMP_INTENSET_CROSS = 0x8
	// Read: Disabled
	LPCOMP_INTENSET_CROSS_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENSET_CROSS_Enabled = 0x1
	// Enable
	LPCOMP_INTENSET_CROSS_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	LPCOMP_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	LPCOMP_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	LPCOMP_INTENCLR_READY = 0x1
	// Read: Disabled
	LPCOMP_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_READY_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_READY_Clear = 0x1
	// Position of DOWN field.
	LPCOMP_INTENCLR_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	LPCOMP_INTENCLR_DOWN_Msk = 0x2
	// Bit DOWN.
	LPCOMP_INTENCLR_DOWN = 0x2
	// Read: Disabled
	LPCOMP_INTENCLR_DOWN_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_DOWN_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_DOWN_Clear = 0x1
	// Position of UP field.
	LPCOMP_INTENCLR_UP_Pos = 0x2
	// Bit mask of UP field.
	LPCOMP_INTENCLR_UP_Msk = 0x4
	// Bit UP.
	LPCOMP_INTENCLR_UP = 0x4
	// Read: Disabled
	LPCOMP_INTENCLR_UP_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_UP_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_UP_Clear = 0x1
	// Position of CROSS field.
	LPCOMP_INTENCLR_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	LPCOMP_INTENCLR_CROSS_Msk = 0x8
	// Bit CROSS.
	LPCOMP_INTENCLR_CROSS = 0x8
	// Read: Disabled
	LPCOMP_INTENCLR_CROSS_Disabled = 0x0
	// Read: Enabled
	LPCOMP_INTENCLR_CROSS_Enabled = 0x1
	// Disable
	LPCOMP_INTENCLR_CROSS_Clear = 0x1

	// RESULT: Compare result
	// Position of RESULT field.
	LPCOMP_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	LPCOMP_RESULT_RESULT_Msk = 0x1
	// Bit RESULT.
	LPCOMP_RESULT_RESULT = 0x1
	// Input voltage is below the reference threshold (VIN+ &lt; VIN-)
	LPCOMP_RESULT_RESULT_Below = 0x0
	// Input voltage is above the reference threshold (VIN+ &gt; VIN-)
	LPCOMP_RESULT_RESULT_Above = 0x1

	// ENABLE: Enable LPCOMP
	// Position of ENABLE field.
	LPCOMP_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPCOMP_ENABLE_ENABLE_Msk = 0x3
	// Disable
	LPCOMP_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	LPCOMP_ENABLE_ENABLE_Enabled = 0x1

	// PSEL: Input pin select
	// Position of PSEL field.
	LPCOMP_PSEL_PSEL_Pos = 0x0
	// Bit mask of PSEL field.
	LPCOMP_PSEL_PSEL_Msk = 0x7
	// AIN0 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput0 = 0x0
	// AIN1 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput1 = 0x1
	// AIN2 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput2 = 0x2
	// AIN3 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput3 = 0x3
	// AIN4 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput4 = 0x4
	// AIN5 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput5 = 0x5
	// AIN6 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput6 = 0x6
	// AIN7 selected as analog input
	LPCOMP_PSEL_PSEL_AnalogInput7 = 0x7

	// REFSEL: Reference select
	// Position of REFSEL field.
	LPCOMP_REFSEL_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	LPCOMP_REFSEL_REFSEL_Msk = 0xf
	// VDD * 1/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref1_8Vdd = 0x0
	// VDD * 2/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref2_8Vdd = 0x1
	// VDD * 3/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref3_8Vdd = 0x2
	// VDD * 4/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref4_8Vdd = 0x3
	// VDD * 5/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref5_8Vdd = 0x4
	// VDD * 6/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref6_8Vdd = 0x5
	// VDD * 7/8 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref7_8Vdd = 0x6
	// External analog reference selected
	LPCOMP_REFSEL_REFSEL_ARef = 0x7
	// VDD * 1/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref1_16Vdd = 0x8
	// VDD * 3/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref3_16Vdd = 0x9
	// VDD * 5/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref5_16Vdd = 0xa
	// VDD * 7/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref7_16Vdd = 0xb
	// VDD * 9/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref9_16Vdd = 0xc
	// VDD * 11/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref11_16Vdd = 0xd
	// VDD * 13/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref13_16Vdd = 0xe
	// VDD * 15/16 selected as reference
	LPCOMP_REFSEL_REFSEL_Ref15_16Vdd = 0xf

	// EXTREFSEL: External reference select
	// Position of EXTREFSEL field.
	LPCOMP_EXTREFSEL_EXTREFSEL_Pos = 0x0
	// Bit mask of EXTREFSEL field.
	LPCOMP_EXTREFSEL_EXTREFSEL_Msk = 0x1
	// Bit EXTREFSEL.
	LPCOMP_EXTREFSEL_EXTREFSEL = 0x1
	// Use AIN0 as external analog reference
	LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 = 0x0
	// Use AIN1 as external analog reference
	LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 = 0x1

	// ANADETECT: Analog detect configuration
	// Position of ANADETECT field.
	LPCOMP_ANADETECT_ANADETECT_Pos = 0x0
	// Bit mask of ANADETECT field.
	LPCOMP_ANADETECT_ANADETECT_Msk = 0x3
	// Generate ANADETECT on crossing, both upward crossing and downward crossing
	LPCOMP_ANADETECT_ANADETECT_Cross = 0x0
	// Generate ANADETECT on upward crossing only
	LPCOMP_ANADETECT_ANADETECT_Up = 0x1
	// Generate ANADETECT on downward crossing only
	LPCOMP_ANADETECT_ANADETECT_Down = 0x2

	// HYST: Comparator hysteresis enable
	// Position of HYST field.
	LPCOMP_HYST_HYST_Pos = 0x0
	// Bit mask of HYST field.
	LPCOMP_HYST_HYST_Msk = 0x1
	// Bit HYST.
	LPCOMP_HYST_HYST = 0x1
	// Comparator hysteresis disabled
	LPCOMP_HYST_HYST_Disabled = 0x0
	// Comparator hysteresis enabled
	LPCOMP_HYST_HYST_Enabled = 0x1
)

// Constants for EGU0_NS: Event generator unit 0
const (
	// TASKS_TRIGGER: Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
	// Position of TASKS_TRIGGER field.
	EGU_TASKS_TRIGGER_TASKS_TRIGGER_Pos = 0x0
	// Bit mask of TASKS_TRIGGER field.
	EGU_TASKS_TRIGGER_TASKS_TRIGGER_Msk = 0x1
	// Bit TASKS_TRIGGER.
	EGU_TASKS_TRIGGER_TASKS_TRIGGER = 0x1
	// Trigger task
	EGU_TASKS_TRIGGER_TASKS_TRIGGER_Trigger = 0x1

	// SUBSCRIBE_TRIGGER: Description collection: Subscribe configuration for task TRIGGER[n]
	// Position of CHIDX field.
	EGU_SUBSCRIBE_TRIGGER_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	EGU_SUBSCRIBE_TRIGGER_CHIDX_Msk = 0xff
	// Position of EN field.
	EGU_SUBSCRIBE_TRIGGER_EN_Pos = 0x1f
	// Bit mask of EN field.
	EGU_SUBSCRIBE_TRIGGER_EN_Msk = 0x80000000
	// Bit EN.
	EGU_SUBSCRIBE_TRIGGER_EN = 0x80000000
	// Disable subscription
	EGU_SUBSCRIBE_TRIGGER_EN_Disabled = 0x0
	// Enable subscription
	EGU_SUBSCRIBE_TRIGGER_EN_Enabled = 0x1

	// EVENTS_TRIGGERED: Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
	// Position of EVENTS_TRIGGERED field.
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Pos = 0x0
	// Bit mask of EVENTS_TRIGGERED field.
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Msk = 0x1
	// Bit EVENTS_TRIGGERED.
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED = 0x1
	// Event not generated
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_NotGenerated = 0x0
	// Event generated
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Generated = 0x1

	// PUBLISH_TRIGGERED: Description collection: Publish configuration for event TRIGGERED[n]
	// Position of CHIDX field.
	EGU_PUBLISH_TRIGGERED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	EGU_PUBLISH_TRIGGERED_CHIDX_Msk = 0xff
	// Position of EN field.
	EGU_PUBLISH_TRIGGERED_EN_Pos = 0x1f
	// Bit mask of EN field.
	EGU_PUBLISH_TRIGGERED_EN_Msk = 0x80000000
	// Bit EN.
	EGU_PUBLISH_TRIGGERED_EN = 0x80000000
	// Disable publishing
	EGU_PUBLISH_TRIGGERED_EN_Disabled = 0x0
	// Enable publishing
	EGU_PUBLISH_TRIGGERED_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTEN_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTEN_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTEN_TRIGGERED0 = 0x1
	// Disable
	EGU_INTEN_TRIGGERED0_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED0_Enabled = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTEN_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTEN_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTEN_TRIGGERED1 = 0x2
	// Disable
	EGU_INTEN_TRIGGERED1_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED1_Enabled = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTEN_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTEN_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTEN_TRIGGERED2 = 0x4
	// Disable
	EGU_INTEN_TRIGGERED2_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED2_Enabled = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTEN_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTEN_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTEN_TRIGGERED3 = 0x8
	// Disable
	EGU_INTEN_TRIGGERED3_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED3_Enabled = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTEN_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTEN_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTEN_TRIGGERED4 = 0x10
	// Disable
	EGU_INTEN_TRIGGERED4_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED4_Enabled = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTEN_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTEN_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTEN_TRIGGERED5 = 0x20
	// Disable
	EGU_INTEN_TRIGGERED5_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED5_Enabled = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTEN_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTEN_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTEN_TRIGGERED6 = 0x40
	// Disable
	EGU_INTEN_TRIGGERED6_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED6_Enabled = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTEN_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTEN_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTEN_TRIGGERED7 = 0x80
	// Disable
	EGU_INTEN_TRIGGERED7_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED7_Enabled = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTEN_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTEN_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTEN_TRIGGERED8 = 0x100
	// Disable
	EGU_INTEN_TRIGGERED8_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED8_Enabled = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTEN_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTEN_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTEN_TRIGGERED9 = 0x200
	// Disable
	EGU_INTEN_TRIGGERED9_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED9_Enabled = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTEN_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTEN_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTEN_TRIGGERED10 = 0x400
	// Disable
	EGU_INTEN_TRIGGERED10_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED10_Enabled = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTEN_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTEN_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTEN_TRIGGERED11 = 0x800
	// Disable
	EGU_INTEN_TRIGGERED11_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED11_Enabled = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTEN_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTEN_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTEN_TRIGGERED12 = 0x1000
	// Disable
	EGU_INTEN_TRIGGERED12_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED12_Enabled = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTEN_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTEN_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTEN_TRIGGERED13 = 0x2000
	// Disable
	EGU_INTEN_TRIGGERED13_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED13_Enabled = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTEN_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTEN_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTEN_TRIGGERED14 = 0x4000
	// Disable
	EGU_INTEN_TRIGGERED14_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED14_Enabled = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTEN_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTEN_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTEN_TRIGGERED15 = 0x8000
	// Disable
	EGU_INTEN_TRIGGERED15_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED15_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTENSET_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTENSET_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTENSET_TRIGGERED0 = 0x1
	// Read: Disabled
	EGU_INTENSET_TRIGGERED0_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED0_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED0_Set = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTENSET_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTENSET_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTENSET_TRIGGERED1 = 0x2
	// Read: Disabled
	EGU_INTENSET_TRIGGERED1_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED1_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED1_Set = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTENSET_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTENSET_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTENSET_TRIGGERED2 = 0x4
	// Read: Disabled
	EGU_INTENSET_TRIGGERED2_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED2_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED2_Set = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTENSET_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTENSET_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTENSET_TRIGGERED3 = 0x8
	// Read: Disabled
	EGU_INTENSET_TRIGGERED3_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED3_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED3_Set = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTENSET_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTENSET_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTENSET_TRIGGERED4 = 0x10
	// Read: Disabled
	EGU_INTENSET_TRIGGERED4_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED4_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED4_Set = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTENSET_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTENSET_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTENSET_TRIGGERED5 = 0x20
	// Read: Disabled
	EGU_INTENSET_TRIGGERED5_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED5_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED5_Set = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTENSET_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTENSET_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTENSET_TRIGGERED6 = 0x40
	// Read: Disabled
	EGU_INTENSET_TRIGGERED6_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED6_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED6_Set = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTENSET_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTENSET_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTENSET_TRIGGERED7 = 0x80
	// Read: Disabled
	EGU_INTENSET_TRIGGERED7_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED7_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED7_Set = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTENSET_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTENSET_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTENSET_TRIGGERED8 = 0x100
	// Read: Disabled
	EGU_INTENSET_TRIGGERED8_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED8_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED8_Set = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTENSET_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTENSET_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTENSET_TRIGGERED9 = 0x200
	// Read: Disabled
	EGU_INTENSET_TRIGGERED9_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED9_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED9_Set = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTENSET_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTENSET_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTENSET_TRIGGERED10 = 0x400
	// Read: Disabled
	EGU_INTENSET_TRIGGERED10_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED10_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED10_Set = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTENSET_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTENSET_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTENSET_TRIGGERED11 = 0x800
	// Read: Disabled
	EGU_INTENSET_TRIGGERED11_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED11_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED11_Set = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTENSET_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTENSET_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTENSET_TRIGGERED12 = 0x1000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED12_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED12_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED12_Set = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTENSET_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTENSET_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTENSET_TRIGGERED13 = 0x2000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED13_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED13_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED13_Set = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTENSET_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTENSET_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTENSET_TRIGGERED14 = 0x4000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED14_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED14_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED14_Set = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTENSET_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTENSET_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTENSET_TRIGGERED15 = 0x8000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED15_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED15_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED15_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTENCLR_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTENCLR_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTENCLR_TRIGGERED0 = 0x1
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED0_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED0_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED0_Clear = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTENCLR_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTENCLR_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTENCLR_TRIGGERED1 = 0x2
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED1_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED1_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED1_Clear = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTENCLR_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTENCLR_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTENCLR_TRIGGERED2 = 0x4
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED2_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED2_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED2_Clear = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTENCLR_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTENCLR_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTENCLR_TRIGGERED3 = 0x8
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED3_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED3_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED3_Clear = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTENCLR_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTENCLR_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTENCLR_TRIGGERED4 = 0x10
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED4_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED4_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED4_Clear = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTENCLR_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTENCLR_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTENCLR_TRIGGERED5 = 0x20
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED5_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED5_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED5_Clear = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTENCLR_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTENCLR_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTENCLR_TRIGGERED6 = 0x40
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED6_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED6_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED6_Clear = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTENCLR_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTENCLR_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTENCLR_TRIGGERED7 = 0x80
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED7_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED7_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED7_Clear = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTENCLR_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTENCLR_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTENCLR_TRIGGERED8 = 0x100
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED8_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED8_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED8_Clear = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTENCLR_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTENCLR_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTENCLR_TRIGGERED9 = 0x200
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED9_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED9_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED9_Clear = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTENCLR_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTENCLR_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTENCLR_TRIGGERED10 = 0x400
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED10_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED10_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED10_Clear = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTENCLR_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTENCLR_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTENCLR_TRIGGERED11 = 0x800
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED11_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED11_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED11_Clear = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTENCLR_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTENCLR_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTENCLR_TRIGGERED12 = 0x1000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED12_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED12_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED12_Clear = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTENCLR_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTENCLR_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTENCLR_TRIGGERED13 = 0x2000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED13_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED13_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED13_Clear = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTENCLR_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTENCLR_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTENCLR_TRIGGERED14 = 0x4000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED14_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED14_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED14_Clear = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTENCLR_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTENCLR_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTENCLR_TRIGGERED15 = 0x8000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED15_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED15_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED15_Clear = 0x1
)

// Constants for PWM0_NS: Pulse width modulation unit 0
const (
	// TASKS_STOP: Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
	// Position of TASKS_STOP field.
	PWM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	PWM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	PWM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	PWM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SEQSTART: Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
	// Position of TASKS_SEQSTART field.
	PWM_TASKS_SEQSTART_TASKS_SEQSTART_Pos = 0x0
	// Bit mask of TASKS_SEQSTART field.
	PWM_TASKS_SEQSTART_TASKS_SEQSTART_Msk = 0x1
	// Bit TASKS_SEQSTART.
	PWM_TASKS_SEQSTART_TASKS_SEQSTART = 0x1
	// Trigger task
	PWM_TASKS_SEQSTART_TASKS_SEQSTART_Trigger = 0x1

	// TASKS_NEXTSTEP: Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
	// Position of TASKS_NEXTSTEP field.
	PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Pos = 0x0
	// Bit mask of TASKS_NEXTSTEP field.
	PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Msk = 0x1
	// Bit TASKS_NEXTSTEP.
	PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP = 0x1
	// Trigger task
	PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Trigger = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	PWM_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	PWM_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	PWM_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	PWM_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_SEQSTART: Description collection: Subscribe configuration for task SEQSTART[n]
	// Position of CHIDX field.
	PWM_SUBSCRIBE_SEQSTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_SUBSCRIBE_SEQSTART_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_SUBSCRIBE_SEQSTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_SUBSCRIBE_SEQSTART_EN_Msk = 0x80000000
	// Bit EN.
	PWM_SUBSCRIBE_SEQSTART_EN = 0x80000000
	// Disable subscription
	PWM_SUBSCRIBE_SEQSTART_EN_Disabled = 0x0
	// Enable subscription
	PWM_SUBSCRIBE_SEQSTART_EN_Enabled = 0x1

	// SUBSCRIBE_NEXTSTEP: Subscribe configuration for task NEXTSTEP
	// Position of CHIDX field.
	PWM_SUBSCRIBE_NEXTSTEP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_SUBSCRIBE_NEXTSTEP_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_SUBSCRIBE_NEXTSTEP_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_SUBSCRIBE_NEXTSTEP_EN_Msk = 0x80000000
	// Bit EN.
	PWM_SUBSCRIBE_NEXTSTEP_EN = 0x80000000
	// Disable subscription
	PWM_SUBSCRIBE_NEXTSTEP_EN_Disabled = 0x0
	// Enable subscription
	PWM_SUBSCRIBE_NEXTSTEP_EN_Enabled = 0x1

	// EVENTS_STOPPED: Response to STOP task, emitted when PWM pulses are no longer generated
	// Position of EVENTS_STOPPED field.
	PWM_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	PWM_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	PWM_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	PWM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	PWM_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_SEQSTARTED: Description collection: First PWM period started on sequence n
	// Position of EVENTS_SEQSTARTED field.
	PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Pos = 0x0
	// Bit mask of EVENTS_SEQSTARTED field.
	PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Msk = 0x1
	// Bit EVENTS_SEQSTARTED.
	PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED = 0x1
	// Event not generated
	PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_NotGenerated = 0x0
	// Event generated
	PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Generated = 0x1

	// EVENTS_SEQEND: Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
	// Position of EVENTS_SEQEND field.
	PWM_EVENTS_SEQEND_EVENTS_SEQEND_Pos = 0x0
	// Bit mask of EVENTS_SEQEND field.
	PWM_EVENTS_SEQEND_EVENTS_SEQEND_Msk = 0x1
	// Bit EVENTS_SEQEND.
	PWM_EVENTS_SEQEND_EVENTS_SEQEND = 0x1
	// Event not generated
	PWM_EVENTS_SEQEND_EVENTS_SEQEND_NotGenerated = 0x0
	// Event generated
	PWM_EVENTS_SEQEND_EVENTS_SEQEND_Generated = 0x1

	// EVENTS_PWMPERIODEND: Emitted at the end of each PWM period
	// Position of EVENTS_PWMPERIODEND field.
	PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Pos = 0x0
	// Bit mask of EVENTS_PWMPERIODEND field.
	PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Msk = 0x1
	// Bit EVENTS_PWMPERIODEND.
	PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND = 0x1
	// Event not generated
	PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_NotGenerated = 0x0
	// Event generated
	PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Generated = 0x1

	// EVENTS_LOOPSDONE: Concatenated sequences have been played the amount of times defined in LOOP.CNT
	// Position of EVENTS_LOOPSDONE field.
	PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Pos = 0x0
	// Bit mask of EVENTS_LOOPSDONE field.
	PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Msk = 0x1
	// Bit EVENTS_LOOPSDONE.
	PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE = 0x1
	// Event not generated
	PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_NotGenerated = 0x0
	// Event generated
	PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Generated = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	PWM_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	PWM_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	PWM_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	PWM_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_SEQSTARTED: Description collection: Publish configuration for event SEQSTARTED[n]
	// Position of CHIDX field.
	PWM_PUBLISH_SEQSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_PUBLISH_SEQSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_PUBLISH_SEQSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_PUBLISH_SEQSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	PWM_PUBLISH_SEQSTARTED_EN = 0x80000000
	// Disable publishing
	PWM_PUBLISH_SEQSTARTED_EN_Disabled = 0x0
	// Enable publishing
	PWM_PUBLISH_SEQSTARTED_EN_Enabled = 0x1

	// PUBLISH_SEQEND: Description collection: Publish configuration for event SEQEND[n]
	// Position of CHIDX field.
	PWM_PUBLISH_SEQEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_PUBLISH_SEQEND_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_PUBLISH_SEQEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_PUBLISH_SEQEND_EN_Msk = 0x80000000
	// Bit EN.
	PWM_PUBLISH_SEQEND_EN = 0x80000000
	// Disable publishing
	PWM_PUBLISH_SEQEND_EN_Disabled = 0x0
	// Enable publishing
	PWM_PUBLISH_SEQEND_EN_Enabled = 0x1

	// PUBLISH_PWMPERIODEND: Publish configuration for event PWMPERIODEND
	// Position of CHIDX field.
	PWM_PUBLISH_PWMPERIODEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_PUBLISH_PWMPERIODEND_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_PUBLISH_PWMPERIODEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_PUBLISH_PWMPERIODEND_EN_Msk = 0x80000000
	// Bit EN.
	PWM_PUBLISH_PWMPERIODEND_EN = 0x80000000
	// Disable publishing
	PWM_PUBLISH_PWMPERIODEND_EN_Disabled = 0x0
	// Enable publishing
	PWM_PUBLISH_PWMPERIODEND_EN_Enabled = 0x1

	// PUBLISH_LOOPSDONE: Publish configuration for event LOOPSDONE
	// Position of CHIDX field.
	PWM_PUBLISH_LOOPSDONE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PWM_PUBLISH_LOOPSDONE_CHIDX_Msk = 0xff
	// Position of EN field.
	PWM_PUBLISH_LOOPSDONE_EN_Pos = 0x1f
	// Bit mask of EN field.
	PWM_PUBLISH_LOOPSDONE_EN_Msk = 0x80000000
	// Bit EN.
	PWM_PUBLISH_LOOPSDONE_EN = 0x80000000
	// Disable publishing
	PWM_PUBLISH_LOOPSDONE_EN_Disabled = 0x0
	// Enable publishing
	PWM_PUBLISH_LOOPSDONE_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of SEQEND0_STOP field.
	PWM_SHORTS_SEQEND0_STOP_Pos = 0x0
	// Bit mask of SEQEND0_STOP field.
	PWM_SHORTS_SEQEND0_STOP_Msk = 0x1
	// Bit SEQEND0_STOP.
	PWM_SHORTS_SEQEND0_STOP = 0x1
	// Disable shortcut
	PWM_SHORTS_SEQEND0_STOP_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_SEQEND0_STOP_Enabled = 0x1
	// Position of SEQEND1_STOP field.
	PWM_SHORTS_SEQEND1_STOP_Pos = 0x1
	// Bit mask of SEQEND1_STOP field.
	PWM_SHORTS_SEQEND1_STOP_Msk = 0x2
	// Bit SEQEND1_STOP.
	PWM_SHORTS_SEQEND1_STOP = 0x2
	// Disable shortcut
	PWM_SHORTS_SEQEND1_STOP_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_SEQEND1_STOP_Enabled = 0x1
	// Position of LOOPSDONE_SEQSTART0 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos = 0x2
	// Bit mask of LOOPSDONE_SEQSTART0 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Msk = 0x4
	// Bit LOOPSDONE_SEQSTART0.
	PWM_SHORTS_LOOPSDONE_SEQSTART0 = 0x4
	// Disable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART0_Enabled = 0x1
	// Position of LOOPSDONE_SEQSTART1 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos = 0x3
	// Bit mask of LOOPSDONE_SEQSTART1 field.
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Msk = 0x8
	// Bit LOOPSDONE_SEQSTART1.
	PWM_SHORTS_LOOPSDONE_SEQSTART1 = 0x8
	// Disable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_LOOPSDONE_SEQSTART1_Enabled = 0x1
	// Position of LOOPSDONE_STOP field.
	PWM_SHORTS_LOOPSDONE_STOP_Pos = 0x4
	// Bit mask of LOOPSDONE_STOP field.
	PWM_SHORTS_LOOPSDONE_STOP_Msk = 0x10
	// Bit LOOPSDONE_STOP.
	PWM_SHORTS_LOOPSDONE_STOP = 0x10
	// Disable shortcut
	PWM_SHORTS_LOOPSDONE_STOP_Disabled = 0x0
	// Enable shortcut
	PWM_SHORTS_LOOPSDONE_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	PWM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PWM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PWM_INTEN_STOPPED = 0x2
	// Disable
	PWM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	PWM_INTEN_STOPPED_Enabled = 0x1
	// Position of SEQSTARTED0 field.
	PWM_INTEN_SEQSTARTED0_Pos = 0x2
	// Bit mask of SEQSTARTED0 field.
	PWM_INTEN_SEQSTARTED0_Msk = 0x4
	// Bit SEQSTARTED0.
	PWM_INTEN_SEQSTARTED0 = 0x4
	// Disable
	PWM_INTEN_SEQSTARTED0_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQSTARTED0_Enabled = 0x1
	// Position of SEQSTARTED1 field.
	PWM_INTEN_SEQSTARTED1_Pos = 0x3
	// Bit mask of SEQSTARTED1 field.
	PWM_INTEN_SEQSTARTED1_Msk = 0x8
	// Bit SEQSTARTED1.
	PWM_INTEN_SEQSTARTED1 = 0x8
	// Disable
	PWM_INTEN_SEQSTARTED1_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQSTARTED1_Enabled = 0x1
	// Position of SEQEND0 field.
	PWM_INTEN_SEQEND0_Pos = 0x4
	// Bit mask of SEQEND0 field.
	PWM_INTEN_SEQEND0_Msk = 0x10
	// Bit SEQEND0.
	PWM_INTEN_SEQEND0 = 0x10
	// Disable
	PWM_INTEN_SEQEND0_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQEND0_Enabled = 0x1
	// Position of SEQEND1 field.
	PWM_INTEN_SEQEND1_Pos = 0x5
	// Bit mask of SEQEND1 field.
	PWM_INTEN_SEQEND1_Msk = 0x20
	// Bit SEQEND1.
	PWM_INTEN_SEQEND1 = 0x20
	// Disable
	PWM_INTEN_SEQEND1_Disabled = 0x0
	// Enable
	PWM_INTEN_SEQEND1_Enabled = 0x1
	// Position of PWMPERIODEND field.
	PWM_INTEN_PWMPERIODEND_Pos = 0x6
	// Bit mask of PWMPERIODEND field.
	PWM_INTEN_PWMPERIODEND_Msk = 0x40
	// Bit PWMPERIODEND.
	PWM_INTEN_PWMPERIODEND = 0x40
	// Disable
	PWM_INTEN_PWMPERIODEND_Disabled = 0x0
	// Enable
	PWM_INTEN_PWMPERIODEND_Enabled = 0x1
	// Position of LOOPSDONE field.
	PWM_INTEN_LOOPSDONE_Pos = 0x7
	// Bit mask of LOOPSDONE field.
	PWM_INTEN_LOOPSDONE_Msk = 0x80
	// Bit LOOPSDONE.
	PWM_INTEN_LOOPSDONE = 0x80
	// Disable
	PWM_INTEN_LOOPSDONE_Disabled = 0x0
	// Enable
	PWM_INTEN_LOOPSDONE_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	PWM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PWM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PWM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	PWM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	PWM_INTENSET_STOPPED_Set = 0x1
	// Position of SEQSTARTED0 field.
	PWM_INTENSET_SEQSTARTED0_Pos = 0x2
	// Bit mask of SEQSTARTED0 field.
	PWM_INTENSET_SEQSTARTED0_Msk = 0x4
	// Bit SEQSTARTED0.
	PWM_INTENSET_SEQSTARTED0 = 0x4
	// Read: Disabled
	PWM_INTENSET_SEQSTARTED0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQSTARTED0_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQSTARTED0_Set = 0x1
	// Position of SEQSTARTED1 field.
	PWM_INTENSET_SEQSTARTED1_Pos = 0x3
	// Bit mask of SEQSTARTED1 field.
	PWM_INTENSET_SEQSTARTED1_Msk = 0x8
	// Bit SEQSTARTED1.
	PWM_INTENSET_SEQSTARTED1 = 0x8
	// Read: Disabled
	PWM_INTENSET_SEQSTARTED1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQSTARTED1_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQSTARTED1_Set = 0x1
	// Position of SEQEND0 field.
	PWM_INTENSET_SEQEND0_Pos = 0x4
	// Bit mask of SEQEND0 field.
	PWM_INTENSET_SEQEND0_Msk = 0x10
	// Bit SEQEND0.
	PWM_INTENSET_SEQEND0 = 0x10
	// Read: Disabled
	PWM_INTENSET_SEQEND0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQEND0_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQEND0_Set = 0x1
	// Position of SEQEND1 field.
	PWM_INTENSET_SEQEND1_Pos = 0x5
	// Bit mask of SEQEND1 field.
	PWM_INTENSET_SEQEND1_Msk = 0x20
	// Bit SEQEND1.
	PWM_INTENSET_SEQEND1 = 0x20
	// Read: Disabled
	PWM_INTENSET_SEQEND1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_SEQEND1_Enabled = 0x1
	// Enable
	PWM_INTENSET_SEQEND1_Set = 0x1
	// Position of PWMPERIODEND field.
	PWM_INTENSET_PWMPERIODEND_Pos = 0x6
	// Bit mask of PWMPERIODEND field.
	PWM_INTENSET_PWMPERIODEND_Msk = 0x40
	// Bit PWMPERIODEND.
	PWM_INTENSET_PWMPERIODEND = 0x40
	// Read: Disabled
	PWM_INTENSET_PWMPERIODEND_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_PWMPERIODEND_Enabled = 0x1
	// Enable
	PWM_INTENSET_PWMPERIODEND_Set = 0x1
	// Position of LOOPSDONE field.
	PWM_INTENSET_LOOPSDONE_Pos = 0x7
	// Bit mask of LOOPSDONE field.
	PWM_INTENSET_LOOPSDONE_Msk = 0x80
	// Bit LOOPSDONE.
	PWM_INTENSET_LOOPSDONE = 0x80
	// Read: Disabled
	PWM_INTENSET_LOOPSDONE_Disabled = 0x0
	// Read: Enabled
	PWM_INTENSET_LOOPSDONE_Enabled = 0x1
	// Enable
	PWM_INTENSET_LOOPSDONE_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	PWM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PWM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PWM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	PWM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	PWM_INTENCLR_STOPPED_Clear = 0x1
	// Position of SEQSTARTED0 field.
	PWM_INTENCLR_SEQSTARTED0_Pos = 0x2
	// Bit mask of SEQSTARTED0 field.
	PWM_INTENCLR_SEQSTARTED0_Msk = 0x4
	// Bit SEQSTARTED0.
	PWM_INTENCLR_SEQSTARTED0 = 0x4
	// Read: Disabled
	PWM_INTENCLR_SEQSTARTED0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQSTARTED0_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQSTARTED0_Clear = 0x1
	// Position of SEQSTARTED1 field.
	PWM_INTENCLR_SEQSTARTED1_Pos = 0x3
	// Bit mask of SEQSTARTED1 field.
	PWM_INTENCLR_SEQSTARTED1_Msk = 0x8
	// Bit SEQSTARTED1.
	PWM_INTENCLR_SEQSTARTED1 = 0x8
	// Read: Disabled
	PWM_INTENCLR_SEQSTARTED1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQSTARTED1_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQSTARTED1_Clear = 0x1
	// Position of SEQEND0 field.
	PWM_INTENCLR_SEQEND0_Pos = 0x4
	// Bit mask of SEQEND0 field.
	PWM_INTENCLR_SEQEND0_Msk = 0x10
	// Bit SEQEND0.
	PWM_INTENCLR_SEQEND0 = 0x10
	// Read: Disabled
	PWM_INTENCLR_SEQEND0_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQEND0_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQEND0_Clear = 0x1
	// Position of SEQEND1 field.
	PWM_INTENCLR_SEQEND1_Pos = 0x5
	// Bit mask of SEQEND1 field.
	PWM_INTENCLR_SEQEND1_Msk = 0x20
	// Bit SEQEND1.
	PWM_INTENCLR_SEQEND1 = 0x20
	// Read: Disabled
	PWM_INTENCLR_SEQEND1_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_SEQEND1_Enabled = 0x1
	// Disable
	PWM_INTENCLR_SEQEND1_Clear = 0x1
	// Position of PWMPERIODEND field.
	PWM_INTENCLR_PWMPERIODEND_Pos = 0x6
	// Bit mask of PWMPERIODEND field.
	PWM_INTENCLR_PWMPERIODEND_Msk = 0x40
	// Bit PWMPERIODEND.
	PWM_INTENCLR_PWMPERIODEND = 0x40
	// Read: Disabled
	PWM_INTENCLR_PWMPERIODEND_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_PWMPERIODEND_Enabled = 0x1
	// Disable
	PWM_INTENCLR_PWMPERIODEND_Clear = 0x1
	// Position of LOOPSDONE field.
	PWM_INTENCLR_LOOPSDONE_Pos = 0x7
	// Bit mask of LOOPSDONE field.
	PWM_INTENCLR_LOOPSDONE_Msk = 0x80
	// Bit LOOPSDONE.
	PWM_INTENCLR_LOOPSDONE = 0x80
	// Read: Disabled
	PWM_INTENCLR_LOOPSDONE_Disabled = 0x0
	// Read: Enabled
	PWM_INTENCLR_LOOPSDONE_Enabled = 0x1
	// Disable
	PWM_INTENCLR_LOOPSDONE_Clear = 0x1

	// ENABLE: PWM module enable register
	// Position of ENABLE field.
	PWM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PWM_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PWM_ENABLE_ENABLE = 0x1
	// Disabled
	PWM_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	PWM_ENABLE_ENABLE_Enabled = 0x1

	// MODE: Selects operating mode of the wave counter
	// Position of UPDOWN field.
	PWM_MODE_UPDOWN_Pos = 0x0
	// Bit mask of UPDOWN field.
	PWM_MODE_UPDOWN_Msk = 0x1
	// Bit UPDOWN.
	PWM_MODE_UPDOWN = 0x1
	// Up counter, edge-aligned PWM duty cycle
	PWM_MODE_UPDOWN_Up = 0x0
	// Up and down counter, center-aligned PWM duty cycle
	PWM_MODE_UPDOWN_UpAndDown = 0x1

	// COUNTERTOP: Value up to which the pulse generator counter counts
	// Position of COUNTERTOP field.
	PWM_COUNTERTOP_COUNTERTOP_Pos = 0x0
	// Bit mask of COUNTERTOP field.
	PWM_COUNTERTOP_COUNTERTOP_Msk = 0x7fff

	// PRESCALER: Configuration for PWM_CLK
	// Position of PRESCALER field.
	PWM_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	PWM_PRESCALER_PRESCALER_Msk = 0x7
	// Divide by 1 (16 MHz)
	PWM_PRESCALER_PRESCALER_DIV_1 = 0x0
	// Divide by 2 (8 MHz)
	PWM_PRESCALER_PRESCALER_DIV_2 = 0x1
	// Divide by 4 (4 MHz)
	PWM_PRESCALER_PRESCALER_DIV_4 = 0x2
	// Divide by 8 (2 MHz)
	PWM_PRESCALER_PRESCALER_DIV_8 = 0x3
	// Divide by 16 (1 MHz)
	PWM_PRESCALER_PRESCALER_DIV_16 = 0x4
	// Divide by 32 (500 kHz)
	PWM_PRESCALER_PRESCALER_DIV_32 = 0x5
	// Divide by 64 (250 kHz)
	PWM_PRESCALER_PRESCALER_DIV_64 = 0x6
	// Divide by 128 (125 kHz)
	PWM_PRESCALER_PRESCALER_DIV_128 = 0x7

	// DECODER: Configuration of the decoder
	// Position of LOAD field.
	PWM_DECODER_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	PWM_DECODER_LOAD_Msk = 0x3
	// 1st half word (16-bit) used in all PWM channels 0..3
	PWM_DECODER_LOAD_Common = 0x0
	// 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
	PWM_DECODER_LOAD_Grouped = 0x1
	// 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
	PWM_DECODER_LOAD_Individual = 0x2
	// 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
	PWM_DECODER_LOAD_WaveForm = 0x3
	// Position of MODE field.
	PWM_DECODER_MODE_Pos = 0x8
	// Bit mask of MODE field.
	PWM_DECODER_MODE_Msk = 0x100
	// Bit MODE.
	PWM_DECODER_MODE = 0x100
	// SEQ[n].REFRESH is used to determine loading internal compare registers
	PWM_DECODER_MODE_RefreshCount = 0x0
	// NEXTSTEP task causes a new value to be loaded to internal compare registers
	PWM_DECODER_MODE_NextStep = 0x1

	// LOOP: Number of playbacks of a loop
	// Position of CNT field.
	PWM_LOOP_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_LOOP_CNT_Msk = 0xffff
	// Looping disabled (stop at the end of the sequence)
	PWM_LOOP_CNT_Disabled = 0x0

	// SEQ.PTR: Description cluster: Beginning address in RAM of this sequence
	// Position of PTR field.
	PWM_SEQ_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	PWM_SEQ_PTR_PTR_Msk = 0xffffffff

	// SEQ.CNT: Description cluster: Number of values (duty cycles) in this sequence
	// Position of CNT field.
	PWM_SEQ_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SEQ_CNT_CNT_Msk = 0x7fff
	// Sequence is disabled, and shall not be started as it is empty
	PWM_SEQ_CNT_CNT_Disabled = 0x0

	// SEQ.REFRESH: Description cluster: Number of additional PWM periods between samples loaded into compare register
	// Position of CNT field.
	PWM_SEQ_REFRESH_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SEQ_REFRESH_CNT_Msk = 0xffffff
	// Update every PWM period
	PWM_SEQ_REFRESH_CNT_Continuous = 0x0

	// SEQ.ENDDELAY: Description cluster: Time added after the sequence
	// Position of CNT field.
	PWM_SEQ_ENDDELAY_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SEQ_ENDDELAY_CNT_Msk = 0xffffff

	// PSEL.OUT: Description collection: Output pin select for PWM channel n
	// Position of PIN field.
	PWM_PSEL_OUT_PIN_Pos = 0x0
	// Bit mask of PIN field.
	PWM_PSEL_OUT_PIN_Msk = 0x1f
	// Position of PORT field.
	PWM_PSEL_OUT_PORT_Pos = 0x5
	// Bit mask of PORT field.
	PWM_PSEL_OUT_PORT_Msk = 0x20
	// Bit PORT.
	PWM_PSEL_OUT_PORT = 0x20
	// Position of CONNECT field.
	PWM_PSEL_OUT_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	PWM_PSEL_OUT_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	PWM_PSEL_OUT_CONNECT = 0x80000000
	// Disconnect
	PWM_PSEL_OUT_CONNECT_Disconnected = 0x1
	// Connect
	PWM_PSEL_OUT_CONNECT_Connected = 0x0
)

// Constants for PDM0_NS: Pulse Density Modulation (Digital Microphone) Interface 0
const (
	// TASKS_START: Starts continuous PDM transfer
	// Position of TASKS_START field.
	PDM_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	PDM_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	PDM_TASKS_START_TASKS_START = 0x1
	// Trigger task
	PDM_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stops PDM transfer
	// Position of TASKS_STOP field.
	PDM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	PDM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	PDM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	PDM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	PDM_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PDM_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	PDM_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	PDM_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	PDM_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	PDM_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	PDM_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	PDM_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PDM_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	PDM_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	PDM_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	PDM_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	PDM_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	PDM_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// EVENTS_STARTED: PDM transfer has started
	// Position of EVENTS_STARTED field.
	PDM_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	PDM_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	PDM_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	PDM_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	PDM_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// EVENTS_STOPPED: PDM transfer has finished
	// Position of EVENTS_STOPPED field.
	PDM_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	PDM_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	PDM_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	PDM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	PDM_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_END: The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
	// Position of EVENTS_END field.
	PDM_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	PDM_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	PDM_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	PDM_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	PDM_EVENTS_END_EVENTS_END_Generated = 0x1

	// PUBLISH_STARTED: Publish configuration for event STARTED
	// Position of CHIDX field.
	PDM_PUBLISH_STARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PDM_PUBLISH_STARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	PDM_PUBLISH_STARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	PDM_PUBLISH_STARTED_EN_Msk = 0x80000000
	// Bit EN.
	PDM_PUBLISH_STARTED_EN = 0x80000000
	// Disable publishing
	PDM_PUBLISH_STARTED_EN_Disabled = 0x0
	// Enable publishing
	PDM_PUBLISH_STARTED_EN_Enabled = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	PDM_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PDM_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	PDM_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	PDM_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	PDM_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	PDM_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	PDM_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_END: Publish configuration for event END
	// Position of CHIDX field.
	PDM_PUBLISH_END_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	PDM_PUBLISH_END_CHIDX_Msk = 0xff
	// Position of EN field.
	PDM_PUBLISH_END_EN_Pos = 0x1f
	// Bit mask of EN field.
	PDM_PUBLISH_END_EN_Msk = 0x80000000
	// Bit EN.
	PDM_PUBLISH_END_EN = 0x80000000
	// Disable publishing
	PDM_PUBLISH_END_EN_Disabled = 0x0
	// Enable publishing
	PDM_PUBLISH_END_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STARTED field.
	PDM_INTEN_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	PDM_INTEN_STARTED_Msk = 0x1
	// Bit STARTED.
	PDM_INTEN_STARTED = 0x1
	// Disable
	PDM_INTEN_STARTED_Disabled = 0x0
	// Enable
	PDM_INTEN_STARTED_Enabled = 0x1
	// Position of STOPPED field.
	PDM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PDM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PDM_INTEN_STOPPED = 0x2
	// Disable
	PDM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	PDM_INTEN_STOPPED_Enabled = 0x1
	// Position of END field.
	PDM_INTEN_END_Pos = 0x2
	// Bit mask of END field.
	PDM_INTEN_END_Msk = 0x4
	// Bit END.
	PDM_INTEN_END = 0x4
	// Disable
	PDM_INTEN_END_Disabled = 0x0
	// Enable
	PDM_INTEN_END_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STARTED field.
	PDM_INTENSET_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	PDM_INTENSET_STARTED_Msk = 0x1
	// Bit STARTED.
	PDM_INTENSET_STARTED = 0x1
	// Read: Disabled
	PDM_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENSET_STARTED_Enabled = 0x1
	// Enable
	PDM_INTENSET_STARTED_Set = 0x1
	// Position of STOPPED field.
	PDM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PDM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PDM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	PDM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	PDM_INTENSET_STOPPED_Set = 0x1
	// Position of END field.
	PDM_INTENSET_END_Pos = 0x2
	// Bit mask of END field.
	PDM_INTENSET_END_Msk = 0x4
	// Bit END.
	PDM_INTENSET_END = 0x4
	// Read: Disabled
	PDM_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	PDM_INTENSET_END_Enabled = 0x1
	// Enable
	PDM_INTENSET_END_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STARTED field.
	PDM_INTENCLR_STARTED_Pos = 0x0
	// Bit mask of STARTED field.
	PDM_INTENCLR_STARTED_Msk = 0x1
	// Bit STARTED.
	PDM_INTENCLR_STARTED = 0x1
	// Read: Disabled
	PDM_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	PDM_INTENCLR_STARTED_Clear = 0x1
	// Position of STOPPED field.
	PDM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	PDM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	PDM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	PDM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	PDM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	PDM_INTENCLR_STOPPED_Clear = 0x1
	// Position of END field.
	PDM_INTENCLR_END_Pos = 0x2
	// Bit mask of END field.
	PDM_INTENCLR_END_Msk = 0x4
	// Bit END.
	PDM_INTENCLR_END = 0x4
	// Read: Disabled
	PDM_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	PDM_INTENCLR_END_Enabled = 0x1
	// Disable
	PDM_INTENCLR_END_Clear = 0x1

	// ENABLE: PDM module enable register
	// Position of ENABLE field.
	PDM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PDM_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PDM_ENABLE_ENABLE = 0x1
	// Disable
	PDM_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	PDM_ENABLE_ENABLE_Enabled = 0x1

	// PDMCLKCTRL: PDM clock generator control
	// Position of FREQ field.
	PDM_PDMCLKCTRL_FREQ_Pos = 0x0
	// Bit mask of FREQ field.
	PDM_PDMCLKCTRL_FREQ_Msk = 0xffffffff
	// PDM_CLK = 32 MHz / 32 = 1.000 MHz
	PDM_PDMCLKCTRL_FREQ_1000K = 0x8000000
	// PDM_CLK = 32 MHz / 31 = 1.032 MHz. Nominal clock for RATIO=Ratio64.
	PDM_PDMCLKCTRL_FREQ_Default = 0x8400000
	// PDM_CLK = 32 MHz / 30 = 1.067 MHz
	PDM_PDMCLKCTRL_FREQ_1067K = 0x8800000
	// PDM_CLK = 32 MHz / 26 = 1.231 MHz
	PDM_PDMCLKCTRL_FREQ_1231K = 0x9800000
	// PDM_CLK = 32 MHz / 25 = 1.280 MHz. Nominal clock for RATIO=Ratio80.
	PDM_PDMCLKCTRL_FREQ_1280K = 0xa000000
	// PDM_CLK = 32 MHz / 24 = 1.333 MHz
	PDM_PDMCLKCTRL_FREQ_1333K = 0xa800000

	// MODE: Defines the routing of the connected PDM microphones' signals
	// Position of OPERATION field.
	PDM_MODE_OPERATION_Pos = 0x0
	// Bit mask of OPERATION field.
	PDM_MODE_OPERATION_Msk = 0x1
	// Bit OPERATION.
	PDM_MODE_OPERATION = 0x1
	// Sample and store one pair (left + right) of 16-bit samples per RAM word R=[31:16]; L=[15:0]
	PDM_MODE_OPERATION_Stereo = 0x0
	// Sample and store two successive left samples (16 bits each) per RAM word L1=[31:16]; L0=[15:0]
	PDM_MODE_OPERATION_Mono = 0x1
	// Position of EDGE field.
	PDM_MODE_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	PDM_MODE_EDGE_Msk = 0x2
	// Bit EDGE.
	PDM_MODE_EDGE = 0x2
	// Left (or mono) is sampled on falling edge of PDM_CLK
	PDM_MODE_EDGE_LeftFalling = 0x0
	// Left (or mono) is sampled on rising edge of PDM_CLK
	PDM_MODE_EDGE_LeftRising = 0x1

	// GAINL: Left output gain adjustment
	// Position of GAINL field.
	PDM_GAINL_GAINL_Pos = 0x0
	// Bit mask of GAINL field.
	PDM_GAINL_GAINL_Msk = 0x7f
	// -20 dB gain adjustment (minimum)
	PDM_GAINL_GAINL_MinGain = 0x0
	// 0 dB gain adjustment
	PDM_GAINL_GAINL_DefaultGain = 0x28
	// +20 dB gain adjustment (maximum)
	PDM_GAINL_GAINL_MaxGain = 0x50

	// GAINR: Right output gain adjustment
	// Position of GAINR field.
	PDM_GAINR_GAINR_Pos = 0x0
	// Bit mask of GAINR field.
	PDM_GAINR_GAINR_Msk = 0x7f
	// -20 dB gain adjustment (minimum)
	PDM_GAINR_GAINR_MinGain = 0x0
	// 0 dB gain adjustment
	PDM_GAINR_GAINR_DefaultGain = 0x28
	// +20 dB gain adjustment (maximum)
	PDM_GAINR_GAINR_MaxGain = 0x50

	// RATIO: Selects the ratio between PDM_CLK and output sample rate. Change PDMCLKCTRL accordingly.
	// Position of RATIO field.
	PDM_RATIO_RATIO_Pos = 0x0
	// Bit mask of RATIO field.
	PDM_RATIO_RATIO_Msk = 0x1
	// Bit RATIO.
	PDM_RATIO_RATIO = 0x1
	// Ratio of 64
	PDM_RATIO_RATIO_Ratio64 = 0x0
	// Ratio of 80
	PDM_RATIO_RATIO_Ratio80 = 0x1

	// PSEL.CLK: Pin number configuration for PDM CLK signal
	// Position of PIN field.
	PDM_PSEL_CLK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	PDM_PSEL_CLK_PIN_Msk = 0x1f
	// Position of PORT field.
	PDM_PSEL_CLK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	PDM_PSEL_CLK_PORT_Msk = 0x20
	// Bit PORT.
	PDM_PSEL_CLK_PORT = 0x20
	// Position of CONNECT field.
	PDM_PSEL_CLK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	PDM_PSEL_CLK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	PDM_PSEL_CLK_CONNECT = 0x80000000
	// Disconnect
	PDM_PSEL_CLK_CONNECT_Disconnected = 0x1
	// Connect
	PDM_PSEL_CLK_CONNECT_Connected = 0x0

	// PSEL.DIN: Pin number configuration for PDM DIN signal
	// Position of PIN field.
	PDM_PSEL_DIN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	PDM_PSEL_DIN_PIN_Msk = 0x1f
	// Position of PORT field.
	PDM_PSEL_DIN_PORT_Pos = 0x5
	// Bit mask of PORT field.
	PDM_PSEL_DIN_PORT_Msk = 0x20
	// Bit PORT.
	PDM_PSEL_DIN_PORT = 0x20
	// Position of CONNECT field.
	PDM_PSEL_DIN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	PDM_PSEL_DIN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	PDM_PSEL_DIN_CONNECT = 0x80000000
	// Disconnect
	PDM_PSEL_DIN_CONNECT_Disconnected = 0x1
	// Connect
	PDM_PSEL_DIN_CONNECT_Connected = 0x0

	// MCLKCONFIG: Master clock generator configuration
	// Position of SRC field.
	PDM_MCLKCONFIG_SRC_Pos = 0x0
	// Bit mask of SRC field.
	PDM_MCLKCONFIG_SRC_Msk = 0x1
	// Bit SRC.
	PDM_MCLKCONFIG_SRC = 0x1
	// 32 MHz peripheral clock
	PDM_MCLKCONFIG_SRC_PCLK32M = 0x0
	// Audio PLL clock
	PDM_MCLKCONFIG_SRC_ACLK = 0x1

	// SAMPLE.PTR: RAM address pointer to write samples to with EasyDMA
	// Position of SAMPLEPTR field.
	PDM_SAMPLE_PTR_SAMPLEPTR_Pos = 0x0
	// Bit mask of SAMPLEPTR field.
	PDM_SAMPLE_PTR_SAMPLEPTR_Msk = 0xffffffff

	// SAMPLE.MAXCNT: Number of samples to allocate memory for in EasyDMA mode
	// Position of BUFFSIZE field.
	PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos = 0x0
	// Bit mask of BUFFSIZE field.
	PDM_SAMPLE_MAXCNT_BUFFSIZE_Msk = 0x7fff
)

// Constants for I2S0_NS: Inter-IC Sound 0
const (
	// TASKS_START: Starts continuous I2S transfer. Also starts MCK generator when this is enabled
	// Position of TASKS_START field.
	I2S_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	I2S_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	I2S_TASKS_START_TASKS_START = 0x1
	// Trigger task
	I2S_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stops I2S transfer and MCK generator. Triggering this task will cause the event STOPPED to be generated.
	// Position of TASKS_STOP field.
	I2S_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	I2S_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	I2S_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	I2S_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	I2S_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	I2S_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	I2S_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	I2S_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	I2S_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	I2S_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	I2S_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	I2S_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	I2S_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	I2S_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	I2S_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	I2S_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	I2S_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	I2S_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// EVENTS_RXPTRUPD: The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words received on the SDIN pin.
	// Position of EVENTS_RXPTRUPD field.
	I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Pos = 0x0
	// Bit mask of EVENTS_RXPTRUPD field.
	I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Msk = 0x1
	// Bit EVENTS_RXPTRUPD.
	I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD = 0x1
	// Event not generated
	I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_NotGenerated = 0x0
	// Event generated
	I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Generated = 0x1

	// EVENTS_STOPPED: I2S transfer stopped.
	// Position of EVENTS_STOPPED field.
	I2S_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	I2S_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	I2S_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	I2S_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	I2S_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_TXPTRUPD: The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
	// Position of EVENTS_TXPTRUPD field.
	I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Pos = 0x0
	// Bit mask of EVENTS_TXPTRUPD field.
	I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Msk = 0x1
	// Bit EVENTS_TXPTRUPD.
	I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD = 0x1
	// Event not generated
	I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_NotGenerated = 0x0
	// Event generated
	I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Generated = 0x1

	// EVENTS_FRAMESTART: Frame start event, generated on the active edge of LRCK
	// Position of EVENTS_FRAMESTART field.
	I2S_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Pos = 0x0
	// Bit mask of EVENTS_FRAMESTART field.
	I2S_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Msk = 0x1
	// Bit EVENTS_FRAMESTART.
	I2S_EVENTS_FRAMESTART_EVENTS_FRAMESTART = 0x1
	// Event not generated
	I2S_EVENTS_FRAMESTART_EVENTS_FRAMESTART_NotGenerated = 0x0
	// Event generated
	I2S_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Generated = 0x1

	// PUBLISH_RXPTRUPD: Publish configuration for event RXPTRUPD
	// Position of CHIDX field.
	I2S_PUBLISH_RXPTRUPD_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	I2S_PUBLISH_RXPTRUPD_CHIDX_Msk = 0xff
	// Position of EN field.
	I2S_PUBLISH_RXPTRUPD_EN_Pos = 0x1f
	// Bit mask of EN field.
	I2S_PUBLISH_RXPTRUPD_EN_Msk = 0x80000000
	// Bit EN.
	I2S_PUBLISH_RXPTRUPD_EN = 0x80000000
	// Disable publishing
	I2S_PUBLISH_RXPTRUPD_EN_Disabled = 0x0
	// Enable publishing
	I2S_PUBLISH_RXPTRUPD_EN_Enabled = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	I2S_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	I2S_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	I2S_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	I2S_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	I2S_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	I2S_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	I2S_PUBLISH_STOPPED_EN_Enabled = 0x1

	// PUBLISH_TXPTRUPD: Publish configuration for event TXPTRUPD
	// Position of CHIDX field.
	I2S_PUBLISH_TXPTRUPD_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	I2S_PUBLISH_TXPTRUPD_CHIDX_Msk = 0xff
	// Position of EN field.
	I2S_PUBLISH_TXPTRUPD_EN_Pos = 0x1f
	// Bit mask of EN field.
	I2S_PUBLISH_TXPTRUPD_EN_Msk = 0x80000000
	// Bit EN.
	I2S_PUBLISH_TXPTRUPD_EN = 0x80000000
	// Disable publishing
	I2S_PUBLISH_TXPTRUPD_EN_Disabled = 0x0
	// Enable publishing
	I2S_PUBLISH_TXPTRUPD_EN_Enabled = 0x1

	// PUBLISH_FRAMESTART: Publish configuration for event FRAMESTART
	// Position of CHIDX field.
	I2S_PUBLISH_FRAMESTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	I2S_PUBLISH_FRAMESTART_CHIDX_Msk = 0xff
	// Position of EN field.
	I2S_PUBLISH_FRAMESTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	I2S_PUBLISH_FRAMESTART_EN_Msk = 0x80000000
	// Bit EN.
	I2S_PUBLISH_FRAMESTART_EN = 0x80000000
	// Disable publishing
	I2S_PUBLISH_FRAMESTART_EN_Disabled = 0x0
	// Enable publishing
	I2S_PUBLISH_FRAMESTART_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of RXPTRUPD field.
	I2S_INTEN_RXPTRUPD_Pos = 0x1
	// Bit mask of RXPTRUPD field.
	I2S_INTEN_RXPTRUPD_Msk = 0x2
	// Bit RXPTRUPD.
	I2S_INTEN_RXPTRUPD = 0x2
	// Disable
	I2S_INTEN_RXPTRUPD_Disabled = 0x0
	// Enable
	I2S_INTEN_RXPTRUPD_Enabled = 0x1
	// Position of STOPPED field.
	I2S_INTEN_STOPPED_Pos = 0x2
	// Bit mask of STOPPED field.
	I2S_INTEN_STOPPED_Msk = 0x4
	// Bit STOPPED.
	I2S_INTEN_STOPPED = 0x4
	// Disable
	I2S_INTEN_STOPPED_Disabled = 0x0
	// Enable
	I2S_INTEN_STOPPED_Enabled = 0x1
	// Position of TXPTRUPD field.
	I2S_INTEN_TXPTRUPD_Pos = 0x5
	// Bit mask of TXPTRUPD field.
	I2S_INTEN_TXPTRUPD_Msk = 0x20
	// Bit TXPTRUPD.
	I2S_INTEN_TXPTRUPD = 0x20
	// Disable
	I2S_INTEN_TXPTRUPD_Disabled = 0x0
	// Enable
	I2S_INTEN_TXPTRUPD_Enabled = 0x1
	// Position of FRAMESTART field.
	I2S_INTEN_FRAMESTART_Pos = 0x7
	// Bit mask of FRAMESTART field.
	I2S_INTEN_FRAMESTART_Msk = 0x80
	// Bit FRAMESTART.
	I2S_INTEN_FRAMESTART = 0x80
	// Disable
	I2S_INTEN_FRAMESTART_Disabled = 0x0
	// Enable
	I2S_INTEN_FRAMESTART_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of RXPTRUPD field.
	I2S_INTENSET_RXPTRUPD_Pos = 0x1
	// Bit mask of RXPTRUPD field.
	I2S_INTENSET_RXPTRUPD_Msk = 0x2
	// Bit RXPTRUPD.
	I2S_INTENSET_RXPTRUPD = 0x2
	// Read: Disabled
	I2S_INTENSET_RXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_RXPTRUPD_Enabled = 0x1
	// Enable
	I2S_INTENSET_RXPTRUPD_Set = 0x1
	// Position of STOPPED field.
	I2S_INTENSET_STOPPED_Pos = 0x2
	// Bit mask of STOPPED field.
	I2S_INTENSET_STOPPED_Msk = 0x4
	// Bit STOPPED.
	I2S_INTENSET_STOPPED = 0x4
	// Read: Disabled
	I2S_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	I2S_INTENSET_STOPPED_Set = 0x1
	// Position of TXPTRUPD field.
	I2S_INTENSET_TXPTRUPD_Pos = 0x5
	// Bit mask of TXPTRUPD field.
	I2S_INTENSET_TXPTRUPD_Msk = 0x20
	// Bit TXPTRUPD.
	I2S_INTENSET_TXPTRUPD = 0x20
	// Read: Disabled
	I2S_INTENSET_TXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_TXPTRUPD_Enabled = 0x1
	// Enable
	I2S_INTENSET_TXPTRUPD_Set = 0x1
	// Position of FRAMESTART field.
	I2S_INTENSET_FRAMESTART_Pos = 0x7
	// Bit mask of FRAMESTART field.
	I2S_INTENSET_FRAMESTART_Msk = 0x80
	// Bit FRAMESTART.
	I2S_INTENSET_FRAMESTART = 0x80
	// Read: Disabled
	I2S_INTENSET_FRAMESTART_Disabled = 0x0
	// Read: Enabled
	I2S_INTENSET_FRAMESTART_Enabled = 0x1
	// Enable
	I2S_INTENSET_FRAMESTART_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of RXPTRUPD field.
	I2S_INTENCLR_RXPTRUPD_Pos = 0x1
	// Bit mask of RXPTRUPD field.
	I2S_INTENCLR_RXPTRUPD_Msk = 0x2
	// Bit RXPTRUPD.
	I2S_INTENCLR_RXPTRUPD = 0x2
	// Read: Disabled
	I2S_INTENCLR_RXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_RXPTRUPD_Enabled = 0x1
	// Disable
	I2S_INTENCLR_RXPTRUPD_Clear = 0x1
	// Position of STOPPED field.
	I2S_INTENCLR_STOPPED_Pos = 0x2
	// Bit mask of STOPPED field.
	I2S_INTENCLR_STOPPED_Msk = 0x4
	// Bit STOPPED.
	I2S_INTENCLR_STOPPED = 0x4
	// Read: Disabled
	I2S_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	I2S_INTENCLR_STOPPED_Clear = 0x1
	// Position of TXPTRUPD field.
	I2S_INTENCLR_TXPTRUPD_Pos = 0x5
	// Bit mask of TXPTRUPD field.
	I2S_INTENCLR_TXPTRUPD_Msk = 0x20
	// Bit TXPTRUPD.
	I2S_INTENCLR_TXPTRUPD = 0x20
	// Read: Disabled
	I2S_INTENCLR_TXPTRUPD_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_TXPTRUPD_Enabled = 0x1
	// Disable
	I2S_INTENCLR_TXPTRUPD_Clear = 0x1
	// Position of FRAMESTART field.
	I2S_INTENCLR_FRAMESTART_Pos = 0x7
	// Bit mask of FRAMESTART field.
	I2S_INTENCLR_FRAMESTART_Msk = 0x80
	// Bit FRAMESTART.
	I2S_INTENCLR_FRAMESTART = 0x80
	// Read: Disabled
	I2S_INTENCLR_FRAMESTART_Disabled = 0x0
	// Read: Enabled
	I2S_INTENCLR_FRAMESTART_Enabled = 0x1
	// Disable
	I2S_INTENCLR_FRAMESTART_Clear = 0x1

	// ENABLE: Enable I2S module
	// Position of ENABLE field.
	I2S_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	I2S_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	I2S_ENABLE_ENABLE = 0x1
	// Disable
	I2S_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	I2S_ENABLE_ENABLE_Enabled = 0x1

	// CONFIG.MODE: I2S mode
	// Position of MODE field.
	I2S_CONFIG_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	I2S_CONFIG_MODE_MODE_Msk = 0x1
	// Bit MODE.
	I2S_CONFIG_MODE_MODE = 0x1
	// Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx.
	I2S_CONFIG_MODE_MODE_Master = 0x0
	// Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx
	I2S_CONFIG_MODE_MODE_Slave = 0x1

	// CONFIG.RXEN: Reception (RX) enable
	// Position of RXEN field.
	I2S_CONFIG_RXEN_RXEN_Pos = 0x0
	// Bit mask of RXEN field.
	I2S_CONFIG_RXEN_RXEN_Msk = 0x1
	// Bit RXEN.
	I2S_CONFIG_RXEN_RXEN = 0x1
	// Reception disabled and now data will be written to the RXD.PTR address.
	I2S_CONFIG_RXEN_RXEN_Disabled = 0x0
	// Reception enabled.
	I2S_CONFIG_RXEN_RXEN_Enabled = 0x1

	// CONFIG.TXEN: Transmission (TX) enable
	// Position of TXEN field.
	I2S_CONFIG_TXEN_TXEN_Pos = 0x0
	// Bit mask of TXEN field.
	I2S_CONFIG_TXEN_TXEN_Msk = 0x1
	// Bit TXEN.
	I2S_CONFIG_TXEN_TXEN = 0x1
	// Transmission disabled and now data will be read from the RXD.TXD address.
	I2S_CONFIG_TXEN_TXEN_Disabled = 0x0
	// Transmission enabled.
	I2S_CONFIG_TXEN_TXEN_Enabled = 0x1

	// CONFIG.MCKEN: Master clock generator enable
	// Position of MCKEN field.
	I2S_CONFIG_MCKEN_MCKEN_Pos = 0x0
	// Bit mask of MCKEN field.
	I2S_CONFIG_MCKEN_MCKEN_Msk = 0x1
	// Bit MCKEN.
	I2S_CONFIG_MCKEN_MCKEN = 0x1
	// Master clock generator disabled and PSEL.MCK not connected(available as GPIO).
	I2S_CONFIG_MCKEN_MCKEN_Disabled = 0x0
	// Master clock generator running and MCK output on PSEL.MCK.
	I2S_CONFIG_MCKEN_MCKEN_Enabled = 0x1

	// CONFIG.MCKFREQ: I2S clock generator control
	// Position of MCKFREQ field.
	I2S_CONFIG_MCKFREQ_MCKFREQ_Pos = 0x0
	// Bit mask of MCKFREQ field.
	I2S_CONFIG_MCKFREQ_MCKFREQ_Msk = 0xffffffff
	// 32 MHz / 2 = 16.0 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2 = 0x80000000
	// 32 MHz / 3 = 10.6666667 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3 = 0x50000000
	// 32 MHz / 4 = 8.0 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4 = 0x40000000
	// 32 MHz / 5 = 6.4 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5 = 0x30000000
	// 32 MHz / 6 = 5.3333333 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6 = 0x28000000
	// 32 MHz / 8 = 4.0 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8 = 0x20000000
	// 32 MHz / 10 = 3.2 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10 = 0x18000000
	// 32 MHz / 11 = 2.9090909 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11 = 0x16000000
	// 32 MHz / 15 = 2.1333333 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15 = 0x11000000
	// 32 MHz / 16 = 2.0 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16 = 0x10000000
	// 32 MHz / 21 = 1.5238095 Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21 = 0xc000000
	// 32 MHz / 23 = 1.3913043 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23 = 0xb000000
	// 32 MHz / 30 = 1.0666667 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30 = 0x8800000
	// 32 MHz / 31 = 1.0322581 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31 = 0x8400000
	// 32 MHz / 32 = 1.0 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32 = 0x8000000
	// 32 MHz / 42 = 0.7619048 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42 = 0x6000000
	// 32 MHz / 63 = 0.5079365 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63 = 0x4100000
	// 32 MHz / 125 = 0.256 MHz Deprecated, use MCKFREQ equation.
	I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125 = 0x20c0000

	// CONFIG.RATIO: MCK / LRCK ratio
	// Position of RATIO field.
	I2S_CONFIG_RATIO_RATIO_Pos = 0x0
	// Bit mask of RATIO field.
	I2S_CONFIG_RATIO_RATIO_Msk = 0xf
	// LRCK = MCK / 32
	I2S_CONFIG_RATIO_RATIO_32X = 0x0
	// LRCK = MCK / 48
	I2S_CONFIG_RATIO_RATIO_48X = 0x1
	// LRCK = MCK / 64
	I2S_CONFIG_RATIO_RATIO_64X = 0x2
	// LRCK = MCK / 96
	I2S_CONFIG_RATIO_RATIO_96X = 0x3
	// LRCK = MCK / 128
	I2S_CONFIG_RATIO_RATIO_128X = 0x4
	// LRCK = MCK / 192
	I2S_CONFIG_RATIO_RATIO_192X = 0x5
	// LRCK = MCK / 256
	I2S_CONFIG_RATIO_RATIO_256X = 0x6
	// LRCK = MCK / 384
	I2S_CONFIG_RATIO_RATIO_384X = 0x7
	// LRCK = MCK / 512
	I2S_CONFIG_RATIO_RATIO_512X = 0x8

	// CONFIG.SWIDTH: Sample width
	// Position of SWIDTH field.
	I2S_CONFIG_SWIDTH_SWIDTH_Pos = 0x0
	// Bit mask of SWIDTH field.
	I2S_CONFIG_SWIDTH_SWIDTH_Msk = 0x7
	// 8 bit sample.
	I2S_CONFIG_SWIDTH_SWIDTH_8Bit = 0x0
	// 16 bit sample.
	I2S_CONFIG_SWIDTH_SWIDTH_16Bit = 0x1
	// 24 bit sample.
	I2S_CONFIG_SWIDTH_SWIDTH_24Bit = 0x2
	// 32-bit sample.
	I2S_CONFIG_SWIDTH_SWIDTH_32Bit = 0x3
	// 8 bit sample in a 16 bit half-frame.
	I2S_CONFIG_SWIDTH_SWIDTH_8BitIn16 = 0x4
	// 8 bit sample in a 32-bit half-frame.
	I2S_CONFIG_SWIDTH_SWIDTH_8BitIn32 = 0x5
	// 16 bit sample in a 32-bit half-frame.
	I2S_CONFIG_SWIDTH_SWIDTH_16BitIn32 = 0x6
	// 24 bit sample in a 32-bit half-frame.
	I2S_CONFIG_SWIDTH_SWIDTH_24BitIn32 = 0x7

	// CONFIG.ALIGN: Alignment of sample within a frame
	// Position of ALIGN field.
	I2S_CONFIG_ALIGN_ALIGN_Pos = 0x0
	// Bit mask of ALIGN field.
	I2S_CONFIG_ALIGN_ALIGN_Msk = 0x1
	// Bit ALIGN.
	I2S_CONFIG_ALIGN_ALIGN = 0x1
	// Left-aligned.
	I2S_CONFIG_ALIGN_ALIGN_Left = 0x0
	// Right-aligned.
	I2S_CONFIG_ALIGN_ALIGN_Right = 0x1

	// CONFIG.FORMAT: Frame format
	// Position of FORMAT field.
	I2S_CONFIG_FORMAT_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	I2S_CONFIG_FORMAT_FORMAT_Msk = 0x1
	// Bit FORMAT.
	I2S_CONFIG_FORMAT_FORMAT = 0x1
	// Original I2S format.
	I2S_CONFIG_FORMAT_FORMAT_I2S = 0x0
	// Alternate (left- or right-aligned) format.
	I2S_CONFIG_FORMAT_FORMAT_Aligned = 0x1

	// CONFIG.CHANNELS: Enable channels
	// Position of CHANNELS field.
	I2S_CONFIG_CHANNELS_CHANNELS_Pos = 0x0
	// Bit mask of CHANNELS field.
	I2S_CONFIG_CHANNELS_CHANNELS_Msk = 0x3
	// Stereo.
	I2S_CONFIG_CHANNELS_CHANNELS_Stereo = 0x0
	// Left only.
	I2S_CONFIG_CHANNELS_CHANNELS_Left = 0x1
	// Right only.
	I2S_CONFIG_CHANNELS_CHANNELS_Right = 0x2

	// CONFIG.CLKCONFIG: Clock source selection for the I2S module
	// Position of CLKSRC field.
	I2S_CONFIG_CLKCONFIG_CLKSRC_Pos = 0x0
	// Bit mask of CLKSRC field.
	I2S_CONFIG_CLKCONFIG_CLKSRC_Msk = 0x1
	// Bit CLKSRC.
	I2S_CONFIG_CLKCONFIG_CLKSRC = 0x1
	// 32MHz peripheral clock
	I2S_CONFIG_CLKCONFIG_CLKSRC_PCLK32M = 0x0
	// Audio PLL clock
	I2S_CONFIG_CLKCONFIG_CLKSRC_ACLK = 0x1
	// Position of BYPASS field.
	I2S_CONFIG_CLKCONFIG_BYPASS_Pos = 0x8
	// Bit mask of BYPASS field.
	I2S_CONFIG_CLKCONFIG_BYPASS_Msk = 0x100
	// Bit BYPASS.
	I2S_CONFIG_CLKCONFIG_BYPASS = 0x100
	// Disable bypass
	I2S_CONFIG_CLKCONFIG_BYPASS_Disable = 0x0
	// Enable bypass
	I2S_CONFIG_CLKCONFIG_BYPASS_Enable = 0x1

	// RXD.PTR: Receive buffer RAM start address.
	// Position of PTR field.
	I2S_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	I2S_RXD_PTR_PTR_Msk = 0xffffffff

	// TXD.PTR: Transmit buffer RAM start address
	// Position of PTR field.
	I2S_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	I2S_TXD_PTR_PTR_Msk = 0xffffffff

	// RXTXD.MAXCNT: Size of RXD and TXD buffers
	// Position of MAXCNT field.
	I2S_RXTXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	I2S_RXTXD_MAXCNT_MAXCNT_Msk = 0x3fff

	// PSEL.MCK: Pin select for MCK signal
	// Position of PIN field.
	I2S_PSEL_MCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_MCK_PIN_Msk = 0x1f
	// Position of PORT field.
	I2S_PSEL_MCK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	I2S_PSEL_MCK_PORT_Msk = 0x20
	// Bit PORT.
	I2S_PSEL_MCK_PORT = 0x20
	// Position of CONNECT field.
	I2S_PSEL_MCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_MCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_MCK_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_MCK_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_MCK_CONNECT_Connected = 0x0

	// PSEL.SCK: Pin select for SCK signal
	// Position of PIN field.
	I2S_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_SCK_PIN_Msk = 0x1f
	// Position of PORT field.
	I2S_PSEL_SCK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	I2S_PSEL_SCK_PORT_Msk = 0x20
	// Bit PORT.
	I2S_PSEL_SCK_PORT = 0x20
	// Position of CONNECT field.
	I2S_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.LRCK: Pin select for LRCK signal
	// Position of PIN field.
	I2S_PSEL_LRCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_LRCK_PIN_Msk = 0x1f
	// Position of PORT field.
	I2S_PSEL_LRCK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	I2S_PSEL_LRCK_PORT_Msk = 0x20
	// Bit PORT.
	I2S_PSEL_LRCK_PORT = 0x20
	// Position of CONNECT field.
	I2S_PSEL_LRCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_LRCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_LRCK_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_LRCK_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_LRCK_CONNECT_Connected = 0x0

	// PSEL.SDIN: Pin select for SDIN signal
	// Position of PIN field.
	I2S_PSEL_SDIN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_SDIN_PIN_Msk = 0x1f
	// Position of PORT field.
	I2S_PSEL_SDIN_PORT_Pos = 0x5
	// Bit mask of PORT field.
	I2S_PSEL_SDIN_PORT_Msk = 0x20
	// Bit PORT.
	I2S_PSEL_SDIN_PORT = 0x20
	// Position of CONNECT field.
	I2S_PSEL_SDIN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_SDIN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_SDIN_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_SDIN_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_SDIN_CONNECT_Connected = 0x0

	// PSEL.SDOUT: Pin select for SDOUT signal
	// Position of PIN field.
	I2S_PSEL_SDOUT_PIN_Pos = 0x0
	// Bit mask of PIN field.
	I2S_PSEL_SDOUT_PIN_Msk = 0x1f
	// Position of PORT field.
	I2S_PSEL_SDOUT_PORT_Pos = 0x5
	// Bit mask of PORT field.
	I2S_PSEL_SDOUT_PORT_Msk = 0x20
	// Bit PORT.
	I2S_PSEL_SDOUT_PORT = 0x20
	// Position of CONNECT field.
	I2S_PSEL_SDOUT_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	I2S_PSEL_SDOUT_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	I2S_PSEL_SDOUT_CONNECT = 0x80000000
	// Disconnect
	I2S_PSEL_SDOUT_CONNECT_Disconnected = 0x1
	// Connect
	I2S_PSEL_SDOUT_CONNECT_Connected = 0x0
)

// Constants for IPC_NS: Interprocessor communication 0
const (
	// TASKS_SEND: Description collection: Trigger events on IPC channel enabled in SEND_CNF[n]
	// Position of TASKS_SEND field.
	IPC_TASKS_SEND_TASKS_SEND_Pos = 0x0
	// Bit mask of TASKS_SEND field.
	IPC_TASKS_SEND_TASKS_SEND_Msk = 0x1
	// Bit TASKS_SEND.
	IPC_TASKS_SEND_TASKS_SEND = 0x1
	// Trigger task
	IPC_TASKS_SEND_TASKS_SEND_Trigger = 0x1

	// SUBSCRIBE_SEND: Description collection: Subscribe configuration for task SEND[n]
	// Position of CHIDX field.
	IPC_SUBSCRIBE_SEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	IPC_SUBSCRIBE_SEND_CHIDX_Msk = 0xff
	// Position of EN field.
	IPC_SUBSCRIBE_SEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	IPC_SUBSCRIBE_SEND_EN_Msk = 0x80000000
	// Bit EN.
	IPC_SUBSCRIBE_SEND_EN = 0x80000000
	// Disable subscription
	IPC_SUBSCRIBE_SEND_EN_Disabled = 0x0
	// Enable subscription
	IPC_SUBSCRIBE_SEND_EN_Enabled = 0x1

	// EVENTS_RECEIVE: Description collection: Event received on one or more of the enabled IPC channels in RECEIVE_CNF[n]
	// Position of EVENTS_RECEIVE field.
	IPC_EVENTS_RECEIVE_EVENTS_RECEIVE_Pos = 0x0
	// Bit mask of EVENTS_RECEIVE field.
	IPC_EVENTS_RECEIVE_EVENTS_RECEIVE_Msk = 0x1
	// Bit EVENTS_RECEIVE.
	IPC_EVENTS_RECEIVE_EVENTS_RECEIVE = 0x1
	// Event not generated
	IPC_EVENTS_RECEIVE_EVENTS_RECEIVE_NotGenerated = 0x0
	// Event generated
	IPC_EVENTS_RECEIVE_EVENTS_RECEIVE_Generated = 0x1

	// PUBLISH_RECEIVE: Description collection: Publish configuration for event RECEIVE[n]
	// Position of CHIDX field.
	IPC_PUBLISH_RECEIVE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	IPC_PUBLISH_RECEIVE_CHIDX_Msk = 0xff
	// Position of EN field.
	IPC_PUBLISH_RECEIVE_EN_Pos = 0x1f
	// Bit mask of EN field.
	IPC_PUBLISH_RECEIVE_EN_Msk = 0x80000000
	// Bit EN.
	IPC_PUBLISH_RECEIVE_EN = 0x80000000
	// Disable publishing
	IPC_PUBLISH_RECEIVE_EN_Disabled = 0x0
	// Enable publishing
	IPC_PUBLISH_RECEIVE_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of RECEIVE0 field.
	IPC_INTEN_RECEIVE0_Pos = 0x0
	// Bit mask of RECEIVE0 field.
	IPC_INTEN_RECEIVE0_Msk = 0x1
	// Bit RECEIVE0.
	IPC_INTEN_RECEIVE0 = 0x1
	// Disable
	IPC_INTEN_RECEIVE0_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE0_Enabled = 0x1
	// Position of RECEIVE1 field.
	IPC_INTEN_RECEIVE1_Pos = 0x1
	// Bit mask of RECEIVE1 field.
	IPC_INTEN_RECEIVE1_Msk = 0x2
	// Bit RECEIVE1.
	IPC_INTEN_RECEIVE1 = 0x2
	// Disable
	IPC_INTEN_RECEIVE1_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE1_Enabled = 0x1
	// Position of RECEIVE2 field.
	IPC_INTEN_RECEIVE2_Pos = 0x2
	// Bit mask of RECEIVE2 field.
	IPC_INTEN_RECEIVE2_Msk = 0x4
	// Bit RECEIVE2.
	IPC_INTEN_RECEIVE2 = 0x4
	// Disable
	IPC_INTEN_RECEIVE2_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE2_Enabled = 0x1
	// Position of RECEIVE3 field.
	IPC_INTEN_RECEIVE3_Pos = 0x3
	// Bit mask of RECEIVE3 field.
	IPC_INTEN_RECEIVE3_Msk = 0x8
	// Bit RECEIVE3.
	IPC_INTEN_RECEIVE3 = 0x8
	// Disable
	IPC_INTEN_RECEIVE3_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE3_Enabled = 0x1
	// Position of RECEIVE4 field.
	IPC_INTEN_RECEIVE4_Pos = 0x4
	// Bit mask of RECEIVE4 field.
	IPC_INTEN_RECEIVE4_Msk = 0x10
	// Bit RECEIVE4.
	IPC_INTEN_RECEIVE4 = 0x10
	// Disable
	IPC_INTEN_RECEIVE4_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE4_Enabled = 0x1
	// Position of RECEIVE5 field.
	IPC_INTEN_RECEIVE5_Pos = 0x5
	// Bit mask of RECEIVE5 field.
	IPC_INTEN_RECEIVE5_Msk = 0x20
	// Bit RECEIVE5.
	IPC_INTEN_RECEIVE5 = 0x20
	// Disable
	IPC_INTEN_RECEIVE5_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE5_Enabled = 0x1
	// Position of RECEIVE6 field.
	IPC_INTEN_RECEIVE6_Pos = 0x6
	// Bit mask of RECEIVE6 field.
	IPC_INTEN_RECEIVE6_Msk = 0x40
	// Bit RECEIVE6.
	IPC_INTEN_RECEIVE6 = 0x40
	// Disable
	IPC_INTEN_RECEIVE6_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE6_Enabled = 0x1
	// Position of RECEIVE7 field.
	IPC_INTEN_RECEIVE7_Pos = 0x7
	// Bit mask of RECEIVE7 field.
	IPC_INTEN_RECEIVE7_Msk = 0x80
	// Bit RECEIVE7.
	IPC_INTEN_RECEIVE7 = 0x80
	// Disable
	IPC_INTEN_RECEIVE7_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE7_Enabled = 0x1
	// Position of RECEIVE8 field.
	IPC_INTEN_RECEIVE8_Pos = 0x8
	// Bit mask of RECEIVE8 field.
	IPC_INTEN_RECEIVE8_Msk = 0x100
	// Bit RECEIVE8.
	IPC_INTEN_RECEIVE8 = 0x100
	// Disable
	IPC_INTEN_RECEIVE8_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE8_Enabled = 0x1
	// Position of RECEIVE9 field.
	IPC_INTEN_RECEIVE9_Pos = 0x9
	// Bit mask of RECEIVE9 field.
	IPC_INTEN_RECEIVE9_Msk = 0x200
	// Bit RECEIVE9.
	IPC_INTEN_RECEIVE9 = 0x200
	// Disable
	IPC_INTEN_RECEIVE9_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE9_Enabled = 0x1
	// Position of RECEIVE10 field.
	IPC_INTEN_RECEIVE10_Pos = 0xa
	// Bit mask of RECEIVE10 field.
	IPC_INTEN_RECEIVE10_Msk = 0x400
	// Bit RECEIVE10.
	IPC_INTEN_RECEIVE10 = 0x400
	// Disable
	IPC_INTEN_RECEIVE10_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE10_Enabled = 0x1
	// Position of RECEIVE11 field.
	IPC_INTEN_RECEIVE11_Pos = 0xb
	// Bit mask of RECEIVE11 field.
	IPC_INTEN_RECEIVE11_Msk = 0x800
	// Bit RECEIVE11.
	IPC_INTEN_RECEIVE11 = 0x800
	// Disable
	IPC_INTEN_RECEIVE11_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE11_Enabled = 0x1
	// Position of RECEIVE12 field.
	IPC_INTEN_RECEIVE12_Pos = 0xc
	// Bit mask of RECEIVE12 field.
	IPC_INTEN_RECEIVE12_Msk = 0x1000
	// Bit RECEIVE12.
	IPC_INTEN_RECEIVE12 = 0x1000
	// Disable
	IPC_INTEN_RECEIVE12_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE12_Enabled = 0x1
	// Position of RECEIVE13 field.
	IPC_INTEN_RECEIVE13_Pos = 0xd
	// Bit mask of RECEIVE13 field.
	IPC_INTEN_RECEIVE13_Msk = 0x2000
	// Bit RECEIVE13.
	IPC_INTEN_RECEIVE13 = 0x2000
	// Disable
	IPC_INTEN_RECEIVE13_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE13_Enabled = 0x1
	// Position of RECEIVE14 field.
	IPC_INTEN_RECEIVE14_Pos = 0xe
	// Bit mask of RECEIVE14 field.
	IPC_INTEN_RECEIVE14_Msk = 0x4000
	// Bit RECEIVE14.
	IPC_INTEN_RECEIVE14 = 0x4000
	// Disable
	IPC_INTEN_RECEIVE14_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE14_Enabled = 0x1
	// Position of RECEIVE15 field.
	IPC_INTEN_RECEIVE15_Pos = 0xf
	// Bit mask of RECEIVE15 field.
	IPC_INTEN_RECEIVE15_Msk = 0x8000
	// Bit RECEIVE15.
	IPC_INTEN_RECEIVE15 = 0x8000
	// Disable
	IPC_INTEN_RECEIVE15_Disabled = 0x0
	// Enable
	IPC_INTEN_RECEIVE15_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of RECEIVE0 field.
	IPC_INTENSET_RECEIVE0_Pos = 0x0
	// Bit mask of RECEIVE0 field.
	IPC_INTENSET_RECEIVE0_Msk = 0x1
	// Bit RECEIVE0.
	IPC_INTENSET_RECEIVE0 = 0x1
	// Read: Disabled
	IPC_INTENSET_RECEIVE0_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE0_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE0_Set = 0x1
	// Position of RECEIVE1 field.
	IPC_INTENSET_RECEIVE1_Pos = 0x1
	// Bit mask of RECEIVE1 field.
	IPC_INTENSET_RECEIVE1_Msk = 0x2
	// Bit RECEIVE1.
	IPC_INTENSET_RECEIVE1 = 0x2
	// Read: Disabled
	IPC_INTENSET_RECEIVE1_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE1_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE1_Set = 0x1
	// Position of RECEIVE2 field.
	IPC_INTENSET_RECEIVE2_Pos = 0x2
	// Bit mask of RECEIVE2 field.
	IPC_INTENSET_RECEIVE2_Msk = 0x4
	// Bit RECEIVE2.
	IPC_INTENSET_RECEIVE2 = 0x4
	// Read: Disabled
	IPC_INTENSET_RECEIVE2_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE2_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE2_Set = 0x1
	// Position of RECEIVE3 field.
	IPC_INTENSET_RECEIVE3_Pos = 0x3
	// Bit mask of RECEIVE3 field.
	IPC_INTENSET_RECEIVE3_Msk = 0x8
	// Bit RECEIVE3.
	IPC_INTENSET_RECEIVE3 = 0x8
	// Read: Disabled
	IPC_INTENSET_RECEIVE3_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE3_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE3_Set = 0x1
	// Position of RECEIVE4 field.
	IPC_INTENSET_RECEIVE4_Pos = 0x4
	// Bit mask of RECEIVE4 field.
	IPC_INTENSET_RECEIVE4_Msk = 0x10
	// Bit RECEIVE4.
	IPC_INTENSET_RECEIVE4 = 0x10
	// Read: Disabled
	IPC_INTENSET_RECEIVE4_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE4_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE4_Set = 0x1
	// Position of RECEIVE5 field.
	IPC_INTENSET_RECEIVE5_Pos = 0x5
	// Bit mask of RECEIVE5 field.
	IPC_INTENSET_RECEIVE5_Msk = 0x20
	// Bit RECEIVE5.
	IPC_INTENSET_RECEIVE5 = 0x20
	// Read: Disabled
	IPC_INTENSET_RECEIVE5_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE5_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE5_Set = 0x1
	// Position of RECEIVE6 field.
	IPC_INTENSET_RECEIVE6_Pos = 0x6
	// Bit mask of RECEIVE6 field.
	IPC_INTENSET_RECEIVE6_Msk = 0x40
	// Bit RECEIVE6.
	IPC_INTENSET_RECEIVE6 = 0x40
	// Read: Disabled
	IPC_INTENSET_RECEIVE6_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE6_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE6_Set = 0x1
	// Position of RECEIVE7 field.
	IPC_INTENSET_RECEIVE7_Pos = 0x7
	// Bit mask of RECEIVE7 field.
	IPC_INTENSET_RECEIVE7_Msk = 0x80
	// Bit RECEIVE7.
	IPC_INTENSET_RECEIVE7 = 0x80
	// Read: Disabled
	IPC_INTENSET_RECEIVE7_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE7_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE7_Set = 0x1
	// Position of RECEIVE8 field.
	IPC_INTENSET_RECEIVE8_Pos = 0x8
	// Bit mask of RECEIVE8 field.
	IPC_INTENSET_RECEIVE8_Msk = 0x100
	// Bit RECEIVE8.
	IPC_INTENSET_RECEIVE8 = 0x100
	// Read: Disabled
	IPC_INTENSET_RECEIVE8_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE8_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE8_Set = 0x1
	// Position of RECEIVE9 field.
	IPC_INTENSET_RECEIVE9_Pos = 0x9
	// Bit mask of RECEIVE9 field.
	IPC_INTENSET_RECEIVE9_Msk = 0x200
	// Bit RECEIVE9.
	IPC_INTENSET_RECEIVE9 = 0x200
	// Read: Disabled
	IPC_INTENSET_RECEIVE9_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE9_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE9_Set = 0x1
	// Position of RECEIVE10 field.
	IPC_INTENSET_RECEIVE10_Pos = 0xa
	// Bit mask of RECEIVE10 field.
	IPC_INTENSET_RECEIVE10_Msk = 0x400
	// Bit RECEIVE10.
	IPC_INTENSET_RECEIVE10 = 0x400
	// Read: Disabled
	IPC_INTENSET_RECEIVE10_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE10_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE10_Set = 0x1
	// Position of RECEIVE11 field.
	IPC_INTENSET_RECEIVE11_Pos = 0xb
	// Bit mask of RECEIVE11 field.
	IPC_INTENSET_RECEIVE11_Msk = 0x800
	// Bit RECEIVE11.
	IPC_INTENSET_RECEIVE11 = 0x800
	// Read: Disabled
	IPC_INTENSET_RECEIVE11_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE11_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE11_Set = 0x1
	// Position of RECEIVE12 field.
	IPC_INTENSET_RECEIVE12_Pos = 0xc
	// Bit mask of RECEIVE12 field.
	IPC_INTENSET_RECEIVE12_Msk = 0x1000
	// Bit RECEIVE12.
	IPC_INTENSET_RECEIVE12 = 0x1000
	// Read: Disabled
	IPC_INTENSET_RECEIVE12_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE12_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE12_Set = 0x1
	// Position of RECEIVE13 field.
	IPC_INTENSET_RECEIVE13_Pos = 0xd
	// Bit mask of RECEIVE13 field.
	IPC_INTENSET_RECEIVE13_Msk = 0x2000
	// Bit RECEIVE13.
	IPC_INTENSET_RECEIVE13 = 0x2000
	// Read: Disabled
	IPC_INTENSET_RECEIVE13_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE13_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE13_Set = 0x1
	// Position of RECEIVE14 field.
	IPC_INTENSET_RECEIVE14_Pos = 0xe
	// Bit mask of RECEIVE14 field.
	IPC_INTENSET_RECEIVE14_Msk = 0x4000
	// Bit RECEIVE14.
	IPC_INTENSET_RECEIVE14 = 0x4000
	// Read: Disabled
	IPC_INTENSET_RECEIVE14_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE14_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE14_Set = 0x1
	// Position of RECEIVE15 field.
	IPC_INTENSET_RECEIVE15_Pos = 0xf
	// Bit mask of RECEIVE15 field.
	IPC_INTENSET_RECEIVE15_Msk = 0x8000
	// Bit RECEIVE15.
	IPC_INTENSET_RECEIVE15 = 0x8000
	// Read: Disabled
	IPC_INTENSET_RECEIVE15_Disabled = 0x0
	// Read: Enabled
	IPC_INTENSET_RECEIVE15_Enabled = 0x1
	// Enable
	IPC_INTENSET_RECEIVE15_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of RECEIVE0 field.
	IPC_INTENCLR_RECEIVE0_Pos = 0x0
	// Bit mask of RECEIVE0 field.
	IPC_INTENCLR_RECEIVE0_Msk = 0x1
	// Bit RECEIVE0.
	IPC_INTENCLR_RECEIVE0 = 0x1
	// Read: Disabled
	IPC_INTENCLR_RECEIVE0_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE0_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE0_Clear = 0x1
	// Position of RECEIVE1 field.
	IPC_INTENCLR_RECEIVE1_Pos = 0x1
	// Bit mask of RECEIVE1 field.
	IPC_INTENCLR_RECEIVE1_Msk = 0x2
	// Bit RECEIVE1.
	IPC_INTENCLR_RECEIVE1 = 0x2
	// Read: Disabled
	IPC_INTENCLR_RECEIVE1_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE1_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE1_Clear = 0x1
	// Position of RECEIVE2 field.
	IPC_INTENCLR_RECEIVE2_Pos = 0x2
	// Bit mask of RECEIVE2 field.
	IPC_INTENCLR_RECEIVE2_Msk = 0x4
	// Bit RECEIVE2.
	IPC_INTENCLR_RECEIVE2 = 0x4
	// Read: Disabled
	IPC_INTENCLR_RECEIVE2_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE2_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE2_Clear = 0x1
	// Position of RECEIVE3 field.
	IPC_INTENCLR_RECEIVE3_Pos = 0x3
	// Bit mask of RECEIVE3 field.
	IPC_INTENCLR_RECEIVE3_Msk = 0x8
	// Bit RECEIVE3.
	IPC_INTENCLR_RECEIVE3 = 0x8
	// Read: Disabled
	IPC_INTENCLR_RECEIVE3_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE3_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE3_Clear = 0x1
	// Position of RECEIVE4 field.
	IPC_INTENCLR_RECEIVE4_Pos = 0x4
	// Bit mask of RECEIVE4 field.
	IPC_INTENCLR_RECEIVE4_Msk = 0x10
	// Bit RECEIVE4.
	IPC_INTENCLR_RECEIVE4 = 0x10
	// Read: Disabled
	IPC_INTENCLR_RECEIVE4_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE4_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE4_Clear = 0x1
	// Position of RECEIVE5 field.
	IPC_INTENCLR_RECEIVE5_Pos = 0x5
	// Bit mask of RECEIVE5 field.
	IPC_INTENCLR_RECEIVE5_Msk = 0x20
	// Bit RECEIVE5.
	IPC_INTENCLR_RECEIVE5 = 0x20
	// Read: Disabled
	IPC_INTENCLR_RECEIVE5_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE5_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE5_Clear = 0x1
	// Position of RECEIVE6 field.
	IPC_INTENCLR_RECEIVE6_Pos = 0x6
	// Bit mask of RECEIVE6 field.
	IPC_INTENCLR_RECEIVE6_Msk = 0x40
	// Bit RECEIVE6.
	IPC_INTENCLR_RECEIVE6 = 0x40
	// Read: Disabled
	IPC_INTENCLR_RECEIVE6_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE6_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE6_Clear = 0x1
	// Position of RECEIVE7 field.
	IPC_INTENCLR_RECEIVE7_Pos = 0x7
	// Bit mask of RECEIVE7 field.
	IPC_INTENCLR_RECEIVE7_Msk = 0x80
	// Bit RECEIVE7.
	IPC_INTENCLR_RECEIVE7 = 0x80
	// Read: Disabled
	IPC_INTENCLR_RECEIVE7_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE7_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE7_Clear = 0x1
	// Position of RECEIVE8 field.
	IPC_INTENCLR_RECEIVE8_Pos = 0x8
	// Bit mask of RECEIVE8 field.
	IPC_INTENCLR_RECEIVE8_Msk = 0x100
	// Bit RECEIVE8.
	IPC_INTENCLR_RECEIVE8 = 0x100
	// Read: Disabled
	IPC_INTENCLR_RECEIVE8_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE8_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE8_Clear = 0x1
	// Position of RECEIVE9 field.
	IPC_INTENCLR_RECEIVE9_Pos = 0x9
	// Bit mask of RECEIVE9 field.
	IPC_INTENCLR_RECEIVE9_Msk = 0x200
	// Bit RECEIVE9.
	IPC_INTENCLR_RECEIVE9 = 0x200
	// Read: Disabled
	IPC_INTENCLR_RECEIVE9_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE9_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE9_Clear = 0x1
	// Position of RECEIVE10 field.
	IPC_INTENCLR_RECEIVE10_Pos = 0xa
	// Bit mask of RECEIVE10 field.
	IPC_INTENCLR_RECEIVE10_Msk = 0x400
	// Bit RECEIVE10.
	IPC_INTENCLR_RECEIVE10 = 0x400
	// Read: Disabled
	IPC_INTENCLR_RECEIVE10_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE10_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE10_Clear = 0x1
	// Position of RECEIVE11 field.
	IPC_INTENCLR_RECEIVE11_Pos = 0xb
	// Bit mask of RECEIVE11 field.
	IPC_INTENCLR_RECEIVE11_Msk = 0x800
	// Bit RECEIVE11.
	IPC_INTENCLR_RECEIVE11 = 0x800
	// Read: Disabled
	IPC_INTENCLR_RECEIVE11_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE11_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE11_Clear = 0x1
	// Position of RECEIVE12 field.
	IPC_INTENCLR_RECEIVE12_Pos = 0xc
	// Bit mask of RECEIVE12 field.
	IPC_INTENCLR_RECEIVE12_Msk = 0x1000
	// Bit RECEIVE12.
	IPC_INTENCLR_RECEIVE12 = 0x1000
	// Read: Disabled
	IPC_INTENCLR_RECEIVE12_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE12_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE12_Clear = 0x1
	// Position of RECEIVE13 field.
	IPC_INTENCLR_RECEIVE13_Pos = 0xd
	// Bit mask of RECEIVE13 field.
	IPC_INTENCLR_RECEIVE13_Msk = 0x2000
	// Bit RECEIVE13.
	IPC_INTENCLR_RECEIVE13 = 0x2000
	// Read: Disabled
	IPC_INTENCLR_RECEIVE13_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE13_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE13_Clear = 0x1
	// Position of RECEIVE14 field.
	IPC_INTENCLR_RECEIVE14_Pos = 0xe
	// Bit mask of RECEIVE14 field.
	IPC_INTENCLR_RECEIVE14_Msk = 0x4000
	// Bit RECEIVE14.
	IPC_INTENCLR_RECEIVE14 = 0x4000
	// Read: Disabled
	IPC_INTENCLR_RECEIVE14_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE14_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE14_Clear = 0x1
	// Position of RECEIVE15 field.
	IPC_INTENCLR_RECEIVE15_Pos = 0xf
	// Bit mask of RECEIVE15 field.
	IPC_INTENCLR_RECEIVE15_Msk = 0x8000
	// Bit RECEIVE15.
	IPC_INTENCLR_RECEIVE15 = 0x8000
	// Read: Disabled
	IPC_INTENCLR_RECEIVE15_Disabled = 0x0
	// Read: Enabled
	IPC_INTENCLR_RECEIVE15_Enabled = 0x1
	// Disable
	IPC_INTENCLR_RECEIVE15_Clear = 0x1

	// INTPEND: Pending interrupts
	// Position of RECEIVE0 field.
	IPC_INTPEND_RECEIVE0_Pos = 0x0
	// Bit mask of RECEIVE0 field.
	IPC_INTPEND_RECEIVE0_Msk = 0x1
	// Bit RECEIVE0.
	IPC_INTPEND_RECEIVE0 = 0x1
	// Read: Not pending
	IPC_INTPEND_RECEIVE0_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE0_Pending = 0x1
	// Position of RECEIVE1 field.
	IPC_INTPEND_RECEIVE1_Pos = 0x1
	// Bit mask of RECEIVE1 field.
	IPC_INTPEND_RECEIVE1_Msk = 0x2
	// Bit RECEIVE1.
	IPC_INTPEND_RECEIVE1 = 0x2
	// Read: Not pending
	IPC_INTPEND_RECEIVE1_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE1_Pending = 0x1
	// Position of RECEIVE2 field.
	IPC_INTPEND_RECEIVE2_Pos = 0x2
	// Bit mask of RECEIVE2 field.
	IPC_INTPEND_RECEIVE2_Msk = 0x4
	// Bit RECEIVE2.
	IPC_INTPEND_RECEIVE2 = 0x4
	// Read: Not pending
	IPC_INTPEND_RECEIVE2_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE2_Pending = 0x1
	// Position of RECEIVE3 field.
	IPC_INTPEND_RECEIVE3_Pos = 0x3
	// Bit mask of RECEIVE3 field.
	IPC_INTPEND_RECEIVE3_Msk = 0x8
	// Bit RECEIVE3.
	IPC_INTPEND_RECEIVE3 = 0x8
	// Read: Not pending
	IPC_INTPEND_RECEIVE3_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE3_Pending = 0x1
	// Position of RECEIVE4 field.
	IPC_INTPEND_RECEIVE4_Pos = 0x4
	// Bit mask of RECEIVE4 field.
	IPC_INTPEND_RECEIVE4_Msk = 0x10
	// Bit RECEIVE4.
	IPC_INTPEND_RECEIVE4 = 0x10
	// Read: Not pending
	IPC_INTPEND_RECEIVE4_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE4_Pending = 0x1
	// Position of RECEIVE5 field.
	IPC_INTPEND_RECEIVE5_Pos = 0x5
	// Bit mask of RECEIVE5 field.
	IPC_INTPEND_RECEIVE5_Msk = 0x20
	// Bit RECEIVE5.
	IPC_INTPEND_RECEIVE5 = 0x20
	// Read: Not pending
	IPC_INTPEND_RECEIVE5_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE5_Pending = 0x1
	// Position of RECEIVE6 field.
	IPC_INTPEND_RECEIVE6_Pos = 0x6
	// Bit mask of RECEIVE6 field.
	IPC_INTPEND_RECEIVE6_Msk = 0x40
	// Bit RECEIVE6.
	IPC_INTPEND_RECEIVE6 = 0x40
	// Read: Not pending
	IPC_INTPEND_RECEIVE6_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE6_Pending = 0x1
	// Position of RECEIVE7 field.
	IPC_INTPEND_RECEIVE7_Pos = 0x7
	// Bit mask of RECEIVE7 field.
	IPC_INTPEND_RECEIVE7_Msk = 0x80
	// Bit RECEIVE7.
	IPC_INTPEND_RECEIVE7 = 0x80
	// Read: Not pending
	IPC_INTPEND_RECEIVE7_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE7_Pending = 0x1
	// Position of RECEIVE8 field.
	IPC_INTPEND_RECEIVE8_Pos = 0x8
	// Bit mask of RECEIVE8 field.
	IPC_INTPEND_RECEIVE8_Msk = 0x100
	// Bit RECEIVE8.
	IPC_INTPEND_RECEIVE8 = 0x100
	// Read: Not pending
	IPC_INTPEND_RECEIVE8_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE8_Pending = 0x1
	// Position of RECEIVE9 field.
	IPC_INTPEND_RECEIVE9_Pos = 0x9
	// Bit mask of RECEIVE9 field.
	IPC_INTPEND_RECEIVE9_Msk = 0x200
	// Bit RECEIVE9.
	IPC_INTPEND_RECEIVE9 = 0x200
	// Read: Not pending
	IPC_INTPEND_RECEIVE9_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE9_Pending = 0x1
	// Position of RECEIVE10 field.
	IPC_INTPEND_RECEIVE10_Pos = 0xa
	// Bit mask of RECEIVE10 field.
	IPC_INTPEND_RECEIVE10_Msk = 0x400
	// Bit RECEIVE10.
	IPC_INTPEND_RECEIVE10 = 0x400
	// Read: Not pending
	IPC_INTPEND_RECEIVE10_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE10_Pending = 0x1
	// Position of RECEIVE11 field.
	IPC_INTPEND_RECEIVE11_Pos = 0xb
	// Bit mask of RECEIVE11 field.
	IPC_INTPEND_RECEIVE11_Msk = 0x800
	// Bit RECEIVE11.
	IPC_INTPEND_RECEIVE11 = 0x800
	// Read: Not pending
	IPC_INTPEND_RECEIVE11_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE11_Pending = 0x1
	// Position of RECEIVE12 field.
	IPC_INTPEND_RECEIVE12_Pos = 0xc
	// Bit mask of RECEIVE12 field.
	IPC_INTPEND_RECEIVE12_Msk = 0x1000
	// Bit RECEIVE12.
	IPC_INTPEND_RECEIVE12 = 0x1000
	// Read: Not pending
	IPC_INTPEND_RECEIVE12_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE12_Pending = 0x1
	// Position of RECEIVE13 field.
	IPC_INTPEND_RECEIVE13_Pos = 0xd
	// Bit mask of RECEIVE13 field.
	IPC_INTPEND_RECEIVE13_Msk = 0x2000
	// Bit RECEIVE13.
	IPC_INTPEND_RECEIVE13 = 0x2000
	// Read: Not pending
	IPC_INTPEND_RECEIVE13_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE13_Pending = 0x1
	// Position of RECEIVE14 field.
	IPC_INTPEND_RECEIVE14_Pos = 0xe
	// Bit mask of RECEIVE14 field.
	IPC_INTPEND_RECEIVE14_Msk = 0x4000
	// Bit RECEIVE14.
	IPC_INTPEND_RECEIVE14 = 0x4000
	// Read: Not pending
	IPC_INTPEND_RECEIVE14_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE14_Pending = 0x1
	// Position of RECEIVE15 field.
	IPC_INTPEND_RECEIVE15_Pos = 0xf
	// Bit mask of RECEIVE15 field.
	IPC_INTPEND_RECEIVE15_Msk = 0x8000
	// Bit RECEIVE15.
	IPC_INTPEND_RECEIVE15 = 0x8000
	// Read: Not pending
	IPC_INTPEND_RECEIVE15_NotPending = 0x0
	// Read: Pending
	IPC_INTPEND_RECEIVE15_Pending = 0x1

	// SEND_CNF: Description collection: Send event configuration for TASKS_SEND[n]
	// Position of CHEN0 field.
	IPC_SEND_CNF_CHEN0_Pos = 0x0
	// Bit mask of CHEN0 field.
	IPC_SEND_CNF_CHEN0_Msk = 0x1
	// Bit CHEN0.
	IPC_SEND_CNF_CHEN0 = 0x1
	// Disable broadcast
	IPC_SEND_CNF_CHEN0_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN0_Enable = 0x1
	// Position of CHEN1 field.
	IPC_SEND_CNF_CHEN1_Pos = 0x1
	// Bit mask of CHEN1 field.
	IPC_SEND_CNF_CHEN1_Msk = 0x2
	// Bit CHEN1.
	IPC_SEND_CNF_CHEN1 = 0x2
	// Disable broadcast
	IPC_SEND_CNF_CHEN1_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN1_Enable = 0x1
	// Position of CHEN2 field.
	IPC_SEND_CNF_CHEN2_Pos = 0x2
	// Bit mask of CHEN2 field.
	IPC_SEND_CNF_CHEN2_Msk = 0x4
	// Bit CHEN2.
	IPC_SEND_CNF_CHEN2 = 0x4
	// Disable broadcast
	IPC_SEND_CNF_CHEN2_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN2_Enable = 0x1
	// Position of CHEN3 field.
	IPC_SEND_CNF_CHEN3_Pos = 0x3
	// Bit mask of CHEN3 field.
	IPC_SEND_CNF_CHEN3_Msk = 0x8
	// Bit CHEN3.
	IPC_SEND_CNF_CHEN3 = 0x8
	// Disable broadcast
	IPC_SEND_CNF_CHEN3_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN3_Enable = 0x1
	// Position of CHEN4 field.
	IPC_SEND_CNF_CHEN4_Pos = 0x4
	// Bit mask of CHEN4 field.
	IPC_SEND_CNF_CHEN4_Msk = 0x10
	// Bit CHEN4.
	IPC_SEND_CNF_CHEN4 = 0x10
	// Disable broadcast
	IPC_SEND_CNF_CHEN4_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN4_Enable = 0x1
	// Position of CHEN5 field.
	IPC_SEND_CNF_CHEN5_Pos = 0x5
	// Bit mask of CHEN5 field.
	IPC_SEND_CNF_CHEN5_Msk = 0x20
	// Bit CHEN5.
	IPC_SEND_CNF_CHEN5 = 0x20
	// Disable broadcast
	IPC_SEND_CNF_CHEN5_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN5_Enable = 0x1
	// Position of CHEN6 field.
	IPC_SEND_CNF_CHEN6_Pos = 0x6
	// Bit mask of CHEN6 field.
	IPC_SEND_CNF_CHEN6_Msk = 0x40
	// Bit CHEN6.
	IPC_SEND_CNF_CHEN6 = 0x40
	// Disable broadcast
	IPC_SEND_CNF_CHEN6_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN6_Enable = 0x1
	// Position of CHEN7 field.
	IPC_SEND_CNF_CHEN7_Pos = 0x7
	// Bit mask of CHEN7 field.
	IPC_SEND_CNF_CHEN7_Msk = 0x80
	// Bit CHEN7.
	IPC_SEND_CNF_CHEN7 = 0x80
	// Disable broadcast
	IPC_SEND_CNF_CHEN7_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN7_Enable = 0x1
	// Position of CHEN8 field.
	IPC_SEND_CNF_CHEN8_Pos = 0x8
	// Bit mask of CHEN8 field.
	IPC_SEND_CNF_CHEN8_Msk = 0x100
	// Bit CHEN8.
	IPC_SEND_CNF_CHEN8 = 0x100
	// Disable broadcast
	IPC_SEND_CNF_CHEN8_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN8_Enable = 0x1
	// Position of CHEN9 field.
	IPC_SEND_CNF_CHEN9_Pos = 0x9
	// Bit mask of CHEN9 field.
	IPC_SEND_CNF_CHEN9_Msk = 0x200
	// Bit CHEN9.
	IPC_SEND_CNF_CHEN9 = 0x200
	// Disable broadcast
	IPC_SEND_CNF_CHEN9_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN9_Enable = 0x1
	// Position of CHEN10 field.
	IPC_SEND_CNF_CHEN10_Pos = 0xa
	// Bit mask of CHEN10 field.
	IPC_SEND_CNF_CHEN10_Msk = 0x400
	// Bit CHEN10.
	IPC_SEND_CNF_CHEN10 = 0x400
	// Disable broadcast
	IPC_SEND_CNF_CHEN10_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN10_Enable = 0x1
	// Position of CHEN11 field.
	IPC_SEND_CNF_CHEN11_Pos = 0xb
	// Bit mask of CHEN11 field.
	IPC_SEND_CNF_CHEN11_Msk = 0x800
	// Bit CHEN11.
	IPC_SEND_CNF_CHEN11 = 0x800
	// Disable broadcast
	IPC_SEND_CNF_CHEN11_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN11_Enable = 0x1
	// Position of CHEN12 field.
	IPC_SEND_CNF_CHEN12_Pos = 0xc
	// Bit mask of CHEN12 field.
	IPC_SEND_CNF_CHEN12_Msk = 0x1000
	// Bit CHEN12.
	IPC_SEND_CNF_CHEN12 = 0x1000
	// Disable broadcast
	IPC_SEND_CNF_CHEN12_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN12_Enable = 0x1
	// Position of CHEN13 field.
	IPC_SEND_CNF_CHEN13_Pos = 0xd
	// Bit mask of CHEN13 field.
	IPC_SEND_CNF_CHEN13_Msk = 0x2000
	// Bit CHEN13.
	IPC_SEND_CNF_CHEN13 = 0x2000
	// Disable broadcast
	IPC_SEND_CNF_CHEN13_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN13_Enable = 0x1
	// Position of CHEN14 field.
	IPC_SEND_CNF_CHEN14_Pos = 0xe
	// Bit mask of CHEN14 field.
	IPC_SEND_CNF_CHEN14_Msk = 0x4000
	// Bit CHEN14.
	IPC_SEND_CNF_CHEN14 = 0x4000
	// Disable broadcast
	IPC_SEND_CNF_CHEN14_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN14_Enable = 0x1
	// Position of CHEN15 field.
	IPC_SEND_CNF_CHEN15_Pos = 0xf
	// Bit mask of CHEN15 field.
	IPC_SEND_CNF_CHEN15_Msk = 0x8000
	// Bit CHEN15.
	IPC_SEND_CNF_CHEN15 = 0x8000
	// Disable broadcast
	IPC_SEND_CNF_CHEN15_Disable = 0x0
	// Enable broadcast
	IPC_SEND_CNF_CHEN15_Enable = 0x1

	// RECEIVE_CNF: Description collection: Receive event configuration for EVENTS_RECEIVE[n]
	// Position of CHEN0 field.
	IPC_RECEIVE_CNF_CHEN0_Pos = 0x0
	// Bit mask of CHEN0 field.
	IPC_RECEIVE_CNF_CHEN0_Msk = 0x1
	// Bit CHEN0.
	IPC_RECEIVE_CNF_CHEN0 = 0x1
	// Disable events
	IPC_RECEIVE_CNF_CHEN0_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN0_Enable = 0x1
	// Position of CHEN1 field.
	IPC_RECEIVE_CNF_CHEN1_Pos = 0x1
	// Bit mask of CHEN1 field.
	IPC_RECEIVE_CNF_CHEN1_Msk = 0x2
	// Bit CHEN1.
	IPC_RECEIVE_CNF_CHEN1 = 0x2
	// Disable events
	IPC_RECEIVE_CNF_CHEN1_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN1_Enable = 0x1
	// Position of CHEN2 field.
	IPC_RECEIVE_CNF_CHEN2_Pos = 0x2
	// Bit mask of CHEN2 field.
	IPC_RECEIVE_CNF_CHEN2_Msk = 0x4
	// Bit CHEN2.
	IPC_RECEIVE_CNF_CHEN2 = 0x4
	// Disable events
	IPC_RECEIVE_CNF_CHEN2_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN2_Enable = 0x1
	// Position of CHEN3 field.
	IPC_RECEIVE_CNF_CHEN3_Pos = 0x3
	// Bit mask of CHEN3 field.
	IPC_RECEIVE_CNF_CHEN3_Msk = 0x8
	// Bit CHEN3.
	IPC_RECEIVE_CNF_CHEN3 = 0x8
	// Disable events
	IPC_RECEIVE_CNF_CHEN3_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN3_Enable = 0x1
	// Position of CHEN4 field.
	IPC_RECEIVE_CNF_CHEN4_Pos = 0x4
	// Bit mask of CHEN4 field.
	IPC_RECEIVE_CNF_CHEN4_Msk = 0x10
	// Bit CHEN4.
	IPC_RECEIVE_CNF_CHEN4 = 0x10
	// Disable events
	IPC_RECEIVE_CNF_CHEN4_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN4_Enable = 0x1
	// Position of CHEN5 field.
	IPC_RECEIVE_CNF_CHEN5_Pos = 0x5
	// Bit mask of CHEN5 field.
	IPC_RECEIVE_CNF_CHEN5_Msk = 0x20
	// Bit CHEN5.
	IPC_RECEIVE_CNF_CHEN5 = 0x20
	// Disable events
	IPC_RECEIVE_CNF_CHEN5_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN5_Enable = 0x1
	// Position of CHEN6 field.
	IPC_RECEIVE_CNF_CHEN6_Pos = 0x6
	// Bit mask of CHEN6 field.
	IPC_RECEIVE_CNF_CHEN6_Msk = 0x40
	// Bit CHEN6.
	IPC_RECEIVE_CNF_CHEN6 = 0x40
	// Disable events
	IPC_RECEIVE_CNF_CHEN6_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN6_Enable = 0x1
	// Position of CHEN7 field.
	IPC_RECEIVE_CNF_CHEN7_Pos = 0x7
	// Bit mask of CHEN7 field.
	IPC_RECEIVE_CNF_CHEN7_Msk = 0x80
	// Bit CHEN7.
	IPC_RECEIVE_CNF_CHEN7 = 0x80
	// Disable events
	IPC_RECEIVE_CNF_CHEN7_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN7_Enable = 0x1
	// Position of CHEN8 field.
	IPC_RECEIVE_CNF_CHEN8_Pos = 0x8
	// Bit mask of CHEN8 field.
	IPC_RECEIVE_CNF_CHEN8_Msk = 0x100
	// Bit CHEN8.
	IPC_RECEIVE_CNF_CHEN8 = 0x100
	// Disable events
	IPC_RECEIVE_CNF_CHEN8_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN8_Enable = 0x1
	// Position of CHEN9 field.
	IPC_RECEIVE_CNF_CHEN9_Pos = 0x9
	// Bit mask of CHEN9 field.
	IPC_RECEIVE_CNF_CHEN9_Msk = 0x200
	// Bit CHEN9.
	IPC_RECEIVE_CNF_CHEN9 = 0x200
	// Disable events
	IPC_RECEIVE_CNF_CHEN9_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN9_Enable = 0x1
	// Position of CHEN10 field.
	IPC_RECEIVE_CNF_CHEN10_Pos = 0xa
	// Bit mask of CHEN10 field.
	IPC_RECEIVE_CNF_CHEN10_Msk = 0x400
	// Bit CHEN10.
	IPC_RECEIVE_CNF_CHEN10 = 0x400
	// Disable events
	IPC_RECEIVE_CNF_CHEN10_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN10_Enable = 0x1
	// Position of CHEN11 field.
	IPC_RECEIVE_CNF_CHEN11_Pos = 0xb
	// Bit mask of CHEN11 field.
	IPC_RECEIVE_CNF_CHEN11_Msk = 0x800
	// Bit CHEN11.
	IPC_RECEIVE_CNF_CHEN11 = 0x800
	// Disable events
	IPC_RECEIVE_CNF_CHEN11_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN11_Enable = 0x1
	// Position of CHEN12 field.
	IPC_RECEIVE_CNF_CHEN12_Pos = 0xc
	// Bit mask of CHEN12 field.
	IPC_RECEIVE_CNF_CHEN12_Msk = 0x1000
	// Bit CHEN12.
	IPC_RECEIVE_CNF_CHEN12 = 0x1000
	// Disable events
	IPC_RECEIVE_CNF_CHEN12_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN12_Enable = 0x1
	// Position of CHEN13 field.
	IPC_RECEIVE_CNF_CHEN13_Pos = 0xd
	// Bit mask of CHEN13 field.
	IPC_RECEIVE_CNF_CHEN13_Msk = 0x2000
	// Bit CHEN13.
	IPC_RECEIVE_CNF_CHEN13 = 0x2000
	// Disable events
	IPC_RECEIVE_CNF_CHEN13_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN13_Enable = 0x1
	// Position of CHEN14 field.
	IPC_RECEIVE_CNF_CHEN14_Pos = 0xe
	// Bit mask of CHEN14 field.
	IPC_RECEIVE_CNF_CHEN14_Msk = 0x4000
	// Bit CHEN14.
	IPC_RECEIVE_CNF_CHEN14 = 0x4000
	// Disable events
	IPC_RECEIVE_CNF_CHEN14_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN14_Enable = 0x1
	// Position of CHEN15 field.
	IPC_RECEIVE_CNF_CHEN15_Pos = 0xf
	// Bit mask of CHEN15 field.
	IPC_RECEIVE_CNF_CHEN15_Msk = 0x8000
	// Bit CHEN15.
	IPC_RECEIVE_CNF_CHEN15 = 0x8000
	// Disable events
	IPC_RECEIVE_CNF_CHEN15_Disable = 0x0
	// Enable events
	IPC_RECEIVE_CNF_CHEN15_Enable = 0x1

	// GPMEM: Description collection: General purpose memory
	// Position of GPMEM field.
	IPC_GPMEM_GPMEM_Pos = 0x0
	// Bit mask of GPMEM field.
	IPC_GPMEM_GPMEM_Msk = 0xffffffff
)

// Constants for QSPI_NS: External flash interface 0
const (
	// TASKS_ACTIVATE: Activate QSPI interface
	// Position of TASKS_ACTIVATE field.
	QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Pos = 0x0
	// Bit mask of TASKS_ACTIVATE field.
	QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Msk = 0x1
	// Bit TASKS_ACTIVATE.
	QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE = 0x1
	// Trigger task
	QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Trigger = 0x1

	// TASKS_READSTART: Start transfer from external flash memory to internal RAM
	// Position of TASKS_READSTART field.
	QSPI_TASKS_READSTART_TASKS_READSTART_Pos = 0x0
	// Bit mask of TASKS_READSTART field.
	QSPI_TASKS_READSTART_TASKS_READSTART_Msk = 0x1
	// Bit TASKS_READSTART.
	QSPI_TASKS_READSTART_TASKS_READSTART = 0x1
	// Trigger task
	QSPI_TASKS_READSTART_TASKS_READSTART_Trigger = 0x1

	// TASKS_WRITESTART: Start transfer from internal RAM to external flash memory
	// Position of TASKS_WRITESTART field.
	QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Pos = 0x0
	// Bit mask of TASKS_WRITESTART field.
	QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Msk = 0x1
	// Bit TASKS_WRITESTART.
	QSPI_TASKS_WRITESTART_TASKS_WRITESTART = 0x1
	// Trigger task
	QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Trigger = 0x1

	// TASKS_ERASESTART: Start external flash memory erase operation
	// Position of TASKS_ERASESTART field.
	QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Pos = 0x0
	// Bit mask of TASKS_ERASESTART field.
	QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Msk = 0x1
	// Bit TASKS_ERASESTART.
	QSPI_TASKS_ERASESTART_TASKS_ERASESTART = 0x1
	// Trigger task
	QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Trigger = 0x1

	// TASKS_DEACTIVATE: Deactivate QSPI interface
	// Position of TASKS_DEACTIVATE field.
	QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Pos = 0x0
	// Bit mask of TASKS_DEACTIVATE field.
	QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Msk = 0x1
	// Bit TASKS_DEACTIVATE.
	QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE = 0x1
	// Trigger task
	QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Trigger = 0x1

	// SUBSCRIBE_ACTIVATE: Subscribe configuration for task ACTIVATE
	// Position of CHIDX field.
	QSPI_SUBSCRIBE_ACTIVATE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QSPI_SUBSCRIBE_ACTIVATE_CHIDX_Msk = 0xff
	// Position of EN field.
	QSPI_SUBSCRIBE_ACTIVATE_EN_Pos = 0x1f
	// Bit mask of EN field.
	QSPI_SUBSCRIBE_ACTIVATE_EN_Msk = 0x80000000
	// Bit EN.
	QSPI_SUBSCRIBE_ACTIVATE_EN = 0x80000000
	// Disable subscription
	QSPI_SUBSCRIBE_ACTIVATE_EN_Disabled = 0x0
	// Enable subscription
	QSPI_SUBSCRIBE_ACTIVATE_EN_Enabled = 0x1

	// SUBSCRIBE_READSTART: Subscribe configuration for task READSTART
	// Position of CHIDX field.
	QSPI_SUBSCRIBE_READSTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QSPI_SUBSCRIBE_READSTART_CHIDX_Msk = 0xff
	// Position of EN field.
	QSPI_SUBSCRIBE_READSTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	QSPI_SUBSCRIBE_READSTART_EN_Msk = 0x80000000
	// Bit EN.
	QSPI_SUBSCRIBE_READSTART_EN = 0x80000000
	// Disable subscription
	QSPI_SUBSCRIBE_READSTART_EN_Disabled = 0x0
	// Enable subscription
	QSPI_SUBSCRIBE_READSTART_EN_Enabled = 0x1

	// SUBSCRIBE_WRITESTART: Subscribe configuration for task WRITESTART
	// Position of CHIDX field.
	QSPI_SUBSCRIBE_WRITESTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QSPI_SUBSCRIBE_WRITESTART_CHIDX_Msk = 0xff
	// Position of EN field.
	QSPI_SUBSCRIBE_WRITESTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	QSPI_SUBSCRIBE_WRITESTART_EN_Msk = 0x80000000
	// Bit EN.
	QSPI_SUBSCRIBE_WRITESTART_EN = 0x80000000
	// Disable subscription
	QSPI_SUBSCRIBE_WRITESTART_EN_Disabled = 0x0
	// Enable subscription
	QSPI_SUBSCRIBE_WRITESTART_EN_Enabled = 0x1

	// SUBSCRIBE_ERASESTART: Subscribe configuration for task ERASESTART
	// Position of CHIDX field.
	QSPI_SUBSCRIBE_ERASESTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QSPI_SUBSCRIBE_ERASESTART_CHIDX_Msk = 0xff
	// Position of EN field.
	QSPI_SUBSCRIBE_ERASESTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	QSPI_SUBSCRIBE_ERASESTART_EN_Msk = 0x80000000
	// Bit EN.
	QSPI_SUBSCRIBE_ERASESTART_EN = 0x80000000
	// Disable subscription
	QSPI_SUBSCRIBE_ERASESTART_EN_Disabled = 0x0
	// Enable subscription
	QSPI_SUBSCRIBE_ERASESTART_EN_Enabled = 0x1

	// SUBSCRIBE_DEACTIVATE: Subscribe configuration for task DEACTIVATE
	// Position of CHIDX field.
	QSPI_SUBSCRIBE_DEACTIVATE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QSPI_SUBSCRIBE_DEACTIVATE_CHIDX_Msk = 0xff
	// Position of EN field.
	QSPI_SUBSCRIBE_DEACTIVATE_EN_Pos = 0x1f
	// Bit mask of EN field.
	QSPI_SUBSCRIBE_DEACTIVATE_EN_Msk = 0x80000000
	// Bit EN.
	QSPI_SUBSCRIBE_DEACTIVATE_EN = 0x80000000
	// Disable subscription
	QSPI_SUBSCRIBE_DEACTIVATE_EN_Disabled = 0x0
	// Enable subscription
	QSPI_SUBSCRIBE_DEACTIVATE_EN_Enabled = 0x1

	// EVENTS_READY: QSPI peripheral is ready. This event will be generated as a response to all QSPI tasks except DEACTIVATE.
	// Position of EVENTS_READY field.
	QSPI_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	QSPI_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	QSPI_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	QSPI_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	QSPI_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// PUBLISH_READY: Publish configuration for event READY
	// Position of CHIDX field.
	QSPI_PUBLISH_READY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QSPI_PUBLISH_READY_CHIDX_Msk = 0xff
	// Position of EN field.
	QSPI_PUBLISH_READY_EN_Pos = 0x1f
	// Bit mask of EN field.
	QSPI_PUBLISH_READY_EN_Msk = 0x80000000
	// Bit EN.
	QSPI_PUBLISH_READY_EN = 0x80000000
	// Disable publishing
	QSPI_PUBLISH_READY_EN_Disabled = 0x0
	// Enable publishing
	QSPI_PUBLISH_READY_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of READY field.
	QSPI_INTEN_READY_Pos = 0x0
	// Bit mask of READY field.
	QSPI_INTEN_READY_Msk = 0x1
	// Bit READY.
	QSPI_INTEN_READY = 0x1
	// Disable
	QSPI_INTEN_READY_Disabled = 0x0
	// Enable
	QSPI_INTEN_READY_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	QSPI_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	QSPI_INTENSET_READY_Msk = 0x1
	// Bit READY.
	QSPI_INTENSET_READY = 0x1
	// Read: Disabled
	QSPI_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	QSPI_INTENSET_READY_Enabled = 0x1
	// Enable
	QSPI_INTENSET_READY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	QSPI_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	QSPI_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	QSPI_INTENCLR_READY = 0x1
	// Read: Disabled
	QSPI_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	QSPI_INTENCLR_READY_Enabled = 0x1
	// Disable
	QSPI_INTENCLR_READY_Clear = 0x1

	// ENABLE: Enable QSPI peripheral and acquire the pins selected in PSELn registers
	// Position of ENABLE field.
	QSPI_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QSPI_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QSPI_ENABLE_ENABLE = 0x1
	// Disable QSPI
	QSPI_ENABLE_ENABLE_Disabled = 0x0
	// Enable QSPI
	QSPI_ENABLE_ENABLE_Enabled = 0x1

	// READ.SRC: Flash memory source address
	// Position of SRC field.
	QSPI_READ_SRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	QSPI_READ_SRC_SRC_Msk = 0xffffffff

	// READ.DST: RAM destination address
	// Position of DST field.
	QSPI_READ_DST_DST_Pos = 0x0
	// Bit mask of DST field.
	QSPI_READ_DST_DST_Msk = 0xffffffff

	// READ.CNT: Read transfer length
	// Position of CNT field.
	QSPI_READ_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	QSPI_READ_CNT_CNT_Msk = 0x1fffff

	// WRITE.DST: Flash destination address
	// Position of DST field.
	QSPI_WRITE_DST_DST_Pos = 0x0
	// Bit mask of DST field.
	QSPI_WRITE_DST_DST_Msk = 0xffffffff

	// WRITE.SRC: RAM source address
	// Position of SRC field.
	QSPI_WRITE_SRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	QSPI_WRITE_SRC_SRC_Msk = 0xffffffff

	// WRITE.CNT: Write transfer length
	// Position of CNT field.
	QSPI_WRITE_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	QSPI_WRITE_CNT_CNT_Msk = 0x1fffff

	// ERASE.PTR: Start address of flash block to be erased
	// Position of PTR field.
	QSPI_ERASE_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	QSPI_ERASE_PTR_PTR_Msk = 0xffffffff

	// ERASE.LEN: Size of block to be erased.
	// Position of LEN field.
	QSPI_ERASE_LEN_LEN_Pos = 0x0
	// Bit mask of LEN field.
	QSPI_ERASE_LEN_LEN_Msk = 0x3
	// Erase 4 kB block (flash command 0x20)
	QSPI_ERASE_LEN_LEN_4KB = 0x0
	// Erase 64 kB block (flash command 0xD8)
	QSPI_ERASE_LEN_LEN_64KB = 0x1
	// Erase all (flash command 0xC7)
	QSPI_ERASE_LEN_LEN_All = 0x2

	// PSEL.SCK: Pin select for serial clock SCK
	// Position of PIN field.
	QSPI_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QSPI_PSEL_SCK_PIN_Msk = 0x1f
	// Position of PORT field.
	QSPI_PSEL_SCK_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QSPI_PSEL_SCK_PORT_Msk = 0x20
	// Bit PORT.
	QSPI_PSEL_SCK_PORT = 0x20
	// Position of CONNECT field.
	QSPI_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QSPI_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QSPI_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	QSPI_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	QSPI_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.CSN: Pin select for chip select signal CSN.
	// Position of PIN field.
	QSPI_PSEL_CSN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QSPI_PSEL_CSN_PIN_Msk = 0x1f
	// Position of PORT field.
	QSPI_PSEL_CSN_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QSPI_PSEL_CSN_PORT_Msk = 0x20
	// Bit PORT.
	QSPI_PSEL_CSN_PORT = 0x20
	// Position of CONNECT field.
	QSPI_PSEL_CSN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QSPI_PSEL_CSN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QSPI_PSEL_CSN_CONNECT = 0x80000000
	// Disconnect
	QSPI_PSEL_CSN_CONNECT_Disconnected = 0x1
	// Connect
	QSPI_PSEL_CSN_CONNECT_Connected = 0x0

	// PSEL.IO0: Pin select for serial data MOSI/IO0.
	// Position of PIN field.
	QSPI_PSEL_IO0_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QSPI_PSEL_IO0_PIN_Msk = 0x1f
	// Position of PORT field.
	QSPI_PSEL_IO0_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QSPI_PSEL_IO0_PORT_Msk = 0x20
	// Bit PORT.
	QSPI_PSEL_IO0_PORT = 0x20
	// Position of CONNECT field.
	QSPI_PSEL_IO0_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QSPI_PSEL_IO0_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QSPI_PSEL_IO0_CONNECT = 0x80000000
	// Disconnect
	QSPI_PSEL_IO0_CONNECT_Disconnected = 0x1
	// Connect
	QSPI_PSEL_IO0_CONNECT_Connected = 0x0

	// PSEL.IO1: Pin select for serial data MISO/IO1.
	// Position of PIN field.
	QSPI_PSEL_IO1_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QSPI_PSEL_IO1_PIN_Msk = 0x1f
	// Position of PORT field.
	QSPI_PSEL_IO1_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QSPI_PSEL_IO1_PORT_Msk = 0x20
	// Bit PORT.
	QSPI_PSEL_IO1_PORT = 0x20
	// Position of CONNECT field.
	QSPI_PSEL_IO1_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QSPI_PSEL_IO1_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QSPI_PSEL_IO1_CONNECT = 0x80000000
	// Disconnect
	QSPI_PSEL_IO1_CONNECT_Disconnected = 0x1
	// Connect
	QSPI_PSEL_IO1_CONNECT_Connected = 0x0

	// PSEL.IO2: Pin select for serial data IO2.
	// Position of PIN field.
	QSPI_PSEL_IO2_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QSPI_PSEL_IO2_PIN_Msk = 0x1f
	// Position of PORT field.
	QSPI_PSEL_IO2_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QSPI_PSEL_IO2_PORT_Msk = 0x20
	// Bit PORT.
	QSPI_PSEL_IO2_PORT = 0x20
	// Position of CONNECT field.
	QSPI_PSEL_IO2_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QSPI_PSEL_IO2_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QSPI_PSEL_IO2_CONNECT = 0x80000000
	// Disconnect
	QSPI_PSEL_IO2_CONNECT_Disconnected = 0x1
	// Connect
	QSPI_PSEL_IO2_CONNECT_Connected = 0x0

	// PSEL.IO3: Pin select for serial data IO3.
	// Position of PIN field.
	QSPI_PSEL_IO3_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QSPI_PSEL_IO3_PIN_Msk = 0x1f
	// Position of PORT field.
	QSPI_PSEL_IO3_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QSPI_PSEL_IO3_PORT_Msk = 0x20
	// Bit PORT.
	QSPI_PSEL_IO3_PORT = 0x20
	// Position of CONNECT field.
	QSPI_PSEL_IO3_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QSPI_PSEL_IO3_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QSPI_PSEL_IO3_CONNECT = 0x80000000
	// Disconnect
	QSPI_PSEL_IO3_CONNECT_Disconnected = 0x1
	// Connect
	QSPI_PSEL_IO3_CONNECT_Connected = 0x0

	// XIPOFFSET: Address offset into the external memory for Execute in Place operation.
	// Position of XIPOFFSET field.
	QSPI_XIPOFFSET_XIPOFFSET_Pos = 0x0
	// Bit mask of XIPOFFSET field.
	QSPI_XIPOFFSET_XIPOFFSET_Msk = 0xffffffff

	// IFCONFIG0: Interface configuration.
	// Position of READOC field.
	QSPI_IFCONFIG0_READOC_Pos = 0x0
	// Bit mask of READOC field.
	QSPI_IFCONFIG0_READOC_Msk = 0x7
	// Single data line SPI. FAST_READ (opcode 0x0B).
	QSPI_IFCONFIG0_READOC_FASTREAD = 0x0
	// Dual data line SPI. READ2O (opcode 0x3B).
	QSPI_IFCONFIG0_READOC_READ2O = 0x1
	// Dual data line SPI. READ2IO (opcode 0xBB).
	QSPI_IFCONFIG0_READOC_READ2IO = 0x2
	// Quad data line SPI. READ4O (opcode 0x6B).
	QSPI_IFCONFIG0_READOC_READ4O = 0x3
	// Quad data line SPI. READ4IO (opcode 0xEB).
	QSPI_IFCONFIG0_READOC_READ4IO = 0x4
	// Position of WRITEOC field.
	QSPI_IFCONFIG0_WRITEOC_Pos = 0x3
	// Bit mask of WRITEOC field.
	QSPI_IFCONFIG0_WRITEOC_Msk = 0x38
	// Single data line SPI. PP (opcode 0x02).
	QSPI_IFCONFIG0_WRITEOC_PP = 0x0
	// Dual data line SPI. PP2O (opcode 0xA2).
	QSPI_IFCONFIG0_WRITEOC_PP2O = 0x1
	// Quad data line SPI. PP4O (opcode 0x32).
	QSPI_IFCONFIG0_WRITEOC_PP4O = 0x2
	// Quad data line SPI. PP4IO (opcode 0x38).
	QSPI_IFCONFIG0_WRITEOC_PP4IO = 0x3
	// Position of ADDRMODE field.
	QSPI_IFCONFIG0_ADDRMODE_Pos = 0x6
	// Bit mask of ADDRMODE field.
	QSPI_IFCONFIG0_ADDRMODE_Msk = 0x40
	// Bit ADDRMODE.
	QSPI_IFCONFIG0_ADDRMODE = 0x40
	// 24-bit addressing.
	QSPI_IFCONFIG0_ADDRMODE_24BIT = 0x0
	// 32-bit addressing.
	QSPI_IFCONFIG0_ADDRMODE_32BIT = 0x1
	// Position of DPMENABLE field.
	QSPI_IFCONFIG0_DPMENABLE_Pos = 0x7
	// Bit mask of DPMENABLE field.
	QSPI_IFCONFIG0_DPMENABLE_Msk = 0x80
	// Bit DPMENABLE.
	QSPI_IFCONFIG0_DPMENABLE = 0x80
	// Disable DPM feature.
	QSPI_IFCONFIG0_DPMENABLE_Disable = 0x0
	// Enable DPM feature.
	QSPI_IFCONFIG0_DPMENABLE_Enable = 0x1
	// Position of PPSIZE field.
	QSPI_IFCONFIG0_PPSIZE_Pos = 0xc
	// Bit mask of PPSIZE field.
	QSPI_IFCONFIG0_PPSIZE_Msk = 0x1000
	// Bit PPSIZE.
	QSPI_IFCONFIG0_PPSIZE = 0x1000
	// 256 bytes.
	QSPI_IFCONFIG0_PPSIZE_256Bytes = 0x0
	// 512 bytes.
	QSPI_IFCONFIG0_PPSIZE_512Bytes = 0x1

	// XIPEN: Enable Execute in Place operation.
	// Position of XIPEN field.
	QSPI_XIPEN_XIPEN_Pos = 0x0
	// Bit mask of XIPEN field.
	QSPI_XIPEN_XIPEN_Msk = 0x1
	// Bit XIPEN.
	QSPI_XIPEN_XIPEN = 0x1
	// Disable XIP interface
	QSPI_XIPEN_XIPEN_Disable = 0x0
	// Enable XIP interface
	QSPI_XIPEN_XIPEN_Enable = 0x1

	// XIP_ENC.KEY0: Bits 31:0 of XIP AES KEY
	// Position of KEY0 field.
	QSPI_XIP_ENC_KEY0_KEY0_Pos = 0x0
	// Bit mask of KEY0 field.
	QSPI_XIP_ENC_KEY0_KEY0_Msk = 0xffffffff

	// XIP_ENC.KEY1: Bits 63:32 of XIP AES KEY
	// Position of KEY1 field.
	QSPI_XIP_ENC_KEY1_KEY1_Pos = 0x0
	// Bit mask of KEY1 field.
	QSPI_XIP_ENC_KEY1_KEY1_Msk = 0xffffffff

	// XIP_ENC.KEY2: Bits 95:64 of XIP AES KEY
	// Position of KEY2 field.
	QSPI_XIP_ENC_KEY2_KEY2_Pos = 0x0
	// Bit mask of KEY2 field.
	QSPI_XIP_ENC_KEY2_KEY2_Msk = 0xffffffff

	// XIP_ENC.KEY3: Bits 127:96 of XIP AES KEY
	// Position of KEY3 field.
	QSPI_XIP_ENC_KEY3_KEY3_Pos = 0x0
	// Bit mask of KEY3 field.
	QSPI_XIP_ENC_KEY3_KEY3_Msk = 0xffffffff

	// XIP_ENC.NONCE0: Bits 31:0 of XIP NONCE
	// Position of NONCE0 field.
	QSPI_XIP_ENC_NONCE0_NONCE0_Pos = 0x0
	// Bit mask of NONCE0 field.
	QSPI_XIP_ENC_NONCE0_NONCE0_Msk = 0xffffffff

	// XIP_ENC.NONCE1: Bits 63:32 of XIP NONCE
	// Position of NONCE1 field.
	QSPI_XIP_ENC_NONCE1_NONCE1_Pos = 0x0
	// Bit mask of NONCE1 field.
	QSPI_XIP_ENC_NONCE1_NONCE1_Msk = 0xffffffff

	// XIP_ENC.NONCE2: Bits 95:64 of XIP NONCE
	// Position of NONCE2 field.
	QSPI_XIP_ENC_NONCE2_NONCE2_Pos = 0x0
	// Bit mask of NONCE2 field.
	QSPI_XIP_ENC_NONCE2_NONCE2_Msk = 0xffffffff

	// XIP_ENC.ENABLE: Enable stream cipher for XIP
	// Position of ENABLE field.
	QSPI_XIP_ENC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QSPI_XIP_ENC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QSPI_XIP_ENC_ENABLE_ENABLE = 0x1
	// Disable stream cipher for QSPI XIP
	QSPI_XIP_ENC_ENABLE_ENABLE_Disabled = 0x0
	// Enable stream cipher for QSPI XIP
	QSPI_XIP_ENC_ENABLE_ENABLE_Enabled = 0x1

	// DMA_ENC.KEY0: Bits 31:0 of DMA AES KEY
	// Position of KEY0 field.
	QSPI_DMA_ENC_KEY0_KEY0_Pos = 0x0
	// Bit mask of KEY0 field.
	QSPI_DMA_ENC_KEY0_KEY0_Msk = 0xffffffff

	// DMA_ENC.KEY1: Bits 63:32 of DMA AES KEY
	// Position of KEY1 field.
	QSPI_DMA_ENC_KEY1_KEY1_Pos = 0x0
	// Bit mask of KEY1 field.
	QSPI_DMA_ENC_KEY1_KEY1_Msk = 0xffffffff

	// DMA_ENC.KEY2: Bits 95:64 of DMA AES KEY
	// Position of KEY2 field.
	QSPI_DMA_ENC_KEY2_KEY2_Pos = 0x0
	// Bit mask of KEY2 field.
	QSPI_DMA_ENC_KEY2_KEY2_Msk = 0xffffffff

	// DMA_ENC.KEY3: Bits 127:96 of DMA AES KEY
	// Position of KEY3 field.
	QSPI_DMA_ENC_KEY3_KEY3_Pos = 0x0
	// Bit mask of KEY3 field.
	QSPI_DMA_ENC_KEY3_KEY3_Msk = 0xffffffff

	// DMA_ENC.NONCE0: Bits 31:0 of DMA NONCE
	// Position of NONCE0 field.
	QSPI_DMA_ENC_NONCE0_NONCE0_Pos = 0x0
	// Bit mask of NONCE0 field.
	QSPI_DMA_ENC_NONCE0_NONCE0_Msk = 0xffffffff

	// DMA_ENC.NONCE1: Bits 63:32 of DMA NONCE
	// Position of NONCE1 field.
	QSPI_DMA_ENC_NONCE1_NONCE1_Pos = 0x0
	// Bit mask of NONCE1 field.
	QSPI_DMA_ENC_NONCE1_NONCE1_Msk = 0xffffffff

	// DMA_ENC.NONCE2: Bits 95:64 of DMA NONCE
	// Position of NONCE2 field.
	QSPI_DMA_ENC_NONCE2_NONCE2_Pos = 0x0
	// Bit mask of NONCE2 field.
	QSPI_DMA_ENC_NONCE2_NONCE2_Msk = 0xffffffff

	// DMA_ENC.ENABLE: Enable stream cipher for EasyDMA
	// Position of ENABLE field.
	QSPI_DMA_ENC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QSPI_DMA_ENC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QSPI_DMA_ENC_ENABLE_ENABLE = 0x1
	// Disable stream cipher for QSPI EasyDMA
	QSPI_DMA_ENC_ENABLE_ENABLE_Disabled = 0x0
	// Enable stream cipher for QSPI EasyDMA
	QSPI_DMA_ENC_ENABLE_ENABLE_Enabled = 0x1

	// IFCONFIG1: Interface configuration.
	// Position of SCKDELAY field.
	QSPI_IFCONFIG1_SCKDELAY_Pos = 0x0
	// Bit mask of SCKDELAY field.
	QSPI_IFCONFIG1_SCKDELAY_Msk = 0xff
	// Position of DPMEN field.
	QSPI_IFCONFIG1_DPMEN_Pos = 0x18
	// Bit mask of DPMEN field.
	QSPI_IFCONFIG1_DPMEN_Msk = 0x1000000
	// Bit DPMEN.
	QSPI_IFCONFIG1_DPMEN = 0x1000000
	// Exit DPM.
	QSPI_IFCONFIG1_DPMEN_Exit = 0x0
	// Enter DPM.
	QSPI_IFCONFIG1_DPMEN_Enter = 0x1
	// Position of SPIMODE field.
	QSPI_IFCONFIG1_SPIMODE_Pos = 0x19
	// Bit mask of SPIMODE field.
	QSPI_IFCONFIG1_SPIMODE_Msk = 0x2000000
	// Bit SPIMODE.
	QSPI_IFCONFIG1_SPIMODE = 0x2000000
	// Mode 0: Data are captured on the clock rising edge and data is output on a falling edge. Base level of clock is 0 (CPOL=0, CPHA=0).
	QSPI_IFCONFIG1_SPIMODE_MODE0 = 0x0
	// Position of SCKFREQ field.
	QSPI_IFCONFIG1_SCKFREQ_Pos = 0x1c
	// Bit mask of SCKFREQ field.
	QSPI_IFCONFIG1_SCKFREQ_Msk = 0xf0000000

	// STATUS: Status register.
	// Position of DPM field.
	QSPI_STATUS_DPM_Pos = 0x2
	// Bit mask of DPM field.
	QSPI_STATUS_DPM_Msk = 0x4
	// Bit DPM.
	QSPI_STATUS_DPM = 0x4
	// External flash is not in DPM.
	QSPI_STATUS_DPM_Disabled = 0x0
	// External flash is in DPM.
	QSPI_STATUS_DPM_Enabled = 0x1
	// Position of READY field.
	QSPI_STATUS_READY_Pos = 0x3
	// Bit mask of READY field.
	QSPI_STATUS_READY_Msk = 0x8
	// Bit READY.
	QSPI_STATUS_READY = 0x8
	// QSPI peripheral is ready. It is allowed to trigger new tasks, writing custom instructions or enter/exit DPM.
	QSPI_STATUS_READY_READY = 0x1
	// QSPI peripheral is busy. It is not allowed to trigger any new tasks, writing custom instructions or enter/exit DPM.
	QSPI_STATUS_READY_BUSY = 0x0
	// Position of SREG field.
	QSPI_STATUS_SREG_Pos = 0x18
	// Bit mask of SREG field.
	QSPI_STATUS_SREG_Msk = 0xff000000

	// DPMDUR: Set the duration required to enter/exit deep power-down mode (DPM).
	// Position of ENTER field.
	QSPI_DPMDUR_ENTER_Pos = 0x0
	// Bit mask of ENTER field.
	QSPI_DPMDUR_ENTER_Msk = 0xffff
	// Position of EXIT field.
	QSPI_DPMDUR_EXIT_Pos = 0x10
	// Bit mask of EXIT field.
	QSPI_DPMDUR_EXIT_Msk = 0xffff0000

	// ADDRCONF: Extended address configuration.
	// Position of OPCODE field.
	QSPI_ADDRCONF_OPCODE_Pos = 0x0
	// Bit mask of OPCODE field.
	QSPI_ADDRCONF_OPCODE_Msk = 0xff
	// Position of BYTE0 field.
	QSPI_ADDRCONF_BYTE0_Pos = 0x8
	// Bit mask of BYTE0 field.
	QSPI_ADDRCONF_BYTE0_Msk = 0xff00
	// Position of BYTE1 field.
	QSPI_ADDRCONF_BYTE1_Pos = 0x10
	// Bit mask of BYTE1 field.
	QSPI_ADDRCONF_BYTE1_Msk = 0xff0000
	// Position of MODE field.
	QSPI_ADDRCONF_MODE_Pos = 0x18
	// Bit mask of MODE field.
	QSPI_ADDRCONF_MODE_Msk = 0x3000000
	// Do not send any instruction.
	QSPI_ADDRCONF_MODE_NoInstr = 0x0
	// Send opcode.
	QSPI_ADDRCONF_MODE_Opcode = 0x1
	// Send opcode, byte0.
	QSPI_ADDRCONF_MODE_OpByte0 = 0x2
	// Send opcode, byte0, byte1.
	QSPI_ADDRCONF_MODE_All = 0x3
	// Position of WIPWAIT field.
	QSPI_ADDRCONF_WIPWAIT_Pos = 0x1a
	// Bit mask of WIPWAIT field.
	QSPI_ADDRCONF_WIPWAIT_Msk = 0x4000000
	// Bit WIPWAIT.
	QSPI_ADDRCONF_WIPWAIT = 0x4000000
	// No wait.
	QSPI_ADDRCONF_WIPWAIT_Disable = 0x0
	// Wait.
	QSPI_ADDRCONF_WIPWAIT_Enable = 0x1
	// Position of WREN field.
	QSPI_ADDRCONF_WREN_Pos = 0x1b
	// Bit mask of WREN field.
	QSPI_ADDRCONF_WREN_Msk = 0x8000000
	// Bit WREN.
	QSPI_ADDRCONF_WREN = 0x8000000
	// Do not send WREN.
	QSPI_ADDRCONF_WREN_Disable = 0x0
	// Send WREN.
	QSPI_ADDRCONF_WREN_Enable = 0x1

	// CINSTRCONF: Custom instruction configuration register.
	// Position of OPCODE field.
	QSPI_CINSTRCONF_OPCODE_Pos = 0x0
	// Bit mask of OPCODE field.
	QSPI_CINSTRCONF_OPCODE_Msk = 0xff
	// Position of LENGTH field.
	QSPI_CINSTRCONF_LENGTH_Pos = 0x8
	// Bit mask of LENGTH field.
	QSPI_CINSTRCONF_LENGTH_Msk = 0xf00
	// Send opcode only.
	QSPI_CINSTRCONF_LENGTH_1B = 0x1
	// Send opcode, CINSTRDAT0.BYTE0.
	QSPI_CINSTRCONF_LENGTH_2B = 0x2
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT0.BYTE1.
	QSPI_CINSTRCONF_LENGTH_3B = 0x3
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT0.BYTE2.
	QSPI_CINSTRCONF_LENGTH_4B = 0x4
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT0.BYTE3.
	QSPI_CINSTRCONF_LENGTH_5B = 0x5
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE4.
	QSPI_CINSTRCONF_LENGTH_6B = 0x6
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE5.
	QSPI_CINSTRCONF_LENGTH_7B = 0x7
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE6.
	QSPI_CINSTRCONF_LENGTH_8B = 0x8
	// Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE7.
	QSPI_CINSTRCONF_LENGTH_9B = 0x9
	// Position of LIO2 field.
	QSPI_CINSTRCONF_LIO2_Pos = 0xc
	// Bit mask of LIO2 field.
	QSPI_CINSTRCONF_LIO2_Msk = 0x1000
	// Bit LIO2.
	QSPI_CINSTRCONF_LIO2 = 0x1000
	// Position of LIO3 field.
	QSPI_CINSTRCONF_LIO3_Pos = 0xd
	// Bit mask of LIO3 field.
	QSPI_CINSTRCONF_LIO3_Msk = 0x2000
	// Bit LIO3.
	QSPI_CINSTRCONF_LIO3 = 0x2000
	// Position of WIPWAIT field.
	QSPI_CINSTRCONF_WIPWAIT_Pos = 0xe
	// Bit mask of WIPWAIT field.
	QSPI_CINSTRCONF_WIPWAIT_Msk = 0x4000
	// Bit WIPWAIT.
	QSPI_CINSTRCONF_WIPWAIT = 0x4000
	// No wait.
	QSPI_CINSTRCONF_WIPWAIT_Disable = 0x0
	// Wait.
	QSPI_CINSTRCONF_WIPWAIT_Enable = 0x1
	// Position of WREN field.
	QSPI_CINSTRCONF_WREN_Pos = 0xf
	// Bit mask of WREN field.
	QSPI_CINSTRCONF_WREN_Msk = 0x8000
	// Bit WREN.
	QSPI_CINSTRCONF_WREN = 0x8000
	// Do not send WREN.
	QSPI_CINSTRCONF_WREN_Disable = 0x0
	// Send WREN.
	QSPI_CINSTRCONF_WREN_Enable = 0x1
	// Position of LFEN field.
	QSPI_CINSTRCONF_LFEN_Pos = 0x10
	// Bit mask of LFEN field.
	QSPI_CINSTRCONF_LFEN_Msk = 0x10000
	// Bit LFEN.
	QSPI_CINSTRCONF_LFEN = 0x10000
	// Long frame mode disabled
	QSPI_CINSTRCONF_LFEN_Disable = 0x0
	// Long frame mode enabled
	QSPI_CINSTRCONF_LFEN_Enable = 0x1
	// Position of LFSTOP field.
	QSPI_CINSTRCONF_LFSTOP_Pos = 0x11
	// Bit mask of LFSTOP field.
	QSPI_CINSTRCONF_LFSTOP_Msk = 0x20000
	// Bit LFSTOP.
	QSPI_CINSTRCONF_LFSTOP = 0x20000
	// Stop
	QSPI_CINSTRCONF_LFSTOP_Stop = 0x1

	// CINSTRDAT0: Custom instruction data register 0.
	// Position of BYTE0 field.
	QSPI_CINSTRDAT0_BYTE0_Pos = 0x0
	// Bit mask of BYTE0 field.
	QSPI_CINSTRDAT0_BYTE0_Msk = 0xff
	// Position of BYTE1 field.
	QSPI_CINSTRDAT0_BYTE1_Pos = 0x8
	// Bit mask of BYTE1 field.
	QSPI_CINSTRDAT0_BYTE1_Msk = 0xff00
	// Position of BYTE2 field.
	QSPI_CINSTRDAT0_BYTE2_Pos = 0x10
	// Bit mask of BYTE2 field.
	QSPI_CINSTRDAT0_BYTE2_Msk = 0xff0000
	// Position of BYTE3 field.
	QSPI_CINSTRDAT0_BYTE3_Pos = 0x18
	// Bit mask of BYTE3 field.
	QSPI_CINSTRDAT0_BYTE3_Msk = 0xff000000

	// CINSTRDAT1: Custom instruction data register 1.
	// Position of BYTE4 field.
	QSPI_CINSTRDAT1_BYTE4_Pos = 0x0
	// Bit mask of BYTE4 field.
	QSPI_CINSTRDAT1_BYTE4_Msk = 0xff
	// Position of BYTE5 field.
	QSPI_CINSTRDAT1_BYTE5_Pos = 0x8
	// Bit mask of BYTE5 field.
	QSPI_CINSTRDAT1_BYTE5_Msk = 0xff00
	// Position of BYTE6 field.
	QSPI_CINSTRDAT1_BYTE6_Pos = 0x10
	// Bit mask of BYTE6 field.
	QSPI_CINSTRDAT1_BYTE6_Msk = 0xff0000
	// Position of BYTE7 field.
	QSPI_CINSTRDAT1_BYTE7_Pos = 0x18
	// Bit mask of BYTE7 field.
	QSPI_CINSTRDAT1_BYTE7_Msk = 0xff000000
)

// Constants for NFCT_NS: NFC-A compatible radio 0
const (
	// TASKS_ACTIVATE: Activate NFCT peripheral for incoming and outgoing frames, change state to activated
	// Position of TASKS_ACTIVATE field.
	NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Pos = 0x0
	// Bit mask of TASKS_ACTIVATE field.
	NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Msk = 0x1
	// Bit TASKS_ACTIVATE.
	NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE = 0x1
	// Trigger task
	NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Trigger = 0x1

	// TASKS_DISABLE: Disable NFCT peripheral
	// Position of TASKS_DISABLE field.
	NFCT_TASKS_DISABLE_TASKS_DISABLE_Pos = 0x0
	// Bit mask of TASKS_DISABLE field.
	NFCT_TASKS_DISABLE_TASKS_DISABLE_Msk = 0x1
	// Bit TASKS_DISABLE.
	NFCT_TASKS_DISABLE_TASKS_DISABLE = 0x1
	// Trigger task
	NFCT_TASKS_DISABLE_TASKS_DISABLE_Trigger = 0x1

	// TASKS_SENSE: Enable NFC sense field mode, change state to sense mode
	// Position of TASKS_SENSE field.
	NFCT_TASKS_SENSE_TASKS_SENSE_Pos = 0x0
	// Bit mask of TASKS_SENSE field.
	NFCT_TASKS_SENSE_TASKS_SENSE_Msk = 0x1
	// Bit TASKS_SENSE.
	NFCT_TASKS_SENSE_TASKS_SENSE = 0x1
	// Trigger task
	NFCT_TASKS_SENSE_TASKS_SENSE_Trigger = 0x1

	// TASKS_STARTTX: Start transmission of an outgoing frame, change state to transmit
	// Position of TASKS_STARTTX field.
	NFCT_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	NFCT_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	NFCT_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	NFCT_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_ENABLERXDATA: Initializes the EasyDMA for receive.
	// Position of TASKS_ENABLERXDATA field.
	NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Pos = 0x0
	// Bit mask of TASKS_ENABLERXDATA field.
	NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Msk = 0x1
	// Bit TASKS_ENABLERXDATA.
	NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA = 0x1
	// Trigger task
	NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Trigger = 0x1

	// TASKS_GOIDLE: Force state machine to IDLE state
	// Position of TASKS_GOIDLE field.
	NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Pos = 0x0
	// Bit mask of TASKS_GOIDLE field.
	NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Msk = 0x1
	// Bit TASKS_GOIDLE.
	NFCT_TASKS_GOIDLE_TASKS_GOIDLE = 0x1
	// Trigger task
	NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Trigger = 0x1

	// TASKS_GOSLEEP: Force state machine to SLEEP_A state
	// Position of TASKS_GOSLEEP field.
	NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Pos = 0x0
	// Bit mask of TASKS_GOSLEEP field.
	NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Msk = 0x1
	// Bit TASKS_GOSLEEP.
	NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP = 0x1
	// Trigger task
	NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Trigger = 0x1

	// SUBSCRIBE_ACTIVATE: Subscribe configuration for task ACTIVATE
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_ACTIVATE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_ACTIVATE_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_ACTIVATE_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_ACTIVATE_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_ACTIVATE_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_ACTIVATE_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_ACTIVATE_EN_Enabled = 0x1

	// SUBSCRIBE_DISABLE: Subscribe configuration for task DISABLE
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_DISABLE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_DISABLE_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_DISABLE_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_DISABLE_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_DISABLE_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_DISABLE_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_DISABLE_EN_Enabled = 0x1

	// SUBSCRIBE_SENSE: Subscribe configuration for task SENSE
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_SENSE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_SENSE_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_SENSE_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_SENSE_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_SENSE_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_SENSE_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_SENSE_EN_Enabled = 0x1

	// SUBSCRIBE_STARTTX: Subscribe configuration for task STARTTX
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_STARTTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_STARTTX_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_STARTTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_STARTTX_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_STARTTX_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_STARTTX_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_STARTTX_EN_Enabled = 0x1

	// SUBSCRIBE_ENABLERXDATA: Subscribe configuration for task ENABLERXDATA
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_ENABLERXDATA_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_ENABLERXDATA_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_ENABLERXDATA_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_ENABLERXDATA_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_ENABLERXDATA_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_ENABLERXDATA_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_ENABLERXDATA_EN_Enabled = 0x1

	// SUBSCRIBE_GOIDLE: Subscribe configuration for task GOIDLE
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_GOIDLE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_GOIDLE_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_GOIDLE_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_GOIDLE_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_GOIDLE_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_GOIDLE_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_GOIDLE_EN_Enabled = 0x1

	// SUBSCRIBE_GOSLEEP: Subscribe configuration for task GOSLEEP
	// Position of CHIDX field.
	NFCT_SUBSCRIBE_GOSLEEP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_SUBSCRIBE_GOSLEEP_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_SUBSCRIBE_GOSLEEP_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_SUBSCRIBE_GOSLEEP_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_SUBSCRIBE_GOSLEEP_EN = 0x80000000
	// Disable subscription
	NFCT_SUBSCRIBE_GOSLEEP_EN_Disabled = 0x0
	// Enable subscription
	NFCT_SUBSCRIBE_GOSLEEP_EN_Enabled = 0x1

	// EVENTS_READY: The NFCT peripheral is ready to receive and send frames
	// Position of EVENTS_READY field.
	NFCT_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	NFCT_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	NFCT_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	NFCT_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// EVENTS_FIELDDETECTED: Remote NFC field detected
	// Position of EVENTS_FIELDDETECTED field.
	NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Pos = 0x0
	// Bit mask of EVENTS_FIELDDETECTED field.
	NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Msk = 0x1
	// Bit EVENTS_FIELDDETECTED.
	NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED = 0x1
	// Event not generated
	NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Generated = 0x1

	// EVENTS_FIELDLOST: Remote NFC field lost
	// Position of EVENTS_FIELDLOST field.
	NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Pos = 0x0
	// Bit mask of EVENTS_FIELDLOST field.
	NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Msk = 0x1
	// Bit EVENTS_FIELDLOST.
	NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST = 0x1
	// Event not generated
	NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Generated = 0x1

	// EVENTS_TXFRAMESTART: Marks the start of the first symbol of a transmitted frame
	// Position of EVENTS_TXFRAMESTART field.
	NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Pos = 0x0
	// Bit mask of EVENTS_TXFRAMESTART field.
	NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Msk = 0x1
	// Bit EVENTS_TXFRAMESTART.
	NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART = 0x1
	// Event not generated
	NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Generated = 0x1

	// EVENTS_TXFRAMEEND: Marks the end of the last transmitted on-air symbol of a frame
	// Position of EVENTS_TXFRAMEEND field.
	NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Pos = 0x0
	// Bit mask of EVENTS_TXFRAMEEND field.
	NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Msk = 0x1
	// Bit EVENTS_TXFRAMEEND.
	NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND = 0x1
	// Event not generated
	NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Generated = 0x1

	// EVENTS_RXFRAMESTART: Marks the end of the first symbol of a received frame
	// Position of EVENTS_RXFRAMESTART field.
	NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Pos = 0x0
	// Bit mask of EVENTS_RXFRAMESTART field.
	NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Msk = 0x1
	// Bit EVENTS_RXFRAMESTART.
	NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART = 0x1
	// Event not generated
	NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Generated = 0x1

	// EVENTS_RXFRAMEEND: Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
	// Position of EVENTS_RXFRAMEEND field.
	NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Pos = 0x0
	// Bit mask of EVENTS_RXFRAMEEND field.
	NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Msk = 0x1
	// Bit EVENTS_RXFRAMEEND.
	NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND = 0x1
	// Event not generated
	NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Generated = 0x1

	// EVENTS_ERROR: NFC error reported. The ERRORSTATUS register contains details on the source of the error.
	// Position of EVENTS_ERROR field.
	NFCT_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	NFCT_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	NFCT_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	NFCT_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_RXERROR: NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
	// Position of EVENTS_RXERROR field.
	NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Pos = 0x0
	// Bit mask of EVENTS_RXERROR field.
	NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Msk = 0x1
	// Bit EVENTS_RXERROR.
	NFCT_EVENTS_RXERROR_EVENTS_RXERROR = 0x1
	// Event not generated
	NFCT_EVENTS_RXERROR_EVENTS_RXERROR_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Generated = 0x1

	// EVENTS_ENDRX: RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
	// Position of EVENTS_ENDRX field.
	NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	NFCT_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	NFCT_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_ENDTX: Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
	// Position of EVENTS_ENDTX field.
	NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Pos = 0x0
	// Bit mask of EVENTS_ENDTX field.
	NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Msk = 0x1
	// Bit EVENTS_ENDTX.
	NFCT_EVENTS_ENDTX_EVENTS_ENDTX = 0x1
	// Event not generated
	NFCT_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Generated = 0x1

	// EVENTS_AUTOCOLRESSTARTED: Auto collision resolution process has started
	// Position of EVENTS_AUTOCOLRESSTARTED field.
	NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Pos = 0x0
	// Bit mask of EVENTS_AUTOCOLRESSTARTED field.
	NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Msk = 0x1
	// Bit EVENTS_AUTOCOLRESSTARTED.
	NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED = 0x1
	// Event not generated
	NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Generated = 0x1

	// EVENTS_COLLISION: NFC auto collision resolution error reported.
	// Position of EVENTS_COLLISION field.
	NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Pos = 0x0
	// Bit mask of EVENTS_COLLISION field.
	NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Msk = 0x1
	// Bit EVENTS_COLLISION.
	NFCT_EVENTS_COLLISION_EVENTS_COLLISION = 0x1
	// Event not generated
	NFCT_EVENTS_COLLISION_EVENTS_COLLISION_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Generated = 0x1

	// EVENTS_SELECTED: NFC auto collision resolution successfully completed
	// Position of EVENTS_SELECTED field.
	NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Pos = 0x0
	// Bit mask of EVENTS_SELECTED field.
	NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Msk = 0x1
	// Bit EVENTS_SELECTED.
	NFCT_EVENTS_SELECTED_EVENTS_SELECTED = 0x1
	// Event not generated
	NFCT_EVENTS_SELECTED_EVENTS_SELECTED_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Generated = 0x1

	// EVENTS_STARTED: EasyDMA is ready to receive or send frames.
	// Position of EVENTS_STARTED field.
	NFCT_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	NFCT_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	NFCT_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	NFCT_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	NFCT_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// PUBLISH_READY: Publish configuration for event READY
	// Position of CHIDX field.
	NFCT_PUBLISH_READY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_READY_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_READY_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_READY_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_READY_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_READY_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_READY_EN_Enabled = 0x1

	// PUBLISH_FIELDDETECTED: Publish configuration for event FIELDDETECTED
	// Position of CHIDX field.
	NFCT_PUBLISH_FIELDDETECTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_FIELDDETECTED_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_FIELDDETECTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_FIELDDETECTED_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_FIELDDETECTED_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_FIELDDETECTED_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_FIELDDETECTED_EN_Enabled = 0x1

	// PUBLISH_FIELDLOST: Publish configuration for event FIELDLOST
	// Position of CHIDX field.
	NFCT_PUBLISH_FIELDLOST_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_FIELDLOST_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_FIELDLOST_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_FIELDLOST_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_FIELDLOST_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_FIELDLOST_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_FIELDLOST_EN_Enabled = 0x1

	// PUBLISH_TXFRAMESTART: Publish configuration for event TXFRAMESTART
	// Position of CHIDX field.
	NFCT_PUBLISH_TXFRAMESTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_TXFRAMESTART_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_TXFRAMESTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_TXFRAMESTART_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_TXFRAMESTART_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_TXFRAMESTART_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_TXFRAMESTART_EN_Enabled = 0x1

	// PUBLISH_TXFRAMEEND: Publish configuration for event TXFRAMEEND
	// Position of CHIDX field.
	NFCT_PUBLISH_TXFRAMEEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_TXFRAMEEND_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_TXFRAMEEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_TXFRAMEEND_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_TXFRAMEEND_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_TXFRAMEEND_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_TXFRAMEEND_EN_Enabled = 0x1

	// PUBLISH_RXFRAMESTART: Publish configuration for event RXFRAMESTART
	// Position of CHIDX field.
	NFCT_PUBLISH_RXFRAMESTART_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_RXFRAMESTART_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_RXFRAMESTART_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_RXFRAMESTART_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_RXFRAMESTART_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_RXFRAMESTART_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_RXFRAMESTART_EN_Enabled = 0x1

	// PUBLISH_RXFRAMEEND: Publish configuration for event RXFRAMEEND
	// Position of CHIDX field.
	NFCT_PUBLISH_RXFRAMEEND_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_RXFRAMEEND_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_RXFRAMEEND_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_RXFRAMEEND_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_RXFRAMEEND_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_RXFRAMEEND_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_RXFRAMEEND_EN_Enabled = 0x1

	// PUBLISH_ERROR: Publish configuration for event ERROR
	// Position of CHIDX field.
	NFCT_PUBLISH_ERROR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_ERROR_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_ERROR_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_ERROR_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_ERROR_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_ERROR_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_ERROR_EN_Enabled = 0x1

	// PUBLISH_RXERROR: Publish configuration for event RXERROR
	// Position of CHIDX field.
	NFCT_PUBLISH_RXERROR_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_RXERROR_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_RXERROR_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_RXERROR_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_RXERROR_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_RXERROR_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_RXERROR_EN_Enabled = 0x1

	// PUBLISH_ENDRX: Publish configuration for event ENDRX
	// Position of CHIDX field.
	NFCT_PUBLISH_ENDRX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_ENDRX_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_ENDRX_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_ENDRX_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_ENDRX_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_ENDRX_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_ENDRX_EN_Enabled = 0x1

	// PUBLISH_ENDTX: Publish configuration for event ENDTX
	// Position of CHIDX field.
	NFCT_PUBLISH_ENDTX_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_ENDTX_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_ENDTX_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_ENDTX_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_ENDTX_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_ENDTX_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_ENDTX_EN_Enabled = 0x1

	// PUBLISH_AUTOCOLRESSTARTED: Publish configuration for event AUTOCOLRESSTARTED
	// Position of CHIDX field.
	NFCT_PUBLISH_AUTOCOLRESSTARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_AUTOCOLRESSTARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_AUTOCOLRESSTARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_AUTOCOLRESSTARTED_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_AUTOCOLRESSTARTED_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_AUTOCOLRESSTARTED_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_AUTOCOLRESSTARTED_EN_Enabled = 0x1

	// PUBLISH_COLLISION: Publish configuration for event COLLISION
	// Position of CHIDX field.
	NFCT_PUBLISH_COLLISION_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_COLLISION_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_COLLISION_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_COLLISION_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_COLLISION_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_COLLISION_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_COLLISION_EN_Enabled = 0x1

	// PUBLISH_SELECTED: Publish configuration for event SELECTED
	// Position of CHIDX field.
	NFCT_PUBLISH_SELECTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_SELECTED_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_SELECTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_SELECTED_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_SELECTED_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_SELECTED_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_SELECTED_EN_Enabled = 0x1

	// PUBLISH_STARTED: Publish configuration for event STARTED
	// Position of CHIDX field.
	NFCT_PUBLISH_STARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	NFCT_PUBLISH_STARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	NFCT_PUBLISH_STARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	NFCT_PUBLISH_STARTED_EN_Msk = 0x80000000
	// Bit EN.
	NFCT_PUBLISH_STARTED_EN = 0x80000000
	// Disable publishing
	NFCT_PUBLISH_STARTED_EN_Disabled = 0x0
	// Enable publishing
	NFCT_PUBLISH_STARTED_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of FIELDDETECTED_ACTIVATE field.
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos = 0x0
	// Bit mask of FIELDDETECTED_ACTIVATE field.
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk = 0x1
	// Bit FIELDDETECTED_ACTIVATE.
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE = 0x1
	// Disable shortcut
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Disabled = 0x0
	// Enable shortcut
	NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Enabled = 0x1
	// Position of FIELDLOST_SENSE field.
	NFCT_SHORTS_FIELDLOST_SENSE_Pos = 0x1
	// Bit mask of FIELDLOST_SENSE field.
	NFCT_SHORTS_FIELDLOST_SENSE_Msk = 0x2
	// Bit FIELDLOST_SENSE.
	NFCT_SHORTS_FIELDLOST_SENSE = 0x2
	// Disable shortcut
	NFCT_SHORTS_FIELDLOST_SENSE_Disabled = 0x0
	// Enable shortcut
	NFCT_SHORTS_FIELDLOST_SENSE_Enabled = 0x1
	// Position of TXFRAMEEND_ENABLERXDATA field.
	NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Pos = 0x5
	// Bit mask of TXFRAMEEND_ENABLERXDATA field.
	NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Msk = 0x20
	// Bit TXFRAMEEND_ENABLERXDATA.
	NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA = 0x20
	// Disable shortcut
	NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Disabled = 0x0
	// Enable shortcut
	NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of READY field.
	NFCT_INTEN_READY_Pos = 0x0
	// Bit mask of READY field.
	NFCT_INTEN_READY_Msk = 0x1
	// Bit READY.
	NFCT_INTEN_READY = 0x1
	// Disable
	NFCT_INTEN_READY_Disabled = 0x0
	// Enable
	NFCT_INTEN_READY_Enabled = 0x1
	// Position of FIELDDETECTED field.
	NFCT_INTEN_FIELDDETECTED_Pos = 0x1
	// Bit mask of FIELDDETECTED field.
	NFCT_INTEN_FIELDDETECTED_Msk = 0x2
	// Bit FIELDDETECTED.
	NFCT_INTEN_FIELDDETECTED = 0x2
	// Disable
	NFCT_INTEN_FIELDDETECTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_FIELDDETECTED_Enabled = 0x1
	// Position of FIELDLOST field.
	NFCT_INTEN_FIELDLOST_Pos = 0x2
	// Bit mask of FIELDLOST field.
	NFCT_INTEN_FIELDLOST_Msk = 0x4
	// Bit FIELDLOST.
	NFCT_INTEN_FIELDLOST = 0x4
	// Disable
	NFCT_INTEN_FIELDLOST_Disabled = 0x0
	// Enable
	NFCT_INTEN_FIELDLOST_Enabled = 0x1
	// Position of TXFRAMESTART field.
	NFCT_INTEN_TXFRAMESTART_Pos = 0x3
	// Bit mask of TXFRAMESTART field.
	NFCT_INTEN_TXFRAMESTART_Msk = 0x8
	// Bit TXFRAMESTART.
	NFCT_INTEN_TXFRAMESTART = 0x8
	// Disable
	NFCT_INTEN_TXFRAMESTART_Disabled = 0x0
	// Enable
	NFCT_INTEN_TXFRAMESTART_Enabled = 0x1
	// Position of TXFRAMEEND field.
	NFCT_INTEN_TXFRAMEEND_Pos = 0x4
	// Bit mask of TXFRAMEEND field.
	NFCT_INTEN_TXFRAMEEND_Msk = 0x10
	// Bit TXFRAMEEND.
	NFCT_INTEN_TXFRAMEEND = 0x10
	// Disable
	NFCT_INTEN_TXFRAMEEND_Disabled = 0x0
	// Enable
	NFCT_INTEN_TXFRAMEEND_Enabled = 0x1
	// Position of RXFRAMESTART field.
	NFCT_INTEN_RXFRAMESTART_Pos = 0x5
	// Bit mask of RXFRAMESTART field.
	NFCT_INTEN_RXFRAMESTART_Msk = 0x20
	// Bit RXFRAMESTART.
	NFCT_INTEN_RXFRAMESTART = 0x20
	// Disable
	NFCT_INTEN_RXFRAMESTART_Disabled = 0x0
	// Enable
	NFCT_INTEN_RXFRAMESTART_Enabled = 0x1
	// Position of RXFRAMEEND field.
	NFCT_INTEN_RXFRAMEEND_Pos = 0x6
	// Bit mask of RXFRAMEEND field.
	NFCT_INTEN_RXFRAMEEND_Msk = 0x40
	// Bit RXFRAMEEND.
	NFCT_INTEN_RXFRAMEEND = 0x40
	// Disable
	NFCT_INTEN_RXFRAMEEND_Disabled = 0x0
	// Enable
	NFCT_INTEN_RXFRAMEEND_Enabled = 0x1
	// Position of ERROR field.
	NFCT_INTEN_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	NFCT_INTEN_ERROR_Msk = 0x80
	// Bit ERROR.
	NFCT_INTEN_ERROR = 0x80
	// Disable
	NFCT_INTEN_ERROR_Disabled = 0x0
	// Enable
	NFCT_INTEN_ERROR_Enabled = 0x1
	// Position of RXERROR field.
	NFCT_INTEN_RXERROR_Pos = 0xa
	// Bit mask of RXERROR field.
	NFCT_INTEN_RXERROR_Msk = 0x400
	// Bit RXERROR.
	NFCT_INTEN_RXERROR = 0x400
	// Disable
	NFCT_INTEN_RXERROR_Disabled = 0x0
	// Enable
	NFCT_INTEN_RXERROR_Enabled = 0x1
	// Position of ENDRX field.
	NFCT_INTEN_ENDRX_Pos = 0xb
	// Bit mask of ENDRX field.
	NFCT_INTEN_ENDRX_Msk = 0x800
	// Bit ENDRX.
	NFCT_INTEN_ENDRX = 0x800
	// Disable
	NFCT_INTEN_ENDRX_Disabled = 0x0
	// Enable
	NFCT_INTEN_ENDRX_Enabled = 0x1
	// Position of ENDTX field.
	NFCT_INTEN_ENDTX_Pos = 0xc
	// Bit mask of ENDTX field.
	NFCT_INTEN_ENDTX_Msk = 0x1000
	// Bit ENDTX.
	NFCT_INTEN_ENDTX = 0x1000
	// Disable
	NFCT_INTEN_ENDTX_Disabled = 0x0
	// Enable
	NFCT_INTEN_ENDTX_Enabled = 0x1
	// Position of AUTOCOLRESSTARTED field.
	NFCT_INTEN_AUTOCOLRESSTARTED_Pos = 0xe
	// Bit mask of AUTOCOLRESSTARTED field.
	NFCT_INTEN_AUTOCOLRESSTARTED_Msk = 0x4000
	// Bit AUTOCOLRESSTARTED.
	NFCT_INTEN_AUTOCOLRESSTARTED = 0x4000
	// Disable
	NFCT_INTEN_AUTOCOLRESSTARTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_AUTOCOLRESSTARTED_Enabled = 0x1
	// Position of COLLISION field.
	NFCT_INTEN_COLLISION_Pos = 0x12
	// Bit mask of COLLISION field.
	NFCT_INTEN_COLLISION_Msk = 0x40000
	// Bit COLLISION.
	NFCT_INTEN_COLLISION = 0x40000
	// Disable
	NFCT_INTEN_COLLISION_Disabled = 0x0
	// Enable
	NFCT_INTEN_COLLISION_Enabled = 0x1
	// Position of SELECTED field.
	NFCT_INTEN_SELECTED_Pos = 0x13
	// Bit mask of SELECTED field.
	NFCT_INTEN_SELECTED_Msk = 0x80000
	// Bit SELECTED.
	NFCT_INTEN_SELECTED = 0x80000
	// Disable
	NFCT_INTEN_SELECTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_SELECTED_Enabled = 0x1
	// Position of STARTED field.
	NFCT_INTEN_STARTED_Pos = 0x14
	// Bit mask of STARTED field.
	NFCT_INTEN_STARTED_Msk = 0x100000
	// Bit STARTED.
	NFCT_INTEN_STARTED = 0x100000
	// Disable
	NFCT_INTEN_STARTED_Disabled = 0x0
	// Enable
	NFCT_INTEN_STARTED_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	NFCT_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	NFCT_INTENSET_READY_Msk = 0x1
	// Bit READY.
	NFCT_INTENSET_READY = 0x1
	// Read: Disabled
	NFCT_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_READY_Enabled = 0x1
	// Enable
	NFCT_INTENSET_READY_Set = 0x1
	// Position of FIELDDETECTED field.
	NFCT_INTENSET_FIELDDETECTED_Pos = 0x1
	// Bit mask of FIELDDETECTED field.
	NFCT_INTENSET_FIELDDETECTED_Msk = 0x2
	// Bit FIELDDETECTED.
	NFCT_INTENSET_FIELDDETECTED = 0x2
	// Read: Disabled
	NFCT_INTENSET_FIELDDETECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_FIELDDETECTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_FIELDDETECTED_Set = 0x1
	// Position of FIELDLOST field.
	NFCT_INTENSET_FIELDLOST_Pos = 0x2
	// Bit mask of FIELDLOST field.
	NFCT_INTENSET_FIELDLOST_Msk = 0x4
	// Bit FIELDLOST.
	NFCT_INTENSET_FIELDLOST = 0x4
	// Read: Disabled
	NFCT_INTENSET_FIELDLOST_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_FIELDLOST_Enabled = 0x1
	// Enable
	NFCT_INTENSET_FIELDLOST_Set = 0x1
	// Position of TXFRAMESTART field.
	NFCT_INTENSET_TXFRAMESTART_Pos = 0x3
	// Bit mask of TXFRAMESTART field.
	NFCT_INTENSET_TXFRAMESTART_Msk = 0x8
	// Bit TXFRAMESTART.
	NFCT_INTENSET_TXFRAMESTART = 0x8
	// Read: Disabled
	NFCT_INTENSET_TXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_TXFRAMESTART_Enabled = 0x1
	// Enable
	NFCT_INTENSET_TXFRAMESTART_Set = 0x1
	// Position of TXFRAMEEND field.
	NFCT_INTENSET_TXFRAMEEND_Pos = 0x4
	// Bit mask of TXFRAMEEND field.
	NFCT_INTENSET_TXFRAMEEND_Msk = 0x10
	// Bit TXFRAMEEND.
	NFCT_INTENSET_TXFRAMEEND = 0x10
	// Read: Disabled
	NFCT_INTENSET_TXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_TXFRAMEEND_Enabled = 0x1
	// Enable
	NFCT_INTENSET_TXFRAMEEND_Set = 0x1
	// Position of RXFRAMESTART field.
	NFCT_INTENSET_RXFRAMESTART_Pos = 0x5
	// Bit mask of RXFRAMESTART field.
	NFCT_INTENSET_RXFRAMESTART_Msk = 0x20
	// Bit RXFRAMESTART.
	NFCT_INTENSET_RXFRAMESTART = 0x20
	// Read: Disabled
	NFCT_INTENSET_RXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_RXFRAMESTART_Enabled = 0x1
	// Enable
	NFCT_INTENSET_RXFRAMESTART_Set = 0x1
	// Position of RXFRAMEEND field.
	NFCT_INTENSET_RXFRAMEEND_Pos = 0x6
	// Bit mask of RXFRAMEEND field.
	NFCT_INTENSET_RXFRAMEEND_Msk = 0x40
	// Bit RXFRAMEEND.
	NFCT_INTENSET_RXFRAMEEND = 0x40
	// Read: Disabled
	NFCT_INTENSET_RXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_RXFRAMEEND_Enabled = 0x1
	// Enable
	NFCT_INTENSET_RXFRAMEEND_Set = 0x1
	// Position of ERROR field.
	NFCT_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	NFCT_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	NFCT_INTENSET_ERROR = 0x80
	// Read: Disabled
	NFCT_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_ERROR_Enabled = 0x1
	// Enable
	NFCT_INTENSET_ERROR_Set = 0x1
	// Position of RXERROR field.
	NFCT_INTENSET_RXERROR_Pos = 0xa
	// Bit mask of RXERROR field.
	NFCT_INTENSET_RXERROR_Msk = 0x400
	// Bit RXERROR.
	NFCT_INTENSET_RXERROR = 0x400
	// Read: Disabled
	NFCT_INTENSET_RXERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_RXERROR_Enabled = 0x1
	// Enable
	NFCT_INTENSET_RXERROR_Set = 0x1
	// Position of ENDRX field.
	NFCT_INTENSET_ENDRX_Pos = 0xb
	// Bit mask of ENDRX field.
	NFCT_INTENSET_ENDRX_Msk = 0x800
	// Bit ENDRX.
	NFCT_INTENSET_ENDRX = 0x800
	// Read: Disabled
	NFCT_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	NFCT_INTENSET_ENDRX_Set = 0x1
	// Position of ENDTX field.
	NFCT_INTENSET_ENDTX_Pos = 0xc
	// Bit mask of ENDTX field.
	NFCT_INTENSET_ENDTX_Msk = 0x1000
	// Bit ENDTX.
	NFCT_INTENSET_ENDTX = 0x1000
	// Read: Disabled
	NFCT_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	NFCT_INTENSET_ENDTX_Set = 0x1
	// Position of AUTOCOLRESSTARTED field.
	NFCT_INTENSET_AUTOCOLRESSTARTED_Pos = 0xe
	// Bit mask of AUTOCOLRESSTARTED field.
	NFCT_INTENSET_AUTOCOLRESSTARTED_Msk = 0x4000
	// Bit AUTOCOLRESSTARTED.
	NFCT_INTENSET_AUTOCOLRESSTARTED = 0x4000
	// Read: Disabled
	NFCT_INTENSET_AUTOCOLRESSTARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_AUTOCOLRESSTARTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_AUTOCOLRESSTARTED_Set = 0x1
	// Position of COLLISION field.
	NFCT_INTENSET_COLLISION_Pos = 0x12
	// Bit mask of COLLISION field.
	NFCT_INTENSET_COLLISION_Msk = 0x40000
	// Bit COLLISION.
	NFCT_INTENSET_COLLISION = 0x40000
	// Read: Disabled
	NFCT_INTENSET_COLLISION_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_COLLISION_Enabled = 0x1
	// Enable
	NFCT_INTENSET_COLLISION_Set = 0x1
	// Position of SELECTED field.
	NFCT_INTENSET_SELECTED_Pos = 0x13
	// Bit mask of SELECTED field.
	NFCT_INTENSET_SELECTED_Msk = 0x80000
	// Bit SELECTED.
	NFCT_INTENSET_SELECTED = 0x80000
	// Read: Disabled
	NFCT_INTENSET_SELECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_SELECTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_SELECTED_Set = 0x1
	// Position of STARTED field.
	NFCT_INTENSET_STARTED_Pos = 0x14
	// Bit mask of STARTED field.
	NFCT_INTENSET_STARTED_Msk = 0x100000
	// Bit STARTED.
	NFCT_INTENSET_STARTED = 0x100000
	// Read: Disabled
	NFCT_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENSET_STARTED_Enabled = 0x1
	// Enable
	NFCT_INTENSET_STARTED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	NFCT_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	NFCT_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	NFCT_INTENCLR_READY = 0x1
	// Read: Disabled
	NFCT_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_READY_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_READY_Clear = 0x1
	// Position of FIELDDETECTED field.
	NFCT_INTENCLR_FIELDDETECTED_Pos = 0x1
	// Bit mask of FIELDDETECTED field.
	NFCT_INTENCLR_FIELDDETECTED_Msk = 0x2
	// Bit FIELDDETECTED.
	NFCT_INTENCLR_FIELDDETECTED = 0x2
	// Read: Disabled
	NFCT_INTENCLR_FIELDDETECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_FIELDDETECTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_FIELDDETECTED_Clear = 0x1
	// Position of FIELDLOST field.
	NFCT_INTENCLR_FIELDLOST_Pos = 0x2
	// Bit mask of FIELDLOST field.
	NFCT_INTENCLR_FIELDLOST_Msk = 0x4
	// Bit FIELDLOST.
	NFCT_INTENCLR_FIELDLOST = 0x4
	// Read: Disabled
	NFCT_INTENCLR_FIELDLOST_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_FIELDLOST_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_FIELDLOST_Clear = 0x1
	// Position of TXFRAMESTART field.
	NFCT_INTENCLR_TXFRAMESTART_Pos = 0x3
	// Bit mask of TXFRAMESTART field.
	NFCT_INTENCLR_TXFRAMESTART_Msk = 0x8
	// Bit TXFRAMESTART.
	NFCT_INTENCLR_TXFRAMESTART = 0x8
	// Read: Disabled
	NFCT_INTENCLR_TXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_TXFRAMESTART_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_TXFRAMESTART_Clear = 0x1
	// Position of TXFRAMEEND field.
	NFCT_INTENCLR_TXFRAMEEND_Pos = 0x4
	// Bit mask of TXFRAMEEND field.
	NFCT_INTENCLR_TXFRAMEEND_Msk = 0x10
	// Bit TXFRAMEEND.
	NFCT_INTENCLR_TXFRAMEEND = 0x10
	// Read: Disabled
	NFCT_INTENCLR_TXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_TXFRAMEEND_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_TXFRAMEEND_Clear = 0x1
	// Position of RXFRAMESTART field.
	NFCT_INTENCLR_RXFRAMESTART_Pos = 0x5
	// Bit mask of RXFRAMESTART field.
	NFCT_INTENCLR_RXFRAMESTART_Msk = 0x20
	// Bit RXFRAMESTART.
	NFCT_INTENCLR_RXFRAMESTART = 0x20
	// Read: Disabled
	NFCT_INTENCLR_RXFRAMESTART_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_RXFRAMESTART_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_RXFRAMESTART_Clear = 0x1
	// Position of RXFRAMEEND field.
	NFCT_INTENCLR_RXFRAMEEND_Pos = 0x6
	// Bit mask of RXFRAMEEND field.
	NFCT_INTENCLR_RXFRAMEEND_Msk = 0x40
	// Bit RXFRAMEEND.
	NFCT_INTENCLR_RXFRAMEEND = 0x40
	// Read: Disabled
	NFCT_INTENCLR_RXFRAMEEND_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_RXFRAMEEND_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_RXFRAMEEND_Clear = 0x1
	// Position of ERROR field.
	NFCT_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	NFCT_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	NFCT_INTENCLR_ERROR = 0x80
	// Read: Disabled
	NFCT_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_ERROR_Clear = 0x1
	// Position of RXERROR field.
	NFCT_INTENCLR_RXERROR_Pos = 0xa
	// Bit mask of RXERROR field.
	NFCT_INTENCLR_RXERROR_Msk = 0x400
	// Bit RXERROR.
	NFCT_INTENCLR_RXERROR = 0x400
	// Read: Disabled
	NFCT_INTENCLR_RXERROR_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_RXERROR_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_RXERROR_Clear = 0x1
	// Position of ENDRX field.
	NFCT_INTENCLR_ENDRX_Pos = 0xb
	// Bit mask of ENDRX field.
	NFCT_INTENCLR_ENDRX_Msk = 0x800
	// Bit ENDRX.
	NFCT_INTENCLR_ENDRX = 0x800
	// Read: Disabled
	NFCT_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_ENDRX_Clear = 0x1
	// Position of ENDTX field.
	NFCT_INTENCLR_ENDTX_Pos = 0xc
	// Bit mask of ENDTX field.
	NFCT_INTENCLR_ENDTX_Msk = 0x1000
	// Bit ENDTX.
	NFCT_INTENCLR_ENDTX = 0x1000
	// Read: Disabled
	NFCT_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_ENDTX_Clear = 0x1
	// Position of AUTOCOLRESSTARTED field.
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos = 0xe
	// Bit mask of AUTOCOLRESSTARTED field.
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Msk = 0x4000
	// Bit AUTOCOLRESSTARTED.
	NFCT_INTENCLR_AUTOCOLRESSTARTED = 0x4000
	// Read: Disabled
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_AUTOCOLRESSTARTED_Clear = 0x1
	// Position of COLLISION field.
	NFCT_INTENCLR_COLLISION_Pos = 0x12
	// Bit mask of COLLISION field.
	NFCT_INTENCLR_COLLISION_Msk = 0x40000
	// Bit COLLISION.
	NFCT_INTENCLR_COLLISION = 0x40000
	// Read: Disabled
	NFCT_INTENCLR_COLLISION_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_COLLISION_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_COLLISION_Clear = 0x1
	// Position of SELECTED field.
	NFCT_INTENCLR_SELECTED_Pos = 0x13
	// Bit mask of SELECTED field.
	NFCT_INTENCLR_SELECTED_Msk = 0x80000
	// Bit SELECTED.
	NFCT_INTENCLR_SELECTED = 0x80000
	// Read: Disabled
	NFCT_INTENCLR_SELECTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_SELECTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_SELECTED_Clear = 0x1
	// Position of STARTED field.
	NFCT_INTENCLR_STARTED_Pos = 0x14
	// Bit mask of STARTED field.
	NFCT_INTENCLR_STARTED_Msk = 0x100000
	// Bit STARTED.
	NFCT_INTENCLR_STARTED = 0x100000
	// Read: Disabled
	NFCT_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	NFCT_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	NFCT_INTENCLR_STARTED_Clear = 0x1

	// ERRORSTATUS: NFC Error Status register
	// Position of FRAMEDELAYTIMEOUT field.
	NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos = 0x0
	// Bit mask of FRAMEDELAYTIMEOUT field.
	NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk = 0x1
	// Bit FRAMEDELAYTIMEOUT.
	NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT = 0x1

	// FRAMESTATUS.RX: Result of last incoming frame
	// Position of CRCERROR field.
	NFCT_FRAMESTATUS_RX_CRCERROR_Pos = 0x0
	// Bit mask of CRCERROR field.
	NFCT_FRAMESTATUS_RX_CRCERROR_Msk = 0x1
	// Bit CRCERROR.
	NFCT_FRAMESTATUS_RX_CRCERROR = 0x1
	// Valid CRC detected
	NFCT_FRAMESTATUS_RX_CRCERROR_CRCCorrect = 0x0
	// CRC received does not match local check
	NFCT_FRAMESTATUS_RX_CRCERROR_CRCError = 0x1
	// Position of PARITYSTATUS field.
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos = 0x2
	// Bit mask of PARITYSTATUS field.
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk = 0x4
	// Bit PARITYSTATUS.
	NFCT_FRAMESTATUS_RX_PARITYSTATUS = 0x4
	// Frame received with parity OK
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityOK = 0x0
	// Frame received with parity error
	NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityError = 0x1
	// Position of OVERRUN field.
	NFCT_FRAMESTATUS_RX_OVERRUN_Pos = 0x3
	// Bit mask of OVERRUN field.
	NFCT_FRAMESTATUS_RX_OVERRUN_Msk = 0x8
	// Bit OVERRUN.
	NFCT_FRAMESTATUS_RX_OVERRUN = 0x8
	// No overrun detected
	NFCT_FRAMESTATUS_RX_OVERRUN_NoOverrun = 0x0
	// Overrun error
	NFCT_FRAMESTATUS_RX_OVERRUN_Overrun = 0x1

	// NFCTAGSTATE: NfcTag state register
	// Position of NFCTAGSTATE field.
	NFCT_NFCTAGSTATE_NFCTAGSTATE_Pos = 0x0
	// Bit mask of NFCTAGSTATE field.
	NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk = 0x7
	// Disabled or sense
	NFCT_NFCTAGSTATE_NFCTAGSTATE_Disabled = 0x0
	// RampUp
	NFCT_NFCTAGSTATE_NFCTAGSTATE_RampUp = 0x2
	// Idle
	NFCT_NFCTAGSTATE_NFCTAGSTATE_Idle = 0x3
	// Receive
	NFCT_NFCTAGSTATE_NFCTAGSTATE_Receive = 0x4
	// FrameDelay
	NFCT_NFCTAGSTATE_NFCTAGSTATE_FrameDelay = 0x5
	// Transmit
	NFCT_NFCTAGSTATE_NFCTAGSTATE_Transmit = 0x6

	// SLEEPSTATE: Sleep state during automatic collision resolution
	// Position of SLEEPSTATE field.
	NFCT_SLEEPSTATE_SLEEPSTATE_Pos = 0x0
	// Bit mask of SLEEPSTATE field.
	NFCT_SLEEPSTATE_SLEEPSTATE_Msk = 0x1
	// Bit SLEEPSTATE.
	NFCT_SLEEPSTATE_SLEEPSTATE = 0x1
	// State is IDLE.
	NFCT_SLEEPSTATE_SLEEPSTATE_Idle = 0x0
	// State is SLEEP_A.
	NFCT_SLEEPSTATE_SLEEPSTATE_SleepA = 0x1

	// FIELDPRESENT: Indicates the presence or not of a valid field
	// Position of FIELDPRESENT field.
	NFCT_FIELDPRESENT_FIELDPRESENT_Pos = 0x0
	// Bit mask of FIELDPRESENT field.
	NFCT_FIELDPRESENT_FIELDPRESENT_Msk = 0x1
	// Bit FIELDPRESENT.
	NFCT_FIELDPRESENT_FIELDPRESENT = 0x1
	// No valid field detected
	NFCT_FIELDPRESENT_FIELDPRESENT_NoField = 0x0
	// Valid field detected
	NFCT_FIELDPRESENT_FIELDPRESENT_FieldPresent = 0x1
	// Position of LOCKDETECT field.
	NFCT_FIELDPRESENT_LOCKDETECT_Pos = 0x1
	// Bit mask of LOCKDETECT field.
	NFCT_FIELDPRESENT_LOCKDETECT_Msk = 0x2
	// Bit LOCKDETECT.
	NFCT_FIELDPRESENT_LOCKDETECT = 0x2
	// Not locked to field
	NFCT_FIELDPRESENT_LOCKDETECT_NotLocked = 0x0
	// Locked to field
	NFCT_FIELDPRESENT_LOCKDETECT_Locked = 0x1

	// FRAMEDELAYMIN: Minimum frame delay
	// Position of FRAMEDELAYMIN field.
	NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos = 0x0
	// Bit mask of FRAMEDELAYMIN field.
	NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk = 0xffff

	// FRAMEDELAYMAX: Maximum frame delay
	// Position of FRAMEDELAYMAX field.
	NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos = 0x0
	// Bit mask of FRAMEDELAYMAX field.
	NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk = 0xfffff

	// FRAMEDELAYMODE: Configuration register for the Frame Delay Timer
	// Position of FRAMEDELAYMODE field.
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos = 0x0
	// Bit mask of FRAMEDELAYMODE field.
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk = 0x3
	// Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout.
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun = 0x0
	// Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window = 0x1
	// Frame is transmitted exactly at FRAMEDELAYMAX
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal = 0x2
	// Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX
	NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid = 0x3

	// PACKETPTR: Packet pointer for TXD and RXD data storage in Data RAM
	// Position of PTR field.
	NFCT_PACKETPTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	NFCT_PACKETPTR_PTR_Msk = 0xffffffff

	// MAXLEN: Size of the RAM buffer allocated to TXD and RXD data storage each
	// Position of MAXLEN field.
	NFCT_MAXLEN_MAXLEN_Pos = 0x0
	// Bit mask of MAXLEN field.
	NFCT_MAXLEN_MAXLEN_Msk = 0x1ff

	// TXD.FRAMECONFIG: Configuration of outgoing frames
	// Position of PARITY field.
	NFCT_TXD_FRAMECONFIG_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	NFCT_TXD_FRAMECONFIG_PARITY_Msk = 0x1
	// Bit PARITY.
	NFCT_TXD_FRAMECONFIG_PARITY = 0x1
	// Parity is not added to TX frames
	NFCT_TXD_FRAMECONFIG_PARITY_NoParity = 0x0
	// Parity is added to TX frames
	NFCT_TXD_FRAMECONFIG_PARITY_Parity = 0x1
	// Position of DISCARDMODE field.
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos = 0x1
	// Bit mask of DISCARDMODE field.
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk = 0x2
	// Bit DISCARDMODE.
	NFCT_TXD_FRAMECONFIG_DISCARDMODE = 0x2
	// Unused bits are discarded at end of frame (EoF)
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardEnd = 0x0
	// Unused bits are discarded at start of frame (SoF)
	NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardStart = 0x1
	// Position of SOF field.
	NFCT_TXD_FRAMECONFIG_SOF_Pos = 0x2
	// Bit mask of SOF field.
	NFCT_TXD_FRAMECONFIG_SOF_Msk = 0x4
	// Bit SOF.
	NFCT_TXD_FRAMECONFIG_SOF = 0x4
	// SoF symbol not added
	NFCT_TXD_FRAMECONFIG_SOF_NoSoF = 0x0
	// SoF symbol added
	NFCT_TXD_FRAMECONFIG_SOF_SoF = 0x1
	// Position of CRCMODETX field.
	NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos = 0x4
	// Bit mask of CRCMODETX field.
	NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk = 0x10
	// Bit CRCMODETX.
	NFCT_TXD_FRAMECONFIG_CRCMODETX = 0x10
	// CRC is not added to the frame
	NFCT_TXD_FRAMECONFIG_CRCMODETX_NoCRCTX = 0x0
	// 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame
	NFCT_TXD_FRAMECONFIG_CRCMODETX_CRC16TX = 0x1

	// TXD.AMOUNT: Size of outgoing frame
	// Position of TXDATABITS field.
	NFCT_TXD_AMOUNT_TXDATABITS_Pos = 0x0
	// Bit mask of TXDATABITS field.
	NFCT_TXD_AMOUNT_TXDATABITS_Msk = 0x7
	// Position of TXDATABYTES field.
	NFCT_TXD_AMOUNT_TXDATABYTES_Pos = 0x3
	// Bit mask of TXDATABYTES field.
	NFCT_TXD_AMOUNT_TXDATABYTES_Msk = 0xff8

	// RXD.FRAMECONFIG: Configuration of incoming frames
	// Position of PARITY field.
	NFCT_RXD_FRAMECONFIG_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	NFCT_RXD_FRAMECONFIG_PARITY_Msk = 0x1
	// Bit PARITY.
	NFCT_RXD_FRAMECONFIG_PARITY = 0x1
	// Parity is not expected in RX frames
	NFCT_RXD_FRAMECONFIG_PARITY_NoParity = 0x0
	// Parity is expected in RX frames
	NFCT_RXD_FRAMECONFIG_PARITY_Parity = 0x1
	// Position of SOF field.
	NFCT_RXD_FRAMECONFIG_SOF_Pos = 0x2
	// Bit mask of SOF field.
	NFCT_RXD_FRAMECONFIG_SOF_Msk = 0x4
	// Bit SOF.
	NFCT_RXD_FRAMECONFIG_SOF = 0x4
	// SoF symbol is not expected in RX frames
	NFCT_RXD_FRAMECONFIG_SOF_NoSoF = 0x0
	// SoF symbol is expected in RX frames
	NFCT_RXD_FRAMECONFIG_SOF_SoF = 0x1
	// Position of CRCMODERX field.
	NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos = 0x4
	// Bit mask of CRCMODERX field.
	NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk = 0x10
	// Bit CRCMODERX.
	NFCT_RXD_FRAMECONFIG_CRCMODERX = 0x10
	// CRC is not expected in RX frames
	NFCT_RXD_FRAMECONFIG_CRCMODERX_NoCRCRX = 0x0
	// Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated
	NFCT_RXD_FRAMECONFIG_CRCMODERX_CRC16RX = 0x1

	// RXD.AMOUNT: Size of last incoming frame
	// Position of RXDATABITS field.
	NFCT_RXD_AMOUNT_RXDATABITS_Pos = 0x0
	// Bit mask of RXDATABITS field.
	NFCT_RXD_AMOUNT_RXDATABITS_Msk = 0x7
	// Position of RXDATABYTES field.
	NFCT_RXD_AMOUNT_RXDATABYTES_Pos = 0x3
	// Bit mask of RXDATABYTES field.
	NFCT_RXD_AMOUNT_RXDATABYTES_Msk = 0xff8

	// MODULATIONCTRL: Enables the modulation output to a GPIO pin which can be connected to a second external antenna.
	// Position of MODULATIONCTRL field.
	NFCT_MODULATIONCTRL_MODULATIONCTRL_Pos = 0x0
	// Bit mask of MODULATIONCTRL field.
	NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk = 0x3
	// Invalid, defaults to same behaviour as for Internal
	NFCT_MODULATIONCTRL_MODULATIONCTRL_Invalid = 0x0
	// Use internal modulator only
	NFCT_MODULATIONCTRL_MODULATIONCTRL_Internal = 0x1
	// Output digital modulation signal to a GPIO pin.
	NFCT_MODULATIONCTRL_MODULATIONCTRL_ModToGpio = 0x2
	// Use internal modulator and output digital modulation signal to a GPIO pin.
	NFCT_MODULATIONCTRL_MODULATIONCTRL_InternalAndModToGpio = 0x3

	// MODULATIONPSEL: Pin select for Modulation control.
	// Position of PIN field.
	NFCT_MODULATIONPSEL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	NFCT_MODULATIONPSEL_PIN_Msk = 0x1f
	// Position of PORT field.
	NFCT_MODULATIONPSEL_PORT_Pos = 0x5
	// Bit mask of PORT field.
	NFCT_MODULATIONPSEL_PORT_Msk = 0x60
	// Position of CONNECT field.
	NFCT_MODULATIONPSEL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	NFCT_MODULATIONPSEL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	NFCT_MODULATIONPSEL_CONNECT = 0x80000000
	// Disconnect
	NFCT_MODULATIONPSEL_CONNECT_Disconnected = 0x1
	// Connect
	NFCT_MODULATIONPSEL_CONNECT_Connected = 0x0

	// NFCID1_LAST: Last NFCID1 part (4, 7 or 10 bytes ID)
	// Position of NFCID1_Z field.
	NFCT_NFCID1_LAST_NFCID1_Z_Pos = 0x0
	// Bit mask of NFCID1_Z field.
	NFCT_NFCID1_LAST_NFCID1_Z_Msk = 0xff
	// Position of NFCID1_Y field.
	NFCT_NFCID1_LAST_NFCID1_Y_Pos = 0x8
	// Bit mask of NFCID1_Y field.
	NFCT_NFCID1_LAST_NFCID1_Y_Msk = 0xff00
	// Position of NFCID1_X field.
	NFCT_NFCID1_LAST_NFCID1_X_Pos = 0x10
	// Bit mask of NFCID1_X field.
	NFCT_NFCID1_LAST_NFCID1_X_Msk = 0xff0000
	// Position of NFCID1_W field.
	NFCT_NFCID1_LAST_NFCID1_W_Pos = 0x18
	// Bit mask of NFCID1_W field.
	NFCT_NFCID1_LAST_NFCID1_W_Msk = 0xff000000

	// NFCID1_2ND_LAST: Second last NFCID1 part (7 or 10 bytes ID)
	// Position of NFCID1_V field.
	NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos = 0x0
	// Bit mask of NFCID1_V field.
	NFCT_NFCID1_2ND_LAST_NFCID1_V_Msk = 0xff
	// Position of NFCID1_U field.
	NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos = 0x8
	// Bit mask of NFCID1_U field.
	NFCT_NFCID1_2ND_LAST_NFCID1_U_Msk = 0xff00
	// Position of NFCID1_T field.
	NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos = 0x10
	// Bit mask of NFCID1_T field.
	NFCT_NFCID1_2ND_LAST_NFCID1_T_Msk = 0xff0000

	// NFCID1_3RD_LAST: Third last NFCID1 part (10 bytes ID)
	// Position of NFCID1_S field.
	NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos = 0x0
	// Bit mask of NFCID1_S field.
	NFCT_NFCID1_3RD_LAST_NFCID1_S_Msk = 0xff
	// Position of NFCID1_R field.
	NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos = 0x8
	// Bit mask of NFCID1_R field.
	NFCT_NFCID1_3RD_LAST_NFCID1_R_Msk = 0xff00
	// Position of NFCID1_Q field.
	NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos = 0x10
	// Bit mask of NFCID1_Q field.
	NFCT_NFCID1_3RD_LAST_NFCID1_Q_Msk = 0xff0000

	// AUTOCOLRESCONFIG: Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated.
	// Position of MODE field.
	NFCT_AUTOCOLRESCONFIG_MODE_Pos = 0x0
	// Bit mask of MODE field.
	NFCT_AUTOCOLRESCONFIG_MODE_Msk = 0x1
	// Bit MODE.
	NFCT_AUTOCOLRESCONFIG_MODE = 0x1
	// Auto collision resolution enabled
	NFCT_AUTOCOLRESCONFIG_MODE_Enabled = 0x0
	// Auto collision resolution disabled
	NFCT_AUTOCOLRESCONFIG_MODE_Disabled = 0x1

	// SENSRES: NFC-A SENS_RES auto-response settings
	// Position of BITFRAMESDD field.
	NFCT_SENSRES_BITFRAMESDD_Pos = 0x0
	// Bit mask of BITFRAMESDD field.
	NFCT_SENSRES_BITFRAMESDD_Msk = 0x1f
	// SDD pattern 00000
	NFCT_SENSRES_BITFRAMESDD_SDD00000 = 0x0
	// SDD pattern 00001
	NFCT_SENSRES_BITFRAMESDD_SDD00001 = 0x1
	// SDD pattern 00010
	NFCT_SENSRES_BITFRAMESDD_SDD00010 = 0x2
	// SDD pattern 00100
	NFCT_SENSRES_BITFRAMESDD_SDD00100 = 0x4
	// SDD pattern 01000
	NFCT_SENSRES_BITFRAMESDD_SDD01000 = 0x8
	// SDD pattern 10000
	NFCT_SENSRES_BITFRAMESDD_SDD10000 = 0x10
	// Position of RFU5 field.
	NFCT_SENSRES_RFU5_Pos = 0x5
	// Bit mask of RFU5 field.
	NFCT_SENSRES_RFU5_Msk = 0x20
	// Bit RFU5.
	NFCT_SENSRES_RFU5 = 0x20
	// Position of NFCIDSIZE field.
	NFCT_SENSRES_NFCIDSIZE_Pos = 0x6
	// Bit mask of NFCIDSIZE field.
	NFCT_SENSRES_NFCIDSIZE_Msk = 0xc0
	// NFCID1 size: single (4 bytes)
	NFCT_SENSRES_NFCIDSIZE_NFCID1Single = 0x0
	// NFCID1 size: double (7 bytes)
	NFCT_SENSRES_NFCIDSIZE_NFCID1Double = 0x1
	// NFCID1 size: triple (10 bytes)
	NFCT_SENSRES_NFCIDSIZE_NFCID1Triple = 0x2
	// Position of PLATFCONFIG field.
	NFCT_SENSRES_PLATFCONFIG_Pos = 0x8
	// Bit mask of PLATFCONFIG field.
	NFCT_SENSRES_PLATFCONFIG_Msk = 0xf00
	// Position of RFU74 field.
	NFCT_SENSRES_RFU74_Pos = 0xc
	// Bit mask of RFU74 field.
	NFCT_SENSRES_RFU74_Msk = 0xf000

	// SELRES: NFC-A SEL_RES auto-response settings
	// Position of RFU10 field.
	NFCT_SELRES_RFU10_Pos = 0x0
	// Bit mask of RFU10 field.
	NFCT_SELRES_RFU10_Msk = 0x3
	// Position of CASCADE field.
	NFCT_SELRES_CASCADE_Pos = 0x2
	// Bit mask of CASCADE field.
	NFCT_SELRES_CASCADE_Msk = 0x4
	// Bit CASCADE.
	NFCT_SELRES_CASCADE = 0x4
	// Position of RFU43 field.
	NFCT_SELRES_RFU43_Pos = 0x3
	// Bit mask of RFU43 field.
	NFCT_SELRES_RFU43_Msk = 0x18
	// Position of PROTOCOL field.
	NFCT_SELRES_PROTOCOL_Pos = 0x5
	// Bit mask of PROTOCOL field.
	NFCT_SELRES_PROTOCOL_Msk = 0x60
	// Position of RFU7 field.
	NFCT_SELRES_RFU7_Pos = 0x7
	// Bit mask of RFU7 field.
	NFCT_SELRES_RFU7_Msk = 0x80
	// Bit RFU7.
	NFCT_SELRES_RFU7 = 0x80
)

// Constants for MUTEX_NS: MUTEX 0
const (
	// MUTEX: Description collection: Mutex register
	// Position of MUTEX field.
	MUTEX_MUTEX_MUTEX_Pos = 0x0
	// Bit mask of MUTEX field.
	MUTEX_MUTEX_MUTEX_Msk = 0x1
	// Bit MUTEX.
	MUTEX_MUTEX_MUTEX = 0x1
	// Mutex n is in unlocked state
	MUTEX_MUTEX_MUTEX_Unlocked = 0x0
	// Mutex n is in locked state
	MUTEX_MUTEX_MUTEX_Locked = 0x1
)

// Constants for QDEC0_NS: Quadrature Decoder 0
const (
	// TASKS_START: Task starting the quadrature decoder
	// Position of TASKS_START field.
	QDEC_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	QDEC_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	QDEC_TASKS_START_TASKS_START = 0x1
	// Trigger task
	QDEC_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Task stopping the quadrature decoder
	// Position of TASKS_STOP field.
	QDEC_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	QDEC_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	QDEC_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	QDEC_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_READCLRACC: Read and clear ACC and ACCDBL
	// Position of TASKS_READCLRACC field.
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Pos = 0x0
	// Bit mask of TASKS_READCLRACC field.
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Msk = 0x1
	// Bit TASKS_READCLRACC.
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC = 0x1
	// Trigger task
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Trigger = 0x1

	// TASKS_RDCLRACC: Read and clear ACC
	// Position of TASKS_RDCLRACC field.
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Pos = 0x0
	// Bit mask of TASKS_RDCLRACC field.
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Msk = 0x1
	// Bit TASKS_RDCLRACC.
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC = 0x1
	// Trigger task
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Trigger = 0x1

	// TASKS_RDCLRDBL: Read and clear ACCDBL
	// Position of TASKS_RDCLRDBL field.
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Pos = 0x0
	// Bit mask of TASKS_RDCLRDBL field.
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Msk = 0x1
	// Bit TASKS_RDCLRDBL.
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL = 0x1
	// Trigger task
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Trigger = 0x1

	// SUBSCRIBE_START: Subscribe configuration for task START
	// Position of CHIDX field.
	QDEC_SUBSCRIBE_START_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_SUBSCRIBE_START_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_SUBSCRIBE_START_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_SUBSCRIBE_START_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_SUBSCRIBE_START_EN = 0x80000000
	// Disable subscription
	QDEC_SUBSCRIBE_START_EN_Disabled = 0x0
	// Enable subscription
	QDEC_SUBSCRIBE_START_EN_Enabled = 0x1

	// SUBSCRIBE_STOP: Subscribe configuration for task STOP
	// Position of CHIDX field.
	QDEC_SUBSCRIBE_STOP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_SUBSCRIBE_STOP_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_SUBSCRIBE_STOP_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_SUBSCRIBE_STOP_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_SUBSCRIBE_STOP_EN = 0x80000000
	// Disable subscription
	QDEC_SUBSCRIBE_STOP_EN_Disabled = 0x0
	// Enable subscription
	QDEC_SUBSCRIBE_STOP_EN_Enabled = 0x1

	// SUBSCRIBE_READCLRACC: Subscribe configuration for task READCLRACC
	// Position of CHIDX field.
	QDEC_SUBSCRIBE_READCLRACC_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_SUBSCRIBE_READCLRACC_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_SUBSCRIBE_READCLRACC_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_SUBSCRIBE_READCLRACC_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_SUBSCRIBE_READCLRACC_EN = 0x80000000
	// Disable subscription
	QDEC_SUBSCRIBE_READCLRACC_EN_Disabled = 0x0
	// Enable subscription
	QDEC_SUBSCRIBE_READCLRACC_EN_Enabled = 0x1

	// SUBSCRIBE_RDCLRACC: Subscribe configuration for task RDCLRACC
	// Position of CHIDX field.
	QDEC_SUBSCRIBE_RDCLRACC_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_SUBSCRIBE_RDCLRACC_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_SUBSCRIBE_RDCLRACC_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_SUBSCRIBE_RDCLRACC_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_SUBSCRIBE_RDCLRACC_EN = 0x80000000
	// Disable subscription
	QDEC_SUBSCRIBE_RDCLRACC_EN_Disabled = 0x0
	// Enable subscription
	QDEC_SUBSCRIBE_RDCLRACC_EN_Enabled = 0x1

	// SUBSCRIBE_RDCLRDBL: Subscribe configuration for task RDCLRDBL
	// Position of CHIDX field.
	QDEC_SUBSCRIBE_RDCLRDBL_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_SUBSCRIBE_RDCLRDBL_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_SUBSCRIBE_RDCLRDBL_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_SUBSCRIBE_RDCLRDBL_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_SUBSCRIBE_RDCLRDBL_EN = 0x80000000
	// Disable subscription
	QDEC_SUBSCRIBE_RDCLRDBL_EN_Disabled = 0x0
	// Enable subscription
	QDEC_SUBSCRIBE_RDCLRDBL_EN_Enabled = 0x1

	// EVENTS_SAMPLERDY: Event being generated for every new sample value written to the SAMPLE register
	// Position of EVENTS_SAMPLERDY field.
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Pos = 0x0
	// Bit mask of EVENTS_SAMPLERDY field.
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Msk = 0x1
	// Bit EVENTS_SAMPLERDY.
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY = 0x1
	// Event not generated
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Generated = 0x1

	// EVENTS_REPORTRDY: Non-null report ready
	// Position of EVENTS_REPORTRDY field.
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Pos = 0x0
	// Bit mask of EVENTS_REPORTRDY field.
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Msk = 0x1
	// Bit EVENTS_REPORTRDY.
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY = 0x1
	// Event not generated
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Generated = 0x1

	// EVENTS_ACCOF: ACC or ACCDBL register overflow
	// Position of EVENTS_ACCOF field.
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Pos = 0x0
	// Bit mask of EVENTS_ACCOF field.
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Msk = 0x1
	// Bit EVENTS_ACCOF.
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF = 0x1
	// Event not generated
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Generated = 0x1

	// EVENTS_DBLRDY: Double displacement(s) detected
	// Position of EVENTS_DBLRDY field.
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Pos = 0x0
	// Bit mask of EVENTS_DBLRDY field.
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Msk = 0x1
	// Bit EVENTS_DBLRDY.
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY = 0x1
	// Event not generated
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Generated = 0x1

	// EVENTS_STOPPED: QDEC has been stopped
	// Position of EVENTS_STOPPED field.
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// PUBLISH_SAMPLERDY: Publish configuration for event SAMPLERDY
	// Position of CHIDX field.
	QDEC_PUBLISH_SAMPLERDY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_PUBLISH_SAMPLERDY_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_PUBLISH_SAMPLERDY_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_PUBLISH_SAMPLERDY_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_PUBLISH_SAMPLERDY_EN = 0x80000000
	// Disable publishing
	QDEC_PUBLISH_SAMPLERDY_EN_Disabled = 0x0
	// Enable publishing
	QDEC_PUBLISH_SAMPLERDY_EN_Enabled = 0x1

	// PUBLISH_REPORTRDY: Publish configuration for event REPORTRDY
	// Position of CHIDX field.
	QDEC_PUBLISH_REPORTRDY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_PUBLISH_REPORTRDY_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_PUBLISH_REPORTRDY_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_PUBLISH_REPORTRDY_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_PUBLISH_REPORTRDY_EN = 0x80000000
	// Disable publishing
	QDEC_PUBLISH_REPORTRDY_EN_Disabled = 0x0
	// Enable publishing
	QDEC_PUBLISH_REPORTRDY_EN_Enabled = 0x1

	// PUBLISH_ACCOF: Publish configuration for event ACCOF
	// Position of CHIDX field.
	QDEC_PUBLISH_ACCOF_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_PUBLISH_ACCOF_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_PUBLISH_ACCOF_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_PUBLISH_ACCOF_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_PUBLISH_ACCOF_EN = 0x80000000
	// Disable publishing
	QDEC_PUBLISH_ACCOF_EN_Disabled = 0x0
	// Enable publishing
	QDEC_PUBLISH_ACCOF_EN_Enabled = 0x1

	// PUBLISH_DBLRDY: Publish configuration for event DBLRDY
	// Position of CHIDX field.
	QDEC_PUBLISH_DBLRDY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_PUBLISH_DBLRDY_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_PUBLISH_DBLRDY_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_PUBLISH_DBLRDY_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_PUBLISH_DBLRDY_EN = 0x80000000
	// Disable publishing
	QDEC_PUBLISH_DBLRDY_EN_Disabled = 0x0
	// Enable publishing
	QDEC_PUBLISH_DBLRDY_EN_Enabled = 0x1

	// PUBLISH_STOPPED: Publish configuration for event STOPPED
	// Position of CHIDX field.
	QDEC_PUBLISH_STOPPED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	QDEC_PUBLISH_STOPPED_CHIDX_Msk = 0xff
	// Position of EN field.
	QDEC_PUBLISH_STOPPED_EN_Pos = 0x1f
	// Bit mask of EN field.
	QDEC_PUBLISH_STOPPED_EN_Msk = 0x80000000
	// Bit EN.
	QDEC_PUBLISH_STOPPED_EN = 0x80000000
	// Disable publishing
	QDEC_PUBLISH_STOPPED_EN_Disabled = 0x0
	// Enable publishing
	QDEC_PUBLISH_STOPPED_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of REPORTRDY_READCLRACC field.
	QDEC_SHORTS_REPORTRDY_READCLRACC_Pos = 0x0
	// Bit mask of REPORTRDY_READCLRACC field.
	QDEC_SHORTS_REPORTRDY_READCLRACC_Msk = 0x1
	// Bit REPORTRDY_READCLRACC.
	QDEC_SHORTS_REPORTRDY_READCLRACC = 0x1
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled = 0x1
	// Position of SAMPLERDY_STOP field.
	QDEC_SHORTS_SAMPLERDY_STOP_Pos = 0x1
	// Bit mask of SAMPLERDY_STOP field.
	QDEC_SHORTS_SAMPLERDY_STOP_Msk = 0x2
	// Bit SAMPLERDY_STOP.
	QDEC_SHORTS_SAMPLERDY_STOP = 0x2
	// Disable shortcut
	QDEC_SHORTS_SAMPLERDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_SAMPLERDY_STOP_Enabled = 0x1
	// Position of REPORTRDY_RDCLRACC field.
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos = 0x2
	// Bit mask of REPORTRDY_RDCLRACC field.
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Msk = 0x4
	// Bit REPORTRDY_RDCLRACC.
	QDEC_SHORTS_REPORTRDY_RDCLRACC = 0x4
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Enabled = 0x1
	// Position of REPORTRDY_STOP field.
	QDEC_SHORTS_REPORTRDY_STOP_Pos = 0x3
	// Bit mask of REPORTRDY_STOP field.
	QDEC_SHORTS_REPORTRDY_STOP_Msk = 0x8
	// Bit REPORTRDY_STOP.
	QDEC_SHORTS_REPORTRDY_STOP = 0x8
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_STOP_Enabled = 0x1
	// Position of DBLRDY_RDCLRDBL field.
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos = 0x4
	// Bit mask of DBLRDY_RDCLRDBL field.
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Msk = 0x10
	// Bit DBLRDY_RDCLRDBL.
	QDEC_SHORTS_DBLRDY_RDCLRDBL = 0x10
	// Disable shortcut
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Enabled = 0x1
	// Position of DBLRDY_STOP field.
	QDEC_SHORTS_DBLRDY_STOP_Pos = 0x5
	// Bit mask of DBLRDY_STOP field.
	QDEC_SHORTS_DBLRDY_STOP_Msk = 0x20
	// Bit DBLRDY_STOP.
	QDEC_SHORTS_DBLRDY_STOP = 0x20
	// Disable shortcut
	QDEC_SHORTS_DBLRDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_DBLRDY_STOP_Enabled = 0x1
	// Position of SAMPLERDY_READCLRACC field.
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos = 0x6
	// Bit mask of SAMPLERDY_READCLRACC field.
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Msk = 0x40
	// Bit SAMPLERDY_READCLRACC.
	QDEC_SHORTS_SAMPLERDY_READCLRACC = 0x40
	// Disable shortcut
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of SAMPLERDY field.
	QDEC_INTENSET_SAMPLERDY_Pos = 0x0
	// Bit mask of SAMPLERDY field.
	QDEC_INTENSET_SAMPLERDY_Msk = 0x1
	// Bit SAMPLERDY.
	QDEC_INTENSET_SAMPLERDY = 0x1
	// Read: Disabled
	QDEC_INTENSET_SAMPLERDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_SAMPLERDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_SAMPLERDY_Set = 0x1
	// Position of REPORTRDY field.
	QDEC_INTENSET_REPORTRDY_Pos = 0x1
	// Bit mask of REPORTRDY field.
	QDEC_INTENSET_REPORTRDY_Msk = 0x2
	// Bit REPORTRDY.
	QDEC_INTENSET_REPORTRDY = 0x2
	// Read: Disabled
	QDEC_INTENSET_REPORTRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_REPORTRDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_REPORTRDY_Set = 0x1
	// Position of ACCOF field.
	QDEC_INTENSET_ACCOF_Pos = 0x2
	// Bit mask of ACCOF field.
	QDEC_INTENSET_ACCOF_Msk = 0x4
	// Bit ACCOF.
	QDEC_INTENSET_ACCOF = 0x4
	// Read: Disabled
	QDEC_INTENSET_ACCOF_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_ACCOF_Enabled = 0x1
	// Enable
	QDEC_INTENSET_ACCOF_Set = 0x1
	// Position of DBLRDY field.
	QDEC_INTENSET_DBLRDY_Pos = 0x3
	// Bit mask of DBLRDY field.
	QDEC_INTENSET_DBLRDY_Msk = 0x8
	// Bit DBLRDY.
	QDEC_INTENSET_DBLRDY = 0x8
	// Read: Disabled
	QDEC_INTENSET_DBLRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_DBLRDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_DBLRDY_Set = 0x1
	// Position of STOPPED field.
	QDEC_INTENSET_STOPPED_Pos = 0x4
	// Bit mask of STOPPED field.
	QDEC_INTENSET_STOPPED_Msk = 0x10
	// Bit STOPPED.
	QDEC_INTENSET_STOPPED = 0x10
	// Read: Disabled
	QDEC_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	QDEC_INTENSET_STOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of SAMPLERDY field.
	QDEC_INTENCLR_SAMPLERDY_Pos = 0x0
	// Bit mask of SAMPLERDY field.
	QDEC_INTENCLR_SAMPLERDY_Msk = 0x1
	// Bit SAMPLERDY.
	QDEC_INTENCLR_SAMPLERDY = 0x1
	// Read: Disabled
	QDEC_INTENCLR_SAMPLERDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_SAMPLERDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_SAMPLERDY_Clear = 0x1
	// Position of REPORTRDY field.
	QDEC_INTENCLR_REPORTRDY_Pos = 0x1
	// Bit mask of REPORTRDY field.
	QDEC_INTENCLR_REPORTRDY_Msk = 0x2
	// Bit REPORTRDY.
	QDEC_INTENCLR_REPORTRDY = 0x2
	// Read: Disabled
	QDEC_INTENCLR_REPORTRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_REPORTRDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_REPORTRDY_Clear = 0x1
	// Position of ACCOF field.
	QDEC_INTENCLR_ACCOF_Pos = 0x2
	// Bit mask of ACCOF field.
	QDEC_INTENCLR_ACCOF_Msk = 0x4
	// Bit ACCOF.
	QDEC_INTENCLR_ACCOF = 0x4
	// Read: Disabled
	QDEC_INTENCLR_ACCOF_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_ACCOF_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_ACCOF_Clear = 0x1
	// Position of DBLRDY field.
	QDEC_INTENCLR_DBLRDY_Pos = 0x3
	// Bit mask of DBLRDY field.
	QDEC_INTENCLR_DBLRDY_Msk = 0x8
	// Bit DBLRDY.
	QDEC_INTENCLR_DBLRDY = 0x8
	// Read: Disabled
	QDEC_INTENCLR_DBLRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_DBLRDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_DBLRDY_Clear = 0x1
	// Position of STOPPED field.
	QDEC_INTENCLR_STOPPED_Pos = 0x4
	// Bit mask of STOPPED field.
	QDEC_INTENCLR_STOPPED_Msk = 0x10
	// Bit STOPPED.
	QDEC_INTENCLR_STOPPED = 0x10
	// Read: Disabled
	QDEC_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_STOPPED_Clear = 0x1

	// ENABLE: Enable the quadrature decoder
	// Position of ENABLE field.
	QDEC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QDEC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QDEC_ENABLE_ENABLE = 0x1
	// Disable
	QDEC_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	QDEC_ENABLE_ENABLE_Enabled = 0x1

	// LEDPOL: LED output pin polarity
	// Position of LEDPOL field.
	QDEC_LEDPOL_LEDPOL_Pos = 0x0
	// Bit mask of LEDPOL field.
	QDEC_LEDPOL_LEDPOL_Msk = 0x1
	// Bit LEDPOL.
	QDEC_LEDPOL_LEDPOL = 0x1
	// Led active on output pin low
	QDEC_LEDPOL_LEDPOL_ActiveLow = 0x0
	// Led active on output pin high
	QDEC_LEDPOL_LEDPOL_ActiveHigh = 0x1

	// SAMPLEPER: Sample period
	// Position of SAMPLEPER field.
	QDEC_SAMPLEPER_SAMPLEPER_Pos = 0x0
	// Bit mask of SAMPLEPER field.
	QDEC_SAMPLEPER_SAMPLEPER_Msk = 0xf
	// 128 us
	QDEC_SAMPLEPER_SAMPLEPER_128us = 0x0
	// 256 us
	QDEC_SAMPLEPER_SAMPLEPER_256us = 0x1
	// 512 us
	QDEC_SAMPLEPER_SAMPLEPER_512us = 0x2
	// 1024 us
	QDEC_SAMPLEPER_SAMPLEPER_1024us = 0x3
	// 2048 us
	QDEC_SAMPLEPER_SAMPLEPER_2048us = 0x4
	// 4096 us
	QDEC_SAMPLEPER_SAMPLEPER_4096us = 0x5
	// 8192 us
	QDEC_SAMPLEPER_SAMPLEPER_8192us = 0x6
	// 16384 us
	QDEC_SAMPLEPER_SAMPLEPER_16384us = 0x7
	// 32768 us
	QDEC_SAMPLEPER_SAMPLEPER_32ms = 0x8
	// 65536 us
	QDEC_SAMPLEPER_SAMPLEPER_65ms = 0x9
	// 131072 us
	QDEC_SAMPLEPER_SAMPLEPER_131ms = 0xa

	// SAMPLE: Motion sample value
	// Position of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Pos = 0x0
	// Bit mask of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Msk = 0xffffffff

	// REPORTPER: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
	// Position of REPORTPER field.
	QDEC_REPORTPER_REPORTPER_Pos = 0x0
	// Bit mask of REPORTPER field.
	QDEC_REPORTPER_REPORTPER_Msk = 0xf
	// 10 samples/report
	QDEC_REPORTPER_REPORTPER_10Smpl = 0x0
	// 40 samples/report
	QDEC_REPORTPER_REPORTPER_40Smpl = 0x1
	// 80 samples/report
	QDEC_REPORTPER_REPORTPER_80Smpl = 0x2
	// 120 samples/report
	QDEC_REPORTPER_REPORTPER_120Smpl = 0x3
	// 160 samples/report
	QDEC_REPORTPER_REPORTPER_160Smpl = 0x4
	// 200 samples/report
	QDEC_REPORTPER_REPORTPER_200Smpl = 0x5
	// 240 samples/report
	QDEC_REPORTPER_REPORTPER_240Smpl = 0x6
	// 280 samples/report
	QDEC_REPORTPER_REPORTPER_280Smpl = 0x7
	// 1 sample/report
	QDEC_REPORTPER_REPORTPER_1Smpl = 0x8

	// ACC: Register accumulating the valid transitions
	// Position of ACC field.
	QDEC_ACC_ACC_Pos = 0x0
	// Bit mask of ACC field.
	QDEC_ACC_ACC_Msk = 0xffffffff

	// ACCREAD: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
	// Position of ACCREAD field.
	QDEC_ACCREAD_ACCREAD_Pos = 0x0
	// Bit mask of ACCREAD field.
	QDEC_ACCREAD_ACCREAD_Msk = 0xffffffff

	// PSEL.LED: Pin select for LED signal
	// Position of PIN field.
	QDEC_PSEL_LED_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_LED_PIN_Msk = 0x1f
	// Position of PORT field.
	QDEC_PSEL_LED_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QDEC_PSEL_LED_PORT_Msk = 0x20
	// Bit PORT.
	QDEC_PSEL_LED_PORT = 0x20
	// Position of CONNECT field.
	QDEC_PSEL_LED_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_LED_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_LED_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_LED_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_LED_CONNECT_Connected = 0x0

	// PSEL.A: Pin select for A signal
	// Position of PIN field.
	QDEC_PSEL_A_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_A_PIN_Msk = 0x1f
	// Position of PORT field.
	QDEC_PSEL_A_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QDEC_PSEL_A_PORT_Msk = 0x20
	// Bit PORT.
	QDEC_PSEL_A_PORT = 0x20
	// Position of CONNECT field.
	QDEC_PSEL_A_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_A_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_A_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_A_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_A_CONNECT_Connected = 0x0

	// PSEL.B: Pin select for B signal
	// Position of PIN field.
	QDEC_PSEL_B_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_B_PIN_Msk = 0x1f
	// Position of PORT field.
	QDEC_PSEL_B_PORT_Pos = 0x5
	// Bit mask of PORT field.
	QDEC_PSEL_B_PORT_Msk = 0x20
	// Bit PORT.
	QDEC_PSEL_B_PORT = 0x20
	// Position of CONNECT field.
	QDEC_PSEL_B_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_B_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_B_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_B_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_B_CONNECT_Connected = 0x0

	// DBFEN: Enable input debounce filters
	// Position of DBFEN field.
	QDEC_DBFEN_DBFEN_Pos = 0x0
	// Bit mask of DBFEN field.
	QDEC_DBFEN_DBFEN_Msk = 0x1
	// Bit DBFEN.
	QDEC_DBFEN_DBFEN = 0x1
	// Debounce input filters disabled
	QDEC_DBFEN_DBFEN_Disabled = 0x0
	// Debounce input filters enabled
	QDEC_DBFEN_DBFEN_Enabled = 0x1

	// LEDPRE: Time period the LED is switched ON prior to sampling
	// Position of LEDPRE field.
	QDEC_LEDPRE_LEDPRE_Pos = 0x0
	// Bit mask of LEDPRE field.
	QDEC_LEDPRE_LEDPRE_Msk = 0x1ff

	// ACCDBL: Register accumulating the number of detected double transitions
	// Position of ACCDBL field.
	QDEC_ACCDBL_ACCDBL_Pos = 0x0
	// Bit mask of ACCDBL field.
	QDEC_ACCDBL_ACCDBL_Msk = 0xf

	// ACCDBLREAD: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
	// Position of ACCDBLREAD field.
	QDEC_ACCDBLREAD_ACCDBLREAD_Pos = 0x0
	// Bit mask of ACCDBLREAD field.
	QDEC_ACCDBLREAD_ACCDBLREAD_Msk = 0xf
)

// Constants for USBD_NS: Universal serial bus device 0
const (
	// TASKS_STARTEPIN: Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
	// Position of TASKS_STARTEPIN field.
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Pos = 0x0
	// Bit mask of TASKS_STARTEPIN field.
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Msk = 0x1
	// Bit TASKS_STARTEPIN.
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN = 0x1
	// Trigger task
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Trigger = 0x1

	// TASKS_STARTISOIN: Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
	// Position of TASKS_STARTISOIN field.
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Pos = 0x0
	// Bit mask of TASKS_STARTISOIN field.
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Msk = 0x1
	// Bit TASKS_STARTISOIN.
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN = 0x1
	// Trigger task
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Trigger = 0x1

	// TASKS_STARTEPOUT: Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
	// Position of TASKS_STARTEPOUT field.
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Pos = 0x0
	// Bit mask of TASKS_STARTEPOUT field.
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Msk = 0x1
	// Bit TASKS_STARTEPOUT.
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT = 0x1
	// Trigger task
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Trigger = 0x1

	// TASKS_STARTISOOUT: Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
	// Position of TASKS_STARTISOOUT field.
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Pos = 0x0
	// Bit mask of TASKS_STARTISOOUT field.
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Msk = 0x1
	// Bit TASKS_STARTISOOUT.
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT = 0x1
	// Trigger task
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Trigger = 0x1

	// TASKS_EP0RCVOUT: Allows OUT data stage on control endpoint 0
	// Position of TASKS_EP0RCVOUT field.
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Pos = 0x0
	// Bit mask of TASKS_EP0RCVOUT field.
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Msk = 0x1
	// Bit TASKS_EP0RCVOUT.
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT = 0x1
	// Trigger task
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Trigger = 0x1

	// TASKS_EP0STATUS: Allows status stage on control endpoint 0
	// Position of TASKS_EP0STATUS field.
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Pos = 0x0
	// Bit mask of TASKS_EP0STATUS field.
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Msk = 0x1
	// Bit TASKS_EP0STATUS.
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS = 0x1
	// Trigger task
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Trigger = 0x1

	// TASKS_EP0STALL: Stalls data and status stage on control endpoint 0
	// Position of TASKS_EP0STALL field.
	USBD_TASKS_EP0STALL_TASKS_EP0STALL_Pos = 0x0
	// Bit mask of TASKS_EP0STALL field.
	USBD_TASKS_EP0STALL_TASKS_EP0STALL_Msk = 0x1
	// Bit TASKS_EP0STALL.
	USBD_TASKS_EP0STALL_TASKS_EP0STALL = 0x1
	// Trigger task
	USBD_TASKS_EP0STALL_TASKS_EP0STALL_Trigger = 0x1

	// TASKS_DPDMDRIVE: Forces D+ and D- lines into the state defined in the DPDMVALUE register
	// Position of TASKS_DPDMDRIVE field.
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Pos = 0x0
	// Bit mask of TASKS_DPDMDRIVE field.
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Msk = 0x1
	// Bit TASKS_DPDMDRIVE.
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE = 0x1
	// Trigger task
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Trigger = 0x1

	// TASKS_DPDMNODRIVE: Stops forcing D+ and D- lines into any state (USB engine takes control)
	// Position of TASKS_DPDMNODRIVE field.
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Pos = 0x0
	// Bit mask of TASKS_DPDMNODRIVE field.
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Msk = 0x1
	// Bit TASKS_DPDMNODRIVE.
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE = 0x1
	// Trigger task
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Trigger = 0x1

	// SUBSCRIBE_STARTEPIN: Description collection: Subscribe configuration for task STARTEPIN[n]
	// Position of CHIDX field.
	USBD_SUBSCRIBE_STARTEPIN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_STARTEPIN_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_STARTEPIN_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_STARTEPIN_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_STARTEPIN_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_STARTEPIN_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_STARTEPIN_EN_Enabled = 0x1

	// SUBSCRIBE_STARTISOIN: Subscribe configuration for task STARTISOIN
	// Position of CHIDX field.
	USBD_SUBSCRIBE_STARTISOIN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_STARTISOIN_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_STARTISOIN_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_STARTISOIN_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_STARTISOIN_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_STARTISOIN_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_STARTISOIN_EN_Enabled = 0x1

	// SUBSCRIBE_STARTEPOUT: Description collection: Subscribe configuration for task STARTEPOUT[n]
	// Position of CHIDX field.
	USBD_SUBSCRIBE_STARTEPOUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_STARTEPOUT_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_STARTEPOUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_STARTEPOUT_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_STARTEPOUT_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_STARTEPOUT_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_STARTEPOUT_EN_Enabled = 0x1

	// SUBSCRIBE_STARTISOOUT: Subscribe configuration for task STARTISOOUT
	// Position of CHIDX field.
	USBD_SUBSCRIBE_STARTISOOUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_STARTISOOUT_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_STARTISOOUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_STARTISOOUT_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_STARTISOOUT_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_STARTISOOUT_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_STARTISOOUT_EN_Enabled = 0x1

	// SUBSCRIBE_EP0RCVOUT: Subscribe configuration for task EP0RCVOUT
	// Position of CHIDX field.
	USBD_SUBSCRIBE_EP0RCVOUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_EP0RCVOUT_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_EP0RCVOUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_EP0RCVOUT_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_EP0RCVOUT_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_EP0RCVOUT_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_EP0RCVOUT_EN_Enabled = 0x1

	// SUBSCRIBE_EP0STATUS: Subscribe configuration for task EP0STATUS
	// Position of CHIDX field.
	USBD_SUBSCRIBE_EP0STATUS_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_EP0STATUS_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_EP0STATUS_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_EP0STATUS_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_EP0STATUS_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_EP0STATUS_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_EP0STATUS_EN_Enabled = 0x1

	// SUBSCRIBE_EP0STALL: Subscribe configuration for task EP0STALL
	// Position of CHIDX field.
	USBD_SUBSCRIBE_EP0STALL_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_EP0STALL_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_EP0STALL_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_EP0STALL_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_EP0STALL_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_EP0STALL_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_EP0STALL_EN_Enabled = 0x1

	// SUBSCRIBE_DPDMDRIVE: Subscribe configuration for task DPDMDRIVE
	// Position of CHIDX field.
	USBD_SUBSCRIBE_DPDMDRIVE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_DPDMDRIVE_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_DPDMDRIVE_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_DPDMDRIVE_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_DPDMDRIVE_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_DPDMDRIVE_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_DPDMDRIVE_EN_Enabled = 0x1

	// SUBSCRIBE_DPDMNODRIVE: Subscribe configuration for task DPDMNODRIVE
	// Position of CHIDX field.
	USBD_SUBSCRIBE_DPDMNODRIVE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_SUBSCRIBE_DPDMNODRIVE_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_SUBSCRIBE_DPDMNODRIVE_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_SUBSCRIBE_DPDMNODRIVE_EN_Msk = 0x80000000
	// Bit EN.
	USBD_SUBSCRIBE_DPDMNODRIVE_EN = 0x80000000
	// Disable subscription
	USBD_SUBSCRIBE_DPDMNODRIVE_EN_Disabled = 0x0
	// Enable subscription
	USBD_SUBSCRIBE_DPDMNODRIVE_EN_Enabled = 0x1

	// EVENTS_USBRESET: Signals that a USB reset condition has been detected on USB lines
	// Position of EVENTS_USBRESET field.
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_Pos = 0x0
	// Bit mask of EVENTS_USBRESET field.
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_Msk = 0x1
	// Bit EVENTS_USBRESET.
	USBD_EVENTS_USBRESET_EVENTS_USBRESET = 0x1
	// Event not generated
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_Generated = 0x1

	// EVENTS_STARTED: Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
	// Position of EVENTS_STARTED field.
	USBD_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	USBD_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	USBD_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	USBD_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// EVENTS_ENDEPIN: Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDEPIN field.
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Pos = 0x0
	// Bit mask of EVENTS_ENDEPIN field.
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Msk = 0x1
	// Bit EVENTS_ENDEPIN.
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN = 0x1
	// Event not generated
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Generated = 0x1

	// EVENTS_EP0DATADONE: An acknowledged data transfer has taken place on the control endpoint
	// Position of EVENTS_EP0DATADONE field.
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Pos = 0x0
	// Bit mask of EVENTS_EP0DATADONE field.
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Msk = 0x1
	// Bit EVENTS_EP0DATADONE.
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE = 0x1
	// Event not generated
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Generated = 0x1

	// EVENTS_ENDISOIN: The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDISOIN field.
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Pos = 0x0
	// Bit mask of EVENTS_ENDISOIN field.
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Msk = 0x1
	// Bit EVENTS_ENDISOIN.
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN = 0x1
	// Event not generated
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Generated = 0x1

	// EVENTS_ENDEPOUT: Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDEPOUT field.
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Pos = 0x0
	// Bit mask of EVENTS_ENDEPOUT field.
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Msk = 0x1
	// Bit EVENTS_ENDEPOUT.
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT = 0x1
	// Event not generated
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Generated = 0x1

	// EVENTS_ENDISOOUT: The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDISOOUT field.
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Pos = 0x0
	// Bit mask of EVENTS_ENDISOOUT field.
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Msk = 0x1
	// Bit EVENTS_ENDISOOUT.
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT = 0x1
	// Event not generated
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Generated = 0x1

	// EVENTS_SOF: Signals that a SOF (start of frame) condition has been detected on USB lines
	// Position of EVENTS_SOF field.
	USBD_EVENTS_SOF_EVENTS_SOF_Pos = 0x0
	// Bit mask of EVENTS_SOF field.
	USBD_EVENTS_SOF_EVENTS_SOF_Msk = 0x1
	// Bit EVENTS_SOF.
	USBD_EVENTS_SOF_EVENTS_SOF = 0x1
	// Event not generated
	USBD_EVENTS_SOF_EVENTS_SOF_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_SOF_EVENTS_SOF_Generated = 0x1

	// EVENTS_USBEVENT: An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
	// Position of EVENTS_USBEVENT field.
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Pos = 0x0
	// Bit mask of EVENTS_USBEVENT field.
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Msk = 0x1
	// Bit EVENTS_USBEVENT.
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT = 0x1
	// Event not generated
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Generated = 0x1

	// EVENTS_EP0SETUP: A valid SETUP token has been received (and acknowledged) on the control endpoint
	// Position of EVENTS_EP0SETUP field.
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Pos = 0x0
	// Bit mask of EVENTS_EP0SETUP field.
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Msk = 0x1
	// Bit EVENTS_EP0SETUP.
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP = 0x1
	// Event not generated
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Generated = 0x1

	// EVENTS_EPDATA: A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
	// Position of EVENTS_EPDATA field.
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_Pos = 0x0
	// Bit mask of EVENTS_EPDATA field.
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_Msk = 0x1
	// Bit EVENTS_EPDATA.
	USBD_EVENTS_EPDATA_EVENTS_EPDATA = 0x1
	// Event not generated
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_Generated = 0x1

	// PUBLISH_USBRESET: Publish configuration for event USBRESET
	// Position of CHIDX field.
	USBD_PUBLISH_USBRESET_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_USBRESET_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_USBRESET_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_USBRESET_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_USBRESET_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_USBRESET_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_USBRESET_EN_Enabled = 0x1

	// PUBLISH_STARTED: Publish configuration for event STARTED
	// Position of CHIDX field.
	USBD_PUBLISH_STARTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_STARTED_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_STARTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_STARTED_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_STARTED_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_STARTED_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_STARTED_EN_Enabled = 0x1

	// PUBLISH_ENDEPIN: Description collection: Publish configuration for event ENDEPIN[n]
	// Position of CHIDX field.
	USBD_PUBLISH_ENDEPIN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_ENDEPIN_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_ENDEPIN_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_ENDEPIN_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_ENDEPIN_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_ENDEPIN_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_ENDEPIN_EN_Enabled = 0x1

	// PUBLISH_EP0DATADONE: Publish configuration for event EP0DATADONE
	// Position of CHIDX field.
	USBD_PUBLISH_EP0DATADONE_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_EP0DATADONE_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_EP0DATADONE_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_EP0DATADONE_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_EP0DATADONE_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_EP0DATADONE_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_EP0DATADONE_EN_Enabled = 0x1

	// PUBLISH_ENDISOIN: Publish configuration for event ENDISOIN
	// Position of CHIDX field.
	USBD_PUBLISH_ENDISOIN_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_ENDISOIN_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_ENDISOIN_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_ENDISOIN_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_ENDISOIN_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_ENDISOIN_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_ENDISOIN_EN_Enabled = 0x1

	// PUBLISH_ENDEPOUT: Description collection: Publish configuration for event ENDEPOUT[n]
	// Position of CHIDX field.
	USBD_PUBLISH_ENDEPOUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_ENDEPOUT_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_ENDEPOUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_ENDEPOUT_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_ENDEPOUT_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_ENDEPOUT_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_ENDEPOUT_EN_Enabled = 0x1

	// PUBLISH_ENDISOOUT: Publish configuration for event ENDISOOUT
	// Position of CHIDX field.
	USBD_PUBLISH_ENDISOOUT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_ENDISOOUT_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_ENDISOOUT_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_ENDISOOUT_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_ENDISOOUT_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_ENDISOOUT_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_ENDISOOUT_EN_Enabled = 0x1

	// PUBLISH_SOF: Publish configuration for event SOF
	// Position of CHIDX field.
	USBD_PUBLISH_SOF_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_SOF_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_SOF_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_SOF_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_SOF_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_SOF_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_SOF_EN_Enabled = 0x1

	// PUBLISH_USBEVENT: Publish configuration for event USBEVENT
	// Position of CHIDX field.
	USBD_PUBLISH_USBEVENT_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_USBEVENT_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_USBEVENT_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_USBEVENT_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_USBEVENT_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_USBEVENT_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_USBEVENT_EN_Enabled = 0x1

	// PUBLISH_EP0SETUP: Publish configuration for event EP0SETUP
	// Position of CHIDX field.
	USBD_PUBLISH_EP0SETUP_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_EP0SETUP_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_EP0SETUP_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_EP0SETUP_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_EP0SETUP_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_EP0SETUP_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_EP0SETUP_EN_Enabled = 0x1

	// PUBLISH_EPDATA: Publish configuration for event EPDATA
	// Position of CHIDX field.
	USBD_PUBLISH_EPDATA_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBD_PUBLISH_EPDATA_CHIDX_Msk = 0xff
	// Position of EN field.
	USBD_PUBLISH_EPDATA_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBD_PUBLISH_EPDATA_EN_Msk = 0x80000000
	// Bit EN.
	USBD_PUBLISH_EPDATA_EN = 0x80000000
	// Disable publishing
	USBD_PUBLISH_EPDATA_EN_Disabled = 0x0
	// Enable publishing
	USBD_PUBLISH_EPDATA_EN_Enabled = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of EP0DATADONE_STARTEPIN0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Pos = 0x0
	// Bit mask of EP0DATADONE_STARTEPIN0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Msk = 0x1
	// Bit EP0DATADONE_STARTEPIN0.
	USBD_SHORTS_EP0DATADONE_STARTEPIN0 = 0x1
	// Disable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Enabled = 0x1
	// Position of EP0DATADONE_STARTEPOUT0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Pos = 0x1
	// Bit mask of EP0DATADONE_STARTEPOUT0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Msk = 0x2
	// Bit EP0DATADONE_STARTEPOUT0.
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0 = 0x2
	// Disable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Enabled = 0x1
	// Position of EP0DATADONE_EP0STATUS field.
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Pos = 0x2
	// Bit mask of EP0DATADONE_EP0STATUS field.
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Msk = 0x4
	// Bit EP0DATADONE_EP0STATUS.
	USBD_SHORTS_EP0DATADONE_EP0STATUS = 0x4
	// Disable shortcut
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Enabled = 0x1
	// Position of ENDEPOUT0_EP0STATUS field.
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Pos = 0x3
	// Bit mask of ENDEPOUT0_EP0STATUS field.
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Msk = 0x8
	// Bit ENDEPOUT0_EP0STATUS.
	USBD_SHORTS_ENDEPOUT0_EP0STATUS = 0x8
	// Disable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Enabled = 0x1
	// Position of ENDEPOUT0_EP0RCVOUT field.
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Pos = 0x4
	// Bit mask of ENDEPOUT0_EP0RCVOUT field.
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Msk = 0x10
	// Bit ENDEPOUT0_EP0RCVOUT.
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT = 0x10
	// Disable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of USBRESET field.
	USBD_INTEN_USBRESET_Pos = 0x0
	// Bit mask of USBRESET field.
	USBD_INTEN_USBRESET_Msk = 0x1
	// Bit USBRESET.
	USBD_INTEN_USBRESET = 0x1
	// Disable
	USBD_INTEN_USBRESET_Disabled = 0x0
	// Enable
	USBD_INTEN_USBRESET_Enabled = 0x1
	// Position of STARTED field.
	USBD_INTEN_STARTED_Pos = 0x1
	// Bit mask of STARTED field.
	USBD_INTEN_STARTED_Msk = 0x2
	// Bit STARTED.
	USBD_INTEN_STARTED = 0x2
	// Disable
	USBD_INTEN_STARTED_Disabled = 0x0
	// Enable
	USBD_INTEN_STARTED_Enabled = 0x1
	// Position of ENDEPIN0 field.
	USBD_INTEN_ENDEPIN0_Pos = 0x2
	// Bit mask of ENDEPIN0 field.
	USBD_INTEN_ENDEPIN0_Msk = 0x4
	// Bit ENDEPIN0.
	USBD_INTEN_ENDEPIN0 = 0x4
	// Disable
	USBD_INTEN_ENDEPIN0_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN0_Enabled = 0x1
	// Position of ENDEPIN1 field.
	USBD_INTEN_ENDEPIN1_Pos = 0x3
	// Bit mask of ENDEPIN1 field.
	USBD_INTEN_ENDEPIN1_Msk = 0x8
	// Bit ENDEPIN1.
	USBD_INTEN_ENDEPIN1 = 0x8
	// Disable
	USBD_INTEN_ENDEPIN1_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN1_Enabled = 0x1
	// Position of ENDEPIN2 field.
	USBD_INTEN_ENDEPIN2_Pos = 0x4
	// Bit mask of ENDEPIN2 field.
	USBD_INTEN_ENDEPIN2_Msk = 0x10
	// Bit ENDEPIN2.
	USBD_INTEN_ENDEPIN2 = 0x10
	// Disable
	USBD_INTEN_ENDEPIN2_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN2_Enabled = 0x1
	// Position of ENDEPIN3 field.
	USBD_INTEN_ENDEPIN3_Pos = 0x5
	// Bit mask of ENDEPIN3 field.
	USBD_INTEN_ENDEPIN3_Msk = 0x20
	// Bit ENDEPIN3.
	USBD_INTEN_ENDEPIN3 = 0x20
	// Disable
	USBD_INTEN_ENDEPIN3_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN3_Enabled = 0x1
	// Position of ENDEPIN4 field.
	USBD_INTEN_ENDEPIN4_Pos = 0x6
	// Bit mask of ENDEPIN4 field.
	USBD_INTEN_ENDEPIN4_Msk = 0x40
	// Bit ENDEPIN4.
	USBD_INTEN_ENDEPIN4 = 0x40
	// Disable
	USBD_INTEN_ENDEPIN4_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN4_Enabled = 0x1
	// Position of ENDEPIN5 field.
	USBD_INTEN_ENDEPIN5_Pos = 0x7
	// Bit mask of ENDEPIN5 field.
	USBD_INTEN_ENDEPIN5_Msk = 0x80
	// Bit ENDEPIN5.
	USBD_INTEN_ENDEPIN5 = 0x80
	// Disable
	USBD_INTEN_ENDEPIN5_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN5_Enabled = 0x1
	// Position of ENDEPIN6 field.
	USBD_INTEN_ENDEPIN6_Pos = 0x8
	// Bit mask of ENDEPIN6 field.
	USBD_INTEN_ENDEPIN6_Msk = 0x100
	// Bit ENDEPIN6.
	USBD_INTEN_ENDEPIN6 = 0x100
	// Disable
	USBD_INTEN_ENDEPIN6_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN6_Enabled = 0x1
	// Position of ENDEPIN7 field.
	USBD_INTEN_ENDEPIN7_Pos = 0x9
	// Bit mask of ENDEPIN7 field.
	USBD_INTEN_ENDEPIN7_Msk = 0x200
	// Bit ENDEPIN7.
	USBD_INTEN_ENDEPIN7 = 0x200
	// Disable
	USBD_INTEN_ENDEPIN7_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN7_Enabled = 0x1
	// Position of EP0DATADONE field.
	USBD_INTEN_EP0DATADONE_Pos = 0xa
	// Bit mask of EP0DATADONE field.
	USBD_INTEN_EP0DATADONE_Msk = 0x400
	// Bit EP0DATADONE.
	USBD_INTEN_EP0DATADONE = 0x400
	// Disable
	USBD_INTEN_EP0DATADONE_Disabled = 0x0
	// Enable
	USBD_INTEN_EP0DATADONE_Enabled = 0x1
	// Position of ENDISOIN field.
	USBD_INTEN_ENDISOIN_Pos = 0xb
	// Bit mask of ENDISOIN field.
	USBD_INTEN_ENDISOIN_Msk = 0x800
	// Bit ENDISOIN.
	USBD_INTEN_ENDISOIN = 0x800
	// Disable
	USBD_INTEN_ENDISOIN_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDISOIN_Enabled = 0x1
	// Position of ENDEPOUT0 field.
	USBD_INTEN_ENDEPOUT0_Pos = 0xc
	// Bit mask of ENDEPOUT0 field.
	USBD_INTEN_ENDEPOUT0_Msk = 0x1000
	// Bit ENDEPOUT0.
	USBD_INTEN_ENDEPOUT0 = 0x1000
	// Disable
	USBD_INTEN_ENDEPOUT0_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT0_Enabled = 0x1
	// Position of ENDEPOUT1 field.
	USBD_INTEN_ENDEPOUT1_Pos = 0xd
	// Bit mask of ENDEPOUT1 field.
	USBD_INTEN_ENDEPOUT1_Msk = 0x2000
	// Bit ENDEPOUT1.
	USBD_INTEN_ENDEPOUT1 = 0x2000
	// Disable
	USBD_INTEN_ENDEPOUT1_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT1_Enabled = 0x1
	// Position of ENDEPOUT2 field.
	USBD_INTEN_ENDEPOUT2_Pos = 0xe
	// Bit mask of ENDEPOUT2 field.
	USBD_INTEN_ENDEPOUT2_Msk = 0x4000
	// Bit ENDEPOUT2.
	USBD_INTEN_ENDEPOUT2 = 0x4000
	// Disable
	USBD_INTEN_ENDEPOUT2_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT2_Enabled = 0x1
	// Position of ENDEPOUT3 field.
	USBD_INTEN_ENDEPOUT3_Pos = 0xf
	// Bit mask of ENDEPOUT3 field.
	USBD_INTEN_ENDEPOUT3_Msk = 0x8000
	// Bit ENDEPOUT3.
	USBD_INTEN_ENDEPOUT3 = 0x8000
	// Disable
	USBD_INTEN_ENDEPOUT3_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT3_Enabled = 0x1
	// Position of ENDEPOUT4 field.
	USBD_INTEN_ENDEPOUT4_Pos = 0x10
	// Bit mask of ENDEPOUT4 field.
	USBD_INTEN_ENDEPOUT4_Msk = 0x10000
	// Bit ENDEPOUT4.
	USBD_INTEN_ENDEPOUT4 = 0x10000
	// Disable
	USBD_INTEN_ENDEPOUT4_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT4_Enabled = 0x1
	// Position of ENDEPOUT5 field.
	USBD_INTEN_ENDEPOUT5_Pos = 0x11
	// Bit mask of ENDEPOUT5 field.
	USBD_INTEN_ENDEPOUT5_Msk = 0x20000
	// Bit ENDEPOUT5.
	USBD_INTEN_ENDEPOUT5 = 0x20000
	// Disable
	USBD_INTEN_ENDEPOUT5_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT5_Enabled = 0x1
	// Position of ENDEPOUT6 field.
	USBD_INTEN_ENDEPOUT6_Pos = 0x12
	// Bit mask of ENDEPOUT6 field.
	USBD_INTEN_ENDEPOUT6_Msk = 0x40000
	// Bit ENDEPOUT6.
	USBD_INTEN_ENDEPOUT6 = 0x40000
	// Disable
	USBD_INTEN_ENDEPOUT6_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT6_Enabled = 0x1
	// Position of ENDEPOUT7 field.
	USBD_INTEN_ENDEPOUT7_Pos = 0x13
	// Bit mask of ENDEPOUT7 field.
	USBD_INTEN_ENDEPOUT7_Msk = 0x80000
	// Bit ENDEPOUT7.
	USBD_INTEN_ENDEPOUT7 = 0x80000
	// Disable
	USBD_INTEN_ENDEPOUT7_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT7_Enabled = 0x1
	// Position of ENDISOOUT field.
	USBD_INTEN_ENDISOOUT_Pos = 0x14
	// Bit mask of ENDISOOUT field.
	USBD_INTEN_ENDISOOUT_Msk = 0x100000
	// Bit ENDISOOUT.
	USBD_INTEN_ENDISOOUT = 0x100000
	// Disable
	USBD_INTEN_ENDISOOUT_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDISOOUT_Enabled = 0x1
	// Position of SOF field.
	USBD_INTEN_SOF_Pos = 0x15
	// Bit mask of SOF field.
	USBD_INTEN_SOF_Msk = 0x200000
	// Bit SOF.
	USBD_INTEN_SOF = 0x200000
	// Disable
	USBD_INTEN_SOF_Disabled = 0x0
	// Enable
	USBD_INTEN_SOF_Enabled = 0x1
	// Position of USBEVENT field.
	USBD_INTEN_USBEVENT_Pos = 0x16
	// Bit mask of USBEVENT field.
	USBD_INTEN_USBEVENT_Msk = 0x400000
	// Bit USBEVENT.
	USBD_INTEN_USBEVENT = 0x400000
	// Disable
	USBD_INTEN_USBEVENT_Disabled = 0x0
	// Enable
	USBD_INTEN_USBEVENT_Enabled = 0x1
	// Position of EP0SETUP field.
	USBD_INTEN_EP0SETUP_Pos = 0x17
	// Bit mask of EP0SETUP field.
	USBD_INTEN_EP0SETUP_Msk = 0x800000
	// Bit EP0SETUP.
	USBD_INTEN_EP0SETUP = 0x800000
	// Disable
	USBD_INTEN_EP0SETUP_Disabled = 0x0
	// Enable
	USBD_INTEN_EP0SETUP_Enabled = 0x1
	// Position of EPDATA field.
	USBD_INTEN_EPDATA_Pos = 0x18
	// Bit mask of EPDATA field.
	USBD_INTEN_EPDATA_Msk = 0x1000000
	// Bit EPDATA.
	USBD_INTEN_EPDATA = 0x1000000
	// Disable
	USBD_INTEN_EPDATA_Disabled = 0x0
	// Enable
	USBD_INTEN_EPDATA_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of USBRESET field.
	USBD_INTENSET_USBRESET_Pos = 0x0
	// Bit mask of USBRESET field.
	USBD_INTENSET_USBRESET_Msk = 0x1
	// Bit USBRESET.
	USBD_INTENSET_USBRESET = 0x1
	// Read: Disabled
	USBD_INTENSET_USBRESET_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_USBRESET_Enabled = 0x1
	// Enable
	USBD_INTENSET_USBRESET_Set = 0x1
	// Position of STARTED field.
	USBD_INTENSET_STARTED_Pos = 0x1
	// Bit mask of STARTED field.
	USBD_INTENSET_STARTED_Msk = 0x2
	// Bit STARTED.
	USBD_INTENSET_STARTED = 0x2
	// Read: Disabled
	USBD_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_STARTED_Enabled = 0x1
	// Enable
	USBD_INTENSET_STARTED_Set = 0x1
	// Position of ENDEPIN0 field.
	USBD_INTENSET_ENDEPIN0_Pos = 0x2
	// Bit mask of ENDEPIN0 field.
	USBD_INTENSET_ENDEPIN0_Msk = 0x4
	// Bit ENDEPIN0.
	USBD_INTENSET_ENDEPIN0 = 0x4
	// Read: Disabled
	USBD_INTENSET_ENDEPIN0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN0_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN0_Set = 0x1
	// Position of ENDEPIN1 field.
	USBD_INTENSET_ENDEPIN1_Pos = 0x3
	// Bit mask of ENDEPIN1 field.
	USBD_INTENSET_ENDEPIN1_Msk = 0x8
	// Bit ENDEPIN1.
	USBD_INTENSET_ENDEPIN1 = 0x8
	// Read: Disabled
	USBD_INTENSET_ENDEPIN1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN1_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN1_Set = 0x1
	// Position of ENDEPIN2 field.
	USBD_INTENSET_ENDEPIN2_Pos = 0x4
	// Bit mask of ENDEPIN2 field.
	USBD_INTENSET_ENDEPIN2_Msk = 0x10
	// Bit ENDEPIN2.
	USBD_INTENSET_ENDEPIN2 = 0x10
	// Read: Disabled
	USBD_INTENSET_ENDEPIN2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN2_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN2_Set = 0x1
	// Position of ENDEPIN3 field.
	USBD_INTENSET_ENDEPIN3_Pos = 0x5
	// Bit mask of ENDEPIN3 field.
	USBD_INTENSET_ENDEPIN3_Msk = 0x20
	// Bit ENDEPIN3.
	USBD_INTENSET_ENDEPIN3 = 0x20
	// Read: Disabled
	USBD_INTENSET_ENDEPIN3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN3_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN3_Set = 0x1
	// Position of ENDEPIN4 field.
	USBD_INTENSET_ENDEPIN4_Pos = 0x6
	// Bit mask of ENDEPIN4 field.
	USBD_INTENSET_ENDEPIN4_Msk = 0x40
	// Bit ENDEPIN4.
	USBD_INTENSET_ENDEPIN4 = 0x40
	// Read: Disabled
	USBD_INTENSET_ENDEPIN4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN4_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN4_Set = 0x1
	// Position of ENDEPIN5 field.
	USBD_INTENSET_ENDEPIN5_Pos = 0x7
	// Bit mask of ENDEPIN5 field.
	USBD_INTENSET_ENDEPIN5_Msk = 0x80
	// Bit ENDEPIN5.
	USBD_INTENSET_ENDEPIN5 = 0x80
	// Read: Disabled
	USBD_INTENSET_ENDEPIN5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN5_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN5_Set = 0x1
	// Position of ENDEPIN6 field.
	USBD_INTENSET_ENDEPIN6_Pos = 0x8
	// Bit mask of ENDEPIN6 field.
	USBD_INTENSET_ENDEPIN6_Msk = 0x100
	// Bit ENDEPIN6.
	USBD_INTENSET_ENDEPIN6 = 0x100
	// Read: Disabled
	USBD_INTENSET_ENDEPIN6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN6_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN6_Set = 0x1
	// Position of ENDEPIN7 field.
	USBD_INTENSET_ENDEPIN7_Pos = 0x9
	// Bit mask of ENDEPIN7 field.
	USBD_INTENSET_ENDEPIN7_Msk = 0x200
	// Bit ENDEPIN7.
	USBD_INTENSET_ENDEPIN7 = 0x200
	// Read: Disabled
	USBD_INTENSET_ENDEPIN7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN7_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN7_Set = 0x1
	// Position of EP0DATADONE field.
	USBD_INTENSET_EP0DATADONE_Pos = 0xa
	// Bit mask of EP0DATADONE field.
	USBD_INTENSET_EP0DATADONE_Msk = 0x400
	// Bit EP0DATADONE.
	USBD_INTENSET_EP0DATADONE = 0x400
	// Read: Disabled
	USBD_INTENSET_EP0DATADONE_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_EP0DATADONE_Enabled = 0x1
	// Enable
	USBD_INTENSET_EP0DATADONE_Set = 0x1
	// Position of ENDISOIN field.
	USBD_INTENSET_ENDISOIN_Pos = 0xb
	// Bit mask of ENDISOIN field.
	USBD_INTENSET_ENDISOIN_Msk = 0x800
	// Bit ENDISOIN.
	USBD_INTENSET_ENDISOIN = 0x800
	// Read: Disabled
	USBD_INTENSET_ENDISOIN_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDISOIN_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDISOIN_Set = 0x1
	// Position of ENDEPOUT0 field.
	USBD_INTENSET_ENDEPOUT0_Pos = 0xc
	// Bit mask of ENDEPOUT0 field.
	USBD_INTENSET_ENDEPOUT0_Msk = 0x1000
	// Bit ENDEPOUT0.
	USBD_INTENSET_ENDEPOUT0 = 0x1000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT0_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT0_Set = 0x1
	// Position of ENDEPOUT1 field.
	USBD_INTENSET_ENDEPOUT1_Pos = 0xd
	// Bit mask of ENDEPOUT1 field.
	USBD_INTENSET_ENDEPOUT1_Msk = 0x2000
	// Bit ENDEPOUT1.
	USBD_INTENSET_ENDEPOUT1 = 0x2000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT1_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT1_Set = 0x1
	// Position of ENDEPOUT2 field.
	USBD_INTENSET_ENDEPOUT2_Pos = 0xe
	// Bit mask of ENDEPOUT2 field.
	USBD_INTENSET_ENDEPOUT2_Msk = 0x4000
	// Bit ENDEPOUT2.
	USBD_INTENSET_ENDEPOUT2 = 0x4000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT2_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT2_Set = 0x1
	// Position of ENDEPOUT3 field.
	USBD_INTENSET_ENDEPOUT3_Pos = 0xf
	// Bit mask of ENDEPOUT3 field.
	USBD_INTENSET_ENDEPOUT3_Msk = 0x8000
	// Bit ENDEPOUT3.
	USBD_INTENSET_ENDEPOUT3 = 0x8000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT3_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT3_Set = 0x1
	// Position of ENDEPOUT4 field.
	USBD_INTENSET_ENDEPOUT4_Pos = 0x10
	// Bit mask of ENDEPOUT4 field.
	USBD_INTENSET_ENDEPOUT4_Msk = 0x10000
	// Bit ENDEPOUT4.
	USBD_INTENSET_ENDEPOUT4 = 0x10000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT4_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT4_Set = 0x1
	// Position of ENDEPOUT5 field.
	USBD_INTENSET_ENDEPOUT5_Pos = 0x11
	// Bit mask of ENDEPOUT5 field.
	USBD_INTENSET_ENDEPOUT5_Msk = 0x20000
	// Bit ENDEPOUT5.
	USBD_INTENSET_ENDEPOUT5 = 0x20000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT5_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT5_Set = 0x1
	// Position of ENDEPOUT6 field.
	USBD_INTENSET_ENDEPOUT6_Pos = 0x12
	// Bit mask of ENDEPOUT6 field.
	USBD_INTENSET_ENDEPOUT6_Msk = 0x40000
	// Bit ENDEPOUT6.
	USBD_INTENSET_ENDEPOUT6 = 0x40000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT6_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT6_Set = 0x1
	// Position of ENDEPOUT7 field.
	USBD_INTENSET_ENDEPOUT7_Pos = 0x13
	// Bit mask of ENDEPOUT7 field.
	USBD_INTENSET_ENDEPOUT7_Msk = 0x80000
	// Bit ENDEPOUT7.
	USBD_INTENSET_ENDEPOUT7 = 0x80000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT7_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT7_Set = 0x1
	// Position of ENDISOOUT field.
	USBD_INTENSET_ENDISOOUT_Pos = 0x14
	// Bit mask of ENDISOOUT field.
	USBD_INTENSET_ENDISOOUT_Msk = 0x100000
	// Bit ENDISOOUT.
	USBD_INTENSET_ENDISOOUT = 0x100000
	// Read: Disabled
	USBD_INTENSET_ENDISOOUT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDISOOUT_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDISOOUT_Set = 0x1
	// Position of SOF field.
	USBD_INTENSET_SOF_Pos = 0x15
	// Bit mask of SOF field.
	USBD_INTENSET_SOF_Msk = 0x200000
	// Bit SOF.
	USBD_INTENSET_SOF = 0x200000
	// Read: Disabled
	USBD_INTENSET_SOF_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_SOF_Enabled = 0x1
	// Enable
	USBD_INTENSET_SOF_Set = 0x1
	// Position of USBEVENT field.
	USBD_INTENSET_USBEVENT_Pos = 0x16
	// Bit mask of USBEVENT field.
	USBD_INTENSET_USBEVENT_Msk = 0x400000
	// Bit USBEVENT.
	USBD_INTENSET_USBEVENT = 0x400000
	// Read: Disabled
	USBD_INTENSET_USBEVENT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_USBEVENT_Enabled = 0x1
	// Enable
	USBD_INTENSET_USBEVENT_Set = 0x1
	// Position of EP0SETUP field.
	USBD_INTENSET_EP0SETUP_Pos = 0x17
	// Bit mask of EP0SETUP field.
	USBD_INTENSET_EP0SETUP_Msk = 0x800000
	// Bit EP0SETUP.
	USBD_INTENSET_EP0SETUP = 0x800000
	// Read: Disabled
	USBD_INTENSET_EP0SETUP_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_EP0SETUP_Enabled = 0x1
	// Enable
	USBD_INTENSET_EP0SETUP_Set = 0x1
	// Position of EPDATA field.
	USBD_INTENSET_EPDATA_Pos = 0x18
	// Bit mask of EPDATA field.
	USBD_INTENSET_EPDATA_Msk = 0x1000000
	// Bit EPDATA.
	USBD_INTENSET_EPDATA = 0x1000000
	// Read: Disabled
	USBD_INTENSET_EPDATA_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_EPDATA_Enabled = 0x1
	// Enable
	USBD_INTENSET_EPDATA_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of USBRESET field.
	USBD_INTENCLR_USBRESET_Pos = 0x0
	// Bit mask of USBRESET field.
	USBD_INTENCLR_USBRESET_Msk = 0x1
	// Bit USBRESET.
	USBD_INTENCLR_USBRESET = 0x1
	// Read: Disabled
	USBD_INTENCLR_USBRESET_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_USBRESET_Enabled = 0x1
	// Disable
	USBD_INTENCLR_USBRESET_Clear = 0x1
	// Position of STARTED field.
	USBD_INTENCLR_STARTED_Pos = 0x1
	// Bit mask of STARTED field.
	USBD_INTENCLR_STARTED_Msk = 0x2
	// Bit STARTED.
	USBD_INTENCLR_STARTED = 0x2
	// Read: Disabled
	USBD_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	USBD_INTENCLR_STARTED_Clear = 0x1
	// Position of ENDEPIN0 field.
	USBD_INTENCLR_ENDEPIN0_Pos = 0x2
	// Bit mask of ENDEPIN0 field.
	USBD_INTENCLR_ENDEPIN0_Msk = 0x4
	// Bit ENDEPIN0.
	USBD_INTENCLR_ENDEPIN0 = 0x4
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN0_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN0_Clear = 0x1
	// Position of ENDEPIN1 field.
	USBD_INTENCLR_ENDEPIN1_Pos = 0x3
	// Bit mask of ENDEPIN1 field.
	USBD_INTENCLR_ENDEPIN1_Msk = 0x8
	// Bit ENDEPIN1.
	USBD_INTENCLR_ENDEPIN1 = 0x8
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN1_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN1_Clear = 0x1
	// Position of ENDEPIN2 field.
	USBD_INTENCLR_ENDEPIN2_Pos = 0x4
	// Bit mask of ENDEPIN2 field.
	USBD_INTENCLR_ENDEPIN2_Msk = 0x10
	// Bit ENDEPIN2.
	USBD_INTENCLR_ENDEPIN2 = 0x10
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN2_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN2_Clear = 0x1
	// Position of ENDEPIN3 field.
	USBD_INTENCLR_ENDEPIN3_Pos = 0x5
	// Bit mask of ENDEPIN3 field.
	USBD_INTENCLR_ENDEPIN3_Msk = 0x20
	// Bit ENDEPIN3.
	USBD_INTENCLR_ENDEPIN3 = 0x20
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN3_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN3_Clear = 0x1
	// Position of ENDEPIN4 field.
	USBD_INTENCLR_ENDEPIN4_Pos = 0x6
	// Bit mask of ENDEPIN4 field.
	USBD_INTENCLR_ENDEPIN4_Msk = 0x40
	// Bit ENDEPIN4.
	USBD_INTENCLR_ENDEPIN4 = 0x40
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN4_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN4_Clear = 0x1
	// Position of ENDEPIN5 field.
	USBD_INTENCLR_ENDEPIN5_Pos = 0x7
	// Bit mask of ENDEPIN5 field.
	USBD_INTENCLR_ENDEPIN5_Msk = 0x80
	// Bit ENDEPIN5.
	USBD_INTENCLR_ENDEPIN5 = 0x80
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN5_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN5_Clear = 0x1
	// Position of ENDEPIN6 field.
	USBD_INTENCLR_ENDEPIN6_Pos = 0x8
	// Bit mask of ENDEPIN6 field.
	USBD_INTENCLR_ENDEPIN6_Msk = 0x100
	// Bit ENDEPIN6.
	USBD_INTENCLR_ENDEPIN6 = 0x100
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN6_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN6_Clear = 0x1
	// Position of ENDEPIN7 field.
	USBD_INTENCLR_ENDEPIN7_Pos = 0x9
	// Bit mask of ENDEPIN7 field.
	USBD_INTENCLR_ENDEPIN7_Msk = 0x200
	// Bit ENDEPIN7.
	USBD_INTENCLR_ENDEPIN7 = 0x200
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN7_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN7_Clear = 0x1
	// Position of EP0DATADONE field.
	USBD_INTENCLR_EP0DATADONE_Pos = 0xa
	// Bit mask of EP0DATADONE field.
	USBD_INTENCLR_EP0DATADONE_Msk = 0x400
	// Bit EP0DATADONE.
	USBD_INTENCLR_EP0DATADONE = 0x400
	// Read: Disabled
	USBD_INTENCLR_EP0DATADONE_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_EP0DATADONE_Enabled = 0x1
	// Disable
	USBD_INTENCLR_EP0DATADONE_Clear = 0x1
	// Position of ENDISOIN field.
	USBD_INTENCLR_ENDISOIN_Pos = 0xb
	// Bit mask of ENDISOIN field.
	USBD_INTENCLR_ENDISOIN_Msk = 0x800
	// Bit ENDISOIN.
	USBD_INTENCLR_ENDISOIN = 0x800
	// Read: Disabled
	USBD_INTENCLR_ENDISOIN_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDISOIN_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDISOIN_Clear = 0x1
	// Position of ENDEPOUT0 field.
	USBD_INTENCLR_ENDEPOUT0_Pos = 0xc
	// Bit mask of ENDEPOUT0 field.
	USBD_INTENCLR_ENDEPOUT0_Msk = 0x1000
	// Bit ENDEPOUT0.
	USBD_INTENCLR_ENDEPOUT0 = 0x1000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT0_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT0_Clear = 0x1
	// Position of ENDEPOUT1 field.
	USBD_INTENCLR_ENDEPOUT1_Pos = 0xd
	// Bit mask of ENDEPOUT1 field.
	USBD_INTENCLR_ENDEPOUT1_Msk = 0x2000
	// Bit ENDEPOUT1.
	USBD_INTENCLR_ENDEPOUT1 = 0x2000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT1_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT1_Clear = 0x1
	// Position of ENDEPOUT2 field.
	USBD_INTENCLR_ENDEPOUT2_Pos = 0xe
	// Bit mask of ENDEPOUT2 field.
	USBD_INTENCLR_ENDEPOUT2_Msk = 0x4000
	// Bit ENDEPOUT2.
	USBD_INTENCLR_ENDEPOUT2 = 0x4000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT2_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT2_Clear = 0x1
	// Position of ENDEPOUT3 field.
	USBD_INTENCLR_ENDEPOUT3_Pos = 0xf
	// Bit mask of ENDEPOUT3 field.
	USBD_INTENCLR_ENDEPOUT3_Msk = 0x8000
	// Bit ENDEPOUT3.
	USBD_INTENCLR_ENDEPOUT3 = 0x8000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT3_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT3_Clear = 0x1
	// Position of ENDEPOUT4 field.
	USBD_INTENCLR_ENDEPOUT4_Pos = 0x10
	// Bit mask of ENDEPOUT4 field.
	USBD_INTENCLR_ENDEPOUT4_Msk = 0x10000
	// Bit ENDEPOUT4.
	USBD_INTENCLR_ENDEPOUT4 = 0x10000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT4_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT4_Clear = 0x1
	// Position of ENDEPOUT5 field.
	USBD_INTENCLR_ENDEPOUT5_Pos = 0x11
	// Bit mask of ENDEPOUT5 field.
	USBD_INTENCLR_ENDEPOUT5_Msk = 0x20000
	// Bit ENDEPOUT5.
	USBD_INTENCLR_ENDEPOUT5 = 0x20000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT5_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT5_Clear = 0x1
	// Position of ENDEPOUT6 field.
	USBD_INTENCLR_ENDEPOUT6_Pos = 0x12
	// Bit mask of ENDEPOUT6 field.
	USBD_INTENCLR_ENDEPOUT6_Msk = 0x40000
	// Bit ENDEPOUT6.
	USBD_INTENCLR_ENDEPOUT6 = 0x40000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT6_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT6_Clear = 0x1
	// Position of ENDEPOUT7 field.
	USBD_INTENCLR_ENDEPOUT7_Pos = 0x13
	// Bit mask of ENDEPOUT7 field.
	USBD_INTENCLR_ENDEPOUT7_Msk = 0x80000
	// Bit ENDEPOUT7.
	USBD_INTENCLR_ENDEPOUT7 = 0x80000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT7_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT7_Clear = 0x1
	// Position of ENDISOOUT field.
	USBD_INTENCLR_ENDISOOUT_Pos = 0x14
	// Bit mask of ENDISOOUT field.
	USBD_INTENCLR_ENDISOOUT_Msk = 0x100000
	// Bit ENDISOOUT.
	USBD_INTENCLR_ENDISOOUT = 0x100000
	// Read: Disabled
	USBD_INTENCLR_ENDISOOUT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDISOOUT_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDISOOUT_Clear = 0x1
	// Position of SOF field.
	USBD_INTENCLR_SOF_Pos = 0x15
	// Bit mask of SOF field.
	USBD_INTENCLR_SOF_Msk = 0x200000
	// Bit SOF.
	USBD_INTENCLR_SOF = 0x200000
	// Read: Disabled
	USBD_INTENCLR_SOF_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_SOF_Enabled = 0x1
	// Disable
	USBD_INTENCLR_SOF_Clear = 0x1
	// Position of USBEVENT field.
	USBD_INTENCLR_USBEVENT_Pos = 0x16
	// Bit mask of USBEVENT field.
	USBD_INTENCLR_USBEVENT_Msk = 0x400000
	// Bit USBEVENT.
	USBD_INTENCLR_USBEVENT = 0x400000
	// Read: Disabled
	USBD_INTENCLR_USBEVENT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_USBEVENT_Enabled = 0x1
	// Disable
	USBD_INTENCLR_USBEVENT_Clear = 0x1
	// Position of EP0SETUP field.
	USBD_INTENCLR_EP0SETUP_Pos = 0x17
	// Bit mask of EP0SETUP field.
	USBD_INTENCLR_EP0SETUP_Msk = 0x800000
	// Bit EP0SETUP.
	USBD_INTENCLR_EP0SETUP = 0x800000
	// Read: Disabled
	USBD_INTENCLR_EP0SETUP_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_EP0SETUP_Enabled = 0x1
	// Disable
	USBD_INTENCLR_EP0SETUP_Clear = 0x1
	// Position of EPDATA field.
	USBD_INTENCLR_EPDATA_Pos = 0x18
	// Bit mask of EPDATA field.
	USBD_INTENCLR_EPDATA_Msk = 0x1000000
	// Bit EPDATA.
	USBD_INTENCLR_EPDATA = 0x1000000
	// Read: Disabled
	USBD_INTENCLR_EPDATA_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_EPDATA_Enabled = 0x1
	// Disable
	USBD_INTENCLR_EPDATA_Clear = 0x1

	// EVENTCAUSE: Details on what caused the USBEVENT event
	// Position of ISOOUTCRC field.
	USBD_EVENTCAUSE_ISOOUTCRC_Pos = 0x0
	// Bit mask of ISOOUTCRC field.
	USBD_EVENTCAUSE_ISOOUTCRC_Msk = 0x1
	// Bit ISOOUTCRC.
	USBD_EVENTCAUSE_ISOOUTCRC = 0x1
	// No error detected
	USBD_EVENTCAUSE_ISOOUTCRC_NotDetected = 0x0
	// Error detected
	USBD_EVENTCAUSE_ISOOUTCRC_Detected = 0x1
	// Position of SUSPEND field.
	USBD_EVENTCAUSE_SUSPEND_Pos = 0x8
	// Bit mask of SUSPEND field.
	USBD_EVENTCAUSE_SUSPEND_Msk = 0x100
	// Bit SUSPEND.
	USBD_EVENTCAUSE_SUSPEND = 0x100
	// Suspend not detected
	USBD_EVENTCAUSE_SUSPEND_NotDetected = 0x0
	// Suspend detected
	USBD_EVENTCAUSE_SUSPEND_Detected = 0x1
	// Position of RESUME field.
	USBD_EVENTCAUSE_RESUME_Pos = 0x9
	// Bit mask of RESUME field.
	USBD_EVENTCAUSE_RESUME_Msk = 0x200
	// Bit RESUME.
	USBD_EVENTCAUSE_RESUME = 0x200
	// Resume not detected
	USBD_EVENTCAUSE_RESUME_NotDetected = 0x0
	// Resume detected
	USBD_EVENTCAUSE_RESUME_Detected = 0x1
	// Position of USBWUALLOWED field.
	USBD_EVENTCAUSE_USBWUALLOWED_Pos = 0xa
	// Bit mask of USBWUALLOWED field.
	USBD_EVENTCAUSE_USBWUALLOWED_Msk = 0x400
	// Bit USBWUALLOWED.
	USBD_EVENTCAUSE_USBWUALLOWED = 0x400
	// Wake up not allowed
	USBD_EVENTCAUSE_USBWUALLOWED_NotAllowed = 0x0
	// Wake up allowed
	USBD_EVENTCAUSE_USBWUALLOWED_Allowed = 0x1
	// Position of READY field.
	USBD_EVENTCAUSE_READY_Pos = 0xb
	// Bit mask of READY field.
	USBD_EVENTCAUSE_READY_Msk = 0x800
	// Bit READY.
	USBD_EVENTCAUSE_READY = 0x800
	// USBEVENT was not issued due to USBD peripheral ready
	USBD_EVENTCAUSE_READY_NotDetected = 0x0
	// USBD peripheral is ready
	USBD_EVENTCAUSE_READY_Ready = 0x1

	// HALTED.EPIN: Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint.
	// Position of GETSTATUS field.
	USBD_HALTED_EPIN_GETSTATUS_Pos = 0x0
	// Bit mask of GETSTATUS field.
	USBD_HALTED_EPIN_GETSTATUS_Msk = 0xffff
	// Endpoint is not halted
	USBD_HALTED_EPIN_GETSTATUS_NotHalted = 0x0
	// Endpoint is halted
	USBD_HALTED_EPIN_GETSTATUS_Halted = 0x1

	// HALTED.EPOUT: Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint.
	// Position of GETSTATUS field.
	USBD_HALTED_EPOUT_GETSTATUS_Pos = 0x0
	// Bit mask of GETSTATUS field.
	USBD_HALTED_EPOUT_GETSTATUS_Msk = 0xffff
	// Endpoint is not halted
	USBD_HALTED_EPOUT_GETSTATUS_NotHalted = 0x0
	// Endpoint is halted
	USBD_HALTED_EPOUT_GETSTATUS_Halted = 0x1

	// EPSTATUS: Provides information on which endpoint's EasyDMA registers have been captured
	// Position of EPIN0 field.
	USBD_EPSTATUS_EPIN0_Pos = 0x0
	// Bit mask of EPIN0 field.
	USBD_EPSTATUS_EPIN0_Msk = 0x1
	// Bit EPIN0.
	USBD_EPSTATUS_EPIN0 = 0x1
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN0_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN0_DataDone = 0x1
	// Position of EPIN1 field.
	USBD_EPSTATUS_EPIN1_Pos = 0x1
	// Bit mask of EPIN1 field.
	USBD_EPSTATUS_EPIN1_Msk = 0x2
	// Bit EPIN1.
	USBD_EPSTATUS_EPIN1 = 0x2
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN1_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN1_DataDone = 0x1
	// Position of EPIN2 field.
	USBD_EPSTATUS_EPIN2_Pos = 0x2
	// Bit mask of EPIN2 field.
	USBD_EPSTATUS_EPIN2_Msk = 0x4
	// Bit EPIN2.
	USBD_EPSTATUS_EPIN2 = 0x4
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN2_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN2_DataDone = 0x1
	// Position of EPIN3 field.
	USBD_EPSTATUS_EPIN3_Pos = 0x3
	// Bit mask of EPIN3 field.
	USBD_EPSTATUS_EPIN3_Msk = 0x8
	// Bit EPIN3.
	USBD_EPSTATUS_EPIN3 = 0x8
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN3_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN3_DataDone = 0x1
	// Position of EPIN4 field.
	USBD_EPSTATUS_EPIN4_Pos = 0x4
	// Bit mask of EPIN4 field.
	USBD_EPSTATUS_EPIN4_Msk = 0x10
	// Bit EPIN4.
	USBD_EPSTATUS_EPIN4 = 0x10
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN4_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN4_DataDone = 0x1
	// Position of EPIN5 field.
	USBD_EPSTATUS_EPIN5_Pos = 0x5
	// Bit mask of EPIN5 field.
	USBD_EPSTATUS_EPIN5_Msk = 0x20
	// Bit EPIN5.
	USBD_EPSTATUS_EPIN5 = 0x20
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN5_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN5_DataDone = 0x1
	// Position of EPIN6 field.
	USBD_EPSTATUS_EPIN6_Pos = 0x6
	// Bit mask of EPIN6 field.
	USBD_EPSTATUS_EPIN6_Msk = 0x40
	// Bit EPIN6.
	USBD_EPSTATUS_EPIN6 = 0x40
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN6_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN6_DataDone = 0x1
	// Position of EPIN7 field.
	USBD_EPSTATUS_EPIN7_Pos = 0x7
	// Bit mask of EPIN7 field.
	USBD_EPSTATUS_EPIN7_Msk = 0x80
	// Bit EPIN7.
	USBD_EPSTATUS_EPIN7 = 0x80
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN7_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN7_DataDone = 0x1
	// Position of EPIN8 field.
	USBD_EPSTATUS_EPIN8_Pos = 0x8
	// Bit mask of EPIN8 field.
	USBD_EPSTATUS_EPIN8_Msk = 0x100
	// Bit EPIN8.
	USBD_EPSTATUS_EPIN8 = 0x100
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN8_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN8_DataDone = 0x1
	// Position of EPOUT0 field.
	USBD_EPSTATUS_EPOUT0_Pos = 0x10
	// Bit mask of EPOUT0 field.
	USBD_EPSTATUS_EPOUT0_Msk = 0x10000
	// Bit EPOUT0.
	USBD_EPSTATUS_EPOUT0 = 0x10000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT0_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT0_DataDone = 0x1
	// Position of EPOUT1 field.
	USBD_EPSTATUS_EPOUT1_Pos = 0x11
	// Bit mask of EPOUT1 field.
	USBD_EPSTATUS_EPOUT1_Msk = 0x20000
	// Bit EPOUT1.
	USBD_EPSTATUS_EPOUT1 = 0x20000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT1_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT1_DataDone = 0x1
	// Position of EPOUT2 field.
	USBD_EPSTATUS_EPOUT2_Pos = 0x12
	// Bit mask of EPOUT2 field.
	USBD_EPSTATUS_EPOUT2_Msk = 0x40000
	// Bit EPOUT2.
	USBD_EPSTATUS_EPOUT2 = 0x40000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT2_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT2_DataDone = 0x1
	// Position of EPOUT3 field.
	USBD_EPSTATUS_EPOUT3_Pos = 0x13
	// Bit mask of EPOUT3 field.
	USBD_EPSTATUS_EPOUT3_Msk = 0x80000
	// Bit EPOUT3.
	USBD_EPSTATUS_EPOUT3 = 0x80000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT3_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT3_DataDone = 0x1
	// Position of EPOUT4 field.
	USBD_EPSTATUS_EPOUT4_Pos = 0x14
	// Bit mask of EPOUT4 field.
	USBD_EPSTATUS_EPOUT4_Msk = 0x100000
	// Bit EPOUT4.
	USBD_EPSTATUS_EPOUT4 = 0x100000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT4_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT4_DataDone = 0x1
	// Position of EPOUT5 field.
	USBD_EPSTATUS_EPOUT5_Pos = 0x15
	// Bit mask of EPOUT5 field.
	USBD_EPSTATUS_EPOUT5_Msk = 0x200000
	// Bit EPOUT5.
	USBD_EPSTATUS_EPOUT5 = 0x200000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT5_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT5_DataDone = 0x1
	// Position of EPOUT6 field.
	USBD_EPSTATUS_EPOUT6_Pos = 0x16
	// Bit mask of EPOUT6 field.
	USBD_EPSTATUS_EPOUT6_Msk = 0x400000
	// Bit EPOUT6.
	USBD_EPSTATUS_EPOUT6 = 0x400000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT6_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT6_DataDone = 0x1
	// Position of EPOUT7 field.
	USBD_EPSTATUS_EPOUT7_Pos = 0x17
	// Bit mask of EPOUT7 field.
	USBD_EPSTATUS_EPOUT7_Msk = 0x800000
	// Bit EPOUT7.
	USBD_EPSTATUS_EPOUT7 = 0x800000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT7_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT7_DataDone = 0x1
	// Position of EPOUT8 field.
	USBD_EPSTATUS_EPOUT8_Pos = 0x18
	// Bit mask of EPOUT8 field.
	USBD_EPSTATUS_EPOUT8_Msk = 0x1000000
	// Bit EPOUT8.
	USBD_EPSTATUS_EPOUT8 = 0x1000000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT8_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT8_DataDone = 0x1

	// EPDATASTATUS: Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)
	// Position of EPIN1 field.
	USBD_EPDATASTATUS_EPIN1_Pos = 0x1
	// Bit mask of EPIN1 field.
	USBD_EPDATASTATUS_EPIN1_Msk = 0x2
	// Bit EPIN1.
	USBD_EPDATASTATUS_EPIN1 = 0x2
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN1_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN1_DataDone = 0x1
	// Position of EPIN2 field.
	USBD_EPDATASTATUS_EPIN2_Pos = 0x2
	// Bit mask of EPIN2 field.
	USBD_EPDATASTATUS_EPIN2_Msk = 0x4
	// Bit EPIN2.
	USBD_EPDATASTATUS_EPIN2 = 0x4
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN2_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN2_DataDone = 0x1
	// Position of EPIN3 field.
	USBD_EPDATASTATUS_EPIN3_Pos = 0x3
	// Bit mask of EPIN3 field.
	USBD_EPDATASTATUS_EPIN3_Msk = 0x8
	// Bit EPIN3.
	USBD_EPDATASTATUS_EPIN3 = 0x8
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN3_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN3_DataDone = 0x1
	// Position of EPIN4 field.
	USBD_EPDATASTATUS_EPIN4_Pos = 0x4
	// Bit mask of EPIN4 field.
	USBD_EPDATASTATUS_EPIN4_Msk = 0x10
	// Bit EPIN4.
	USBD_EPDATASTATUS_EPIN4 = 0x10
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN4_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN4_DataDone = 0x1
	// Position of EPIN5 field.
	USBD_EPDATASTATUS_EPIN5_Pos = 0x5
	// Bit mask of EPIN5 field.
	USBD_EPDATASTATUS_EPIN5_Msk = 0x20
	// Bit EPIN5.
	USBD_EPDATASTATUS_EPIN5 = 0x20
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN5_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN5_DataDone = 0x1
	// Position of EPIN6 field.
	USBD_EPDATASTATUS_EPIN6_Pos = 0x6
	// Bit mask of EPIN6 field.
	USBD_EPDATASTATUS_EPIN6_Msk = 0x40
	// Bit EPIN6.
	USBD_EPDATASTATUS_EPIN6 = 0x40
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN6_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN6_DataDone = 0x1
	// Position of EPIN7 field.
	USBD_EPDATASTATUS_EPIN7_Pos = 0x7
	// Bit mask of EPIN7 field.
	USBD_EPDATASTATUS_EPIN7_Msk = 0x80
	// Bit EPIN7.
	USBD_EPDATASTATUS_EPIN7 = 0x80
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN7_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN7_DataDone = 0x1
	// Position of EPOUT1 field.
	USBD_EPDATASTATUS_EPOUT1_Pos = 0x11
	// Bit mask of EPOUT1 field.
	USBD_EPDATASTATUS_EPOUT1_Msk = 0x20000
	// Bit EPOUT1.
	USBD_EPDATASTATUS_EPOUT1 = 0x20000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT1_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT1_Started = 0x1
	// Position of EPOUT2 field.
	USBD_EPDATASTATUS_EPOUT2_Pos = 0x12
	// Bit mask of EPOUT2 field.
	USBD_EPDATASTATUS_EPOUT2_Msk = 0x40000
	// Bit EPOUT2.
	USBD_EPDATASTATUS_EPOUT2 = 0x40000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT2_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT2_Started = 0x1
	// Position of EPOUT3 field.
	USBD_EPDATASTATUS_EPOUT3_Pos = 0x13
	// Bit mask of EPOUT3 field.
	USBD_EPDATASTATUS_EPOUT3_Msk = 0x80000
	// Bit EPOUT3.
	USBD_EPDATASTATUS_EPOUT3 = 0x80000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT3_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT3_Started = 0x1
	// Position of EPOUT4 field.
	USBD_EPDATASTATUS_EPOUT4_Pos = 0x14
	// Bit mask of EPOUT4 field.
	USBD_EPDATASTATUS_EPOUT4_Msk = 0x100000
	// Bit EPOUT4.
	USBD_EPDATASTATUS_EPOUT4 = 0x100000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT4_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT4_Started = 0x1
	// Position of EPOUT5 field.
	USBD_EPDATASTATUS_EPOUT5_Pos = 0x15
	// Bit mask of EPOUT5 field.
	USBD_EPDATASTATUS_EPOUT5_Msk = 0x200000
	// Bit EPOUT5.
	USBD_EPDATASTATUS_EPOUT5 = 0x200000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT5_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT5_Started = 0x1
	// Position of EPOUT6 field.
	USBD_EPDATASTATUS_EPOUT6_Pos = 0x16
	// Bit mask of EPOUT6 field.
	USBD_EPDATASTATUS_EPOUT6_Msk = 0x400000
	// Bit EPOUT6.
	USBD_EPDATASTATUS_EPOUT6 = 0x400000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT6_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT6_Started = 0x1
	// Position of EPOUT7 field.
	USBD_EPDATASTATUS_EPOUT7_Pos = 0x17
	// Bit mask of EPOUT7 field.
	USBD_EPDATASTATUS_EPOUT7_Msk = 0x800000
	// Bit EPOUT7.
	USBD_EPDATASTATUS_EPOUT7 = 0x800000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT7_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT7_Started = 0x1

	// USBADDR: Device USB address
	// Position of ADDR field.
	USBD_USBADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	USBD_USBADDR_ADDR_Msk = 0x7f

	// BMREQUESTTYPE: SETUP data, byte 0, bmRequestType
	// Position of RECIPIENT field.
	USBD_BMREQUESTTYPE_RECIPIENT_Pos = 0x0
	// Bit mask of RECIPIENT field.
	USBD_BMREQUESTTYPE_RECIPIENT_Msk = 0x1f
	// Device
	USBD_BMREQUESTTYPE_RECIPIENT_Device = 0x0
	// Interface
	USBD_BMREQUESTTYPE_RECIPIENT_Interface = 0x1
	// Endpoint
	USBD_BMREQUESTTYPE_RECIPIENT_Endpoint = 0x2
	// Other
	USBD_BMREQUESTTYPE_RECIPIENT_Other = 0x3
	// Position of TYPE field.
	USBD_BMREQUESTTYPE_TYPE_Pos = 0x5
	// Bit mask of TYPE field.
	USBD_BMREQUESTTYPE_TYPE_Msk = 0x60
	// Standard
	USBD_BMREQUESTTYPE_TYPE_Standard = 0x0
	// Class
	USBD_BMREQUESTTYPE_TYPE_Class = 0x1
	// Vendor
	USBD_BMREQUESTTYPE_TYPE_Vendor = 0x2
	// Position of DIRECTION field.
	USBD_BMREQUESTTYPE_DIRECTION_Pos = 0x7
	// Bit mask of DIRECTION field.
	USBD_BMREQUESTTYPE_DIRECTION_Msk = 0x80
	// Bit DIRECTION.
	USBD_BMREQUESTTYPE_DIRECTION = 0x80
	// Host-to-device
	USBD_BMREQUESTTYPE_DIRECTION_HostToDevice = 0x0
	// Device-to-host
	USBD_BMREQUESTTYPE_DIRECTION_DeviceToHost = 0x1

	// BREQUEST: SETUP data, byte 1, bRequest
	// Position of BREQUEST field.
	USBD_BREQUEST_BREQUEST_Pos = 0x0
	// Bit mask of BREQUEST field.
	USBD_BREQUEST_BREQUEST_Msk = 0xff
	// Standard request GET_STATUS
	USBD_BREQUEST_BREQUEST_STD_GET_STATUS = 0x0
	// Standard request CLEAR_FEATURE
	USBD_BREQUEST_BREQUEST_STD_CLEAR_FEATURE = 0x1
	// Standard request SET_FEATURE
	USBD_BREQUEST_BREQUEST_STD_SET_FEATURE = 0x3
	// Standard request SET_ADDRESS
	USBD_BREQUEST_BREQUEST_STD_SET_ADDRESS = 0x5
	// Standard request GET_DESCRIPTOR
	USBD_BREQUEST_BREQUEST_STD_GET_DESCRIPTOR = 0x6
	// Standard request SET_DESCRIPTOR
	USBD_BREQUEST_BREQUEST_STD_SET_DESCRIPTOR = 0x7
	// Standard request GET_CONFIGURATION
	USBD_BREQUEST_BREQUEST_STD_GET_CONFIGURATION = 0x8
	// Standard request SET_CONFIGURATION
	USBD_BREQUEST_BREQUEST_STD_SET_CONFIGURATION = 0x9
	// Standard request GET_INTERFACE
	USBD_BREQUEST_BREQUEST_STD_GET_INTERFACE = 0xa
	// Standard request SET_INTERFACE
	USBD_BREQUEST_BREQUEST_STD_SET_INTERFACE = 0xb
	// Standard request SYNCH_FRAME
	USBD_BREQUEST_BREQUEST_STD_SYNCH_FRAME = 0xc

	// WVALUEL: SETUP data, byte 2, LSB of wValue
	// Position of WVALUEL field.
	USBD_WVALUEL_WVALUEL_Pos = 0x0
	// Bit mask of WVALUEL field.
	USBD_WVALUEL_WVALUEL_Msk = 0xff

	// WVALUEH: SETUP data, byte 3, MSB of wValue
	// Position of WVALUEH field.
	USBD_WVALUEH_WVALUEH_Pos = 0x0
	// Bit mask of WVALUEH field.
	USBD_WVALUEH_WVALUEH_Msk = 0xff

	// WINDEXL: SETUP data, byte 4, LSB of wIndex
	// Position of WINDEXL field.
	USBD_WINDEXL_WINDEXL_Pos = 0x0
	// Bit mask of WINDEXL field.
	USBD_WINDEXL_WINDEXL_Msk = 0xff

	// WINDEXH: SETUP data, byte 5, MSB of wIndex
	// Position of WINDEXH field.
	USBD_WINDEXH_WINDEXH_Pos = 0x0
	// Bit mask of WINDEXH field.
	USBD_WINDEXH_WINDEXH_Msk = 0xff

	// WLENGTHL: SETUP data, byte 6, LSB of wLength
	// Position of WLENGTHL field.
	USBD_WLENGTHL_WLENGTHL_Pos = 0x0
	// Bit mask of WLENGTHL field.
	USBD_WLENGTHL_WLENGTHL_Msk = 0xff

	// WLENGTHH: SETUP data, byte 7, MSB of wLength
	// Position of WLENGTHH field.
	USBD_WLENGTHH_WLENGTHH_Pos = 0x0
	// Bit mask of WLENGTHH field.
	USBD_WLENGTHH_WLENGTHH_Msk = 0xff

	// SIZE.EPOUT: Description collection: Number of bytes received last in the data stage of this OUT endpoint
	// Position of SIZE field.
	USBD_SIZE_EPOUT_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	USBD_SIZE_EPOUT_SIZE_Msk = 0x7f

	// SIZE.ISOOUT: Number of bytes received last on this ISO OUT data endpoint
	// Position of SIZE field.
	USBD_SIZE_ISOOUT_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	USBD_SIZE_ISOOUT_SIZE_Msk = 0x3ff
	// Position of ZERO field.
	USBD_SIZE_ISOOUT_ZERO_Pos = 0x10
	// Bit mask of ZERO field.
	USBD_SIZE_ISOOUT_ZERO_Msk = 0x10000
	// Bit ZERO.
	USBD_SIZE_ISOOUT_ZERO = 0x10000
	// No zero-length data received, use value in SIZE
	USBD_SIZE_ISOOUT_ZERO_Normal = 0x0
	// Zero-length data received, ignore value in SIZE
	USBD_SIZE_ISOOUT_ZERO_ZeroData = 0x1

	// ENABLE: Enable USB
	// Position of ENABLE field.
	USBD_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	USBD_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	USBD_ENABLE_ENABLE = 0x1
	// USB peripheral is disabled
	USBD_ENABLE_ENABLE_Disabled = 0x0
	// USB peripheral is enabled
	USBD_ENABLE_ENABLE_Enabled = 0x1

	// USBPULLUP: Control of the USB pull-up
	// Position of CONNECT field.
	USBD_USBPULLUP_CONNECT_Pos = 0x0
	// Bit mask of CONNECT field.
	USBD_USBPULLUP_CONNECT_Msk = 0x1
	// Bit CONNECT.
	USBD_USBPULLUP_CONNECT = 0x1
	// Pull-up is disconnected
	USBD_USBPULLUP_CONNECT_Disabled = 0x0
	// Pull-up is connected to D+
	USBD_USBPULLUP_CONNECT_Enabled = 0x1

	// DPDMVALUE: State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing).
	// Position of STATE field.
	USBD_DPDMVALUE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	USBD_DPDMVALUE_STATE_Msk = 0x1f
	// D+ forced low, D- forced high (K state) for a timing preset in hardware (50 us or 5 ms, depending on bus state)
	USBD_DPDMVALUE_STATE_Resume = 0x1
	// D+ forced high, D- forced low (J state)
	USBD_DPDMVALUE_STATE_J = 0x2
	// D+ forced low, D- forced high (K state)
	USBD_DPDMVALUE_STATE_K = 0x4

	// DTOGGLE: Data toggle control and status
	// Position of EP field.
	USBD_DTOGGLE_EP_Pos = 0x0
	// Bit mask of EP field.
	USBD_DTOGGLE_EP_Msk = 0x7
	// Position of IO field.
	USBD_DTOGGLE_IO_Pos = 0x7
	// Bit mask of IO field.
	USBD_DTOGGLE_IO_Msk = 0x80
	// Bit IO.
	USBD_DTOGGLE_IO = 0x80
	// Selects OUT endpoint
	USBD_DTOGGLE_IO_Out = 0x0
	// Selects IN endpoint
	USBD_DTOGGLE_IO_In = 0x1
	// Position of VALUE field.
	USBD_DTOGGLE_VALUE_Pos = 0x8
	// Bit mask of VALUE field.
	USBD_DTOGGLE_VALUE_Msk = 0x300
	// No action on data toggle when writing the register with this value
	USBD_DTOGGLE_VALUE_Nop = 0x0
	// Data toggle is DATA0 on endpoint set by EP and IO
	USBD_DTOGGLE_VALUE_Data0 = 0x1
	// Data toggle is DATA1 on endpoint set by EP and IO
	USBD_DTOGGLE_VALUE_Data1 = 0x2

	// EPINEN: Endpoint IN enable
	// Position of IN0 field.
	USBD_EPINEN_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	USBD_EPINEN_IN0_Msk = 0x1
	// Bit IN0.
	USBD_EPINEN_IN0 = 0x1
	// Disable endpoint IN 0 (no response to IN tokens)
	USBD_EPINEN_IN0_Disable = 0x0
	// Enable endpoint IN 0 (response to IN tokens)
	USBD_EPINEN_IN0_Enable = 0x1
	// Position of IN1 field.
	USBD_EPINEN_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	USBD_EPINEN_IN1_Msk = 0x2
	// Bit IN1.
	USBD_EPINEN_IN1 = 0x2
	// Disable endpoint IN 1 (no response to IN tokens)
	USBD_EPINEN_IN1_Disable = 0x0
	// Enable endpoint IN 1 (response to IN tokens)
	USBD_EPINEN_IN1_Enable = 0x1
	// Position of IN2 field.
	USBD_EPINEN_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	USBD_EPINEN_IN2_Msk = 0x4
	// Bit IN2.
	USBD_EPINEN_IN2 = 0x4
	// Disable endpoint IN 2 (no response to IN tokens)
	USBD_EPINEN_IN2_Disable = 0x0
	// Enable endpoint IN 2 (response to IN tokens)
	USBD_EPINEN_IN2_Enable = 0x1
	// Position of IN3 field.
	USBD_EPINEN_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	USBD_EPINEN_IN3_Msk = 0x8
	// Bit IN3.
	USBD_EPINEN_IN3 = 0x8
	// Disable endpoint IN 3 (no response to IN tokens)
	USBD_EPINEN_IN3_Disable = 0x0
	// Enable endpoint IN 3 (response to IN tokens)
	USBD_EPINEN_IN3_Enable = 0x1
	// Position of IN4 field.
	USBD_EPINEN_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	USBD_EPINEN_IN4_Msk = 0x10
	// Bit IN4.
	USBD_EPINEN_IN4 = 0x10
	// Disable endpoint IN 4 (no response to IN tokens)
	USBD_EPINEN_IN4_Disable = 0x0
	// Enable endpoint IN 4 (response to IN tokens)
	USBD_EPINEN_IN4_Enable = 0x1
	// Position of IN5 field.
	USBD_EPINEN_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	USBD_EPINEN_IN5_Msk = 0x20
	// Bit IN5.
	USBD_EPINEN_IN5 = 0x20
	// Disable endpoint IN 5 (no response to IN tokens)
	USBD_EPINEN_IN5_Disable = 0x0
	// Enable endpoint IN 5 (response to IN tokens)
	USBD_EPINEN_IN5_Enable = 0x1
	// Position of IN6 field.
	USBD_EPINEN_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	USBD_EPINEN_IN6_Msk = 0x40
	// Bit IN6.
	USBD_EPINEN_IN6 = 0x40
	// Disable endpoint IN 6 (no response to IN tokens)
	USBD_EPINEN_IN6_Disable = 0x0
	// Enable endpoint IN 6 (response to IN tokens)
	USBD_EPINEN_IN6_Enable = 0x1
	// Position of IN7 field.
	USBD_EPINEN_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	USBD_EPINEN_IN7_Msk = 0x80
	// Bit IN7.
	USBD_EPINEN_IN7 = 0x80
	// Disable endpoint IN 7 (no response to IN tokens)
	USBD_EPINEN_IN7_Disable = 0x0
	// Enable endpoint IN 7 (response to IN tokens)
	USBD_EPINEN_IN7_Enable = 0x1
	// Position of ISOIN field.
	USBD_EPINEN_ISOIN_Pos = 0x8
	// Bit mask of ISOIN field.
	USBD_EPINEN_ISOIN_Msk = 0x100
	// Bit ISOIN.
	USBD_EPINEN_ISOIN = 0x100
	// Disable ISO IN endpoint 8
	USBD_EPINEN_ISOIN_Disable = 0x0
	// Enable ISO IN endpoint 8
	USBD_EPINEN_ISOIN_Enable = 0x1

	// EPOUTEN: Endpoint OUT enable
	// Position of OUT0 field.
	USBD_EPOUTEN_OUT0_Pos = 0x0
	// Bit mask of OUT0 field.
	USBD_EPOUTEN_OUT0_Msk = 0x1
	// Bit OUT0.
	USBD_EPOUTEN_OUT0 = 0x1
	// Disable endpoint OUT 0 (no response to OUT tokens)
	USBD_EPOUTEN_OUT0_Disable = 0x0
	// Enable endpoint OUT 0 (response to OUT tokens)
	USBD_EPOUTEN_OUT0_Enable = 0x1
	// Position of OUT1 field.
	USBD_EPOUTEN_OUT1_Pos = 0x1
	// Bit mask of OUT1 field.
	USBD_EPOUTEN_OUT1_Msk = 0x2
	// Bit OUT1.
	USBD_EPOUTEN_OUT1 = 0x2
	// Disable endpoint OUT 1 (no response to OUT tokens)
	USBD_EPOUTEN_OUT1_Disable = 0x0
	// Enable endpoint OUT 1 (response to OUT tokens)
	USBD_EPOUTEN_OUT1_Enable = 0x1
	// Position of OUT2 field.
	USBD_EPOUTEN_OUT2_Pos = 0x2
	// Bit mask of OUT2 field.
	USBD_EPOUTEN_OUT2_Msk = 0x4
	// Bit OUT2.
	USBD_EPOUTEN_OUT2 = 0x4
	// Disable endpoint OUT 2 (no response to OUT tokens)
	USBD_EPOUTEN_OUT2_Disable = 0x0
	// Enable endpoint OUT 2 (response to OUT tokens)
	USBD_EPOUTEN_OUT2_Enable = 0x1
	// Position of OUT3 field.
	USBD_EPOUTEN_OUT3_Pos = 0x3
	// Bit mask of OUT3 field.
	USBD_EPOUTEN_OUT3_Msk = 0x8
	// Bit OUT3.
	USBD_EPOUTEN_OUT3 = 0x8
	// Disable endpoint OUT 3 (no response to OUT tokens)
	USBD_EPOUTEN_OUT3_Disable = 0x0
	// Enable endpoint OUT 3 (response to OUT tokens)
	USBD_EPOUTEN_OUT3_Enable = 0x1
	// Position of OUT4 field.
	USBD_EPOUTEN_OUT4_Pos = 0x4
	// Bit mask of OUT4 field.
	USBD_EPOUTEN_OUT4_Msk = 0x10
	// Bit OUT4.
	USBD_EPOUTEN_OUT4 = 0x10
	// Disable endpoint OUT 4 (no response to OUT tokens)
	USBD_EPOUTEN_OUT4_Disable = 0x0
	// Enable endpoint OUT 4 (response to OUT tokens)
	USBD_EPOUTEN_OUT4_Enable = 0x1
	// Position of OUT5 field.
	USBD_EPOUTEN_OUT5_Pos = 0x5
	// Bit mask of OUT5 field.
	USBD_EPOUTEN_OUT5_Msk = 0x20
	// Bit OUT5.
	USBD_EPOUTEN_OUT5 = 0x20
	// Disable endpoint OUT 5 (no response to OUT tokens)
	USBD_EPOUTEN_OUT5_Disable = 0x0
	// Enable endpoint OUT 5 (response to OUT tokens)
	USBD_EPOUTEN_OUT5_Enable = 0x1
	// Position of OUT6 field.
	USBD_EPOUTEN_OUT6_Pos = 0x6
	// Bit mask of OUT6 field.
	USBD_EPOUTEN_OUT6_Msk = 0x40
	// Bit OUT6.
	USBD_EPOUTEN_OUT6 = 0x40
	// Disable endpoint OUT 6 (no response to OUT tokens)
	USBD_EPOUTEN_OUT6_Disable = 0x0
	// Enable endpoint OUT 6 (response to OUT tokens)
	USBD_EPOUTEN_OUT6_Enable = 0x1
	// Position of OUT7 field.
	USBD_EPOUTEN_OUT7_Pos = 0x7
	// Bit mask of OUT7 field.
	USBD_EPOUTEN_OUT7_Msk = 0x80
	// Bit OUT7.
	USBD_EPOUTEN_OUT7 = 0x80
	// Disable endpoint OUT 7 (no response to OUT tokens)
	USBD_EPOUTEN_OUT7_Disable = 0x0
	// Enable endpoint OUT 7 (response to OUT tokens)
	USBD_EPOUTEN_OUT7_Enable = 0x1
	// Position of ISOOUT field.
	USBD_EPOUTEN_ISOOUT_Pos = 0x8
	// Bit mask of ISOOUT field.
	USBD_EPOUTEN_ISOOUT_Msk = 0x100
	// Bit ISOOUT.
	USBD_EPOUTEN_ISOOUT = 0x100
	// Disable ISO OUT endpoint 8
	USBD_EPOUTEN_ISOOUT_Disable = 0x0
	// Enable ISO OUT endpoint 8
	USBD_EPOUTEN_ISOOUT_Enable = 0x1

	// EPSTALL: STALL endpoints
	// Position of EP field.
	USBD_EPSTALL_EP_Pos = 0x0
	// Bit mask of EP field.
	USBD_EPSTALL_EP_Msk = 0x7
	// Position of IO field.
	USBD_EPSTALL_IO_Pos = 0x7
	// Bit mask of IO field.
	USBD_EPSTALL_IO_Msk = 0x80
	// Bit IO.
	USBD_EPSTALL_IO = 0x80
	// Selects OUT endpoint
	USBD_EPSTALL_IO_Out = 0x0
	// Selects IN endpoint
	USBD_EPSTALL_IO_In = 0x1
	// Position of STALL field.
	USBD_EPSTALL_STALL_Pos = 0x8
	// Bit mask of STALL field.
	USBD_EPSTALL_STALL_Msk = 0x100
	// Bit STALL.
	USBD_EPSTALL_STALL = 0x100
	// Don't stall selected endpoint
	USBD_EPSTALL_STALL_UnStall = 0x0
	// Stall selected endpoint
	USBD_EPSTALL_STALL_Stall = 0x1

	// ISOSPLIT: Controls the split of ISO buffers
	// Position of SPLIT field.
	USBD_ISOSPLIT_SPLIT_Pos = 0x0
	// Bit mask of SPLIT field.
	USBD_ISOSPLIT_SPLIT_Msk = 0xffff
	// Full buffer dedicated to either iso IN or OUT
	USBD_ISOSPLIT_SPLIT_OneDir = 0x0
	// Lower half for IN, upper half for OUT
	USBD_ISOSPLIT_SPLIT_HalfIN = 0x80

	// FRAMECNTR: Returns the current value of the start of frame counter
	// Position of FRAMECNTR field.
	USBD_FRAMECNTR_FRAMECNTR_Pos = 0x0
	// Bit mask of FRAMECNTR field.
	USBD_FRAMECNTR_FRAMECNTR_Msk = 0x7ff

	// LOWPOWER: Controls USBD peripheral low power mode during USB suspend
	// Position of LOWPOWER field.
	USBD_LOWPOWER_LOWPOWER_Pos = 0x0
	// Bit mask of LOWPOWER field.
	USBD_LOWPOWER_LOWPOWER_Msk = 0x1
	// Bit LOWPOWER.
	USBD_LOWPOWER_LOWPOWER = 0x1
	// Software must write this value to exit low power mode and before performing a remote wake-up
	USBD_LOWPOWER_LOWPOWER_ForceNormal = 0x0
	// Software must write this value to enter low power mode after DMA and software have finished interacting with the USB peripheral
	USBD_LOWPOWER_LOWPOWER_LowPower = 0x1

	// ISOINCONFIG: Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
	// Position of RESPONSE field.
	USBD_ISOINCONFIG_RESPONSE_Pos = 0x0
	// Bit mask of RESPONSE field.
	USBD_ISOINCONFIG_RESPONSE_Msk = 0x1
	// Bit RESPONSE.
	USBD_ISOINCONFIG_RESPONSE = 0x1
	// Endpoint does not respond in that case
	USBD_ISOINCONFIG_RESPONSE_NoResp = 0x0
	// Endpoint responds with a zero-length data packet in that case
	USBD_ISOINCONFIG_RESPONSE_ZeroData = 0x1

	// EPIN.PTR: Description cluster: Data pointer
	// Position of PTR field.
	USBD_EPIN_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_EPIN_PTR_PTR_Msk = 0xffffffff

	// EPIN.MAXCNT: Description cluster: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_EPIN_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_EPIN_MAXCNT_MAXCNT_Msk = 0x7f

	// EPIN.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_EPIN_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_EPIN_AMOUNT_AMOUNT_Msk = 0x7f

	// ISOIN.PTR: Data pointer
	// Position of PTR field.
	USBD_ISOIN_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_ISOIN_PTR_PTR_Msk = 0xffffffff

	// ISOIN.MAXCNT: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_ISOIN_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_ISOIN_MAXCNT_MAXCNT_Msk = 0x3ff

	// ISOIN.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_ISOIN_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_ISOIN_AMOUNT_AMOUNT_Msk = 0x3ff

	// EPOUT.PTR: Description cluster: Data pointer
	// Position of PTR field.
	USBD_EPOUT_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_EPOUT_PTR_PTR_Msk = 0xffffffff

	// EPOUT.MAXCNT: Description cluster: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_EPOUT_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_EPOUT_MAXCNT_MAXCNT_Msk = 0x7f

	// EPOUT.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_EPOUT_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_EPOUT_AMOUNT_AMOUNT_Msk = 0x7f

	// ISOOUT.PTR: Data pointer
	// Position of PTR field.
	USBD_ISOOUT_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_ISOOUT_PTR_PTR_Msk = 0xffffffff

	// ISOOUT.MAXCNT: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_ISOOUT_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_ISOOUT_MAXCNT_MAXCNT_Msk = 0x3ff

	// ISOOUT.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_ISOOUT_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_ISOOUT_AMOUNT_AMOUNT_Msk = 0x3ff
)

// Constants for USBREGULATOR_NS: USB Regulator 0
const (
	// EVENTS_USBDETECTED: Voltage supply detected on VBUS
	// Position of EVENTS_USBDETECTED field.
	USBREG_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Pos = 0x0
	// Bit mask of EVENTS_USBDETECTED field.
	USBREG_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Msk = 0x1
	// Bit EVENTS_USBDETECTED.
	USBREG_EVENTS_USBDETECTED_EVENTS_USBDETECTED = 0x1
	// Event not generated
	USBREG_EVENTS_USBDETECTED_EVENTS_USBDETECTED_NotGenerated = 0x0
	// Event generated
	USBREG_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Generated = 0x1

	// EVENTS_USBREMOVED: Voltage supply removed from VBUS
	// Position of EVENTS_USBREMOVED field.
	USBREG_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Pos = 0x0
	// Bit mask of EVENTS_USBREMOVED field.
	USBREG_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Msk = 0x1
	// Bit EVENTS_USBREMOVED.
	USBREG_EVENTS_USBREMOVED_EVENTS_USBREMOVED = 0x1
	// Event not generated
	USBREG_EVENTS_USBREMOVED_EVENTS_USBREMOVED_NotGenerated = 0x0
	// Event generated
	USBREG_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Generated = 0x1

	// EVENTS_USBPWRRDY: USB 3.3 V supply ready
	// Position of EVENTS_USBPWRRDY field.
	USBREG_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Pos = 0x0
	// Bit mask of EVENTS_USBPWRRDY field.
	USBREG_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Msk = 0x1
	// Bit EVENTS_USBPWRRDY.
	USBREG_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY = 0x1
	// Event not generated
	USBREG_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_NotGenerated = 0x0
	// Event generated
	USBREG_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Generated = 0x1

	// PUBLISH_USBDETECTED: Publish configuration for event USBDETECTED
	// Position of CHIDX field.
	USBREG_PUBLISH_USBDETECTED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBREG_PUBLISH_USBDETECTED_CHIDX_Msk = 0xff
	// Position of EN field.
	USBREG_PUBLISH_USBDETECTED_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBREG_PUBLISH_USBDETECTED_EN_Msk = 0x80000000
	// Bit EN.
	USBREG_PUBLISH_USBDETECTED_EN = 0x80000000
	// Disable publishing
	USBREG_PUBLISH_USBDETECTED_EN_Disabled = 0x0
	// Enable publishing
	USBREG_PUBLISH_USBDETECTED_EN_Enabled = 0x1

	// PUBLISH_USBREMOVED: Publish configuration for event USBREMOVED
	// Position of CHIDX field.
	USBREG_PUBLISH_USBREMOVED_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBREG_PUBLISH_USBREMOVED_CHIDX_Msk = 0xff
	// Position of EN field.
	USBREG_PUBLISH_USBREMOVED_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBREG_PUBLISH_USBREMOVED_EN_Msk = 0x80000000
	// Bit EN.
	USBREG_PUBLISH_USBREMOVED_EN = 0x80000000
	// Disable publishing
	USBREG_PUBLISH_USBREMOVED_EN_Disabled = 0x0
	// Enable publishing
	USBREG_PUBLISH_USBREMOVED_EN_Enabled = 0x1

	// PUBLISH_USBPWRRDY: Publish configuration for event USBPWRRDY
	// Position of CHIDX field.
	USBREG_PUBLISH_USBPWRRDY_CHIDX_Pos = 0x0
	// Bit mask of CHIDX field.
	USBREG_PUBLISH_USBPWRRDY_CHIDX_Msk = 0xff
	// Position of EN field.
	USBREG_PUBLISH_USBPWRRDY_EN_Pos = 0x1f
	// Bit mask of EN field.
	USBREG_PUBLISH_USBPWRRDY_EN_Msk = 0x80000000
	// Bit EN.
	USBREG_PUBLISH_USBPWRRDY_EN = 0x80000000
	// Disable publishing
	USBREG_PUBLISH_USBPWRRDY_EN_Disabled = 0x0
	// Enable publishing
	USBREG_PUBLISH_USBPWRRDY_EN_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of USBDETECTED field.
	USBREG_INTEN_USBDETECTED_Pos = 0x0
	// Bit mask of USBDETECTED field.
	USBREG_INTEN_USBDETECTED_Msk = 0x1
	// Bit USBDETECTED.
	USBREG_INTEN_USBDETECTED = 0x1
	// Disable
	USBREG_INTEN_USBDETECTED_Disabled = 0x0
	// Enable
	USBREG_INTEN_USBDETECTED_Enabled = 0x1
	// Position of USBREMOVED field.
	USBREG_INTEN_USBREMOVED_Pos = 0x1
	// Bit mask of USBREMOVED field.
	USBREG_INTEN_USBREMOVED_Msk = 0x2
	// Bit USBREMOVED.
	USBREG_INTEN_USBREMOVED = 0x2
	// Disable
	USBREG_INTEN_USBREMOVED_Disabled = 0x0
	// Enable
	USBREG_INTEN_USBREMOVED_Enabled = 0x1
	// Position of USBPWRRDY field.
	USBREG_INTEN_USBPWRRDY_Pos = 0x2
	// Bit mask of USBPWRRDY field.
	USBREG_INTEN_USBPWRRDY_Msk = 0x4
	// Bit USBPWRRDY.
	USBREG_INTEN_USBPWRRDY = 0x4
	// Disable
	USBREG_INTEN_USBPWRRDY_Disabled = 0x0
	// Enable
	USBREG_INTEN_USBPWRRDY_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of USBDETECTED field.
	USBREG_INTENSET_USBDETECTED_Pos = 0x0
	// Bit mask of USBDETECTED field.
	USBREG_INTENSET_USBDETECTED_Msk = 0x1
	// Bit USBDETECTED.
	USBREG_INTENSET_USBDETECTED = 0x1
	// Read: Disabled
	USBREG_INTENSET_USBDETECTED_Disabled = 0x0
	// Read: Enabled
	USBREG_INTENSET_USBDETECTED_Enabled = 0x1
	// Enable
	USBREG_INTENSET_USBDETECTED_Set = 0x1
	// Position of USBREMOVED field.
	USBREG_INTENSET_USBREMOVED_Pos = 0x1
	// Bit mask of USBREMOVED field.
	USBREG_INTENSET_USBREMOVED_Msk = 0x2
	// Bit USBREMOVED.
	USBREG_INTENSET_USBREMOVED = 0x2
	// Read: Disabled
	USBREG_INTENSET_USBREMOVED_Disabled = 0x0
	// Read: Enabled
	USBREG_INTENSET_USBREMOVED_Enabled = 0x1
	// Enable
	USBREG_INTENSET_USBREMOVED_Set = 0x1
	// Position of USBPWRRDY field.
	USBREG_INTENSET_USBPWRRDY_Pos = 0x2
	// Bit mask of USBPWRRDY field.
	USBREG_INTENSET_USBPWRRDY_Msk = 0x4
	// Bit USBPWRRDY.
	USBREG_INTENSET_USBPWRRDY = 0x4
	// Read: Disabled
	USBREG_INTENSET_USBPWRRDY_Disabled = 0x0
	// Read: Enabled
	USBREG_INTENSET_USBPWRRDY_Enabled = 0x1
	// Enable
	USBREG_INTENSET_USBPWRRDY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of USBDETECTED field.
	USBREG_INTENCLR_USBDETECTED_Pos = 0x0
	// Bit mask of USBDETECTED field.
	USBREG_INTENCLR_USBDETECTED_Msk = 0x1
	// Bit USBDETECTED.
	USBREG_INTENCLR_USBDETECTED = 0x1
	// Read: Disabled
	USBREG_INTENCLR_USBDETECTED_Disabled = 0x0
	// Read: Enabled
	USBREG_INTENCLR_USBDETECTED_Enabled = 0x1
	// Disable
	USBREG_INTENCLR_USBDETECTED_Clear = 0x1
	// Position of USBREMOVED field.
	USBREG_INTENCLR_USBREMOVED_Pos = 0x1
	// Bit mask of USBREMOVED field.
	USBREG_INTENCLR_USBREMOVED_Msk = 0x2
	// Bit USBREMOVED.
	USBREG_INTENCLR_USBREMOVED = 0x2
	// Read: Disabled
	USBREG_INTENCLR_USBREMOVED_Disabled = 0x0
	// Read: Enabled
	USBREG_INTENCLR_USBREMOVED_Enabled = 0x1
	// Disable
	USBREG_INTENCLR_USBREMOVED_Clear = 0x1
	// Position of USBPWRRDY field.
	USBREG_INTENCLR_USBPWRRDY_Pos = 0x2
	// Bit mask of USBPWRRDY field.
	USBREG_INTENCLR_USBPWRRDY_Msk = 0x4
	// Bit USBPWRRDY.
	USBREG_INTENCLR_USBPWRRDY = 0x4
	// Read: Disabled
	USBREG_INTENCLR_USBPWRRDY_Disabled = 0x0
	// Read: Enabled
	USBREG_INTENCLR_USBPWRRDY_Enabled = 0x1
	// Disable
	USBREG_INTENCLR_USBPWRRDY_Clear = 0x1

	// USBREGSTATUS: USB supply status
	// Position of VBUSDETECT field.
	USBREG_USBREGSTATUS_VBUSDETECT_Pos = 0x0
	// Bit mask of VBUSDETECT field.
	USBREG_USBREGSTATUS_VBUSDETECT_Msk = 0x1
	// Bit VBUSDETECT.
	USBREG_USBREGSTATUS_VBUSDETECT = 0x1
	// VBUS voltage below valid threshold
	USBREG_USBREGSTATUS_VBUSDETECT_NoVbus = 0x0
	// VBUS voltage above valid threshold
	USBREG_USBREGSTATUS_VBUSDETECT_VbusPresent = 0x1
	// Position of OUTPUTRDY field.
	USBREG_USBREGSTATUS_OUTPUTRDY_Pos = 0x1
	// Bit mask of OUTPUTRDY field.
	USBREG_USBREGSTATUS_OUTPUTRDY_Msk = 0x2
	// Bit OUTPUTRDY.
	USBREG_USBREGSTATUS_OUTPUTRDY = 0x2
	// USBREG output settling time not elapsed
	USBREG_USBREGSTATUS_OUTPUTRDY_NotReady = 0x0
	// USBREG output settling time elapsed (same information as USBPWRRDY event)
	USBREG_USBREGSTATUS_OUTPUTRDY_Ready = 0x1
)

// Constants for KMU_NS: Key management unit 0
const (
	// TASKS_PUSH_KEYSLOT: Push a key slot over secure APB
	// Position of TASKS_PUSH_KEYSLOT field.
	KMU_TASKS_PUSH_KEYSLOT_TASKS_PUSH_KEYSLOT_Pos = 0x0
	// Bit mask of TASKS_PUSH_KEYSLOT field.
	KMU_TASKS_PUSH_KEYSLOT_TASKS_PUSH_KEYSLOT_Msk = 0x1
	// Bit TASKS_PUSH_KEYSLOT.
	KMU_TASKS_PUSH_KEYSLOT_TASKS_PUSH_KEYSLOT = 0x1
	// Trigger task
	KMU_TASKS_PUSH_KEYSLOT_TASKS_PUSH_KEYSLOT_Trigger = 0x1

	// EVENTS_KEYSLOT_PUSHED: Key slot successfully pushed over secure APB
	// Position of EVENTS_KEYSLOT_PUSHED field.
	KMU_EVENTS_KEYSLOT_PUSHED_EVENTS_KEYSLOT_PUSHED_Pos = 0x0
	// Bit mask of EVENTS_KEYSLOT_PUSHED field.
	KMU_EVENTS_KEYSLOT_PUSHED_EVENTS_KEYSLOT_PUSHED_Msk = 0x1
	// Bit EVENTS_KEYSLOT_PUSHED.
	KMU_EVENTS_KEYSLOT_PUSHED_EVENTS_KEYSLOT_PUSHED = 0x1
	// Event not generated
	KMU_EVENTS_KEYSLOT_PUSHED_EVENTS_KEYSLOT_PUSHED_NotGenerated = 0x0
	// Event generated
	KMU_EVENTS_KEYSLOT_PUSHED_EVENTS_KEYSLOT_PUSHED_Generated = 0x1

	// EVENTS_KEYSLOT_REVOKED: Key slot has been revoked and cannot be tasked for selection
	// Position of EVENTS_KEYSLOT_REVOKED field.
	KMU_EVENTS_KEYSLOT_REVOKED_EVENTS_KEYSLOT_REVOKED_Pos = 0x0
	// Bit mask of EVENTS_KEYSLOT_REVOKED field.
	KMU_EVENTS_KEYSLOT_REVOKED_EVENTS_KEYSLOT_REVOKED_Msk = 0x1
	// Bit EVENTS_KEYSLOT_REVOKED.
	KMU_EVENTS_KEYSLOT_REVOKED_EVENTS_KEYSLOT_REVOKED = 0x1
	// Event not generated
	KMU_EVENTS_KEYSLOT_REVOKED_EVENTS_KEYSLOT_REVOKED_NotGenerated = 0x0
	// Event generated
	KMU_EVENTS_KEYSLOT_REVOKED_EVENTS_KEYSLOT_REVOKED_Generated = 0x1

	// EVENTS_KEYSLOT_ERROR: No key slot selected, no destination address defined, or error during push operation
	// Position of EVENTS_KEYSLOT_ERROR field.
	KMU_EVENTS_KEYSLOT_ERROR_EVENTS_KEYSLOT_ERROR_Pos = 0x0
	// Bit mask of EVENTS_KEYSLOT_ERROR field.
	KMU_EVENTS_KEYSLOT_ERROR_EVENTS_KEYSLOT_ERROR_Msk = 0x1
	// Bit EVENTS_KEYSLOT_ERROR.
	KMU_EVENTS_KEYSLOT_ERROR_EVENTS_KEYSLOT_ERROR = 0x1
	// Event not generated
	KMU_EVENTS_KEYSLOT_ERROR_EVENTS_KEYSLOT_ERROR_NotGenerated = 0x0
	// Event generated
	KMU_EVENTS_KEYSLOT_ERROR_EVENTS_KEYSLOT_ERROR_Generated = 0x1

	// INTEN: Enable or disable interrupt
	// Position of KEYSLOT_PUSHED field.
	KMU_INTEN_KEYSLOT_PUSHED_Pos = 0x0
	// Bit mask of KEYSLOT_PUSHED field.
	KMU_INTEN_KEYSLOT_PUSHED_Msk = 0x1
	// Bit KEYSLOT_PUSHED.
	KMU_INTEN_KEYSLOT_PUSHED = 0x1
	// Disable
	KMU_INTEN_KEYSLOT_PUSHED_Disabled = 0x0
	// Enable
	KMU_INTEN_KEYSLOT_PUSHED_Enabled = 0x1
	// Position of KEYSLOT_REVOKED field.
	KMU_INTEN_KEYSLOT_REVOKED_Pos = 0x1
	// Bit mask of KEYSLOT_REVOKED field.
	KMU_INTEN_KEYSLOT_REVOKED_Msk = 0x2
	// Bit KEYSLOT_REVOKED.
	KMU_INTEN_KEYSLOT_REVOKED = 0x2
	// Disable
	KMU_INTEN_KEYSLOT_REVOKED_Disabled = 0x0
	// Enable
	KMU_INTEN_KEYSLOT_REVOKED_Enabled = 0x1
	// Position of KEYSLOT_ERROR field.
	KMU_INTEN_KEYSLOT_ERROR_Pos = 0x2
	// Bit mask of KEYSLOT_ERROR field.
	KMU_INTEN_KEYSLOT_ERROR_Msk = 0x4
	// Bit KEYSLOT_ERROR.
	KMU_INTEN_KEYSLOT_ERROR = 0x4
	// Disable
	KMU_INTEN_KEYSLOT_ERROR_Disabled = 0x0
	// Enable
	KMU_INTEN_KEYSLOT_ERROR_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of KEYSLOT_PUSHED field.
	KMU_INTENSET_KEYSLOT_PUSHED_Pos = 0x0
	// Bit mask of KEYSLOT_PUSHED field.
	KMU_INTENSET_KEYSLOT_PUSHED_Msk = 0x1
	// Bit KEYSLOT_PUSHED.
	KMU_INTENSET_KEYSLOT_PUSHED = 0x1
	// Read: Disabled
	KMU_INTENSET_KEYSLOT_PUSHED_Disabled = 0x0
	// Read: Enabled
	KMU_INTENSET_KEYSLOT_PUSHED_Enabled = 0x1
	// Enable
	KMU_INTENSET_KEYSLOT_PUSHED_Set = 0x1
	// Position of KEYSLOT_REVOKED field.
	KMU_INTENSET_KEYSLOT_REVOKED_Pos = 0x1
	// Bit mask of KEYSLOT_REVOKED field.
	KMU_INTENSET_KEYSLOT_REVOKED_Msk = 0x2
	// Bit KEYSLOT_REVOKED.
	KMU_INTENSET_KEYSLOT_REVOKED = 0x2
	// Read: Disabled
	KMU_INTENSET_KEYSLOT_REVOKED_Disabled = 0x0
	// Read: Enabled
	KMU_INTENSET_KEYSLOT_REVOKED_Enabled = 0x1
	// Enable
	KMU_INTENSET_KEYSLOT_REVOKED_Set = 0x1
	// Position of KEYSLOT_ERROR field.
	KMU_INTENSET_KEYSLOT_ERROR_Pos = 0x2
	// Bit mask of KEYSLOT_ERROR field.
	KMU_INTENSET_KEYSLOT_ERROR_Msk = 0x4
	// Bit KEYSLOT_ERROR.
	KMU_INTENSET_KEYSLOT_ERROR = 0x4
	// Read: Disabled
	KMU_INTENSET_KEYSLOT_ERROR_Disabled = 0x0
	// Read: Enabled
	KMU_INTENSET_KEYSLOT_ERROR_Enabled = 0x1
	// Enable
	KMU_INTENSET_KEYSLOT_ERROR_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of KEYSLOT_PUSHED field.
	KMU_INTENCLR_KEYSLOT_PUSHED_Pos = 0x0
	// Bit mask of KEYSLOT_PUSHED field.
	KMU_INTENCLR_KEYSLOT_PUSHED_Msk = 0x1
	// Bit KEYSLOT_PUSHED.
	KMU_INTENCLR_KEYSLOT_PUSHED = 0x1
	// Read: Disabled
	KMU_INTENCLR_KEYSLOT_PUSHED_Disabled = 0x0
	// Read: Enabled
	KMU_INTENCLR_KEYSLOT_PUSHED_Enabled = 0x1
	// Disable
	KMU_INTENCLR_KEYSLOT_PUSHED_Clear = 0x1
	// Position of KEYSLOT_REVOKED field.
	KMU_INTENCLR_KEYSLOT_REVOKED_Pos = 0x1
	// Bit mask of KEYSLOT_REVOKED field.
	KMU_INTENCLR_KEYSLOT_REVOKED_Msk = 0x2
	// Bit KEYSLOT_REVOKED.
	KMU_INTENCLR_KEYSLOT_REVOKED = 0x2
	// Read: Disabled
	KMU_INTENCLR_KEYSLOT_REVOKED_Disabled = 0x0
	// Read: Enabled
	KMU_INTENCLR_KEYSLOT_REVOKED_Enabled = 0x1
	// Disable
	KMU_INTENCLR_KEYSLOT_REVOKED_Clear = 0x1
	// Position of KEYSLOT_ERROR field.
	KMU_INTENCLR_KEYSLOT_ERROR_Pos = 0x2
	// Bit mask of KEYSLOT_ERROR field.
	KMU_INTENCLR_KEYSLOT_ERROR_Msk = 0x4
	// Bit KEYSLOT_ERROR.
	KMU_INTENCLR_KEYSLOT_ERROR = 0x4
	// Read: Disabled
	KMU_INTENCLR_KEYSLOT_ERROR_Disabled = 0x0
	// Read: Enabled
	KMU_INTENCLR_KEYSLOT_ERROR_Enabled = 0x1
	// Disable
	KMU_INTENCLR_KEYSLOT_ERROR_Clear = 0x1

	// INTPEND: Pending interrupts
	// Position of KEYSLOT_PUSHED field.
	KMU_INTPEND_KEYSLOT_PUSHED_Pos = 0x0
	// Bit mask of KEYSLOT_PUSHED field.
	KMU_INTPEND_KEYSLOT_PUSHED_Msk = 0x1
	// Bit KEYSLOT_PUSHED.
	KMU_INTPEND_KEYSLOT_PUSHED = 0x1
	// Read: Not pending
	KMU_INTPEND_KEYSLOT_PUSHED_NotPending = 0x0
	// Read: Pending
	KMU_INTPEND_KEYSLOT_PUSHED_Pending = 0x1
	// Position of KEYSLOT_REVOKED field.
	KMU_INTPEND_KEYSLOT_REVOKED_Pos = 0x1
	// Bit mask of KEYSLOT_REVOKED field.
	KMU_INTPEND_KEYSLOT_REVOKED_Msk = 0x2
	// Bit KEYSLOT_REVOKED.
	KMU_INTPEND_KEYSLOT_REVOKED = 0x2
	// Read: Not pending
	KMU_INTPEND_KEYSLOT_REVOKED_NotPending = 0x0
	// Read: Pending
	KMU_INTPEND_KEYSLOT_REVOKED_Pending = 0x1
	// Position of KEYSLOT_ERROR field.
	KMU_INTPEND_KEYSLOT_ERROR_Pos = 0x2
	// Bit mask of KEYSLOT_ERROR field.
	KMU_INTPEND_KEYSLOT_ERROR_Msk = 0x4
	// Bit KEYSLOT_ERROR.
	KMU_INTPEND_KEYSLOT_ERROR = 0x4
	// Read: Not pending
	KMU_INTPEND_KEYSLOT_ERROR_NotPending = 0x0
	// Read: Pending
	KMU_INTPEND_KEYSLOT_ERROR_Pending = 0x1

	// STATUS: Status bits for KMU operation
	// Position of SELECTED field.
	KMU_STATUS_SELECTED_Pos = 0x0
	// Bit mask of SELECTED field.
	KMU_STATUS_SELECTED_Msk = 0x1
	// Bit SELECTED.
	KMU_STATUS_SELECTED = 0x1
	// No key slot ID selected by KMU
	KMU_STATUS_SELECTED_Disabled = 0x0
	// Key slot ID successfully selected by KMU
	KMU_STATUS_SELECTED_Enabled = 0x1
	// Position of BLOCKED field.
	KMU_STATUS_BLOCKED_Pos = 0x1
	// Bit mask of BLOCKED field.
	KMU_STATUS_BLOCKED_Msk = 0x2
	// Bit BLOCKED.
	KMU_STATUS_BLOCKED = 0x2
	// No access violation detected
	KMU_STATUS_BLOCKED_Disabled = 0x0
	// Access violation detected and blocked
	KMU_STATUS_BLOCKED_Enabled = 0x1

	// SELECTKEYSLOT: Select key slot to be read over AHB or pushed over secure APB when TASKS_PUSH_KEYSLOT is started
	// Position of ID field.
	KMU_SELECTKEYSLOT_ID_Pos = 0x0
	// Bit mask of ID field.
	KMU_SELECTKEYSLOT_ID_Msk = 0xff
)

// Constants for NVMC_NS: Non-volatile memory controller 0
const (
	// READY: Ready flag
	// Position of READY field.
	NVMC_READY_READY_Pos = 0x0
	// Bit mask of READY field.
	NVMC_READY_READY_Msk = 0x1
	// Bit READY.
	NVMC_READY_READY = 0x1
	// NVMC is busy (on-going write or erase operation)
	NVMC_READY_READY_Busy = 0x0
	// NVMC is ready
	NVMC_READY_READY_Ready = 0x1

	// READYNEXT: Ready flag
	// Position of READYNEXT field.
	NVMC_READYNEXT_READYNEXT_Pos = 0x0
	// Bit mask of READYNEXT field.
	NVMC_READYNEXT_READYNEXT_Msk = 0x1
	// Bit READYNEXT.
	NVMC_READYNEXT_READYNEXT = 0x1
	// NVMC cannot accept any write operation
	NVMC_READYNEXT_READYNEXT_Busy = 0x0
	// NVMC is ready
	NVMC_READYNEXT_READYNEXT_Ready = 0x1

	// CONFIG: Configuration register
	// Position of WEN field.
	NVMC_CONFIG_WEN_Pos = 0x0
	// Bit mask of WEN field.
	NVMC_CONFIG_WEN_Msk = 0x7
	// Read only access
	NVMC_CONFIG_WEN_Ren = 0x0
	// Write enabled
	NVMC_CONFIG_WEN_Wen = 0x1
	// Erase enabled
	NVMC_CONFIG_WEN_Een = 0x2
	// Partial erase enabled
	NVMC_CONFIG_WEN_PEen = 0x4

	// ERASEALL: Register for erasing all non-volatile user memory
	// Position of ERASEALL field.
	NVMC_ERASEALL_ERASEALL_Pos = 0x0
	// Bit mask of ERASEALL field.
	NVMC_ERASEALL_ERASEALL_Msk = 0x1
	// Bit ERASEALL.
	NVMC_ERASEALL_ERASEALL = 0x1
	// No operation
	NVMC_ERASEALL_ERASEALL_NoOperation = 0x0
	// Start chip erase
	NVMC_ERASEALL_ERASEALL_Erase = 0x1

	// ERASEPAGEPARTIALCFG: Register for partial erase configuration
	// Position of DURATION field.
	NVMC_ERASEPAGEPARTIALCFG_DURATION_Pos = 0x0
	// Bit mask of DURATION field.
	NVMC_ERASEPAGEPARTIALCFG_DURATION_Msk = 0x7f

	// CONFIGNS: Unspecified
	// Position of WEN field.
	NVMC_CONFIGNS_WEN_Pos = 0x0
	// Bit mask of WEN field.
	NVMC_CONFIGNS_WEN_Msk = 0x3
	// Read only access
	NVMC_CONFIGNS_WEN_Ren = 0x0
	// Write enabled
	NVMC_CONFIGNS_WEN_Wen = 0x1
	// Erase enabled
	NVMC_CONFIGNS_WEN_Een = 0x2

	// WRITEUICRNS: Non-secure APPROTECT enable register
	// Position of SET field.
	NVMC_WRITEUICRNS_SET_Pos = 0x0
	// Bit mask of SET field.
	NVMC_WRITEUICRNS_SET_Msk = 0x1
	// Bit SET.
	NVMC_WRITEUICRNS_SET = 0x1
	// Set value
	NVMC_WRITEUICRNS_SET_Set = 0x1
	// Position of KEY field.
	NVMC_WRITEUICRNS_KEY_Pos = 0x4
	// Bit mask of KEY field.
	NVMC_WRITEUICRNS_KEY_Msk = 0xfffffff0
	// Key value
	NVMC_WRITEUICRNS_KEY_Keyvalid = 0xafbe5a7
)

// Constants for P0_NS: GPIO Port 0
const (
	// OUT: Write GPIO port
	// Position of PIN0 field.
	GPIO_OUT_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUT_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUT_PIN0 = 0x1
	// Pin driver is low
	GPIO_OUT_PIN0_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN0_High = 0x1
	// Position of PIN1 field.
	GPIO_OUT_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUT_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUT_PIN1 = 0x2
	// Pin driver is low
	GPIO_OUT_PIN1_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN1_High = 0x1
	// Position of PIN2 field.
	GPIO_OUT_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUT_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUT_PIN2 = 0x4
	// Pin driver is low
	GPIO_OUT_PIN2_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN2_High = 0x1
	// Position of PIN3 field.
	GPIO_OUT_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUT_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUT_PIN3 = 0x8
	// Pin driver is low
	GPIO_OUT_PIN3_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN3_High = 0x1
	// Position of PIN4 field.
	GPIO_OUT_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUT_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUT_PIN4 = 0x10
	// Pin driver is low
	GPIO_OUT_PIN4_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN4_High = 0x1
	// Position of PIN5 field.
	GPIO_OUT_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUT_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUT_PIN5 = 0x20
	// Pin driver is low
	GPIO_OUT_PIN5_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN5_High = 0x1
	// Position of PIN6 field.
	GPIO_OUT_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUT_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUT_PIN6 = 0x40
	// Pin driver is low
	GPIO_OUT_PIN6_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN6_High = 0x1
	// Position of PIN7 field.
	GPIO_OUT_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUT_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUT_PIN7 = 0x80
	// Pin driver is low
	GPIO_OUT_PIN7_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN7_High = 0x1
	// Position of PIN8 field.
	GPIO_OUT_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUT_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUT_PIN8 = 0x100
	// Pin driver is low
	GPIO_OUT_PIN8_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN8_High = 0x1
	// Position of PIN9 field.
	GPIO_OUT_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUT_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUT_PIN9 = 0x200
	// Pin driver is low
	GPIO_OUT_PIN9_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN9_High = 0x1
	// Position of PIN10 field.
	GPIO_OUT_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUT_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUT_PIN10 = 0x400
	// Pin driver is low
	GPIO_OUT_PIN10_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN10_High = 0x1
	// Position of PIN11 field.
	GPIO_OUT_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUT_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUT_PIN11 = 0x800
	// Pin driver is low
	GPIO_OUT_PIN11_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN11_High = 0x1
	// Position of PIN12 field.
	GPIO_OUT_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUT_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUT_PIN12 = 0x1000
	// Pin driver is low
	GPIO_OUT_PIN12_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN12_High = 0x1
	// Position of PIN13 field.
	GPIO_OUT_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUT_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUT_PIN13 = 0x2000
	// Pin driver is low
	GPIO_OUT_PIN13_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN13_High = 0x1
	// Position of PIN14 field.
	GPIO_OUT_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUT_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUT_PIN14 = 0x4000
	// Pin driver is low
	GPIO_OUT_PIN14_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN14_High = 0x1
	// Position of PIN15 field.
	GPIO_OUT_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUT_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUT_PIN15 = 0x8000
	// Pin driver is low
	GPIO_OUT_PIN15_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN15_High = 0x1
	// Position of PIN16 field.
	GPIO_OUT_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUT_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUT_PIN16 = 0x10000
	// Pin driver is low
	GPIO_OUT_PIN16_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN16_High = 0x1
	// Position of PIN17 field.
	GPIO_OUT_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUT_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUT_PIN17 = 0x20000
	// Pin driver is low
	GPIO_OUT_PIN17_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN17_High = 0x1
	// Position of PIN18 field.
	GPIO_OUT_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUT_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUT_PIN18 = 0x40000
	// Pin driver is low
	GPIO_OUT_PIN18_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN18_High = 0x1
	// Position of PIN19 field.
	GPIO_OUT_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUT_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUT_PIN19 = 0x80000
	// Pin driver is low
	GPIO_OUT_PIN19_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN19_High = 0x1
	// Position of PIN20 field.
	GPIO_OUT_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUT_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUT_PIN20 = 0x100000
	// Pin driver is low
	GPIO_OUT_PIN20_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN20_High = 0x1
	// Position of PIN21 field.
	GPIO_OUT_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUT_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUT_PIN21 = 0x200000
	// Pin driver is low
	GPIO_OUT_PIN21_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN21_High = 0x1
	// Position of PIN22 field.
	GPIO_OUT_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUT_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUT_PIN22 = 0x400000
	// Pin driver is low
	GPIO_OUT_PIN22_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN22_High = 0x1
	// Position of PIN23 field.
	GPIO_OUT_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUT_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUT_PIN23 = 0x800000
	// Pin driver is low
	GPIO_OUT_PIN23_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN23_High = 0x1
	// Position of PIN24 field.
	GPIO_OUT_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUT_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUT_PIN24 = 0x1000000
	// Pin driver is low
	GPIO_OUT_PIN24_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN24_High = 0x1
	// Position of PIN25 field.
	GPIO_OUT_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUT_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUT_PIN25 = 0x2000000
	// Pin driver is low
	GPIO_OUT_PIN25_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN25_High = 0x1
	// Position of PIN26 field.
	GPIO_OUT_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUT_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUT_PIN26 = 0x4000000
	// Pin driver is low
	GPIO_OUT_PIN26_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN26_High = 0x1
	// Position of PIN27 field.
	GPIO_OUT_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUT_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUT_PIN27 = 0x8000000
	// Pin driver is low
	GPIO_OUT_PIN27_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN27_High = 0x1
	// Position of PIN28 field.
	GPIO_OUT_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUT_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUT_PIN28 = 0x10000000
	// Pin driver is low
	GPIO_OUT_PIN28_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN28_High = 0x1
	// Position of PIN29 field.
	GPIO_OUT_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUT_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUT_PIN29 = 0x20000000
	// Pin driver is low
	GPIO_OUT_PIN29_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN29_High = 0x1
	// Position of PIN30 field.
	GPIO_OUT_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUT_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUT_PIN30 = 0x40000000
	// Pin driver is low
	GPIO_OUT_PIN30_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN30_High = 0x1
	// Position of PIN31 field.
	GPIO_OUT_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUT_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUT_PIN31 = 0x80000000
	// Pin driver is low
	GPIO_OUT_PIN31_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN31_High = 0x1

	// OUTSET: Set individual bits in GPIO port
	// Position of PIN0 field.
	GPIO_OUTSET_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUTSET_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUTSET_PIN0 = 0x1
	// Read: pin driver is low
	GPIO_OUTSET_PIN0_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN0_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN0_Set = 0x1
	// Position of PIN1 field.
	GPIO_OUTSET_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUTSET_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUTSET_PIN1 = 0x2
	// Read: pin driver is low
	GPIO_OUTSET_PIN1_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN1_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN1_Set = 0x1
	// Position of PIN2 field.
	GPIO_OUTSET_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUTSET_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUTSET_PIN2 = 0x4
	// Read: pin driver is low
	GPIO_OUTSET_PIN2_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN2_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN2_Set = 0x1
	// Position of PIN3 field.
	GPIO_OUTSET_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUTSET_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUTSET_PIN3 = 0x8
	// Read: pin driver is low
	GPIO_OUTSET_PIN3_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN3_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN3_Set = 0x1
	// Position of PIN4 field.
	GPIO_OUTSET_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUTSET_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUTSET_PIN4 = 0x10
	// Read: pin driver is low
	GPIO_OUTSET_PIN4_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN4_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN4_Set = 0x1
	// Position of PIN5 field.
	GPIO_OUTSET_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUTSET_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUTSET_PIN5 = 0x20
	// Read: pin driver is low
	GPIO_OUTSET_PIN5_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN5_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN5_Set = 0x1
	// Position of PIN6 field.
	GPIO_OUTSET_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUTSET_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUTSET_PIN6 = 0x40
	// Read: pin driver is low
	GPIO_OUTSET_PIN6_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN6_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN6_Set = 0x1
	// Position of PIN7 field.
	GPIO_OUTSET_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUTSET_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUTSET_PIN7 = 0x80
	// Read: pin driver is low
	GPIO_OUTSET_PIN7_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN7_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN7_Set = 0x1
	// Position of PIN8 field.
	GPIO_OUTSET_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUTSET_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUTSET_PIN8 = 0x100
	// Read: pin driver is low
	GPIO_OUTSET_PIN8_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN8_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN8_Set = 0x1
	// Position of PIN9 field.
	GPIO_OUTSET_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUTSET_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUTSET_PIN9 = 0x200
	// Read: pin driver is low
	GPIO_OUTSET_PIN9_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN9_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN9_Set = 0x1
	// Position of PIN10 field.
	GPIO_OUTSET_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUTSET_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUTSET_PIN10 = 0x400
	// Read: pin driver is low
	GPIO_OUTSET_PIN10_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN10_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN10_Set = 0x1
	// Position of PIN11 field.
	GPIO_OUTSET_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUTSET_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUTSET_PIN11 = 0x800
	// Read: pin driver is low
	GPIO_OUTSET_PIN11_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN11_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN11_Set = 0x1
	// Position of PIN12 field.
	GPIO_OUTSET_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUTSET_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUTSET_PIN12 = 0x1000
	// Read: pin driver is low
	GPIO_OUTSET_PIN12_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN12_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN12_Set = 0x1
	// Position of PIN13 field.
	GPIO_OUTSET_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUTSET_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUTSET_PIN13 = 0x2000
	// Read: pin driver is low
	GPIO_OUTSET_PIN13_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN13_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN13_Set = 0x1
	// Position of PIN14 field.
	GPIO_OUTSET_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUTSET_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUTSET_PIN14 = 0x4000
	// Read: pin driver is low
	GPIO_OUTSET_PIN14_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN14_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN14_Set = 0x1
	// Position of PIN15 field.
	GPIO_OUTSET_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUTSET_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUTSET_PIN15 = 0x8000
	// Read: pin driver is low
	GPIO_OUTSET_PIN15_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN15_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN15_Set = 0x1
	// Position of PIN16 field.
	GPIO_OUTSET_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUTSET_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUTSET_PIN16 = 0x10000
	// Read: pin driver is low
	GPIO_OUTSET_PIN16_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN16_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN16_Set = 0x1
	// Position of PIN17 field.
	GPIO_OUTSET_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUTSET_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUTSET_PIN17 = 0x20000
	// Read: pin driver is low
	GPIO_OUTSET_PIN17_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN17_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN17_Set = 0x1
	// Position of PIN18 field.
	GPIO_OUTSET_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUTSET_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUTSET_PIN18 = 0x40000
	// Read: pin driver is low
	GPIO_OUTSET_PIN18_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN18_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN18_Set = 0x1
	// Position of PIN19 field.
	GPIO_OUTSET_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUTSET_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUTSET_PIN19 = 0x80000
	// Read: pin driver is low
	GPIO_OUTSET_PIN19_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN19_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN19_Set = 0x1
	// Position of PIN20 field.
	GPIO_OUTSET_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUTSET_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUTSET_PIN20 = 0x100000
	// Read: pin driver is low
	GPIO_OUTSET_PIN20_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN20_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN20_Set = 0x1
	// Position of PIN21 field.
	GPIO_OUTSET_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUTSET_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUTSET_PIN21 = 0x200000
	// Read: pin driver is low
	GPIO_OUTSET_PIN21_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN21_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN21_Set = 0x1
	// Position of PIN22 field.
	GPIO_OUTSET_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUTSET_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUTSET_PIN22 = 0x400000
	// Read: pin driver is low
	GPIO_OUTSET_PIN22_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN22_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN22_Set = 0x1
	// Position of PIN23 field.
	GPIO_OUTSET_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUTSET_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUTSET_PIN23 = 0x800000
	// Read: pin driver is low
	GPIO_OUTSET_PIN23_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN23_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN23_Set = 0x1
	// Position of PIN24 field.
	GPIO_OUTSET_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUTSET_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUTSET_PIN24 = 0x1000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN24_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN24_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN24_Set = 0x1
	// Position of PIN25 field.
	GPIO_OUTSET_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUTSET_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUTSET_PIN25 = 0x2000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN25_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN25_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN25_Set = 0x1
	// Position of PIN26 field.
	GPIO_OUTSET_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUTSET_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUTSET_PIN26 = 0x4000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN26_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN26_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN26_Set = 0x1
	// Position of PIN27 field.
	GPIO_OUTSET_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUTSET_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUTSET_PIN27 = 0x8000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN27_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN27_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN27_Set = 0x1
	// Position of PIN28 field.
	GPIO_OUTSET_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUTSET_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUTSET_PIN28 = 0x10000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN28_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN28_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN28_Set = 0x1
	// Position of PIN29 field.
	GPIO_OUTSET_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUTSET_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUTSET_PIN29 = 0x20000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN29_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN29_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN29_Set = 0x1
	// Position of PIN30 field.
	GPIO_OUTSET_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUTSET_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUTSET_PIN30 = 0x40000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN30_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN30_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN30_Set = 0x1
	// Position of PIN31 field.
	GPIO_OUTSET_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUTSET_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUTSET_PIN31 = 0x80000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN31_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN31_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN31_Set = 0x1

	// OUTCLR: Clear individual bits in GPIO port
	// Position of PIN0 field.
	GPIO_OUTCLR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUTCLR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUTCLR_PIN0 = 0x1
	// Read: pin driver is low
	GPIO_OUTCLR_PIN0_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN0_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN0_Clear = 0x1
	// Position of PIN1 field.
	GPIO_OUTCLR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUTCLR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUTCLR_PIN1 = 0x2
	// Read: pin driver is low
	GPIO_OUTCLR_PIN1_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN1_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN1_Clear = 0x1
	// Position of PIN2 field.
	GPIO_OUTCLR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUTCLR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUTCLR_PIN2 = 0x4
	// Read: pin driver is low
	GPIO_OUTCLR_PIN2_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN2_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN2_Clear = 0x1
	// Position of PIN3 field.
	GPIO_OUTCLR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUTCLR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUTCLR_PIN3 = 0x8
	// Read: pin driver is low
	GPIO_OUTCLR_PIN3_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN3_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN3_Clear = 0x1
	// Position of PIN4 field.
	GPIO_OUTCLR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUTCLR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUTCLR_PIN4 = 0x10
	// Read: pin driver is low
	GPIO_OUTCLR_PIN4_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN4_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN4_Clear = 0x1
	// Position of PIN5 field.
	GPIO_OUTCLR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUTCLR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUTCLR_PIN5 = 0x20
	// Read: pin driver is low
	GPIO_OUTCLR_PIN5_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN5_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN5_Clear = 0x1
	// Position of PIN6 field.
	GPIO_OUTCLR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUTCLR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUTCLR_PIN6 = 0x40
	// Read: pin driver is low
	GPIO_OUTCLR_PIN6_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN6_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN6_Clear = 0x1
	// Position of PIN7 field.
	GPIO_OUTCLR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUTCLR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUTCLR_PIN7 = 0x80
	// Read: pin driver is low
	GPIO_OUTCLR_PIN7_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN7_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN7_Clear = 0x1
	// Position of PIN8 field.
	GPIO_OUTCLR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUTCLR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUTCLR_PIN8 = 0x100
	// Read: pin driver is low
	GPIO_OUTCLR_PIN8_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN8_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN8_Clear = 0x1
	// Position of PIN9 field.
	GPIO_OUTCLR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUTCLR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUTCLR_PIN9 = 0x200
	// Read: pin driver is low
	GPIO_OUTCLR_PIN9_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN9_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN9_Clear = 0x1
	// Position of PIN10 field.
	GPIO_OUTCLR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUTCLR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUTCLR_PIN10 = 0x400
	// Read: pin driver is low
	GPIO_OUTCLR_PIN10_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN10_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN10_Clear = 0x1
	// Position of PIN11 field.
	GPIO_OUTCLR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUTCLR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUTCLR_PIN11 = 0x800
	// Read: pin driver is low
	GPIO_OUTCLR_PIN11_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN11_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN11_Clear = 0x1
	// Position of PIN12 field.
	GPIO_OUTCLR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUTCLR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUTCLR_PIN12 = 0x1000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN12_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN12_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN12_Clear = 0x1
	// Position of PIN13 field.
	GPIO_OUTCLR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUTCLR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUTCLR_PIN13 = 0x2000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN13_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN13_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN13_Clear = 0x1
	// Position of PIN14 field.
	GPIO_OUTCLR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUTCLR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUTCLR_PIN14 = 0x4000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN14_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN14_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN14_Clear = 0x1
	// Position of PIN15 field.
	GPIO_OUTCLR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUTCLR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUTCLR_PIN15 = 0x8000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN15_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN15_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN15_Clear = 0x1
	// Position of PIN16 field.
	GPIO_OUTCLR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUTCLR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUTCLR_PIN16 = 0x10000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN16_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN16_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN16_Clear = 0x1
	// Position of PIN17 field.
	GPIO_OUTCLR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUTCLR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUTCLR_PIN17 = 0x20000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN17_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN17_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN17_Clear = 0x1
	// Position of PIN18 field.
	GPIO_OUTCLR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUTCLR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUTCLR_PIN18 = 0x40000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN18_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN18_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN18_Clear = 0x1
	// Position of PIN19 field.
	GPIO_OUTCLR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUTCLR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUTCLR_PIN19 = 0x80000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN19_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN19_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN19_Clear = 0x1
	// Position of PIN20 field.
	GPIO_OUTCLR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUTCLR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUTCLR_PIN20 = 0x100000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN20_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN20_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN20_Clear = 0x1
	// Position of PIN21 field.
	GPIO_OUTCLR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUTCLR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUTCLR_PIN21 = 0x200000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN21_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN21_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN21_Clear = 0x1
	// Position of PIN22 field.
	GPIO_OUTCLR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUTCLR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUTCLR_PIN22 = 0x400000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN22_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN22_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN22_Clear = 0x1
	// Position of PIN23 field.
	GPIO_OUTCLR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUTCLR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUTCLR_PIN23 = 0x800000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN23_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN23_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN23_Clear = 0x1
	// Position of PIN24 field.
	GPIO_OUTCLR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUTCLR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUTCLR_PIN24 = 0x1000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN24_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN24_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN24_Clear = 0x1
	// Position of PIN25 field.
	GPIO_OUTCLR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUTCLR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUTCLR_PIN25 = 0x2000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN25_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN25_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN25_Clear = 0x1
	// Position of PIN26 field.
	GPIO_OUTCLR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUTCLR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUTCLR_PIN26 = 0x4000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN26_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN26_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN26_Clear = 0x1
	// Position of PIN27 field.
	GPIO_OUTCLR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUTCLR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUTCLR_PIN27 = 0x8000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN27_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN27_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN27_Clear = 0x1
	// Position of PIN28 field.
	GPIO_OUTCLR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUTCLR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUTCLR_PIN28 = 0x10000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN28_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN28_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN28_Clear = 0x1
	// Position of PIN29 field.
	GPIO_OUTCLR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUTCLR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUTCLR_PIN29 = 0x20000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN29_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN29_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN29_Clear = 0x1
	// Position of PIN30 field.
	GPIO_OUTCLR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUTCLR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUTCLR_PIN30 = 0x40000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN30_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN30_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN30_Clear = 0x1
	// Position of PIN31 field.
	GPIO_OUTCLR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUTCLR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUTCLR_PIN31 = 0x80000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN31_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN31_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN31_Clear = 0x1

	// IN: Read GPIO port
	// Position of PIN0 field.
	GPIO_IN_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_IN_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_IN_PIN0 = 0x1
	// Pin input is low
	GPIO_IN_PIN0_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN0_High = 0x1
	// Position of PIN1 field.
	GPIO_IN_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_IN_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_IN_PIN1 = 0x2
	// Pin input is low
	GPIO_IN_PIN1_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN1_High = 0x1
	// Position of PIN2 field.
	GPIO_IN_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_IN_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_IN_PIN2 = 0x4
	// Pin input is low
	GPIO_IN_PIN2_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN2_High = 0x1
	// Position of PIN3 field.
	GPIO_IN_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_IN_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_IN_PIN3 = 0x8
	// Pin input is low
	GPIO_IN_PIN3_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN3_High = 0x1
	// Position of PIN4 field.
	GPIO_IN_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_IN_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_IN_PIN4 = 0x10
	// Pin input is low
	GPIO_IN_PIN4_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN4_High = 0x1
	// Position of PIN5 field.
	GPIO_IN_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_IN_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_IN_PIN5 = 0x20
	// Pin input is low
	GPIO_IN_PIN5_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN5_High = 0x1
	// Position of PIN6 field.
	GPIO_IN_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_IN_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_IN_PIN6 = 0x40
	// Pin input is low
	GPIO_IN_PIN6_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN6_High = 0x1
	// Position of PIN7 field.
	GPIO_IN_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_IN_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_IN_PIN7 = 0x80
	// Pin input is low
	GPIO_IN_PIN7_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN7_High = 0x1
	// Position of PIN8 field.
	GPIO_IN_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_IN_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_IN_PIN8 = 0x100
	// Pin input is low
	GPIO_IN_PIN8_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN8_High = 0x1
	// Position of PIN9 field.
	GPIO_IN_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_IN_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_IN_PIN9 = 0x200
	// Pin input is low
	GPIO_IN_PIN9_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN9_High = 0x1
	// Position of PIN10 field.
	GPIO_IN_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_IN_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_IN_PIN10 = 0x400
	// Pin input is low
	GPIO_IN_PIN10_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN10_High = 0x1
	// Position of PIN11 field.
	GPIO_IN_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_IN_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_IN_PIN11 = 0x800
	// Pin input is low
	GPIO_IN_PIN11_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN11_High = 0x1
	// Position of PIN12 field.
	GPIO_IN_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_IN_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_IN_PIN12 = 0x1000
	// Pin input is low
	GPIO_IN_PIN12_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN12_High = 0x1
	// Position of PIN13 field.
	GPIO_IN_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_IN_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_IN_PIN13 = 0x2000
	// Pin input is low
	GPIO_IN_PIN13_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN13_High = 0x1
	// Position of PIN14 field.
	GPIO_IN_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_IN_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_IN_PIN14 = 0x4000
	// Pin input is low
	GPIO_IN_PIN14_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN14_High = 0x1
	// Position of PIN15 field.
	GPIO_IN_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_IN_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_IN_PIN15 = 0x8000
	// Pin input is low
	GPIO_IN_PIN15_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN15_High = 0x1
	// Position of PIN16 field.
	GPIO_IN_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_IN_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_IN_PIN16 = 0x10000
	// Pin input is low
	GPIO_IN_PIN16_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN16_High = 0x1
	// Position of PIN17 field.
	GPIO_IN_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_IN_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_IN_PIN17 = 0x20000
	// Pin input is low
	GPIO_IN_PIN17_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN17_High = 0x1
	// Position of PIN18 field.
	GPIO_IN_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_IN_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_IN_PIN18 = 0x40000
	// Pin input is low
	GPIO_IN_PIN18_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN18_High = 0x1
	// Position of PIN19 field.
	GPIO_IN_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_IN_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_IN_PIN19 = 0x80000
	// Pin input is low
	GPIO_IN_PIN19_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN19_High = 0x1
	// Position of PIN20 field.
	GPIO_IN_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_IN_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_IN_PIN20 = 0x100000
	// Pin input is low
	GPIO_IN_PIN20_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN20_High = 0x1
	// Position of PIN21 field.
	GPIO_IN_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_IN_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_IN_PIN21 = 0x200000
	// Pin input is low
	GPIO_IN_PIN21_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN21_High = 0x1
	// Position of PIN22 field.
	GPIO_IN_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_IN_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_IN_PIN22 = 0x400000
	// Pin input is low
	GPIO_IN_PIN22_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN22_High = 0x1
	// Position of PIN23 field.
	GPIO_IN_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_IN_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_IN_PIN23 = 0x800000
	// Pin input is low
	GPIO_IN_PIN23_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN23_High = 0x1
	// Position of PIN24 field.
	GPIO_IN_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_IN_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_IN_PIN24 = 0x1000000
	// Pin input is low
	GPIO_IN_PIN24_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN24_High = 0x1
	// Position of PIN25 field.
	GPIO_IN_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_IN_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_IN_PIN25 = 0x2000000
	// Pin input is low
	GPIO_IN_PIN25_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN25_High = 0x1
	// Position of PIN26 field.
	GPIO_IN_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_IN_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_IN_PIN26 = 0x4000000
	// Pin input is low
	GPIO_IN_PIN26_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN26_High = 0x1
	// Position of PIN27 field.
	GPIO_IN_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_IN_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_IN_PIN27 = 0x8000000
	// Pin input is low
	GPIO_IN_PIN27_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN27_High = 0x1
	// Position of PIN28 field.
	GPIO_IN_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_IN_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_IN_PIN28 = 0x10000000
	// Pin input is low
	GPIO_IN_PIN28_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN28_High = 0x1
	// Position of PIN29 field.
	GPIO_IN_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_IN_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_IN_PIN29 = 0x20000000
	// Pin input is low
	GPIO_IN_PIN29_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN29_High = 0x1
	// Position of PIN30 field.
	GPIO_IN_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_IN_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_IN_PIN30 = 0x40000000
	// Pin input is low
	GPIO_IN_PIN30_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN30_High = 0x1
	// Position of PIN31 field.
	GPIO_IN_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_IN_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_IN_PIN31 = 0x80000000
	// Pin input is low
	GPIO_IN_PIN31_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN31_High = 0x1

	// DIR: Direction of GPIO pins
	// Position of PIN0 field.
	GPIO_DIR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIR_PIN0 = 0x1
	// Pin set as input
	GPIO_DIR_PIN0_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN0_Output = 0x1
	// Position of PIN1 field.
	GPIO_DIR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIR_PIN1 = 0x2
	// Pin set as input
	GPIO_DIR_PIN1_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN1_Output = 0x1
	// Position of PIN2 field.
	GPIO_DIR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIR_PIN2 = 0x4
	// Pin set as input
	GPIO_DIR_PIN2_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN2_Output = 0x1
	// Position of PIN3 field.
	GPIO_DIR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIR_PIN3 = 0x8
	// Pin set as input
	GPIO_DIR_PIN3_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN3_Output = 0x1
	// Position of PIN4 field.
	GPIO_DIR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIR_PIN4 = 0x10
	// Pin set as input
	GPIO_DIR_PIN4_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN4_Output = 0x1
	// Position of PIN5 field.
	GPIO_DIR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIR_PIN5 = 0x20
	// Pin set as input
	GPIO_DIR_PIN5_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN5_Output = 0x1
	// Position of PIN6 field.
	GPIO_DIR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIR_PIN6 = 0x40
	// Pin set as input
	GPIO_DIR_PIN6_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN6_Output = 0x1
	// Position of PIN7 field.
	GPIO_DIR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIR_PIN7 = 0x80
	// Pin set as input
	GPIO_DIR_PIN7_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN7_Output = 0x1
	// Position of PIN8 field.
	GPIO_DIR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIR_PIN8 = 0x100
	// Pin set as input
	GPIO_DIR_PIN8_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN8_Output = 0x1
	// Position of PIN9 field.
	GPIO_DIR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIR_PIN9 = 0x200
	// Pin set as input
	GPIO_DIR_PIN9_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN9_Output = 0x1
	// Position of PIN10 field.
	GPIO_DIR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIR_PIN10 = 0x400
	// Pin set as input
	GPIO_DIR_PIN10_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN10_Output = 0x1
	// Position of PIN11 field.
	GPIO_DIR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIR_PIN11 = 0x800
	// Pin set as input
	GPIO_DIR_PIN11_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN11_Output = 0x1
	// Position of PIN12 field.
	GPIO_DIR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIR_PIN12 = 0x1000
	// Pin set as input
	GPIO_DIR_PIN12_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN12_Output = 0x1
	// Position of PIN13 field.
	GPIO_DIR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIR_PIN13 = 0x2000
	// Pin set as input
	GPIO_DIR_PIN13_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN13_Output = 0x1
	// Position of PIN14 field.
	GPIO_DIR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIR_PIN14 = 0x4000
	// Pin set as input
	GPIO_DIR_PIN14_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN14_Output = 0x1
	// Position of PIN15 field.
	GPIO_DIR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIR_PIN15 = 0x8000
	// Pin set as input
	GPIO_DIR_PIN15_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN15_Output = 0x1
	// Position of PIN16 field.
	GPIO_DIR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIR_PIN16 = 0x10000
	// Pin set as input
	GPIO_DIR_PIN16_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN16_Output = 0x1
	// Position of PIN17 field.
	GPIO_DIR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIR_PIN17 = 0x20000
	// Pin set as input
	GPIO_DIR_PIN17_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN17_Output = 0x1
	// Position of PIN18 field.
	GPIO_DIR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIR_PIN18 = 0x40000
	// Pin set as input
	GPIO_DIR_PIN18_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN18_Output = 0x1
	// Position of PIN19 field.
	GPIO_DIR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIR_PIN19 = 0x80000
	// Pin set as input
	GPIO_DIR_PIN19_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN19_Output = 0x1
	// Position of PIN20 field.
	GPIO_DIR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIR_PIN20 = 0x100000
	// Pin set as input
	GPIO_DIR_PIN20_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN20_Output = 0x1
	// Position of PIN21 field.
	GPIO_DIR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIR_PIN21 = 0x200000
	// Pin set as input
	GPIO_DIR_PIN21_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN21_Output = 0x1
	// Position of PIN22 field.
	GPIO_DIR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIR_PIN22 = 0x400000
	// Pin set as input
	GPIO_DIR_PIN22_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN22_Output = 0x1
	// Position of PIN23 field.
	GPIO_DIR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIR_PIN23 = 0x800000
	// Pin set as input
	GPIO_DIR_PIN23_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN23_Output = 0x1
	// Position of PIN24 field.
	GPIO_DIR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIR_PIN24 = 0x1000000
	// Pin set as input
	GPIO_DIR_PIN24_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN24_Output = 0x1
	// Position of PIN25 field.
	GPIO_DIR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIR_PIN25 = 0x2000000
	// Pin set as input
	GPIO_DIR_PIN25_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN25_Output = 0x1
	// Position of PIN26 field.
	GPIO_DIR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIR_PIN26 = 0x4000000
	// Pin set as input
	GPIO_DIR_PIN26_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN26_Output = 0x1
	// Position of PIN27 field.
	GPIO_DIR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIR_PIN27 = 0x8000000
	// Pin set as input
	GPIO_DIR_PIN27_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN27_Output = 0x1
	// Position of PIN28 field.
	GPIO_DIR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIR_PIN28 = 0x10000000
	// Pin set as input
	GPIO_DIR_PIN28_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN28_Output = 0x1
	// Position of PIN29 field.
	GPIO_DIR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIR_PIN29 = 0x20000000
	// Pin set as input
	GPIO_DIR_PIN29_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN29_Output = 0x1
	// Position of PIN30 field.
	GPIO_DIR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIR_PIN30 = 0x40000000
	// Pin set as input
	GPIO_DIR_PIN30_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN30_Output = 0x1
	// Position of PIN31 field.
	GPIO_DIR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIR_PIN31 = 0x80000000
	// Pin set as input
	GPIO_DIR_PIN31_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN31_Output = 0x1

	// DIRSET: DIR set register
	// Position of PIN0 field.
	GPIO_DIRSET_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIRSET_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIRSET_PIN0 = 0x1
	// Read: pin set as input
	GPIO_DIRSET_PIN0_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN0_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN0_Set = 0x1
	// Position of PIN1 field.
	GPIO_DIRSET_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIRSET_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIRSET_PIN1 = 0x2
	// Read: pin set as input
	GPIO_DIRSET_PIN1_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN1_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN1_Set = 0x1
	// Position of PIN2 field.
	GPIO_DIRSET_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIRSET_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIRSET_PIN2 = 0x4
	// Read: pin set as input
	GPIO_DIRSET_PIN2_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN2_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN2_Set = 0x1
	// Position of PIN3 field.
	GPIO_DIRSET_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIRSET_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIRSET_PIN3 = 0x8
	// Read: pin set as input
	GPIO_DIRSET_PIN3_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN3_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN3_Set = 0x1
	// Position of PIN4 field.
	GPIO_DIRSET_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIRSET_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIRSET_PIN4 = 0x10
	// Read: pin set as input
	GPIO_DIRSET_PIN4_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN4_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN4_Set = 0x1
	// Position of PIN5 field.
	GPIO_DIRSET_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIRSET_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIRSET_PIN5 = 0x20
	// Read: pin set as input
	GPIO_DIRSET_PIN5_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN5_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN5_Set = 0x1
	// Position of PIN6 field.
	GPIO_DIRSET_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIRSET_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIRSET_PIN6 = 0x40
	// Read: pin set as input
	GPIO_DIRSET_PIN6_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN6_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN6_Set = 0x1
	// Position of PIN7 field.
	GPIO_DIRSET_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIRSET_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIRSET_PIN7 = 0x80
	// Read: pin set as input
	GPIO_DIRSET_PIN7_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN7_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN7_Set = 0x1
	// Position of PIN8 field.
	GPIO_DIRSET_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIRSET_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIRSET_PIN8 = 0x100
	// Read: pin set as input
	GPIO_DIRSET_PIN8_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN8_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN8_Set = 0x1
	// Position of PIN9 field.
	GPIO_DIRSET_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIRSET_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIRSET_PIN9 = 0x200
	// Read: pin set as input
	GPIO_DIRSET_PIN9_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN9_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN9_Set = 0x1
	// Position of PIN10 field.
	GPIO_DIRSET_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIRSET_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIRSET_PIN10 = 0x400
	// Read: pin set as input
	GPIO_DIRSET_PIN10_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN10_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN10_Set = 0x1
	// Position of PIN11 field.
	GPIO_DIRSET_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIRSET_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIRSET_PIN11 = 0x800
	// Read: pin set as input
	GPIO_DIRSET_PIN11_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN11_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN11_Set = 0x1
	// Position of PIN12 field.
	GPIO_DIRSET_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIRSET_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIRSET_PIN12 = 0x1000
	// Read: pin set as input
	GPIO_DIRSET_PIN12_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN12_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN12_Set = 0x1
	// Position of PIN13 field.
	GPIO_DIRSET_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIRSET_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIRSET_PIN13 = 0x2000
	// Read: pin set as input
	GPIO_DIRSET_PIN13_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN13_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN13_Set = 0x1
	// Position of PIN14 field.
	GPIO_DIRSET_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIRSET_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIRSET_PIN14 = 0x4000
	// Read: pin set as input
	GPIO_DIRSET_PIN14_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN14_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN14_Set = 0x1
	// Position of PIN15 field.
	GPIO_DIRSET_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIRSET_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIRSET_PIN15 = 0x8000
	// Read: pin set as input
	GPIO_DIRSET_PIN15_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN15_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN15_Set = 0x1
	// Position of PIN16 field.
	GPIO_DIRSET_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIRSET_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIRSET_PIN16 = 0x10000
	// Read: pin set as input
	GPIO_DIRSET_PIN16_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN16_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN16_Set = 0x1
	// Position of PIN17 field.
	GPIO_DIRSET_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIRSET_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIRSET_PIN17 = 0x20000
	// Read: pin set as input
	GPIO_DIRSET_PIN17_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN17_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN17_Set = 0x1
	// Position of PIN18 field.
	GPIO_DIRSET_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIRSET_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIRSET_PIN18 = 0x40000
	// Read: pin set as input
	GPIO_DIRSET_PIN18_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN18_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN18_Set = 0x1
	// Position of PIN19 field.
	GPIO_DIRSET_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIRSET_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIRSET_PIN19 = 0x80000
	// Read: pin set as input
	GPIO_DIRSET_PIN19_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN19_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN19_Set = 0x1
	// Position of PIN20 field.
	GPIO_DIRSET_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIRSET_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIRSET_PIN20 = 0x100000
	// Read: pin set as input
	GPIO_DIRSET_PIN20_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN20_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN20_Set = 0x1
	// Position of PIN21 field.
	GPIO_DIRSET_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIRSET_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIRSET_PIN21 = 0x200000
	// Read: pin set as input
	GPIO_DIRSET_PIN21_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN21_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN21_Set = 0x1
	// Position of PIN22 field.
	GPIO_DIRSET_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIRSET_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIRSET_PIN22 = 0x400000
	// Read: pin set as input
	GPIO_DIRSET_PIN22_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN22_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN22_Set = 0x1
	// Position of PIN23 field.
	GPIO_DIRSET_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIRSET_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIRSET_PIN23 = 0x800000
	// Read: pin set as input
	GPIO_DIRSET_PIN23_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN23_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN23_Set = 0x1
	// Position of PIN24 field.
	GPIO_DIRSET_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIRSET_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIRSET_PIN24 = 0x1000000
	// Read: pin set as input
	GPIO_DIRSET_PIN24_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN24_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN24_Set = 0x1
	// Position of PIN25 field.
	GPIO_DIRSET_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIRSET_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIRSET_PIN25 = 0x2000000
	// Read: pin set as input
	GPIO_DIRSET_PIN25_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN25_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN25_Set = 0x1
	// Position of PIN26 field.
	GPIO_DIRSET_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIRSET_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIRSET_PIN26 = 0x4000000
	// Read: pin set as input
	GPIO_DIRSET_PIN26_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN26_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN26_Set = 0x1
	// Position of PIN27 field.
	GPIO_DIRSET_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIRSET_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIRSET_PIN27 = 0x8000000
	// Read: pin set as input
	GPIO_DIRSET_PIN27_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN27_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN27_Set = 0x1
	// Position of PIN28 field.
	GPIO_DIRSET_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIRSET_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIRSET_PIN28 = 0x10000000
	// Read: pin set as input
	GPIO_DIRSET_PIN28_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN28_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN28_Set = 0x1
	// Position of PIN29 field.
	GPIO_DIRSET_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIRSET_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIRSET_PIN29 = 0x20000000
	// Read: pin set as input
	GPIO_DIRSET_PIN29_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN29_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN29_Set = 0x1
	// Position of PIN30 field.
	GPIO_DIRSET_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIRSET_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIRSET_PIN30 = 0x40000000
	// Read: pin set as input
	GPIO_DIRSET_PIN30_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN30_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN30_Set = 0x1
	// Position of PIN31 field.
	GPIO_DIRSET_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIRSET_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIRSET_PIN31 = 0x80000000
	// Read: pin set as input
	GPIO_DIRSET_PIN31_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN31_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN31_Set = 0x1

	// DIRCLR: DIR clear register
	// Position of PIN0 field.
	GPIO_DIRCLR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIRCLR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIRCLR_PIN0 = 0x1
	// Read: pin set as input
	GPIO_DIRCLR_PIN0_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN0_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN0_Clear = 0x1
	// Position of PIN1 field.
	GPIO_DIRCLR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIRCLR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIRCLR_PIN1 = 0x2
	// Read: pin set as input
	GPIO_DIRCLR_PIN1_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN1_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN1_Clear = 0x1
	// Position of PIN2 field.
	GPIO_DIRCLR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIRCLR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIRCLR_PIN2 = 0x4
	// Read: pin set as input
	GPIO_DIRCLR_PIN2_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN2_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN2_Clear = 0x1
	// Position of PIN3 field.
	GPIO_DIRCLR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIRCLR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIRCLR_PIN3 = 0x8
	// Read: pin set as input
	GPIO_DIRCLR_PIN3_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN3_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN3_Clear = 0x1
	// Position of PIN4 field.
	GPIO_DIRCLR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIRCLR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIRCLR_PIN4 = 0x10
	// Read: pin set as input
	GPIO_DIRCLR_PIN4_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN4_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN4_Clear = 0x1
	// Position of PIN5 field.
	GPIO_DIRCLR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIRCLR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIRCLR_PIN5 = 0x20
	// Read: pin set as input
	GPIO_DIRCLR_PIN5_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN5_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN5_Clear = 0x1
	// Position of PIN6 field.
	GPIO_DIRCLR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIRCLR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIRCLR_PIN6 = 0x40
	// Read: pin set as input
	GPIO_DIRCLR_PIN6_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN6_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN6_Clear = 0x1
	// Position of PIN7 field.
	GPIO_DIRCLR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIRCLR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIRCLR_PIN7 = 0x80
	// Read: pin set as input
	GPIO_DIRCLR_PIN7_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN7_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN7_Clear = 0x1
	// Position of PIN8 field.
	GPIO_DIRCLR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIRCLR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIRCLR_PIN8 = 0x100
	// Read: pin set as input
	GPIO_DIRCLR_PIN8_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN8_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN8_Clear = 0x1
	// Position of PIN9 field.
	GPIO_DIRCLR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIRCLR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIRCLR_PIN9 = 0x200
	// Read: pin set as input
	GPIO_DIRCLR_PIN9_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN9_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN9_Clear = 0x1
	// Position of PIN10 field.
	GPIO_DIRCLR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIRCLR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIRCLR_PIN10 = 0x400
	// Read: pin set as input
	GPIO_DIRCLR_PIN10_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN10_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN10_Clear = 0x1
	// Position of PIN11 field.
	GPIO_DIRCLR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIRCLR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIRCLR_PIN11 = 0x800
	// Read: pin set as input
	GPIO_DIRCLR_PIN11_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN11_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN11_Clear = 0x1
	// Position of PIN12 field.
	GPIO_DIRCLR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIRCLR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIRCLR_PIN12 = 0x1000
	// Read: pin set as input
	GPIO_DIRCLR_PIN12_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN12_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN12_Clear = 0x1
	// Position of PIN13 field.
	GPIO_DIRCLR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIRCLR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIRCLR_PIN13 = 0x2000
	// Read: pin set as input
	GPIO_DIRCLR_PIN13_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN13_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN13_Clear = 0x1
	// Position of PIN14 field.
	GPIO_DIRCLR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIRCLR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIRCLR_PIN14 = 0x4000
	// Read: pin set as input
	GPIO_DIRCLR_PIN14_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN14_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN14_Clear = 0x1
	// Position of PIN15 field.
	GPIO_DIRCLR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIRCLR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIRCLR_PIN15 = 0x8000
	// Read: pin set as input
	GPIO_DIRCLR_PIN15_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN15_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN15_Clear = 0x1
	// Position of PIN16 field.
	GPIO_DIRCLR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIRCLR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIRCLR_PIN16 = 0x10000
	// Read: pin set as input
	GPIO_DIRCLR_PIN16_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN16_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN16_Clear = 0x1
	// Position of PIN17 field.
	GPIO_DIRCLR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIRCLR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIRCLR_PIN17 = 0x20000
	// Read: pin set as input
	GPIO_DIRCLR_PIN17_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN17_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN17_Clear = 0x1
	// Position of PIN18 field.
	GPIO_DIRCLR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIRCLR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIRCLR_PIN18 = 0x40000
	// Read: pin set as input
	GPIO_DIRCLR_PIN18_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN18_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN18_Clear = 0x1
	// Position of PIN19 field.
	GPIO_DIRCLR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIRCLR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIRCLR_PIN19 = 0x80000
	// Read: pin set as input
	GPIO_DIRCLR_PIN19_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN19_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN19_Clear = 0x1
	// Position of PIN20 field.
	GPIO_DIRCLR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIRCLR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIRCLR_PIN20 = 0x100000
	// Read: pin set as input
	GPIO_DIRCLR_PIN20_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN20_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN20_Clear = 0x1
	// Position of PIN21 field.
	GPIO_DIRCLR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIRCLR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIRCLR_PIN21 = 0x200000
	// Read: pin set as input
	GPIO_DIRCLR_PIN21_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN21_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN21_Clear = 0x1
	// Position of PIN22 field.
	GPIO_DIRCLR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIRCLR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIRCLR_PIN22 = 0x400000
	// Read: pin set as input
	GPIO_DIRCLR_PIN22_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN22_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN22_Clear = 0x1
	// Position of PIN23 field.
	GPIO_DIRCLR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIRCLR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIRCLR_PIN23 = 0x800000
	// Read: pin set as input
	GPIO_DIRCLR_PIN23_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN23_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN23_Clear = 0x1
	// Position of PIN24 field.
	GPIO_DIRCLR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIRCLR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIRCLR_PIN24 = 0x1000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN24_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN24_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN24_Clear = 0x1
	// Position of PIN25 field.
	GPIO_DIRCLR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIRCLR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIRCLR_PIN25 = 0x2000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN25_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN25_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN25_Clear = 0x1
	// Position of PIN26 field.
	GPIO_DIRCLR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIRCLR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIRCLR_PIN26 = 0x4000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN26_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN26_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN26_Clear = 0x1
	// Position of PIN27 field.
	GPIO_DIRCLR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIRCLR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIRCLR_PIN27 = 0x8000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN27_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN27_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN27_Clear = 0x1
	// Position of PIN28 field.
	GPIO_DIRCLR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIRCLR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIRCLR_PIN28 = 0x10000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN28_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN28_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN28_Clear = 0x1
	// Position of PIN29 field.
	GPIO_DIRCLR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIRCLR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIRCLR_PIN29 = 0x20000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN29_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN29_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN29_Clear = 0x1
	// Position of PIN30 field.
	GPIO_DIRCLR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIRCLR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIRCLR_PIN30 = 0x40000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN30_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN30_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN30_Clear = 0x1
	// Position of PIN31 field.
	GPIO_DIRCLR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIRCLR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIRCLR_PIN31 = 0x80000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN31_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN31_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN31_Clear = 0x1

	// LATCH: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
	// Position of PIN0 field.
	GPIO_LATCH_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_LATCH_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_LATCH_PIN0 = 0x1
	// Criteria has not been met
	GPIO_LATCH_PIN0_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN0_Latched = 0x1
	// Position of PIN1 field.
	GPIO_LATCH_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_LATCH_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_LATCH_PIN1 = 0x2
	// Criteria has not been met
	GPIO_LATCH_PIN1_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN1_Latched = 0x1
	// Position of PIN2 field.
	GPIO_LATCH_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_LATCH_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_LATCH_PIN2 = 0x4
	// Criteria has not been met
	GPIO_LATCH_PIN2_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN2_Latched = 0x1
	// Position of PIN3 field.
	GPIO_LATCH_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_LATCH_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_LATCH_PIN3 = 0x8
	// Criteria has not been met
	GPIO_LATCH_PIN3_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN3_Latched = 0x1
	// Position of PIN4 field.
	GPIO_LATCH_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_LATCH_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_LATCH_PIN4 = 0x10
	// Criteria has not been met
	GPIO_LATCH_PIN4_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN4_Latched = 0x1
	// Position of PIN5 field.
	GPIO_LATCH_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_LATCH_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_LATCH_PIN5 = 0x20
	// Criteria has not been met
	GPIO_LATCH_PIN5_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN5_Latched = 0x1
	// Position of PIN6 field.
	GPIO_LATCH_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_LATCH_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_LATCH_PIN6 = 0x40
	// Criteria has not been met
	GPIO_LATCH_PIN6_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN6_Latched = 0x1
	// Position of PIN7 field.
	GPIO_LATCH_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_LATCH_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_LATCH_PIN7 = 0x80
	// Criteria has not been met
	GPIO_LATCH_PIN7_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN7_Latched = 0x1
	// Position of PIN8 field.
	GPIO_LATCH_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_LATCH_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_LATCH_PIN8 = 0x100
	// Criteria has not been met
	GPIO_LATCH_PIN8_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN8_Latched = 0x1
	// Position of PIN9 field.
	GPIO_LATCH_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_LATCH_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_LATCH_PIN9 = 0x200
	// Criteria has not been met
	GPIO_LATCH_PIN9_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN9_Latched = 0x1
	// Position of PIN10 field.
	GPIO_LATCH_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_LATCH_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_LATCH_PIN10 = 0x400
	// Criteria has not been met
	GPIO_LATCH_PIN10_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN10_Latched = 0x1
	// Position of PIN11 field.
	GPIO_LATCH_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_LATCH_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_LATCH_PIN11 = 0x800
	// Criteria has not been met
	GPIO_LATCH_PIN11_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN11_Latched = 0x1
	// Position of PIN12 field.
	GPIO_LATCH_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_LATCH_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_LATCH_PIN12 = 0x1000
	// Criteria has not been met
	GPIO_LATCH_PIN12_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN12_Latched = 0x1
	// Position of PIN13 field.
	GPIO_LATCH_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_LATCH_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_LATCH_PIN13 = 0x2000
	// Criteria has not been met
	GPIO_LATCH_PIN13_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN13_Latched = 0x1
	// Position of PIN14 field.
	GPIO_LATCH_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_LATCH_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_LATCH_PIN14 = 0x4000
	// Criteria has not been met
	GPIO_LATCH_PIN14_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN14_Latched = 0x1
	// Position of PIN15 field.
	GPIO_LATCH_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_LATCH_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_LATCH_PIN15 = 0x8000
	// Criteria has not been met
	GPIO_LATCH_PIN15_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN15_Latched = 0x1
	// Position of PIN16 field.
	GPIO_LATCH_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_LATCH_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_LATCH_PIN16 = 0x10000
	// Criteria has not been met
	GPIO_LATCH_PIN16_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN16_Latched = 0x1
	// Position of PIN17 field.
	GPIO_LATCH_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_LATCH_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_LATCH_PIN17 = 0x20000
	// Criteria has not been met
	GPIO_LATCH_PIN17_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN17_Latched = 0x1
	// Position of PIN18 field.
	GPIO_LATCH_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_LATCH_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_LATCH_PIN18 = 0x40000
	// Criteria has not been met
	GPIO_LATCH_PIN18_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN18_Latched = 0x1
	// Position of PIN19 field.
	GPIO_LATCH_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_LATCH_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_LATCH_PIN19 = 0x80000
	// Criteria has not been met
	GPIO_LATCH_PIN19_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN19_Latched = 0x1
	// Position of PIN20 field.
	GPIO_LATCH_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_LATCH_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_LATCH_PIN20 = 0x100000
	// Criteria has not been met
	GPIO_LATCH_PIN20_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN20_Latched = 0x1
	// Position of PIN21 field.
	GPIO_LATCH_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_LATCH_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_LATCH_PIN21 = 0x200000
	// Criteria has not been met
	GPIO_LATCH_PIN21_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN21_Latched = 0x1
	// Position of PIN22 field.
	GPIO_LATCH_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_LATCH_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_LATCH_PIN22 = 0x400000
	// Criteria has not been met
	GPIO_LATCH_PIN22_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN22_Latched = 0x1
	// Position of PIN23 field.
	GPIO_LATCH_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_LATCH_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_LATCH_PIN23 = 0x800000
	// Criteria has not been met
	GPIO_LATCH_PIN23_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN23_Latched = 0x1
	// Position of PIN24 field.
	GPIO_LATCH_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_LATCH_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_LATCH_PIN24 = 0x1000000
	// Criteria has not been met
	GPIO_LATCH_PIN24_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN24_Latched = 0x1
	// Position of PIN25 field.
	GPIO_LATCH_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_LATCH_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_LATCH_PIN25 = 0x2000000
	// Criteria has not been met
	GPIO_LATCH_PIN25_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN25_Latched = 0x1
	// Position of PIN26 field.
	GPIO_LATCH_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_LATCH_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_LATCH_PIN26 = 0x4000000
	// Criteria has not been met
	GPIO_LATCH_PIN26_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN26_Latched = 0x1
	// Position of PIN27 field.
	GPIO_LATCH_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_LATCH_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_LATCH_PIN27 = 0x8000000
	// Criteria has not been met
	GPIO_LATCH_PIN27_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN27_Latched = 0x1
	// Position of PIN28 field.
	GPIO_LATCH_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_LATCH_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_LATCH_PIN28 = 0x10000000
	// Criteria has not been met
	GPIO_LATCH_PIN28_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN28_Latched = 0x1
	// Position of PIN29 field.
	GPIO_LATCH_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_LATCH_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_LATCH_PIN29 = 0x20000000
	// Criteria has not been met
	GPIO_LATCH_PIN29_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN29_Latched = 0x1
	// Position of PIN30 field.
	GPIO_LATCH_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_LATCH_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_LATCH_PIN30 = 0x40000000
	// Criteria has not been met
	GPIO_LATCH_PIN30_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN30_Latched = 0x1
	// Position of PIN31 field.
	GPIO_LATCH_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_LATCH_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_LATCH_PIN31 = 0x80000000
	// Criteria has not been met
	GPIO_LATCH_PIN31_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN31_Latched = 0x1

	// DETECTMODE: Select between default DETECT signal behavior and LDETECT mode (For non-secure pin only)
	// Position of DETECTMODE field.
	GPIO_DETECTMODE_DETECTMODE_Pos = 0x0
	// Bit mask of DETECTMODE field.
	GPIO_DETECTMODE_DETECTMODE_Msk = 0x1
	// Bit DETECTMODE.
	GPIO_DETECTMODE_DETECTMODE = 0x1
	// DETECT directly connected to PIN DETECT signals
	GPIO_DETECTMODE_DETECTMODE_Default = 0x0
	// Use the latched LDETECT behavior
	GPIO_DETECTMODE_DETECTMODE_LDETECT = 0x1

	// DETECTMODE_SEC: Select between default DETECT signal behavior and LDETECT mode (For secure pin only)
	// Position of DETECTMODE field.
	GPIO_DETECTMODE_SEC_DETECTMODE_Pos = 0x0
	// Bit mask of DETECTMODE field.
	GPIO_DETECTMODE_SEC_DETECTMODE_Msk = 0x1
	// Bit DETECTMODE.
	GPIO_DETECTMODE_SEC_DETECTMODE = 0x1
	// DETECT directly connected to PIN DETECT signals
	GPIO_DETECTMODE_SEC_DETECTMODE_Default = 0x0
	// Use the latched LDETECT behavior
	GPIO_DETECTMODE_SEC_DETECTMODE_LDETECT = 0x1

	// PIN_CNF: Description collection: Configuration of GPIO pins
	// Position of DIR field.
	GPIO_PIN_CNF_DIR_Pos = 0x0
	// Bit mask of DIR field.
	GPIO_PIN_CNF_DIR_Msk = 0x1
	// Bit DIR.
	GPIO_PIN_CNF_DIR = 0x1
	// Configure pin as an input pin
	GPIO_PIN_CNF_DIR_Input = 0x0
	// Configure pin as an output pin
	GPIO_PIN_CNF_DIR_Output = 0x1
	// Position of INPUT field.
	GPIO_PIN_CNF_INPUT_Pos = 0x1
	// Bit mask of INPUT field.
	GPIO_PIN_CNF_INPUT_Msk = 0x2
	// Bit INPUT.
	GPIO_PIN_CNF_INPUT = 0x2
	// Connect input buffer
	GPIO_PIN_CNF_INPUT_Connect = 0x0
	// Disconnect input buffer
	GPIO_PIN_CNF_INPUT_Disconnect = 0x1
	// Position of PULL field.
	GPIO_PIN_CNF_PULL_Pos = 0x2
	// Bit mask of PULL field.
	GPIO_PIN_CNF_PULL_Msk = 0xc
	// No pull
	GPIO_PIN_CNF_PULL_Disabled = 0x0
	// Pull down on pin
	GPIO_PIN_CNF_PULL_Pulldown = 0x1
	// Pull up on pin
	GPIO_PIN_CNF_PULL_Pullup = 0x3
	// Position of DRIVE field.
	GPIO_PIN_CNF_DRIVE_Pos = 0x8
	// Bit mask of DRIVE field.
	GPIO_PIN_CNF_DRIVE_Msk = 0xf00
	// Standard '0', standard '1'
	GPIO_PIN_CNF_DRIVE_S0S1 = 0x0
	// High drive '0', standard '1'
	GPIO_PIN_CNF_DRIVE_H0S1 = 0x1
	// Standard '0', high drive '1'
	GPIO_PIN_CNF_DRIVE_S0H1 = 0x2
	// High drive '0', high 'drive '1''
	GPIO_PIN_CNF_DRIVE_H0H1 = 0x3
	// Disconnect '0', standard '1' (normally used for wired-or connections)
	GPIO_PIN_CNF_DRIVE_D0S1 = 0x4
	// Disconnect '0', high drive '1' (normally used for wired-or connections)
	GPIO_PIN_CNF_DRIVE_D0H1 = 0x5
	// Standard '0', disconnect '1' (normally used for wired-and connections)
	GPIO_PIN_CNF_DRIVE_S0D1 = 0x6
	// High drive '0', disconnect '1' (normally used for wired-and connections)
	GPIO_PIN_CNF_DRIVE_H0D1 = 0x7
	// Extra high drive '0', extra high drive '1'
	GPIO_PIN_CNF_DRIVE_E0E1 = 0xb
	// Position of SENSE field.
	GPIO_PIN_CNF_SENSE_Pos = 0x10
	// Bit mask of SENSE field.
	GPIO_PIN_CNF_SENSE_Msk = 0x30000
	// Disabled
	GPIO_PIN_CNF_SENSE_Disabled = 0x0
	// Sense for high level
	GPIO_PIN_CNF_SENSE_High = 0x2
	// Sense for low level
	GPIO_PIN_CNF_SENSE_Low = 0x3
	// Position of MCUSEL field.
	GPIO_PIN_CNF_MCUSEL_Pos = 0x1c
	// Bit mask of MCUSEL field.
	GPIO_PIN_CNF_MCUSEL_Msk = 0x70000000
	// Application MCU
	GPIO_PIN_CNF_MCUSEL_AppMCU = 0x0
	// Network MCU
	GPIO_PIN_CNF_MCUSEL_NetworkMCU = 0x1
	// Peripheral with dedicated pins
	GPIO_PIN_CNF_MCUSEL_Peripheral = 0x3
	// Trace and Debug Subsystem
	GPIO_PIN_CNF_MCUSEL_TND = 0x7
)

// Constants for CRYPTOCELL_S: ARM TrustZone CryptoCell register interface
const (
	// ENABLE: Enable CRYPTOCELL subsystem.
	// Position of ENABLE field.
	CRYPTOCELL_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CRYPTOCELL_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	CRYPTOCELL_ENABLE_ENABLE = 0x1
	// CRYPTOCELL subsystem disabled.
	CRYPTOCELL_ENABLE_ENABLE_Disabled = 0x0
	// CRYPTOCELL subsystem enabled.
	CRYPTOCELL_ENABLE_ENABLE_Enabled = 0x1
)

// Constants for VMC_NS: Volatile Memory controller 0
const (
	// RAM.POWER: Description cluster: RAM[n] power control register
	// Position of S0POWER field.
	VMC_RAM_POWER_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	VMC_RAM_POWER_S0POWER_Msk = 0x1
	// Bit S0POWER.
	VMC_RAM_POWER_S0POWER = 0x1
	// Off
	VMC_RAM_POWER_S0POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S0POWER_On = 0x1
	// Position of S1POWER field.
	VMC_RAM_POWER_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	VMC_RAM_POWER_S1POWER_Msk = 0x2
	// Bit S1POWER.
	VMC_RAM_POWER_S1POWER = 0x2
	// Off
	VMC_RAM_POWER_S1POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S1POWER_On = 0x1
	// Position of S2POWER field.
	VMC_RAM_POWER_S2POWER_Pos = 0x2
	// Bit mask of S2POWER field.
	VMC_RAM_POWER_S2POWER_Msk = 0x4
	// Bit S2POWER.
	VMC_RAM_POWER_S2POWER = 0x4
	// Off
	VMC_RAM_POWER_S2POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S2POWER_On = 0x1
	// Position of S3POWER field.
	VMC_RAM_POWER_S3POWER_Pos = 0x3
	// Bit mask of S3POWER field.
	VMC_RAM_POWER_S3POWER_Msk = 0x8
	// Bit S3POWER.
	VMC_RAM_POWER_S3POWER = 0x8
	// Off
	VMC_RAM_POWER_S3POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S3POWER_On = 0x1
	// Position of S4POWER field.
	VMC_RAM_POWER_S4POWER_Pos = 0x4
	// Bit mask of S4POWER field.
	VMC_RAM_POWER_S4POWER_Msk = 0x10
	// Bit S4POWER.
	VMC_RAM_POWER_S4POWER = 0x10
	// Off
	VMC_RAM_POWER_S4POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S4POWER_On = 0x1
	// Position of S5POWER field.
	VMC_RAM_POWER_S5POWER_Pos = 0x5
	// Bit mask of S5POWER field.
	VMC_RAM_POWER_S5POWER_Msk = 0x20
	// Bit S5POWER.
	VMC_RAM_POWER_S5POWER = 0x20
	// Off
	VMC_RAM_POWER_S5POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S5POWER_On = 0x1
	// Position of S6POWER field.
	VMC_RAM_POWER_S6POWER_Pos = 0x6
	// Bit mask of S6POWER field.
	VMC_RAM_POWER_S6POWER_Msk = 0x40
	// Bit S6POWER.
	VMC_RAM_POWER_S6POWER = 0x40
	// Off
	VMC_RAM_POWER_S6POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S6POWER_On = 0x1
	// Position of S7POWER field.
	VMC_RAM_POWER_S7POWER_Pos = 0x7
	// Bit mask of S7POWER field.
	VMC_RAM_POWER_S7POWER_Msk = 0x80
	// Bit S7POWER.
	VMC_RAM_POWER_S7POWER = 0x80
	// Off
	VMC_RAM_POWER_S7POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S7POWER_On = 0x1
	// Position of S8POWER field.
	VMC_RAM_POWER_S8POWER_Pos = 0x8
	// Bit mask of S8POWER field.
	VMC_RAM_POWER_S8POWER_Msk = 0x100
	// Bit S8POWER.
	VMC_RAM_POWER_S8POWER = 0x100
	// Off
	VMC_RAM_POWER_S8POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S8POWER_On = 0x1
	// Position of S9POWER field.
	VMC_RAM_POWER_S9POWER_Pos = 0x9
	// Bit mask of S9POWER field.
	VMC_RAM_POWER_S9POWER_Msk = 0x200
	// Bit S9POWER.
	VMC_RAM_POWER_S9POWER = 0x200
	// Off
	VMC_RAM_POWER_S9POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S9POWER_On = 0x1
	// Position of S10POWER field.
	VMC_RAM_POWER_S10POWER_Pos = 0xa
	// Bit mask of S10POWER field.
	VMC_RAM_POWER_S10POWER_Msk = 0x400
	// Bit S10POWER.
	VMC_RAM_POWER_S10POWER = 0x400
	// Off
	VMC_RAM_POWER_S10POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S10POWER_On = 0x1
	// Position of S11POWER field.
	VMC_RAM_POWER_S11POWER_Pos = 0xb
	// Bit mask of S11POWER field.
	VMC_RAM_POWER_S11POWER_Msk = 0x800
	// Bit S11POWER.
	VMC_RAM_POWER_S11POWER = 0x800
	// Off
	VMC_RAM_POWER_S11POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S11POWER_On = 0x1
	// Position of S12POWER field.
	VMC_RAM_POWER_S12POWER_Pos = 0xc
	// Bit mask of S12POWER field.
	VMC_RAM_POWER_S12POWER_Msk = 0x1000
	// Bit S12POWER.
	VMC_RAM_POWER_S12POWER = 0x1000
	// Off
	VMC_RAM_POWER_S12POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S12POWER_On = 0x1
	// Position of S13POWER field.
	VMC_RAM_POWER_S13POWER_Pos = 0xd
	// Bit mask of S13POWER field.
	VMC_RAM_POWER_S13POWER_Msk = 0x2000
	// Bit S13POWER.
	VMC_RAM_POWER_S13POWER = 0x2000
	// Off
	VMC_RAM_POWER_S13POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S13POWER_On = 0x1
	// Position of S14POWER field.
	VMC_RAM_POWER_S14POWER_Pos = 0xe
	// Bit mask of S14POWER field.
	VMC_RAM_POWER_S14POWER_Msk = 0x4000
	// Bit S14POWER.
	VMC_RAM_POWER_S14POWER = 0x4000
	// Off
	VMC_RAM_POWER_S14POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S14POWER_On = 0x1
	// Position of S15POWER field.
	VMC_RAM_POWER_S15POWER_Pos = 0xf
	// Bit mask of S15POWER field.
	VMC_RAM_POWER_S15POWER_Msk = 0x8000
	// Bit S15POWER.
	VMC_RAM_POWER_S15POWER = 0x8000
	// Off
	VMC_RAM_POWER_S15POWER_Off = 0x0
	// On
	VMC_RAM_POWER_S15POWER_On = 0x1
	// Position of S0RETENTION field.
	VMC_RAM_POWER_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	VMC_RAM_POWER_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	VMC_RAM_POWER_S0RETENTION = 0x10000
	// Off
	VMC_RAM_POWER_S0RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S0RETENTION_On = 0x1
	// Position of S1RETENTION field.
	VMC_RAM_POWER_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	VMC_RAM_POWER_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	VMC_RAM_POWER_S1RETENTION = 0x20000
	// Off
	VMC_RAM_POWER_S1RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S1RETENTION_On = 0x1
	// Position of S2RETENTION field.
	VMC_RAM_POWER_S2RETENTION_Pos = 0x12
	// Bit mask of S2RETENTION field.
	VMC_RAM_POWER_S2RETENTION_Msk = 0x40000
	// Bit S2RETENTION.
	VMC_RAM_POWER_S2RETENTION = 0x40000
	// Off
	VMC_RAM_POWER_S2RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S2RETENTION_On = 0x1
	// Position of S3RETENTION field.
	VMC_RAM_POWER_S3RETENTION_Pos = 0x13
	// Bit mask of S3RETENTION field.
	VMC_RAM_POWER_S3RETENTION_Msk = 0x80000
	// Bit S3RETENTION.
	VMC_RAM_POWER_S3RETENTION = 0x80000
	// Off
	VMC_RAM_POWER_S3RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S3RETENTION_On = 0x1
	// Position of S4RETENTION field.
	VMC_RAM_POWER_S4RETENTION_Pos = 0x14
	// Bit mask of S4RETENTION field.
	VMC_RAM_POWER_S4RETENTION_Msk = 0x100000
	// Bit S4RETENTION.
	VMC_RAM_POWER_S4RETENTION = 0x100000
	// Off
	VMC_RAM_POWER_S4RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S4RETENTION_On = 0x1
	// Position of S5RETENTION field.
	VMC_RAM_POWER_S5RETENTION_Pos = 0x15
	// Bit mask of S5RETENTION field.
	VMC_RAM_POWER_S5RETENTION_Msk = 0x200000
	// Bit S5RETENTION.
	VMC_RAM_POWER_S5RETENTION = 0x200000
	// Off
	VMC_RAM_POWER_S5RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S5RETENTION_On = 0x1
	// Position of S6RETENTION field.
	VMC_RAM_POWER_S6RETENTION_Pos = 0x16
	// Bit mask of S6RETENTION field.
	VMC_RAM_POWER_S6RETENTION_Msk = 0x400000
	// Bit S6RETENTION.
	VMC_RAM_POWER_S6RETENTION = 0x400000
	// Off
	VMC_RAM_POWER_S6RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S6RETENTION_On = 0x1
	// Position of S7RETENTION field.
	VMC_RAM_POWER_S7RETENTION_Pos = 0x17
	// Bit mask of S7RETENTION field.
	VMC_RAM_POWER_S7RETENTION_Msk = 0x800000
	// Bit S7RETENTION.
	VMC_RAM_POWER_S7RETENTION = 0x800000
	// Off
	VMC_RAM_POWER_S7RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S7RETENTION_On = 0x1
	// Position of S8RETENTION field.
	VMC_RAM_POWER_S8RETENTION_Pos = 0x18
	// Bit mask of S8RETENTION field.
	VMC_RAM_POWER_S8RETENTION_Msk = 0x1000000
	// Bit S8RETENTION.
	VMC_RAM_POWER_S8RETENTION = 0x1000000
	// Off
	VMC_RAM_POWER_S8RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S8RETENTION_On = 0x1
	// Position of S9RETENTION field.
	VMC_RAM_POWER_S9RETENTION_Pos = 0x19
	// Bit mask of S9RETENTION field.
	VMC_RAM_POWER_S9RETENTION_Msk = 0x2000000
	// Bit S9RETENTION.
	VMC_RAM_POWER_S9RETENTION = 0x2000000
	// Off
	VMC_RAM_POWER_S9RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S9RETENTION_On = 0x1
	// Position of S10RETENTION field.
	VMC_RAM_POWER_S10RETENTION_Pos = 0x1a
	// Bit mask of S10RETENTION field.
	VMC_RAM_POWER_S10RETENTION_Msk = 0x4000000
	// Bit S10RETENTION.
	VMC_RAM_POWER_S10RETENTION = 0x4000000
	// Off
	VMC_RAM_POWER_S10RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S10RETENTION_On = 0x1
	// Position of S11RETENTION field.
	VMC_RAM_POWER_S11RETENTION_Pos = 0x1b
	// Bit mask of S11RETENTION field.
	VMC_RAM_POWER_S11RETENTION_Msk = 0x8000000
	// Bit S11RETENTION.
	VMC_RAM_POWER_S11RETENTION = 0x8000000
	// Off
	VMC_RAM_POWER_S11RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S11RETENTION_On = 0x1
	// Position of S12RETENTION field.
	VMC_RAM_POWER_S12RETENTION_Pos = 0x1c
	// Bit mask of S12RETENTION field.
	VMC_RAM_POWER_S12RETENTION_Msk = 0x10000000
	// Bit S12RETENTION.
	VMC_RAM_POWER_S12RETENTION = 0x10000000
	// Off
	VMC_RAM_POWER_S12RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S12RETENTION_On = 0x1
	// Position of S13RETENTION field.
	VMC_RAM_POWER_S13RETENTION_Pos = 0x1d
	// Bit mask of S13RETENTION field.
	VMC_RAM_POWER_S13RETENTION_Msk = 0x20000000
	// Bit S13RETENTION.
	VMC_RAM_POWER_S13RETENTION = 0x20000000
	// Off
	VMC_RAM_POWER_S13RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S13RETENTION_On = 0x1
	// Position of S14RETENTION field.
	VMC_RAM_POWER_S14RETENTION_Pos = 0x1e
	// Bit mask of S14RETENTION field.
	VMC_RAM_POWER_S14RETENTION_Msk = 0x40000000
	// Bit S14RETENTION.
	VMC_RAM_POWER_S14RETENTION = 0x40000000
	// Off
	VMC_RAM_POWER_S14RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S14RETENTION_On = 0x1
	// Position of S15RETENTION field.
	VMC_RAM_POWER_S15RETENTION_Pos = 0x1f
	// Bit mask of S15RETENTION field.
	VMC_RAM_POWER_S15RETENTION_Msk = 0x80000000
	// Bit S15RETENTION.
	VMC_RAM_POWER_S15RETENTION = 0x80000000
	// Off
	VMC_RAM_POWER_S15RETENTION_Off = 0x0
	// On
	VMC_RAM_POWER_S15RETENTION_On = 0x1

	// RAM.POWERSET: Description cluster: RAM[n] power control set register
	// Position of S0POWER field.
	VMC_RAM_POWERSET_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	VMC_RAM_POWERSET_S0POWER_Msk = 0x1
	// Bit S0POWER.
	VMC_RAM_POWERSET_S0POWER = 0x1
	// On
	VMC_RAM_POWERSET_S0POWER_On = 0x1
	// Position of S1POWER field.
	VMC_RAM_POWERSET_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	VMC_RAM_POWERSET_S1POWER_Msk = 0x2
	// Bit S1POWER.
	VMC_RAM_POWERSET_S1POWER = 0x2
	// On
	VMC_RAM_POWERSET_S1POWER_On = 0x1
	// Position of S2POWER field.
	VMC_RAM_POWERSET_S2POWER_Pos = 0x2
	// Bit mask of S2POWER field.
	VMC_RAM_POWERSET_S2POWER_Msk = 0x4
	// Bit S2POWER.
	VMC_RAM_POWERSET_S2POWER = 0x4
	// On
	VMC_RAM_POWERSET_S2POWER_On = 0x1
	// Position of S3POWER field.
	VMC_RAM_POWERSET_S3POWER_Pos = 0x3
	// Bit mask of S3POWER field.
	VMC_RAM_POWERSET_S3POWER_Msk = 0x8
	// Bit S3POWER.
	VMC_RAM_POWERSET_S3POWER = 0x8
	// On
	VMC_RAM_POWERSET_S3POWER_On = 0x1
	// Position of S4POWER field.
	VMC_RAM_POWERSET_S4POWER_Pos = 0x4
	// Bit mask of S4POWER field.
	VMC_RAM_POWERSET_S4POWER_Msk = 0x10
	// Bit S4POWER.
	VMC_RAM_POWERSET_S4POWER = 0x10
	// On
	VMC_RAM_POWERSET_S4POWER_On = 0x1
	// Position of S5POWER field.
	VMC_RAM_POWERSET_S5POWER_Pos = 0x5
	// Bit mask of S5POWER field.
	VMC_RAM_POWERSET_S5POWER_Msk = 0x20
	// Bit S5POWER.
	VMC_RAM_POWERSET_S5POWER = 0x20
	// On
	VMC_RAM_POWERSET_S5POWER_On = 0x1
	// Position of S6POWER field.
	VMC_RAM_POWERSET_S6POWER_Pos = 0x6
	// Bit mask of S6POWER field.
	VMC_RAM_POWERSET_S6POWER_Msk = 0x40
	// Bit S6POWER.
	VMC_RAM_POWERSET_S6POWER = 0x40
	// On
	VMC_RAM_POWERSET_S6POWER_On = 0x1
	// Position of S7POWER field.
	VMC_RAM_POWERSET_S7POWER_Pos = 0x7
	// Bit mask of S7POWER field.
	VMC_RAM_POWERSET_S7POWER_Msk = 0x80
	// Bit S7POWER.
	VMC_RAM_POWERSET_S7POWER = 0x80
	// On
	VMC_RAM_POWERSET_S7POWER_On = 0x1
	// Position of S8POWER field.
	VMC_RAM_POWERSET_S8POWER_Pos = 0x8
	// Bit mask of S8POWER field.
	VMC_RAM_POWERSET_S8POWER_Msk = 0x100
	// Bit S8POWER.
	VMC_RAM_POWERSET_S8POWER = 0x100
	// On
	VMC_RAM_POWERSET_S8POWER_On = 0x1
	// Position of S9POWER field.
	VMC_RAM_POWERSET_S9POWER_Pos = 0x9
	// Bit mask of S9POWER field.
	VMC_RAM_POWERSET_S9POWER_Msk = 0x200
	// Bit S9POWER.
	VMC_RAM_POWERSET_S9POWER = 0x200
	// On
	VMC_RAM_POWERSET_S9POWER_On = 0x1
	// Position of S10POWER field.
	VMC_RAM_POWERSET_S10POWER_Pos = 0xa
	// Bit mask of S10POWER field.
	VMC_RAM_POWERSET_S10POWER_Msk = 0x400
	// Bit S10POWER.
	VMC_RAM_POWERSET_S10POWER = 0x400
	// On
	VMC_RAM_POWERSET_S10POWER_On = 0x1
	// Position of S11POWER field.
	VMC_RAM_POWERSET_S11POWER_Pos = 0xb
	// Bit mask of S11POWER field.
	VMC_RAM_POWERSET_S11POWER_Msk = 0x800
	// Bit S11POWER.
	VMC_RAM_POWERSET_S11POWER = 0x800
	// On
	VMC_RAM_POWERSET_S11POWER_On = 0x1
	// Position of S12POWER field.
	VMC_RAM_POWERSET_S12POWER_Pos = 0xc
	// Bit mask of S12POWER field.
	VMC_RAM_POWERSET_S12POWER_Msk = 0x1000
	// Bit S12POWER.
	VMC_RAM_POWERSET_S12POWER = 0x1000
	// On
	VMC_RAM_POWERSET_S12POWER_On = 0x1
	// Position of S13POWER field.
	VMC_RAM_POWERSET_S13POWER_Pos = 0xd
	// Bit mask of S13POWER field.
	VMC_RAM_POWERSET_S13POWER_Msk = 0x2000
	// Bit S13POWER.
	VMC_RAM_POWERSET_S13POWER = 0x2000
	// On
	VMC_RAM_POWERSET_S13POWER_On = 0x1
	// Position of S14POWER field.
	VMC_RAM_POWERSET_S14POWER_Pos = 0xe
	// Bit mask of S14POWER field.
	VMC_RAM_POWERSET_S14POWER_Msk = 0x4000
	// Bit S14POWER.
	VMC_RAM_POWERSET_S14POWER = 0x4000
	// On
	VMC_RAM_POWERSET_S14POWER_On = 0x1
	// Position of S15POWER field.
	VMC_RAM_POWERSET_S15POWER_Pos = 0xf
	// Bit mask of S15POWER field.
	VMC_RAM_POWERSET_S15POWER_Msk = 0x8000
	// Bit S15POWER.
	VMC_RAM_POWERSET_S15POWER = 0x8000
	// On
	VMC_RAM_POWERSET_S15POWER_On = 0x1
	// Position of S0RETENTION field.
	VMC_RAM_POWERSET_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	VMC_RAM_POWERSET_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	VMC_RAM_POWERSET_S0RETENTION = 0x10000
	// On
	VMC_RAM_POWERSET_S0RETENTION_On = 0x1
	// Position of S1RETENTION field.
	VMC_RAM_POWERSET_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	VMC_RAM_POWERSET_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	VMC_RAM_POWERSET_S1RETENTION = 0x20000
	// On
	VMC_RAM_POWERSET_S1RETENTION_On = 0x1
	// Position of S2RETENTION field.
	VMC_RAM_POWERSET_S2RETENTION_Pos = 0x12
	// Bit mask of S2RETENTION field.
	VMC_RAM_POWERSET_S2RETENTION_Msk = 0x40000
	// Bit S2RETENTION.
	VMC_RAM_POWERSET_S2RETENTION = 0x40000
	// On
	VMC_RAM_POWERSET_S2RETENTION_On = 0x1
	// Position of S3RETENTION field.
	VMC_RAM_POWERSET_S3RETENTION_Pos = 0x13
	// Bit mask of S3RETENTION field.
	VMC_RAM_POWERSET_S3RETENTION_Msk = 0x80000
	// Bit S3RETENTION.
	VMC_RAM_POWERSET_S3RETENTION = 0x80000
	// On
	VMC_RAM_POWERSET_S3RETENTION_On = 0x1
	// Position of S4RETENTION field.
	VMC_RAM_POWERSET_S4RETENTION_Pos = 0x14
	// Bit mask of S4RETENTION field.
	VMC_RAM_POWERSET_S4RETENTION_Msk = 0x100000
	// Bit S4RETENTION.
	VMC_RAM_POWERSET_S4RETENTION = 0x100000
	// On
	VMC_RAM_POWERSET_S4RETENTION_On = 0x1
	// Position of S5RETENTION field.
	VMC_RAM_POWERSET_S5RETENTION_Pos = 0x15
	// Bit mask of S5RETENTION field.
	VMC_RAM_POWERSET_S5RETENTION_Msk = 0x200000
	// Bit S5RETENTION.
	VMC_RAM_POWERSET_S5RETENTION = 0x200000
	// On
	VMC_RAM_POWERSET_S5RETENTION_On = 0x1
	// Position of S6RETENTION field.
	VMC_RAM_POWERSET_S6RETENTION_Pos = 0x16
	// Bit mask of S6RETENTION field.
	VMC_RAM_POWERSET_S6RETENTION_Msk = 0x400000
	// Bit S6RETENTION.
	VMC_RAM_POWERSET_S6RETENTION = 0x400000
	// On
	VMC_RAM_POWERSET_S6RETENTION_On = 0x1
	// Position of S7RETENTION field.
	VMC_RAM_POWERSET_S7RETENTION_Pos = 0x17
	// Bit mask of S7RETENTION field.
	VMC_RAM_POWERSET_S7RETENTION_Msk = 0x800000
	// Bit S7RETENTION.
	VMC_RAM_POWERSET_S7RETENTION = 0x800000
	// On
	VMC_RAM_POWERSET_S7RETENTION_On = 0x1
	// Position of S8RETENTION field.
	VMC_RAM_POWERSET_S8RETENTION_Pos = 0x18
	// Bit mask of S8RETENTION field.
	VMC_RAM_POWERSET_S8RETENTION_Msk = 0x1000000
	// Bit S8RETENTION.
	VMC_RAM_POWERSET_S8RETENTION = 0x1000000
	// On
	VMC_RAM_POWERSET_S8RETENTION_On = 0x1
	// Position of S9RETENTION field.
	VMC_RAM_POWERSET_S9RETENTION_Pos = 0x19
	// Bit mask of S9RETENTION field.
	VMC_RAM_POWERSET_S9RETENTION_Msk = 0x2000000
	// Bit S9RETENTION.
	VMC_RAM_POWERSET_S9RETENTION = 0x2000000
	// On
	VMC_RAM_POWERSET_S9RETENTION_On = 0x1
	// Position of S10RETENTION field.
	VMC_RAM_POWERSET_S10RETENTION_Pos = 0x1a
	// Bit mask of S10RETENTION field.
	VMC_RAM_POWERSET_S10RETENTION_Msk = 0x4000000
	// Bit S10RETENTION.
	VMC_RAM_POWERSET_S10RETENTION = 0x4000000
	// On
	VMC_RAM_POWERSET_S10RETENTION_On = 0x1
	// Position of S11RETENTION field.
	VMC_RAM_POWERSET_S11RETENTION_Pos = 0x1b
	// Bit mask of S11RETENTION field.
	VMC_RAM_POWERSET_S11RETENTION_Msk = 0x8000000
	// Bit S11RETENTION.
	VMC_RAM_POWERSET_S11RETENTION = 0x8000000
	// On
	VMC_RAM_POWERSET_S11RETENTION_On = 0x1
	// Position of S12RETENTION field.
	VMC_RAM_POWERSET_S12RETENTION_Pos = 0x1c
	// Bit mask of S12RETENTION field.
	VMC_RAM_POWERSET_S12RETENTION_Msk = 0x10000000
	// Bit S12RETENTION.
	VMC_RAM_POWERSET_S12RETENTION = 0x10000000
	// On
	VMC_RAM_POWERSET_S12RETENTION_On = 0x1
	// Position of S13RETENTION field.
	VMC_RAM_POWERSET_S13RETENTION_Pos = 0x1d
	// Bit mask of S13RETENTION field.
	VMC_RAM_POWERSET_S13RETENTION_Msk = 0x20000000
	// Bit S13RETENTION.
	VMC_RAM_POWERSET_S13RETENTION = 0x20000000
	// On
	VMC_RAM_POWERSET_S13RETENTION_On = 0x1
	// Position of S14RETENTION field.
	VMC_RAM_POWERSET_S14RETENTION_Pos = 0x1e
	// Bit mask of S14RETENTION field.
	VMC_RAM_POWERSET_S14RETENTION_Msk = 0x40000000
	// Bit S14RETENTION.
	VMC_RAM_POWERSET_S14RETENTION = 0x40000000
	// On
	VMC_RAM_POWERSET_S14RETENTION_On = 0x1
	// Position of S15RETENTION field.
	VMC_RAM_POWERSET_S15RETENTION_Pos = 0x1f
	// Bit mask of S15RETENTION field.
	VMC_RAM_POWERSET_S15RETENTION_Msk = 0x80000000
	// Bit S15RETENTION.
	VMC_RAM_POWERSET_S15RETENTION = 0x80000000
	// On
	VMC_RAM_POWERSET_S15RETENTION_On = 0x1

	// RAM.POWERCLR: Description cluster: RAM[n] power control clear register
	// Position of S0POWER field.
	VMC_RAM_POWERCLR_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	VMC_RAM_POWERCLR_S0POWER_Msk = 0x1
	// Bit S0POWER.
	VMC_RAM_POWERCLR_S0POWER = 0x1
	// Off
	VMC_RAM_POWERCLR_S0POWER_Off = 0x1
	// Position of S1POWER field.
	VMC_RAM_POWERCLR_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	VMC_RAM_POWERCLR_S1POWER_Msk = 0x2
	// Bit S1POWER.
	VMC_RAM_POWERCLR_S1POWER = 0x2
	// Off
	VMC_RAM_POWERCLR_S1POWER_Off = 0x1
	// Position of S2POWER field.
	VMC_RAM_POWERCLR_S2POWER_Pos = 0x2
	// Bit mask of S2POWER field.
	VMC_RAM_POWERCLR_S2POWER_Msk = 0x4
	// Bit S2POWER.
	VMC_RAM_POWERCLR_S2POWER = 0x4
	// Off
	VMC_RAM_POWERCLR_S2POWER_Off = 0x1
	// Position of S3POWER field.
	VMC_RAM_POWERCLR_S3POWER_Pos = 0x3
	// Bit mask of S3POWER field.
	VMC_RAM_POWERCLR_S3POWER_Msk = 0x8
	// Bit S3POWER.
	VMC_RAM_POWERCLR_S3POWER = 0x8
	// Off
	VMC_RAM_POWERCLR_S3POWER_Off = 0x1
	// Position of S4POWER field.
	VMC_RAM_POWERCLR_S4POWER_Pos = 0x4
	// Bit mask of S4POWER field.
	VMC_RAM_POWERCLR_S4POWER_Msk = 0x10
	// Bit S4POWER.
	VMC_RAM_POWERCLR_S4POWER = 0x10
	// Off
	VMC_RAM_POWERCLR_S4POWER_Off = 0x1
	// Position of S5POWER field.
	VMC_RAM_POWERCLR_S5POWER_Pos = 0x5
	// Bit mask of S5POWER field.
	VMC_RAM_POWERCLR_S5POWER_Msk = 0x20
	// Bit S5POWER.
	VMC_RAM_POWERCLR_S5POWER = 0x20
	// Off
	VMC_RAM_POWERCLR_S5POWER_Off = 0x1
	// Position of S6POWER field.
	VMC_RAM_POWERCLR_S6POWER_Pos = 0x6
	// Bit mask of S6POWER field.
	VMC_RAM_POWERCLR_S6POWER_Msk = 0x40
	// Bit S6POWER.
	VMC_RAM_POWERCLR_S6POWER = 0x40
	// Off
	VMC_RAM_POWERCLR_S6POWER_Off = 0x1
	// Position of S7POWER field.
	VMC_RAM_POWERCLR_S7POWER_Pos = 0x7
	// Bit mask of S7POWER field.
	VMC_RAM_POWERCLR_S7POWER_Msk = 0x80
	// Bit S7POWER.
	VMC_RAM_POWERCLR_S7POWER = 0x80
	// Off
	VMC_RAM_POWERCLR_S7POWER_Off = 0x1
	// Position of S8POWER field.
	VMC_RAM_POWERCLR_S8POWER_Pos = 0x8
	// Bit mask of S8POWER field.
	VMC_RAM_POWERCLR_S8POWER_Msk = 0x100
	// Bit S8POWER.
	VMC_RAM_POWERCLR_S8POWER = 0x100
	// Off
	VMC_RAM_POWERCLR_S8POWER_Off = 0x1
	// Position of S9POWER field.
	VMC_RAM_POWERCLR_S9POWER_Pos = 0x9
	// Bit mask of S9POWER field.
	VMC_RAM_POWERCLR_S9POWER_Msk = 0x200
	// Bit S9POWER.
	VMC_RAM_POWERCLR_S9POWER = 0x200
	// Off
	VMC_RAM_POWERCLR_S9POWER_Off = 0x1
	// Position of S10POWER field.
	VMC_RAM_POWERCLR_S10POWER_Pos = 0xa
	// Bit mask of S10POWER field.
	VMC_RAM_POWERCLR_S10POWER_Msk = 0x400
	// Bit S10POWER.
	VMC_RAM_POWERCLR_S10POWER = 0x400
	// Off
	VMC_RAM_POWERCLR_S10POWER_Off = 0x1
	// Position of S11POWER field.
	VMC_RAM_POWERCLR_S11POWER_Pos = 0xb
	// Bit mask of S11POWER field.
	VMC_RAM_POWERCLR_S11POWER_Msk = 0x800
	// Bit S11POWER.
	VMC_RAM_POWERCLR_S11POWER = 0x800
	// Off
	VMC_RAM_POWERCLR_S11POWER_Off = 0x1
	// Position of S12POWER field.
	VMC_RAM_POWERCLR_S12POWER_Pos = 0xc
	// Bit mask of S12POWER field.
	VMC_RAM_POWERCLR_S12POWER_Msk = 0x1000
	// Bit S12POWER.
	VMC_RAM_POWERCLR_S12POWER = 0x1000
	// Off
	VMC_RAM_POWERCLR_S12POWER_Off = 0x1
	// Position of S13POWER field.
	VMC_RAM_POWERCLR_S13POWER_Pos = 0xd
	// Bit mask of S13POWER field.
	VMC_RAM_POWERCLR_S13POWER_Msk = 0x2000
	// Bit S13POWER.
	VMC_RAM_POWERCLR_S13POWER = 0x2000
	// Off
	VMC_RAM_POWERCLR_S13POWER_Off = 0x1
	// Position of S14POWER field.
	VMC_RAM_POWERCLR_S14POWER_Pos = 0xe
	// Bit mask of S14POWER field.
	VMC_RAM_POWERCLR_S14POWER_Msk = 0x4000
	// Bit S14POWER.
	VMC_RAM_POWERCLR_S14POWER = 0x4000
	// Off
	VMC_RAM_POWERCLR_S14POWER_Off = 0x1
	// Position of S15POWER field.
	VMC_RAM_POWERCLR_S15POWER_Pos = 0xf
	// Bit mask of S15POWER field.
	VMC_RAM_POWERCLR_S15POWER_Msk = 0x8000
	// Bit S15POWER.
	VMC_RAM_POWERCLR_S15POWER = 0x8000
	// Off
	VMC_RAM_POWERCLR_S15POWER_Off = 0x1
	// Position of S0RETENTION field.
	VMC_RAM_POWERCLR_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	VMC_RAM_POWERCLR_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	VMC_RAM_POWERCLR_S0RETENTION = 0x10000
	// Off
	VMC_RAM_POWERCLR_S0RETENTION_Off = 0x1
	// Position of S1RETENTION field.
	VMC_RAM_POWERCLR_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	VMC_RAM_POWERCLR_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	VMC_RAM_POWERCLR_S1RETENTION = 0x20000
	// Off
	VMC_RAM_POWERCLR_S1RETENTION_Off = 0x1
	// Position of S2RETENTION field.
	VMC_RAM_POWERCLR_S2RETENTION_Pos = 0x12
	// Bit mask of S2RETENTION field.
	VMC_RAM_POWERCLR_S2RETENTION_Msk = 0x40000
	// Bit S2RETENTION.
	VMC_RAM_POWERCLR_S2RETENTION = 0x40000
	// Off
	VMC_RAM_POWERCLR_S2RETENTION_Off = 0x1
	// Position of S3RETENTION field.
	VMC_RAM_POWERCLR_S3RETENTION_Pos = 0x13
	// Bit mask of S3RETENTION field.
	VMC_RAM_POWERCLR_S3RETENTION_Msk = 0x80000
	// Bit S3RETENTION.
	VMC_RAM_POWERCLR_S3RETENTION = 0x80000
	// Off
	VMC_RAM_POWERCLR_S3RETENTION_Off = 0x1
	// Position of S4RETENTION field.
	VMC_RAM_POWERCLR_S4RETENTION_Pos = 0x14
	// Bit mask of S4RETENTION field.
	VMC_RAM_POWERCLR_S4RETENTION_Msk = 0x100000
	// Bit S4RETENTION.
	VMC_RAM_POWERCLR_S4RETENTION = 0x100000
	// Off
	VMC_RAM_POWERCLR_S4RETENTION_Off = 0x1
	// Position of S5RETENTION field.
	VMC_RAM_POWERCLR_S5RETENTION_Pos = 0x15
	// Bit mask of S5RETENTION field.
	VMC_RAM_POWERCLR_S5RETENTION_Msk = 0x200000
	// Bit S5RETENTION.
	VMC_RAM_POWERCLR_S5RETENTION = 0x200000
	// Off
	VMC_RAM_POWERCLR_S5RETENTION_Off = 0x1
	// Position of S6RETENTION field.
	VMC_RAM_POWERCLR_S6RETENTION_Pos = 0x16
	// Bit mask of S6RETENTION field.
	VMC_RAM_POWERCLR_S6RETENTION_Msk = 0x400000
	// Bit S6RETENTION.
	VMC_RAM_POWERCLR_S6RETENTION = 0x400000
	// Off
	VMC_RAM_POWERCLR_S6RETENTION_Off = 0x1
	// Position of S7RETENTION field.
	VMC_RAM_POWERCLR_S7RETENTION_Pos = 0x17
	// Bit mask of S7RETENTION field.
	VMC_RAM_POWERCLR_S7RETENTION_Msk = 0x800000
	// Bit S7RETENTION.
	VMC_RAM_POWERCLR_S7RETENTION = 0x800000
	// Off
	VMC_RAM_POWERCLR_S7RETENTION_Off = 0x1
	// Position of S8RETENTION field.
	VMC_RAM_POWERCLR_S8RETENTION_Pos = 0x18
	// Bit mask of S8RETENTION field.
	VMC_RAM_POWERCLR_S8RETENTION_Msk = 0x1000000
	// Bit S8RETENTION.
	VMC_RAM_POWERCLR_S8RETENTION = 0x1000000
	// Off
	VMC_RAM_POWERCLR_S8RETENTION_Off = 0x1
	// Position of S9RETENTION field.
	VMC_RAM_POWERCLR_S9RETENTION_Pos = 0x19
	// Bit mask of S9RETENTION field.
	VMC_RAM_POWERCLR_S9RETENTION_Msk = 0x2000000
	// Bit S9RETENTION.
	VMC_RAM_POWERCLR_S9RETENTION = 0x2000000
	// Off
	VMC_RAM_POWERCLR_S9RETENTION_Off = 0x1
	// Position of S10RETENTION field.
	VMC_RAM_POWERCLR_S10RETENTION_Pos = 0x1a
	// Bit mask of S10RETENTION field.
	VMC_RAM_POWERCLR_S10RETENTION_Msk = 0x4000000
	// Bit S10RETENTION.
	VMC_RAM_POWERCLR_S10RETENTION = 0x4000000
	// Off
	VMC_RAM_POWERCLR_S10RETENTION_Off = 0x1
	// Position of S11RETENTION field.
	VMC_RAM_POWERCLR_S11RETENTION_Pos = 0x1b
	// Bit mask of S11RETENTION field.
	VMC_RAM_POWERCLR_S11RETENTION_Msk = 0x8000000
	// Bit S11RETENTION.
	VMC_RAM_POWERCLR_S11RETENTION = 0x8000000
	// Off
	VMC_RAM_POWERCLR_S11RETENTION_Off = 0x1
	// Position of S12RETENTION field.
	VMC_RAM_POWERCLR_S12RETENTION_Pos = 0x1c
	// Bit mask of S12RETENTION field.
	VMC_RAM_POWERCLR_S12RETENTION_Msk = 0x10000000
	// Bit S12RETENTION.
	VMC_RAM_POWERCLR_S12RETENTION = 0x10000000
	// Off
	VMC_RAM_POWERCLR_S12RETENTION_Off = 0x1
	// Position of S13RETENTION field.
	VMC_RAM_POWERCLR_S13RETENTION_Pos = 0x1d
	// Bit mask of S13RETENTION field.
	VMC_RAM_POWERCLR_S13RETENTION_Msk = 0x20000000
	// Bit S13RETENTION.
	VMC_RAM_POWERCLR_S13RETENTION = 0x20000000
	// Off
	VMC_RAM_POWERCLR_S13RETENTION_Off = 0x1
	// Position of S14RETENTION field.
	VMC_RAM_POWERCLR_S14RETENTION_Pos = 0x1e
	// Bit mask of S14RETENTION field.
	VMC_RAM_POWERCLR_S14RETENTION_Msk = 0x40000000
	// Bit S14RETENTION.
	VMC_RAM_POWERCLR_S14RETENTION = 0x40000000
	// Off
	VMC_RAM_POWERCLR_S14RETENTION_Off = 0x1
	// Position of S15RETENTION field.
	VMC_RAM_POWERCLR_S15RETENTION_Pos = 0x1f
	// Bit mask of S15RETENTION field.
	VMC_RAM_POWERCLR_S15RETENTION_Msk = 0x80000000
	// Bit S15RETENTION.
	VMC_RAM_POWERCLR_S15RETENTION = 0x80000000
	// Off
	VMC_RAM_POWERCLR_S15RETENTION_Off = 0x1
)
